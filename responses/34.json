{
    "payload": {
        "prompt": "\r\n2024-04-06T01:11:32.987577Z DEBUG cursor_hero_ui_inspector::ui_inspector_plugin: found None\r\n2024-04-06T01:11:33.024901Z TRACE cursor_hero_ui_automation_types::ui_automation_types: Looking in Desktop 1 - DrillId::Root for DrillId::Child(2) (full: DrillId::Child(2))\r\n2024-04-06T01:11:33.025333Z TRACE cursor_hero_ui_automation_types::ui_automation_types: found children Some([\" - DrillId::Child(0)\", \" - DrillId::Child(1)\", \"TH\\u{200b}E\\u{200b}\\u{feff}\\u{feff} \\u{200b}\\u{200b}\\u{200b}\\u{200b}FIN\\u{200b}\\u{feff}\\u{200b}\\u{200b}\\u{200b}\\u{200b}\\u{200b}\\u{200b}\\u{200b}\\u{feff}\\u{200b}\\u{feff}ALS - DrillId::Child(2)\", \"#the-finals | Guh-Uh-Guys - Discord - DrillId::Child(3)\", \"Cursor Hero v0.4.0 - DrillId::Child(4)\", \"3 - Search and 54 more pages - Personal - Microsoft\\u{200b} Edge - DrillId::Child(5)\", \"Eddie - Session terminated. - DrillId::Child(6)\", \"ui_inspector_plugin.rs - Untitled (Workspace) - Visual Studio Code - DrillId::Child(7)\", \"Calculator - DrillId::Child(8)\", \" - DrillId::Child(9)\", \"todo.md - Untitled (Workspace) - Visual Studio Code - DrillId::Child(10)\", \"Command Prompt - DrillId::Child(11)\", \"Spotify Premium - DrillId::Child(12)\", \"Taskbar - DrillId::Child(13)\", \"Program Manager - DrillId::Child(14)\"])\r\n2024-04-06T01:11:33.026018Z DEBUG cursor_hero_ui_inspector::ui_inspector_plugin: found None\r\n2024-04-06T01:11:33.059650Z TRACE cursor_hero_ui_automation_types::ui_automation_types: Looking in Desktop 1 - DrillId::Root for DrillId::Child(2) (full: DrillId::Child(2))\r\n2024-04-06T01:11:33.060112Z TRACE cursor_hero_ui_automation_types::ui_automation_types: found children Some([\" - DrillId::Child(0)\", \" - DrillId::Child(1)\", \"TH\\u{200b}E\\u{200b}\\u{feff}\\u{feff} \\u{200b}\\u{200b}\\u{200b}\\u{200b}FIN\\u{200b}\\u{feff}\\u{200b}\\u{200b}\\u{200b}\\u{200b}\\u{200b}\\u{200b}\\u{200b}\\u{feff}\\u{200b}\\u{feff}ALS - DrillId::Child(2)\", \"#the-finals | Guh-Uh-Guys - Discord - DrillId::Child(3)\", \"Cursor Hero v0.4.0 - DrillId::Child(4)\", \"3 - Search and 54 more pages - Personal - Microsoft\\u{200b} Edge - DrillId::Child(5)\", \"Eddie - Session terminated. - DrillId::Child(6)\", \"ui_inspector_plugin.rs - Untitled (Workspace) - Visual Studio Code - DrillId::Child(7)\", \"Calculator - DrillId::Child(8)\", \" - DrillId::Child(9)\", \"todo.md - Untitled (Workspace) - Visual Studio Code - DrillId::Child(10)\", \"Command Prompt - DrillId::Child(11)\", \"Spotify Premium - DrillId::Child(12)\", \"Taskbar - DrillId::Child(13)\", \"Program Manager - DrillId::Child(14)\"])\r\n2024-04-06T01:11:33.060822Z DEBUG cursor_hero_ui_inspector::ui_inspector_plugin: found None\r\n2024-04-06T01:11:33.090970Z TRACE cursor_hero_ui_automation_types::ui_automation_types: Looking in Desktop 1 - DrillId::Root for DrillId::Child(2) (full: DrillId::Child(2))\r\n2024-04-06T01:11:33.091366Z TRACE cursor_hero_ui_automation_types::ui_automation_types: found children Some([\" - DrillId::Child(0)\", \" - DrillId::Child(1)\", \"TH\\u{200b}E\\u{200b}\\u{feff}\\u{feff} \\u{200b}\\u{200b}\\u{200b}\\u{200b}FIN\\u{200b}\\u{feff}\\u{200b}\\u{200b}\\u{200b}\\u{200b}\\u{200b}\\u{200b}\\u{200b}\\u{feff}\\u{200b}\\u{feff}ALS - DrillId::Child(2)\", \"#the-finals | Guh-Uh-Guys - Discord - DrillId::Child(3)\", \"Cursor Hero v0.4.0 - DrillId::Child(4)\", \"3 - Search and 54 more pages - Personal - Microsoft\\u{200b} Edge - DrillId::Child(5)\", \"Eddie - Session terminated. - DrillId::Child(6)\", \"ui_inspector_plugin.rs - Untitled (Workspace) - Visual Studio Code - DrillId::Child(7)\", \"Calculator - DrillId::Child(8)\", \" - DrillId::Child(9)\", \"todo.md - Untitled (Workspace) - Visual Studio Code - DrillId::Child(10)\", \"Command Prompt - DrillId::Child(11)\", \"Spotify Premium - DrillId::Child(12)\", \"Taskbar - DrillId::Child(13)\", \"Program Manager - DrillId::Child(14)\"])\r\n2024-04-06T01:11:33.092239Z DEBUG cursor_hero_ui_inspector::ui_inspector_plugin: found None\r\n2024-04-06T01:11:33.133234Z TRACE cursor_hero_ui_automation_types::ui_automation_types: Looking in Desktop 1 - DrillId::Root for DrillId::Child(2) (full: DrillId::Child(2))\r\n2024-04-06T01:11:33.133585Z TRACE cursor_hero_ui_automation_types::ui_automation_types: found children Some([\" - DrillId::Child(0)\", \" - DrillId::Child(1)\", \"TH\\u{200b}E\\u{200b}\\u{feff}\\u{feff} \\u{200b}\\u{200b}\\u{200b}\\u{200b}FIN\\u{200b}\\u{feff}\\u{200b}\\u{200b}\\u{200b}\\u{200b}\\u{200b}\\u{200b}\\u{200b}\\u{feff}\\u{200b}\\u{feff}ALS - DrillId::Child(2)\", \"#the-finals | Guh-Uh-Guys - Discord - DrillId::Child(3)\", \"Cursor Hero v0.4.0 - DrillId::Child(4)\", \"3 - Search and 54 more pages - Personal - Microsoft\\u{200b} Edge - DrillId::Child(5)\", \"Eddie - Session terminated. - DrillId::Child(6)\", \"ui_inspector_plugin.rs - Untitled (Workspace) - Visual Studio Code - DrillId::Child(7)\", \"Calculator - DrillId::Child(8)\", \" - DrillId::Child(9)\", \"todo.md - Untitled (Workspace) - Visual Studio Code - DrillId::Child(10)\", \"Command Prompt - DrillId::Child(11)\", \"Spotify Premium - DrillId::Child(12)\", \"Taskbar - DrillId::Child(13)\", \"Program Manager - DrillId::Child(14)\"])\r\n2024-04-06T01:11:33.134368Z DEBUG cursor_hero_ui_inspector::ui_inspector_plugin: found None\r\n2024-04-06T01:11:33.161312Z TRACE cursor_hero_ui_automation_types::ui_automation_types: Looking in Desktop 1 - DrillId::Root for DrillId::Child(2) (full: DrillId::Child(2))\r\n2024-04-06T01:11:33.161755Z TRACE cursor_hero_ui_automation_types::ui_automation_types: found children Some([\" - DrillId::Child(0)\", \" - DrillId::Child(1)\", \"TH\\u{200b}E\\u{200b}\\u{feff}\\u{feff} \\u{200b}\\u{200b}\\u{200b}\\u{200b}FIN\\u{200b}\\u{feff}\\u{200b}\\u{200b}\\u{200b}\\u{200b}\\u{200b}\\u{200b}\\u{200b}\\u{feff}\\u{200b}\\u{feff}ALS - DrillId::Child(2)\", \"#the-finals | Guh-Uh-Guys - Discord - DrillId::Child(3)\", \"Cursor Hero v0.4.0 - DrillId::Child(4)\", \"3 - Search and 54 more pages - Personal - Microsoft\\u{200b} Edge - DrillId::Child(5)\", \"Eddie - Session terminated. - DrillId::Child(6)\", \"ui_inspector_plugin.rs - Untitled (Workspace) - Visual Studio Code - DrillId::Child(7)\", \"Calculator - DrillId::Child(8)\", \" - DrillId::Child(9)\", \"todo.md - Untitled (Workspace) - Visual Studio Code - DrillId::Child(10)\", \"Command Prompt - DrillId::Child(11)\", \"Spotify Premium - DrillId::Child(12)\", \"Taskbar - DrillId::Child(13)\", \"Program Manager - DrillId::Child(14)\"])\r\n2024-04-06T01:11:33.162596Z DEBUG cursor_hero_ui_inspector::ui_inspector_plugin: found None\r\n2024-04-06T01:11:33.267982Z TRACE cursor_hero_ui_automation_types::ui_automation_types: Looking in Desktop 1 - DrillId::Root for DrillId::Child(2) (full: DrillId::Child(2))\r\n2024-04-06T01:11:33.268407Z TRACE cursor_hero_ui_automation_types::ui_automation_types: found children Some([\" - DrillId::Child(0)\", \" - DrillId::Child(1)\", \"TH\\u{200b}E\\u{200b}\\u{feff}\\u{feff} \\u{200b}\\u{200b}\\u{200b}\\u{200b}FIN\\u{200b}\\u{feff}\\u{200b}\\u{200b}\\u{200b}\\u{200b}\\u{200b}\\u{200b}\\u{200b}\\u{feff}\\u{200b}\\u{feff}ALS - DrillId::Child(2)\", \"#the-finals | Guh-Uh-Guys - Discord - DrillId::Child(3)\", \"Cursor Hero v0.4.0 - DrillId::Child(4)\", \"3 - Search and 54 more pages - Personal - Microsoft\\u{200b} Edge - DrillId::Child(5)\", \"Eddie - Session terminated. - DrillId::Child(6)\", \"ui_inspector_plugin.rs - Untitled (Workspace) - Visual Studio Code - DrillId::Child(7)\", \"Calculator - DrillId::Child(8)\", \" - DrillId::Child(9)\", \"todo.md - Untitled (Workspace) - Visual Studio Code - DrillId::Child(10)\", \"Command Prompt - DrillId::Child(11)\", \"Spotify Premium - DrillId::Child(12)\", \"Taskbar - DrillId::Child(13)\", \"Program Manager - DrillId::Child(14)\"])\r\n2024-04-06T01:11:33.269386Z DEBUG cursor_hero_ui_inspector::ui_inspector_plugin: found None\r\nThose are the logs of a problem I'm having.\r\nI have a tree inspector view and an item I am trying to show the properties of.\r\nThe UIData resource has the drill_id of the selected element.\r\nThe tree correctly highlights the selected element.\r\nHovering over an element in the game is meant to select it.\r\n\r\nHere is the source code, please identify why the error is happening.\r\n\r\n# Summary\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\chat\\src\\chat_sfx_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse cursor_hero_character_types::prelude::*;\r\nuse cursor_hero_chat_types::prelude::*;\r\nuse rand::prelude::SliceRandom;\r\npub struct ChatSfxPlugin;\r\n\r\nimpl Plugin for ChatSfxPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Update, play_sound_for_new_chat_messages);\r\n        app.add_systems(Update, play_sound_for_keystrokes);\r\n    }\r\n}\r\nfn play_sound_for_new_chat_messages(\r\n    mut commands: Commands,\r\n    mut events: EventReader<ChatEvent>,\r\n    character_query: Query<&Transform, With<Character>>,\r\n    asset_server: Res<AssetServer>,\r\n) {\r\n    for event in events.read() {\r\n        let ChatEvent::Chat { character_id, .. } = event;\r\n        let Ok(character) = character_query.get(*character_id) else {\r\n            warn!(\"Character not found for event {:?}\", event);\r\n            continue;\r\n        };\r\n        let character_transform = character;\r\n        commands.spawn((\r\n            AudioBundle {\r\n                source: asset_server.load(\"sounds/kenny_bong_001.ogg\"),\r\n                settings: PlaybackSettings::DESPAWN.with_spatial(true),\r\n            },\r\n            SpatialBundle {\r\n                transform: *character_transform,\r\n                ..default()\r\n            },\r\n        ));\r\n    }\r\n}\r\n\r\nfn play_sound_for_keystrokes(\r\n    mut commands: Commands,\r\n    mut events: EventReader<ChatInputEvent>,\r\n    character_query: Query<&Transform, With<Character>>,\r\n    asset_server: Res<AssetServer>,\r\n) {\r\n    for event in events.read() {\r\n        let ChatInputEvent::TextChanged { character_id, .. } = event else {\r\n            continue;\r\n        };\r\n        let Ok(character) = character_query.get(*character_id) else {\r\n            warn!(\"Character not found for event {:?}\", event);\r\n            continue;\r\n        };\r\n        let character_transform = character;\r\n\r\n        // optimization opportunity: avoid unnecessary allocations\r\n        let choices = [\"sounds/kenny_click_002.ogg\", \"sounds/kenny_click_003.ogg\"];\r\n        let Some(choice) = choices.choose(&mut rand::thread_rng()) else {\r\n            continue;\r\n        };\r\n\r\n        commands.spawn((\r\n            AudioBundle {\r\n                source: asset_server.load(*choice),\r\n                settings: PlaybackSettings::DESPAWN.with_spatial(true),\r\n            },\r\n            SpatialBundle {\r\n                transform: *character_transform,\r\n                ..default()\r\n            },\r\n        ));\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\app_types\\src\\app_types_plugin.rs\r\n\r\n````rust\r\nuse crate::prelude::*;\r\nuse bevy::prelude::*;\r\n\r\npub struct AppTypesPlugin;\r\n\r\nimpl Plugin for AppTypesPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<MyComponent>();\r\n        app.add_event::<MyEvent>();\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\cursor_types\\src\\cursor_action_types.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse leafwing_input_manager::prelude::*;\r\nuse leafwing_input_manager::user_input::InputKind;\r\n\r\npub struct CursorActionPlugin;\r\n\r\nimpl Plugin for CursorActionPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_plugins(InputManagerPlugin::<CursorAction>::default());\r\n    }\r\n}\r\n\r\n#[derive(Actionlike, PartialEq, Eq, Clone, Copy, Hash, Debug, Reflect)]\r\npub enum CursorAction {\r\n    Move,\r\n}\r\n\r\nimpl CursorAction {\r\n    fn default_gamepad_binding(&self) -> UserInput {\r\n        match self {\r\n            Self::Move => UserInput::Single(InputKind::DualAxis(DualAxis::right_stick())),\r\n        }\r\n    }\r\n\r\n    fn default_mkb_binding(&self) -> UserInput {\r\n        match self {\r\n            Self::Move => UserInput::VirtualDPad(VirtualDPad::arrow_keys()),\r\n        }\r\n    }\r\n\r\n    pub fn default_input_map() -> InputMap<CursorAction> {\r\n        let mut input_map = InputMap::default();\r\n\r\n        for variant in CursorAction::variants() {\r\n            input_map.insert(variant.default_mkb_binding(), variant);\r\n            input_map.insert(variant.default_gamepad_binding(), variant);\r\n        }\r\n        input_map\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\movement_tool\\src\\movement_tool_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n\r\nuse crate::movement_speed_plugin::MovementSpeedPlugin;\r\nuse crate::movement_sprint_plugin::MovementSprintPlugin;\r\nuse crate::movement_target_plugin::MovementTargetPlugin;\r\nuse crate::movement_tool_populate_plugin::MovementToolPopulatePlugin;\r\nuse crate::movement_tool_tick_plugin::MovementToolTickPlugin;\r\n\r\npub struct MovementToolPlugin;\r\n\r\nimpl Plugin for MovementToolPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_plugins(MovementSpeedPlugin);\r\n        app.add_plugins(MovementSprintPlugin);\r\n        app.add_plugins(MovementToolTickPlugin);\r\n        app.add_plugins(MovementTargetPlugin);\r\n        app.add_plugins(MovementToolPopulatePlugin);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\host_fs_types\\src\\host_fs_types.rs\r\n\r\n````rust\r\nuse std::path::PathBuf;\r\n\r\nuse bevy::prelude::*;\r\n\r\n#[derive(Component, Debug, Reflect, Clone, Eq, PartialEq)]\r\npub struct HostPath {\r\n    pub path: PathBuf,\r\n}\r\n\r\n#[derive(Event, Debug, Reflect)]\r\npub enum HostPathAction {\r\n    OpenWithCode { path: HostPath },\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\inference\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_inference\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\ncursor_hero_inference_types = {workspace = true}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\memory\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_memory\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\ncursor_hero_memory_types = { workspace = true }\r\ncursor_hero_winutils = { workspace = true }\r\ncursor_hero_character_types = { workspace = true }\r\ncursor_hero_camera = { workspace = true }\r\ncursor_hero_toolbelt_types = { workspace = true }\r\ncursor_hero_voice_to_text_types = { workspace = true }\r\ncursor_hero_secret_types = { workspace = true }\r\ncursor_hero_observation_types = { workspace = true }\r\nraw-window-handle = { workspace = true }\r\nserde = { workspace = true, features=[\"derive\"] }\r\nserde_json = { workspace = true }\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\glados_tts\\src\\glados_tts.rs\r\n\r\n````rust\r\nuse cursor_hero_glados_tts_types::glados_tts_types::GladosTtsStatus;\r\nuse reqwest::Client;\r\nuse std::error::Error;\r\nuse std::process::Command;\r\n\r\npub async fn generate(prompt: &str) -> Result<Vec<u8>, Box<dyn Error>> {\r\n    // Construct the URL for the TTS endpoint\r\n    let url = \"http://localhost:8124/synthesize\";\r\n\r\n    // Create an instance of the reqwest client\r\n    let client = Client::new();\r\n\r\n    // Send a GET request to the server\r\n    let response = client.post(url).body(prompt.to_string()).send().await?;\r\n\r\n    // Ensure the request was successful and extract the bytes\r\n    let bytes = response.bytes().await?;\r\n\r\n    let wav = bytes.to_vec();\r\n\r\n    // Ensure the audio decoder won't crash the freaking game\r\n    rodio::Decoder::new(std::io::Cursor::new(wav.clone()))?;\r\n\r\n    Ok(wav)\r\n}\r\n\r\npub async fn get_status() -> Result<GladosTtsStatus, Box<dyn Error>> {\r\n    let client = Client::new();\r\n    match client.get(\"http://localhost:8124/\").send().await {\r\n        Ok(res) => match res.status().is_success() {\r\n            true => Ok(GladosTtsStatus::Alive),\r\n            false => Ok(GladosTtsStatus::Dead),\r\n        },\r\n        Err(_) => Ok(GladosTtsStatus::Dead),\r\n    }\r\n}\r\n\r\npub fn start() -> Result<(), Box<dyn Error>> {\r\n    // wt --window 0 --profile PowerShell -- pwsh -Command \"cd G:\\ml\\glados-tts-upstream && conda activate gladostts && python .\\engine.py\"\r\n    match std::process::Command::new(\"wt\")\r\n        .args([\r\n            \"--window\",\r\n            \"0\",\r\n            \"--profile\",\r\n            \"PowerShell\",\r\n            \"--title\",\r\n            \"GLaDOS TTS\",\r\n            \"--\",\r\n            \"pwsh\",\r\n            \"-Command\",\r\n            \"\\\"cd\",\r\n            \"G:\\\\ml\\\\glados-tts-upstream\",\r\n            \"&&\",\r\n            \"conda\",\r\n            \"activate\",\r\n            \"gladostts\",\r\n            \"&&\",\r\n            \"python\",\r\n            \".\\\\engine.py\\\"\",\r\n        ])\r\n        .spawn()\r\n    {\r\n        Ok(_) => Ok(()),\r\n        Err(e) => Err(Box::new(e)),\r\n    }\r\n}\r\n\r\npub fn start_vscode() -> Result<(), Box<dyn Error>> {\r\n    match Command::new(r\"C:\\Program Files\\Microsoft VS Code\\Code.exe\")\r\n        .args([\"G:\\\\ml\\\\glados-tts-upstream\"])\r\n        .spawn()\r\n    {\r\n        Ok(_) => Ok(()),\r\n        Err(e) => Err(Box::new(e)),\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\math\\src\\lib.rs\r\n\r\n````rust\r\nmod corner;\r\nmod lerp;\r\nmod math_plugin;\r\nmod shuffle;\r\n\r\npub mod prelude {\r\n    pub use crate::corner::*;\r\n    pub use crate::lerp::*;\r\n    pub use crate::math_plugin::*;\r\n    pub use crate::shuffle::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\movement_tool\\src\\movement_speed_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse cursor_hero_character_types::prelude::*;\r\nuse cursor_hero_input::active_input_state_plugin::InputMethod;\r\nuse cursor_hero_movement_tool_types::prelude::*;\r\nuse cursor_hero_toolbelt_types::prelude::*;\r\n\r\npub struct MovementSpeedPlugin;\r\n\r\nimpl Plugin for MovementSpeedPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(OnEnter(InputMethod::MouseAndKeyboard), set_mnk_speed);\r\n        app.add_systems(OnEnter(InputMethod::Gamepad), set_gamepad_speed);\r\n    }\r\n}\r\n\r\nfn set_mnk_speed(\r\n    mut tool_query: Query<(&mut MovementTool, &Parent), With<MovementTool>>,\r\n    toolbelt_query: Query<&Parent, With<Toolbelt>>,\r\n    character_query: Query<(), With<MainCharacter>>,\r\n) {\r\n    for tool in tool_query.iter_mut() {\r\n        let (mut tool, tool_parent) = tool;\r\n        let Ok(toolbelt) = toolbelt_query.get(tool_parent.get()) else {\r\n            continue;\r\n        };\r\n        if character_query.get(toolbelt.get()).is_err() {\r\n            continue;\r\n        }\r\n        *tool = MovementTool {\r\n            target: tool.target,\r\n            ..MovementTool::default_mnk()\r\n        };\r\n    }\r\n}\r\n\r\nfn set_gamepad_speed(\r\n    mut tool_query: Query<(&mut MovementTool, &Parent), With<MovementTool>>,\r\n    toolbelt_query: Query<&Parent, With<Toolbelt>>,\r\n    character_query: Query<(), With<MainCharacter>>,\r\n) {\r\n    for tool in tool_query.iter_mut() {\r\n        let (mut tool, tool_parent) = tool;\r\n        let Ok(toolbelt) = toolbelt_query.get(tool_parent.get()) else {\r\n            continue;\r\n        };\r\n        if character_query.get(toolbelt.get()).is_err() {\r\n            continue;\r\n        }\r\n        *tool = MovementTool {\r\n            target: tool.target,\r\n            ..MovementTool::default_gamepad()\r\n        };\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\memory_types\\src\\lib.rs\r\n\r\n````rust\r\nmod memory_types;\r\nmod memory_types_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::memory_types::*;\r\n    pub use crate::memory_types_plugin::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\cursor_types\\src\\cursor_types_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n\r\nuse crate::prelude::*;\r\n\r\npub struct CursorTypesPlugin;\r\nimpl Plugin for CursorTypesPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<Cursor>();\r\n        app.register_type::<MainCursor>();\r\n        app.configure_sets(Update, CursorSystemSet::Position);\r\n\r\n        app.add_event::<CursorReachEvent>();\r\n\r\n        app.register_type::<Hovered>();\r\n        app.register_type::<Hoverable>();\r\n        app.register_type::<Hovering>();\r\n        app.add_event::<HoverEvent>();\r\n\r\n        app.register_type::<Clickable>();\r\n        app.register_type::<Pressed>();\r\n        app.register_type::<Pressing>();\r\n        app.add_event::<ClickEvent>();\r\n        app.add_event::<ToolClickEvent>();\r\n\r\n        app.register_type::<CursorMirror>();\r\n        app.register_type::<HostCursorPosition>();\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\floaty_nametag_types\\src\\floaty_nametag_types_plugin.rs\r\n\r\n````rust\r\nuse crate::prelude::*;\r\nuse bevy::prelude::*;\r\n\r\npub struct FloatyNametagTypesPlugin;\r\n\r\nimpl Plugin for FloatyNametagTypesPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<FloatyName>();\r\n        app.register_type::<FloatyNametag>();\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\glados_tts\\src\\glados_tts_status_plugin.rs\r\n\r\n````rust\r\nuse std::time::Duration;\r\n\r\nuse bevy::prelude::*;\r\nuse bevy::utils::Instant;\r\nuse cursor_hero_glados_tts_types::prelude::*;\r\n\r\npub struct GladosTtsStatusPlugin;\r\n\r\nimpl Plugin for GladosTtsStatusPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.init_resource::<GladosTtsStatus>();\r\n        app.add_systems(Update, handle_startup_event);\r\n        app.add_systems(Update, periodic_ping);\r\n        app.add_systems(Update, handle_pong);\r\n    }\r\n}\r\n\r\nfn handle_startup_event(\r\n    mut status_events: ParamSet<(\r\n        EventReader<GladosTtsStatusEvent>,\r\n        EventWriter<GladosTtsStatusEvent>,\r\n    )>,\r\n    mut glados_tts_status: ResMut<GladosTtsStatus>,\r\n) {\r\n    let starting = status_events\r\n        .p0()\r\n        .read()\r\n        .any(|event| matches!(event, GladosTtsStatusEvent::Startup));\r\n    if !starting {\r\n        return;\r\n    }\r\n    status_events.p0().clear();\r\n\r\n    *glados_tts_status = GladosTtsStatus::Starting {\r\n        instant: Instant::now(),\r\n        timeout: Duration::from_secs(60),\r\n    };\r\n    let event = GladosTtsStatusEvent::Changed {\r\n        new_value: *glados_tts_status,\r\n    };\r\n    debug!(\"Sending event {:?}\", event);\r\n    status_events.p1().send(event);\r\n}\r\n\r\nfn periodic_ping(\r\n    mut ping_events: EventWriter<GladosTtsPingEvent>,\r\n    mut last_ping: Local<Option<Instant>>,\r\n) {\r\n    if let Some(instant) = *last_ping {\r\n        if instant.elapsed().as_secs() > 5 {\r\n            ping_events.send(GladosTtsPingEvent::Ping);\r\n            *last_ping = Some(Instant::now());\r\n        }\r\n    } else {\r\n        ping_events.send(GladosTtsPingEvent::Ping);\r\n        *last_ping = Some(Instant::now());\r\n    }\r\n}\r\n\r\nfn handle_pong(\r\n    mut ping_events: EventReader<GladosTtsPingEvent>,\r\n    mut status_events: EventWriter<GladosTtsStatusEvent>,\r\n    mut glados_tts_status: ResMut<GladosTtsStatus>,\r\n) {\r\n    for event in ping_events.read() {\r\n        let GladosTtsPingEvent::Pong { status } = event else {\r\n            continue;\r\n        };\r\n        // identify the new state based on the pong\r\n        let new_status = match (*glados_tts_status, *status) {\r\n            // if starting, only change to dead if the timeout has been exceeded\r\n            (GladosTtsStatus::Starting { instant, timeout }, status) => {\r\n                if status == GladosTtsStatus::Alive {\r\n                    GladosTtsStatus::Alive\r\n                } else if instant.elapsed() > timeout {\r\n                    GladosTtsStatus::Dead\r\n                } else {\r\n                    GladosTtsStatus::Starting { instant, timeout }\r\n                }\r\n            }\r\n            // respect the new status if it's not starting\r\n            _ => *status,\r\n        };\r\n\r\n        if *glados_tts_status != new_status {\r\n            *glados_tts_status = new_status;\r\n            let event = GladosTtsStatusEvent::Changed {\r\n                new_value: new_status,\r\n            };\r\n            debug!(\"Sending event {:?}\", event);\r\n            status_events.send(event);\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\character\\src\\lib.rs\r\n\r\n````rust\r\npub mod character_appearance_plugin;\r\npub mod character_plugin;\r\npub mod character_spawning_plugin;\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\calculator_app\\src\\lib.rs\r\n\r\n````rust\r\npub mod calculator_app_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::calculator_app_plugin::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\input\\src\\lib.rs\r\n\r\n````rust\r\npub mod active_input_state_plugin;\r\npub mod input_plugin;\r\npub mod update_gamepad_settings;\r\n\r\npub use input_plugin::InputPlugin;\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\observation\\src\\observation_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n\r\nuse crate::observation_buffer_plugin::ObservationBufferPlugin;\r\nuse crate::observation_log_plugin::ObservationLogPlugin;\r\nuse crate::observation_tool_plugin::ObservationToolPlugin;\r\nuse crate::observe_chat_plugin::ObserveChatPlugin;\r\n\r\npub struct ObservationPlugin;\r\n\r\nimpl Plugin for ObservationPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_plugins(ObservationLogPlugin);\r\n        app.add_plugins(ObservationToolPlugin);\r\n        app.add_plugins(ObservationBufferPlugin);\r\n        app.add_plugins(ObserveChatPlugin);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\fullscreen_tool\\src\\fullscreen_tool_plugin.rs\r\n\r\n````rust\r\nuse crate::fullscreen_tool_populate_plugin::FullscreenToolPopulatePlugin;\r\nuse crate::fullscreen_tool_tick_plugin::FullscreenToolTickPlugin;\r\nuse bevy::prelude::*;\r\n\r\npub struct FullscreenToolPlugin;\r\n\r\nimpl Plugin for FullscreenToolPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_plugins(FullscreenToolPopulatePlugin);\r\n        app.add_plugins(FullscreenToolTickPlugin);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\inference_types\\src\\prompt_types.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse cursor_hero_text_asset_types::text_asset_loader_types::TextAsset;\r\n\r\nuse crate::prelude::TextInferenceOptions;\r\n\r\n#[derive(Reflect, Debug, PartialEq, Eq, Clone)]\r\npub enum TextPrompt {\r\n    Raw {\r\n        content: String,\r\n        options: Option<TextInferenceOptions>,\r\n    },\r\n    Chat {\r\n        chat_history: String,\r\n        options: Option<TextInferenceOptions>,\r\n    },\r\n}\r\n\r\nimpl TextPrompt {\r\n    pub fn options(&self) -> Option<TextInferenceOptions> {\r\n        match self {\r\n            TextPrompt::Raw { options, .. } => options.clone(),\r\n            TextPrompt::Chat { options, .. } => options.clone(),\r\n        }\r\n    }\r\n}\r\n\r\n#[derive(Reflect, Debug, PartialEq, Eq, Clone)]\r\npub struct MaterializedTextPrompt {\r\n    pub prompt: TextPrompt,\r\n    pub materialized: String,\r\n}\r\n\r\n#[derive(Resource, Debug, Default, Reflect, PartialEq, Eq, Clone)]\r\n#[reflect(Resource)]\r\npub struct TextPromptHandles {\r\n    pub raw: Handle<TextAsset>,\r\n    pub chat: Handle<TextAsset>,\r\n}\r\n\r\n#[derive(Reflect, Debug, PartialEq, Eq, Clone)]\r\npub enum SpeechPrompt {\r\n    Raw { content: String },\r\n}\r\n\r\n#[derive(Reflect, Debug, PartialEq, Eq, Clone)]\r\npub enum TranscriptionPrompt {\r\n    Raw { content: Vec<u8> },\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\host_fs_types\\src\\host_fs_types_plugin.rs\r\n\r\n````rust\r\nuse crate::prelude::*;\r\nuse bevy::prelude::*;\r\n\r\npub struct HostFsTypesPlugin;\r\n\r\nimpl Plugin for HostFsTypesPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<HostPath>();\r\n        app.add_event::<HostPathAction>();\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\agent\\src\\agent_movement_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse bevy_xpbd_2d::components::AngularVelocity;\r\nuse bevy_xpbd_2d::components::Rotation;\r\nuse cursor_hero_agent_types::prelude::*;\r\nuse cursor_hero_character_types::prelude::*;\r\nuse cursor_hero_movement_tool_types::prelude::*;\r\nuse cursor_hero_toolbelt_types::prelude::*;\r\nuse leafwing_input_manager::axislike::DualAxisData;\r\nuse leafwing_input_manager::prelude::*;\r\n\r\npub struct AgentMovementPlugin;\r\n\r\nimpl Plugin for AgentMovementPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Update, agent_tool_movement);\r\n        app.add_systems(Update, keep_upright);\r\n    }\r\n}\r\n\r\n#[allow(clippy::type_complexity)]\r\nfn agent_tool_movement(\r\n    character_query: Query<(&Children, &Transform), (With<Character>, With<Agent>)>,\r\n    toolbelt_query: Query<&Children, With<Toolbelt>>,\r\n    mut tool_query: Query<&mut ActionState<MovementToolAction>>,\r\n    time: Res<Time>,\r\n) {\r\n    for character in character_query.iter() {\r\n        let (character_children, character_transform) = character;\r\n        for character_child_id in character_children.iter() {\r\n            let Ok(toolbelt) = toolbelt_query.get(*character_child_id) else {\r\n                continue;\r\n            };\r\n            let toolbelt_children = toolbelt;\r\n            for tool in toolbelt_children.iter() {\r\n                let Ok(mut tool) = tool_query.get_mut(*tool) else {\r\n                    continue;\r\n                };\r\n                let data = tool.action_data_mut(MovementToolAction::Move);\r\n                let center = Vec2::new(1920.0, -1080.0) / 2.0;\r\n                // walk in a circle around the center\r\n                let desired_position = center + Vec2::from_angle(time.elapsed_seconds()) * 100.0;\r\n                let direction = desired_position - character_transform.translation.xy();\r\n                data.axis_pair = Some(DualAxisData::from_xy(direction.clamp_length_max(1.0)));\r\n                tool.press(MovementToolAction::Move);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n#[allow(clippy::type_complexity)]\r\nfn keep_upright(\r\n    mut character_query: Query<(&Rotation, &mut AngularVelocity), (With<Character>, With<Agent>)>,\r\n) {\r\n    for (rotation, mut angular_velocity) in character_query.iter_mut() {\r\n        *angular_velocity = AngularVelocity(rotation.sin() * -1.0);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\chat_types\\src\\chat_types.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse bevy::utils::HashSet;\r\nuse cursor_hero_toolbelt_types::prelude::*;\r\nuse leafwing_input_manager::prelude::*;\r\n\r\n#[derive(Component, Debug, Reflect, Default)]\r\npub struct ChatTool {\r\n    pub focused: bool,\r\n    pub buffer: String,\r\n    pub tools_disabled_during_focus: HashSet<Entity>,\r\n    pub state: ChatToolState,\r\n}\r\n\r\n#[derive(PartialEq, Reflect, Debug, Default, Clone)]\r\npub enum ChatToolState {\r\n    #[default]\r\n    Idle,\r\n    InitialRepeatDelay(Timer),\r\n    RepeatDelay(Timer),\r\n}\r\n\r\n#[derive(Component, Reflect, Default)]\r\npub struct ChatWheelTool;\r\n\r\n#[derive(Actionlike, PartialEq, Eq, Clone, Copy, Hash, Debug, Reflect)]\r\npub enum ChatToolAction {\r\n    Focus,\r\n    Unfocus,\r\n    Submit,\r\n    WordModifier,\r\n    Backspace,\r\n}\r\n\r\nimpl ChatToolAction {\r\n    fn default_gamepad_binding(&self) -> UserInput {\r\n        match self {\r\n            Self::Focus => GamepadButtonType::North.into(),\r\n            Self::Unfocus => GamepadButtonType::East.into(),\r\n            Self::Submit => GamepadButtonType::South.into(),\r\n            Self::WordModifier => GamepadButtonType::LeftTrigger.into(),\r\n            Self::Backspace => GamepadButtonType::West.into(),\r\n        }\r\n    }\r\n\r\n    fn default_mkb_binding(&self) -> UserInput {\r\n        match self {\r\n            Self::Focus => KeyCode::Return.into(),\r\n            Self::Unfocus => KeyCode::Escape.into(),\r\n            Self::Submit => KeyCode::Return.into(),\r\n            Self::WordModifier => KeyCode::ControlLeft.into(),\r\n            Self::Backspace => KeyCode::Back.into(),\r\n        }\r\n    }\r\n}\r\nimpl ToolAction for ChatToolAction {\r\n    fn default_input_map(_event: &ToolbeltPopulateEvent) -> Option<InputMap<ChatToolAction>> {\r\n        let mut input_map = InputMap::default();\r\n\r\n        for variant in ChatToolAction::variants() {\r\n            input_map.insert(variant.default_mkb_binding(), variant);\r\n            input_map.insert(variant.default_gamepad_binding(), variant);\r\n        }\r\n        Some(input_map)\r\n    }\r\n}\r\n\r\n#[derive(Event, PartialEq, Eq, Clone, Hash, Debug, Reflect)]\r\npub enum ChatEvent {\r\n    Chat {\r\n        character_id: Entity,\r\n        message: String,\r\n    },\r\n}\r\n\r\n#[derive(Event, PartialEq, Eq, Clone, Hash, Debug, Reflect)]\r\npub enum ChatInputEvent {\r\n    Focus {\r\n        tool_id: Entity,\r\n        toolbelt_id: Entity,\r\n        character_id: Entity,\r\n    },\r\n    Unfocus {\r\n        tool_id: Entity,\r\n        toolbelt_id: Entity,\r\n        character_id: Entity,\r\n    },\r\n    TextChanged {\r\n        character_id: Entity,\r\n        toolbelt_id: Entity,\r\n        tool_id: Entity,\r\n    },\r\n}\r\n\r\n#[derive(Component, Reflect, Debug, Default)]\r\npub struct ChatInput;\r\n\r\n#[derive(Component, Reflect, Debug, Default)]\r\npub struct ChatBubble {\r\n    pub lifetime: Timer,\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\calculator_app\\src\\calculator_app_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n\r\npub struct CalculatorAppPlugin;\r\n\r\nimpl Plugin for CalculatorAppPlugin {\r\n    fn build(&self, _app: &mut App) {}\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\chat\\src\\chat_bubble_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse bevy::text::Text2dBounds;\r\nuse bevy_xpbd_2d::prelude::*;\r\nuse cursor_hero_character_types::prelude::*;\r\nuse cursor_hero_chat_types::prelude::*;\r\npub struct ChatBubblePlugin;\r\n\r\nimpl Plugin for ChatBubblePlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Update, handle_chat_input_events);\r\n        app.add_systems(Update, handle_chat_events);\r\n        app.add_systems(Update, chat_bubble_lifetime);\r\n    }\r\n}\r\nfn handle_chat_input_events(\r\n    mut commands: Commands,\r\n    tool_query: Query<&mut ChatTool>,\r\n    character_query: Query<&Children, With<Character>>,\r\n    chat_input_query: Query<&Children, With<ChatInput>>,\r\n    mut text_query: Query<&mut Text>,\r\n    mut chat_input_events: EventReader<ChatInputEvent>,\r\n) {\r\n    for event in chat_input_events.read() {\r\n        match event {\r\n            ChatInputEvent::Focus {\r\n                character_id,\r\n                tool_id,\r\n                ..\r\n            } => {\r\n                if let Ok(character_children) = character_query.get(*character_id) {\r\n                    for child in character_children.iter() {\r\n                        if chat_input_query.get(*child).is_ok() {\r\n                            warn!(\"Chat input entity already exists?\");\r\n                            continue;\r\n                        }\r\n                    }\r\n                }\r\n                let starting_text = match tool_query.get(*tool_id) {\r\n                    Ok(tool) => tool.buffer.clone(),\r\n                    Err(_) => {\r\n                        warn!(\r\n                            \"Chat tool {:?} not found? Skipping chat bubble creation.\",\r\n                            tool_id\r\n                        );\r\n                        continue;\r\n                    }\r\n                };\r\n                debug!(\r\n                    \"Creating chat input entity for character {:?}\",\r\n                    character_id\r\n                );\r\n                commands.entity(*character_id).with_children(|parent| {\r\n                    let size = Vec2::new(300.0, 100.0);\r\n                    let resolution = 3.0;\r\n                    let padding = Vec2::new(10.0, 10.0);\r\n                    parent\r\n                        .spawn((\r\n                            SpriteBundle {\r\n                                sprite: Sprite {\r\n                                    color: Color::ALICE_BLUE,\r\n                                    custom_size: Some(size),\r\n                                    ..default()\r\n                                },\r\n                                transform: Transform::from_translation(Vec3::new(0.0, 100.0, -1.0)),\r\n                                ..default()\r\n                            },\r\n                            ChatInput,\r\n                            Name::new(\"Chat Input Bubble\"),\r\n                        ))\r\n                        .with_children(|parent| {\r\n                            parent.spawn((Text2dBundle {\r\n                                text: Text::from_section(\r\n                                    starting_text,\r\n                                    TextStyle {\r\n                                        font_size: 20.0 * resolution,\r\n                                        color: Color::MIDNIGHT_BLUE,\r\n                                        ..default()\r\n                                    },\r\n                                ),\r\n                                text_2d_bounds: Text2dBounds {\r\n                                    size: size * resolution - padding,\r\n                                },\r\n                                transform: Transform::from_translation(Vec3::new(0.0, 0.0, 1.0))\r\n                                    .with_scale(Vec3::new(1.0 / resolution, 1.0 / resolution, 1.0)),\r\n                                ..default()\r\n                            },));\r\n                        });\r\n                });\r\n            }\r\n            ChatInputEvent::Unfocus { character_id, .. } => {\r\n                debug!(\r\n                    \"Removing chat input entity for character {:?}\",\r\n                    character_id\r\n                );\r\n                if let Ok(character_children) = character_query.get(*character_id) {\r\n                    for child in character_children.iter() {\r\n                        if chat_input_query.get(*child).is_ok() {\r\n                            commands.entity(*child).despawn_recursive();\r\n                            commands.entity(*character_id).remove_children(&[*child]);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            ChatInputEvent::TextChanged {\r\n                character_id,\r\n                tool_id,\r\n                ..\r\n            } => {\r\n                let new_text = match tool_query.get(*tool_id) {\r\n                    Ok(tool) => tool.buffer.clone(),\r\n                    Err(_) => {\r\n                        warn!(\r\n                            \"Chat tool {:?} not found? Skipping chat bubble update.\",\r\n                            tool_id\r\n                        );\r\n                        continue;\r\n                    }\r\n                };\r\n                debug!(\r\n                    \"Updating chat input entity for character {:?}\",\r\n                    character_id\r\n                );\r\n                if let Ok(character_children) = character_query.get(*character_id) {\r\n                    for child in character_children.iter() {\r\n                        if let Ok(chat_input) = chat_input_query.get(*child) {\r\n                            let chat_input_children = chat_input;\r\n                            for child in chat_input_children.iter() {\r\n                                if let Ok(mut text) = text_query.get_mut(*child) {\r\n                                    text.sections[0].value = new_text.clone();\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                } else {\r\n                    warn!(\r\n                        \"Character {:?} not found? Skipping chat bubble update.\",\r\n                        character_id\r\n                    );\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfn handle_chat_events(\r\n    mut events: EventReader<ChatEvent>,\r\n    mut commands: Commands,\r\n    character_query: Query<&GlobalTransform, With<Character>>,\r\n) {\r\n    for event in events.read() {\r\n        match event {\r\n            ChatEvent::Chat {\r\n                character_id,\r\n                message,\r\n            } => {\r\n                if let Ok(character) = character_query.get(*character_id) {\r\n                    let character_transform = character;\r\n                    info!(\r\n                        \"Creating chat bubble for character {:?} at position {:?}\",\r\n                        character_id,\r\n                        character_transform.translation()\r\n                    );\r\n                    let size = Vec2::new(300.0, 100.0);\r\n                    let resolution = 3.0;\r\n                    let padding = Vec2::new(10.0, 10.0);\r\n                    let mut transform = character_transform.compute_transform();\r\n                    transform.translation -= Vec3::new(0.0, 100.0, 10.0);\r\n                    commands\r\n                        .spawn((\r\n                            SpriteBundle {\r\n                                sprite: Sprite {\r\n                                    color: Color::BLACK,\r\n                                    custom_size: Some(size),\r\n                                    ..default()\r\n                                },\r\n                                transform,\r\n                                ..default()\r\n                            },\r\n                            ChatBubble {\r\n                                lifetime: Timer::from_seconds(25.0, TimerMode::Once),\r\n                            },\r\n                            RigidBody::Dynamic,\r\n                            LinearVelocity(Vec2::new(0.0, -30.0)),\r\n                            Collider::cuboid(size.x, size.y),\r\n                            Name::new(\"Chat Bubble\"),\r\n                        ))\r\n                        .with_children(|parent| {\r\n                            parent.spawn((Text2dBundle {\r\n                                text: Text::from_section(\r\n                                    message.clone(),\r\n                                    TextStyle {\r\n                                        font_size: 20.0 * resolution,\r\n                                        color: Color::WHITE,\r\n                                        ..default()\r\n                                    },\r\n                                ),\r\n                                text_2d_bounds: Text2dBounds {\r\n                                    size: size * resolution - padding,\r\n                                },\r\n                                transform: Transform::from_translation(Vec3::new(0.0, 0.0, 1.0))\r\n                                    .with_scale(Vec3::new(1.0 / resolution, 1.0 / resolution, 1.0)),\r\n                                ..default()\r\n                            },));\r\n                        });\r\n                } else {\r\n                    warn!(\r\n                        \"Character {:?} not found? Skipping chat bubble creation.\",\r\n                        character_id\r\n                    );\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfn chat_bubble_lifetime(\r\n    mut commands: Commands,\r\n    time: Res<Time>,\r\n    mut query: Query<(Entity, &mut ChatBubble)>,\r\n) {\r\n    for (entity, mut chat_bubble) in query.iter_mut() {\r\n        chat_bubble.lifetime.tick(time.delta());\r\n        if chat_bubble.lifetime.finished() {\r\n            commands.entity(entity).despawn_recursive();\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\fullscreen_tool_types\\src\\lib.rs\r\n\r\n````rust\r\npub mod fullscreen_tool_types;\r\npub mod fullscreen_tool_types_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::fullscreen_tool_types::*;\r\n    pub use crate::fullscreen_tool_types_plugin::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\observation\\src\\observe_chat_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse cursor_hero_character_types::prelude::*;\r\nuse cursor_hero_chat_types::prelude::*;\r\nuse cursor_hero_environment_types::environment_types::EnvironmentTracker;\r\nuse cursor_hero_observation_types::prelude::*;\r\npub struct ObserveChatPlugin;\r\n\r\nimpl Plugin for ObserveChatPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Update, observe_chat);\r\n    }\r\n}\r\n\r\nfn observe_chat(\r\n    mut chat_events: EventReader<ChatEvent>,\r\n    mut observation_events: EventWriter<SomethingObservableHappenedEvent>,\r\n    character_query: Query<(Option<&Name>, Option<&EnvironmentTracker>), With<Character>>,\r\n) {\r\n    for event in chat_events.read() {\r\n        let ChatEvent::Chat {\r\n            character_id,\r\n            message,\r\n        } = event;\r\n        let Ok(character) = character_query.get(*character_id) else {\r\n            warn!(\r\n                \"Chat event for unknown character? character_id {:?}\",\r\n                character_id\r\n            );\r\n            continue;\r\n        };\r\n        let (character_name, character_environment_tag) = character;\r\n\r\n        let Some(character_name) = character_name else {\r\n            warn!(\r\n                \"Chat event for character with no name? character_id {:?}\",\r\n                character_id\r\n            );\r\n            continue;\r\n        };\r\n\r\n        let environment_id = character_environment_tag.map(|tag| tag.environment_id);\r\n\r\n        let event = SomethingObservableHappenedEvent::Chat {\r\n            environment_id,\r\n            character_id: *character_id,\r\n            character_name: character_name.to_string(),\r\n            message: message.clone(),\r\n        };\r\n        debug!(\"Sending event: {:?}\", event);\r\n        observation_events.send(event);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\environment\\src\\lib.rs\r\n\r\n````rust\r\npub mod environment_plugin;\r\npub mod environment_tracker_plugin;\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\host_event_types\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_host_event_types\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\inference\\src\\prompt_asset_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse cursor_hero_inference_types::prelude::*;\r\n\r\npub struct PromptAssetPlugin;\r\n\r\nimpl Plugin for PromptAssetPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.init_resource::<TextPromptHandles>();\r\n        app.add_systems(Startup, load_prompt_assets);\r\n    }\r\n}\r\n\r\nfn load_prompt_assets(mut commands: Commands, asset_server: Res<AssetServer>) {\r\n    commands.insert_resource(TextPromptHandles {\r\n        raw: asset_server.load(\"prompt_templates/raw.txt\"),\r\n        chat: asset_server.load(\"prompt_templates/chat.txt\"),\r\n    });\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\camera\\src\\lib.rs\r\n\r\n````rust\r\n#![feature(let_chains)]\r\npub mod camera_plugin;\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\host_event\\src\\host_event_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n\r\nuse crossbeam_channel::Receiver;\r\nuse cursor_hero_host_event_types::prelude::HostEvent;\r\nuse cursor_hero_winutils::win_events::create_os_event_listener;\r\nuse cursor_hero_winutils::win_events::ProcMessage;\r\n\r\npub struct HostEventPlugin;\r\n\r\nimpl Plugin for HostEventPlugin {\r\n    #![allow(unused_variables)]\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Startup, start_worker);\r\n        app.add_systems(Update, process_events);\r\n    }\r\n}\r\n\r\n#[derive(Resource)]\r\nstruct EventBridge {\r\n    receiver: Receiver<ProcMessage>,\r\n}\r\n\r\nfn start_worker(mut commands: Commands) {\r\n    info!(\"Starting worker thread\");\r\n    let Ok(rx) = create_os_event_listener() else {\r\n        error!(\"Failed to create OS event listener\");\r\n        return;\r\n    };\r\n    commands.insert_resource(EventBridge { receiver: rx });\r\n}\r\n\r\nfn process_events(bridge: ResMut<EventBridge>, mut host_events: EventWriter<HostEvent>) {\r\n    for event in bridge.receiver.try_iter() {\r\n        if let ProcMessage::MouseMoved { .. } = event {\r\n            host_events.send(HostEvent::MousePhysicallyMoved);\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\data\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_data\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\cursor\\src\\cursor_hover_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse bevy_xpbd_2d::components::CollidingEntities;\r\nuse cursor_hero_cursor_types::prelude::*;\r\n\r\npub struct CursorHoverPlugin;\r\n\r\nimpl Plugin for CursorHoverPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Update, hover_detection);\r\n    }\r\n}\r\n\r\n#[allow(clippy::type_complexity)]\r\npub fn hover_detection(\r\n    mut commands: Commands,\r\n    mut cursor_query: Query<(Entity, &CollidingEntities, Option<&mut Hovering>), With<Cursor>>,\r\n    target_query: Query<(Entity, &Visibility, Option<&Hovered>), With<Hoverable>>,\r\n    mut events: EventWriter<HoverEvent>,\r\n) {\r\n    for (cursor_id, cursor_touching, cursor_hovering) in cursor_query.iter_mut() {\r\n        // find out what the cursor is touching\r\n        let mut still_touching = vec![];\r\n        for touching_id in cursor_touching.iter() {\r\n            let Ok((target_id, target_visible, target_hovered)) = target_query.get(*touching_id)\r\n            else {\r\n                continue;\r\n            };\r\n            if target_visible == Visibility::Hidden {\r\n                continue;\r\n            }\r\n            if target_hovered.is_none() {\r\n                commands.entity(target_id).insert(Hovered);\r\n                debug!(\"HoverStart: {:?}\", target_id);\r\n                events.send(HoverEvent::Start {\r\n                    target_id,\r\n                    cursor_id,\r\n                });\r\n            }\r\n            still_touching.push(target_id);\r\n        }\r\n        // update the cursor tracker\r\n        match cursor_hovering {\r\n            Some(mut cursor_hovering) => {\r\n                for entry in cursor_hovering.hovering.iter() {\r\n                    if !still_touching.contains(entry) {\r\n                        if let Some(mut target_commands) = commands.get_entity(*entry) {\r\n                            target_commands.remove::<Hovered>();\r\n                            debug!(\"HoverEnd: {:?}\", entry);\r\n                            events.send(HoverEvent::End {\r\n                                target_id: *entry,\r\n                                cursor_id,\r\n                            });\r\n                        }\r\n                    }\r\n                }\r\n                if still_touching.is_empty() {\r\n                    commands.entity(cursor_id).remove::<Hovering>();\r\n                } else {\r\n                    cursor_hovering.hovering = still_touching;\r\n                }\r\n            }\r\n            None => {\r\n                if !still_touching.is_empty() {\r\n                    commands.entity(cursor_id).insert(Hovering {\r\n                        hovering: still_touching,\r\n                    });\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\cursor\\src\\cursor_click_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse bevy::utils::HashMap;\r\nuse bevy::utils::HashSet;\r\nuse bevy_xpbd_2d::components::CollidingEntities;\r\nuse cursor_hero_cursor_types::prelude::*;\r\n\r\npub struct CursorClickPlugin;\r\n\r\nimpl Plugin for CursorClickPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Update, press_detection);\r\n        app.add_systems(Update, release_detection);\r\n    }\r\n}\r\n\r\n#[allow(clippy::type_complexity)]\r\npub fn press_detection(\r\n    mut commands: Commands,\r\n    mut tool_click_events: EventReader<ToolClickEvent>,\r\n    mut click_events: EventWriter<ClickEvent>,\r\n    mut cursor_query: Query<(&CollidingEntities, Option<&mut Pressing>), With<Cursor>>,\r\n    mut target_query: Query<(Entity, &Visibility, Option<&mut Pressed>), With<Clickable>>,\r\n) {\r\n    let mut cursor_target_ways: Vec<(Entity, Entity, Way)> = vec![];\r\n    let mut target_cursor_ways: Vec<(Entity, Entity, Way)> = vec![];\r\n    for tool_click_event in tool_click_events.read() {\r\n        // only check pressed events\r\n        let ToolClickEvent::Pressed { cursor_id, way } = tool_click_event else {\r\n            continue;\r\n        };\r\n\r\n        // find the cursor for the event\r\n        let Ok((cursor_touching, cursor_pressing)) = cursor_query.get_mut(*cursor_id) else {\r\n            warn!(\"Cursor {:?} not found\", cursor_id);\r\n            continue;\r\n        };\r\n\r\n        let mut pressed = vec![];\r\n\r\n        // for each element the cursor is touching\r\n        for touching_id in cursor_touching.iter() {\r\n            // debug!(\"Cursor {:?} touching {:?}\", cursor_id, touching_id);\r\n            // ensure it is a clickable element\r\n            let Ok((target_id, target_visible, target_pressed)) =\r\n                target_query.get_mut(*touching_id)\r\n            else {\r\n                // debug!(\"Target {:?} not valid\", touching_id);\r\n                continue;\r\n            };\r\n            // ensure the element is visible\r\n            if target_visible == Visibility::Hidden {\r\n                continue;\r\n            }\r\n\r\n            // track in the element what is pressing it\r\n            if target_pressed.is_none() {\r\n                // nothing is pressing this element yet\r\n                target_cursor_ways.push((*touching_id, *cursor_id, *way));\r\n            } else if let Some(mut target_pressed) = target_pressed {\r\n                // something is already pressing this element\r\n                if target_pressed\r\n                    .presses\r\n                    .iter()\r\n                    .any(|press| press.cursor_id == *cursor_id && press.way == *way)\r\n                {\r\n                    warn!(\"Cursor {:?} already pressing {:?}\", cursor_id, target_id);\r\n                } else {\r\n                    target_pressed.presses.push(CursorPress {\r\n                        cursor_id: *cursor_id,\r\n                        way: *way,\r\n                    });\r\n                }\r\n            }\r\n\r\n            // send pressed event\r\n            click_events.send(ClickEvent::Pressed {\r\n                target_id,\r\n                cursor_id: *cursor_id,\r\n                way: *way,\r\n            });\r\n\r\n            pressed.push(target_id);\r\n        }\r\n\r\n        match cursor_pressing {\r\n            Some(mut cursor_pressing) => {\r\n                for target_id in pressed.into_iter() {\r\n                    if cursor_pressing\r\n                        .pressing\r\n                        .iter()\r\n                        .any(|p| p.target_id == target_id && p.way == *way)\r\n                    {\r\n                        warn!(\"Cursor {:?} already pressing {:?}\", cursor_id, target_id);\r\n                    } else {\r\n                        cursor_pressing.pressing.push(TargetPress {\r\n                            target_id,\r\n                            way: *way,\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n            None => {\r\n                for target_id in pressed.into_iter() {\r\n                    cursor_target_ways.push((*cursor_id, target_id, *way));\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // We have deferred the insertion of the Pressed and Pressing components\r\n    // This is because doing it in the event loop causes clobbering when simultaneous events occur\r\n    let cursor_target_ways = group_by_entity(cursor_target_ways);\r\n    for (cursor_id, target_presses) in cursor_target_ways {\r\n        commands.entity(cursor_id).insert(Pressing {\r\n            pressing: target_presses\r\n                .into_iter()\r\n                .map(|(target_id, way)| TargetPress { target_id, way })\r\n                .collect(),\r\n        });\r\n    }\r\n    let target_cursor_ways = group_by_entity(target_cursor_ways);\r\n    for (target_id, cursor_presses) in target_cursor_ways {\r\n        commands.entity(target_id).insert(Pressed {\r\n            presses: cursor_presses\r\n                .into_iter()\r\n                .map(|(cursor_id, way)| CursorPress { cursor_id, way })\r\n                .collect(),\r\n        });\r\n    }\r\n}\r\n\r\nfn group_by_entity(ways: Vec<(Entity, Entity, Way)>) -> HashMap<Entity, Vec<(Entity, Way)>> {\r\n    let mut groups: HashMap<Entity, Vec<(Entity, Way)>> = HashMap::new();\r\n\r\n    for (cursor, target, way) in ways {\r\n        groups\r\n            .entry(cursor)\r\n            .or_insert_with(Vec::new)\r\n            .push((target, way));\r\n    }\r\n\r\n    groups\r\n}\r\n\r\n#[allow(clippy::type_complexity)]\r\nfn release_detection(\r\n    mut commands: Commands,\r\n    mut tool_click_events: EventReader<ToolClickEvent>,\r\n    mut click_events: EventWriter<ClickEvent>,\r\n    mut cursor_query: Query<(&CollidingEntities, Option<&mut Pressing>), With<Cursor>>,\r\n    mut target_query: Query<(Entity, &Visibility, Option<&mut Pressed>), With<Clickable>>,\r\n) {\r\n    for tool_click_event in tool_click_events.read() {\r\n        // only check released events\r\n        let ToolClickEvent::Released { cursor_id, way } = tool_click_event else {\r\n            continue;\r\n        };\r\n\r\n        // find the cursor for the event\r\n        let Ok((cursor_touching, cursor_pressing)) = cursor_query.get_mut(*cursor_id) else {\r\n            warn!(\"Cursor {:?} not found\", cursor_id);\r\n            continue;\r\n        };\r\n\r\n        // each element the cursor has tracked as pressing now needs to be released\r\n        // if the cursor is still touching that element, also send a click event\r\n\r\n        // for each element the cursor is touching\r\n        let mut clicked: Vec<Entity> = vec![];\r\n        for touching_id in cursor_touching.iter() {\r\n            // ensure it is a clickable element\r\n            let Ok((target_id, target_visible, target_pressed)) =\r\n                target_query.get_mut(*touching_id)\r\n            else {\r\n                continue;\r\n            };\r\n            // ensure the element is visible\r\n            if target_visible == Visibility::Hidden {\r\n                continue;\r\n            }\r\n\r\n            // update the tracker in the target\r\n            if let Some(mut pressed) = target_pressed {\r\n                if let Some(press_index) = pressed\r\n                    .presses\r\n                    .iter()\r\n                    .position(|press| press.cursor_id == *cursor_id && press.way == *way)\r\n                {\r\n                    if pressed.presses.len() == 1 {\r\n                        // this is the last press, remove the tracker\r\n                        commands.entity(target_id).remove::<Pressed>();\r\n                    } else {\r\n                        // remove the press from the tracker\r\n                        pressed.presses.remove(press_index);\r\n                    }\r\n                } else {\r\n                    warn!(\"Cursor {:?} not pressing {:?}\", cursor_id, target_id);\r\n                }\r\n            } else {\r\n                warn!(\r\n                    \"Target {:?} didn't know it was pressed by cursor {:?}. Did you press elsewhere and release here?\",\r\n                    target_id, cursor_id\r\n                );\r\n            }\r\n\r\n            clicked.push(target_id);\r\n        }\r\n\r\n        match cursor_pressing {\r\n            Some(mut pressing) => {\r\n                // send release events\r\n                let mut remove = HashSet::new();\r\n                pressing\r\n                    .pressing\r\n                    .iter()\r\n                    .filter(|press| press.way == *way)\r\n                    .for_each(|press: &TargetPress| {\r\n                        click_events.send(ClickEvent::Released {\r\n                            target_id: press.target_id,\r\n                            cursor_id: *cursor_id,\r\n                            way: *way,\r\n                        });\r\n                        remove.insert(*press);\r\n                    });\r\n                pressing.pressing.retain(|press| !remove.contains(press));\r\n                if pressing.pressing.is_empty() {\r\n                    commands.entity(*cursor_id).remove::<Pressing>();\r\n                }\r\n                // ensure all clicked are present in remove\r\n                for target_id in clicked.iter() {\r\n                    if !remove.contains(&TargetPress {\r\n                        target_id: *target_id,\r\n                        way: *way,\r\n                    }) {\r\n                        warn!(\r\n                            \"Cursor {:?} didn't know it was clicking {:?}\",\r\n                            cursor_id, target_id\r\n                        );\r\n                    } else {\r\n                        click_events.send(ClickEvent::Clicked {\r\n                            target_id: *target_id,\r\n                            cursor_id: *cursor_id,\r\n                            way: *way,\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n            None => {\r\n                debug!(\"Cursor {:?} wasn't pressing anything\", cursor_id);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\inference_types\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_inference_types\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\nollama-rs = { workspace = true }\r\ncursor_hero_text_asset_types = {workspace = true}\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\host_event\\src\\lib.rs\r\n\r\n````rust\r\npub mod host_event_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::host_event_plugin::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\metrics\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_metrics\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nindexmap = { workspace = true}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\glados_tts\\src\\glados_tts_inference_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse crossbeam_channel::bounded;\r\nuse crossbeam_channel::Receiver;\r\nuse crossbeam_channel::Sender;\r\nuse cursor_hero_inference_types::prelude::*;\r\nuse std::thread;\r\n\r\npub struct GladosTtsInferencePlugin;\r\n\r\nimpl Plugin for GladosTtsInferencePlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Startup, create_worker_thread);\r\n        app.add_systems(Update, bridge_requests);\r\n        app.add_systems(Update, bridge_responses);\r\n    }\r\n}\r\n\r\n#[derive(Debug)]\r\nenum GameboundMessage {\r\n    Response {\r\n        session_id: Entity,\r\n        prompt: SpeechPrompt,\r\n        response: Vec<u8>,\r\n    },\r\n}\r\n\r\n#[derive(Debug)]\r\nenum ThreadboundMessage {\r\n    Generate {\r\n        session_id: Entity,\r\n        prompt: SpeechPrompt,\r\n    },\r\n}\r\n\r\n#[derive(Resource)]\r\nstruct Bridge {\r\n    pub sender: Sender<ThreadboundMessage>,\r\n    pub receiver: Receiver<GameboundMessage>,\r\n}\r\n\r\nfn create_worker_thread(mut commands: Commands) {\r\n    let (game_tx, game_rx) = bounded::<_>(10);\r\n    let (thread_tx, thread_rx) = bounded::<_>(10);\r\n    commands.insert_resource(Bridge {\r\n        sender: thread_tx,\r\n        receiver: game_rx,\r\n    });\r\n\r\n    let game_tx_clone = game_tx.clone();\r\n    thread::Builder::new()\r\n        .name(\"GLaDOSTTS thread\".to_string())\r\n        .spawn(move || {\r\n            let rt = tokio::runtime::Runtime::new().unwrap();\r\n            rt.block_on(async {\r\n                let game_tx = game_tx_clone;\r\n                loop {\r\n                    let msg = match thread_rx.recv() {\r\n                        Ok(msg) => msg,\r\n                        Err(_) => {\r\n                            error!(\"Threadbound channel failure, exiting\");\r\n                            break;\r\n                        }\r\n                    };\r\n                    match msg {\r\n                        ThreadboundMessage::Generate { session_id, prompt } => {\r\n                            debug!(\"Worker received generate request for session {:?}, generating response\", session_id);\r\n                            let prompt_str = match &prompt {\r\n                                SpeechPrompt::Raw { content } => content,\r\n                            };\r\n                            let data = match crate::glados_tts::generate(prompt_str).await {\r\n                                Ok(data) => data,\r\n                                Err(e) => {\r\n                                    error!(\"Failed to generate TTS: {:?}\", e);\r\n                                    continue;\r\n                                }\r\n                            };\r\n                            if let Err(e) = game_tx.send(GameboundMessage::Response {\r\n                                session_id,\r\n                                prompt: prompt.clone(),\r\n                                response: data,\r\n                            }) {\r\n                                error!(\"Gamebound channel failure, exiting: {:?}\", e);\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                    std::thread::sleep(std::time::Duration::from_millis(50));\r\n                }\r\n            });\r\n        })\r\n        .expect(\"Failed to spawn thread\");\r\n}\r\n\r\nfn bridge_requests(bridge: ResMut<Bridge>, mut events: EventReader<SpeechInferenceEvent>) {\r\n    for event in events.read() {\r\n        if let SpeechInferenceEvent::Request { session_id, prompt } = event {\r\n            debug!(\r\n                \"Received generate request for session {:?}, sending over bridge to worker thread\",\r\n                session_id\r\n            );\r\n            if let Err(e) = bridge.sender.send(ThreadboundMessage::Generate {\r\n                session_id: *session_id,\r\n                prompt: prompt.clone(),\r\n            }) {\r\n                error!(\"Threadbound channel failure: {:?}\", e);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfn bridge_responses(bridge: ResMut<Bridge>, mut events: EventWriter<SpeechInferenceEvent>) {\r\n    for msg in bridge.receiver.try_iter() {\r\n        match msg {\r\n            GameboundMessage::Response {\r\n                session_id,\r\n                prompt,\r\n                response,\r\n            } => {\r\n                debug!(\r\n                    \"Received bridge response for session {:?}, sending game event\",\r\n                    session_id\r\n                );\r\n                events.send(SpeechInferenceEvent::Response {\r\n                    session_id,\r\n                    prompt,\r\n                    wav: response,\r\n                });\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\observation\\src\\observation_log_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse cursor_hero_observation_types::prelude::*;\r\n\r\npub struct ObservationLogPlugin;\r\n\r\nimpl Plugin for ObservationLogPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Update, log_observations);\r\n    }\r\n}\r\n\r\nfn log_observations(mut observation_event_reader: EventReader<SomethingObservableHappenedEvent>) {\r\n    for event in observation_event_reader.read() {\r\n        info!(\"{}\", event);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\movement_tool\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_movement_tool\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\ncursor_hero_toolbelt_types = { workspace = true }\r\ncursor_hero_physics = { workspace = true }\r\ncursor_hero_movement_tool_types = { workspace = true }\r\ncursor_hero_character_types = { workspace = true }\r\ncursor_hero_tools = { workspace = true }\r\ncursor_hero_sprint_tool_types = { workspace = true }\r\ncursor_hero_input = { workspace = true }\r\ncursor_hero_math = { workspace = true }\r\nleafwing-input-manager = { workspace = true }\r\nbevy_xpbd_2d = { workspace = true }\r\nitertools = {workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\memory_types\\src\\memory_types_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n// use crate::prelude::*;\r\n\r\npub struct MemoryTypesPlugin;\r\n\r\nimpl Plugin for MemoryTypesPlugin {\r\n    fn build(&self, _app: &mut App) {}\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\observation\\src\\observation_tool_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse cursor_hero_character_types::character_types::AgentCharacter;\r\nuse cursor_hero_chat_types::chat_types::ChatEvent;\r\nuse cursor_hero_inference_types::prelude::*;\r\nuse cursor_hero_observation_types::prelude::*;\r\nuse cursor_hero_toolbelt_types::prelude::*;\r\nuse cursor_hero_tools::prelude::*;\r\n\r\npub struct ObservationToolPlugin;\r\n\r\nimpl Plugin for ObservationToolPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Update, toolbelt_events);\r\n        app.add_systems(Update, tool_tick);\r\n        app.add_systems(Update, handle_text_inference_response);\r\n        app.add_systems(Update, handle_tts_inference_response);\r\n    }\r\n}\r\n\r\nfn toolbelt_events(\r\n    mut commands: Commands,\r\n    asset_server: Res<AssetServer>,\r\n    mut reader: EventReader<ToolbeltPopulateEvent>,\r\n) {\r\n    for event in reader.read() {\r\n        if event.loadout == ToolbeltLoadout::Agent {\r\n            ToolSpawnConfig::<ObservationTool, NoInputs>::new(\r\n                ObservationTool::default(),\r\n                event.id,\r\n                event,\r\n            )\r\n            .with_src_path(file!().into())\r\n            .guess_name(file!())\r\n            .guess_image(file!(), &asset_server, \"png\")\r\n            .with_description(\"Logs information about the environment to the console.\")\r\n            .with_starting_state(StartingState::Inactive)\r\n            .spawn(&mut commands);\r\n        }\r\n    }\r\n}\r\n\r\n#[allow(clippy::type_complexity)]\r\nfn tool_tick(\r\n    mut tool_query: Query<(&Parent, &mut ObservationTool), With<ActiveTool>>,\r\n    toolbelt_query: Query<&Parent, With<Toolbelt>>,\r\n    mut character_query: Query<&mut ObservationBuffer>,\r\n    mut events: EventWriter<TextInferenceEvent>,\r\n) {\r\n    for tool in tool_query.iter_mut() {\r\n        let (tool_parent, mut tool) = tool;\r\n\r\n        let Ok(toolbelt) = toolbelt_query.get(tool_parent.get()) else {\r\n            warn!(\"Failed to get toolbelt\");\r\n            continue;\r\n        };\r\n        let toolbelt_parent = toolbelt;\r\n\r\n        let character_id = toolbelt_parent.get();\r\n        let Ok(character) = character_query.get_mut(character_id) else {\r\n            warn!(\"Failed to get character\");\r\n            continue;\r\n        };\r\n\r\n        let character_observation_buffer = character;\r\n        let whats_new = tool\r\n            .last_inference\r\n            .map(|last_inference| {\r\n                character_observation_buffer\r\n                    .observations\r\n                    .iter()\r\n                    .filter(|entry| entry.datetime > last_inference)\r\n                    .map(|entry| entry.origin.into_whats_new(character_id))\r\n                    .fold(WhatsNew::Nothing, |acc, new| acc.max(new))\r\n            })\r\n            .unwrap_or_else(|| {\r\n                character_observation_buffer\r\n                    .observations\r\n                    .iter()\r\n                    .map(|entry| entry.origin.into_whats_new(character_id))\r\n                    .fold(WhatsNew::Nothing, |acc, new| acc.max(new))\r\n            });\r\n\r\n        // Update the field for debug viewing in the inspector\r\n        tool._whats_new = Some(whats_new);\r\n\r\n        // the agent will observe its own chats\r\n        // so this check doesn't prevent all forms of loops\r\n        if let WhatsNew::Nothing = whats_new {\r\n            continue;\r\n        }\r\n\r\n        if let Some(last_inference) = tool.last_inference {\r\n            if last_inference + whats_new.reply_delay() > chrono::Local::now() {\r\n                continue;\r\n            }\r\n        }\r\n\r\n        let mut chat_history = String::new();\r\n        for entry in character_observation_buffer.observations.iter() {\r\n            // let timestamp = entry.datetime.format(\"%Y-%m-%d %H:%M:%S\").to_string();\r\n            chat_history.push_str(entry.origin.to_string().as_str());\r\n            chat_history.push('\\n');\r\n        }\r\n\r\n        events.send(TextInferenceEvent::Request {\r\n            session_id: character_id,\r\n            prompt: TextPrompt::Chat {\r\n                chat_history,\r\n                options: Some(TextInferenceOptions {\r\n                    stop: Some(vec![\r\n                        \"\\n\".to_string(),\r\n                        \"(Human)\".to_string(),\r\n                        \"(Tume Eena)\".to_string(),\r\n                        \"(Ithia Tig)\".to_string(),\r\n                    ]),\r\n                    ..default()\r\n                }),\r\n            },\r\n        });\r\n        debug!(\"ObservationToolPlugin: Sent observation event\");\r\n\r\n        tool.last_inference = Some(chrono::Local::now());\r\n    }\r\n}\r\n\r\nfn handle_text_inference_response(\r\n    mut inference_events: EventReader<TextInferenceEvent>,\r\n    mut chat_events: EventWriter<ChatEvent>,\r\n    mut tts_events: EventWriter<SpeechInferenceEvent>,\r\n    agent_query: Query<(), With<AgentCharacter>>,\r\n) {\r\n    for event in inference_events.read() {\r\n        let TextInferenceEvent::Response {\r\n            response,\r\n            session_id,\r\n            ..\r\n        } = event\r\n        else {\r\n            continue;\r\n        };\r\n        if agent_query.get(*session_id).is_err() {\r\n            // Only inference responses for agent sessions are to be converted to chat messages and spoken\r\n            continue;\r\n        }\r\n\r\n        if response.is_empty() {\r\n            debug!(\"Received empty response, skipping\");\r\n            continue;\r\n        }\r\n\r\n        let event = ChatEvent::Chat {\r\n            character_id: *session_id,\r\n            message: response.clone(),\r\n        };\r\n        debug!(\"Sending event: {:?}\", event);\r\n        chat_events.send(event);\r\n\r\n        let event = SpeechInferenceEvent::Request {\r\n            session_id: *session_id,\r\n            prompt: SpeechPrompt::Raw {\r\n                content: response.clone(),\r\n            },\r\n        };\r\n        debug!(\"Sending event: {:?}\", event);\r\n        tts_events.send(event);\r\n    }\r\n}\r\n\r\nfn handle_tts_inference_response(\r\n    mut commands: Commands,\r\n    mut tts_events: EventReader<SpeechInferenceEvent>,\r\n    agent_query: Query<(), With<AgentCharacter>>,\r\n    mut audio_assets: ResMut<Assets<AudioSource>>,\r\n) {\r\n    for event in tts_events.read() {\r\n        if let SpeechInferenceEvent::Response {\r\n            session_id, wav, ..\r\n        } = event\r\n        {\r\n            if agent_query.get(*session_id).is_ok() {\r\n                info!(\r\n                    \"Received TTS response for session {:?}, playing\",\r\n                    session_id\r\n                );\r\n                let audio = audio_assets.add(AudioSource {\r\n                    bytes: wav.clone().into(),\r\n                });\r\n                commands.entity(*session_id).insert({\r\n                    AudioBundle {\r\n                        source: audio,\r\n                        settings: PlaybackSettings::REMOVE.with_spatial(true),\r\n                    }\r\n                });\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero\"\r\nversion = \"0.4.0\"\r\nedition = \"2021\"\r\n\r\n[workspace]\r\nmembers = [\"crates/*\", \"other/gamepad_hell\",  \"other/uparrow-enter\"]\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[workspace.dependencies]\r\ncursor_hero_ui_hover_types = { path = \"./crates/ui_hover_types\" }\r\ncursor_hero_ui_hover = { path = \"./crates/ui_hover\" }\r\ncursor_hero_ui_inspector_types = { path = \"./crates/ui_inspector_types\" }\r\ncursor_hero_ui_inspector = { path = \"./crates/ui_inspector\" }\r\ncursor_hero_worker_types = { path = \"./crates/worker_types\" }\r\ncursor_hero_worker = { path = \"./crates/worker\" }\r\ncursor_hero_memory_types = { path = \"./crates/memory_types\" }\r\ncursor_hero_memory = { path = \"./crates/memory\" }\r\ncursor_hero_window_swap_tool = { path = \"./crates/window_swap_tool\" }\r\ncursor_hero_window_swap_tool_types = { path = \"./crates/window_swap_tool_types\" }\r\ncursor_hero_host_fs_types = { path = \"./crates/host_fs_types\" }\r\ncursor_hero_host_fs = { path = \"./crates/host_fs\" }\r\ncursor_hero_window_position_types = { path = \"./crates/window_position_types\" }\r\ncursor_hero_window_position = { path = \"./crates/window_position\" }\r\ncursor_hero_ui_automation_types = { path = \"./crates/ui_automation_types\" }\r\ncursor_hero_ui_automation = { path = \"./crates/ui_automation\" }\r\ncursor_hero_brick_types = { path = \"./crates/brick_types\" }\r\ncursor_hero_brick = { path = \"./crates/brick\" }\r\ncursor_hero_fullscreen_tool = { path = \"./crates/fullscreen_tool\" }\r\ncursor_hero_fullscreen_tool_types = { path = \"./crates/fullscreen_tool_types\" }\r\ncursor_hero_ui_watcher_types = { path = \"./crates/ui_watcher_types\" }\r\ncursor_hero_ui_watcher = { path = \"./crates/ui_watcher\" }\r\ncursor_hero_floaty_nametag_types = { path = \"./crates/floaty_nametag_types\" }\r\ncursor_hero_floaty_nametag = { path = \"./crates/floaty_nametag\" }\r\ncursor_hero_host_event_types = { path = \"./crates/host_event_types\" }\r\ncursor_hero_host_event = { path = \"./crates/host_event\" }\r\ncursor_hero_taskbar_tool = { path = \"./crates/taskbar_tool\" }\r\ncursor_hero_start_menu_types = { path = \"./crates/start_menu_types\" }\r\ncursor_hero_start_menu = { path = \"./crates/start_menu\" }\r\ncursor_hero_calculator_app_types = { path = \"./crates/calculator_app_types\" }\r\ncursor_hero_calculator_app = { path = \"./crates/calculator_app\" }\r\ncursor_hero_app_types = { path = \"./crates/app_types\" }\r\ncursor_hero_app = { path = \"./crates/app\" }\r\ncursor_hero_secret_types = { path = \"./crates/secret_types\" }\r\ncursor_hero_secret = { path = \"./crates/secret\" }\r\ncursor_hero_voice_to_text_types = { path = \"./crates/voice_to_text_types\" }\r\ncursor_hero_voice_to_text = { path = \"./crates/voice_to_text\" }\r\ncursor_hero_glados_tts_types = { path = \"./crates/glados_tts_types\" }\r\ncursor_hero_glados_tts = { path = \"./crates/glados_tts\" }\r\ncursor_hero_ollama_types = { path = \"./crates/ollama_types\" }\r\ncursor_hero_ollama = { path = \"./crates/ollama\" }\r\ncursor_hero_text_asset_types = { path = \"./crates/text_asset_types\" }\r\ncursor_hero_text_asset = { path = \"./crates/text_asset\" }\r\ncursor_hero_environment_types = { path = \"./crates/environment_types\" }\r\ncursor_hero_chat_types = { path = \"./crates/chat_types\" }\r\ncursor_hero_chat = { path = \"./crates/chat\" }\r\ncursor_hero_observation_types = { path = \"./crates/observation_types\" }\r\ncursor_hero_observation = { path = \"./crates/observation\" }\r\ncursor_hero_inference_types = { path = \"./crates/inference_types\" }\r\ncursor_hero_inference = { path = \"./crates/inference\" }\r\ncursor_hero_movement_tool_types = { path = \"./crates/movement_tool_types\" }\r\ncursor_hero_movement_tool = { path = \"./crates/movement_tool\" }\r\ncursor_hero_character_types = { path = \"./crates/character_types\" }\r\ncursor_hero_agent_types = { path = \"./crates/agent_types\" }\r\ncursor_hero_physics_debug = { path = \"./crates/physics_debug\" }\r\ncursor_hero_math = { path = \"./crates/math\" }\r\ncursor_hero_cursor_types = { path = \"./crates/cursor_types\" }\r\ncursor_hero_toolbelt_types = { path = \"./crates/toolbelt_types\" }\r\ncursor_hero_sprint_tool_types = { path = \"./crates/sprint_tool_types\" }\r\ncursor_hero_sprint_tool = { path = \"./crates/sprint_tool\" }\r\ncursor_hero_agent = { path = \"./crates/agent\" }\r\ncursor_hero_taskbar = { path = \"./crates/taskbar\" }\r\ncursor_hero_taskbar_types = { path = \"./crates/taskbar_types\" }\r\ncursor_hero_environment_nametag = { path = \"./crates/environment_nametag\" }\r\ncursor_hero_environment = { path = \"./crates/environment\" }\r\ncursor_hero_xelu_prompts = { path = \"./crates/xelu_prompts\" }\r\ncursor_hero_pause_tool = { path = \"./crates/pause_tool\" }\r\ncursor_hero_wallpaper = { path = \"./crates/wallpaper\" }\r\ncursor_hero_hover = { path = \"./crates/hover\" }\r\ncursor_hero_pressure_plate = { path = \"./crates/pressure_plate\" }\r\ncursor_hero_level_bounds = { path = \"./crates/level_bounds\" }\r\ncursor_hero_bevy = { path = \"./crates/bevy\" }\r\ncursor_hero_input = { path = \"./crates/input\" }\r\ncursor_hero_camera = { path = \"./crates/camera\" }\r\ncursor_hero_character = { path = \"./crates/character\" }\r\ncursor_hero_data = { path = \"./crates/data\" }\r\ncursor_hero_metrics = { path = \"./crates/metrics\" }\r\ncursor_hero_click_drag_character_movement = { path = \"./crates/click_drag_character_movement\" }\r\ncursor_hero_physics = { path = \"./crates/physics\" }\r\ncursor_hero_cursor = { path = \"./crates/cursor\" }\r\ncursor_hero_screen = { path = \"./crates/screen\" }\r\ncursor_hero_toolbelt = { path = \"./crates/toolbelt\" }\r\ncursor_hero_tools = { path = \"./crates/tools\" }\r\ncursor_hero_ui = { path = \"./crates/ui\" }\r\ncursor_hero_winutils = { path = \"./crates/winutils\" }\r\ncursor_hero_restart_memory = { path = \"./crates/restart_memory\" }\r\ncursor_hero_version = { path = \"./crates/version\" }\r\ncursor_hero_plugins = { path = \"./crates/plugins\" }\r\ncursor_hero_icon = { path = \"./crates/icon\" }\r\n#inline_tweak = {git = \"https://github.com/Uriopass/inline_tweak\", version = \"1.1.0\", tag = \"v1.1.0\"} # features=[\"derive\"]\r\nanyhow = \"1.0.75\"\r\nglam = \"0.25.0\"\r\n# bevy = { version = \"0.12.1\", path = \"../bevy\"}\r\nbevy = { version = \"0.12.1\", git = \"https://github.com/TeamDman/bevy.git\", branch = \"cursor_hero\" }\r\n# bevy-inspector-egui = { version = \"0.22.1\", path=\"../bevy-inspector-egui/crates/bevy-inspector-egui\" }\r\nbevy-inspector-egui = { version = \"0.22.1\", git = \"https://github.com/TeamDman/bevy-inspector-egui.git\", branch = \"cursor_hero\" }\r\nbevy_xpbd_2d = { git = \"https://github.com/TeamDman/bevy_xpbd.git\", branch = \"cursor_hero\", features = [\r\n  \"simd\",\r\n  \"parallel\",\r\n] }\r\nbevy_egui = { git = \"https://github.com/TeamDman/bevy_egui.git\", branch = \"cursor_hero\", version = \"0.24\" }\r\n# enigo = {git = \"https://github.com/TeamDman/enigo\", branch = \"cursor_hero\", version = \"0.1.3\"}\r\n# enigo = {path = \"../../rust/enigo\", version = \"0.1.3\"}\r\nenigo = \"0.2.0-rc2\"\r\negui = \"0.24\"\r\ncrossbeam-channel = \"0.5.8\"\r\nitertools = \"0.12.0\"\r\nraw-window-handle = \"0.5.2\"\r\nleafwing-input-manager = { git = \"https://github.com/TeamDman/leafwing-input-manager.git\", branch = \"cursor_hero\" }\r\nwindows = \"0.52.0\"\r\nindexmap = \"2.1.0\"\r\nimage = \"0.24.7\"\r\nscreenshots = \"0.8.4\"\r\nuiautomation = \"0.7.3\"\r\nserde = { version = \"1.0\", features = [\"derive\"] }\r\nserde_json = \"1.0\"\r\ntokio = { version = \"1.32.0\", features = [\"net\", \"full\"] }\r\ntokio-named-pipes = \"0.1.0\"\r\nsyn = { version = \"2.0.48\", features = [\"full\", \"visit-mut\", \"visit\"] }\r\nquote = \"1.0.35\"\r\nproc-macro2 = \"1.0.76\"\r\nbevy_embedded_assets = { version = \"0.9.1\", git = \"https://github.com/TeamDman/bevy_embedded_assets.git\", branch = \"cursor_hero\" }\r\nwinit = \"0.28.7\"\r\nfxhash = \"0.2.1\"\r\nwidestring = \"1.0.2\"\r\nwinreg = \"0.52.0\"\r\nrand = \"0.8.5\"\r\nollama-rs = \"0.1.6\"\r\nreqwest = \"0.11.24\"\r\nurlencoding = \"2.1.3\"\r\nchrono = \"0.4.33\"\r\nrodio = { version = \"0.17\", default-features = false }\r\nzeroize = \"1.7.0\"\r\ntokio-tungstenite = \"0.21.0\"\r\nfutures-util = \"0.3.30\"\r\nonce_cell = \"1.19.0\"\r\n\r\n[dependencies]\r\ncursor_hero_plugins = { workspace = true }\r\ncursor_hero_version = { workspace = true }\r\nbevy = { workspace = true }\r\n\r\n[dev-dependencies]\r\n# bevy = { workspace = true, features = [\"dynamic_linking\"] }\r\nbevy = { workspace = true }\r\n\r\n\r\n[build-dependencies]\r\nembed-resource = \"1.6.3\"\r\n\r\n[profile.dev]\r\nopt-level = 1\r\n\r\n[profile.dev.package.\"*\"]\r\nopt-level = 3\r\n\r\n# [patch.crates-io]\r\n# winit = { path = \"D:/Repos/rust/winit\" }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\fullscreen_tool\\src\\fullscreen_tool_tick_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse bevy::window::PrimaryWindow;\r\nuse cursor_hero_fullscreen_tool_types::prelude::*;\r\nuse cursor_hero_toolbelt_types::prelude::*;\r\nuse cursor_hero_tools::tool_spawning::StartingState;\r\n\r\npub struct FullscreenToolTickPlugin;\r\n\r\nimpl Plugin for FullscreenToolTickPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Update, handle_toggle);\r\n        app.add_systems(Update, match_window_state);\r\n    }\r\n}\r\n\r\nfn match_window_state(\r\n    mut commands: Commands,\r\n    tool_query: Query<(Entity, Option<&ActiveTool>), With<FullscreenTool>>,\r\n    window_query: Query<&Window, With<PrimaryWindow>>,\r\n) {\r\n    let Some(mode) = window_query.iter().map(|w| w.mode).next() else {\r\n        warn!(\"No window found\");\r\n        return;\r\n    };\r\n    for tool in tool_query.iter() {\r\n        let (tool_id, tool_active) = tool;\r\n        let desired_state = FullscreenTool::state_for_mode(mode);\r\n        if tool_active == desired_state.as_active().as_ref() {\r\n            continue;\r\n        }\r\n        match desired_state {\r\n            StartingState::Active => {\r\n                info!(\"Activating FullscreenTool without event to match window state\");\r\n                commands.entity(tool_id).insert(ActiveTool);\r\n            }\r\n            StartingState::Inactive => {\r\n                info!(\"Deactivating FullscreenTool without event to match window state\");\r\n                commands.entity(tool_id).remove::<ActiveTool>();\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfn handle_toggle(\r\n    tool_query: Query<(), With<FullscreenTool>>,\r\n    mut window_query: Query<&mut Window, With<PrimaryWindow>>,\r\n    mut tool_events: EventReader<ToolActivationEvent>,\r\n) {\r\n    for event in tool_events.read() {\r\n        match event {\r\n            ToolActivationEvent::Activate(tool_id) if tool_query.contains(*tool_id) => {\r\n                info!(\"FullscreenTool activated, setting window to fullscreen.\");\r\n                if window_query.is_empty() {\r\n                    warn!(\"No window found\");\r\n                    continue;\r\n                }\r\n                for mut window in window_query.iter_mut() {\r\n                    window.mode = bevy::window::WindowMode::BorderlessFullscreen;\r\n                }\r\n            }\r\n            ToolActivationEvent::Deactivate(tool_id) if tool_query.contains(*tool_id) => {\r\n                info!(\"FullscreenTool deactivated, setting window to windowed.\");\r\n                if window_query.is_empty() {\r\n                    warn!(\"No window found\");\r\n                    continue;\r\n                }\r\n                for mut window in window_query.iter_mut() {\r\n                    window.mode = bevy::window::WindowMode::Windowed;\r\n                }\r\n            }\r\n            _ => {}\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\chat\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_chat\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\ncursor_hero_character_types = { workspace = true }\r\ncursor_hero_toolbelt_types = { workspace = true }\r\ncursor_hero_chat_types = { workspace = true }\r\ncursor_hero_voice_to_text_types = { workspace = true }\r\ncursor_hero_tools = { workspace = true }\r\nleafwing-input-manager = { workspace = true }\r\ncursor_hero_observation_types = { workspace = true }\r\nrand = { workspace = true }\r\nbevy_xpbd_2d = { workspace = true }\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\bevy\\src\\vec_into_rect.rs\r\n\r\n````rust\r\nuse bevy::math::Rect;\r\nuse bevy::math::Vec2;\r\n\r\npub trait Vec2ToRect {\r\n    fn as_size_of_rect_with_center(&self, center: &Vec2) -> Rect;\r\n}\r\nimpl Vec2ToRect for Vec2 {\r\n    fn as_size_of_rect_with_center(&self, center: &Vec2) -> Rect {\r\n        Rect::from_center_size(*center, *self)\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\math\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_math\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\observation\\src\\lib.rs\r\n\r\n````rust\r\npub mod observation_buffer_plugin;\r\npub mod observation_log_plugin;\r\npub mod observation_plugin;\r\npub mod observation_tool_plugin;\r\npub mod observe_chat_plugin;\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\environment_nametag\\src\\lib.rs\r\n\r\n````rust\r\npub mod environment_nametag_plugin;\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\agent_types\\src\\lib.rs\r\n\r\n````rust\r\npub mod agent_types;\r\npub mod agent_types_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::agent_types::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\movement_tool_types\\src\\movement_tool_types.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse leafwing_input_manager::prelude::*;\r\nuse leafwing_input_manager::user_input::InputKind;\r\n\r\nuse bevy_inspector_egui::prelude::ReflectInspectorOptions;\r\nuse bevy_inspector_egui::InspectorOptions;\r\nuse cursor_hero_input::active_input_state_plugin::InputMethod;\r\nuse cursor_hero_toolbelt_types::prelude::*;\r\n\r\n#[derive(Component, Reflect, Debug, InspectorOptions)]\r\n#[reflect(Component, InspectorOptions)]\r\npub struct MovementTool {\r\n    #[inspector(min = 0.0)]\r\n    pub speed: f32,\r\n    #[inspector(min = 0.0)]\r\n    pub default_speed: f32,\r\n    #[inspector(min = 0.0)]\r\n    pub sprint_speed: f32,\r\n    pub target: MovementTarget,\r\n}\r\nimpl Default for MovementTool {\r\n    fn default() -> Self {\r\n        match InputMethod::default() {\r\n            InputMethod::MouseAndKeyboard | InputMethod::Keyboard => Self::default_mnk(),\r\n            InputMethod::Gamepad => Self::default_gamepad(),\r\n        }\r\n    }\r\n}\r\nimpl MovementTool {\r\n    pub fn default_mnk() -> MovementTool {\r\n        MovementTool {\r\n            speed: 8000.0,\r\n            default_speed: 8000.0,\r\n            sprint_speed: 40000.0,\r\n            target: MovementTarget::Character,\r\n        }\r\n    }\r\n    pub fn default_gamepad() -> MovementTool {\r\n        MovementTool {\r\n            speed: 800.0,\r\n            default_speed: 800.0,\r\n            sprint_speed: 80000.0,\r\n            target: MovementTarget::Character,\r\n        }\r\n    }\r\n}\r\n\r\n#[derive(Reflect, Debug, Clone, Copy)]\r\npub enum MovementTarget {\r\n    Character,\r\n    Camera(Entity),\r\n}\r\n\r\n#[derive(Event, Debug, Reflect)]\r\npub enum MovementTargetEvent {\r\n    SetTarget {\r\n        tool_id: Entity,\r\n        target: MovementTarget,\r\n    },\r\n}\r\n\r\n#[derive(Actionlike, PartialEq, Eq, Clone, Copy, Hash, Debug, Reflect)]\r\npub enum MovementToolAction {\r\n    Move,\r\n}\r\n\r\nimpl MovementToolAction {\r\n    fn default_gamepad_binding(&self) -> UserInput {\r\n        match self {\r\n            Self::Move => UserInput::Single(InputKind::DualAxis(DualAxis::left_stick())),\r\n        }\r\n    }\r\n\r\n    fn default_mkb_binding(&self) -> UserInput {\r\n        match self {\r\n            Self::Move => UserInput::VirtualDPad(VirtualDPad::wasd()),\r\n        }\r\n    }\r\n}\r\nimpl ToolAction for MovementToolAction {\r\n    fn default_input_map(_event: &ToolbeltPopulateEvent) -> Option<InputMap<MovementToolAction>> {\r\n        let mut input_map = InputMap::default();\r\n\r\n        for variant in MovementToolAction::variants() {\r\n            input_map.insert(variant.default_mkb_binding(), variant);\r\n            input_map.insert(variant.default_gamepad_binding(), variant);\r\n        }\r\n        Some(input_map)\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\click_drag_character_movement\\src\\lib.rs\r\n\r\n````rust\r\nuse bevy::input::mouse::MouseButtonInput;\r\nuse bevy::input::mouse::MouseMotion;\r\nuse bevy::prelude::*;\r\nuse bevy::window::PrimaryWindow;\r\nuse bevy_xpbd_2d::components::Position;\r\n\r\nuse cursor_hero_camera::camera_plugin::update_camera_zoom;\r\nuse cursor_hero_camera::camera_plugin::FollowWithMainCamera;\r\nuse cursor_hero_camera::camera_plugin::MainCamera;\r\nuse cursor_hero_character_types::prelude::*;\r\n\r\npub struct ClickDragMovementPlugin;\r\n\r\nimpl Plugin for ClickDragMovementPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(\r\n            Update,\r\n            (\r\n                mouse_drag_update.after(update_camera_zoom),\r\n                teleport_character_to_camera\r\n                    .after(mouse_drag_update)\r\n                    .run_if(should_teleport_character_to_camera),\r\n            ),\r\n        )\r\n        .insert_resource(MouseDragState::default())\r\n        .register_type::<MouseDragState>();\r\n    }\r\n}\r\n\r\n#[derive(Reflect)]\r\nstruct Anchor {\r\n    drag_start_world_position: Vec2,\r\n}\r\n\r\n#[derive(Resource, Reflect, Default)]\r\n#[reflect(Resource)]\r\nstruct MouseDragState {\r\n    anchor: Option<Anchor>,\r\n    is_dragging: bool,\r\n}\r\n\r\nfn should_teleport_character_to_camera(\r\n    query: Query<&FollowWithMainCamera, Added<FollowWithMainCamera>>,\r\n    mouse_drag_state: Res<MouseDragState>,\r\n) -> bool {\r\n    query.iter().next().is_some() && mouse_drag_state.is_dragging\r\n}\r\n\r\n/// when the camera starts following a character while dragging, teleport the character to the camera\r\nfn teleport_character_to_camera(\r\n    mut character: Query<&mut Transform, (With<Character>, Without<MainCamera>)>,\r\n    camera_transform_query: Query<&Transform, (With<MainCamera>, Without<Character>)>,\r\n) {\r\n    character.single_mut().translation = camera_transform_query.single().translation;\r\n}\r\n\r\n#[allow(clippy::type_complexity)]\r\nfn mouse_drag_update(\r\n    mut mouse_button_input_events: EventReader<MouseButtonInput>,\r\n    mut mouse_drag_state: ResMut<MouseDragState>,\r\n    mut mouse_motion_events: EventReader<MouseMotion>,\r\n    mut follow: Query<&mut Position, (With<FollowWithMainCamera>, Without<MainCamera>)>,\r\n    window_query: Query<&Window, With<PrimaryWindow>>,\r\n    camera_query: Query<(&Camera, &GlobalTransform), (With<MainCamera>, Without<Character>)>,\r\n    mut camera_transform_query: Query<&mut Transform, (With<MainCamera>, Without<Character>)>,\r\n) {\r\n    let (camera, camera_global_transform) = camera_query.single();\r\n    let window = window_query.single();\r\n\r\n    // drag start and end logic\r\n    for event in mouse_button_input_events.read() {\r\n        if event.button == MouseButton::Left {\r\n            mouse_drag_state.is_dragging = event.state.is_pressed();\r\n            if mouse_drag_state.is_dragging {\r\n                // begin dragging\r\n                if let Some(screen_position) = window.cursor_position() {\r\n                    if let Some(world_position) = camera\r\n                        .viewport_to_world(camera_global_transform, screen_position)\r\n                        .map(|ray| ray.origin.truncate())\r\n                    {\r\n                        mouse_drag_state.anchor = Some(Anchor {\r\n                            drag_start_world_position: world_position,\r\n                        });\r\n                    }\r\n                }\r\n            } else {\r\n                // finish dragging\r\n                mouse_drag_state.anchor = None;\r\n            }\r\n        }\r\n    }\r\n\r\n    if mouse_drag_state.is_dragging {\r\n        // perform drag update\r\n        if let Some(anchor) = &mouse_drag_state.anchor {\r\n            if let Some(current_screen_position) = window.cursor_position() {\r\n                // mouse is inside the window, convert to world coords\r\n                if let Some(current_world_position) = camera\r\n                    .viewport_to_world(camera_global_transform, current_screen_position)\r\n                    .map(|ray| ray.origin.truncate())\r\n                {\r\n                    // calculate delta from the anchor\r\n                    let delta = anchor.drag_start_world_position - current_world_position;\r\n                    if let Ok(mut follow) = follow.get_single_mut() {\r\n                        // reposition the thing the camera is following\r\n                        follow.0 += delta;\r\n                    } else {\r\n                        // move the camera when not following something\r\n                        camera_transform_query.single_mut().translation += delta.extend(0.0);\r\n                    }\r\n                    // track info needed to keep alignment with starting point\r\n                    mouse_drag_state.anchor = Some(Anchor {\r\n                        drag_start_world_position: anchor.drag_start_world_position,\r\n                    });\r\n                }\r\n            } else {\r\n                // cursor is outside the window, use delta to approximate mouse position\r\n                let mut delta = mouse_motion_events\r\n                    .read()\r\n                    .fold(Vec2::ZERO, |acc, event| acc + event.delta);\r\n                delta.x *= -1.0;\r\n                if let Ok(mut follow) = follow.get_single_mut() {\r\n                    // reposition the thing the camera is following\r\n                    follow.0 += delta;\r\n                } else {\r\n                    // move the camera when not following something\r\n                    camera_transform_query.single_mut().translation += delta.extend(0.0);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\agent\\src\\agent_spawning_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n\r\nuse bevy_xpbd_2d::components::Collider;\r\nuse bevy_xpbd_2d::components::RigidBody;\r\nuse cursor_hero_agent_types::prelude::*;\r\nuse cursor_hero_bevy::prelude::NegativeYVec2;\r\nuse cursor_hero_character_types::prelude::*;\r\nuse cursor_hero_environment_types::prelude::*;\r\nuse cursor_hero_floaty_nametag_types::prelude::*;\r\nuse cursor_hero_observation_types::prelude::*;\r\nuse cursor_hero_physics::damping_plugin::MovementDamping;\r\n\r\npub struct AgentSpawningPlugin;\r\n\r\nimpl Plugin for AgentSpawningPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Update, spawn_agent);\r\n    }\r\n}\r\n\r\nfn spawn_agent(\r\n    mut commands: Commands,\r\n    mut environment_events: EventReader<PopulateEnvironmentEvent>,\r\n    environment_query: Query<&AgentEnvironment>,\r\n    asset_server: Res<AssetServer>,\r\n) {\r\n    for event in environment_events.read() {\r\n        if !environment_query.contains(event.environment_id) {\r\n            continue;\r\n        }\r\n        info!(\r\n            \"Spawning agent for environment {:?}\",\r\n            event.environment_id\r\n        );\r\n        commands\r\n            .entity(event.environment_id)\r\n            .with_children(|parent| {\r\n                let spawn_position = Vec2::new(1920.0, 1080.0).neg_y() / 2.0;\r\n                parent.spawn((\r\n                    SpriteBundle {\r\n                        sprite: Sprite {\r\n                            custom_size: Some(Vec2::new(64.0, 64.0)),\r\n                            ..default()\r\n                        },\r\n                        texture: asset_server.load(AgentAppearance::Default.get_texture_path()),\r\n                        transform: Transform::from_translation(spawn_position.extend(80.0)),\r\n                        ..default()\r\n                    },\r\n                    Character,\r\n                    AgentCharacter,\r\n                    Name::new(\"Character - (Agent) Ithia Tig\"),\r\n                    FloatyName {\r\n                        text: \"Ithia Tig\".to_string(),\r\n                        vertical_offset: 40.0,\r\n                        appearance: NametagAppearance::Character,\r\n                    },\r\n                    Agent,\r\n                    RigidBody::Dynamic,\r\n                    ObservationBuffer {\r\n                        log_level: ObservationLogLevel::All,\r\n                        ..default()\r\n                    },\r\n                    Collider::capsule(25.0, 12.5),\r\n                    MovementDamping { factor: 0.90 },\r\n                ));\r\n            });\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\level_bounds\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_level_bounds\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\ncursor_hero_character_types = { workspace = true }\r\ncursor_hero_environment_types = { workspace = true }\r\nbevy = { workspace = true }\r\nbevy_xpbd_2d = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\glados_tts_types\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_glados_tts_types\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\cursor_types\\src\\cursor_types.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n\r\nuse bevy_inspector_egui::prelude::ReflectInspectorOptions;\r\nuse bevy_inspector_egui::InspectorOptions;\r\n\r\nuse crate::cursor_behaviour_types::CursorMovementBehaviour;\r\n\r\n#[derive(SystemSet, Clone, Hash, Debug, PartialEq, Eq)]\r\npub enum CursorSystemSet {\r\n    Position,\r\n}\r\n\r\n#[derive(Reflect, Debug, PartialEq, Eq, Clone)]\r\npub enum CursorLogBehaviour {\r\n    Errors,\r\n    ErrorsAndPositionUpdates,\r\n}\r\n\r\n#[derive(Component, Debug, Reflect)]\r\npub struct MainCursor;\r\n\r\n#[derive(Component, InspectorOptions, Debug, Reflect)]\r\n#[reflect(InspectorOptions)]\r\npub struct Cursor {\r\n    #[inspector(min = 0.0)]\r\n    pub reach: f32,\r\n    #[inspector(min = 0.0)]\r\n    pub default_reach: f32,\r\n    #[inspector(min = 0.0)]\r\n    pub sprint_reach: f32,\r\n    pub movement_behaviour: CursorMovementBehaviour,\r\n    pub log_behaviour: CursorLogBehaviour,\r\n}\r\nimpl Default for Cursor {\r\n    fn default() -> Self {\r\n        Cursor::new_unknown_cursor()\r\n    }\r\n}\r\nimpl Cursor {\r\n    pub fn new_host_cursor() -> Self {\r\n        Self {\r\n            reach: 50.0,\r\n            default_reach: 50.0,\r\n            sprint_reach: 2000.0,\r\n            movement_behaviour: CursorMovementBehaviour::None,\r\n            log_behaviour: CursorLogBehaviour::Errors,\r\n            // log_behaviour: CursorLogBehaviour::ErrorsAndPositionUpdates,\r\n        }\r\n    }\r\n    pub fn new_agent_cursor() -> Self {\r\n        Self {\r\n            reach: 50.0,\r\n            default_reach: 50.0,\r\n            sprint_reach: 2000.0,\r\n            movement_behaviour: CursorMovementBehaviour::None,\r\n            log_behaviour: CursorLogBehaviour::Errors,\r\n            // log_behaviour: CursorLogBehaviour::ErrorsAndPositionUpdates,\r\n        }\r\n    }\r\n    pub fn new_unknown_cursor() -> Self {\r\n        Self {\r\n            reach: 0.0,\r\n            default_reach: 0.0,\r\n            sprint_reach: 0.0,\r\n            movement_behaviour: CursorMovementBehaviour::None,\r\n            log_behaviour: CursorLogBehaviour::Errors,\r\n            // log_behaviour: CursorLogBehaviour::ErrorsAndPositionUpdates,\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\inference_types\\src\\inference_types.rs\r\n\r\n````rust\r\nuse crate::prelude::*;\r\nuse bevy::prelude::*;\r\n\r\n#[derive(Reflect, Debug, Clone, Default, Eq, PartialEq)]\r\npub struct TextInferenceOptions {\r\n    pub num_predict: Option<usize>,\r\n    pub stop: Option<Vec<String>>,\r\n}\r\n\r\n#[derive(Event, Reflect, Debug, Clone)]\r\npub enum TextInferenceEvent {\r\n    Request {\r\n        session_id: Entity,\r\n        prompt: TextPrompt,\r\n    },\r\n    Response {\r\n        session_id: Entity,\r\n        prompt: MaterializedTextPrompt,\r\n        response: String,\r\n    },\r\n}\r\n\r\n#[derive(Event, Reflect, Debug, Clone)]\r\npub enum SpeechInferenceEvent {\r\n    Request {\r\n        session_id: Entity,\r\n        prompt: SpeechPrompt,\r\n    },\r\n    Response {\r\n        session_id: Entity,\r\n        prompt: SpeechPrompt,\r\n        wav: Vec<u8>,\r\n    },\r\n}\r\n\r\n#[derive(Event, Reflect, Debug, Clone)]\r\npub enum TranscriptionInferenceEvent {\r\n    Request {\r\n        session_id: Entity,\r\n        prompt: TranscriptionPrompt,\r\n    },\r\n    Response {\r\n        session_id: Entity,\r\n        prompt: TranscriptionPrompt,\r\n        transcription: String,\r\n    },\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\inference_types\\src\\inference_types_plugin.rs\r\n\r\n````rust\r\nuse crate::prelude::*;\r\nuse bevy::prelude::*;\r\npub struct InferenceTypesPlugin;\r\n\r\nimpl Plugin for InferenceTypesPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<TextPrompt>();\r\n        app.register_type::<MaterializedTextPrompt>();\r\n        app.register_type::<TextInferenceEvent>();\r\n        app.add_event::<TextInferenceEvent>();\r\n\r\n        app.register_type::<SpeechPrompt>();\r\n        app.register_type::<SpeechInferenceEvent>();\r\n        app.add_event::<SpeechInferenceEvent>();\r\n\r\n        app.register_type::<TranscriptionPrompt>();\r\n        app.register_type::<TranscriptionInferenceEvent>();\r\n        app.add_event::<TranscriptionInferenceEvent>();\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\calculator_app_types\\src\\calculator_app_types_plugin.rs\r\n\r\n````rust\r\nuse crate::prelude::*;\r\nuse bevy::prelude::*;\r\n\r\npub struct CalculatorAppTypesPlugin;\r\n\r\nimpl Plugin for CalculatorAppTypesPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<AppWindow>();\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\bevy\\src\\lib.rs\r\n\r\n````rust\r\nmod neg_y;\r\nmod rect_expand;\r\nmod rect_extents;\r\nmod rect_in_rect;\r\nmod rect_scaled;\r\nmod rect_with_properties;\r\nmod translate;\r\nmod vec_into_rect;\r\n\r\npub mod prelude {\r\n    pub use crate::neg_y::*;\r\n    pub use crate::rect_expand::*;\r\n    pub use crate::rect_extents::*;\r\n    pub use crate::rect_in_rect::*;\r\n    pub use crate::rect_scaled::*;\r\n    pub use crate::rect_with_properties::*;\r\n    pub use crate::translate::*;\r\n    pub use crate::vec_into_rect::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\glados_tts\\src\\glados_tts_status_worker_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse crossbeam_channel::bounded;\r\nuse crossbeam_channel::Receiver;\r\nuse crossbeam_channel::Sender;\r\nuse cursor_hero_glados_tts_types::prelude::*;\r\nuse std::thread;\r\n\r\npub struct GladosTtsStatusWorkerPlugin;\r\n\r\nimpl Plugin for GladosTtsStatusWorkerPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Startup, create_worker_thread);\r\n        app.add_systems(Update, events_to_bridge);\r\n        app.add_systems(Update, bridge_to_events);\r\n    }\r\n}\r\n\r\n#[derive(Debug)]\r\nenum GameboundMessage {\r\n    Pong { status: GladosTtsStatus },\r\n}\r\n\r\n#[derive(Debug)]\r\nenum ThreadboundMessage {\r\n    Ping,\r\n    Startup,\r\n}\r\n\r\n#[derive(Resource)]\r\nstruct Bridge {\r\n    pub sender: Sender<ThreadboundMessage>,\r\n    pub receiver: Receiver<GameboundMessage>,\r\n}\r\n\r\nfn create_worker_thread(mut commands: Commands) {\r\n    let (game_tx, game_rx) = bounded::<_>(10);\r\n    let (thread_tx, thread_rx) = bounded::<_>(10);\r\n    commands.insert_resource(Bridge {\r\n        sender: thread_tx,\r\n        receiver: game_rx,\r\n    });\r\n\r\n    let game_tx_clone = game_tx.clone();\r\n    thread::Builder::new()\r\n        .name(\"GLaDOS TTS status thread\".to_string())\r\n        .spawn(move || {\r\n            let rt = tokio::runtime::Runtime::new().unwrap();\r\n            rt.block_on(async {\r\n                let game_tx = game_tx_clone;\r\n                loop {\r\n                    let msg = match thread_rx.recv() {\r\n                        Ok(msg) => msg,\r\n                        Err(_) => {\r\n                            error!(\"Threadbound channel failure, exiting\");\r\n                            break;\r\n                        }\r\n                    };\r\n                    match msg {\r\n                        ThreadboundMessage::Ping => {\r\n                            debug!(\"Worker received ping request, pinging GladosTts API\");\r\n                            let status = match crate::glados_tts::get_status().await {\r\n                                Ok(status) => status,\r\n                                Err(e) => {\r\n                                    error!(\"Failed to get status: {:?}\", e);\r\n                                    GladosTtsStatus::Unknown\r\n                                }\r\n                            };\r\n                            if let Err(e) = game_tx.send(GameboundMessage::Pong { status }) {\r\n                                error!(\"Gamebound channel failure, exiting: {}\", e);\r\n                                break;\r\n                            }\r\n                        }\r\n                        ThreadboundMessage::Startup => {\r\n                            debug!(\"Worker received startup request, starting GladosTts API\");\r\n                            if let Err(e) = crate::glados_tts::start() {\r\n                                error!(\"Failed to start: {:?}\", e);\r\n                            };\r\n                        }\r\n                    }\r\n                    std::thread::sleep(std::time::Duration::from_millis(50));\r\n                }\r\n            });\r\n        })\r\n        .expect(\"Failed to spawn thread\");\r\n}\r\n\r\nfn events_to_bridge(\r\n    bridge: ResMut<Bridge>,\r\n    mut ping_events: EventReader<GladosTtsPingEvent>,\r\n    mut status_events: EventReader<GladosTtsStatusEvent>,\r\n) {\r\n    // Detect ping requests\r\n    for event in ping_events.read() {\r\n        let GladosTtsPingEvent::Ping = event else {\r\n            continue;\r\n        };\r\n        let msg = ThreadboundMessage::Ping;\r\n        debug!(\"Sending bridge message: {:?}\", msg);\r\n        if let Err(e) = bridge.sender.send(msg) {\r\n            error!(\"Threadbound channel failure: {}\", e);\r\n        }\r\n    }\r\n\r\n    // Detect startup requests\r\n    let starting = status_events\r\n        .read()\r\n        .any(|event| matches!(event, GladosTtsStatusEvent::Startup));\r\n    if starting {\r\n        status_events.clear();\r\n        let msg = ThreadboundMessage::Startup;\r\n        debug!(\"Sending bridge message: {:?}\", msg);\r\n        if let Err(e) = bridge.sender.send(msg) {\r\n            error!(\"Threadbound channel failure: {}\", e);\r\n        }\r\n    }\r\n}\r\n\r\nfn bridge_to_events(bridge: ResMut<Bridge>, mut events: EventWriter<GladosTtsPingEvent>) {\r\n    for msg in bridge.receiver.try_iter() {\r\n        match msg {\r\n            GameboundMessage::Pong { status } => {\r\n                let event = GladosTtsPingEvent::Pong { status };\r\n                debug!(\"Received bridge response, sending game event {:?}\", event);\r\n                events.send(event);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\fullscreen_tool\\src\\fullscreen_tool_populate_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse bevy::window::PrimaryWindow;\r\nuse cursor_hero_fullscreen_tool_types::prelude::*;\r\nuse cursor_hero_toolbelt_types::prelude::*;\r\nuse cursor_hero_tools::tool_spawning::NoInputs;\r\nuse cursor_hero_tools::tool_spawning::ToolSpawnConfig;\r\n\r\npub struct FullscreenToolPopulatePlugin;\r\n\r\nimpl Plugin for FullscreenToolPopulatePlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Update, handle_toolbelt_events);\r\n    }\r\n}\r\n\r\nfn handle_toolbelt_events(\r\n    mut commands: Commands,\r\n    asset_server: Res<AssetServer>,\r\n    mut reader: EventReader<ToolbeltPopulateEvent>,\r\n    window_query: Query<&Window, With<PrimaryWindow>>,\r\n) {\r\n    for event in reader.read() {\r\n        let ToolbeltLoadout::WindowPosition = event.loadout else {\r\n            continue;\r\n        };\r\n\r\n        let mode = window_query\r\n            .iter()\r\n            .map(|w| w.mode)\r\n            .next()\r\n            .unwrap_or_default();\r\n        let state = FullscreenTool::state_for_mode(mode);\r\n        debug!(\"Window: {:?}, tool: {:?}\", mode, state);\r\n        ToolSpawnConfig::<_, NoInputs>::new(FullscreenTool, event.id, event)\r\n            .with_src_path(file!().into())\r\n            .guess_name(file!())\r\n            .guess_image(file!(), &asset_server, \"webp\")\r\n            .with_description(\"Toggles fullscreen mode.\")\r\n            .with_starting_state(state)\r\n            .spawn(&mut commands);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\agent\\src\\lib.rs\r\n\r\n````rust\r\npub mod agent_movement_plugin;\r\npub mod agent_plugin;\r\npub mod agent_spawning_plugin;\r\npub mod insert_agent_toolbelt;\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\fullscreen_tool_types\\src\\fullscreen_tool_types_plugin.rs\r\n\r\n````rust\r\nuse crate::prelude::*;\r\nuse bevy::prelude::*;\r\n\r\npub struct FullscreenToolTypesPlugin;\r\n\r\nimpl Plugin for FullscreenToolTypesPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<FullscreenTool>();\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\environment_nametag\\src\\environment_nametag_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse bevy::utils::HashSet;\r\nuse cursor_hero_bevy::prelude::Vec2ToRect;\r\nuse cursor_hero_environment_types::prelude::*;\r\nuse cursor_hero_screen::screen_plugin::Screen;\r\nuse cursor_hero_screen::screen_plugin::ScreenParent;\r\n\r\npub struct EnvironmentNametagPlugin;\r\n\r\nimpl Plugin for EnvironmentNametagPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_event::<NametagEvent>();\r\n        app.add_systems(Update, spawn_nametags_in_new_environments);\r\n        app.add_systems(Update, recalc_new_screen_nametags);\r\n        app.add_systems(Update, handle_nametag_update_event);\r\n        app.add_systems(Update, handle_nametag_recalculate_position_event);\r\n        app.register_type::<Nametag>();\r\n    }\r\n}\r\n\r\n#[allow(clippy::type_complexity)]\r\nfn spawn_nametags_in_new_environments(\r\n    mut environment_reader: EventReader<PopulateEnvironmentEvent>,\r\n    mut commands: Commands,\r\n    environment_query: Query<&Name, Or<(With<HostEnvironment>, With<AgentEnvironment>)>>,\r\n    asset_server: Res<AssetServer>,\r\n) {\r\n    for event in environment_reader.read() {\r\n        let Ok(environment_name) = environment_query.get(event.environment_id) else {\r\n            continue;\r\n        };\r\n        let environment_id = event.environment_id;\r\n        info!(\r\n            \"Spawning nametags for environment {:?} ({})\",\r\n            environment_id, environment_name\r\n        );\r\n        commands.entity(environment_id).with_children(|parent| {\r\n            parent.spawn((\r\n                Text2dBundle {\r\n                    text: Text::from_section(\r\n                        environment_name.to_string(),\r\n                        TextStyle {\r\n                            font_size: 72.0,\r\n                            font: asset_server\r\n                                .load(\"fonts/kenney_kenney-fonts/Fonts/Kenney Future Narrow.ttf\"),\r\n                            color: Color::WHITE,\r\n                        },\r\n                    )\r\n                    .with_alignment(TextAlignment::Center),\r\n                    transform: Transform::from_xyz(0.0, 200.0, 1.0).with_scale(Vec3::splat(4.0)),\r\n                    ..default()\r\n                },\r\n                Nametag,\r\n                Name::new(\"Nametag\"),\r\n            ));\r\n        });\r\n    }\r\n}\r\n\r\nfn recalc_new_screen_nametags(\r\n    mut nametag_events: EventWriter<NametagEvent>,\r\n    screen_query: Query<&Parent, Added<Screen>>,\r\n    screen_parent_query: Query<&Parent, With<ScreenParent>>,\r\n) {\r\n    for new_screen_parent_id in screen_query.iter() {\r\n        if let Ok(environment_id) = screen_parent_query.get(new_screen_parent_id.get()) {\r\n            info!(\r\n                \"Detected new screen {:?} in environment {:?}, sending recalculate position event\",\r\n                new_screen_parent_id, environment_id\r\n            );\r\n            nametag_events.send(NametagEvent::RecalculatePosition {\r\n                environment_id: environment_id.get(),\r\n            });\r\n        }\r\n    }\r\n}\r\n\r\nfn handle_nametag_update_event(\r\n    mut nametag_events: EventReader<NametagEvent>,\r\n    environment_query: Query<&Children, With<EnvironmentKind>>,\r\n    mut nametag_query: Query<(&mut Text, &mut Transform), With<Nametag>>,\r\n) {\r\n    for nametag_event in nametag_events.read() {\r\n        if let NametagEvent::Update {\r\n            environment_id,\r\n            name,\r\n        } = nametag_event\r\n        {\r\n            info!(\r\n                \"Updating nametag for environment {:?} to {}\",\r\n                environment_id, name\r\n            );\r\n            if let Ok(environment_children) = environment_query.get(*environment_id) {\r\n                for child in environment_children.iter() {\r\n                    if let Ok((mut nametag_text, _)) = nametag_query.get_mut(*child) {\r\n                        nametag_text.sections[0].value = name.clone();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n#[allow(clippy::type_complexity)]\r\nfn handle_nametag_recalculate_position_event(\r\n    mut nametag_events: EventReader<NametagEvent>,\r\n    environment_query: Query<&Children, With<EnvironmentKind>>,\r\n    mut nametag_query: Query<(&mut Text, &mut Transform), (With<Nametag>, Without<Screen>)>,\r\n    screen_parent_query: Query<&Children, With<ScreenParent>>,\r\n    screen_query: Query<(&Sprite, &GlobalTransform), (With<Screen>, Without<Nametag>)>,\r\n) {\r\n    let mut debounce = HashSet::new();\r\n    for nametag_event in nametag_events.read() {\r\n        if let NametagEvent::RecalculatePosition { environment_id } = nametag_event {\r\n            if debounce.contains(environment_id) {\r\n                debug!(\r\n                    \"Debounced recalculate position event for environment {:?}, skipping\",\r\n                    environment_id\r\n                );\r\n                continue;\r\n            }\r\n            info!(\r\n                \"Recalculating nametag position for environment {:?}\",\r\n                environment_id\r\n            );\r\n            debounce.insert(environment_id);\r\n            if let Ok(environment_children) = environment_query.get(*environment_id) {\r\n                let mut max_extents = Rect::default();\r\n                for environment_child_id in environment_children.iter() {\r\n                    // debug!(\r\n                    //     \"Checking environment child {:?} for environment {:?}\",\r\n                    //     environment_child_id, environment_id\r\n                    // );\r\n                    if let Ok(screen_parent_children) =\r\n                        screen_parent_query.get(*environment_child_id)\r\n                    {\r\n                        debug!(\r\n                            \"Found screen parent children {:?} for environment {:?}\",\r\n                            screen_parent_children, environment_id\r\n                        );\r\n                        for screen_id in screen_parent_children.iter() {\r\n                            if let Ok((screen_sprite, screen_transform)) =\r\n                                screen_query.get(*screen_id)\r\n                            {\r\n                                if let Some(screen_size) = screen_sprite.custom_size {\r\n                                    max_extents =\r\n                                        max_extents.union(screen_size.as_size_of_rect_with_center(\r\n                                            &screen_transform.translation().xy(),\r\n                                        ));\r\n                                } else {\r\n                                    warn!(\r\n                                        \"Screen {:?} did not have custom size, skipping\",\r\n                                        screen_id\r\n                                    );\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                if max_extents.is_empty() {\r\n                    warn!(\r\n                        \"Max extents for environment {:?} was empty, skipping\",\r\n                        environment_id\r\n                    );\r\n                    continue;\r\n                }\r\n                info!(\r\n                    \"Max extents for environment {:?} is {:?}\",\r\n                    environment_id, max_extents\r\n                );\r\n                for child in environment_children.iter() {\r\n                    if let Ok((_, mut nametag_transform)) = nametag_query.get_mut(*child) {\r\n                        nametag_transform.translation.x = max_extents.center().x;\r\n                        nametag_transform.translation.y = max_extents.max.y + 200.0;\r\n                    }\r\n                }\r\n            } else {\r\n                warn!(\r\n                    \"Could not find environment children for environment {:?}\",\r\n                    environment_id\r\n                );\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\memory\\src\\primary_window_memory_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse bevy::window::PrimaryWindow;\r\nuse bevy::window::RawHandleWrapper;\r\nuse bevy::window::WindowMode;\r\nuse bevy::window::WindowResolution;\r\nuse bevy::winit::WinitWindows;\r\nuse cursor_hero_memory_types::prelude::*;\r\nuse cursor_hero_winutils::win_window::get_window_inner_bounds;\r\nuse serde::Deserialize;\r\nuse serde::Serialize;\r\n\r\npub struct PrimaryWindowMemoryPlugin;\r\n\r\n// TODO: remember maximized status\r\n\r\nimpl Plugin for PrimaryWindowMemoryPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.insert_resource(PrimaryWindowMemoryConfig::default());\r\n        app.add_systems(Update, persist.pipe(handle_persist_errors));\r\n        app.add_systems(Update, restore.pipe(handle_restore_errors));\r\n    }\r\n}\r\n\r\nconst PERSIST_FILE_NAME: &str = \"primary_window.json\";\r\n\r\n// not moved to lib to ensure log contains this module name\r\nfn handle_persist_errors(In(result): In<Result<PersistSuccess, PersistError>>) {\r\n    if let Err(e) = result {\r\n        error!(\"Persist error occurred: {:?}\", e);\r\n    } else if let Ok(PersistSuccess::WritePerformed) = result {\r\n        debug!(\"Persisted succeeded\");\r\n    }\r\n}\r\n\r\nfn handle_restore_errors(In(result): In<Result<RestoreSuccess, RestoreError>>) {\r\n    if let Err(e) = result {\r\n        error!(\"Restore error occurred: {:?}\", e);\r\n    } else if let Ok(RestoreSuccess::Performed) = result {\r\n        info!(\"Restore succeeded\");\r\n    }\r\n}\r\n\r\n#[derive(Debug, Resource, Reflect)]\r\n#[reflect(Resource)]\r\nstruct PrimaryWindowMemoryConfig {\r\n    pub debounce_timer: Timer,\r\n}\r\nimpl Default for PrimaryWindowMemoryConfig {\r\n    fn default() -> Self {\r\n        Self {\r\n            debounce_timer: Timer::from_seconds(10.0, TimerMode::Repeating),\r\n        }\r\n    }\r\n}\r\n\r\n#[derive(Debug, Serialize, Deserialize, PartialEq, Clone, Copy)]\r\nstruct DiskData {\r\n    resolution: Vec2,\r\n    position: IVec2,\r\n    mode: WindowMode,\r\n}\r\n\r\nfn persist(\r\n    mut config: ResMut<PrimaryWindowMemoryConfig>,\r\n    memory_config: Res<MemoryConfig>,\r\n    time: Res<Time>,\r\n    window_query: Query<(Entity, &RawHandleWrapper, &Window), With<PrimaryWindow>>,\r\n    winit_windows: NonSend<WinitWindows>,\r\n    mut debounce: Local<Option<DiskData>>,\r\n) -> Result<PersistSuccess, PersistError> {\r\n    if !config.debounce_timer.tick(time.delta()).just_finished() {\r\n        return Ok(PersistSuccess::Cooldown);\r\n    }\r\n\r\n    let (window_id, window_handle, window) =\r\n        window_query.get_single().map_err(|_| PersistError::Query)?;\r\n\r\n    let winit_window = winit_windows\r\n        .get_window(window_id)\r\n        .ok_or(PersistError::Query)?;\r\n\r\n    if winit_window.is_minimized().unwrap_or(false) {\r\n        return Ok(PersistSuccess::NoAction);\r\n    }\r\n    let resolution = Vec2::new(\r\n        window.resolution.physical_width() as f32,\r\n        window.resolution.physical_height() as f32,\r\n    );\r\n    let position = match window.position {\r\n        WindowPosition::At(position) => position,\r\n        _ => {\r\n            let hwnd = match window_handle.window_handle {\r\n                raw_window_handle::RawWindowHandle::Win32(handle) => handle.hwnd as isize,\r\n                _ => return Ok(PersistSuccess::NoAction),\r\n            };\r\n            get_window_inner_bounds(hwnd)\r\n                .map_err(PersistError::WindowBounds)?\r\n                .size()\r\n        }\r\n    };\r\n\r\n    let data = DiskData {\r\n        resolution,\r\n        position,\r\n        mode: window.mode,\r\n    };\r\n    if debounce.is_none() || debounce.as_ref().unwrap() != &data {\r\n        let minimized = position.x == -32000 || position.y == -32000;\r\n        if minimized {\r\n            return Ok(PersistSuccess::NoAction);\r\n        }\r\n        let file = get_persist_file(memory_config.as_ref(), PERSIST_FILE_NAME, Usage::Persist)\r\n            .map_err(PersistError::Io)?;\r\n        write_to_disk(file, data)?;\r\n        *debounce = Some(data);\r\n        Ok(PersistSuccess::WritePerformed)\r\n    } else {\r\n        Ok(PersistSuccess::Debounce)\r\n    }\r\n}\r\n\r\nfn restore(\r\n    memory_config: Res<MemoryConfig>,\r\n    mut window_query: Query<&mut Window, Added<PrimaryWindow>>,\r\n) -> Result<RestoreSuccess, RestoreError> {\r\n    let Ok(mut window) = window_query.get_single_mut() else {\r\n        return Ok(RestoreSuccess::NoAction);\r\n    };\r\n    restore_window(memory_config.as_ref(), &mut window)\r\n}\r\n\r\npub fn restore_window(\r\n    memory_config: &MemoryConfig,\r\n    window: &mut Window,\r\n) -> Result<RestoreSuccess, RestoreError> {\r\n    let file = get_persist_file(memory_config, PERSIST_FILE_NAME, Usage::Restore)\r\n        .map_err(RestoreError::Io)?;\r\n    let data: DiskData = read_from_disk(file)?;\r\n    window.resolution = WindowResolution::from(data.resolution);\r\n    window.position = WindowPosition::At(data.position);\r\n    window.mode = data.mode;\r\n    Ok(RestoreSuccess::Performed)\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\movement_tool_types\\src\\movement_tool_types_plugin.rs\r\n\r\n````rust\r\nuse crate::prelude::*;\r\nuse bevy::prelude::*;\r\n\r\npub struct MovementToolTypesPlugin;\r\n\r\nimpl Plugin for MovementToolTypesPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<MovementTool>();\r\n        app.add_event::<MovementTargetEvent>();\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\movement_tool\\src\\movement_sprint_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse cursor_hero_character_types::prelude::*;\r\nuse cursor_hero_math::prelude::Lerp;\r\nuse cursor_hero_movement_tool_types::prelude::*;\r\nuse cursor_hero_sprint_tool_types::sprint_tool_types_plugin::SprintEvent;\r\nuse cursor_hero_toolbelt_types::prelude::*;\r\nuse itertools::Itertools;\r\npub struct MovementSprintPlugin;\r\n\r\nimpl Plugin for MovementSprintPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Update, handle_sprint_events);\r\n    }\r\n}\r\n\r\nfn handle_sprint_events(\r\n    mut sprint_events: EventReader<SprintEvent>,\r\n    character_query: Query<&Children, With<Character>>,\r\n    toolbelt_query: Query<&Children, With<Toolbelt>>,\r\n    mut tool_query: Query<&mut MovementTool>,\r\n) {\r\n    for event in sprint_events.read() {\r\n        let character_id = match event {\r\n            SprintEvent::Active { character_id, .. } => character_id,\r\n            SprintEvent::Stop { character_id } => character_id,\r\n        };\r\n        let Ok(character) = character_query.get(*character_id) else {\r\n            warn!(\"Character {:?} does not exist\", character_id);\r\n            continue;\r\n        };\r\n        let character_kids = character;\r\n\r\n        let tool_ids = character_kids\r\n            .iter()\r\n            .filter_map(|kid| toolbelt_query.get(*kid).ok())\r\n            .flat_map(|toolbelt| toolbelt.iter())\r\n            .filter(|kid| tool_query.contains(**kid))\r\n            .cloned()\r\n            .collect_vec();\r\n\r\n        match event {\r\n            SprintEvent::Active { throttle, .. } => {\r\n                let mut iter = tool_query.iter_many_mut(&tool_ids);\r\n                while let Some(mut tool) = iter.fetch_next() {\r\n                    tool.speed = (tool.default_speed, tool.sprint_speed).lerp(*throttle);\r\n                }\r\n            }\r\n            SprintEvent::Stop { .. } => {\r\n                let mut iter = tool_query.iter_many_mut(&tool_ids);\r\n                while let Some(mut tool) = iter.fetch_next() {\r\n                    tool.speed = tool.default_speed;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\inference_types\\src\\lib.rs\r\n\r\n````rust\r\npub mod inference_types;\r\npub mod inference_types_plugin;\r\npub mod prompt_types;\r\n\r\npub mod prelude {\r\n    pub use crate::inference_types::*;\r\n    pub use crate::inference_types_plugin::InferenceTypesPlugin;\r\n    pub use crate::prompt_types::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\data\\src\\sounds.rs\r\n\r\n````rust\r\n/*\r\n * WARNING: THIS FILE IS AUTOGENERATED\r\n * DO NOT EDIT THIS FILE DIRECTLY\r\n *\r\n */\r\npub const PRESSURE_PLATE_ACTIVATION_DURATION: f32 = 1.84;\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\data\\src\\lib.rs\r\n\r\n````rust\r\npub mod paths;\r\npub mod sounds;\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\inference\\src\\lib.rs\r\n\r\n````rust\r\npub mod inference_plugin;\r\npub mod prompt_asset_plugin;\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\bevy\\src\\rect_expand.rs\r\n\r\n````rust\r\nuse bevy::math::IRect;\r\nuse bevy::math::IVec2;\r\n\r\nuse cursor_hero_math::prelude::Corner;\r\npub trait IExpandable {\r\n    fn expand(&self, amount: IVec2) -> IRect;\r\n    fn expand_from(&self, corner: Corner, amount: IVec2) -> IRect;\r\n}\r\nimpl IExpandable for IRect {\r\n    fn expand(&self, amount: IVec2) -> IRect {\r\n        IRect::from_center_size(self.center(), self.size() + amount)\r\n    }\r\n    fn expand_from(&self, corner: Corner, amount: IVec2) -> IRect {\r\n        match corner {\r\n            Corner::TopLeft => IRect {\r\n                min: self.min - amount,\r\n                max: self.max,\r\n            },\r\n            Corner::TopRight => IRect {\r\n                min: self.min - IVec2::new(0, amount.y),\r\n                max: self.max + IVec2::new(amount.x, 0),\r\n            },\r\n            Corner::BottomLeft => IRect {\r\n                min: self.min - IVec2::new(amount.x, 0),\r\n                max: self.max + IVec2::new(0, amount.y),\r\n            },\r\n            Corner::BottomRight => IRect {\r\n                min: self.min,\r\n                max: self.max + amount,\r\n            },\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\environment_nametag\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_environment_nametag\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\ncursor_hero_environment = { workspace = true}\r\ncursor_hero_bevy = { workspace = true}\r\ncursor_hero_screen = { workspace = true}\r\ncursor_hero_environment_types = { workspace = true}\r\nbevy = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\hover\\src\\hover_ui_automation_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\npub struct HoverUiAutomationPlugin;\r\n\r\nimpl Plugin for HoverUiAutomationPlugin {\r\n    fn build(&self, _app: &mut App) {\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\movement_tool_types\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_movement_tool_types\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\nleafwing-input-manager = { workspace = true }\r\nbevy-inspector-egui = { workspace = true }\r\ncursor_hero_toolbelt_types = { workspace = true }\r\ncursor_hero_input = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\build.rs\r\n\r\n````rust\r\nextern crate embed_resource;\r\nuse std::env;\r\n// use std::fs;\r\n// use std::path::Path;\r\n\r\nfn main() {\r\n    let target = env::var(\"TARGET\").unwrap();\r\n    if target.contains(\"windows\") {\r\n        embed_resource::compile(\"icon.rc\");\r\n    }\r\n\r\n    // Check if it is a release build\r\n    // let profile = env::var(\"PROFILE\").unwrap();\r\n    // if profile == \"release\" {\r\n    //     // Get the crate version\r\n    //     let version = env::var(\"CARGO_PKG_VERSION\").unwrap();\r\n    //     // Define the original and new binary names\r\n    //     let original_binary_name = \"cursor_hero\"; // Replace with your binary name\r\n    //     let new_binary_name = format!(\"{}_v{}.exe\", original_binary_name, version);\r\n\r\n    //     // Set the output directory (where Cargo puts the compiled binaries)\r\n    //     let out_dir = env::var(\"OUT_DIR\").unwrap();\r\n    //     let target_dir = Path::new(&out_dir)\r\n    //         .parent()\r\n    //         .unwrap()\r\n    //         .parent()\r\n    //         .unwrap()\r\n    //         .parent()\r\n    //         .unwrap();\r\n\r\n    //     // Construct the paths to the original and new binaries\r\n    //     let original_binary_path = target_dir.join(original_binary_name).with_extension(\"exe\");\r\n    //     let new_binary_path = target_dir.join(new_binary_name).with_extension(\"exe\");\r\n\r\n    //     // Copy the binary\r\n    //     fs::copy(original_binary_path, new_binary_path).expect(\"Failed to copy the file\");\r\n    // }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\glados_tts\\src\\glados_tts_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n\r\nuse crate::glados_tts_button_plugin::GladosTtsButtonPlugin;\r\nuse crate::glados_tts_inference_plugin::GladosTtsInferencePlugin;\r\nuse crate::glados_tts_status_plugin::GladosTtsStatusPlugin;\r\nuse crate::glados_tts_status_worker_plugin::GladosTtsStatusWorkerPlugin;\r\n\r\npub struct GladosTtsPlugin;\r\n\r\nimpl Plugin for GladosTtsPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_plugins(GladosTtsInferencePlugin);\r\n        app.add_plugins(GladosTtsButtonPlugin);\r\n        app.add_plugins(GladosTtsStatusPlugin);\r\n        app.add_plugins(GladosTtsStatusWorkerPlugin);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\floaty_nametag_types\\src\\lib.rs\r\n\r\n````rust\r\npub mod floaty_nametag_types;\r\npub mod floaty_nametag_types_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::floaty_nametag_types::*;\r\n    pub use crate::floaty_nametag_types_plugin::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\character\\src\\character_spawning_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n\r\nuse bevy_xpbd_2d::prelude::*;\r\n\r\nuse cursor_hero_bevy::prelude::NegativeYVec2;\r\nuse cursor_hero_camera::camera_plugin::CameraEvent;\r\nuse cursor_hero_character_types::prelude::*;\r\nuse cursor_hero_environment_types::prelude::*;\r\nuse cursor_hero_physics::damping_plugin::MovementDamping;\r\nuse cursor_hero_toolbelt_types::toolbelt_types::ToolbeltBundle;\r\nuse cursor_hero_toolbelt_types::toolbelt_types::ToolbeltLoadout;\r\nuse cursor_hero_toolbelt_types::toolbelt_types::ToolbeltPopulateEvent;\r\nuse cursor_hero_winutils::win_mouse::get_cursor_position;\r\npub struct CharacterSpawningPlugin;\r\n\r\nimpl Plugin for CharacterSpawningPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Startup, spawn_character);\r\n    }\r\n}\r\n\r\nfn spawn_character(\r\n    mut commands: Commands,\r\n    asset_server: Res<AssetServer>,\r\n    mut camera_events: EventWriter<CameraEvent>,\r\n    mut writer: EventWriter<ToolbeltPopulateEvent>,\r\n) {\r\n    let os_cursor_pos = match get_cursor_position() {\r\n        Ok(pos) => pos,\r\n        Err(e) => {\r\n            error!(\r\n                \"Failed to get cursor position, spawning character at (0,0): {}\",\r\n                e\r\n            );\r\n            IVec2::ZERO\r\n        }\r\n    };\r\n    let mut character = commands.spawn((\r\n        SpriteBundle {\r\n            texture: asset_server.load(CharacterAppearance::Focused.get_texture_path()),\r\n            sprite: Sprite {\r\n                custom_size: Some(Vec2::new(50.0, 50.0)),\r\n                ..default()\r\n            },\r\n            transform: Transform::from_translation(os_cursor_pos.as_vec2().neg_y().extend(100.0)),\r\n            ..default()\r\n        },\r\n        Character,\r\n        MainCharacter,\r\n        MovementDamping { factor: 0.90 },\r\n        Name::new(\"Character - (Human) Tume Eena\"),\r\n        // FloatyName {\r\n        //     text: \"Tume Eena\".to_string(),\r\n        //     vertical_offset: 40.0,\r\n        //     appearance: NametagAppearance::Character,\r\n        // },\r\n        RigidBody::Kinematic,\r\n        Collider::capsule(15.0, 12.5),\r\n        TrackEnvironmentTag,\r\n    ));\r\n    camera_events.send(CameraEvent::BeginFollowing {\r\n        target_id: character.id(),\r\n    });\r\n    let character_id = character.id();\r\n    character.with_children(|c_commands| {\r\n        let toolbelt = c_commands.spawn(ToolbeltBundle::default());\r\n        writer.send(ToolbeltPopulateEvent {\r\n            id: toolbelt.id(),\r\n            loadout: ToolbeltLoadout::default(),\r\n        });\r\n        info!(\r\n            \"Sent populate default toolbelt event to fresh main character {:?}\",\r\n            character_id\r\n        );\r\n    });\r\n\r\n    info!(\"Spawned character\");\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\host_fs_types\\src\\lib.rs\r\n\r\n````rust\r\npub mod host_fs_types;\r\npub mod host_fs_types_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::host_fs_types::*;\r\n    pub use crate::host_fs_types_plugin::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\data\\src\\paths.rs\r\n\r\n````rust\r\npub const CURSOR_HERO_GIT_DIR: &str = \"D:/Repos/Games/Cursor-Hero/\";\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\cursor_types\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_cursor_types\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\nbevy-inspector-egui = { workspace = true }\r\n# cursor_hero_toolbelt_types = { workspace = true }\r\nleafwing-input-manager = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\floaty_nametag\\src\\floaty_nametag_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse bevy::transform::TransformSystem;\r\nuse bevy_xpbd_2d::prelude::*;\r\nuse cursor_hero_floaty_nametag_types::prelude::*;\r\n\r\npub struct FloatyNametagPlugin;\r\n\r\nimpl Plugin for FloatyNametagPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Update, spawn_nametags);\r\n        app.add_systems(\r\n            PostUpdate,\r\n            update_nametags\r\n                .after(PhysicsSet::Sync)\r\n                .before(TransformSystem::TransformPropagate),\r\n        );\r\n    }\r\n}\r\n\r\nfn spawn_nametags(\r\n    mut commands: Commands,\r\n    query: Query<(Entity, &GlobalTransform, &FloatyName), Added<FloatyName>>,\r\n    asset_server: Res<AssetServer>,\r\n) {\r\n    for entry in query.iter() {\r\n        let (owner, transform, name) = entry;\r\n        debug!(\"Spawning nametag for {:?}\", name.text.clone());\r\n        let ratio = 2.0;\r\n        commands.spawn((\r\n            Name::new(format!(\"FloatyNametag: {}\", name.text.clone())),\r\n            FloatyNametag { owner },\r\n            Text2dBundle {\r\n                text: Text::from_section(\r\n                    name.text.clone(),\r\n                    TextStyle {\r\n                        font: asset_server.load(name.appearance.get_font_path()),\r\n                        font_size: 18.0 * ratio,\r\n                        color: name.appearance.get_text_color(),\r\n                    },\r\n                )\r\n                .with_alignment(TextAlignment::Center),\r\n                transform: Transform::from_translation(\r\n                    transform.translation() + Vec3::new(0.0, name.vertical_offset, 0.0),\r\n                )\r\n                .with_scale(Vec3::new(1.0 / ratio, 1.0 / ratio, 1.0)),\r\n                ..default()\r\n            },\r\n        ));\r\n    }\r\n}\r\n\r\nfn update_nametags(\r\n    mut commands: Commands,\r\n    owner_query: Query<(Ref<GlobalTransform>, Ref<FloatyName>), Without<FloatyNametag>>,\r\n    mut floaty_query: Query<\r\n        (Entity, &mut Text, &mut Transform, &FloatyNametag),\r\n        Without<FloatyName>,\r\n    >,\r\n) {\r\n    for floaty in floaty_query.iter_mut() {\r\n        let (entity, mut text, mut transform, nametag) = floaty;\r\n        let Ok(owner) = owner_query.get(nametag.owner) else {\r\n            debug!(\"Owner of nametag {:?} not found, despawning\", nametag.owner);\r\n            commands.entity(entity).despawn_recursive();\r\n            continue;\r\n        };\r\n        let (owner_transform, owner_floaty_name) = owner;\r\n        if !owner_transform.is_changed() && !owner_floaty_name.is_changed() {\r\n            continue;\r\n        }\r\n        text.sections[0].value = owner_floaty_name.text.clone();\r\n        transform.translation =\r\n            owner_transform.translation() + Vec3::new(0.0, owner_floaty_name.vertical_offset, 0.0);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\chat\\src\\chat_plugin.rs\r\n\r\n````rust\r\nuse crate::chat_bubble_plugin::ChatBubblePlugin;\r\nuse crate::chat_focus_exclusivity_plugin::ChatFocusExclusivityPlugin;\r\nuse crate::chat_input_buffer_plugin::ChatInputBufferPlugin;\r\nuse crate::chat_sfx_plugin::ChatSfxPlugin;\r\nuse crate::chat_tool_plugin::ChatToolPlugin;\r\nuse bevy::prelude::*;\r\npub struct ChatPlugin;\r\n\r\nimpl Plugin for ChatPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_plugins(ChatToolPlugin);\r\n        app.add_plugins(ChatFocusExclusivityPlugin);\r\n        app.add_plugins(ChatBubblePlugin);\r\n        app.add_plugins(ChatInputBufferPlugin);\r\n        app.add_plugins(ChatSfxPlugin);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\fullscreen_tool\\src\\lib.rs\r\n\r\n````rust\r\npub mod fullscreen_tool_plugin;\r\npub mod fullscreen_tool_populate_plugin;\r\npub mod fullscreen_tool_tick_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::fullscreen_tool_plugin::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\host_fs_types\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_host_fs_types\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\floaty_nametag_types\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_floaty_nametag_types\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\chat\\src\\chat_tool_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse cursor_hero_character_types::prelude::*;\r\nuse cursor_hero_chat_types::prelude::*;\r\nuse cursor_hero_toolbelt_types::prelude::*;\r\nuse cursor_hero_tools::prelude::*;\r\nuse cursor_hero_voice_to_text_types::voice_to_text_types::VoiceToTextTranscriptionEvent;\r\nuse leafwing_input_manager::prelude::*;\r\n\r\npub struct ChatToolPlugin;\r\n\r\nimpl Plugin for ChatToolPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_plugins(InputManagerPlugin::<ChatToolAction>::default());\r\n        app.add_systems(Update, toolbelt_events);\r\n        app.add_systems(Update, handle_input);\r\n        app.add_systems(Update, handle_voice_events);\r\n    }\r\n}\r\n\r\nfn toolbelt_events(\r\n    mut commands: Commands,\r\n    asset_server: Res<AssetServer>,\r\n    mut reader: EventReader<ToolbeltPopulateEvent>,\r\n) {\r\n    for event in reader.read() {\r\n        let ToolbeltLoadout::Default = event.loadout else {\r\n            continue;\r\n        };\r\n        {\r\n            ToolSpawnConfig::<ChatTool, ChatToolAction>::new(ChatTool::default(), event.id, event)\r\n                .with_src_path(file!().into())\r\n                .guess_name(file!())\r\n                .guess_image(file!(), &asset_server, \"webp\")\r\n                .with_description(\"Send chat messages into the world\")\r\n                .spawn(&mut commands);\r\n        }\r\n    }\r\n}\r\n\r\nfn handle_input(\r\n    mut tool_query: Query<\r\n        (Entity, &ActionState<ChatToolAction>, &Parent, &mut ChatTool),\r\n        With<ActiveTool>,\r\n    >,\r\n    toolbelt_query: Query<&Parent, With<Toolbelt>>,\r\n    mut character_query: Query<Entity, With<Character>>,\r\n    mut chat_events: EventWriter<ChatEvent>,\r\n    mut chat_input_events: EventWriter<ChatInputEvent>,\r\n) {\r\n    for tool in tool_query.iter_mut() {\r\n        let (tool_id, tool_actions, tool_parent, mut tool) = tool;\r\n\r\n        let Ok(toolbelt) = toolbelt_query.get(tool_parent.get()) else {\r\n            warn!(\"Tool not inside a toolbelt?\");\r\n            continue;\r\n        };\r\n        let toolbelt_parent = toolbelt;\r\n        let Ok(character) = character_query.get_mut(toolbelt_parent.get()) else {\r\n            warn!(\"Toolbelt parent not a character?\");\r\n            continue;\r\n        };\r\n        let character_id = character;\r\n\r\n        if tool_actions.just_pressed(ChatToolAction::Focus) && !tool.focused {\r\n            let event = ChatInputEvent::Focus {\r\n                tool_id,\r\n                toolbelt_id: tool_parent.get(),\r\n                character_id,\r\n            };\r\n            info!(\"Sending focus event {:?}\", event);\r\n            chat_input_events.send(event);\r\n        } else if tool_actions.just_pressed(ChatToolAction::Unfocus) && tool.focused {\r\n            let event = ChatInputEvent::Unfocus {\r\n                tool_id,\r\n                toolbelt_id: tool_parent.get(),\r\n                character_id,\r\n            };\r\n            info!(\"Sending unfocus event {:?}\", event);\r\n            chat_input_events.send(event);\r\n        } else if tool_actions.just_pressed(ChatToolAction::Submit) && tool.focused {\r\n            let message = tool.buffer.clone();\r\n            if !message.is_empty() {\r\n                tool.buffer.clear();\r\n\r\n                let event = ChatEvent::Chat {\r\n                    character_id,\r\n                    message,\r\n                };\r\n                info!(\"Sending chat event {:?}\", event);\r\n                chat_events.send(event);\r\n            }\r\n            let event = ChatInputEvent::Unfocus {\r\n                tool_id,\r\n                toolbelt_id: tool_parent.get(),\r\n                character_id,\r\n            };\r\n            info!(\"Sending unfocus event {:?}\", event);\r\n            chat_input_events.send(event);\r\n        }\r\n    }\r\n}\r\n\r\nfn handle_voice_events(\r\n    mut voice_events: EventReader<VoiceToTextTranscriptionEvent>,\r\n    mut chat_events: EventWriter<ChatEvent>,\r\n    character_query: Query<Entity, With<MainCharacter>>,\r\n) {\r\n    let character_id = match character_query.get_single() {\r\n        Ok(character_id) => character_id,\r\n        Err(e) => {\r\n            warn!(\"Failed to get main character: {:?}\", e);\r\n            return;\r\n        }\r\n    };\r\n\r\n    for event in voice_events.read() {\r\n        let VoiceToTextTranscriptionEvent::Received { transcription } = event;\r\n        if transcription.is_empty() {\r\n            continue;\r\n        }\r\n        let event = ChatEvent::Chat {\r\n            character_id,\r\n            message: transcription.clone(),\r\n        };\r\n        info!(\"Sending chat event {:?}\", event);\r\n        chat_events.send(event);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\floaty_nametag\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_floaty_nametag\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\ncursor_hero_floaty_nametag_types = { workspace = true }\r\nbevy_xpbd_2d = { workspace = true }\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\environment\\src\\environment_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse cursor_hero_environment_types::prelude::*;\r\n\r\nuse crate::environment_tracker_plugin::EnvironmentTrackerPlugin;\r\n\r\npub struct EnvironmentPlugin;\r\n\r\nimpl Plugin for EnvironmentPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_plugins(EnvironmentTrackerPlugin);\r\n        app.add_systems(Startup, send_create_host_event);\r\n        app.add_systems(Startup, send_create_game_event);\r\n        app.add_systems(Update, handle_create_events);\r\n        app.add_systems(Update, send_populate_events);\r\n    }\r\n}\r\n\r\nfn send_create_host_event(mut events: EventWriter<CreateEnvironmentRequestEvent>) {\r\n    events.send(CreateEnvironmentRequestEvent {\r\n        kind: EnvironmentKind::Host,\r\n        origin: Vec2::new(0.0, 0.0),\r\n    });\r\n}\r\n\r\nfn send_create_game_event(mut events: EventWriter<CreateEnvironmentRequestEvent>) {\r\n    events.send(CreateEnvironmentRequestEvent {\r\n        kind: EnvironmentKind::Agent,\r\n        origin: Vec2::new(0.0, -3000.0),\r\n    });\r\n}\r\n\r\n#[allow(clippy::type_complexity)]\r\nfn send_populate_events(\r\n    environment_query: Query<Entity, Added<EnvironmentKind>>,\r\n    mut populate_events: EventWriter<PopulateEnvironmentEvent>,\r\n) {\r\n    for environment in environment_query.iter() {\r\n        let environment_id = environment;\r\n        let event = PopulateEnvironmentEvent { environment_id };\r\n        debug!(\"Sending populate event: {:?}\", event);\r\n        populate_events.send(event);\r\n    }\r\n}\r\n\r\nfn handle_create_events(\r\n    mut commands: Commands,\r\n    mut create_events: EventReader<CreateEnvironmentRequestEvent>,\r\n) {\r\n    for event in create_events.read() {\r\n        info!(\"Creating environment at {:?}\", event.origin);\r\n        let mut c = commands.spawn((\r\n            SpatialBundle {\r\n                transform: Transform::from_translation(event.origin.extend(0.0)),\r\n                ..default()\r\n            },\r\n            event.kind,\r\n            Name::new(event.kind.name().to_string()),\r\n        ));\r\n        match event.kind {\r\n            EnvironmentKind::Host => {\r\n                c.insert(HostEnvironment);\r\n            }\r\n            EnvironmentKind::Agent => {\r\n                c.insert(AgentEnvironment);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\cursor_types\\src\\cursor_reach_types.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n\r\n#[derive(Event, Debug, Reflect)]\r\npub enum CursorReachEvent {\r\n    SetCursor { cursor_id: Entity, reach: f32 },\r\n    SetCursorPercent { cursor_id: Entity, percent: f32 },\r\n    SetCharacter { character_id: Entity, reach: f32 },\r\n    SetCharacterPercent { character_id: Entity, percent: f32 },\r\n    ResetCursor { cursor_id: Entity },\r\n    ResetCharacter { character_id: Entity },\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\input\\src\\input_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n\r\nuse crate::active_input_state_plugin::ActiveInputStatePlugin;\r\nuse crate::update_gamepad_settings::update_gamepad_settings;\r\n\r\npub struct InputPlugin;\r\n\r\nimpl Plugin for InputPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_plugins(ActiveInputStatePlugin);\r\n        app.add_systems(Update, update_gamepad_settings);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\app_types\\src\\lib.rs\r\n\r\n````rust\r\npub mod app_types;\r\npub mod app_types_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::app_types::*;\r\n    pub use crate::app_types_plugin::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\environment_types\\src\\lib.rs\r\n\r\n````rust\r\npub mod environment_types;\r\npub mod environment_types_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::environment_types::*;\r\n    pub use crate::environment_types_plugin::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\chat\\src\\lib.rs\r\n\r\n````rust\r\npub mod chat_bubble_plugin;\r\npub mod chat_focus_exclusivity_plugin;\r\npub mod chat_input_buffer_plugin;\r\npub mod chat_plugin;\r\npub mod chat_sfx_plugin;\r\npub mod chat_tool_plugin;\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\glados_tts\\src\\glados_tts_button_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse bevy_xpbd_2d::prelude::*;\r\nuse cursor_hero_environment_types::prelude::*;\r\nuse cursor_hero_glados_tts_types::prelude::*;\r\nuse cursor_hero_math::prelude::Lerp;\r\nuse cursor_hero_cursor_types::prelude::*;\r\n\r\nuse crate::glados_tts;\r\npub struct GladosTtsButtonPlugin;\r\n\r\nimpl Plugin for GladosTtsButtonPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Update, populate_new_host_environments);\r\n        app.add_systems(Update, update_visuals);\r\n        app.add_systems(Update, status_button_click);\r\n        app.add_systems(Update, vscode_button_click);\r\n        app.add_systems(Update, handle_vscode_events);\r\n    }\r\n}\r\n\r\nfn populate_new_host_environments(\r\n    mut commands: Commands,\r\n    mut environment_events: EventReader<PopulateEnvironmentEvent>,\r\n    environment_query: Query<&HostEnvironment>,\r\n    asset_server: Res<AssetServer>,\r\n) {\r\n    for event in environment_events.read() {\r\n        if !environment_query.contains(event.environment_id) {\r\n            continue;\r\n        }\r\n        info!(\r\n            \"Adding button to new host environment {:?}\",\r\n            event.environment_id\r\n        );\r\n        commands\r\n            .entity(event.environment_id)\r\n            .with_children(|parent| {\r\n                parent\r\n                    .spawn((\r\n                        GladosTtsStatusButton::default(),\r\n                        Name::new(\"GLaDOS TTS Button\"),\r\n                        SpriteBundle {\r\n                            sprite: Sprite {\r\n                                custom_size: Some(Vec2::new(200.0, 100.0)),\r\n                                color: Color::PURPLE,\r\n                                ..default()\r\n                            },\r\n                            transform: Transform::from_translation(Vec3::new(\r\n                                1920.0 / 2.0 - 600.0,\r\n                                -1080.0 - 200.0,\r\n                                0.0,\r\n                            )),\r\n                            ..default()\r\n                        },\r\n                        Clickable,\r\n                        Hoverable,\r\n                        RigidBody::Static,\r\n                        Sensor,\r\n                        Collider::cuboid(200.0, 100.0),\r\n                    ))\r\n                    .with_children(|parent| {\r\n                        parent.spawn((Text2dBundle {\r\n                            text: Text::from_section(\r\n                                \"GLaDOS TTS Server Control\".to_string(),\r\n                                TextStyle {\r\n                                    font: asset_server.load(\"fonts/FiraSans-Bold.ttf\"),\r\n                                    font_size: 32.0,\r\n                                    color: Color::WHITE,\r\n                                },\r\n                            )\r\n                            .with_alignment(TextAlignment::Center),\r\n                            transform: Transform::from_xyz(0.0, 70.0, 1.0),\r\n                            ..default()\r\n                        },));\r\n                    });\r\n                parent\r\n                    .spawn((\r\n                        GladosTtsVscodeButton::default(),\r\n                        Name::new(\"GLaDOS TTS VSCode Button\"),\r\n                        SpriteBundle {\r\n                            sprite: Sprite {\r\n                                custom_size: Some(Vec2::new(200.0, 100.0)),\r\n                                color: Color::rgb(0.0, 0.6, 0.8),\r\n                                ..default()\r\n                            },\r\n                            transform: Transform::from_translation(Vec3::new(\r\n                                1920.0 / 2.0 - 600.0,\r\n                                -1080.0 - 350.0,\r\n                                0.0,\r\n                            )),\r\n                            ..default()\r\n                        },\r\n                        Clickable,\r\n                        Hoverable,\r\n                        RigidBody::Static,\r\n                        Sensor,\r\n                        Collider::cuboid(200.0, 100.0),\r\n                    ))\r\n                    .with_children(|parent| {\r\n                        parent.spawn((Text2dBundle {\r\n                            text: Text::from_section(\r\n                                \"open in vscode\".to_string(),\r\n                                TextStyle {\r\n                                    font: asset_server.load(\"fonts/FiraSans-Bold.ttf\"),\r\n                                    font_size: 32.0,\r\n                                    color: Color::WHITE,\r\n                                },\r\n                            )\r\n                            .with_alignment(TextAlignment::Center),\r\n                            transform: Transform::from_xyz(0.0, 0.0, 1.0),\r\n                            ..default()\r\n                        },));\r\n                    });\r\n            });\r\n    }\r\n}\r\n\r\nfn update_visuals(\r\n    mut events: EventReader<GladosTtsStatusEvent>,\r\n    mut button_query: Query<(&mut Sprite, &Children, &mut GladosTtsStatusButton)>,\r\n    mut button_text_query: Query<&mut Text>,\r\n) {\r\n    for event in events.read() {\r\n        let GladosTtsStatusEvent::Changed { new_value: status } = event else {\r\n            continue;\r\n        };\r\n        debug!(\"Updating GladosTts Server Control visuals to {:?}\", status);\r\n        for button in button_query.iter_mut() {\r\n            let (mut button_sprite, button_children, mut button) = button;\r\n            button.visual_state = match button.visual_state {\r\n                GladosTtsStatusButtonVisualState::Default { .. } => {\r\n                    GladosTtsStatusButtonVisualState::Default { status: *status }\r\n                }\r\n                GladosTtsStatusButtonVisualState::Hovered { .. } => {\r\n                    GladosTtsStatusButtonVisualState::Hovered { status: *status }\r\n                }\r\n                GladosTtsStatusButtonVisualState::Pressed { .. } => {\r\n                    GladosTtsStatusButtonVisualState::Pressed { status: *status }\r\n                }\r\n            };\r\n            match status {\r\n                GladosTtsStatus::Alive => {\r\n                    button_sprite.color = Color::GREEN;\r\n                }\r\n                GladosTtsStatus::Dead => {\r\n                    button_sprite.color = Color::RED;\r\n                }\r\n                GladosTtsStatus::Unknown => {\r\n                    button_sprite.color = Color::PURPLE;\r\n                }\r\n                GladosTtsStatus::Starting { instant, timeout } => {\r\n                    button_sprite.color = Color::YELLOW\r\n                        * (1.0, 0.1).lerp(instant.elapsed().as_secs_f32() / timeout.as_secs_f32());\r\n                }\r\n            }\r\n            for child in button_children.iter() {\r\n                if let Ok(mut text) = button_text_query.get_mut(*child) {\r\n                    match status {\r\n                        GladosTtsStatus::Alive => {\r\n                            text.sections[0].value =\r\n                                \"GLaDOS TTS Server Control (Alive)\".to_string();\r\n                        }\r\n                        GladosTtsStatus::Dead => {\r\n                            text.sections[0].value = \"GLaDOS TTS Server Control (Dead)\".to_string();\r\n                        }\r\n                        GladosTtsStatus::Unknown => {\r\n                            text.sections[0].value =\r\n                                \"GLaDOS TTS Server Control (Unknown)\".to_string();\r\n                        }\r\n                        GladosTtsStatus::Starting { instant, .. } => {\r\n                            text.sections[0].value = format!(\r\n                                \"GLaDOS TTS Server Control (Starting {}s ago)\",\r\n                                instant.elapsed().as_secs()\r\n                            );\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    for button in button_query.iter_mut() {\r\n        let (mut sprite, children, button) = button;\r\n        // if the visual state status is starting, update the text to show the time elapsed\r\n        let (GladosTtsStatusButtonVisualState::Default {\r\n            status: GladosTtsStatus::Starting { instant, timeout },\r\n        }\r\n        | GladosTtsStatusButtonVisualState::Hovered {\r\n            status: GladosTtsStatus::Starting { instant, timeout },\r\n        }\r\n        | GladosTtsStatusButtonVisualState::Pressed {\r\n            status: GladosTtsStatus::Starting { instant, timeout },\r\n        }) = button.visual_state\r\n        else {\r\n            continue;\r\n        };\r\n        sprite.color = Color::YELLOW\r\n            * (1.0, 0.1).lerp(instant.elapsed().as_secs_f32() / timeout.as_secs_f32());\r\n        for child in children.iter() {\r\n            if let Ok(mut text) = button_text_query.get_mut(*child) {\r\n                text.sections[0].value = format!(\r\n                    \"GladosTts Server Control (Starting {}s ago)\",\r\n                    instant.elapsed().as_secs()\r\n                );\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfn status_button_click(\r\n    mut click_events: EventReader<ClickEvent>,\r\n    button_query: Query<&GladosTtsStatusButton>,\r\n    mut status_events: EventWriter<GladosTtsStatusEvent>,\r\n) {\r\n    for event in click_events.read() {\r\n        let ClickEvent::Clicked {\r\n            target_id,\r\n            cursor_id: _,\r\n            way,\r\n        } = event\r\n        else {\r\n            continue;\r\n        };\r\n        if way != &Way::Left {\r\n            continue;\r\n        }\r\n        if let Ok(button) = button_query.get(*target_id) {\r\n            info!(\"GladosTts Server Control clicked\");\r\n            // if the button visual status is alive, do nothing\r\n            match button.visual_state {\r\n                GladosTtsStatusButtonVisualState::Default {\r\n                    status: GladosTtsStatus::Alive,\r\n                }\r\n                | GladosTtsStatusButtonVisualState::Hovered {\r\n                    status: GladosTtsStatus::Alive,\r\n                }\r\n                | GladosTtsStatusButtonVisualState::Pressed {\r\n                    status: GladosTtsStatus::Alive,\r\n                } => {\r\n                    warn!(\"GladosTts Server Control is already alive\");\r\n                    continue;\r\n                }\r\n                _ => {}\r\n            }\r\n            let event = GladosTtsStatusEvent::Startup;\r\n            debug!(\"Sending event {:?}\", event);\r\n            status_events.send(event);\r\n        }\r\n    }\r\n}\r\n\r\nfn vscode_button_click(\r\n    mut click_events: EventReader<ClickEvent>,\r\n    button_query: Query<&GladosTtsVscodeButton>,\r\n    mut vscode_events: EventWriter<GladosTtsVscodeEvent>,\r\n) {\r\n    for event in click_events.read() {\r\n        let ClickEvent::Clicked {\r\n            target_id,\r\n            cursor_id: _,\r\n            way,\r\n        } = event\r\n        else {\r\n            continue;\r\n        };\r\n        if way != &Way::Left {\r\n            continue;\r\n        }\r\n        if button_query.get(*target_id).is_ok() {\r\n            info!(\"GladosTts vscode clicked\");\r\n            let event = GladosTtsVscodeEvent::Startup;\r\n            debug!(\"Sending event {:?}\", event);\r\n            vscode_events.send(event);\r\n        }\r\n    }\r\n}\r\n\r\nfn handle_vscode_events(mut vscode_events: EventReader<GladosTtsVscodeEvent>) {\r\n    let should_start = vscode_events\r\n        .read()\r\n        .any(|event| matches!(event, GladosTtsVscodeEvent::Startup));\r\n    if should_start {\r\n        info!(\"Opening vscode\");\r\n        if let Err(e) = glados_tts::start_vscode() {\r\n            error!(\"Failed to start vscode: {:?}\", e);\r\n        }\r\n    }\r\n    vscode_events.clear();\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\brick_types\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_brick_types\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\app\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_app\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\ncursor_hero_app_types = { workspace = true }\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\input\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_input\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\ncursor_hero_host_event_types = { workspace = true}\r\ncursor_hero_cursor_types = { workspace = true}\r\nleafwing-input-manager = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\app\\src\\lib.rs\r\n\r\n````rust\r\npub mod app_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::app_plugin::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\glados_tts_types\\src\\glados_tts_types_plugin.rs\r\n\r\n````rust\r\nuse crate::prelude::*;\r\nuse bevy::prelude::*;\r\n\r\npub struct GladosTtsTypesPlugin;\r\n\r\nimpl Plugin for GladosTtsTypesPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<GladosTtsStatus>();\r\n        app.register_type::<GladosTtsStatusButton>();\r\n        app.register_type::<GladosTtsStatusButtonVisualState>();\r\n        app.register_type::<GladosTtsStatusEvent>();\r\n        app.add_event::<GladosTtsStatusEvent>();\r\n\r\n        app.register_type::<GladosTtsPingEvent>();\r\n        app.add_event::<GladosTtsPingEvent>();\r\n\r\n        app.register_type::<GladosTtsVscodeButton>();\r\n        app.register_type::<GladosTtsVscodeButtonVisualState>();\r\n        app.register_type::<GladosTtsVscodeEvent>();\r\n        app.add_event::<GladosTtsVscodeEvent>();\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\icon\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_icon\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\nimage = { workspace = true }\r\nwinit = { workspace = true }\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\input\\src\\update_gamepad_settings.rs\r\n\r\n````rust\r\nuse bevy::input::gamepad::ButtonSettings;\r\nuse bevy::input::gamepad::GamepadConnectionEvent;\r\nuse bevy::input::gamepad::GamepadSettings;\r\nuse bevy::prelude::*;\r\n\r\npub const PRESS_THRESHOLD: f32 = 0.1;\r\npub const RELEASE_THRESHOLD: f32 = 0.08;\r\n\r\n/// Responsible for updating the trigger thresholds for Mining Laser\r\n/// https://github.com/Leafwing-Studios/leafwing-input-manager/issues/405\r\npub fn update_gamepad_settings(\r\n    mut gamepad_events: EventReader<GamepadConnectionEvent>,\r\n    mut gamepad_settings: ResMut<GamepadSettings>,\r\n) {\r\n    gamepad_events.read().for_each(|event| {\r\n        info!(\"Updating Gamepad Settings\");\r\n\r\n        gamepad_settings.button_settings.insert(\r\n            GamepadButton {\r\n                gamepad: event.gamepad,\r\n                button_type: GamepadButtonType::RightTrigger2,\r\n            },\r\n            ButtonSettings::new(PRESS_THRESHOLD, RELEASE_THRESHOLD).unwrap(), //Ok because this would be programmer error\r\n        );\r\n\r\n        gamepad_settings.button_settings.insert(\r\n            GamepadButton {\r\n                gamepad: event.gamepad,\r\n                button_type: GamepadButtonType::LeftTrigger2,\r\n            },\r\n            ButtonSettings::new(PRESS_THRESHOLD, RELEASE_THRESHOLD).unwrap(), //Ok because this would be programmer error\r\n        );\r\n    });\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\cursor\\src\\cursor_spawning_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse bevy::sprite::Anchor;\r\nuse bevy_xpbd_2d::prelude::*;\r\nuse cursor_hero_character_types::prelude::*;\r\nuse cursor_hero_environment_types::environment_types::TrackEnvironmentTag;\r\nuse cursor_hero_cursor_types::prelude::*;\r\nuse leafwing_input_manager::prelude::*;\r\n\r\npub struct CursorSpawningPlugin;\r\n\r\nimpl Plugin for CursorSpawningPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Update, insert_cursor);\r\n    }\r\n}\r\n\r\n#[allow(clippy::type_complexity)]\r\nfn insert_cursor(\r\n    mut commands: Commands,\r\n    asset_server: Res<AssetServer>,\r\n    character: Query<(Entity, Option<&MainCharacter>, Option<&AgentCharacter>), Added<Character>>,\r\n) {\r\n    for character in character.iter() {\r\n        let (character_id, is_main_character, is_agent_character) = character;\r\n        info!(\"Creating cursor for character '{:?}'\", character_id);\r\n        commands.entity(character_id).with_children(|parent| {\r\n            let mut p = parent.spawn((\r\n                Name::new(\"Cursor\"),\r\n                SpriteBundle {\r\n                    texture: asset_server.load(\"textures/cursor.png\"),\r\n                    transform: Transform::from_xyz(0.0, 0.0, 2.0),\r\n                    sprite: Sprite {\r\n                        color: Color::rgb(0.149, 0.549, 0.184),\r\n                        anchor: Anchor::TopLeft,\r\n                        ..default()\r\n                    },\r\n                    ..Default::default()\r\n                },\r\n                TrackEnvironmentTag,\r\n                RigidBody::Dynamic,\r\n                Collider::cuboid(10.0, 10.0),\r\n                Sensor,\r\n            ));\r\n            match (is_main_character.is_some(), is_agent_character.is_some()) {\r\n                (true, false) => {\r\n                    p.insert((\r\n                        MainCursor,\r\n                        Cursor::new_host_cursor(),\r\n                        InputManagerBundle::<CursorAction> {\r\n                            input_map: CursorAction::default_input_map(),\r\n                            action_state: ActionState::default(),\r\n                        },\r\n                    ));\r\n                }\r\n                (false, true) => {\r\n                    p.insert((\r\n                        Cursor::new_agent_cursor(),\r\n                        InputManagerBundle::<CursorAction> {\r\n                            input_map: InputMap::default(),\r\n                            action_state: ActionState::default(),\r\n                        },\r\n                    ));\r\n                }\r\n                (is_main, is_agent) => {\r\n                    error!(\r\n                        \"Character '{:?}' isn't exclusively main or agent: main: {:?}, agent: {:?}\",\r\n                        character_id, is_main, is_agent\r\n                    );\r\n                    p.insert((\r\n                        Cursor::new_unknown_cursor(),\r\n                        InputManagerBundle::<CursorAction> {\r\n                            input_map: InputMap::default(),\r\n                            action_state: ActionState::default(),\r\n                        },\r\n                    ));\r\n                }\r\n            }\r\n        });\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\cursor\\src\\cursor_positioning_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse bevy::transform::TransformSystem;\r\nuse bevy::window::PrimaryWindow;\r\nuse bevy_xpbd_2d::prelude::*;\r\nuse cursor_hero_bevy::prelude::NegativeYVec2;\r\nuse cursor_hero_camera::camera_plugin::MainCamera;\r\nuse cursor_hero_character_types::prelude::*;\r\nuse cursor_hero_environment_types::prelude::*;\r\nuse cursor_hero_input::active_input_state_plugin::InputMethod;\r\nuse cursor_hero_cursor_types::cursor_behaviour_types::CursorMovementBehaviour;\r\nuse cursor_hero_cursor_types::prelude::*;\r\nuse cursor_hero_winutils::win_mouse::set_cursor_position;\r\nuse cursor_hero_winutils::win_window::get_window_bounds;\r\nuse cursor_hero_winutils::win_window::get_window_inner_offset;\r\nuse leafwing_input_manager::prelude::*;\r\n\r\nuse bevy::window::RawHandleWrapper;\r\n\r\npub struct CursorPositioningPlugin;\r\nimpl Plugin for CursorPositioningPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(\r\n            PostUpdate,\r\n            (update_cursor)\r\n                .in_set(CursorSystemSet::Position)\r\n                .after(PhysicsSet::Sync)\r\n                .after(TransformSystem::TransformPropagate),\r\n        );\r\n    }\r\n}\r\n\r\n#[derive(Default, Debug)]\r\nstruct CursorUpdate {\r\n    local_target: Option<Vec2>,\r\n    global_target: Option<Vec2>,\r\n    host_target: Option<IVec2>,\r\n}\r\n\r\n#[derive(Debug)]\r\nstruct DecisionInfo {\r\n    current_behaviour: CursorMovementBehaviour,\r\n    is_main_character: bool,\r\n    in_host_environment: bool,\r\n    stick_in_use: bool,\r\n    active_input_method: InputMethod,\r\n}\r\n\r\n#[allow(clippy::type_complexity)]\r\n#[allow(clippy::too_many_arguments)]\r\nfn update_cursor(\r\n    mut cursor_query: Query<\r\n        (\r\n            &mut Transform,\r\n            &GlobalTransform,\r\n            &mut Position,\r\n            &ActionState<CursorAction>,\r\n            &mut Cursor,\r\n            Option<&EnvironmentTracker>,\r\n            &Parent,\r\n        ),\r\n        (Without<Character>, With<Cursor>),\r\n    >,\r\n    mut character_query: Query<\r\n        (Ref<GlobalTransform>, Option<&MainCharacter>),\r\n        (With<Character>, Without<Cursor>, Without<MainCamera>),\r\n    >,\r\n    camera_query: Query<\r\n        (&Camera, &GlobalTransform),\r\n        (With<MainCamera>, Without<Character>, Without<Cursor>),\r\n    >,\r\n    window_query: Query<(&Window, &RawHandleWrapper), With<PrimaryWindow>>,\r\n    input_method: Res<InputMethod>,\r\n    environment_query: Query<(), With<HostEnvironment>>,\r\n    mut last_known_cursor_position: Local<Option<Vec2>>,\r\n    mut previous_update: Local<CursorUpdate>,\r\n) {\r\n    for cursor in cursor_query.iter_mut() {\r\n        let (\r\n            mut cursor_transform,\r\n            cursor_global_transform,\r\n            mut cursor_position,\r\n            cursor_actions,\r\n            mut cursor,\r\n            cursor_environment,\r\n            cursor_parent,\r\n        ) = cursor;\r\n\r\n        let stick_in_use = cursor_actions.pressed(CursorAction::Move);\r\n        let in_host_environment = cursor_environment\r\n            .map(|e| environment_query.contains(e.environment_id))\r\n            .unwrap_or(false);\r\n\r\n        let Ok(character) = character_query.get_mut(cursor_parent.get()) else {\r\n            warn!(\"No character found\");\r\n            continue;\r\n        };\r\n        let (character_global_transform, is_main_character) = character;\r\n\r\n        let Ok(camera) = camera_query.get_single() else {\r\n            warn!(\"No camera found\");\r\n            return;\r\n        };\r\n        let (camera, camera_global_transform) = camera;\r\n\r\n        let Ok(window) = window_query.get_single() else {\r\n            warn!(\"No window found\");\r\n            return;\r\n        };\r\n        let (window, window_handle) = window;\r\n\r\n        let decision_info = DecisionInfo {\r\n            current_behaviour: cursor.movement_behaviour,\r\n            is_main_character: is_main_character.is_some(),\r\n            in_host_environment,\r\n            stick_in_use,\r\n            active_input_method: *input_method,\r\n        };\r\n\r\n        let next_behaviour = match decision_info {\r\n            DecisionInfo {\r\n                is_main_character: true,\r\n                in_host_environment: true,\r\n                stick_in_use: true,\r\n                ..\r\n            }\r\n            | DecisionInfo {\r\n                is_main_character: true,\r\n                in_host_environment: true,\r\n                active_input_method: InputMethod::Gamepad,\r\n                ..\r\n            }\r\n            | DecisionInfo {\r\n                is_main_character: true,\r\n                in_host_environment: true,\r\n                active_input_method: InputMethod::Keyboard,\r\n                ..\r\n            } => CursorMovementBehaviour::SetHostCursorFromCursorWorldCoords,\r\n            DecisionInfo {\r\n                is_main_character: true,\r\n                stick_in_use: false,\r\n                active_input_method: InputMethod::MouseAndKeyboard,\r\n                ..\r\n            } => CursorMovementBehaviour::SetCursorFromHostCursorWindowCoords,\r\n            DecisionInfo {\r\n                is_main_character: true,\r\n                in_host_environment: false,\r\n                stick_in_use: true,\r\n                ..\r\n            } => CursorMovementBehaviour::SetHostCursorFromWindowCoords,\r\n            DecisionInfo {\r\n                is_main_character: true,\r\n                in_host_environment: false,\r\n                stick_in_use: false,\r\n                ..\r\n            } => decision_info.current_behaviour,\r\n            DecisionInfo {\r\n                current_behaviour: CursorMovementBehaviour::None,\r\n                ..\r\n            } => CursorMovementBehaviour::None,\r\n            _ => {\r\n                warn!(\"Unhandled case: {:?}\", decision_info);\r\n                decision_info.current_behaviour\r\n            }\r\n        };\r\n\r\n        if next_behaviour != cursor.movement_behaviour {\r\n            info!(\r\n                \"Switching to {:?} given {:?}\",\r\n                next_behaviour, decision_info\r\n            );\r\n            cursor.movement_behaviour = next_behaviour;\r\n        }\r\n\r\n        let this_update = match cursor.movement_behaviour {\r\n            CursorMovementBehaviour::None => {\r\n                // sync physics to render\r\n                CursorUpdate {\r\n                    local_target: None,\r\n                    global_target: Some(cursor_global_transform.translation().xy()),\r\n                    host_target: None,\r\n                }\r\n            }\r\n            CursorMovementBehaviour::SetCursorFromHostCursorWindowCoords => {\r\n                // usual mode for mouse and keyboard input\r\n                match window.cursor_position().or(*last_known_cursor_position) {\r\n                    Some(host_cursor_xy) => {\r\n                        // Cache to avoid jitter\r\n                        *last_known_cursor_position = Some(host_cursor_xy);\r\n\r\n                        // Calculate target positions\r\n                        let Some(global_target) = camera\r\n                            .viewport_to_world(camera_global_transform, host_cursor_xy)\r\n                            .map(|ray| ray.origin.truncate())\r\n                        else {\r\n                            return;\r\n                        };\r\n                        let local_target =\r\n                            global_target - character_global_transform.translation().xy();\r\n                        CursorUpdate {\r\n                            local_target: Some(local_target),\r\n                            global_target: Some(global_target),\r\n                            host_target: None,\r\n                        }\r\n                    }\r\n                    None => {\r\n                        if cursor.log_behaviour == CursorLogBehaviour::ErrorsAndPositionUpdates {\r\n                            warn!(\"No cursor position found\");\r\n                        }\r\n                        CursorUpdate::default()\r\n                    }\r\n                }\r\n            }\r\n            CursorMovementBehaviour::SetHostCursorFromCursorWorldCoords => {\r\n                // host follows cursor, render and physics are the same\r\n                if stick_in_use {\r\n                    match cursor_actions.axis_pair(CursorAction::Move) {\r\n                        Some(axis_pair) => {\r\n                            let look = axis_pair.xy();\r\n                            if look.x.is_nan() || look.y.is_nan() {\r\n                                warn!(\"{} | look vector is unusable\", cursor.movement_behaviour);\r\n                                CursorUpdate::default()\r\n                            } else {\r\n                                let character_translation =\r\n                                    character_global_transform.translation();\r\n                                let local_target = look * cursor.reach;\r\n                                let global_target = character_translation.xy() + local_target;\r\n                                let host_target = global_target.neg_y().as_ivec2();\r\n                                CursorUpdate {\r\n                                    local_target: Some(local_target),\r\n                                    global_target: Some(global_target),\r\n                                    host_target: Some(host_target),\r\n                                }\r\n                            }\r\n                        }\r\n                        None => {\r\n                            warn!(\"{}, No axis pair found?\", cursor.movement_behaviour);\r\n                            CursorUpdate::default()\r\n                        }\r\n                    }\r\n                } else {\r\n                    // cursor stick not in use, reset cursor to the origin of the character\r\n                    let character_translation = character_global_transform.translation();\r\n                    let local_target = Vec2::ZERO;\r\n                    let global_target = character_translation.xy();\r\n                    let host_target = character_translation.xy().neg_y().as_ivec2();\r\n                    CursorUpdate {\r\n                        local_target: Some(local_target),\r\n                        global_target: Some(global_target),\r\n                        host_target: Some(host_target),\r\n                    }\r\n                }\r\n            }\r\n            CursorMovementBehaviour::SetHostCursorFromWindowCoords => {\r\n                if stick_in_use {\r\n                    // stick in use\r\n                    // the host cursor will go over the cursor's window position\r\n                    match cursor_actions.axis_pair(CursorAction::Move) {\r\n                        Some(axis_pair) => {\r\n                            let look = axis_pair.xy();\r\n\r\n                            // the look vector could be unusable\r\n                            if look.x.is_nan() || look.y.is_nan() {\r\n                                warn!(\"{} | look vector is unusable\", cursor.movement_behaviour);\r\n                                CursorUpdate::default()\r\n                            } else {\r\n                                // the spot you want to be is the character position + stick direction\r\n                                let character_translation =\r\n                                    character_global_transform.translation();\r\n                                let local_target = look * cursor.reach;\r\n                                let global_target =\r\n                                    character_translation + local_target.extend(0.0);\r\n\r\n                                // update the host cursor\r\n                                let window_bounds = match window_handle.window_handle {\r\n                                    raw_window_handle::RawWindowHandle::Win32(handle) => {\r\n                                        match get_window_bounds(handle.hwnd as _) {\r\n                                            Ok(bounds) => bounds,\r\n                                            Err(e) => {\r\n                                                error!(\"Failed to get window bounds: {:?}\", e);\r\n                                                return;\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                    _ => panic!(\"Unsupported window handle\"),\r\n                                };\r\n                                let host_target = camera\r\n                                    .world_to_viewport(camera_global_transform, global_target)\r\n                                    .map(|viewport| {\r\n                                        let mut host_target =\r\n                                            viewport.as_ivec2() + window_bounds.min;\r\n                                        // accomodate window decorations\r\n                                        let mut offset = get_window_inner_offset();\r\n                                        offset.x *= 2;\r\n                                        host_target += offset;\r\n                                        host_target\r\n                                    });\r\n\r\n                                CursorUpdate {\r\n                                    local_target: Some(local_target.xy()),\r\n                                    global_target: Some(global_target.xy()),\r\n                                    host_target,\r\n                                }\r\n                            }\r\n                        }\r\n                        None => {\r\n                            warn!(\"{} | No axis pair found?\", cursor.movement_behaviour);\r\n                            CursorUpdate::default()\r\n                        }\r\n                    }\r\n                } else {\r\n                    // stick not in use\r\n                    // reset cursor to the origin of the character\r\n                    let character_translation = character_global_transform.translation();\r\n                    let local_target = Vec2::ZERO;\r\n                    let global_target = character_translation.xy().neg_y();\r\n\r\n                    // update the host cursor\r\n                    let window_bounds = match window_handle.window_handle {\r\n                        raw_window_handle::RawWindowHandle::Win32(handle) => {\r\n                            match get_window_bounds(handle.hwnd as _) {\r\n                                Ok(bounds) => bounds,\r\n                                Err(e) => {\r\n                                    error!(\"Failed to get window bounds: {:?}\", e);\r\n                                    return;\r\n                                }\r\n                            }\r\n                        }\r\n                        _ => panic!(\"Unsupported window handle\"),\r\n                    };\r\n                    let host_target = camera\r\n                        .world_to_viewport(camera_global_transform, character_translation)\r\n                        .map(|viewport| {\r\n                            let mut host_target = viewport.as_ivec2() + window_bounds.min;\r\n                            // accomodate window decorations\r\n                            let mut offset = get_window_inner_offset();\r\n                            offset.x *= 2;\r\n                            // debug!(\"host_target={:?} offset={:?}\", host_target, offset);\r\n                            host_target += offset;\r\n                            host_target\r\n                        });\r\n\r\n                    CursorUpdate {\r\n                        local_target: Some(local_target),\r\n                        global_target: Some(global_target),\r\n                        host_target,\r\n                    }\r\n                }\r\n            }\r\n        };\r\n\r\n        // Update render body\r\n        let mut render_updated = false;\r\n        if this_update.local_target != previous_update.local_target\r\n            && let Some(local_target) = this_update.local_target\r\n        {\r\n            let target_distance = local_target - cursor_transform.translation.xy();\r\n            if target_distance != Vec2::ZERO {\r\n                // Not at destination, update render body (which physics will follow)\r\n                if cursor.log_behaviour == CursorLogBehaviour::ErrorsAndPositionUpdates {\r\n                    debug!(\r\n                        \"{} stick={:?} | target_distance={:?}, updating render body to local_target={:?}\",\r\n                        cursor.movement_behaviour, stick_in_use, target_distance, local_target\r\n                    );\r\n                }\r\n                cursor_transform.translation.x = local_target.x;\r\n                cursor_transform.translation.y = local_target.y;\r\n                render_updated = true;\r\n            }\r\n        }\r\n\r\n        // Update physics body\r\n        if !render_updated\r\n            && this_update.global_target != previous_update.global_target\r\n            && let Some(global_target) = this_update.global_target\r\n        {\r\n            let target_distance = global_target - cursor_position.xy();\r\n            if target_distance != Vec2::ZERO {\r\n                // Not at destination, update physics body\r\n                if cursor.log_behaviour == CursorLogBehaviour::ErrorsAndPositionUpdates {\r\n                    debug!(\r\n                        \"{} stick={:?} | target_distance={:?}, updating physics body to global_target={:?}\",\r\n                        cursor.movement_behaviour, stick_in_use, target_distance, global_target\r\n                    );\r\n                }\r\n                // prevent feedback loop\r\n                let cursor_position = cursor_position.bypass_change_detection();\r\n\r\n                // update physics body\r\n                cursor_position.x = global_target.x;\r\n                cursor_position.y = global_target.y;\r\n            }\r\n        }\r\n\r\n        if this_update.host_target != previous_update.host_target\r\n            && let Some(host_target) = this_update.host_target\r\n        {\r\n            match set_cursor_position(host_target) {\r\n                Ok(_) => {\r\n                    if cursor.log_behaviour == CursorLogBehaviour::ErrorsAndPositionUpdates {\r\n                        debug!(\r\n                            \"{} | set host cursor to {:?}\",\r\n                            cursor.movement_behaviour, host_target\r\n                        );\r\n                    }\r\n                }\r\n                Err(e) => {\r\n                    warn!(\r\n                        \"{} | host cursor update failed, tried setting to {:?}, error={:?}\",\r\n                        cursor.movement_behaviour, host_target, e\r\n                    );\r\n                }\r\n            }\r\n        }\r\n\r\n        *previous_update = this_update;\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\chat\\src\\chat_input_buffer_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse cursor_hero_character_types::character_types::Character;\r\nuse cursor_hero_chat_types::prelude::*;\r\nuse cursor_hero_toolbelt_types::prelude::*;\r\nuse leafwing_input_manager::action_state::ActionState;\r\n\r\npub struct ChatInputBufferPlugin;\r\n\r\nimpl Plugin for ChatInputBufferPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Update, handle_char);\r\n        app.add_systems(Update, handle_input);\r\n    }\r\n}\r\n\r\nfn handle_char(\r\n    mut tool_query: Query<(Entity, &mut ChatTool, &Parent), With<ActiveTool>>,\r\n    toolbelt_query: Query<&Parent, With<Toolbelt>>,\r\n    character_query: Query<Entity, With<Character>>,\r\n    mut chat_input_events: EventWriter<ChatInputEvent>,\r\n    mut character_events: EventReader<ReceivedCharacter>,\r\n) {\r\n    for event in character_events.read() {\r\n        if event.char.is_control() {\r\n            continue;\r\n        }\r\n        for tool in tool_query.iter_mut() {\r\n            let (tool_id, mut tool, tool_parent) = tool;\r\n            if !tool.focused {\r\n                continue;\r\n            }\r\n            let Ok(toolbelt) = toolbelt_query.get(tool_parent.get()) else {\r\n                warn!(\"Tool not inside a toolbelt?\");\r\n                continue;\r\n            };\r\n            let toolbelt_parent = toolbelt;\r\n            let Ok(character) = character_query.get(toolbelt_parent.get()) else {\r\n                warn!(\"Toolbelt parent not a character?\");\r\n                continue;\r\n            };\r\n            let character_id = character;\r\n            tool.buffer.push(event.char);\r\n            chat_input_events.send(ChatInputEvent::TextChanged {\r\n                tool_id,\r\n                toolbelt_id: tool_parent.get(),\r\n                character_id,\r\n            });\r\n            debug!(\r\n                \"Appended char '{}' ({}) to chat buffer. New: {}\",\r\n                event.char, event.char as u32, tool.buffer\r\n            );\r\n        }\r\n    }\r\n}\r\n\r\nfn handle_input(\r\n    mut tool_query: Query<\r\n        (Entity, &mut ChatTool, &ActionState<ChatToolAction>, &Parent),\r\n        With<ActiveTool>,\r\n    >,\r\n    toolbelt_query: Query<&Parent, With<Toolbelt>>,\r\n    character_query: Query<Entity, With<Character>>,\r\n    mut chat_input_events: EventWriter<ChatInputEvent>,\r\n    time: Res<Time>,\r\n) {\r\n    for tool in tool_query.iter_mut() {\r\n        let (tool_id, mut tool, tool_actions, tool_parent) = tool;\r\n        if !tool.focused {\r\n            continue;\r\n        }\r\n        let input_active = tool_actions.pressed(ChatToolAction::Backspace);\r\n        match (input_active, &mut tool.state) {\r\n            // no input is active, return to default state\r\n            (false, state) => {\r\n                if *state != ChatToolState::Idle {\r\n                    tool.state = ChatToolState::Idle;\r\n                }\r\n                continue;\r\n            }\r\n            // first input, start initial delay\r\n            (true, ChatToolState::Idle) => {\r\n                tool.state =\r\n                    ChatToolState::InitialRepeatDelay(Timer::from_seconds(0.5, TimerMode::Once));\r\n            }\r\n            // check initial delay finished, start repeat delay\r\n            (true, ChatToolState::InitialRepeatDelay(ref mut timer)) => {\r\n                if timer.tick(time.delta()).just_finished() {\r\n                    tool.state =\r\n                        ChatToolState::RepeatDelay(Timer::from_seconds(0.03, TimerMode::Repeating));\r\n                } else {\r\n                    continue;\r\n                }\r\n            }\r\n            // been held, continue repeat delay\r\n            (true, ChatToolState::RepeatDelay(ref mut timer)) => {\r\n                if !timer.tick(time.delta()).just_finished() {\r\n                    continue;\r\n                }\r\n            }\r\n        }\r\n\r\n        let Ok(toolbelt) = toolbelt_query.get(tool_parent.get()) else {\r\n            warn!(\"Tool not inside a toolbelt?\");\r\n            continue;\r\n        };\r\n        let toolbelt_parent = toolbelt;\r\n        let Ok(character) = character_query.get(toolbelt_parent.get()) else {\r\n            warn!(\"Toolbelt parent not a character?\");\r\n            continue;\r\n        };\r\n        let character_id = character;\r\n        let original_buffer = tool.buffer.clone();\r\n        if tool_actions.pressed(ChatToolAction::Backspace) {\r\n            if tool_actions.pressed(ChatToolAction::WordModifier) {\r\n                // delete word\r\n                while let Some(c) = tool.buffer.pop() {\r\n                    if c.is_whitespace() {\r\n                        break;\r\n                    }\r\n                }\r\n            } else {\r\n                tool.buffer.pop();\r\n            }\r\n        }\r\n        if original_buffer == tool.buffer {\r\n            continue;\r\n        }\r\n        chat_input_events.send(ChatInputEvent::TextChanged {\r\n            tool_id,\r\n            toolbelt_id: tool_parent.get(),\r\n            character_id,\r\n        });\r\n        debug!(\"Updated chat buffer. New: {}\", tool.buffer);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\observation\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_observation\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\ncursor_hero_observation_types = { workspace = true }\r\ncursor_hero_inference_types = { workspace = true }\r\ncursor_hero_toolbelt_types = { workspace = true }\r\ncursor_hero_tools = { workspace = true }\r\ncursor_hero_chat_types = { workspace = true }\r\ncursor_hero_character_types = { workspace = true }\r\ncursor_hero_environment_types = { workspace = true }\r\nchrono = {workspace = true}\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\character_types\\src\\character_types.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n\r\n#[derive(Component, Reflect, Default)]\r\npub struct Character;\r\n\r\n#[derive(Component, Reflect, Default)]\r\npub struct MainCharacter;\r\n#[derive(Component, Reflect, Default)]\r\npub struct AgentCharacter;\r\n\r\n#[derive(Component, Reflect, Eq, PartialEq, Debug)]\r\npub enum CharacterAppearance {\r\n    Focused,\r\n    Unfocused,\r\n}\r\nimpl CharacterAppearance {\r\n    pub fn get_texture_path(&self) -> &'static str {\r\n        match self {\r\n            Self::Focused => \"textures/character/default_character_focused.png\",\r\n            Self::Unfocused => \"textures/character/default_character_unfocused.png\",\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\cursor_types\\src\\cursor_hover_types.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n\r\n#[derive(Event, Debug, Reflect)]\r\npub enum HoverEvent {\r\n    Start {\r\n        target_id: Entity,\r\n        cursor_id: Entity,\r\n    },\r\n    End {\r\n        target_id: Entity,\r\n        cursor_id: Entity,\r\n    },\r\n}\r\n\r\n#[derive(Component, Reflect, Debug)]\r\npub struct Hovered;\r\n#[derive(Component, Reflect, Debug)]\r\npub struct Hoverable;\r\n#[derive(Component, Reflect, Debug)]\r\npub struct Hovering {\r\n    pub hovering: Vec<Entity>,\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\math\\src\\shuffle.rs\r\n\r\n````rust\r\n#[cfg(target_arch = \"x86\")]\r\nuse std::arch::x86::_mm_shuffle_epi8;\r\nuse std::arch::x86_64::__m128i;\r\nuse std::arch::x86_64::_mm_loadu_si128;\r\nuse std::arch::x86_64::_mm_setr_epi8;\r\n#[cfg(target_arch = \"x86_64\")]\r\nuse std::arch::x86_64::_mm_shuffle_epi8;\r\nuse std::arch::x86_64::_mm_storeu_si128;\r\n\r\n/// Convert BGRA to RGBA\r\n///\r\n/// Uses SIMD to go fast\r\npub fn bgra_to_rgba(data: &mut [u8]) {\r\n    // The shuffle mask for converting BGRA -> RGBA\r\n    let mask: __m128i = unsafe {\r\n        _mm_setr_epi8(\r\n            2, 1, 0, 3, // First pixel\r\n            6, 5, 4, 7, // Second pixel\r\n            10, 9, 8, 11, // Third pixel\r\n            14, 13, 12, 15, // Fourth pixel\r\n        )\r\n    };\r\n    // For each 16-byte chunk in your data\r\n    for chunk in data.chunks_exact_mut(16) {\r\n        let mut vector = unsafe { _mm_loadu_si128(chunk.as_ptr() as *const __m128i) };\r\n        vector = unsafe { _mm_shuffle_epi8(vector, mask) };\r\n        unsafe { _mm_storeu_si128(chunk.as_mut_ptr() as *mut __m128i, vector) };\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\character_types\\src\\lib.rs\r\n\r\n````rust\r\npub mod character_types;\r\npub mod character_types_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::character_types::*;\r\n    pub use crate::character_types_plugin::CharacterTypesPlugin;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\environment\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_environment\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\ncursor_hero_environment_types = { workspace = true}\r\ncursor_hero_level_bounds = { workspace = true }\r\ncursor_hero_cursor_types = { workspace = true }\r\nbevy_xpbd_2d = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\math\\src\\lerp.rs\r\n\r\n````rust\r\npub trait Lerp {\r\n    fn lerp(self, open: f32) -> f32;\r\n}\r\n\r\nimpl Lerp for (f32, f32) {\r\n    fn lerp(self, open: f32) -> f32 {\r\n        let (start, end) = self;\r\n        start + (end - start) * open.clamp(0.0, 1.0)\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\memory\\src\\main_camera_memory_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse cursor_hero_camera::camera_plugin::MainCamera;\r\nuse cursor_hero_memory_types::prelude::*;\r\nuse serde::Deserialize;\r\nuse serde::Serialize;\r\n\r\npub struct MainCameraMemoryPlugin;\r\n\r\nimpl Plugin for MainCameraMemoryPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.insert_resource(MainCameraMemoryConfig::default());\r\n        app.add_systems(Update, persist.pipe(handle_persist_errors));\r\n        app.add_systems(Update, restore.pipe(handle_restore_errors));\r\n    }\r\n}\r\nconst PERSIST_FILE_NAME: &str = \"main_camera.json\";\r\n\r\n// not moved to lib to ensure log contains this module name\r\nfn handle_persist_errors(In(result): In<Result<PersistSuccess, PersistError>>) {\r\n    if let Err(e) = result {\r\n        error!(\"Persist error occurred: {:?}\", e);\r\n    } else if let Ok(PersistSuccess::WritePerformed) = result {\r\n        debug!(\"Persisted succeeded\");\r\n    }\r\n}\r\n\r\nfn handle_restore_errors(In(result): In<Result<RestoreSuccess, RestoreError>>) {\r\n    if let Err(e) = result {\r\n        error!(\"Restore error occurred: {:?}\", e);\r\n    } else if let Ok(RestoreSuccess::Performed) = result {\r\n        info!(\"Restore succeeded\");\r\n    }\r\n}\r\n\r\n#[derive(Debug, Resource, Reflect)]\r\n#[reflect(Resource)]\r\nstruct MainCameraMemoryConfig {\r\n    pub debounce_timer: Timer,\r\n}\r\nimpl Default for MainCameraMemoryConfig {\r\n    fn default() -> Self {\r\n        Self {\r\n            debounce_timer: Timer::from_seconds(10.0, TimerMode::Repeating),\r\n        }\r\n    }\r\n}\r\n\r\n#[derive(Debug, Serialize, Deserialize, PartialEq, Clone, Copy)]\r\nstruct DiskData {\r\n    scale: Vec3,\r\n}\r\n\r\nfn persist(\r\n    mut config: ResMut<MainCameraMemoryConfig>,\r\n    memory_config: Res<MemoryConfig>,\r\n    mut debounce: Local<Option<DiskData>>,\r\n    time: Res<Time>,\r\n    camera_query: Query<&Transform, With<MainCamera>>,\r\n) -> Result<PersistSuccess, PersistError> {\r\n    if !config.debounce_timer.tick(time.delta()).just_finished() {\r\n        return Ok(PersistSuccess::Cooldown);\r\n    }\r\n\r\n    let camera_transform = camera_query.get_single().map_err(|_| PersistError::Query)?;\r\n\r\n    let data = DiskData {\r\n        scale: camera_transform.scale,\r\n    };\r\n    if debounce.is_none() || debounce.as_ref().unwrap() != &data {\r\n        let file = get_persist_file(memory_config.as_ref(), PERSIST_FILE_NAME, Usage::Persist)\r\n            .map_err(PersistError::Io)?;\r\n        write_to_disk(file, data)?;\r\n        *debounce = Some(data);\r\n        Ok(PersistSuccess::WritePerformed)\r\n    } else {\r\n        Ok(PersistSuccess::Debounce)\r\n    }\r\n}\r\n\r\nfn restore(\r\n    memory_config: Res<MemoryConfig>,\r\n    mut camera_query: Query<&mut Transform, Added<MainCamera>>,\r\n) -> Result<RestoreSuccess, RestoreError> {\r\n    let Ok(mut camera_transform) = camera_query.get_single_mut() else {\r\n        return Ok(RestoreSuccess::NoAction);\r\n    };\r\n    let file = get_persist_file(memory_config.as_ref(), PERSIST_FILE_NAME, Usage::Restore)\r\n        .map_err(RestoreError::Io)?;\r\n    let data: DiskData = read_from_disk(file)?;\r\n    info!(\"Restoring main camera scale to {:?}\", data.scale);\r\n    camera_transform.scale = data.scale;\r\n    Ok(RestoreSuccess::Performed)\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\memory\\src\\memory_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse cursor_hero_memory_types::prelude::MemoryConfig;\r\nuse cursor_hero_memory_types::prelude::MemoryPluginBuildConfig;\r\n\r\nuse crate::agent_observation_memory_plugin::AgentObservationMemoryPlugin;\r\nuse crate::main_camera_memory_plugin::MainCameraMemoryPlugin;\r\nuse crate::main_character_memory_plugin::MainCharacterMemoryPlugin;\r\nuse crate::primary_window_memory_plugin::PrimaryWindowMemoryPlugin;\r\nuse crate::voice_to_text_memory_plugin::VoiceToTextMemoryPlugin;\r\n\r\npub struct MemoryPlugin {\r\n    pub config: MemoryConfig,\r\n    pub build_config: MemoryPluginBuildConfig,\r\n}\r\n\r\nimpl Plugin for MemoryPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.insert_resource(self.config.clone());\r\n        if self.build_config.main_character_memory_enabled {\r\n            app.add_plugins(MainCharacterMemoryPlugin);\r\n        }\r\n        if self.build_config.primary_window_memory_enabled {\r\n            app.add_plugins(PrimaryWindowMemoryPlugin);\r\n        }\r\n        if self.build_config.main_camera_memory_enabled {\r\n            app.add_plugins(MainCameraMemoryPlugin);\r\n        }\r\n        if self.build_config.voice_to_text_memory_enabled {\r\n            app.add_plugins(VoiceToTextMemoryPlugin);\r\n        }\r\n        if self.build_config.agent_observation_memory_enabled {\r\n            app.add_plugins(AgentObservationMemoryPlugin);\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\math\\src\\corner.rs\r\n\r\n````rust\r\nuse bevy::reflect::Reflect;\r\n\r\n#[derive(Debug, Reflect, Eq, Clone, PartialEq, Hash)]\r\npub enum Corner {\r\n    TopLeft,\r\n    TopRight,\r\n    BottomLeft,\r\n    BottomRight,\r\n}\r\nimpl Corner {\r\n    pub fn variants() -> [Self; 4] {\r\n        [\r\n            Self::TopLeft,\r\n            Self::TopRight,\r\n            Self::BottomLeft,\r\n            Self::BottomRight,\r\n        ]\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\brick\\src\\lib.rs\r\n\r\n````rust\r\npub mod brick_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::brick_plugin::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\character_types\\src\\character_types_plugin.rs\r\n\r\n````rust\r\nuse crate::character_types::*;\r\nuse bevy::prelude::*;\r\npub struct CharacterTypesPlugin;\r\n\r\nimpl Plugin for CharacterTypesPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<Character>();\r\n        app.register_type::<MainCharacter>();\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\glados_tts\\src\\lib.rs\r\n\r\n````rust\r\npub mod glados_tts;\r\npub mod glados_tts_button_plugin;\r\npub mod glados_tts_inference_plugin;\r\npub mod glados_tts_plugin;\r\npub mod glados_tts_status_plugin;\r\npub mod glados_tts_status_worker_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::glados_tts_plugin::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\glados_tts\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_glados_tts\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\ncursor_hero_inference_types = { workspace = true }\r\ncursor_hero_glados_tts_types = { workspace = true }\r\ntokio = {workspace = true}\r\nreqwest = {workspace = true}\r\nurlencoding = {workspace = true}\r\ncrossbeam-channel = { workspace = true }\r\ncursor_hero_environment_types = {workspace = true}\r\ncursor_hero_cursor_types = {workspace = true}\r\ncursor_hero_math = {workspace = true}\r\nbevy_xpbd_2d = { workspace = true }\r\nrodio = { workspace = true, features=[\"wav\"]}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\chat_types\\src\\chat_types_plugin.rs\r\n\r\n````rust\r\nuse crate::prelude::*;\r\nuse bevy::prelude::*;\r\npub struct ChatTypesPlugin;\r\n\r\nimpl Plugin for ChatTypesPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<ChatWheelTool>();\r\n        app.register_type::<ChatTool>();\r\n        app.register_type::<ChatBubble>();\r\n        app.register_type::<ChatInput>();\r\n        app.add_event::<ChatEvent>();\r\n        app.add_event::<ChatInputEvent>();\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\floaty_nametag\\src\\lib.rs\r\n\r\n````rust\r\npub mod floaty_nametag_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::floaty_nametag_plugin::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\cursor_types\\src\\cursor_click_types.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n\r\n#[derive(Component, Reflect, Debug)]\r\npub struct Clickable;\r\n\r\n#[derive(Reflect, Debug)]\r\npub struct CursorPress {\r\n    pub cursor_id: Entity,\r\n    pub way: Way,\r\n}\r\n#[derive(Component, Reflect, Debug)]\r\npub struct Pressed {\r\n    pub presses: Vec<CursorPress>,\r\n}\r\n\r\n#[derive(Reflect, Debug, Hash, PartialEq, Eq, Copy, Clone)]\r\npub struct TargetPress {\r\n    pub target_id: Entity,\r\n    pub way: Way,\r\n}\r\n#[derive(Component, Reflect, Debug)]\r\npub struct Pressing {\r\n    pub pressing: Vec<TargetPress>,\r\n}\r\n\r\n#[derive(Reflect, Debug, Clone, Copy, Eq, PartialEq, Hash)]\r\npub enum Way {\r\n    Left,\r\n    Right,\r\n    Middle,\r\n}\r\n\r\n#[derive(Event, Debug, Reflect)]\r\npub enum ClickEvent {\r\n    Pressed {\r\n        target_id: Entity,\r\n        cursor_id: Entity,\r\n        way: Way,\r\n    },\r\n    Released {\r\n        target_id: Entity,\r\n        cursor_id: Entity,\r\n        way: Way,\r\n    },\r\n    Clicked {\r\n        target_id: Entity,\r\n        cursor_id: Entity,\r\n        way: Way,\r\n    },\r\n}\r\n#[derive(Event, Debug, Reflect)]\r\npub enum ToolClickEvent {\r\n    Pressed { cursor_id: Entity, way: Way },\r\n    Released { cursor_id: Entity, way: Way },\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\character\\src\\character_appearance_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n\r\npub struct CharacterAppearancePlugin;\r\nuse cursor_hero_camera::camera_plugin::CameraEvent;\r\nuse cursor_hero_character_types::prelude::*;\r\n\r\nimpl Plugin for CharacterAppearancePlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Update, update_character_appearance_from_camera_events);\r\n    }\r\n}\r\n\r\nfn update_character_appearance_from_camera_events(\r\n    mut camera_events: EventReader<CameraEvent>,\r\n    asset_server: Res<AssetServer>,\r\n    mut character_query: Query<&mut Handle<Image>, With<Character>>,\r\n) {\r\n    for event in camera_events.read() {\r\n        match event {\r\n            CameraEvent::BeginFollowing { target_id } => {\r\n                if let Ok(mut texture) = character_query.get_mut(*target_id) {\r\n                    *texture = asset_server.load(CharacterAppearance::Focused.get_texture_path());\r\n                    info!(\"Updated character appearance to focused\");\r\n                }\r\n            }\r\n            CameraEvent::StopFollowing { target_id } => {\r\n                if let Ok(mut texture) = character_query.get_mut(*target_id) {\r\n                    *texture = asset_server.load(CharacterAppearance::Unfocused.get_texture_path());\r\n                    info!(\"Updated character appearance to unfocused\");\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\brick\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_brick\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\ncursor_hero_brick_types = { workspace = true }\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\brick_types\\src\\lib.rs\r\n\r\n````rust\r\npub mod brick_types;\r\npub mod brick_types_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::brick_types::*;\r\n    pub use crate::brick_types_plugin::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\chat_types\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_chat_types\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\nleafwing-input-manager = { workspace = true }\r\ncursor_hero_toolbelt_types = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\host_event_types\\src\\lib.rs\r\n\r\n````rust\r\nmod host_event_types;\r\nmod host_event_types_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::host_event_types::*;\r\n    pub use crate::host_event_types_plugin::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\character\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_character\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\ncursor_hero_camera = { workspace = true }\r\ncursor_hero_bevy = { workspace = true }\r\ncursor_hero_input = { workspace = true }\r\ncursor_hero_physics = { workspace = true }\r\ncursor_hero_winutils = { workspace = true}\r\ncursor_hero_toolbelt_types = { workspace = true}\r\ncursor_hero_environment_types = { workspace = true}\r\ncursor_hero_floaty_nametag_types = { workspace = true}\r\ncursor_hero_character_types = { workspace = true}\r\nbevy = { workspace = true }\r\nbevy_xpbd_2d = { workspace = true }\r\nleafwing-input-manager = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\camera\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_camera\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\nbevy_xpbd_2d = { workspace = true }\r\nbevy_egui = {workspace = true}\r\nleafwing-input-manager = { workspace = true }\r\ncursor_hero_physics = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\agent\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_agent\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\ncursor_hero_environment_types = { workspace = true }\r\ncursor_hero_character_types = { workspace = true }\r\ncursor_hero_movement_tool_types = { workspace = true }\r\ncursor_hero_agent_types = { workspace = true }\r\ncursor_hero_physics = { workspace = true }\r\ncursor_hero_input = { workspace = true }\r\ncursor_hero_bevy = { workspace = true }\r\ncursor_hero_toolbelt_types = { workspace = true }\r\ncursor_hero_observation_types = { workspace = true }\r\ncursor_hero_camera = { workspace = true }\r\nbevy_xpbd_2d = { workspace = true }\r\nbevy-inspector-egui = { workspace = true}\r\nleafwing-input-manager = { workspace = true }\r\ncursor_hero_floaty_nametag_types = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\app\\src\\app_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n\r\npub struct AppPlugin;\r\n\r\nimpl Plugin for AppPlugin {\r\n    fn build(&self, _app: &mut App) {}\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\chat\\src\\chat_focus_exclusivity_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse cursor_hero_chat_types::prelude::*;\r\nuse cursor_hero_toolbelt_types::prelude::*;\r\n\r\npub struct ChatFocusExclusivityPlugin;\r\n\r\nimpl Plugin for ChatFocusExclusivityPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Update, handle_focus_changed);\r\n    }\r\n}\r\n\r\nfn handle_focus_changed(\r\n    mut commands: Commands,\r\n    mut events: EventReader<ChatInputEvent>,\r\n    mut tool_query: Query<&mut ChatTool, With<ChatTool>>,\r\n    toolbelt_query: Query<&Children, With<Toolbelt>>,\r\n    active_tool_query: Query<(), (With<ActiveTool>, Without<ChatTool>)>,\r\n) {\r\n    for event in events.read() {\r\n        let (ChatInputEvent::Focus {\r\n            tool_id,\r\n            toolbelt_id,\r\n            ..\r\n        }\r\n        | ChatInputEvent::Unfocus {\r\n            tool_id,\r\n            toolbelt_id,\r\n            ..\r\n        }) = event\r\n        else {\r\n            continue;\r\n        };\r\n        let focusing = matches!(event, ChatInputEvent::Focus { .. });\r\n\r\n        let Ok(tool) = tool_query.get_mut(*tool_id) else {\r\n            warn!(\"Tool {:?} not found for event {:?}\", tool_id, event);\r\n            continue;\r\n        };\r\n        let mut tool = tool;\r\n\r\n        let Ok(toolbelt) = toolbelt_query.get(*toolbelt_id) else {\r\n            warn!(\"Toolbelt {:?} not found for event {:?}\", toolbelt_id, event);\r\n            continue;\r\n        };\r\n        let toolbelt_children = toolbelt;\r\n        if focusing {\r\n            tool.focused = true;\r\n            for tool_id in toolbelt_children.iter() {\r\n                if active_tool_query.contains(*tool_id) {\r\n                    tool.tools_disabled_during_focus.insert(*tool_id);\r\n                    commands.entity(*tool_id).remove::<ActiveTool>();\r\n                    debug!(\"Disabled tool {:?} while focused\", tool_id);\r\n                }\r\n            }\r\n            debug!(\"Set tool {:?} as focused\", tool_id);\r\n        } else {\r\n            tool.focused = false;\r\n            for tool_id in tool.tools_disabled_during_focus.iter() {\r\n                match commands.get_entity(*tool_id) {\r\n                    Some(mut entity) => {\r\n                        entity.insert(ActiveTool);\r\n                    }\r\n                    None => {\r\n                        warn!(\"Error re-enabling tool {:?}, does not exist\", tool_id);\r\n                    }\r\n                }\r\n                debug!(\"Re-enabled tool {:?} after unfocusing\", tool_id);\r\n            }\r\n            tool.tools_disabled_during_focus.clear();\r\n            debug!(\"Set tool {:?} as unfocused\", tool_id);\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\cursor\\src\\lib.rs\r\n\r\n````rust\r\n#![feature(let_chains)]\r\n\r\npub mod cursor_click_plugin;\r\npub mod cursor_hover_plugin;\r\npub mod cursor_plugin;\r\npub mod cursor_positioning_plugin;\r\npub mod cursor_reach_plugin;\r\npub mod cursor_spawning_plugin;\r\npub mod cursor_mirroring_plugin;\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\agent_types\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_agent_types\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\calculator_app_types\\src\\calculator_app_types.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n\r\n#[derive(Component, Debug, Reflect)]\r\npub struct AppWindow;\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\observation\\src\\observation_buffer_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse cursor_hero_environment_types::prelude::*;\r\nuse cursor_hero_observation_types::prelude::*;\r\n\r\n/// Responsible for storing observations inside ObservationBuckets of those who are able to observe them.\r\npub struct ObservationBufferPlugin;\r\n\r\nimpl Plugin for ObservationBufferPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Update, update_buffers);\r\n    }\r\n}\r\n\r\nfn update_buffers(\r\n    mut observation_events: EventReader<SomethingObservableHappenedEvent>,\r\n    mut buffer_query: Query<(Entity, &mut ObservationBuffer, Option<&EnvironmentTracker>)>,\r\n    mut buffer_events: EventWriter<ObservationBufferEvent>,\r\n) {\r\n    for event in observation_events.read() {\r\n        for buffer in buffer_query.iter_mut() {\r\n            let (buffer_id, mut buffer, buffer_environment_tag) = buffer;\r\n\r\n            // Determine if the buffer can see the event\r\n            let can_see = match (buffer_environment_tag, event) {\r\n                (\r\n                    Some(EnvironmentTracker {\r\n                        environment_id: buffer_environment_id,\r\n                    }),\r\n                    SomethingObservableHappenedEvent::Chat {\r\n                        environment_id: Some(event_environment_id),\r\n                        ..\r\n                    },\r\n                ) => *buffer_environment_id == *event_environment_id,\r\n                (\r\n                    _,\r\n                    SomethingObservableHappenedEvent::MemoryRestored {\r\n                        observation_buffer_id,\r\n                    },\r\n                ) => buffer_id == *observation_buffer_id,\r\n                (\r\n                    Some(EnvironmentTracker {\r\n                        environment_id: buffer_environment_id,\r\n                    }),\r\n                    SomethingObservableHappenedEvent::UISnapshot {\r\n                        environment_id: Some(event_environment_id),\r\n                        ..\r\n                    },\r\n                ) => *buffer_environment_id == *event_environment_id,\r\n                // A buffer outside all environments will observe all environments\r\n                (None, _) => true,\r\n                _ => false,\r\n            };\r\n            if !can_see {\r\n                if buffer.log_level == ObservationLogLevel::All {\r\n                    debug!(\"Buffer {:?} cannot see event {}\", buffer_id, event)\r\n                }\r\n                continue;\r\n            }\r\n\r\n            let entry = ObservationBufferEntry {\r\n                datetime: chrono::Local::now(),\r\n                origin: event.clone(),\r\n            };\r\n            if buffer.log_level == ObservationLogLevel::All {\r\n                debug!(\"Buffer {:?} observed event {}\", buffer_id, &entry)\r\n            }\r\n            buffer.observations.push(entry);\r\n\r\n            let event = ObservationBufferEvent::Updated { buffer_id };\r\n            buffer_events.send(event);\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\brick_types\\src\\brick_types_plugin.rs\r\n\r\n````rust\r\nuse crate::prelude::*;\r\nuse bevy::prelude::*;\r\n\r\npub struct BrickTypesPlugin;\r\n\r\nimpl Plugin for BrickTypesPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<Brick>();\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\environment_types\\src\\environment_types_plugin.rs\r\n\r\n````rust\r\nuse crate::prelude::*;\r\nuse bevy::prelude::*;\r\n\r\npub struct EnvironmentTypesPlugin;\r\n\r\nimpl Plugin for EnvironmentTypesPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<TrackEnvironmentTag>();\r\n        app.register_type::<EnvironmentTracker>();\r\n        app.register_type::<EnvironmentKind>();\r\n        app.register_type::<HostEnvironment>();\r\n        app.register_type::<AgentEnvironment>();\r\n        app.register_type::<Nametag>();\r\n        app.add_event::<CreateEnvironmentRequestEvent>();\r\n        app.add_event::<PopulateEnvironmentEvent>();\r\n        app.add_event::<NametagEvent>();\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\level_bounds\\src\\lib.rs\r\n\r\n````rust\r\npub mod level_bounds_plugin;\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\app_types\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_app_types\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\movement_tool\\src\\movement_tool_tick_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse cursor_hero_character_types::prelude::*;\r\nuse cursor_hero_movement_tool_types::prelude::*;\r\nuse cursor_hero_physics::damping_plugin::DampingSystemSet;\r\nuse cursor_hero_toolbelt_types::prelude::*;\r\nuse leafwing_input_manager::prelude::*;\r\n\r\nuse bevy_xpbd_2d::math::*;\r\nuse bevy_xpbd_2d::prelude::*;\r\n\r\npub struct MovementToolTickPlugin;\r\n\r\nimpl Plugin for MovementToolTickPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_plugins(InputManagerPlugin::<MovementToolAction>::default());\r\n        app.add_systems(Update, handle_inputs.after(DampingSystemSet::Dampen));\r\n    }\r\n}\r\n\r\nfn handle_inputs(\r\n    time: Res<Time<Physics>>,\r\n    tool_query: Query<(&ActionState<MovementToolAction>, &MovementTool, &Parent), With<ActiveTool>>,\r\n    toolbelt_query: Query<&Parent, With<Toolbelt>>,\r\n    mut character_query: Query<&mut LinearVelocity, (With<Character>, Without<Camera>)>,\r\n    mut camera_query: Query<&mut LinearVelocity, (With<Camera>, Without<Character>)>,\r\n) {\r\n    let delta_time = time.delta_seconds_f64().adjust_precision();\r\n    for tool in tool_query.iter() {\r\n        let (tool_actions, tool, tool_parent) = tool;\r\n        if !tool_actions.pressed(MovementToolAction::Move) {\r\n            continue;\r\n        }\r\n        let Ok(toolbelt_parent) = toolbelt_query.get(tool_parent.get()) else {\r\n            continue;\r\n        };\r\n        let move_delta = delta_time\r\n            * tool_actions\r\n                .clamped_axis_pair(MovementToolAction::Move)\r\n                .unwrap()\r\n                .xy();\r\n        match tool.target {\r\n            MovementTarget::Character => {\r\n                let Ok(character) = character_query.get_mut(toolbelt_parent.get()) else {\r\n                    warn!(\"Character {:?} does not exist\", toolbelt_parent);\r\n                    continue;\r\n                };\r\n                let mut character_velocity = character;\r\n                character_velocity.x += move_delta.x * tool.speed;\r\n                character_velocity.y += move_delta.y * tool.speed;\r\n            }\r\n            MovementTarget::Camera(camera_id) => {\r\n                let Ok(camera) = camera_query.get_mut(camera_id) else {\r\n                    warn!(\"Camera {:?} does not exist\", camera_id);\r\n                    continue;\r\n                };\r\n                let mut camera_velocity = camera;\r\n                camera_velocity.x += move_delta.x * tool.speed;\r\n                camera_velocity.y += move_delta.y * tool.speed;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\level_bounds\\src\\level_bounds_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse bevy_xpbd_2d::components::Collider;\r\nuse bevy_xpbd_2d::components::CollidingEntities;\r\nuse bevy_xpbd_2d::components::LinearVelocity;\r\n\r\nuse bevy_xpbd_2d::components::RigidBody;\r\nuse bevy_xpbd_2d::components::Sensor;\r\nuse cursor_hero_character_types::prelude::*;\r\nuse cursor_hero_environment_types::prelude::*;\r\n\r\npub struct LevelBoundsPlugin;\r\n\r\nimpl Plugin for LevelBoundsPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<LevelBounds>();\r\n        app.register_type::<LevelBoundsHolder>();\r\n        app.register_type::<LevelBoundsParentRef>();\r\n        app.add_event::<LevelBoundsEvent>();\r\n        app.add_systems(Update, enforce);\r\n        app.add_systems(\r\n            Update,\r\n            (\r\n                handle_populate_environment_events,\r\n                apply_deferred,\r\n                handle_level_bounds_events,\r\n            )\r\n                .chain(),\r\n        );\r\n    }\r\n}\r\n\r\n#[derive(Event, Reflect, Debug, Clone, Copy)]\r\npub enum LevelBoundsEvent {\r\n    AddPlayArea { environment_id: Entity, area: Rect },\r\n}\r\n\r\n#[derive(Component, Reflect)]\r\npub struct LevelBoundsHolder;\r\n#[derive(Component, Reflect)]\r\npub struct LevelBoundsParentRef(Entity);\r\nimpl LevelBoundsParentRef {\r\n    pub fn get(&self) -> Entity {\r\n        self.0\r\n    }\r\n}\r\n#[derive(Component, Reflect)]\r\npub struct LevelBounds;\r\n\r\n#[allow(clippy::type_complexity)]\r\nfn handle_populate_environment_events(\r\n    mut commands: Commands,\r\n    mut events: EventReader<PopulateEnvironmentEvent>,\r\n    environment_query: Query<(), Or<(With<HostEnvironment>, With<AgentEnvironment>)>>,\r\n) {\r\n    for event in events.read() {\r\n        if !environment_query.contains(event.environment_id) {\r\n            continue;\r\n        }\r\n\r\n        info!(\r\n            \"Populating environment {:?} with level bounds parent\",\r\n            event\r\n        );\r\n        let mut level_bounds_holder_id = None;\r\n        commands\r\n            .entity(event.environment_id)\r\n            .with_children(|parent| {\r\n                level_bounds_holder_id = Some(\r\n                    parent\r\n                        .spawn((\r\n                            SpatialBundle::default(),\r\n                            LevelBoundsHolder,\r\n                            Name::new(\"Level Bounds\"),\r\n                        ))\r\n                        .id(),\r\n                );\r\n            });\r\n        let Some(level_bounds_holder_id) = level_bounds_holder_id else {\r\n            warn!(\r\n                \"Failed to create level bounds holder for environment {:?}\",\r\n                event\r\n            );\r\n            continue;\r\n        };\r\n        commands\r\n            .entity(event.environment_id)\r\n            .insert(LevelBoundsParentRef(level_bounds_holder_id));\r\n    }\r\n}\r\n\r\npub fn handle_level_bounds_events(\r\n    mut events: EventReader<LevelBoundsEvent>,\r\n    environment_query: Query<&LevelBoundsParentRef, With<EnvironmentKind>>,\r\n    mut commands: Commands,\r\n    mut deferred: Local<Vec<LevelBoundsEvent>>,\r\n) {\r\n    let mut new_deferred = Vec::new();\r\n    for event in events.read().chain(deferred.into_iter()) {\r\n        match event {\r\n            LevelBoundsEvent::AddPlayArea {\r\n                environment_id,\r\n                area,\r\n            } => {\r\n                if let Ok(level_bounds_parent_ref) = environment_query.get(*environment_id) {\r\n                    info!(\r\n                        \"Adding play area with size {:?} to level bounds for environment {:?}\",\r\n                        area.size(),\r\n                        environment_id\r\n                    );\r\n                    commands\r\n                        .entity(level_bounds_parent_ref.get())\r\n                        .with_children(|parent| {\r\n                            parent.spawn((\r\n                                SpriteBundle {\r\n                                    sprite: Sprite {\r\n                                        custom_size: Some(area.size()),\r\n                                        color: Color::ORANGE,\r\n                                        ..default()\r\n                                    },\r\n                                    transform: Transform::from_translation(\r\n                                        area.center().extend(-2.0),\r\n                                    ),\r\n                                    visibility: Visibility::Hidden,\r\n                                    ..default()\r\n                                },\r\n                                Sensor,\r\n                                RigidBody::Static,\r\n                                Collider::cuboid(area.size().x, area.size().y),\r\n                                LevelBounds,\r\n                                Name::new(\"Level Bounds\"),\r\n                            ));\r\n                        });\r\n                } else {\r\n                    debug!(\r\n                        \"Deferring level bounds event for environment {:?}\",\r\n                        environment_id\r\n                    );\r\n                    new_deferred.push(*event);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    *deferred = new_deferred;\r\n}\r\n\r\n#[allow(clippy::type_complexity)]\r\nfn enforce(\r\n    mut character_query: Query<\r\n        (Entity, &GlobalTransform, &mut LinearVelocity),\r\n        (With<Character>, Without<LevelBounds>),\r\n    >,\r\n    level_bounds: Query<\r\n        (&GlobalTransform, &CollidingEntities),\r\n        (With<LevelBounds>, Without<Character>),\r\n    >,\r\n) {\r\n    for (character_entity, character_transform, mut character_velocity) in\r\n        character_query.iter_mut()\r\n    {\r\n        let mut is_in_bounds = false;\r\n        for (_, in_bounds) in level_bounds.iter() {\r\n            if in_bounds.contains(&character_entity) {\r\n                is_in_bounds = true;\r\n                break;\r\n            }\r\n        }\r\n        if !is_in_bounds {\r\n            // debug!(\"Found {} level bounds\", level_bounds.iter().count());\r\n            // apply a force to to the character in the direction of the nearest boundary\r\n            let mut nearest_boundary = None;\r\n            let mut nearest_boundary_distance = f32::MAX;\r\n            for (bounds_transform, _) in level_bounds.iter() {\r\n                let distance = character_transform\r\n                    .translation()\r\n                    .distance(bounds_transform.translation());\r\n                // debug!(\"Distance to boundary: {}\", distance);\r\n                if distance < nearest_boundary_distance {\r\n                    nearest_boundary_distance = distance;\r\n                    nearest_boundary = Some(bounds_transform.translation());\r\n                }\r\n            }\r\n            if let Some(nearest_boundary) = nearest_boundary {\r\n                let direction = nearest_boundary - character_transform.translation();\r\n                character_velocity.0 +=\r\n                    direction.normalize().xy() * direction.length_squared() / 1000.0;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\movement_tool\\src\\movement_target_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse cursor_hero_movement_tool_types::prelude::*;\r\n\r\npub struct MovementTargetPlugin;\r\n\r\nimpl Plugin for MovementTargetPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Update, handle_set_movement_events);\r\n    }\r\n}\r\n\r\nfn handle_set_movement_events(\r\n    mut movement_target_events: EventReader<MovementTargetEvent>,\r\n    mut tool_query: Query<&mut MovementTool>,\r\n) {\r\n    for event in movement_target_events.read() {\r\n        match event {\r\n            MovementTargetEvent::SetTarget { tool_id, target } => {\r\n                let Ok(mut tool) = tool_query.get_mut(*tool_id) else {\r\n                    warn!(\"Tool {:?} does not exist\", tool_id);\r\n                    continue;\r\n                };\r\n                tool.target = *target;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\hover\\src\\lib.rs\r\n\r\n````rust\r\n#![feature(let_chains)]\r\npub mod hover_tool;\r\npub mod hover_ui_automation_plugin;\r\npub mod screenshot_tool;\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\calculator_app_types\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_calculator_app_types\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\environment_types\\src\\environment_types.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n\r\n#[derive(Component, Debug, Reflect, Clone, Copy)]\r\npub enum EnvironmentKind {\r\n    Host,\r\n    Agent,\r\n}\r\nimpl EnvironmentKind {\r\n    pub fn name(&self) -> &str {\r\n        match self {\r\n            EnvironmentKind::Host => \"Host Environment\",\r\n            EnvironmentKind::Agent => \"Agent Environment\",\r\n        }\r\n    }\r\n}\r\n\r\n#[derive(Component, Debug, Reflect, Eq, PartialEq)]\r\npub struct EnvironmentTracker {\r\n    pub environment_id: Entity,\r\n}\r\n\r\n#[derive(Component, Debug, Reflect)]\r\npub struct HostEnvironment;\r\n#[derive(Component, Debug, Reflect)]\r\npub struct AgentEnvironment;\r\n\r\n#[derive(Component, Default, Reflect)]\r\npub struct Nametag;\r\n\r\n#[derive(Component, Debug, Reflect)]\r\npub struct TrackEnvironmentTag;\r\n\r\n#[derive(Event, Debug, Reflect)]\r\npub struct CreateEnvironmentRequestEvent {\r\n    pub origin: Vec2,\r\n    pub kind: EnvironmentKind,\r\n}\r\n\r\n#[derive(Event, Debug, Reflect)]\r\npub struct PopulateEnvironmentEvent {\r\n    pub environment_id: Entity,\r\n}\r\n\r\n#[derive(Event, Debug, Reflect)]\r\npub enum NametagEvent {\r\n    Update {\r\n        environment_id: Entity,\r\n        name: String,\r\n    },\r\n    RecalculatePosition {\r\n        environment_id: Entity,\r\n    },\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\hover\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_hover\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nimage = { workspace = true}\r\nbevy_egui = {workspace = true}\r\ncursor_hero_tools = { workspace = true }\r\ncursor_hero_physics = { workspace = true }\r\ncursor_hero_toolbelt_types = { workspace = true}\r\ncursor_hero_pressure_plate = { workspace = true}\r\ncursor_hero_environment_types = { workspace = true}\r\ncursor_hero_screen = { workspace = true}\r\ncursor_hero_cursor_types = { workspace = true}\r\ncursor_hero_character_types = { workspace = true}\r\ncursor_hero_camera = { workspace = true}\r\ncursor_hero_bevy = { workspace = true}\r\ncursor_hero_ui_automation = { workspace = true}\r\ncursor_hero_winutils = { workspace = true}\r\nbevy = { workspace = true }\r\nitertools = { workspace = true }\r\nbevy-inspector-egui = { workspace = true }\r\nserde = { workspace = true }\r\nserde_json = { workspace = true }\r\nleafwing-input-manager = { workspace = true }\r\nuiautomation = { workspace = true }\r\nwindows = { workspace = true, features = [\r\n  \"Win32_Foundation\",\r\n  \"Win32_Graphics_Gdi\",\r\n  \"Win32_UI_WindowsAndMessaging\",\r\n  \"Win32_System_Com\",\r\n  \"Win32_UI_Accessibility\",\r\n  \"Win32_UI_Input_KeyboardAndMouse\",\r\n  \"Gaming_Input\",\r\n  \"Win32_Gaming\",\r\n  \"Win32_System_Threading\",\r\n] }\r\ncrossbeam-channel = { workspace = true }\r\ntokio = { workspace = true, features = [\"net\", \"full\"] }\r\ntokio-named-pipes = { workspace = true }\r\nbevy_xpbd_2d = { workspace = true }\r\nrand = { workspace = true }\r\ncursor_hero_floaty_nametag_types = { workspace = true }\r\ncursor_hero_worker = { workspace = true }\r\ncursor_hero_ui_hover_types = { workspace = true}\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\memory\\src\\voice_to_text_memory_plugin.rs\r\n\r\n````rust\r\nuse std::time::Duration;\r\n\r\nuse bevy::prelude::*;\r\nuse bevy::utils::Instant;\r\n\r\nuse cursor_hero_memory_types::prelude::*;\r\nuse cursor_hero_secret_types::secrets_types::SecretString;\r\nuse cursor_hero_voice_to_text_types::voice_to_text_types::VoiceToTextStatus;\r\nuse cursor_hero_voice_to_text_types::voice_to_text_types::VoiceToTextStatusEvent;\r\nuse serde::Deserialize;\r\nuse serde::Serialize;\r\n\r\npub struct VoiceToTextMemoryPlugin;\r\n\r\nimpl Plugin for VoiceToTextMemoryPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.insert_resource(VoiceToTextMemoryConfig::default());\r\n        app.add_systems(Update, persist.pipe(handle_persist_errors));\r\n        app.add_systems(Update, restore.pipe(handle_restore_errors));\r\n    }\r\n}\r\nconst PERSIST_FILE_NAME: &str = \"voice_to_text.json\";\r\n\r\n// not moved to lib to ensure log contains this module name\r\nfn handle_persist_errors(In(result): In<Result<PersistSuccess, PersistError>>) {\r\n    if let Err(e) = result {\r\n        error!(\"Persist error occurred: {:?}\", e);\r\n    } else if let Ok(PersistSuccess::WritePerformed) = result {\r\n        debug!(\"Persisted succeeded\");\r\n    }\r\n}\r\n\r\nfn handle_restore_errors(In(result): In<Result<RestoreSuccess, RestoreError>>) {\r\n    if let Err(e) = result {\r\n        error!(\"Restore error occurred: {:?}\", e);\r\n    } else if let Ok(RestoreSuccess::Performed) = result {\r\n        info!(\"Restore succeeded\");\r\n    }\r\n}\r\n\r\n#[derive(Debug, Resource, Reflect)]\r\n#[reflect(Resource)]\r\nstruct VoiceToTextMemoryConfig {\r\n    pub persist_cooldown: Timer,\r\n    pub restore_retry_cooldown: Duration,\r\n}\r\nimpl Default for VoiceToTextMemoryConfig {\r\n    fn default() -> Self {\r\n        Self {\r\n            persist_cooldown: Timer::from_seconds(10.0, TimerMode::Repeating),\r\n            restore_retry_cooldown: Duration::from_secs(60),\r\n        }\r\n    }\r\n}\r\n\r\n#[derive(Debug, Serialize, Deserialize, PartialEq, Clone)]\r\nstruct DiskData {\r\n    api_key: Option<SecretString>,\r\n}\r\n\r\nfn persist(\r\n    mut config: ResMut<VoiceToTextMemoryConfig>,\r\n    memory_config: Res<MemoryConfig>,\r\n    mut debounce: Local<Option<DiskData>>,\r\n    time: Res<Time>,\r\n    voice_status: Res<VoiceToTextStatus>,\r\n) -> Result<PersistSuccess, PersistError> {\r\n    if !config.persist_cooldown.tick(time.delta()).just_finished() {\r\n        return Ok(PersistSuccess::Cooldown);\r\n    }\r\n    let api_key = match &*voice_status {\r\n        VoiceToTextStatus::Alive { api_key, .. } | VoiceToTextStatus::Starting { api_key, .. } => {\r\n            Some(api_key.clone())\r\n        }\r\n        VoiceToTextStatus::Dead => None,\r\n        _ => {\r\n            return Ok(PersistSuccess::NoAction);\r\n        }\r\n    };\r\n    let data = DiskData { api_key };\r\n    if debounce.is_none() || debounce.as_ref().unwrap() != &data {\r\n        let file = get_persist_file(memory_config.as_ref(), PERSIST_FILE_NAME, Usage::Persist)\r\n            .map_err(PersistError::Io)?;\r\n        write_to_disk(file, data.clone())?;\r\n        *debounce = Some(data);\r\n        Ok(PersistSuccess::WritePerformed)\r\n    } else {\r\n        Ok(PersistSuccess::Debounce)\r\n    }\r\n}\r\n\r\nfn restore(\r\n    config: Res<VoiceToTextMemoryConfig>,\r\n    memory_config: Res<MemoryConfig>,\r\n    mut current_status: ResMut<VoiceToTextStatus>,\r\n    mut status_events: EventWriter<VoiceToTextStatusEvent>,\r\n    mut attempted_at: Local<Option<Instant>>,\r\n) -> Result<RestoreSuccess, RestoreError> {\r\n    if matches!(\r\n        *current_status,\r\n        VoiceToTextStatus::Alive { .. }\r\n            | VoiceToTextStatus::Starting { .. }\r\n            | VoiceToTextStatus::UnknownWithCachedApiKey { .. }\r\n            | VoiceToTextStatus::Dead\r\n    ) {\r\n        return Ok(RestoreSuccess::NoAction);\r\n    }\r\n    let file = match get_persist_file(memory_config.as_ref(), PERSIST_FILE_NAME, Usage::Restore) {\r\n        Ok(file) => Ok(file),\r\n        Err(e) => {\r\n            if let Some(attempt) = *attempted_at {\r\n                if attempt.elapsed() > config.restore_retry_cooldown {\r\n                    *attempted_at = Some(Instant::now());\r\n                    return Err(RestoreError::Io(e));\r\n                } else {\r\n                    // Silently ignore the error and retry later\r\n                    return Ok(RestoreSuccess::NoAction);\r\n                }\r\n            } else {\r\n                *attempted_at = Some(Instant::now());\r\n                return Err(RestoreError::Io(e));\r\n            }\r\n        }\r\n    }?;\r\n    let data: DiskData = read_from_disk(file)?;\r\n    let Some(api_key) = data.api_key else {\r\n        return Ok(RestoreSuccess::NoAction);\r\n    };\r\n\r\n    info!(\"Restoring api key\");\r\n\r\n    let new_status = match *current_status {\r\n        VoiceToTextStatus::Unknown\r\n        | VoiceToTextStatus::AliveButWeDontKnowTheApiKey\r\n        | VoiceToTextStatus::UnknownWithCachedApiKey { .. } => {\r\n            VoiceToTextStatus::UnknownWithCachedApiKey { api_key }\r\n        }\r\n        ref current => current.clone(),\r\n    };\r\n    if new_status != *current_status {\r\n        let event = VoiceToTextStatusEvent::Changed {\r\n            old_status: current_status.clone(),\r\n            new_status: new_status.clone(),\r\n        };\r\n        debug!(\"Sending event: {:?}\", event);\r\n        status_events.send(event);\r\n        *current_status = new_status;\r\n        Ok(RestoreSuccess::Performed)\r\n    } else {\r\n        Ok(RestoreSuccess::NoAction)\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\agent\\src\\agent_plugin.rs\r\n\r\n````rust\r\nuse crate::agent_movement_plugin::AgentMovementPlugin;\r\nuse crate::agent_spawning_plugin::AgentSpawningPlugin;\r\nuse crate::insert_agent_toolbelt::InsertAgentToolbeltPlugin;\r\nuse bevy::prelude::*;\r\n\r\npub struct AgentPlugin;\r\n\r\nimpl Plugin for AgentPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_plugins(InsertAgentToolbeltPlugin);\r\n        app.add_plugins(AgentSpawningPlugin);\r\n        app.add_plugins(AgentMovementPlugin);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\bevy\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_bevy\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = {workspace = true}\r\ncursor_hero_math = {workspace = true}\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\agent_types\\src\\agent_types.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n\r\n#[derive(Component, Reflect, Debug)]\r\npub struct Agent;\r\n\r\n#[derive(Reflect, Eq, PartialEq, Debug)]\r\npub enum AgentAppearance {\r\n    Default,\r\n}\r\nimpl AgentAppearance {\r\n    pub fn get_texture_path(&self) -> &'static str {\r\n        match self {\r\n            Self::Default => \"textures/agent/default_agent.png\",\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\host_fs\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_host_fs\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\ncursor_hero_host_fs_types = { workspace = true }\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\bevy\\src\\rect_with_properties.rs\r\n\r\n````rust\r\nuse bevy::math::Rect;\r\nuse bevy::math::Vec2;\r\n\r\npub trait RectWithHeight {\r\n    fn with_height(&self, height: f32) -> Rect;\r\n}\r\nimpl RectWithHeight for Rect {\r\n    fn with_height(&self, height: f32) -> Rect {\r\n        Rect::from_center_size(self.center(), Vec2::new(self.width(), height))\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\calculator_app_types\\src\\lib.rs\r\n\r\n````rust\r\npub mod calculator_app_types;\r\npub mod calculator_app_types_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::calculator_app_types::*;\r\n    pub use crate::calculator_app_types_plugin::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\hover\\src\\hover_tool.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse cursor_hero_toolbelt_types::prelude::*;\r\nuse cursor_hero_tools::prelude::*;\r\nuse cursor_hero_ui_hover_types::prelude::HoverInfo;\r\n\r\npub struct HoverToolPlugin;\r\n\r\nimpl Plugin for HoverToolPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<HoverTool>();\r\n        app.add_systems(Update, toolbelt_events);\r\n        app.add_systems(Update, tick);\r\n    }\r\n}\r\n\r\n#[derive(Component, Reflect, Default)]\r\nstruct HoverTool;\r\n\r\nfn toolbelt_events(\r\n    mut commands: Commands,\r\n    asset_server: Res<AssetServer>,\r\n    mut reader: EventReader<ToolbeltPopulateEvent>,\r\n) {\r\n    for event in reader.read() {\r\n        if event.loadout != ToolbeltLoadout::Default {\r\n            continue;\r\n        }\r\n        ToolSpawnConfig::<HoverTool, NoInputs>::new(HoverTool, event.id, event)\r\n            .with_src_path(file!().into())\r\n            .guess_name(file!())\r\n            .guess_image(file!(), &asset_server, \"png\")\r\n            .with_description(\"UI hover visuals\")\r\n            .spawn(&mut commands);\r\n    }\r\n}\r\n\r\nfn tick(\r\n    tool_query: Query<Entity, (With<ActiveTool>, With<HoverTool>)>,\r\n    mut hover_info: ResMut<HoverInfo>,\r\n) {\r\n    if tool_query.iter().next().is_some() {\r\n        if !hover_info.enabled {\r\n            info!(\"Enabling hover info\");\r\n            hover_info.enabled = true;\r\n        }\r\n    } else if hover_info.enabled {\r\n        info!(\"Disabling hover info\");\r\n        hover_info.enabled = false;\r\n        hover_info.host_element = None;\r\n        hover_info.game_element = None;\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\inference\\src\\inference_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n\r\nuse crate::prompt_asset_plugin::PromptAssetPlugin;\r\n\r\npub struct InferencePlugin;\r\n\r\nimpl Plugin for InferencePlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_plugins(PromptAssetPlugin);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\host_fs\\src\\host_fs_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse cursor_hero_host_fs_types::host_fs_types::HostPathAction;\r\n\r\npub struct HostFsPlugin;\r\n\r\nimpl Plugin for HostFsPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Update, handle_host_path_events);\r\n    }\r\n}\r\n\r\nfn handle_host_path_events(mut host_path_events: EventReader<HostPathAction>) {\r\n    for event in host_path_events.read() {\r\n        match event {\r\n            HostPathAction::OpenWithCode { path } => {\r\n                println!(\"Open with code: {:?}\", path);\r\n                let Some(x) = path.path.to_str() else {\r\n                    continue;\r\n                };\r\n                if let Err(e) = std::process::Command::new(\"code.cmd\").arg(x).spawn() {\r\n                    error!(\"Failed to open with code: {:?}\", e);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\fullscreen_tool_types\\src\\fullscreen_tool_types.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse bevy::window::WindowMode;\r\nuse bevy_inspector_egui::prelude::ReflectInspectorOptions;\r\nuse bevy_inspector_egui::InspectorOptions;\r\nuse cursor_hero_tools::tool_spawning::StartingState;\r\n\r\n#[derive(Component, Reflect, Debug, InspectorOptions, Default)]\r\n#[reflect(Component, InspectorOptions)]\r\npub struct FullscreenTool;\r\n\r\nimpl FullscreenTool {\r\n    pub fn state_for_mode(mode: WindowMode) -> StartingState {\r\n        match mode {\r\n            WindowMode::Windowed => StartingState::Inactive,\r\n            _ => StartingState::Active,\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\movement_tool_types\\src\\lib.rs\r\n\r\n````rust\r\npub mod movement_tool_types;\r\npub mod movement_tool_types_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::movement_tool_types::*;\r\n    pub use crate::movement_tool_types_plugin::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\brick_types\\src\\brick_types.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n\r\n#[derive(Component, Debug, Reflect)]\r\npub struct Brick;\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\glados_tts_types\\src\\lib.rs\r\n\r\n````rust\r\npub mod glados_tts_types;\r\npub mod glados_tts_types_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::glados_tts_types::*;\r\n    pub use crate::glados_tts_types_plugin::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\cursor\\src\\cursor_reach_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse cursor_hero_character_types::prelude::*;\r\nuse cursor_hero_math::prelude::Lerp;\r\nuse cursor_hero_cursor_types::prelude::*;\r\n\r\nuse cursor_hero_sprint_tool_types::sprint_tool_types_plugin::SprintEvent;\r\nuse cursor_hero_toolbelt_types::toolbelt_types::Wheel;\r\n\r\npub struct CursorReachPlugin;\r\n\r\nimpl Plugin for CursorReachPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Update, handle_reach_events);\r\n        app.add_systems(Update, handle_sprint_events);\r\n    }\r\n}\r\n\r\nfn handle_reach_events(\r\n    mut reach_events: EventReader<CursorReachEvent>,\r\n    character_query: Query<&Children, With<Character>>,\r\n    mut cursor_query: Query<&mut Cursor>,\r\n) {\r\n    for event in reach_events.read() {\r\n        match event {\r\n            CursorReachEvent::SetCursor { cursor_id, reach } => {\r\n                let Ok(mut cursor) = cursor_query.get_mut(*cursor_id) else {\r\n                    warn!(\"cursor not found processing {:?}\", event);\r\n                    continue;\r\n                };\r\n                cursor.reach = *reach;\r\n            }\r\n            CursorReachEvent::SetCursorPercent {\r\n                cursor_id,\r\n                percent,\r\n            } => {\r\n                let Ok(mut cursor) = cursor_query.get_mut(*cursor_id) else {\r\n                    warn!(\"cursor not found processing {:?}\", event);\r\n                    continue;\r\n                };\r\n                cursor.reach = (cursor.default_reach, cursor.sprint_reach).lerp(*percent);\r\n            }\r\n\r\n            CursorReachEvent::SetCharacter {\r\n                character_id,\r\n                reach,\r\n            } => {\r\n                let Ok(character) = character_query.get(*character_id) else {\r\n                    warn!(\"Character not found processing {:?}\", event);\r\n                    continue;\r\n                };\r\n                let mut found = false;\r\n                for kid in character.iter() {\r\n                    let Ok(mut cursor) = cursor_query.get_mut(*kid) else {\r\n                        continue;\r\n                    };\r\n                    cursor.reach = *reach;\r\n                    found = true;\r\n                }\r\n                if !found {\r\n                    warn!(\"cursor not found processing {:?}\", event);\r\n                }\r\n            }\r\n            CursorReachEvent::SetCharacterPercent {\r\n                character_id,\r\n                percent,\r\n            } => {\r\n                let Ok(character) = character_query.get(*character_id) else {\r\n                    warn!(\"Character not found processing {:?}\", event);\r\n                    continue;\r\n                };\r\n                let mut found = false;\r\n                for kid in character.iter() {\r\n                    let Ok(mut cursor) = cursor_query.get_mut(*kid) else {\r\n                        continue;\r\n                    };\r\n                    cursor.reach = (cursor.default_reach, cursor.sprint_reach).lerp(*percent);\r\n                    found = true;\r\n                }\r\n                if !found {\r\n                    warn!(\"cursor not found processing {:?}\", event);\r\n                }\r\n            }\r\n\r\n            CursorReachEvent::ResetCursor { cursor_id } => {\r\n                let Ok(mut cursor) = cursor_query.get_mut(*cursor_id) else {\r\n                    warn!(\"cursor not found processing {:?}\", event);\r\n                    continue;\r\n                };\r\n                cursor.reach = cursor.default_reach;\r\n            }\r\n            CursorReachEvent::ResetCharacter { character_id } => {\r\n                let Ok(character) = character_query.get(*character_id) else {\r\n                    warn!(\"Character not found processing {:?}\", event);\r\n                    continue;\r\n                };\r\n                let mut found = false;\r\n                for kid in character.iter() {\r\n                    let Ok(mut cursor) = cursor_query.get_mut(*kid) else {\r\n                        continue;\r\n                    };\r\n                    cursor.reach = cursor.default_reach;\r\n                    found = true;\r\n                }\r\n                if !found {\r\n                    warn!(\"cursor not found processing {:?}\", event);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfn handle_sprint_events(\r\n    mut reach_events: EventWriter<CursorReachEvent>,\r\n    mut sprint_events: EventReader<SprintEvent>,\r\n    character_query: Query<&Children, With<Character>>,\r\n    toolbelt_query: Query<&Wheel, With<Character>>,\r\n) {\r\n    for event in sprint_events.read() {\r\n        let character_id = match event {\r\n            SprintEvent::Active { character_id, .. } => character_id,\r\n            SprintEvent::Stop { character_id } => character_id,\r\n        };\r\n        let Ok(character) = character_query.get(*character_id) else {\r\n            warn!(\"Character not found processing {:?}\", event);\r\n            continue;\r\n        };\r\n        let toolbelt_open = character.iter().any(|kid| {\r\n            let Ok(toolbelt) = toolbelt_query.get(*kid) else {\r\n                return false;\r\n            };\r\n            toolbelt.open\r\n        });\r\n        if toolbelt_open {\r\n            // Toolbelt reach updates take priority over sprint reach updates\r\n            continue;\r\n        }\r\n        match event {\r\n            SprintEvent::Active {\r\n                character_id,\r\n                throttle,\r\n            } => {\r\n                reach_events.send(CursorReachEvent::SetCharacterPercent {\r\n                    character_id: *character_id,\r\n                    percent: *throttle,\r\n                });\r\n            }\r\n            SprintEvent::Stop { character_id } => {\r\n                reach_events.send(CursorReachEvent::ResetCharacter {\r\n                    character_id: *character_id,\r\n                });\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\bevy\\src\\rect_scaled.rs\r\n\r\n````rust\r\nuse bevy::math::IRect;\r\nuse bevy::math::Rect;\r\nuse bevy::math::URect;\r\nuse bevy::math::Vec2;\r\n\r\npub trait RectScale {\r\n    fn scale(&self, scale: Vec2) -> Rect;\r\n}\r\nimpl RectScale for Rect {\r\n    fn scale(&self, scale: Vec2) -> Rect {\r\n        Rect {\r\n            min: self.min * scale,\r\n            max: self.max * scale,\r\n        }\r\n    }\r\n}\r\n\r\npub trait IRectScale {\r\n    fn scale(&self, scale: Vec2) -> IRect;\r\n}\r\nimpl IRectScale for IRect {\r\n    fn scale(&self, scale: Vec2) -> IRect {\r\n        IRect {\r\n            min: (self.min.as_vec2() * scale).as_ivec2(),\r\n            max: (self.max.as_vec2() * scale).as_ivec2(),\r\n        }\r\n    }\r\n}\r\n\r\npub trait URectScale {\r\n    fn scale(&self, scale: Vec2) -> URect;\r\n}\r\nimpl URectScale for URect {\r\n    fn scale(&self, scale: Vec2) -> URect {\r\n        URect {\r\n            min: (self.min.as_vec2() * scale).as_uvec2(),\r\n            max: (self.max.as_vec2() * scale).as_uvec2(),\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\bevy\\src\\neg_y.rs\r\n\r\n````rust\r\nuse bevy::math::IRect;\r\nuse bevy::math::IVec2;\r\nuse bevy::math::IVec3;\r\nuse bevy::math::Rect;\r\nuse bevy::math::Vec2;\r\nuse bevy::math::Vec3;\r\n\r\npub trait NegativeYRect {\r\n    fn neg_y(&self) -> Rect;\r\n}\r\nimpl NegativeYRect for Rect {\r\n    fn neg_y(&self) -> Rect {\r\n        Rect::from_center_size(self.center().neg_y(), self.size())\r\n    }\r\n}\r\n\r\npub trait NegativeYIRect {\r\n    fn neg_y(&self) -> IRect;\r\n}\r\nimpl NegativeYIRect for IRect {\r\n    fn neg_y(&self) -> IRect {\r\n        IRect::from_center_size(self.center().neg_y(), self.size())\r\n    }\r\n}\r\n\r\npub trait NegativeYVec2 {\r\n    fn neg_y(&self) -> Vec2;\r\n}\r\nimpl NegativeYVec2 for Vec2 {\r\n    fn neg_y(&self) -> Vec2 {\r\n        Vec2::new(self.x, -self.y)\r\n    }\r\n}\r\n\r\npub trait NegativeYIVec2 {\r\n    fn neg_y(&self) -> IVec2;\r\n}\r\nimpl NegativeYIVec2 for IVec2 {\r\n    fn neg_y(&self) -> IVec2 {\r\n        IVec2::new(self.x, -self.y)\r\n    }\r\n}\r\n\r\npub trait NegativeYVec3 {\r\n    fn neg_y(&self) -> Vec3;\r\n}\r\nimpl NegativeYVec3 for Vec3 {\r\n    fn neg_y(&self) -> Vec3 {\r\n        Vec3::new(self.x, -self.y, self.z)\r\n    }\r\n}\r\n\r\npub trait NegativeYIVec3 {\r\n    fn neg_y(&self) -> IVec3;\r\n}\r\nimpl NegativeYIVec3 for IVec3 {\r\n    fn neg_y(&self) -> IVec3 {\r\n        IVec3::new(self.x, -self.y, self.z)\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\memory_types\\src\\memory_types.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse std::fs::File;\r\nuse std::fs::OpenOptions;\r\nuse std::io::Read;\r\nuse std::io::Write;\r\nuse std::path::PathBuf;\r\n\r\n#[derive(Resource, Reflect, Clone)]\r\npub struct MemoryConfig {\r\n    pub save_dir: String,\r\n}\r\n\r\n#[derive(Reflect, Default)]\r\npub struct MemoryPluginBuildConfig {\r\n    pub main_character_memory_enabled: bool,\r\n    pub primary_window_memory_enabled: bool,\r\n    pub main_camera_memory_enabled: bool,\r\n    pub voice_to_text_memory_enabled: bool,\r\n    pub agent_observation_memory_enabled: bool,\r\n}\r\n\r\nimpl MemoryPluginBuildConfig {\r\n    pub fn all_enabled() -> Self {\r\n        Self {\r\n            main_character_memory_enabled: true,\r\n            primary_window_memory_enabled: true,\r\n            main_camera_memory_enabled: true,\r\n            voice_to_text_memory_enabled: true,\r\n            agent_observation_memory_enabled: true,\r\n        }\r\n    }\r\n}\r\n\r\n#[derive(Debug)]\r\n#[allow(dead_code)]\r\npub enum PersistError {\r\n    Io(std::io::Error),\r\n    WindowBounds(cursor_hero_winutils::win_window::WindowBoundsError),\r\n    Query,\r\n    Json(serde_json::Error),\r\n}\r\n\r\n#[derive(Debug)]\r\npub enum PersistSuccess {\r\n    WritePerformed,\r\n    Debounce,\r\n    Cooldown,\r\n    NoAction,\r\n}\r\n\r\n#[derive(Debug)]\r\n#[allow(dead_code)]\r\npub enum RestoreError {\r\n    Io(std::io::Error),\r\n    Json(serde_json::Error),\r\n    Query,\r\n}\r\n\r\n#[derive(Debug)]\r\npub enum RestoreSuccess {\r\n    Performed,\r\n    NoAction,\r\n}\r\n\r\n#[derive(Eq, PartialEq)]\r\npub enum Usage {\r\n    Persist,\r\n    Restore,\r\n}\r\n\r\npub fn get_persist_file(\r\n    config: &MemoryConfig,\r\n    file_name: &str,\r\n    usage: Usage,\r\n) -> Result<std::fs::File, std::io::Error> {\r\n    let mut file_path = PathBuf::from(config.save_dir.clone());\r\n    if usage == Usage::Persist && !file_path.exists() {\r\n        std::fs::create_dir_all(&file_path)?;\r\n    }\r\n    file_path.push(file_name);\r\n\r\n    let file = match usage {\r\n        Usage::Persist => OpenOptions::new()\r\n            .write(true)\r\n            .truncate(true)\r\n            .create(true)\r\n            .open(file_path)?,\r\n        Usage::Restore => OpenOptions::new().read(true).open(file_path)?,\r\n    };\r\n    Ok(file)\r\n}\r\n\r\npub fn write_to_disk<T>(mut file: File, data: T) -> Result<PersistSuccess, PersistError>\r\nwhere\r\n    T: serde::Serialize,\r\n{\r\n    let serialized = serde_json::to_string_pretty(&data).map_err(PersistError::Json)?;\r\n    file.write_all(serialized.as_bytes())\r\n        .map_err(PersistError::Io)?;\r\n    Ok(PersistSuccess::WritePerformed)\r\n}\r\n\r\npub fn read_from_disk<T>(mut file: File) -> Result<T, RestoreError>\r\nwhere\r\n    T: serde::de::DeserializeOwned,\r\n{\r\n    let mut contents = String::new();\r\n    file.read_to_string(&mut contents)\r\n        .map_err(RestoreError::Io)?;\r\n    let data = serde_json::from_str(&contents).map_err(RestoreError::Json)?;\r\n    Ok(data)\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\bevy\\src\\rect_extents.rs\r\n\r\n````rust\r\nuse bevy::math::IRect;\r\nuse bevy::math::IVec2;\r\nuse bevy::math::Rect;\r\nuse bevy::math::Vec2;\r\nuse cursor_hero_math::prelude::Corner;\r\n\r\npub trait CornerOfRect {\r\n    fn of(&self, rect: &Rect) -> Vec2;\r\n}\r\nimpl CornerOfRect for Corner {\r\n    fn of(&self, rect: &Rect) -> Vec2 {\r\n        match self {\r\n            Corner::TopLeft => rect.top_left(),\r\n            Corner::TopRight => rect.top_right(),\r\n            Corner::BottomLeft => rect.bottom_left(),\r\n            Corner::BottomRight => rect.bottom_right(),\r\n        }\r\n    }\r\n}\r\n\r\npub trait CornerOfIRect {\r\n    fn of(&self, rect: &IRect) -> IVec2;\r\n}\r\nimpl CornerOfIRect for Corner {\r\n    fn of(&self, rect: &IRect) -> IVec2 {\r\n        match self {\r\n            Corner::TopLeft => rect.top_left(),\r\n            Corner::TopRight => rect.top_right(),\r\n            Corner::BottomLeft => rect.bottom_left(),\r\n            Corner::BottomRight => rect.bottom_right(),\r\n        }\r\n    }\r\n}\r\n\r\npub trait TopRight {\r\n    fn top_right(&self) -> Vec2;\r\n}\r\nimpl TopRight for Rect {\r\n    fn top_right(&self) -> Vec2 {\r\n        Vec2::new(self.max.x, self.min.y)\r\n    }\r\n}\r\n\r\npub trait TopRightI {\r\n    fn top_right(&self) -> IVec2;\r\n}\r\nimpl TopRightI for IRect {\r\n    fn top_right(&self) -> IVec2 {\r\n        IVec2::new(self.max.x, self.min.y)\r\n    }\r\n}\r\n\r\npub trait BottomLeft {\r\n    fn bottom_left(&self) -> Vec2;\r\n}\r\nimpl BottomLeft for Rect {\r\n    fn bottom_left(&self) -> Vec2 {\r\n        Vec2::new(self.min.x, self.max.y)\r\n    }\r\n}\r\n\r\npub trait BottomLeftI {\r\n    fn bottom_left(&self) -> IVec2;\r\n}\r\nimpl BottomLeftI for IRect {\r\n    fn bottom_left(&self) -> IVec2 {\r\n        IVec2::new(self.min.x, self.max.y)\r\n    }\r\n}\r\n\r\npub trait BottomRight {\r\n    fn bottom_right(&self) -> Vec2;\r\n}\r\nimpl BottomRight for Rect {\r\n    fn bottom_right(&self) -> Vec2 {\r\n        self.max\r\n    }\r\n}\r\n\r\npub trait BottomRightI {\r\n    fn bottom_right(&self) -> IVec2;\r\n}\r\nimpl BottomRightI for IRect {\r\n    fn bottom_right(&self) -> IVec2 {\r\n        self.max\r\n    }\r\n}\r\n\r\npub trait TopLeft {\r\n    fn top_left(&self) -> Vec2;\r\n}\r\nimpl TopLeft for Rect {\r\n    fn top_left(&self) -> Vec2 {\r\n        self.min\r\n    }\r\n}\r\n\r\npub trait TopLeftI {\r\n    fn top_left(&self) -> IVec2;\r\n}\r\nimpl TopLeftI for IRect {\r\n    fn top_left(&self) -> IVec2 {\r\n        self.min\r\n    }\r\n}\r\n\r\npub trait Left {\r\n    fn left(&self) -> f32;\r\n}\r\nimpl Left for Rect {\r\n    fn left(&self) -> f32 {\r\n        self.min.x\r\n    }\r\n}\r\n\r\npub trait LeftI {\r\n    fn left(&self) -> i32;\r\n}\r\nimpl LeftI for IRect {\r\n    fn left(&self) -> i32 {\r\n        self.min.x\r\n    }\r\n}\r\n\r\npub trait Right {\r\n    fn right(&self) -> f32;\r\n}\r\nimpl Right for Rect {\r\n    fn right(&self) -> f32 {\r\n        self.max.x\r\n    }\r\n}\r\n\r\npub trait RightI {\r\n    fn right(&self) -> i32;\r\n}\r\nimpl RightI for IRect {\r\n    fn right(&self) -> i32 {\r\n        self.max.x\r\n    }\r\n}\r\n\r\npub trait Bottom {\r\n    fn bottom(&self) -> f32;\r\n}\r\nimpl Bottom for Rect {\r\n    fn bottom(&self) -> f32 {\r\n        self.min.y\r\n    }\r\n}\r\n\r\npub trait BottomI {\r\n    fn bottom(&self) -> i32;\r\n}\r\nimpl BottomI for IRect {\r\n    fn bottom(&self) -> i32 {\r\n        self.min.y\r\n    }\r\n}\r\n\r\npub trait Top {\r\n    fn top(&self) -> f32;\r\n}\r\nimpl Top for Rect {\r\n    fn top(&self) -> f32 {\r\n        self.max.y\r\n    }\r\n}\r\n\r\npub trait TopI {\r\n    fn top(&self) -> i32;\r\n}\r\nimpl TopI for IRect {\r\n    fn top(&self) -> i32 {\r\n        self.max.y\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\cursor\\src\\cursor_mirroring_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse bevy::sprite::Anchor;\r\nuse cursor_hero_cursor_types::prelude::*;\r\nuse cursor_hero_winutils::win_mouse::get_cursor_position;\r\nuse cursor_hero_worker::prelude::anyhow::Result;\r\nuse cursor_hero_worker::prelude::WorkerMessage;\r\nuse cursor_hero_worker::prelude::Sender;\r\nuse cursor_hero_worker::prelude::WorkerConfig;\r\nuse cursor_hero_worker::prelude::WorkerPlugin;\r\n\r\npub struct CursorMirroringPlugin;\r\nimpl Plugin for CursorMirroringPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_plugins(WorkerPlugin {\r\n            config: WorkerConfig::<ThreadboundCursorMessage, GameboundCursorMessage, ()> {\r\n                name: \"cursor_mirroring\".to_string(),\r\n                handle_threadbound_message: handle_threadbound_message,\r\n                threadbound_message_receiver: |_thread_rx, _state| {\r\n                    // Keep the thread working on the task without waiting for a message\r\n                    Ok(ThreadboundCursorMessage::CaptureCursorPosition)\r\n                },\r\n                sleep_duration: std::time::Duration::from_nanos(500),\r\n                ..default()\r\n            },\r\n        });\r\n        app.add_systems(Startup, spawn_cursor);\r\n        app.add_systems(Update, (handle_gamebound_messages, update_visuals).chain());\r\n        app.insert_resource(HostCursorPosition::default());\r\n    }\r\n}\r\n\r\n#[derive(Debug, Reflect, Clone, Event)]\r\nenum ThreadboundCursorMessage {\r\n    CaptureCursorPosition,\r\n}\r\nimpl WorkerMessage for ThreadboundCursorMessage {}\r\n\r\n// This can be made public in the types crate if the need arises\r\n#[derive(Debug, Reflect, Clone, Event)]\r\nenum GameboundCursorMessage {\r\n    HostCursorPosition(IVec2),\r\n}\r\nimpl WorkerMessage for GameboundCursorMessage {}\r\n\r\nfn handle_threadbound_message(\r\n    msg: &ThreadboundCursorMessage,\r\n    reply_tx: &Sender<GameboundCursorMessage>,\r\n    _state: &mut (),\r\n) -> Result<()> {\r\n    let ThreadboundCursorMessage::CaptureCursorPosition = msg;\r\n    let pos = get_cursor_position()?;\r\n    reply_tx.send(GameboundCursorMessage::HostCursorPosition(pos))?;\r\n    Ok(())\r\n}\r\n\r\nfn handle_gamebound_messages(\r\n    mut rx: EventReader<GameboundCursorMessage>,\r\n    mut res: ResMut<HostCursorPosition>,\r\n) {\r\n    if rx.is_empty() {\r\n        return;\r\n    }\r\n    let mut latest = None;\r\n    for msg in rx.read() {\r\n        latest = Some(msg);\r\n    }\r\n    if let Some(GameboundCursorMessage::HostCursorPosition(pos)) = latest {\r\n        res.0 = pos.clone();\r\n    }\r\n}\r\n\r\nfn spawn_cursor(mut commands: Commands, asset_server: Res<AssetServer>) {\r\n    commands.spawn((\r\n        SpriteBundle {\r\n            transform: Transform::from_xyz(0.0, 0.0, 20.0),\r\n            sprite: Sprite {\r\n                // custom_size: Some(Vec2::new(20.0, 20.0)),\r\n                anchor: Anchor::TopLeft,\r\n                ..default()\r\n            },\r\n\r\n            texture: asset_server.load(\"textures/cursor.png\"),\r\n            ..default()\r\n        },\r\n        CursorMirror,\r\n        Name::new(\"Cursor Mirror\"),\r\n    ));\r\n}\r\n\r\nfn update_visuals(\r\n    mut cursor_mirrors: Query<(&mut Transform, &CursorMirror)>,\r\n    cursor_position: Res<HostCursorPosition>,\r\n) {\r\n    for (mut transform, _) in &mut cursor_mirrors.iter_mut() {\r\n        transform.translation.x = cursor_position.x as f32;\r\n        transform.translation.y = -cursor_position.y as f32;\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\host_event_types\\src\\host_event_types_plugin.rs\r\n\r\n````rust\r\nuse crate::prelude::*;\r\nuse bevy::prelude::*;\r\n\r\npub struct HostEventTypesPlugin;\r\n\r\nimpl Plugin for HostEventTypesPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_event::<HostEvent>();\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\memory_types\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_memory_types\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\ncursor_hero_winutils = { workspace = true }\r\ncursor_hero_character_types = { workspace = true }\r\ncursor_hero_camera = { workspace = true }\r\ncursor_hero_toolbelt_types = { workspace = true }\r\ncursor_hero_voice_to_text_types = { workspace = true }\r\ncursor_hero_secret_types = { workspace = true }\r\ncursor_hero_observation_types = { workspace = true }\r\nraw-window-handle = { workspace = true }\r\nserde = { workspace = true, features=[\"derive\"] }\r\nserde_json = { workspace = true }\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\fullscreen_tool\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_fullscreen_tool\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\ncursor_hero_fullscreen_tool_types = { workspace = true }\r\ncursor_hero_toolbelt_types = { workspace = true }\r\ncursor_hero_tools = { workspace = true }\r\nleafwing-input-manager = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\agent_types\\src\\agent_types_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n\r\nuse crate::prelude::*;\r\n\r\npub struct AgentTypesPlugin;\r\n\r\nimpl Plugin for AgentTypesPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<Agent>();\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\camera\\src\\camera_plugin.rs\r\n\r\n````rust\r\nuse bevy::ecs::query::QuerySingleError::MultipleEntities;\r\nuse bevy::ecs::query::QuerySingleError::NoEntities;\r\nuse bevy::input::mouse::MouseWheel;\r\nuse bevy::prelude::*;\r\nuse bevy::transform::TransformSystem;\r\nuse bevy::window::PrimaryWindow;\r\nuse bevy_egui::EguiContext;\r\nuse bevy_xpbd_2d::prelude::*;\r\nuse cursor_hero_physics::damping_plugin::MovementDamping;\r\npub struct CameraPlugin;\r\nimpl Plugin for CameraPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<MainCamera>();\r\n        app.add_event::<CameraEvent>();\r\n        app.add_systems(Startup, spawn_camera);\r\n        app.add_systems(Update, (update_camera_zoom, handle_events));\r\n        app.add_systems(\r\n            PostUpdate,\r\n            follow\r\n                .in_set(CameraSystemSet::Follow)\r\n                .after(PhysicsSet::Sync)\r\n                .before(TransformSystem::TransformPropagate),\r\n        );\r\n    }\r\n}\r\n\r\n#[derive(SystemSet, Clone, Hash, Debug, PartialEq, Eq)]\r\npub enum CameraSystemSet {\r\n    Follow,\r\n}\r\n\r\n#[derive(Component, Reflect)]\r\npub struct MainCamera;\r\n\r\nfn spawn_camera(mut commands: Commands) {\r\n    commands.spawn((\r\n        Camera2dBundle::default(),\r\n        MainCamera,\r\n        MovementDamping { factor: 0.90 },\r\n        MassPropertiesBundle::new_computed(&Collider::ball(10.0), 1.0),\r\n        RigidBody::Dynamic,\r\n        SpatialListener::new(-7.0),\r\n    ));\r\n}\r\n\r\n#[derive(Component)]\r\npub struct FollowWithMainCamera;\r\n\r\n#[derive(Event, Debug, Reflect)]\r\npub enum CameraEvent {\r\n    BeginFollowing { target_id: Entity },\r\n    StopFollowing { target_id: Entity },\r\n}\r\n\r\npub fn update_camera_zoom(\r\n    mut cam: Query<&mut Transform, With<MainCamera>>,\r\n    mut scroll: EventReader<MouseWheel>,\r\n    egui_context_query: Query<&EguiContext, With<PrimaryWindow>>,\r\n) {\r\n    let Ok(egui_context) = egui_context_query.get_single() else {\r\n        return;\r\n    };\r\n    let hovering_over_egui = egui_context.clone().get_mut().is_pointer_over_area();\r\n    if hovering_over_egui {\r\n        scroll.clear();\r\n        return;\r\n    }\r\n    for event in scroll.read() {\r\n        let mut scale = cam.single_mut().scale;\r\n        scale *= Vec2::splat(1.0 - event.y / 10.0).extend(1.0);\r\n        scale = scale.clamp(Vec3::splat(0.1), Vec3::splat(10.0));\r\n        cam.single_mut().scale = scale;\r\n    }\r\n}\r\n\r\nfn handle_events(\r\n    mut commands: Commands,\r\n    mut camera_events: EventReader<CameraEvent>,\r\n    character_query: Query<&GlobalTransform, Without<MainCamera>>,\r\n    mut camera_query: Query<&mut Transform, With<MainCamera>>,\r\n) {\r\n    for event in camera_events.read() {\r\n        match event {\r\n            CameraEvent::BeginFollowing { target_id } => {\r\n                info!(\"Camera following character '{:?}'\", target_id);\r\n                // tag character to mark it as being followed\r\n                commands.entity(*target_id).insert(FollowWithMainCamera);\r\n                if let Ok(mut camera_transform) = camera_query.get_single_mut()\r\n                    && let Ok(character_transform) = character_query.get_single()\r\n                {\r\n                    camera_transform.translation = character_transform.translation();\r\n                }\r\n            }\r\n            CameraEvent::StopFollowing { target_id } => {\r\n                info!(\"Camera stopped following character '{:?}'\", target_id);\r\n                // remove tag from character\r\n                commands.entity(*target_id).remove::<FollowWithMainCamera>();\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfn follow(\r\n    follow_query: Query<&GlobalTransform, With<FollowWithMainCamera>>,\r\n    mut cam_query: Query<&mut Transform, With<MainCamera>>,\r\n) {\r\n    let follow = match follow_query.get_single() {\r\n        Ok(follow) => follow,\r\n        Err(NoEntities(_)) => return,\r\n        Err(MultipleEntities(e)) => {\r\n            error!(\"Multiple entities are being followed: {:?}\", e);\r\n            return;\r\n        }\r\n    };\r\n    let follow_global_transform = follow;\r\n\r\n    let camera = match cam_query.get_single_mut() {\r\n        Ok(camera) => camera,\r\n        Err(NoEntities(_)) => return,\r\n        Err(MultipleEntities(e)) => {\r\n            error!(\"Multiple cameras found: {:?}\", e);\r\n            return;\r\n        }\r\n    };\r\n    let mut camera_transform = camera;\r\n\r\n    // update transform\r\n    let follow_translation = follow_global_transform.translation();\r\n    camera_transform.translation = follow_translation;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\bevy\\src\\rect_in_rect.rs\r\n\r\n````rust\r\nuse bevy::math::Rect;\r\nuse bevy::math::Vec2;\r\n\r\npub trait AtInsideBottom {\r\n    fn at_inside_bottom(&self, other: &Rect) -> Rect;\r\n}\r\nimpl AtInsideBottom for Rect {\r\n    fn at_inside_bottom(&self, other: &Rect) -> Rect {\r\n        Rect::from_center_size(\r\n            Vec2::new(\r\n                other.center().x,\r\n                other.center().y - other.height() / 2.0 + self.height() / 2.0,\r\n            ),\r\n            self.size(),\r\n        )\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\fullscreen_tool_types\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_fullscreen_tool_types\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\nleafwing-input-manager = { workspace = true }\r\nbevy-inspector-egui = { workspace = true }\r\ncursor_hero_toolbelt_types = { workspace = true }\r\ncursor_hero_input = { workspace = true }\r\ncursor_hero_tools = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\character_types\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_character_types\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\nbevy-inspector-egui = { workspace = true}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\environment_types\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_environment_types\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\icon\\src\\lib.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse bevy::winit::WinitWindows;\r\nuse winit::window::Icon;\r\n\r\npub struct IconPlugin;\r\n\r\nimpl Plugin for IconPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Startup, load_window_icon);\r\n    }\r\n}\r\n\r\n#[derive(Resource, Reflect, Default)]\r\n#[reflect(Resource)]\r\nstruct WindowIconResource(Handle<Image>);\r\n\r\nfn load_window_icon(mut commands: Commands, asset_server: Res<AssetServer>) {\r\n    let icon_handle = asset_server.load(\"textures/icon.png\");\r\n    commands.add(|world: &mut World| {\r\n        // register the system\r\n        let system_id = world.register_system(update_window_icon);\r\n        info!(\r\n            \"Registered update_window_icon system with id {:?}\",\r\n            system_id\r\n        );\r\n\r\n        // add it to the update schedule\r\n        let mut schedules = world.resource_mut::<Schedules>();\r\n        if let Some(schedule) = schedules.get_mut(Update) {\r\n            schedule.add_systems(update_window_icon);\r\n        } else {\r\n            let mut new_schedule = Schedule::new(Update);\r\n            new_schedule.add_systems(update_window_icon);\r\n            schedules.insert(new_schedule);\r\n        }\r\n\r\n        // add handle holder with system id for later removal\r\n        world.insert_resource(WindowIconResource(icon_handle));\r\n    });\r\n}\r\n\r\nfn update_window_icon(\r\n    windows: NonSend<WinitWindows>,\r\n    materials: Res<Assets<Image>>,\r\n    icon_resource: Res<WindowIconResource>,\r\n    // mut commands: Commands,\r\n    mut flag: Local<bool>,\r\n) {\r\n    if *flag {\r\n        return;\r\n    }\r\n    if let Some(icon) = materials.get(&icon_resource.0) {\r\n        // update the icon\r\n        let icon = Icon::from_rgba(icon.clone().data, icon.size().x, icon.size().y).unwrap();\r\n        for window in windows.windows.values() {\r\n            window.set_window_icon(Some(icon.clone()));\r\n        }\r\n        info!(\"Updated window icon\");\r\n\r\n        // remove this system\r\n        // commands.add(move |world: &mut World| {\r\n        //     match world.remove_system(system_id) {\r\n        //         Ok(_) => info!(\"Removed update_window_icon system since it did its job\"),\r\n        //         Err(e) => error!(\"Failed to remove update_window_icon system: {}\", e),\r\n        //     }\r\n        //     let mut schedules = world.resource_mut::<Schedules>();\r\n        //     if let Some(_schedule) = schedules.get_mut(Update) {\r\n        //         /*\r\n        //         https://discord.com/channels/691052431525675048/749335865876021248/1138225592064561243\r\n        //         Alice \ud83c\udf39 \u2014 08/07/2023 5:42 PM\r\n        //         We're also missing a Schedule::remove_system API, with a solution for\r\n        //         a) dependency invalidation and\r\n        //         b) disambiguation of multiple copies of a system in the same schedule\r\n        //                              */\r\n        //         // this method does not exist yet.\r\n        //         // should probably make a PR for it\r\n        //         // and should also include a simplified way to remove a system from a schedule\r\n        //         // maybe a .remove_when similar to .run_if\r\n        //         // schedule.remove_system(system_id);\r\n        //     }\r\n        // });\r\n        *flag = true;\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\movement_tool\\src\\movement_tool.rs\r\n\r\n````rust\r\nuse crate::tool_spawning::ToolSpawnConfig;\r\nuse bevy::prelude::*;\r\nuse bevy_xpbd_2d::math::*;\r\nuse bevy_xpbd_2d::prelude::*;\r\nuse cursor_hero_character_types::prelude::*;\r\nuse cursor_hero_math::prelude::Lerp;\r\nuse itertools::Itertools;\r\nuse leafwing_input_manager::prelude::*;\r\nuse leafwing_input_manager::user_input::InputKind;\r\n\r\npub struct MovementToolPlugin;\r\n\r\nimpl Plugin for MovementToolPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        \r\n    }\r\n}\r\n\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\input\\src\\active_input_state_plugin.rs\r\n\r\n````rust\r\nuse bevy::input::gamepad::GamepadEvent;\r\nuse bevy::input::keyboard::KeyboardInput;\r\nuse bevy::prelude::*;\r\nuse cursor_hero_host_event_types::prelude::HostEvent;\r\nuse cursor_hero_cursor_types::cursor_action_types::CursorAction;\r\nuse cursor_hero_cursor_types::cursor_types::MainCursor;\r\nuse leafwing_input_manager::action_state::ActionState;\r\n\r\npub struct ActiveInputStatePlugin;\r\n\r\nimpl Plugin for ActiveInputStatePlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_state::<InputMethod>();\r\n        app.insert_resource(InputMethod::MouseAndKeyboard);\r\n        app.add_systems(Update, update_input_method);\r\n    }\r\n}\r\n\r\n#[derive(Resource, Reflect, Debug, Clone, Copy, Default, Eq, PartialEq, Hash, States)]\r\n#[reflect(Resource)]\r\npub enum InputMethod {\r\n    #[default]\r\n    MouseAndKeyboard,\r\n    Keyboard,\r\n    Gamepad,\r\n}\r\n\r\nfn update_input_method(\r\n    current_state: Res<State<InputMethod>>,\r\n    mut next_state: ResMut<NextState<InputMethod>>,\r\n    mut gamepad_events: EventReader<GamepadEvent>,\r\n    mut host_events: EventReader<HostEvent>,\r\n    mut keyboard_events: EventReader<KeyboardInput>,\r\n    cursor_actions: Query<&ActionState<CursorAction>, With<MainCursor>>,\r\n) {\r\n    let current_input_method = *current_state.get();\r\n    let keyboard_used = keyboard_events.read().count() > 0;\r\n    let gamepad_used = gamepad_events\r\n        .read()\r\n        .filter(|e| match e {\r\n            GamepadEvent::Button(_) => true,\r\n            GamepadEvent::Axis(ax) => ax.value != 0.0,\r\n            _ => false,\r\n        })\r\n        .count()\r\n        > 0;\r\n    let mouse_used = host_events\r\n        .read()\r\n        .filter(|e| **e == HostEvent::MousePhysicallyMoved)\r\n        .count()\r\n        > 0;\r\n    let cursor_moved = cursor_actions.iter().any(|a| {\r\n        a.axis_pair(CursorAction::Move)\r\n            .map(|xy| !xy.x().is_nan() && !xy.y().is_nan() && xy.xy() != Vec2::ZERO)\r\n            .unwrap_or(false)\r\n    });\r\n\r\n    #[derive(Debug)]\r\n    struct DecisionInfo {\r\n        current_input_method: InputMethod,\r\n        keyboard_used: bool,\r\n        gamepad_used: bool,\r\n        mouse_used: bool,\r\n        cursor_moved: bool,\r\n    }\r\n    let decision_info = DecisionInfo {\r\n        current_input_method,\r\n        keyboard_used,\r\n        gamepad_used,\r\n        mouse_used,\r\n        cursor_moved,\r\n    };\r\n    let proposed_state = match decision_info {\r\n        DecisionInfo {\r\n            gamepad_used: true, ..\r\n        } => InputMethod::Gamepad,\r\n        DecisionInfo {\r\n            current_input_method: InputMethod::MouseAndKeyboard,\r\n            cursor_moved: true,\r\n            ..\r\n        } => InputMethod::Keyboard,\r\n        DecisionInfo {\r\n            mouse_used: true, ..\r\n        }\r\n        | DecisionInfo {\r\n            current_input_method: InputMethod::Gamepad,\r\n            keyboard_used: true,\r\n            ..\r\n        } => InputMethod::MouseAndKeyboard,\r\n        DecisionInfo {\r\n            current_input_method,\r\n            ..\r\n        } => current_input_method,\r\n    };\r\n    if proposed_state != current_input_method {\r\n        next_state.set(proposed_state);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\metrics\\src\\lib.rs\r\n\r\n````rust\r\nuse indexmap::IndexMap;\r\nuse std::time::Duration;\r\nuse std::time::Instant;\r\n\r\n#[derive(Debug, Clone)]\r\npub struct Metric {\r\n    pub name: String,\r\n    pub duration: Duration,\r\n}\r\n\r\n#[derive(Default, Debug)]\r\npub struct Metrics {\r\n    ongoing: IndexMap<String, Instant>,\r\n    completed: IndexMap<String, Duration>,\r\n}\r\n\r\nimpl Metrics {\r\n    pub fn begin(&mut self, name: &str) {\r\n        self.ongoing.insert(name.to_string(), Instant::now());\r\n    }\r\n\r\n    pub fn end(&mut self, name: &str) {\r\n        if let Some(start_time) = self.ongoing.remove(name) {\r\n            let duration = start_time.elapsed();\r\n            self.completed.insert(name.to_string(), duration);\r\n        }\r\n    }\r\n\r\n    #[allow(dead_code)]\r\n    pub fn report(&self) -> String {\r\n        format!(\r\n            \"{} | total {:?}\",\r\n            self.completed\r\n                .iter()\r\n                .map(|(name, duration)| format!(\"{} {:?}\", name, duration))\r\n                .collect::<Vec<_>>()\r\n                .join(\" | \"),\r\n            &self.total()\r\n        )\r\n    }\r\n\r\n    pub fn total(&self) -> Duration {\r\n        self.completed.values().sum()\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n\r\n    #[test]\r\n    fn test_metrics_tracking() {\r\n        let mut metrics = Metrics::default();\r\n\r\n        metrics.begin(\"z first\");\r\n        std::thread::sleep(Duration::from_millis(10));\r\n        metrics.end(\"z first\");\r\n\r\n        metrics.begin(\"a second\");\r\n        std::thread::sleep(Duration::from_millis(20));\r\n        metrics.end(\"a second\");\r\n\r\n        let report = metrics.report();\r\n        println!(\"{}\", report);\r\n        assert!(report.contains(\"z first\"));\r\n        assert!(report.contains(\"a second\"));\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\app_types\\src\\app_types.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n\r\n#[derive(Component, Debug, Reflect)]\r\npub struct MyComponent;\r\n\r\n#[derive(Event, Debug, Reflect)]\r\npub enum MyEvent {\r\n    Guh,\r\n    Uh,\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\cursor_types\\src\\cursor_behaviour_types.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse std::fmt::Display;\r\nuse std::fmt::Formatter;\r\n\r\n#[derive(Eq, PartialEq, Debug, Reflect, Clone, Copy)]\r\npub enum CursorMovementBehaviour {\r\n    None,\r\n    SetHostCursorFromCursorWorldCoords,\r\n    SetHostCursorFromWindowCoords,\r\n    SetCursorFromHostCursorWindowCoords,\r\n}\r\n\r\nimpl Display for CursorMovementBehaviour {\r\n    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {\r\n        write!(\r\n            f,\r\n            \"{}\",\r\n            match self {\r\n                CursorMovementBehaviour::None => \"None\",\r\n                CursorMovementBehaviour::SetHostCursorFromCursorWorldCoords =>\r\n                    \"SetHostCursorFromCursorWorldCoords\",\r\n                CursorMovementBehaviour::SetHostCursorFromWindowCoords =>\r\n                    \"SetHostCursorFromWindowCoords\",\r\n                CursorMovementBehaviour::SetCursorFromHostCursorWindowCoords =>\r\n                    \"SetCursorFromHostCursorWindowCoords\",\r\n            }\r\n        )\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\host_fs\\src\\lib.rs\r\n\r\n````rust\r\npub mod host_fs_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::host_fs_plugin::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\host_event_types\\src\\host_event_types.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n\r\n#[derive(Event, Debug, Reflect, Eq, PartialEq)]\r\npub enum HostEvent {\r\n    MousePhysicallyMoved,\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\character\\src\\character_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n\r\nuse crate::character_appearance_plugin::CharacterAppearancePlugin;\r\nuse crate::character_spawning_plugin::CharacterSpawningPlugin;\r\npub struct CharacterPlugin;\r\n\r\nimpl Plugin for CharacterPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_plugins(CharacterAppearancePlugin);\r\n        app.add_plugins(CharacterSpawningPlugin);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\glados_tts_types\\src\\glados_tts_types.rs\r\n\r\n````rust\r\nuse std::time::Duration;\r\n\r\nuse bevy::prelude::*;\r\nuse bevy::utils::Instant;\r\n\r\n#[derive(Reflect, Resource, Default, Debug, Eq, PartialEq, Clone, Copy)]\r\n#[reflect(Resource)]\r\npub enum GladosTtsStatus {\r\n    #[default]\r\n    Unknown,\r\n    Alive,\r\n    Dead,\r\n    Starting {\r\n        instant: Instant,\r\n        timeout: Duration,\r\n    },\r\n}\r\n\r\n#[derive(Component, Debug, Reflect, Default)]\r\npub struct GladosTtsStatusButton {\r\n    pub visual_state: GladosTtsStatusButtonVisualState,\r\n}\r\n\r\n#[derive(Debug, Reflect, Eq, PartialEq)]\r\npub enum GladosTtsStatusButtonVisualState {\r\n    Default { status: GladosTtsStatus },\r\n    Hovered { status: GladosTtsStatus },\r\n    Pressed { status: GladosTtsStatus },\r\n}\r\nimpl Default for GladosTtsStatusButtonVisualState {\r\n    fn default() -> Self {\r\n        GladosTtsStatusButtonVisualState::Default {\r\n            status: GladosTtsStatus::Unknown,\r\n        }\r\n    }\r\n}\r\n\r\n#[derive(Component, Debug, Reflect, Default)]\r\npub struct GladosTtsVscodeButton {\r\n    pub visual_state: GladosTtsVscodeButtonVisualState,\r\n}\r\n#[derive(Debug, Reflect, Eq, PartialEq, Default)]\r\npub enum GladosTtsVscodeButtonVisualState {\r\n    #[default]\r\n    Default,\r\n}\r\n#[derive(Event, Debug, Reflect)]\r\npub enum GladosTtsVscodeEvent {\r\n    Startup,\r\n}\r\n\r\n#[derive(Event, Debug, Reflect)]\r\npub enum GladosTtsPingEvent {\r\n    Ping,\r\n    Pong { status: GladosTtsStatus },\r\n}\r\n\r\n#[derive(Event, Debug, Reflect)]\r\npub enum GladosTtsStatusEvent {\r\n    Changed { new_value: GladosTtsStatus },\r\n    Startup,\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\environment\\src\\environment_tracker_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse bevy::utils::HashSet;\r\nuse bevy_xpbd_2d::components::CollidingEntities;\r\nuse cursor_hero_environment_types::prelude::*;\r\nuse cursor_hero_level_bounds::level_bounds_plugin::LevelBounds;\r\nuse cursor_hero_level_bounds::level_bounds_plugin::LevelBoundsHolder;\r\n\r\npub struct EnvironmentTrackerPlugin;\r\n\r\nimpl Plugin for EnvironmentTrackerPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Update, track);\r\n    }\r\n}\r\n\r\nfn track(\r\n    mut commands: Commands,\r\n    mut thing_query: Query<(Entity, Option<&mut EnvironmentTracker>, &CollidingEntities)>,\r\n    level_bounds_query: Query<&Parent, With<LevelBounds>>,\r\n    level_bounds_holder_query: Query<&Parent, With<LevelBoundsHolder>>,\r\n) {\r\n    for (thing_id, thing_environment_tag, thing_colliding_entities) in thing_query.iter_mut() {\r\n        // find out what level bounds the cursor is touching\r\n        // find those bounds' parent\r\n        // find the parent of the parent to get the environment ID\r\n        let environment_ids = thing_colliding_entities\r\n            .0\r\n            .iter()\r\n            .filter_map(|entity| {\r\n                if let Ok(level_bounds_holder_id) = level_bounds_query.get(*entity) {\r\n                    if let Ok(environment_id) =\r\n                        level_bounds_holder_query.get(level_bounds_holder_id.get())\r\n                    {\r\n                        return Some(environment_id.get());\r\n                    }\r\n                }\r\n                None\r\n            })\r\n            .collect::<HashSet<Entity>>();\r\n        if environment_ids.len() > 1 {\r\n            warn!(\r\n                \"Thing {:?} is touching multiple environments: {:?}\",\r\n                thing_id, environment_ids\r\n            );\r\n        }\r\n        if let Some(environment_id) = environment_ids.iter().next() {\r\n            if let Some(mut tag) = thing_environment_tag {\r\n                tag.environment_id = *environment_id;\r\n            } else {\r\n                commands.entity(thing_id).insert(EnvironmentTracker {\r\n                    environment_id: *environment_id,\r\n                });\r\n            }\r\n        } else if thing_environment_tag.is_some() {\r\n            commands.entity(thing_id).remove::<EnvironmentTracker>();\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\hover\\src\\screenshot_tool.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse bevy::window::PrimaryWindow;\r\nuse bevy_egui::egui;\r\nuse bevy_egui::egui::Pos2;\r\nuse bevy_egui::EguiContext;\r\nuse bevy_egui::EguiContexts;\r\nuse bevy_inspector_egui::reflect_inspector::Context;\r\nuse bevy_inspector_egui::reflect_inspector::InspectorUi;\r\nuse bevy_xpbd_2d::components::Collider;\r\nuse bevy_xpbd_2d::components::RigidBody;\r\nuse crossbeam_channel::Sender;\r\nuse cursor_hero_bevy::prelude::NegativeYIVec3;\r\nuse cursor_hero_bevy::prelude::NegativeYVec2;\r\nuse cursor_hero_camera::camera_plugin::MainCamera;\r\nuse cursor_hero_character_types::prelude::*;\r\nuse cursor_hero_environment_types::prelude::TrackEnvironmentTag;\r\nuse cursor_hero_physics::damping_plugin::MovementDamping;\r\nuse cursor_hero_cursor_types::prelude::*;\r\nuse cursor_hero_screen::get_image::get_image;\r\nuse cursor_hero_screen::get_image::ScreensToImageParam;\r\nuse cursor_hero_toolbelt_types::prelude::*;\r\nuse cursor_hero_tools::cube_tool::CubeToolInteractable;\r\nuse cursor_hero_tools::prelude::*;\r\nuse cursor_hero_ui_automation::prelude::find_element_at;\r\nuse cursor_hero_ui_automation::prelude::gather_elements_at;\r\nuse cursor_hero_ui_automation::prelude::gather_incomplete_ui_tree_starting_deep;\r\nuse cursor_hero_ui_automation::prelude::DrillId;\r\nuse cursor_hero_ui_automation::prelude::ElementInfo;\r\nuse cursor_hero_worker::prelude::anyhow::Result;\r\nuse cursor_hero_worker::prelude::WorkerMessage;\r\nuse cursor_hero_worker::prelude::WorkerConfig;\r\nuse cursor_hero_worker::prelude::WorkerPlugin;\r\nuse leafwing_input_manager::prelude::*;\r\nuse rand::thread_rng;\r\nuse rand::Rng;\r\n\r\npub struct ScreenshotToolPlugin;\r\n\r\nimpl Plugin for ScreenshotToolPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_plugins(WorkerPlugin {\r\n            config: WorkerConfig::<ThreadboundMessage, GameboundMessage, ()> {\r\n                name: \"screenshot_tool\".to_string(),\r\n                is_ui_automation_thread: true,\r\n                handle_threadbound_message,\r\n                ..default()\r\n            },\r\n        });\r\n        app.register_type::<ScreenshotTool>();\r\n        app.register_type::<ScreenshotBrick>();\r\n        app.add_plugins(InputManagerPlugin::<ScreenshotToolAction>::default());\r\n        app.add_systems(Update, toolbelt_events);\r\n        app.add_systems(Update, handle_input);\r\n        app.add_systems(Update, handle_replies);\r\n        // app.add_systems(Update, ui);\r\n    }\r\n}\r\n\r\n#[derive(Debug, Reflect, Clone, Event)]\r\nenum ThreadboundMessage {\r\n    Capture { world_position: Vec3 },\r\n    CaptureBrick { world_position: Vec3 },\r\n    Print { world_position: Vec3 },\r\n    Fracture { world_position: Vec3 },\r\n}\r\nimpl WorkerMessage for ThreadboundMessage {}\r\n\r\n#[derive(Debug, Reflect, Clone, Event)]\r\nenum GameboundMessage {\r\n    Capture {\r\n        ui_tree: ElementInfo,\r\n        hovered_element: ElementInfo,\r\n        world_position: Vec3,\r\n    },\r\n    CaptureBrick {\r\n        ui_tree: ElementInfo,\r\n        hovered_element: ElementInfo,\r\n        world_position: Vec3,\r\n    },\r\n    Print(ElementInfo),\r\n    Fracture {\r\n        data: Vec<(ElementInfo, usize)>,\r\n        world_position: Vec3,\r\n    },\r\n}\r\nimpl WorkerMessage for GameboundMessage {}\r\n\r\n#[derive(Component, Reflect, Default)]\r\nstruct ScreenshotTool;\r\n\r\n#[derive(Actionlike, PartialEq, Eq, Clone, Copy, Hash, Debug, Reflect)]\r\nenum ScreenshotToolAction {\r\n    Capture,\r\n    CaptureBrick,\r\n    Print,\r\n    Fracture,\r\n}\r\nimpl ScreenshotToolAction {\r\n    fn default_gamepad_binding(&self) -> UserInput {\r\n        match self {\r\n            Self::Capture => GamepadButtonType::RightTrigger.into(),\r\n            Self::CaptureBrick => GamepadButtonType::South.into(),\r\n            Self::Print => GamepadButtonType::North.into(),\r\n            Self::Fracture => GamepadButtonType::Select.into(),\r\n        }\r\n    }\r\n\r\n    fn default_mkb_binding(&self) -> UserInput {\r\n        match self {\r\n            Self::Capture => MouseButton::Left.into(),\r\n            Self::CaptureBrick => MouseButton::Middle.into(),\r\n            Self::Print => MouseButton::Right.into(),\r\n            Self::Fracture => KeyCode::G.into(),\r\n        }\r\n    }\r\n}\r\nimpl ToolAction for ScreenshotToolAction {\r\n    fn default_input_map(_event: &ToolbeltPopulateEvent) -> Option<InputMap<ScreenshotToolAction>> {\r\n        let mut input_map = InputMap::default();\r\n\r\n        for variant in ScreenshotToolAction::variants() {\r\n            input_map.insert(variant.default_mkb_binding(), variant);\r\n            input_map.insert(variant.default_gamepad_binding(), variant);\r\n        }\r\n        Some(input_map)\r\n    }\r\n}\r\n\r\n#[derive(Reflect, Default)]\r\nstruct ScreenshotBrickEguiState {\r\n    selected: Option<DrillId>,\r\n    expanded: Vec<DrillId>,\r\n}\r\n\r\n#[derive(Component, Reflect)]\r\nstruct ScreenshotBrick {\r\n    ui_tree: ElementInfo,\r\n    hero_element: ElementInfo,\r\n    egui_state: ScreenshotBrickEguiState,\r\n}\r\n\r\nfn toolbelt_events(\r\n    mut commands: Commands,\r\n    asset_server: Res<AssetServer>,\r\n    mut reader: EventReader<ToolbeltPopulateEvent>,\r\n) {\r\n    for event in reader.read() {\r\n        if event.loadout == ToolbeltLoadout::Default {\r\n            ToolSpawnConfig::<ScreenshotTool, ScreenshotToolAction>::new(\r\n                ScreenshotTool,\r\n                event.id,\r\n                event,\r\n            )\r\n            .with_src_path(file!().into())\r\n            .guess_name(file!())\r\n            .guess_image(file!(), &asset_server, \"webp\")\r\n            .with_description(\"Turn UI elements into information.\")\r\n            .with_starting_state(StartingState::Inactive)\r\n            .spawn(&mut commands);\r\n        }\r\n    }\r\n}\r\n\r\nfn handle_input(\r\n    tools: Query<(&ActionState<ScreenshotToolAction>, &Parent), With<ActiveTool>>,\r\n    toolbelts: Query<&Parent, With<Toolbelt>>,\r\n    characters: Query<&Children, With<Character>>,\r\n    cursors: Query<&GlobalTransform, With<Cursor>>,\r\n    mut bridge: EventWriter<ThreadboundMessage>,\r\n    egui_context_query: Query<&EguiContext, With<PrimaryWindow>>,\r\n) {\r\n    for tool in tools.iter() {\r\n        let (tool_actions, tool_parent) = tool;\r\n\r\n        let Ok(toolbelt) = toolbelts.get(tool_parent.get()) else {\r\n            warn!(\"Tool not inside a toolbelt?\");\r\n            continue;\r\n        };\r\n        let toolbelt_parent = toolbelt;\r\n\r\n        let Ok(character) = characters.get(toolbelt_parent.get()) else {\r\n            warn!(\"Toolbelt parent not a character?\");\r\n            continue;\r\n        };\r\n        let character_children = character;\r\n\r\n        let Some(cursor) = character_children\r\n            .iter()\r\n            .filter_map(|x| cursors.get(*x).ok())\r\n            .next()\r\n        else {\r\n            //TODO: warn if more than one cursor found\r\n            warn!(\"Character {:?} missing a cursor?\", toolbelt_parent.get());\r\n            debug!(\"Character children: {:?}\", character_children);\r\n            continue;\r\n        };\r\n        let cursor_transform = cursor;\r\n        let cursor_translation = cursor_transform.translation();\r\n        let hovering_over_egui = egui_context_query\r\n            .get_single()\r\n            .ok()\r\n            .map(|egui_context| egui_context.clone().get_mut().is_pointer_over_area())\r\n            .unwrap_or(false);\r\n        if hovering_over_egui {\r\n            continue;\r\n        }\r\n        if tool_actions.just_pressed(ScreenshotToolAction::Capture) {\r\n            info!(\"Capture\");\r\n            let msg = ThreadboundMessage::Capture {\r\n                world_position: cursor_translation,\r\n            };\r\n            bridge.send(msg);\r\n        }\r\n        if tool_actions.just_pressed(ScreenshotToolAction::CaptureBrick) {\r\n            info!(\"CaptureBrick\");\r\n            let msg = ThreadboundMessage::CaptureBrick {\r\n                world_position: cursor_translation,\r\n            };\r\n            bridge.send(msg);\r\n        }\r\n        if tool_actions.just_pressed(ScreenshotToolAction::Print) {\r\n            info!(\"Print\");\r\n            let msg = ThreadboundMessage::Print {\r\n                world_position: cursor_translation,\r\n            };\r\n            bridge.send(msg);\r\n        }\r\n        if tool_actions.just_pressed(ScreenshotToolAction::Fracture) {\r\n            info!(\"Fracture\");\r\n            let msg = ThreadboundMessage::Fracture {\r\n                world_position: cursor_translation,\r\n            };\r\n            bridge.send(msg);\r\n        }\r\n    }\r\n}\r\n\r\nfn handle_threadbound_message(\r\n    msg: &ThreadboundMessage,\r\n    reply_tx: &Sender<GameboundMessage>,\r\n    _state: &mut (),\r\n) -> Result<()> {\r\n    match msg {\r\n        ThreadboundMessage::Capture { world_position }\r\n        | ThreadboundMessage::CaptureBrick { world_position } => {\r\n            let mouse_position = world_position.xy().neg_y().as_ivec2();\r\n            debug!(\"Worker received click: {:?} {:?}\", msg, mouse_position);\r\n\r\n            let elem = find_element_at(mouse_position)?;\r\n            info!(\"{} - {}\", elem.get_classname()?, elem.get_name()?);\r\n\r\n            let id = elem.get_automation_id()?;\r\n            info!(\"Automation ID: {}\", id);\r\n            let gathered = gather_incomplete_ui_tree_starting_deep(elem)?;\r\n            // debug!(\"Element info: {:?}\", element_info);\r\n            let msg = match msg {\r\n                ThreadboundMessage::Capture { world_position } => GameboundMessage::Capture {\r\n                    ui_tree: gathered.ui_tree,\r\n                    hovered_element: gathered.start_info,\r\n                    world_position: *world_position,\r\n                },\r\n                ThreadboundMessage::CaptureBrick { world_position } => {\r\n                    GameboundMessage::CaptureBrick {\r\n                        ui_tree: gathered.ui_tree,\r\n                        hovered_element: gathered.start_info,\r\n                        world_position: *world_position,\r\n                    }\r\n                }\r\n                _ => unreachable!(),\r\n            };\r\n            reply_tx.send(msg)?;\r\n        }\r\n        ThreadboundMessage::Print { world_position } => {\r\n            let mouse_position = world_position.xy().neg_y().as_ivec2();\r\n            debug!(\"Worker received click: {:?} {:?}\", msg, mouse_position);\r\n\r\n            let elem = find_element_at(mouse_position)?;\r\n            info!(\"{:?}\", elem);\r\n\r\n            // Can we click on elements with this?\r\n            // elem.send_keys(keys, interval) exists!\r\n\r\n            // Send the info\r\n            let id = elem.get_automation_id()?;\r\n            info!(\"Automation ID: {}\", id);\r\n            let gathered = gather_incomplete_ui_tree_starting_deep(elem)?;\r\n            reply_tx.send(GameboundMessage::Print(gathered.ui_tree))?;\r\n        }\r\n        ThreadboundMessage::Fracture { world_position } => {\r\n            let mouse_position = world_position.xy().neg_y().as_ivec2();\r\n            debug!(\"Worker received click: {:?} {:?}\", msg, mouse_position);\r\n\r\n            let found = gather_elements_at(mouse_position)?;\r\n            let data = found\r\n                .into_iter()\r\n                .filter_map(|(elem, depth)| {\r\n                    gather_incomplete_ui_tree_starting_deep(elem)\r\n                        .ok()\r\n                        .map(|info| (info.start_info, depth))\r\n                })\r\n                .collect();\r\n            reply_tx.send(GameboundMessage::Fracture {\r\n                data,\r\n                world_position: *world_position,\r\n            })?;\r\n        }\r\n    }\r\n\r\n    Ok(())\r\n}\r\n\r\nfn handle_replies(\r\n    mut commands: Commands,\r\n    mut bridge: EventReader<GameboundMessage>,\r\n    screen_access: ScreensToImageParam,\r\n    asset_server: Res<AssetServer>,\r\n) {\r\n    for msg in bridge.read() {\r\n        match &msg {\r\n            GameboundMessage::Capture {\r\n                ui_tree,\r\n                hovered_element,\r\n                world_position,\r\n            }\r\n            | GameboundMessage::CaptureBrick {\r\n                ui_tree,\r\n                hovered_element,\r\n                world_position,\r\n            } => {\r\n                let (size, pos, texture_region) = match msg {\r\n                    GameboundMessage::Capture { .. } => (\r\n                        hovered_element.bounding_rect.size().as_vec2(),\r\n                        hovered_element\r\n                            .bounding_rect\r\n                            .center()\r\n                            .extend(20)\r\n                            .neg_y()\r\n                            .as_vec3(),\r\n                        hovered_element.bounding_rect,\r\n                    ),\r\n                    GameboundMessage::CaptureBrick { .. } => (\r\n                        hovered_element.bounding_rect.size().as_vec2().normalize() * 60.0,\r\n                        *world_position,\r\n                        hovered_element.bounding_rect,\r\n                    ),\r\n                    _ => unreachable!(),\r\n                };\r\n                spawn_brick(\r\n                    &mut commands,\r\n                    ui_tree,\r\n                    hovered_element,\r\n                    size,\r\n                    pos,\r\n                    texture_region,\r\n                    &screen_access,\r\n                    &asset_server,\r\n                );\r\n            }\r\n            GameboundMessage::Print(info) => {\r\n                info!(\"Received info for element {:?}\", info);\r\n                commands.spawn((\r\n                    AudioBundle {\r\n                        source: asset_server.load(\"sounds/tape recorder eject 4.ogg\"),\r\n                        settings: PlaybackSettings::REMOVE,\r\n                    },\r\n                    Name::new(format!(\"SFX Element - {}\", info.name)),\r\n                ));\r\n            }\r\n            GameboundMessage::Fracture {\r\n                data,\r\n                world_position,\r\n            } => {\r\n                info!(\"Received info with {} elements\", data.len());\r\n                if !data.is_empty() {\r\n                    commands.spawn((\r\n                        SpatialBundle {\r\n                            transform: Transform::from_translation(*world_position),\r\n                            ..default()\r\n                        },\r\n                        AudioBundle {\r\n                            source: asset_server.load(\"sounds/spring strung light 4.ogg\"),\r\n                            settings: PlaybackSettings::DESPAWN.with_spatial(true),\r\n                        },\r\n                        Name::new(\"Fracture Sound\"),\r\n                    ));\r\n                }\r\n                for (info, depth) in data {\r\n                    // let Ok(image) = get_image(info.bounding_rect, &access) else {\r\n                    //     continue;\r\n                    // };\r\n                    // let texture_handle = asset_server.add(image);\r\n\r\n                    // spawn the element image\r\n                    let mut elem_center_pos =\r\n                        info.bounding_rect.center().as_vec2().extend(*depth as f32);\r\n                    elem_center_pos.y *= -1.0;\r\n                    commands.spawn((\r\n                        SpriteBundle {\r\n                            transform: Transform::from_translation(elem_center_pos),\r\n                            sprite: Sprite {\r\n                                custom_size: Some(info.bounding_rect.size().as_vec2()),\r\n                                color: Color::hsl(thread_rng().gen_range(0.0..360.0), 0.5, 0.5),\r\n                                ..default()\r\n                            },\r\n                            // texture: texture_handle,\r\n                            ..default()\r\n                        },\r\n                        CubeToolInteractable,\r\n                        RigidBody::Dynamic,\r\n                        Collider::cuboid(\r\n                            info.bounding_rect.width() as f32,\r\n                            info.bounding_rect.height() as f32,\r\n                        ),\r\n                        MovementDamping::default(),\r\n                        Name::new(format!(\"Element - {}\", info.name)),\r\n                    ));\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n#[allow(clippy::too_many_arguments)]\r\nfn spawn_brick(\r\n    commands: &mut Commands,\r\n    ui_tree: &ElementInfo,\r\n    hero_element: &ElementInfo,\r\n    size: Vec2,\r\n    pos: Vec3,\r\n    texture_region: IRect,\r\n    screen_access: &ScreensToImageParam,\r\n    asset_server: &Res<AssetServer>,\r\n) {\r\n    let Ok(image) = get_image(texture_region, screen_access) else {\r\n        return;\r\n    };\r\n    let texture_handle = asset_server.add(image);\r\n    let expanded = ui_tree\r\n        .get_descendents()\r\n        .iter()\r\n        .chain([ui_tree].iter())\r\n        .filter(|x| x.children.is_some())\r\n        .map(|x| x.drill_id.clone())\r\n        .collect();\r\n    commands.spawn((\r\n        SpriteBundle {\r\n            transform: Transform::from_translation(pos),\r\n            sprite: Sprite {\r\n                custom_size: Some(size),\r\n                ..default()\r\n            },\r\n            texture: texture_handle,\r\n            ..default()\r\n        },\r\n        AudioBundle {\r\n            source: asset_server.load(\"sounds/spring strung light 4.ogg\"),\r\n            settings: PlaybackSettings::REMOVE.with_spatial(true),\r\n        },\r\n        // FloatyName {\r\n        //     text: element_info.name.clone(),\r\n        //     vertical_offset: 40.0,\r\n        //     appearance: NametagAppearance::Databrick,\r\n        // },\r\n        Hoverable,\r\n        Clickable,\r\n        CubeToolInteractable,\r\n        RigidBody::Dynamic,\r\n        TrackEnvironmentTag,\r\n        ScreenshotBrick {\r\n            ui_tree: ui_tree.clone(),\r\n            hero_element: hero_element.clone(),\r\n            egui_state: ScreenshotBrickEguiState {\r\n                selected: Some(hero_element.drill_id.clone()),\r\n                expanded,\r\n            },\r\n        },\r\n        Collider::cuboid(size.x, size.y),\r\n        MovementDamping::default(),\r\n        Name::new(format!(\"Element - {}\", hero_element.name)),\r\n    ));\r\n}\r\n\r\nfn ui(\r\n    mut commands: Commands,\r\n    screen_access: ScreensToImageParam,\r\n    asset_server: Res<AssetServer>,\r\n    mut contexts: EguiContexts,\r\n    mut brick_query: Query<(\r\n        Entity,\r\n        &mut ScreenshotBrick,\r\n        &Sprite,\r\n        &Name,\r\n        &GlobalTransform,\r\n    )>,\r\n    camera_query: Query<(&GlobalTransform, &Camera), With<MainCamera>>,\r\n    type_registry: Res<AppTypeRegistry>,\r\n) {\r\n    let Ok(camera) = camera_query.get_single() else {\r\n        warn!(\"No camera found\");\r\n        return;\r\n    };\r\n    let (camera_transform, camera) = camera;\r\n\r\n    let ctx = contexts.ctx_mut();\r\n    // let scale = (camera_transform.compute_transform().scale.x * 1.0).round();\r\n    // debug!(\"Scale: {}\", scale);\r\n    // ctx.set_zoom_factor(scale);\r\n\r\n    if brick_query.is_empty() {\r\n        return;\r\n    }\r\n\r\n    let mut cx = Context {\r\n        world: None,\r\n        queue: None,\r\n    };\r\n\r\n    let type_registry = type_registry.0.clone();\r\n    let type_registry = type_registry.read();\r\n\r\n    let mut inspector = InspectorUi::for_bevy(&type_registry, &mut cx);\r\n\r\n    for brick in brick_query.iter_mut() {\r\n        let (brick_id, mut brick, brick_sprite, brick_name, brick_global_transform) = brick;\r\n        let brick_global_translation = brick_global_transform.translation();\r\n        let popout_pos = brick_global_translation\r\n            + Vec3::new(\r\n                brick_sprite.custom_size.unwrap_or_default().x + 50.0,\r\n                0.0,\r\n                0.0,\r\n            );\r\n        let egui_pos = camera\r\n            .world_to_viewport(camera_transform, brick_global_translation)\r\n            .unwrap_or_default();\r\n\r\n        let id = egui::Id::new(brick_id);\r\n\r\n        egui::Window::new(brick_name.chars().take(64).collect::<String>())\r\n            .id(id)\r\n            .fixed_pos(Pos2::new(egui_pos.x, egui_pos.y))\r\n            .default_width(1200.0)\r\n            // .resizable(true)\r\n            .show(ctx, |ui| {\r\n                egui::SidePanel::left(id.with(\"tree\"))\r\n                    .resizable(true)\r\n                    .width_range(100.0..=4000.0)\r\n                    .default_width(600.0)\r\n                    .show_inside(ui, |ui| {\r\n                        ui.vertical_centered(|ui| {\r\n                            ui.heading(\"UI Tree\");\r\n                        });\r\n                        egui::ScrollArea::both().show(ui, |ui| {\r\n                            let id = id.with(brick.ui_tree.runtime_id.clone());\r\n\r\n                            let mut temp_egui_state = std::mem::take(&mut brick.egui_state);\r\n                            let mut temp_info = std::mem::take(&mut brick.ui_tree);\r\n                            ui_for_element_info(\r\n                                &mut temp_egui_state,\r\n                                id,\r\n                                &mut commands,\r\n                                &screen_access,\r\n                                &asset_server,\r\n                                ui,\r\n                                &mut temp_info,\r\n                                &mut inspector,\r\n                                &popout_pos,\r\n                            );\r\n                            brick.egui_state = temp_egui_state;\r\n                            brick.ui_tree = temp_info;\r\n\r\n                            ui.allocate_space(ui.available_size());\r\n                        });\r\n                    });\r\n\r\n                egui::TopBottomPanel::bottom(id.with(\"invisible bottom panel\"))\r\n                    .show_separator_line(false)\r\n                    .show_inside(ui, |_| ());\r\n\r\n                egui::CentralPanel::default().show_inside(ui, |ui| {\r\n                    ui.heading(\"AHOY!\");\r\n                    let id = brick.egui_state.selected.clone();\r\n                    if let Some(id) = id\r\n                        && let Some(x) = brick.ui_tree.lookup_drill_id_mut(id)\r\n                    {\r\n                        inspector.ui_for_reflect(x, ui);\r\n                    }\r\n                    // inspector.ui_for_reflect_readonly(&data, ui);\r\n                });\r\n            });\r\n    }\r\n}\r\n\r\n#[derive(Reflect, Debug)]\r\nstruct ElementUIData {\r\n    runtime_id: String,\r\n    frick: String,\r\n}\r\n\r\n#[allow(clippy::too_many_arguments)]\r\nfn ui_for_element_info(\r\n    state: &mut ScreenshotBrickEguiState,\r\n    id: egui::Id,\r\n    _commands: &mut Commands,\r\n    _screen_access: &ScreensToImageParam,\r\n    _asset_server: &Res<AssetServer>,\r\n    ui: &mut egui::Ui,\r\n    element_info: &mut ElementInfo,\r\n    _inspector: &mut InspectorUi,\r\n    _popout_pos: &Vec3,\r\n) {\r\n    egui::collapsing_header::CollapsingState::load_with_default_open(\r\n        ui.ctx(),\r\n        id,\r\n        state.expanded.contains(&element_info.drill_id),\r\n    )\r\n    .show_header(ui, |ui| {\r\n        let mut selected = state.selected == Some(element_info.drill_id.clone());\r\n        if ui\r\n            .toggle_value(\r\n                &mut selected,\r\n                format!(\r\n                    \"{:?} | {}\",\r\n                    element_info.name, element_info.localized_control_type\r\n                ),\r\n            )\r\n            .changed()\r\n        {\r\n            state.selected = if selected {\r\n                Some(element_info.drill_id.clone())\r\n            } else {\r\n                None\r\n            };\r\n        };\r\n    })\r\n    .body(|ui| {\r\n        // if ui.button(\"Popout\").clicked() {\r\n        //     spawn_brick(\r\n        //         commands,\r\n        //         element_info,\r\n        //         element_info.bounding_rect.size(),\r\n        //         *popout_pos,\r\n        //         screen_access,\r\n        //         asset_server,\r\n        //     )\r\n        // }\r\n\r\n        if let Some(children) = &mut element_info.children {\r\n            for child in children.iter_mut() {\r\n                ui_for_element_info(\r\n                    state,\r\n                    id.with(child.runtime_id.clone()),\r\n                    _commands,\r\n                    _screen_access,\r\n                    _asset_server,\r\n                    ui,\r\n                    child,\r\n                    _inspector,\r\n                    _popout_pos,\r\n                );\r\n            }\r\n        }\r\n    });\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\brick\\src\\brick_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n\r\npub struct BrickPlugin;\r\n\r\nimpl Plugin for BrickPlugin {\r\n    fn build(&self, _app: &mut App) {}\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\floaty_nametag_types\\src\\floaty_nametag_types.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n\r\n#[derive(Component, Debug, Reflect)]\r\npub struct FloatyName {\r\n    pub text: String,\r\n    pub vertical_offset: f32,\r\n    pub appearance: NametagAppearance,\r\n}\r\n\r\n#[derive(Component, Debug, Reflect)]\r\npub struct FloatyNametag {\r\n    pub owner: Entity,\r\n}\r\n\r\n#[derive(Debug, Reflect)]\r\npub enum NametagAppearance {\r\n    Character,\r\n    Databrick,\r\n}\r\nimpl NametagAppearance {\r\n    pub fn get_font_path(&self) -> String {\r\n        match self {\r\n            NametagAppearance::Character => \"fonts/kenney_kenney-fonts/Fonts/Kenney Rocket.ttf\",\r\n            NametagAppearance::Databrick => \"fonts/kenney_kenney-fonts/Fonts/Kenney Blocks.ttf\",\r\n        }\r\n        .to_string()\r\n    }\r\n    pub fn get_text_color(&self) -> Color {\r\n        match self {\r\n            NametagAppearance::Character => Color::GREEN,\r\n            NametagAppearance::Databrick => Color::BLUE,\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\memory\\src\\agent_observation_memory_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse bevy::utils::HashMap;\r\nuse cursor_hero_character_types::prelude::*;\r\n\r\nuse cursor_hero_memory_types::prelude::*;\r\nuse cursor_hero_observation_types::observation_types::ObservationBuffer;\r\nuse cursor_hero_observation_types::observation_types::SomethingObservableHappenedEvent;\r\nuse serde::Deserialize;\r\nuse serde::Serialize;\r\n\r\npub struct AgentObservationMemoryPlugin;\r\n\r\nimpl Plugin for AgentObservationMemoryPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.insert_resource(MainCharacterMemoryConfig::default());\r\n        app.add_systems(Update, persist.pipe(handle_persist_errors));\r\n        app.add_systems(Update, restore.pipe(handle_restore_errors));\r\n    }\r\n}\r\nconst PERSIST_FILE_NAME: &str = \"agent_memory.json\";\r\n\r\n// not moved to lib to ensure log contains this module name\r\nfn handle_persist_errors(In(result): In<Result<PersistSuccess, PersistError>>) {\r\n    if let Err(e) = result {\r\n        error!(\"Persist error occurred: {:?}\", e);\r\n    } else if let Ok(PersistSuccess::WritePerformed) = result {\r\n        debug!(\"Persisted succeeded\");\r\n    }\r\n}\r\n\r\nfn handle_restore_errors(In(result): In<Result<RestoreSuccess, RestoreError>>) {\r\n    if let Err(e) = result {\r\n        error!(\"Restore error occurred: {:?}\", e);\r\n    } else if let Ok(RestoreSuccess::Performed) = result {\r\n        info!(\"Restore succeeded\");\r\n    }\r\n}\r\n\r\n#[derive(Debug, Resource, Reflect)]\r\n#[reflect(Resource)]\r\nstruct MainCharacterMemoryConfig {\r\n    pub persist_cooldown: Timer,\r\n}\r\nimpl Default for MainCharacterMemoryConfig {\r\n    fn default() -> Self {\r\n        Self {\r\n            persist_cooldown: Timer::from_seconds(10.0, TimerMode::Repeating),\r\n        }\r\n    }\r\n}\r\n\r\n#[derive(Debug, Serialize, Deserialize, PartialEq, Clone, Default)]\r\nstruct DiskData {\r\n    observations_by_observer_name: HashMap<String, ObservationBuffer>,\r\n}\r\n\r\nfn persist(\r\n    mut config: ResMut<MainCharacterMemoryConfig>,\r\n    memory_config: Res<MemoryConfig>,\r\n    mut debounce: Local<Option<DiskData>>,\r\n    time: Res<Time>,\r\n    agent_query: Query<(&Name, &ObservationBuffer), With<AgentCharacter>>,\r\n) -> Result<PersistSuccess, PersistError> {\r\n    if !config.persist_cooldown.tick(time.delta()).just_finished() {\r\n        return Ok(PersistSuccess::Cooldown);\r\n    }\r\n\r\n    let mut data = DiskData::default();\r\n    for agent in agent_query.iter() {\r\n        data.observations_by_observer_name\r\n            .insert(agent.0.as_str().to_string(), agent.1.clone());\r\n    }\r\n\r\n    if debounce.is_none() || debounce.as_ref().unwrap() != &data {\r\n        let file = get_persist_file(memory_config.as_ref(), PERSIST_FILE_NAME, Usage::Persist)\r\n            .map_err(PersistError::Io)?;\r\n        write_to_disk(file, data.clone())?;\r\n        *debounce = Some(data);\r\n        Ok(PersistSuccess::WritePerformed)\r\n    } else {\r\n        Ok(PersistSuccess::Debounce)\r\n    }\r\n}\r\n\r\nfn restore(\r\n    memory_config: Res<MemoryConfig>,\r\n    mut agent_query: Query<(Entity, &Name, &mut ObservationBuffer), Added<AgentCharacter>>,\r\n    mut observation_events: EventWriter<SomethingObservableHappenedEvent>,\r\n) -> Result<RestoreSuccess, RestoreError> {\r\n    if agent_query.is_empty() {\r\n        return Ok(RestoreSuccess::NoAction);\r\n    }\r\n\r\n    let file = get_persist_file(memory_config.as_ref(), PERSIST_FILE_NAME, Usage::Restore)\r\n        .map_err(RestoreError::Io)?;\r\n    let mut data: DiskData = read_from_disk(file)?;\r\n    info!(\r\n        \"Restoring agent memories, found {} entries\",\r\n        data.observations_by_observer_name.len()\r\n    );\r\n    for agent in agent_query.iter_mut() {\r\n        let (agent_id, agent_name, mut agent_buffer) = agent;\r\n        let agent_name = agent_name.as_str();\r\n        // Each agent's observations is keyed by its name in the save file.\r\n        if let Some(buffer) = data.observations_by_observer_name.remove(agent_name) {\r\n            // Previous observations that reference entity IDs will have odd appearances in world inspectors because the IDs have been reused from restarts.\r\n\r\n            *agent_buffer = buffer;\r\n\r\n            let event = SomethingObservableHappenedEvent::MemoryRestored {\r\n                observation_buffer_id: agent_id,\r\n            };\r\n            debug!(\"Sending event {:?}\", event);\r\n            observation_events.send(event);\r\n        }\r\n    }\r\n    Ok(RestoreSuccess::Performed)\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\bevy\\src\\translate.rs\r\n\r\n````rust\r\nuse bevy::math::IRect;\r\nuse bevy::math::IVec2;\r\nuse bevy::math::IVec3;\r\nuse bevy::math::Rect;\r\nuse bevy::math::Vec2;\r\nuse bevy::math::Vec3;\r\n\r\npub trait TranslateVec2 {\r\n    fn translate(&self, translation: &Vec2) -> Self;\r\n}\r\npub trait TranslateIVec2 {\r\n    fn translate(&self, translation: &IVec2) -> Self;\r\n}\r\npub trait TranslateVec3 {\r\n    fn translate(&self, translation: &Vec3) -> Self;\r\n}\r\npub trait TranslateIVec3 {\r\n    fn translate(&self, translation: &IVec3) -> Self;\r\n}\r\n\r\nimpl TranslateVec2 for Rect {\r\n    fn translate(&self, translation: &Vec2) -> Rect {\r\n        Rect {\r\n            min: self.min + *translation,\r\n            max: self.max + *translation,\r\n        }\r\n    }\r\n}\r\nimpl TranslateIVec2 for IRect {\r\n    fn translate(&self, translation: &IVec2) -> IRect {\r\n        IRect {\r\n            min: self.min + *translation,\r\n            max: self.max + *translation,\r\n        }\r\n    }\r\n}\r\n\r\nimpl TranslateVec2 for Vec2 {\r\n    fn translate(&self, translation: &Vec2) -> Vec2 {\r\n        *self + *translation\r\n    }\r\n}\r\nimpl TranslateIVec2 for IVec2 {\r\n    fn translate(&self, translation: &IVec2) -> IVec2 {\r\n        *self + *translation\r\n    }\r\n}\r\n\r\nimpl TranslateVec3 for Vec3 {\r\n    fn translate(&self, translation: &Vec3) -> Vec3 {\r\n        *self + *translation\r\n    }\r\n}\r\nimpl TranslateIVec3 for IVec3 {\r\n    fn translate(&self, translation: &IVec3) -> IVec3 {\r\n        *self + *translation\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\cursor_types\\src\\cursor_mirroring_types.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n\r\n#[derive(Component, Reflect)]\r\npub struct CursorMirror;\r\n\r\n#[derive(Resource, Deref, Default, Reflect)]\r\n#[reflect(Resource)]\r\npub struct HostCursorPosition(pub IVec2);\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\click_drag_character_movement\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_click_drag_character_movement\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\ncursor_hero_camera = { workspace = true }\r\ncursor_hero_character_types = { workspace = true }\r\nbevy = { workspace = true }\r\nbevy_xpbd_2d = { workspace = true }\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\movement_tool\\src\\movement_tool_populate_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse cursor_hero_movement_tool_types::prelude::*;\r\nuse cursor_hero_toolbelt_types::prelude::*;\r\nuse cursor_hero_tools::tool_spawning::ToolSpawnConfig;\r\n\r\npub struct MovementToolPopulatePlugin;\r\n\r\nimpl Plugin for MovementToolPopulatePlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Update, handle_toolbelt_events);\r\n    }\r\n}\r\n\r\nfn handle_toolbelt_events(\r\n    mut commands: Commands,\r\n    asset_server: Res<AssetServer>,\r\n    mut reader: EventReader<ToolbeltPopulateEvent>,\r\n) {\r\n    for event in reader.read() {\r\n        match event.loadout {\r\n            ToolbeltLoadout::Default\r\n            | ToolbeltLoadout::Taskbar\r\n            | ToolbeltLoadout::WindowPosition\r\n            | ToolbeltLoadout::Keyboard => {\r\n                ToolSpawnConfig::<_, MovementToolAction>::new(\r\n                    MovementTool::default(),\r\n                    event.id,\r\n                    event,\r\n                )\r\n                .with_src_path(file!().into())\r\n                .guess_name(file!())\r\n                .guess_image(file!(), &asset_server, \"png\")\r\n                .with_description(\"Go faster, reach further\")\r\n                .spawn(&mut commands);\r\n            }\r\n            ToolbeltLoadout::Agent => {\r\n                ToolSpawnConfig::<_, MovementToolAction>::new(\r\n                    MovementTool::default(),\r\n                    event.id,\r\n                    event,\r\n                )\r\n                .with_src_path(file!().into())\r\n                .with_input_map(None)\r\n                .guess_name(file!())\r\n                .guess_image(file!(), &asset_server, \"png\")\r\n                .with_description(\"Go faster, reach further\")\r\n                .spawn(&mut commands);\r\n            }\r\n            _ => {}\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\cursor\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_cursor\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\ncursor_hero_character_types = { workspace = true }\r\ncursor_hero_camera = { workspace = true }\r\ncursor_hero_level_bounds = { workspace = true }\r\ncursor_hero_math = { workspace = true }\r\ncursor_hero_bevy = { workspace = true }\r\ncursor_hero_environment_types = { workspace = true }\r\ncursor_hero_input = { workspace = true }\r\ncursor_hero_cursor_types = { workspace = true }\r\ncursor_hero_toolbelt_types = { workspace = true }\r\ncursor_hero_sprint_tool_types = { workspace = true }\r\ncursor_hero_winutils = { workspace = true }\r\nbevy = { workspace = true }\r\nleafwing-input-manager = { workspace = true }\r\nbevy_xpbd_2d = { workspace = true }\r\nbevy_egui = {workspace = true}\r\nbevy-inspector-egui = { workspace = true}\r\nraw-window-handle = {workspace = true }\r\ncursor_hero_worker = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\cursor\\src\\cursor_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse cursor_hero_cursor_types::cursor_action_types::CursorActionPlugin;\r\n\r\nuse crate::cursor_click_plugin::CursorClickPlugin;\r\nuse crate::cursor_hover_plugin::CursorHoverPlugin;\r\nuse crate::cursor_positioning_plugin::CursorPositioningPlugin;\r\nuse crate::cursor_reach_plugin::CursorReachPlugin;\r\nuse crate::cursor_spawning_plugin::CursorSpawningPlugin;\r\nuse crate::cursor_mirroring_plugin::CursorMirroringPlugin;\r\n\r\npub struct CursorPlugin;\r\nimpl Plugin for CursorPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_plugins((\r\n            CursorHoverPlugin,\r\n            CursorReachPlugin,\r\n            CursorClickPlugin,\r\n            CursorPositioningPlugin,\r\n            CursorSpawningPlugin,\r\n            CursorActionPlugin,\r\n            CursorMirroringPlugin,\r\n        ));\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\math\\src\\math_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n\r\nuse crate::prelude::Corner;\r\n\r\npub struct MathPlugin;\r\n\r\nimpl Plugin for MathPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<Corner>();\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\memory\\src\\main_character_memory_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse cursor_hero_character_types::prelude::*;\r\n\r\nuse cursor_hero_memory_types::prelude::*;\r\nuse cursor_hero_toolbelt_types::toolbelt_types::Toolbelt;\r\nuse cursor_hero_toolbelt_types::toolbelt_types::ToolbeltPopulateEvent;\r\nuse serde::Deserialize;\r\nuse serde::Serialize;\r\n\r\npub struct MainCharacterMemoryPlugin;\r\n\r\nimpl Plugin for MainCharacterMemoryPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.insert_resource(MainCharacterMemoryConfig::default());\r\n        app.add_systems(Update, persist.pipe(handle_persist_errors));\r\n        app.add_systems(\r\n            Update,\r\n            (apply_deferred, restore.pipe(handle_restore_errors)).chain(),\r\n        );\r\n    }\r\n}\r\nconst PERSIST_FILE_NAME: &str = \"main_character.json\";\r\n\r\n// not moved to lib to ensure log contains this module name\r\nfn handle_persist_errors(In(result): In<Result<PersistSuccess, PersistError>>) {\r\n    if let Err(e) = result {\r\n        error!(\"Persist error occurred: {:?}\", e);\r\n    } else if let Ok(PersistSuccess::WritePerformed) = result {\r\n        debug!(\"Persisted succeeded\");\r\n    }\r\n}\r\n\r\nfn handle_restore_errors(In(result): In<Result<RestoreSuccess, RestoreError>>) {\r\n    if let Err(e) = result {\r\n        error!(\"Restore error occurred: {:?}\", e);\r\n    } else if let Ok(RestoreSuccess::Performed) = result {\r\n        info!(\"Restore succeeded\");\r\n    }\r\n}\r\n\r\n#[derive(Debug, Resource, Reflect)]\r\n#[reflect(Resource)]\r\nstruct MainCharacterMemoryConfig {\r\n    pub debounce_timer: Timer,\r\n}\r\nimpl Default for MainCharacterMemoryConfig {\r\n    fn default() -> Self {\r\n        Self {\r\n            debounce_timer: Timer::from_seconds(10.0, TimerMode::Repeating),\r\n        }\r\n    }\r\n}\r\n\r\n#[derive(Debug, Serialize, Deserialize, PartialEq, Clone, Copy)]\r\nstruct DiskData {\r\n    character_position: Vec3,\r\n    toolbelt: Toolbelt,\r\n}\r\n\r\nfn persist(\r\n    mut config: ResMut<MainCharacterMemoryConfig>,\r\n    memory_config: Res<MemoryConfig>,\r\n    mut debounce: Local<Option<DiskData>>,\r\n    time: Res<Time>,\r\n    character_query: Query<(&Transform, &Children), With<MainCharacter>>,\r\n    toolbelt_query: Query<&Toolbelt>,\r\n) -> Result<PersistSuccess, PersistError> {\r\n    if !config.debounce_timer.tick(time.delta()).just_finished() {\r\n        return Ok(PersistSuccess::Cooldown);\r\n    }\r\n\r\n    let character = character_query\r\n        .get_single()\r\n        .map_err(|_| PersistError::Query)?;\r\n    let (character_transform, character_children) = character;\r\n    let character_position = character_transform.translation;\r\n\r\n    let mut found = None;\r\n    for child in character_children.iter() {\r\n        match (found, toolbelt_query.get(*child)) {\r\n            (None, Ok(toolbelt)) => {\r\n                found = Some(toolbelt);\r\n            }\r\n            (Some(_), Ok(_)) => {\r\n                return Err(PersistError::Query);\r\n            }\r\n            _ => {}\r\n        }\r\n    }\r\n    let toolbelt = *found.ok_or(PersistError::Query)?;\r\n\r\n    let data = DiskData {\r\n        character_position,\r\n        toolbelt,\r\n    };\r\n    if debounce.is_none() || debounce.as_ref().unwrap() != &data {\r\n        let file = get_persist_file(memory_config.as_ref(), PERSIST_FILE_NAME, Usage::Persist)\r\n            .map_err(PersistError::Io)?;\r\n        write_to_disk(file, data)?;\r\n        *debounce = Some(data);\r\n        Ok(PersistSuccess::WritePerformed)\r\n    } else {\r\n        Ok(PersistSuccess::Debounce)\r\n    }\r\n}\r\n\r\nfn restore(\r\n    memory_config: Res<MemoryConfig>,\r\n    mut character_query: Query<(&mut Transform, &Children), Added<MainCharacter>>,\r\n    mut toolbelt_query: Query<&mut Toolbelt>,\r\n    mut commands: Commands,\r\n    mut toolbelt_events: EventWriter<ToolbeltPopulateEvent>,\r\n) -> Result<RestoreSuccess, RestoreError> {\r\n    let Ok(character) = character_query.get_single_mut() else {\r\n        return Ok(RestoreSuccess::NoAction);\r\n    };\r\n    let (mut character_transform, character_children) = character;\r\n    let mut toolbelt_id = None;\r\n    for child in character_children.iter() {\r\n        match (toolbelt_id, toolbelt_query.contains(*child)) {\r\n            (None, true) => {\r\n                toolbelt_id = Some(child);\r\n            }\r\n            (Some(_), true) => {\r\n                return Err(RestoreError::Query);\r\n            }\r\n            _ => {}\r\n        }\r\n    }\r\n    let toolbelt_id = *toolbelt_id.ok_or(RestoreError::Query)?;\r\n    let mut toolbelt = toolbelt_query\r\n        .get_mut(toolbelt_id)\r\n        .map_err(|_| RestoreError::Query)?;\r\n\r\n    let file = get_persist_file(memory_config.as_ref(), PERSIST_FILE_NAME, Usage::Restore)\r\n        .map_err(RestoreError::Io)?;\r\n    let data: DiskData = read_from_disk(file)?;\r\n\r\n    info!(\r\n        \"Restoring main character position to {:?}\",\r\n        data.character_position\r\n    );\r\n    character_transform.translation = data.character_position;\r\n\r\n    info!(\"Restoring toolbelt to {:?}\", data.toolbelt);\r\n    *toolbelt = data.toolbelt;\r\n    commands.entity(toolbelt_id).despawn_descendants();\r\n    toolbelt_events.send(ToolbeltPopulateEvent {\r\n        id: toolbelt_id,\r\n        loadout: data.toolbelt.loadout,\r\n    });\r\n    // layout is going to get clobbered to defaults by toolbelt_properties_plugin\r\n    // this is fine for now since there are no scenarios where a loadout isn't using its default layout\r\n\r\n    Ok(RestoreSuccess::Performed)\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\chat_types\\src\\lib.rs\r\n\r\n````rust\r\npub mod chat_types;\r\npub mod chat_types_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::chat_types::*;\r\n    pub use crate::chat_types_plugin::ChatTypesPlugin;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\cursor_types\\src\\lib.rs\r\n\r\n````rust\r\npub mod cursor_action_types;\r\npub mod cursor_behaviour_types;\r\npub mod cursor_click_types;\r\npub mod cursor_hover_types;\r\npub mod cursor_reach_types;\r\npub mod cursor_types;\r\npub mod cursor_mirroring_types;\r\npub mod cursor_types_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::cursor_action_types::*;\r\n    pub use crate::cursor_click_types::*;\r\n    pub use crate::cursor_hover_types::*;\r\n    pub use crate::cursor_reach_types::*;\r\n    pub use crate::cursor_types::*;\r\n    pub use crate::cursor_mirroring_types::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\movement_tool\\src\\lib.rs\r\n\r\n````rust\r\npub mod movement_speed_plugin;\r\npub mod movement_sprint_plugin;\r\npub mod movement_target_plugin;\r\npub mod movement_tool_plugin;\r\npub mod movement_tool_populate_plugin;\r\npub mod movement_tool_tick_plugin;\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\host_event\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_host_event\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\ncursor_hero_host_event_types = { workspace = true }\r\ncursor_hero_winutils = {workspace = true}\r\nraw-window-handle = { workspace = true }\r\ncrossbeam-channel = { workspace = true }\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\calculator_app\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_calculator_app\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\ncursor_hero_calculator_app_types = { workspace = true }\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\agent\\src\\insert_agent_toolbelt.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse cursor_hero_agent_types::agent_types::Agent;\r\nuse cursor_hero_character_types::prelude::*;\r\nuse cursor_hero_toolbelt_types::toolbelt_types::*;\r\n\r\npub struct InsertAgentToolbeltPlugin;\r\n\r\nimpl Plugin for InsertAgentToolbeltPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Update, insert_agent_toolbelt);\r\n    }\r\n}\r\n\r\npub fn insert_agent_toolbelt(\r\n    mut commands: Commands,\r\n    mut writer: EventWriter<ToolbeltPopulateEvent>,\r\n    fresh_characters: Query<Entity, (Added<Agent>, With<Character>)>,\r\n) {\r\n    for character in fresh_characters.iter() {\r\n        let character_id = character;\r\n        commands.entity(character_id).with_children(|c_commands| {\r\n            let toolbelt = c_commands.spawn(ToolbeltBundle::default());\r\n            writer.send(ToolbeltPopulateEvent {\r\n                id: toolbelt.id(),\r\n                loadout: ToolbeltLoadout::Agent,\r\n            });\r\n            info!(\r\n                \"Sent populate agent toolbelt event for agent {:?}\",\r\n                character_id\r\n            );\r\n        });\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\memory\\src\\lib.rs\r\n\r\n````rust\r\nmod agent_observation_memory_plugin;\r\nmod main_camera_memory_plugin;\r\nmod main_character_memory_plugin;\r\nmod memory_plugin;\r\npub mod primary_window_memory_plugin;\r\nmod voice_to_text_memory_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::memory_plugin::*;\r\n    pub use cursor_hero_memory_types;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\secret\\src\\secrets_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n\r\npub struct SecretsPlugin;\r\n\r\nimpl Plugin for SecretsPlugin {\r\n    fn build(&self, _app: &mut App) {}\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\tools\\src\\tool_spawning.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse bevy::utils::HashMap;\r\nuse bevy_xpbd_2d::prelude::*;\r\nuse cursor_hero_host_fs_types::host_fs_types::HostPath;\r\nuse cursor_hero_cursor_types::prelude::*;\r\n\r\nuse cursor_hero_toolbelt_types::prelude::*;\r\nuse leafwing_input_manager::prelude::*;\r\nuse std::path::Path;\r\nuse std::path::PathBuf;\r\n\r\n#[derive(Actionlike, PartialEq, Eq, Clone, Copy, Hash, Debug, Reflect)]\r\npub enum NoInputs {}\r\n\r\nimpl ToolAction for NoInputs {\r\n    fn default_input_map(_event: &ToolbeltPopulateEvent) -> Option<InputMap<Self>> {\r\n        None\r\n    }\r\n}\r\n\r\npub struct ToolSpawnConfig<T, Action>\r\nwhere\r\n    T: Bundle,\r\n    Action: ToolAction + Actionlike,\r\n{\r\n    tag: T,\r\n    event: ToolbeltPopulateEvent,\r\n    name: String,\r\n    description: String,\r\n    display_actions: HashMap<String, Vec<UserInput>>,\r\n    texture: Handle<Image>,\r\n    toolbelt_id: Entity,\r\n    starting_state: StartingState,\r\n    size: Option<Vec2>,\r\n    input_map: Option<InputMap<Action>>,\r\n    src_path: Option<PathBuf>,\r\n}\r\n\r\nimpl<T, Action> ToolSpawnConfig<T, Action>\r\nwhere\r\n    T: Bundle,\r\n    Action: ToolAction + Actionlike + core::fmt::Debug,\r\n{\r\n    pub fn new(tag: T, toolbelt_id: Entity, event: &ToolbeltPopulateEvent) -> Self {\r\n        Self {\r\n            tag,\r\n            event: *event,\r\n            name: \"Unnamed Tool\".to_string(),\r\n            description: \"Who knows what this does?\".to_string(),\r\n            texture: Handle::default(),\r\n            toolbelt_id,\r\n            starting_state: StartingState::Active,\r\n            size: Some(Vec2::new(100.0, 100.0)),\r\n            input_map: None,\r\n            display_actions: HashMap::new(),\r\n            src_path: None,\r\n        }\r\n        .with_input_map(Action::default_input_map(event))\r\n    }\r\n\r\n    pub fn with_src_path(mut self, path: PathBuf) -> Self {\r\n        self.src_path = Some(path);\r\n        self\r\n    }\r\n\r\n    pub fn with_name(mut self, name: String) -> Self {\r\n        self.name = name;\r\n        self\r\n    }\r\n\r\n    pub fn with_description(mut self, description: &'static str) -> Self {\r\n        self.description = description.to_string();\r\n        self\r\n    }\r\n\r\n    pub fn guess_name(mut self, file_path: &str) -> Self {\r\n        self.name = Self::format_tool_name_from_source(file_path);\r\n        self\r\n    }\r\n\r\n    pub fn with_input_map(mut self, input_map: Option<InputMap<Action>>) -> Self {\r\n        self.display_actions = match input_map {\r\n            None => HashMap::new(),\r\n            Some(ref input_map) => input_map\r\n                .iter()\r\n                .map(|v| (format!(\"{:?}\", v.0), v.1.clone()))\r\n                .collect(),\r\n        };\r\n        self.input_map = input_map;\r\n        self\r\n    }\r\n\r\n    fn format_tool_name_from_source(file_path: &str) -> String {\r\n        // Extract the file name from the path\r\n        Self::clean_name(file_path)\r\n            .split('_')\r\n            .map(|word| {\r\n                word.chars()\r\n                    .enumerate()\r\n                    .map(|(i, c)| {\r\n                        if i == 0 {\r\n                            c.to_uppercase().to_string()\r\n                        } else {\r\n                            c.to_string()\r\n                        }\r\n                    })\r\n                    .collect::<String>()\r\n            })\r\n            .collect::<Vec<_>>()\r\n            .join(\" \")\r\n    }\r\n\r\n    pub fn guess_image(\r\n        mut self,\r\n        file_path: &str,\r\n        asset_server: &Res<AssetServer>,\r\n        extension: &str,\r\n    ) -> Self {\r\n        self.texture = asset_server.load(Self::format_tool_image_from_source(file_path, extension));\r\n        self\r\n    }\r\n\r\n    fn clean_name(file_path: &str) -> &str {\r\n        Path::new(file_path)\r\n            .file_stem() // Get the file stem (file name without extension)\r\n            .and_then(|stem| stem.to_str()) // Convert OsStr to &str\r\n            .unwrap_or(\"\")\r\n            .trim_end_matches(\"_plugin\")\r\n            .trim_end_matches(\"_populate\")\r\n            .trim_start_matches(\"spawn_\")\r\n    }\r\n\r\n    fn format_tool_image_from_source(file_path: &str, extension: &str) -> String {\r\n        format!(\r\n            \"textures/tools/{}.{}\",\r\n            Self::clean_name(file_path),\r\n            extension\r\n        )\r\n    }\r\n\r\n    pub fn with_asset_image(\r\n        mut self,\r\n        file_name: &'static str,\r\n        asset_server: &Res<AssetServer>,\r\n    ) -> Self {\r\n        self.texture = asset_server.load(format!(\"textures/tools/{}\", file_name));\r\n        self\r\n    }\r\n\r\n    pub fn with_image(mut self, texture: Handle<Image>) -> Self {\r\n        self.texture = texture;\r\n        self\r\n    }\r\n\r\n    pub fn with_starting_state(mut self, state: StartingState) -> Self {\r\n        self.starting_state = state;\r\n        self\r\n    }\r\n\r\n    pub fn with_size(mut self, size: Vec2) -> Self {\r\n        self.size = Some(size);\r\n        self\r\n    }\r\n\r\n    pub fn spawn(self, commands: &mut Commands) {\r\n        commands.entity(self.toolbelt_id).with_children(|toolbelt| {\r\n            let mut tool = toolbelt.spawn((\r\n                Tool {\r\n                    name: self.name.clone(),\r\n                    description: self.description,\r\n                    actions: self.display_actions,\r\n                    texture: self.texture.clone(),\r\n                },\r\n                self.tag,\r\n                Name::new(self.name.clone()),\r\n                SpriteBundle {\r\n                    sprite: Sprite {\r\n                        custom_size: self.size,\r\n                        ..default()\r\n                    },\r\n                    texture: self.texture,\r\n                    visibility: Visibility::Hidden,\r\n                    ..default()\r\n                },\r\n                Sensor,\r\n                RigidBody::Kinematic,\r\n                Hoverable,\r\n                Collider::cuboid(100.0, 100.0),\r\n            ));\r\n            if let StartingState::Active = self.starting_state {\r\n                tool.insert(ActiveTool);\r\n            }\r\n            if let Some(src_path) = self.src_path {\r\n                tool.insert(HostPath { path: src_path });\r\n            }\r\n            let input_map = self.input_map.unwrap_or_default();\r\n            tool.insert(InputManagerBundle {\r\n                input_map,\r\n                ..default()\r\n            });\r\n        });\r\n        debug!(\"{:?} => {:?}\", self.event, self.name);\r\n    }\r\n}\r\n\r\n#[allow(clippy::too_many_arguments)]\r\nfn spawn_tool_impl(\r\n    tool: Tool,\r\n    event: &ToolbeltPopulateEvent,\r\n    commands: &mut Commands,\r\n    toolbelt_id: Entity,\r\n    _asset_server: &Res<AssetServer>,\r\n    tool_component: impl Component,\r\n    input_manager: Option<impl Bundle>,\r\n    starting_state: StartingState,\r\n    custom_size: Option<Vec2>,\r\n) {\r\n    let tool_name = tool.name.clone();\r\n    commands.entity(toolbelt_id).with_children(|toolbelt| {\r\n        let name = Name::new(tool_name.clone());\r\n        let texture = tool.texture.clone();\r\n        let mut tool = toolbelt.spawn((\r\n            tool,\r\n            name,\r\n            SpriteBundle {\r\n                sprite: Sprite {\r\n                    custom_size: custom_size.or(Some(Vec2::new(100.0, 100.0))),\r\n                    ..default()\r\n                },\r\n                texture,\r\n                visibility: Visibility::Hidden,\r\n                ..default()\r\n            },\r\n            tool_component,\r\n            Sensor,\r\n            RigidBody::Kinematic,\r\n            Collider::cuboid(100.0, 100.0),\r\n        ));\r\n        if let StartingState::Active = starting_state {\r\n            tool.insert(ActiveTool);\r\n        }\r\n        if let Some(bundle) = input_manager {\r\n            tool.insert(bundle);\r\n        }\r\n    });\r\n    info!(\"{:?} => {:?}\", event, tool_name);\r\n}\r\n\r\n#[allow(clippy::too_many_arguments)]\r\npub fn spawn_action_tool<T>(\r\n    tool: Tool,\r\n    event: &ToolbeltPopulateEvent,\r\n    commands: &mut Commands,\r\n    toolbelt_id: Entity,\r\n    _character_id: Entity,\r\n    asset_server: &Res<AssetServer>,\r\n    tool_component: impl Component,\r\n    starting_state: StartingState,\r\n    custom_size: Option<Vec2>,\r\n) where\r\n    T: ToolAction + Actionlike,\r\n{\r\n    spawn_tool_impl(\r\n        tool,\r\n        event,\r\n        commands,\r\n        toolbelt_id,\r\n        asset_server,\r\n        tool_component,\r\n        T::default_input_map(event).map(|input_map| InputManagerBundle::<T> {\r\n            input_map,\r\n            ..default()\r\n        }),\r\n        starting_state,\r\n        custom_size,\r\n    )\r\n}\r\n\r\n#[derive(Bundle)]\r\npub struct NoopBundle {}\r\n\r\n#[derive(Debug)]\r\npub enum StartingState {\r\n    Active,\r\n    Inactive,\r\n}\r\nimpl StartingState {\r\n    pub fn as_active(&self) -> Option<ActiveTool> {\r\n        match self {\r\n            StartingState::Active => Some(ActiveTool),\r\n            StartingState::Inactive => None,\r\n        }\r\n    }\r\n}\r\n\r\n#[allow(clippy::too_many_arguments)]\r\npub fn spawn_tool(\r\n    tool: Tool,\r\n    event: &ToolbeltPopulateEvent,\r\n    commands: &mut Commands,\r\n    toolbelt_id: Entity,\r\n    _character_id: Entity,\r\n    asset_server: &Res<AssetServer>,\r\n    tool_component: impl Component,\r\n    starting_state: StartingState,\r\n    custom_size: Option<Vec2>,\r\n) {\r\n    spawn_tool_impl(\r\n        tool,\r\n        event,\r\n        commands,\r\n        toolbelt_id,\r\n        asset_server,\r\n        tool_component,\r\n        None::<NoopBundle>,\r\n        starting_state,\r\n        custom_size,\r\n    )\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui_automation\\src\\elements_at_point.rs\r\n\r\n````rust\r\nuse bevy::math::IVec2;\r\nuse std::collections::VecDeque;\r\nuse uiautomation::types::Point;\r\nuse uiautomation::UIAutomation;\r\nuse uiautomation::UIElement;\r\n\r\npub fn find_element_at(pos: IVec2) -> Result<UIElement, uiautomation::Error> {\r\n    let automation = UIAutomation::new()?;\r\n    automation.element_from_point(Point::new(pos.x, pos.y))\r\n}\r\n\r\npub fn gather_elements_at(pos: IVec2) -> Result<Vec<(UIElement, usize)>, uiautomation::Error> {\r\n    let automation = UIAutomation::new()?;\r\n    let walker = automation.create_tree_walker()?;\r\n    let start = automation.element_from_point(Point::new(pos.x, pos.y))?;\r\n    let mut rtn = vec![];\r\n    let mut next = VecDeque::new();\r\n    next.push_back((start, 0));\r\n    while let Some((elem, depth)) = next.pop_front() {\r\n        rtn.push((elem.clone(), depth));\r\n        if let Ok(child) = walker.get_first_child(&elem) {\r\n            next.push_back((child.clone(), depth + 1));\r\n            let mut next_sibling = child;\r\n            while let Ok(sibling) = walker.get_next_sibling(&next_sibling) {\r\n                next.push_back((sibling.clone(), depth + 1));\r\n                next_sibling = sibling;\r\n            }\r\n        }\r\n    }\r\n    Ok(rtn)\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\tools\\src\\talk_tool.rs\r\n\r\n````rust\r\nuse std::thread;\r\n\r\nuse bevy::prelude::*;\r\nuse cursor_hero_voice_to_text_types::voice_to_text_types::VoiceToTextCommandEvent;\r\nuse cursor_hero_voice_to_text_types::voice_to_text_types::VoiceToTextStatus;\r\nuse cursor_hero_voice_to_text_types::voice_to_text_types::VoiceToTextStatusEvent;\r\nuse leafwing_input_manager::prelude::*;\r\n\r\nuse crossbeam_channel::bounded;\r\nuse crossbeam_channel::Sender;\r\nuse cursor_hero_winutils::win_mouse::press_f23_key;\r\nuse cursor_hero_winutils::win_mouse::release_f23_key;\r\n\r\nuse cursor_hero_toolbelt_types::prelude::*;\r\n\r\nuse crate::prelude::*;\r\n\r\npub struct TalkToolPlugin;\r\n\r\nimpl Plugin for TalkToolPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<TalkTool>();\r\n        app.add_plugins(InputManagerPlugin::<TalkToolAction>::default());\r\n        app.add_systems(Startup, spawn_worker_thread);\r\n        app.add_systems(Update, toolbelt_events);\r\n        app.add_systems(Update, handle_input);\r\n    }\r\n}\r\n\r\n#[derive(Component, Reflect, Default)]\r\nstruct TalkTool;\r\n\r\nfn toolbelt_events(\r\n    mut commands: Commands,\r\n    asset_server: Res<AssetServer>,\r\n    mut reader: EventReader<ToolbeltPopulateEvent>,\r\n) {\r\n    for event in reader.read() {\r\n        let (ToolbeltLoadout::Keyboard | ToolbeltLoadout::Default) = event.loadout else {\r\n            continue;\r\n        };\r\n        {\r\n            ToolSpawnConfig::<TalkTool, TalkToolAction>::new(TalkTool, event.id, event)\r\n                .with_src_path(file!().into())\r\n                .guess_name(file!())\r\n                .guess_image(file!(), &asset_server, \"png\")\r\n                .with_description(\"Presses F23\")\r\n                .spawn(&mut commands);\r\n        }\r\n    }\r\n}\r\n\r\n#[derive(Actionlike, PartialEq, Eq, Clone, Copy, Hash, Debug, Reflect)]\r\nenum TalkToolAction {\r\n    PushToTalk,\r\n    ToggleAlwaysOn,\r\n}\r\n\r\n#[derive(Debug)]\r\nenum Motion {\r\n    Up,\r\n    Down,\r\n}\r\n\r\n#[derive(Debug)]\r\nenum ThreadMessage {\r\n    ListenButton(Motion),\r\n}\r\n\r\n#[derive(Resource)]\r\nstruct Bridge {\r\n    pub sender: Sender<ThreadMessage>,\r\n}\r\n\r\nimpl TalkToolAction {\r\n    fn default_wheel_gamepad_binding(&self) -> UserInput {\r\n        match self {\r\n            Self::PushToTalk => GamepadButtonType::Select.into(),\r\n            Self::ToggleAlwaysOn => GamepadButtonType::Start.into(),\r\n        }\r\n    }\r\n\r\n    fn default_wheel_mkb_binding(&self) -> UserInput {\r\n        match self {\r\n            Self::PushToTalk => KeyCode::ShiftRight.into(),\r\n            Self::ToggleAlwaysOn => KeyCode::Scroll.into(),\r\n        }\r\n    }\r\n    fn talk_wheel_gamepad_binding(&self) -> UserInput {\r\n        match self {\r\n            Self::PushToTalk => GamepadButtonType::Select.into(),\r\n            Self::ToggleAlwaysOn => GamepadButtonType::Start.into(),\r\n        }\r\n    }\r\n\r\n    fn talk_wheel_mkb_binding(&self) -> UserInput {\r\n        match self {\r\n            Self::PushToTalk => KeyCode::ShiftRight.into(),\r\n            Self::ToggleAlwaysOn => KeyCode::Scroll.into(),\r\n        }\r\n    }\r\n}\r\nimpl ToolAction for TalkToolAction {\r\n    fn default_input_map(event: &ToolbeltPopulateEvent) -> Option<InputMap<TalkToolAction>> {\r\n        match event.loadout {\r\n            ToolbeltLoadout::Default => Some(Self::with_defaults(\r\n                Self::default_wheel_gamepad_binding,\r\n                Self::default_wheel_mkb_binding,\r\n            )),\r\n            ToolbeltLoadout::Keyboard => Some(Self::with_defaults(\r\n                Self::talk_wheel_gamepad_binding,\r\n                Self::talk_wheel_mkb_binding,\r\n            )),\r\n            _ => None,\r\n        }\r\n    }\r\n}\r\n\r\nfn spawn_worker_thread(mut commands: Commands) {\r\n    let (tx, rx) = bounded::<_>(10);\r\n    commands.insert_resource(Bridge { sender: tx });\r\n    thread::spawn(move || loop {\r\n        let action = match rx.recv() {\r\n            Ok(action) => action,\r\n            Err(e) => {\r\n                error!(\"Failed to receive thread message, exiting: {:?}\", e);\r\n                break;\r\n            }\r\n        };\r\n        debug!(\"Worker received thread message: {:?}\", action);\r\n        match match action {\r\n            ThreadMessage::ListenButton(Motion::Down) => press_f23_key(),\r\n            ThreadMessage::ListenButton(Motion::Up) => release_f23_key(),\r\n        } {\r\n            Ok(_) => {}\r\n            Err(e) => {\r\n                error!(\"Failed to handle event {:?}: {:?}\", action, e);\r\n            }\r\n        }\r\n    });\r\n}\r\n\r\nfn handle_input(\r\n    tools: Query<&ActionState<TalkToolAction>, With<ActiveTool>>,\r\n    bridge: ResMut<Bridge>,\r\n    mut voice_command_events: EventWriter<VoiceToTextCommandEvent>,\r\n    mut voice_status_events: EventWriter<VoiceToTextStatusEvent>,\r\n    mut voice_status: ResMut<VoiceToTextStatus>,\r\n) {\r\n    for t_act in tools.iter() {\r\n        if t_act.just_pressed(TalkToolAction::PushToTalk) {\r\n            info!(\"Listen button pressed\");\r\n            match bridge\r\n                .sender\r\n                .send(ThreadMessage::ListenButton(Motion::Down))\r\n            {\r\n                Ok(_) => {}\r\n                Err(e) => {\r\n                    error!(\"Failed to send thread message: {:?}\", e);\r\n                }\r\n            }\r\n        }\r\n        if t_act.just_released(TalkToolAction::PushToTalk) {\r\n            info!(\"Listen button released\");\r\n            match bridge.sender.send(ThreadMessage::ListenButton(Motion::Up)) {\r\n                Ok(_) => {}\r\n                Err(e) => {\r\n                    error!(\"Failed to send thread message: {:?}\", e);\r\n                }\r\n            }\r\n        }\r\n        if t_act.just_pressed(TalkToolAction::ToggleAlwaysOn) {\r\n            let VoiceToTextStatus::Alive { api_key, listening } = voice_status.clone() else {\r\n                warn!(\"VoiceToTextStatus not Alive, ignoring event\");\r\n                continue;\r\n            };\r\n            let new_status = VoiceToTextStatus::Alive {\r\n                api_key: api_key.clone(),\r\n                listening: !listening,\r\n            };\r\n\r\n            let event = VoiceToTextCommandEvent::SetListening {\r\n                listening: !listening,\r\n                api_key,\r\n            };\r\n            info!(\"Sending event: {:?}\", event);\r\n            voice_command_events.send(event);\r\n\r\n            let event = VoiceToTextStatusEvent::Changed {\r\n                old_status: voice_status.clone(),\r\n                new_status: new_status.clone(),\r\n            };\r\n            info!(\"Sending event: {:?}\", event);\r\n            voice_status_events.send(event);\r\n\r\n            *voice_status = new_status;\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\text_asset\\src\\text_asset_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse cursor_hero_text_asset_types::prelude::*;\r\npub struct TextAssetPlugin;\r\n\r\nimpl Plugin for TextAssetPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.init_asset::<TextAsset>();\r\n        app.init_asset_loader::<TextAssetLoader>();\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\plugins\\src\\default_launch_mode_plugin.rs\r\n\r\n````rust\r\nuse bevy::input::common_conditions::input_toggle_active;\r\nuse bevy::prelude::*;\r\nuse cursor_hero_input::active_input_state_plugin::InputMethod;\r\n\r\nuse bevy::audio::AudioPlugin;\r\nuse bevy::audio::SpatialScale;\r\nuse bevy::diagnostic::FrameTimeDiagnosticsPlugin;\r\nuse bevy::log::LogPlugin;\r\nuse bevy_embedded_assets::EmbeddedAssetPlugin;\r\nuse bevy_inspector_egui::quick::StateInspectorPlugin;\r\nuse bevy_inspector_egui::quick::WorldInspectorPlugin;\r\nuse cursor_hero_agent::agent_plugin::AgentPlugin;\r\nuse cursor_hero_camera::camera_plugin::CameraPlugin;\r\nuse cursor_hero_character::character_plugin::CharacterPlugin;\r\nuse cursor_hero_environment::environment_plugin::EnvironmentPlugin;\r\nuse cursor_hero_environment_nametag::environment_nametag_plugin::EnvironmentNametagPlugin;\r\nuse cursor_hero_hover::hover_tool::HoverToolPlugin;\r\nuse cursor_hero_hover::hover_ui_automation_plugin::HoverUiAutomationPlugin;\r\nuse cursor_hero_hover::screenshot_tool::ScreenshotToolPlugin;\r\nuse cursor_hero_icon::IconPlugin;\r\nuse cursor_hero_input::InputPlugin;\r\nuse cursor_hero_level_bounds::level_bounds_plugin::LevelBoundsPlugin;\r\nuse cursor_hero_math::prelude::MathPlugin;\r\nuse cursor_hero_memory::primary_window_memory_plugin::restore_window;\r\nuse cursor_hero_physics::damping_plugin::DampingPlugin;\r\nuse cursor_hero_physics::physics_plugin::PhysicsPlugin;\r\nuse cursor_hero_physics_debug::physics_debug_plugin::PhysicsDebugPlugin;\r\nuse cursor_hero_cursor::cursor_plugin::CursorPlugin;\r\nuse cursor_hero_cursor_types::cursor_types_plugin::CursorTypesPlugin;\r\nuse cursor_hero_pressure_plate::pressure_plate_plugin::PressurePlatePlugin;\r\nuse cursor_hero_screen::screen_plugin::ScreenPlugin;\r\nuse cursor_hero_screen::screen_capture_and_update_plugin::ScreenCaptureAndUpdatePlugin;\r\nuse cursor_hero_sprint_tool::sprint_tool_plugin::SprintToolPlugin;\r\nuse cursor_hero_sprint_tool_types::sprint_tool_types_plugin::SprintToolTypesPlugin;\r\nuse cursor_hero_taskbar::taskbar_plugin::TaskbarPlugin;\r\nuse cursor_hero_toolbelt::toolbelt_plugin::ToolbeltPlugin;\r\nuse cursor_hero_toolbelt_types::toolbelt_types_plugin::ToolbeltTypesPlugin;\r\nuse cursor_hero_tools::ToolPlugin;\r\nuse cursor_hero_ui::about_text_plugin::AboutTextPlugin;\r\nuse cursor_hero_ui::fps_text_plugin::FpsTextPlugin;\r\nuse cursor_hero_ui_watcher::ui_watcher_plugin::UiWatcherPlugin;\r\nuse cursor_hero_ui_watcher_types::ui_watcher_types_plugin::UiWatcherTypesPlugin;\r\nuse cursor_hero_version::version_plugin::Version;\r\nuse cursor_hero_wallpaper::wallpaper_plugin::WallpaperPlugin;\r\n\r\nuse cursor_hero_agent_types::agent_types_plugin::AgentTypesPlugin;\r\nuse cursor_hero_app::prelude::*;\r\nuse cursor_hero_app_types::prelude::*;\r\nuse cursor_hero_brick::prelude::*;\r\nuse cursor_hero_brick_types::prelude::*;\r\nuse cursor_hero_calculator_app::prelude::*;\r\nuse cursor_hero_calculator_app_types::prelude::*;\r\nuse cursor_hero_character_types::character_types_plugin::CharacterTypesPlugin;\r\nuse cursor_hero_chat::chat_plugin::ChatPlugin;\r\nuse cursor_hero_chat_types::chat_types_plugin::ChatTypesPlugin;\r\nuse cursor_hero_environment_types::environment_types_plugin::EnvironmentTypesPlugin;\r\nuse cursor_hero_floaty_nametag::prelude::*;\r\nuse cursor_hero_floaty_nametag_types::prelude::*;\r\nuse cursor_hero_fullscreen_tool::prelude::*;\r\nuse cursor_hero_fullscreen_tool_types::prelude::*;\r\nuse cursor_hero_glados_tts::prelude::*;\r\nuse cursor_hero_glados_tts_types::prelude::*;\r\nuse cursor_hero_host_event::prelude::*;\r\nuse cursor_hero_host_event_types::prelude::*;\r\nuse cursor_hero_host_fs::prelude::*;\r\nuse cursor_hero_host_fs_types::prelude::*;\r\nuse cursor_hero_inference::inference_plugin::InferencePlugin;\r\nuse cursor_hero_inference_types::inference_types_plugin::InferenceTypesPlugin;\r\nuse cursor_hero_memory::prelude::*;\r\nuse cursor_hero_memory_types::prelude::*;\r\nuse cursor_hero_movement_tool::movement_tool_plugin::MovementToolPlugin;\r\nuse cursor_hero_movement_tool_types::movement_tool_types_plugin::MovementToolTypesPlugin;\r\nuse cursor_hero_observation::observation_plugin::ObservationPlugin;\r\nuse cursor_hero_observation_types::observation_types_plugin::ObservationTypesPlugin;\r\nuse cursor_hero_ollama::prelude::*;\r\nuse cursor_hero_ollama_types::prelude::*;\r\nuse cursor_hero_secret::prelude::*;\r\nuse cursor_hero_secret_types::prelude::*;\r\nuse cursor_hero_start_menu::prelude::*;\r\nuse cursor_hero_start_menu_types::prelude::*;\r\nuse cursor_hero_taskbar_tool::prelude::*;\r\nuse cursor_hero_taskbar_types::prelude::TaskbarTypesPlugin;\r\nuse cursor_hero_text_asset::prelude::*;\r\nuse cursor_hero_text_asset_types::prelude::*;\r\nuse cursor_hero_ui_automation::prelude::*;\r\nuse cursor_hero_voice_to_text::prelude::*;\r\nuse cursor_hero_voice_to_text_types::prelude::*;\r\nuse cursor_hero_window_position::prelude::*;\r\nuse cursor_hero_window_position_types::prelude::*;\r\nuse cursor_hero_window_swap_tool::prelude::*;\r\nuse cursor_hero_window_swap_tool_types::prelude::*;\r\nuse cursor_hero_ui_inspector::prelude::*;\r\nuse cursor_hero_ui_inspector_types::prelude::*;\r\nuse cursor_hero_ui_hover::prelude::*;\r\nuse cursor_hero_ui_hover_types::prelude::*;\r\npub struct DefaultLaunchModePlugin;\r\n\r\nimpl Plugin for DefaultLaunchModePlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_plugins(UiHoverTypesPlugin);\r\n        app.add_plugins(UiHoverPlugin);\r\n        app.add_plugins(UIInspectorTypesPlugin);\r\n        app.add_plugins(UiInspectorPlugin);\r\n        app.add_plugins(MemoryTypesPlugin);\r\n        let memory_config = MemoryConfig {\r\n            save_dir: \"Cursor Hero Memory\".to_string(),\r\n        };\r\n        app.add_plugins(MemoryPlugin {\r\n            config: memory_config.clone(),\r\n            build_config: MemoryPluginBuildConfig::all_enabled(),\r\n        });\r\n        app.add_plugins(WindowSwapToolPlugin);\r\n        app.add_plugins(WindowSwapToolTypesPlugin);\r\n        app.add_plugins(HostFsTypesPlugin);\r\n        app.add_plugins(HostFsPlugin);\r\n        app.add_plugins(WindowPositionTypesPlugin);\r\n        app.add_plugins(WindowPositionPlugin);\r\n        app.add_plugins(UiAutomationTypesPlugin);\r\n        app.add_plugins(UiAutomationPlugin);\r\n        app.add_plugins(BrickTypesPlugin);\r\n        app.add_plugins(BrickPlugin);\r\n        app.add_plugins(FullscreenToolPlugin);\r\n        app.add_plugins(FullscreenToolTypesPlugin);\r\n        app.add_plugins(FloatyNametagTypesPlugin);\r\n        app.add_plugins(FloatyNametagPlugin);\r\n        app.add_plugins(HostEventTypesPlugin);\r\n        app.add_plugins(HostEventPlugin);\r\n        app.add_plugins(TaskbarToolPlugin);\r\n        app.add_plugins(StartMenuTypesPlugin);\r\n        app.add_plugins(StartMenuPlugin);\r\n        app.add_plugins(CalculatorAppTypesPlugin);\r\n        app.add_plugins(CalculatorAppPlugin);\r\n        app.add_plugins(AppTypesPlugin);\r\n        app.add_plugins(AppPlugin);\r\n        app.add_plugins(SecretsTypesPlugin);\r\n        app.add_plugins(SecretsPlugin);\r\n        app.add_plugins(VoiceToTextTypesPlugin);\r\n        app.add_plugins(VoiceToTextPlugin);\r\n        app.add_plugins(GladosTtsTypesPlugin);\r\n        app.add_plugins(GladosTtsPlugin);\r\n        app.add_plugins(OllamaTypesPlugin);\r\n        app.add_plugins(OllamaPlugin);\r\n        app.add_plugins(EnvironmentTypesPlugin);\r\n        app.add_plugins(ChatTypesPlugin);\r\n        app.add_plugins(ChatPlugin);\r\n        app.add_plugins(ObservationTypesPlugin);\r\n        app.add_plugins(ObservationPlugin);\r\n        app.add_plugins(InferenceTypesPlugin);\r\n        app.add_plugins(InferencePlugin);\r\n        app.add_plugins(MovementToolTypesPlugin);\r\n        app.add_plugins(MovementToolPlugin);\r\n        app.add_plugins(CharacterTypesPlugin);\r\n        app.add_plugins(AgentTypesPlugin);\r\n        app.add_plugins(AgentPlugin);\r\n        app.add_plugins(AboutTextPlugin);\r\n        app.add_plugins(CameraPlugin);\r\n        app.add_plugins(CharacterPlugin);\r\n        app.add_plugins(DampingPlugin);\r\n        app.add_plugins(EnvironmentNametagPlugin);\r\n        app.add_plugins(EnvironmentPlugin);\r\n        app.add_plugins(FpsTextPlugin);\r\n        app.add_plugins(HoverToolPlugin);\r\n        app.add_plugins(HoverUiAutomationPlugin);\r\n        app.add_plugins(IconPlugin);\r\n        app.add_plugins(InputPlugin);\r\n        app.add_plugins(ScreenshotToolPlugin);\r\n        app.add_plugins(LevelBoundsPlugin);\r\n        app.add_plugins(MathPlugin);\r\n        app.add_plugins(PhysicsDebugPlugin);\r\n        app.add_plugins(PhysicsPlugin);\r\n        app.add_plugins(CursorPlugin);\r\n        app.add_plugins(CursorTypesPlugin);\r\n        app.add_plugins(PressurePlatePlugin);\r\n        app.add_plugins(ScreenPlugin);\r\n        app.add_plugins(ScreenCaptureAndUpdatePlugin);\r\n        app.add_plugins(SprintToolPlugin);\r\n        app.add_plugins(SprintToolTypesPlugin);\r\n        app.add_plugins(TaskbarPlugin);\r\n        app.add_plugins(ToolbeltPlugin);\r\n        app.add_plugins(ToolbeltTypesPlugin);\r\n        app.add_plugins(ToolPlugin);\r\n        app.add_plugins(WallpaperPlugin);\r\n        app.add_plugins(UiWatcherTypesPlugin);\r\n        app.add_plugins(UiWatcherPlugin);\r\n\r\n        // must be before the default plugins\r\n        app.add_plugins(EmbeddedAssetPlugin {\r\n            mode: bevy_embedded_assets::PluginMode::ReplaceDefault,\r\n        });\r\n\r\n        #[cfg(debug_assertions)]\r\n        let log_plugin = LogPlugin {\r\n            level: bevy::log::Level::INFO,\r\n            filter: \"wgpu=error,cursor_hero=debug,cursor_hero_ui_automation_types=trace\"\r\n// bevy_ecs=info,\r\n// cursor_hero=debug,\r\n// cursor_hero_cursor::cursor_hover_plugin=info,\r\n// cursor_hero_ollama::ollama_status_worker_plugin=info,\r\n// cursor_hero_voice_to_text::voice_to_text_ping_plugin=info,\r\n// cursor_hero_voice_to_text::voice_to_text_worker_plugin=info,\r\n// cursor_hero_glados_tts::glados_tts_status_worker_plugin=info,\r\n// cursor_hero_tools::click_tool=info,\r\n// cursor_hero_memory=info\r\n            .replace('\\n', \"\")\r\n            .trim()\r\n            .into(),\r\n            // TODO: fix warnings when minimized\r\n        };\r\n        //         #[cfg(debug_assertions)]\r\n        //         let log_plugin = LogPlugin {\r\n        //             level: bevy::log::Level::DEBUG,\r\n        //             filter: \"\r\n        // debug\r\n        //             \".replace('\\n',\"\").trim().into(),\r\n        //             // TODO: fix warnings when minimized\r\n        //         };\r\n        #[cfg(not(debug_assertions))]\r\n        let log_plugin = LogPlugin {\r\n            level: bevy::log::Level::INFO,\r\n            filter: \"wgpu=error\".into(),\r\n        };\r\n        const AUDIO_SCALE: f32 = 1. / 100.0;\r\n        let version = match app.world.get_resource::<Version>() {\r\n            Some(version) => version.0.clone(),\r\n            None => {\r\n                warn!(\"Version resource not found\");\r\n                \"Unknown\".to_string()\r\n            }\r\n        };\r\n        let mut window = Window {\r\n            title: format!(\"Cursor Hero v{}\", version),\r\n            resizable: true,\r\n            ..default()\r\n        };\r\n        if let Err(e) = restore_window(&memory_config, &mut window) {\r\n            error!(\"Failed to restore window: {:?}\", e);\r\n        }\r\n        app.add_plugins(\r\n            DefaultPlugins\r\n                .set(ImagePlugin::default_nearest())\r\n                .set(AudioPlugin {\r\n                    spatial_scale: SpatialScale::new_2d(AUDIO_SCALE),\r\n                    ..default()\r\n                })\r\n                .set(WindowPlugin {\r\n                    primary_window: Some(window),\r\n                    ..default()\r\n                })\r\n                .set(log_plugin)\r\n                .build(),\r\n        );\r\n\r\n        // must be after the default plugins (relies on assetserver existing)\r\n        app.add_plugins(TextAssetTypesPlugin);\r\n        app.add_plugins(TextAssetPlugin);\r\n        app.add_plugins(TaskbarTypesPlugin);\r\n\r\n        // must be after the default plugins\r\n        app.add_plugins(\r\n            WorldInspectorPlugin::default().run_if(input_toggle_active(false, KeyCode::Grave)),\r\n        );\r\n        app.add_plugins(\r\n            StateInspectorPlugin::<InputMethod>::default()\r\n                .run_if(input_toggle_active(false, KeyCode::Grave)),\r\n        );\r\n        app.add_plugins(FrameTimeDiagnosticsPlugin);\r\n    }\r\n}\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\toolbelt\\src\\wheel_audio.rs\r\n\r\n````rust\r\nuse cursor_hero_toolbelt_types::toolbelt_types::*;\r\n\r\nuse bevy::audio::Volume;\r\nuse bevy::audio::VolumeLevel;\r\nuse bevy::prelude::*;\r\n\r\n#[derive(Component)]\r\npub struct WheelAudio;\r\n\r\npub fn wheel_audio(\r\n    mut commands: Commands,\r\n    asset_server: Res<AssetServer>,\r\n    mut toolbelt_events: EventReader<ToolbeltOpeningEvent>,\r\n    toolbelt_query: Query<&GlobalTransform>,\r\n) {\r\n    for event in toolbelt_events.read() {\r\n        match event {\r\n            ToolbeltOpeningEvent::Opened { toolbelt_id } => {\r\n                let Ok(toolbelt_transform) = toolbelt_query.get(*toolbelt_id) else {\r\n                    continue;\r\n                };\r\n                commands.spawn((\r\n                    AudioBundle {\r\n                        source: asset_server.load(\"sounds/plastic toy snapping shut 1.ogg\"),\r\n                        settings: PlaybackSettings::DESPAWN\r\n                            .with_spatial(true)\r\n                            .with_volume(Volume::Relative(VolumeLevel::new(0.5))),\r\n                    },\r\n                    SpatialBundle {\r\n                        transform: toolbelt_transform.compute_transform(),\r\n                        ..default()\r\n                    },\r\n                    WheelAudio,\r\n                    Name::new(\"opening sound\"),\r\n                ));\r\n            }\r\n            ToolbeltOpeningEvent::Closed { toolbelt_id } => {\r\n                let Ok(toolbelt_transform) = toolbelt_query.get(*toolbelt_id) else {\r\n                    continue;\r\n                };\r\n                commands.spawn((\r\n                    AudioBundle {\r\n                        source: asset_server\r\n                            .load(\"sounds/plastic toy snapping shut 1 reversed.ogg\"),\r\n                        settings: PlaybackSettings::DESPAWN\r\n                            .with_spatial(true)\r\n                            .with_volume(Volume::Relative(VolumeLevel::new(0.5))),\r\n                    },\r\n                    SpatialBundle {\r\n                        transform: toolbelt_transform.compute_transform(),\r\n                        ..default()\r\n                    },\r\n                    WheelAudio,\r\n                    Name::new(\"closing sound\"),\r\n                ));\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\start_menu\\src\\start_menu_plugin.rs\r\n\r\n````rust\r\nuse crate::start_menu_button_plugin::StartMenuButtonPlugin;\r\nuse bevy::prelude::*;\r\nuse cursor_hero_start_menu_types::prelude::*;\r\nuse cursor_hero_winutils::win_colors::get_accent_color;\r\n\r\npub struct StartMenuPlugin;\r\n\r\nimpl Plugin for StartMenuPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_plugins(StartMenuButtonPlugin);\r\n        app.add_systems(Update, handle_open_events);\r\n        app.add_systems(Update, handle_close_events);\r\n    }\r\n}\r\nfn handle_open_events(\r\n    mut commands: Commands,\r\n    mut start_menu_events: EventReader<StartMenuEvent>,\r\n    start_menu_button_query: Query<&Sprite, With<StartMenuButton>>,\r\n) {\r\n    for event in start_menu_events.read() {\r\n        let StartMenuEvent::Open {\r\n            start_menu_button_id,\r\n        } = event\r\n        else {\r\n            continue;\r\n        };\r\n        info!(\"Opening start menu for button {:?}\", start_menu_button_id);\r\n        let Ok(Sprite {\r\n            custom_size: Some(start_menu_button_size),\r\n            ..\r\n        }) = start_menu_button_query.get(*start_menu_button_id)\r\n        else {\r\n            warn!(\r\n                \"Couldn't find start menu button sprite for {:?}\",\r\n                start_menu_button_id\r\n            );\r\n            continue;\r\n        };\r\n        let size = Vec2::new(400.0, 400.0);\r\n        let start_menu_pos = ((size / 2.0)\r\n            + Vec2::new(\r\n                -start_menu_button_size.x / 2.0,\r\n                start_menu_button_size.y / 2.0,\r\n            ))\r\n        .extend(3.0);\r\n        commands\r\n            .entity(*start_menu_button_id)\r\n            .with_children(|parent| {\r\n                parent.spawn((\r\n                    SpriteBundle {\r\n                        sprite: Sprite {\r\n                            custom_size: Some(size),\r\n                            color: match get_accent_color() {\r\n                                Ok(color) => color,\r\n                                Err(err) => {\r\n                                    warn!(\"Couldn't get start color: {}\", err);\r\n                                    Color::rgb(0.0, 0.0, 0.0)\r\n                                }\r\n                            },\r\n                            ..default()\r\n                        },\r\n                        transform: Transform::from_translation(start_menu_pos),\r\n                        ..Default::default()\r\n                    },\r\n                    StartMenu,\r\n                ));\r\n            });\r\n    }\r\n}\r\n\r\nfn handle_close_events(\r\n    mut commands: Commands,\r\n    mut start_menu_events: EventReader<StartMenuEvent>,\r\n    start_menu_button_query: Query<&Children, With<StartMenuButton>>,\r\n    start_menu_query: Query<(), With<StartMenu>>,\r\n) {\r\n    for event in start_menu_events.read() {\r\n        let StartMenuEvent::Close {\r\n            start_menu_button_id,\r\n        } = event\r\n        else {\r\n            continue;\r\n        };\r\n        info!(\"Closing start menu for button {:?}\", start_menu_button_id);\r\n        let Ok(start_menu_button_children) = start_menu_button_query.get(*start_menu_button_id)\r\n        else {\r\n            warn!(\r\n                \"Couldn't find start menu button children for {:?}\",\r\n                start_menu_button_id\r\n            );\r\n            continue;\r\n        };\r\n        let mut removed = vec![];\r\n        for child in start_menu_button_children.iter() {\r\n            if start_menu_query.get(*child).is_ok() {\r\n                commands.entity(*child).despawn_recursive();\r\n                removed.push(*child);\r\n            }\r\n        }\r\n        commands\r\n            .entity(*start_menu_button_id)\r\n            .remove_children(&removed);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui_automation_types\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_ui_automation_types\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\nuiautomation = {workspace = true}\r\nserde = { version = \"1.0\", features = [\"derive\"] }\r\nitertools = { workspace = true }\r\nbevy-inspector-egui = { workspace = true }\r\nanyhow = {workspace = true}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui_automation_types\\src\\ui_automation_drill.rs\r\n\r\n````rust\r\nuse crate::prelude::DrillId;\r\nuse anyhow::Context;\r\nuse anyhow::Result;\r\nuse std::collections::VecDeque;\r\nuse uiautomation::UIElement;\r\nuse uiautomation::UITreeWalker;\r\n\r\n#[derive(Debug)]\r\npub enum DrillError {\r\n    UI(uiautomation::Error),\r\n    EmptyPath,\r\n    BadPath,\r\n    OutOfBounds {\r\n        given: u32,\r\n        max: u32,\r\n        error: uiautomation::Error,\r\n    },\r\n}\r\nimpl std::error::Error for DrillError {}\r\nimpl std::fmt::Display for DrillError {\r\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\r\n        match self {\r\n            DrillError::UI(e) => write!(f, \"UIAutomation error: {}\", e),\r\n            DrillError::EmptyPath => write!(f, \"Empty path\"),\r\n            DrillError::BadPath => write!(f, \"Bad path\"),\r\n            DrillError::OutOfBounds { given, max, error } => write!(\r\n                f,\r\n                \"Out of bounds: given {}, max {}, error: {}\",\r\n                given, max, error\r\n            ),\r\n        }\r\n    }\r\n}\r\nimpl From<uiautomation::Error> for DrillError {\r\n    fn from(e: uiautomation::Error) -> Self {\r\n        DrillError::UI(e)\r\n    }\r\n}\r\npub trait Drillable {\r\n    fn drill<T: Into<DrillId>>(&self, walker: &UITreeWalker, path: T) -> Result<UIElement>;\r\n}\r\nimpl Drillable for UIElement {\r\n    fn drill<T: Into<DrillId>>(&self, walker: &UITreeWalker, path: T) -> Result<UIElement> {\r\n        let drill_id: DrillId = path.into();\r\n        match drill_id {\r\n            DrillId::Child(path) => {\r\n                let mut path = path\r\n                    .into_iter()\r\n                    .map(|x| x as u32)\r\n                    .collect::<VecDeque<u32>>();\r\n                if path.iter().any(|x| (*x as i32) < 0) {\r\n                    return Err(DrillError::BadPath.into());\r\n                }\r\n                drill_inner(self, walker, &mut path)\r\n            }\r\n            DrillId::Root | DrillId::Unknown => Err(DrillError::BadPath.into()),\r\n        }\r\n    }\r\n}\r\nfn drill_inner(\r\n    start: &UIElement,\r\n    walker: &UITreeWalker,\r\n    path: &mut VecDeque<u32>,\r\n) -> Result<UIElement> {\r\n    let target_index = match path.pop_front() {\r\n        Some(x) => x,\r\n        None => return Err(DrillError::EmptyPath.into()),\r\n    };\r\n    let mut child = walker\r\n        .get_first_child(start)\r\n        .context(\"get first child of start\")?;\r\n    let mut i = 0;\r\n    while i < target_index {\r\n        i += 1;\r\n        child = match walker.get_next_sibling(&child) {\r\n            Ok(x) => x,\r\n            Err(e) => {\r\n                return Err(DrillError::OutOfBounds {\r\n                    given: i,\r\n                    max: target_index,\r\n                    error: e,\r\n                }\r\n                .into())\r\n            }\r\n        };\r\n    }\r\n    if path.is_empty() {\r\n        Ok(child)\r\n    } else {\r\n        drill_inner(&child, walker, path)\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\taskbar_tool\\src\\lib.rs\r\n\r\n````rust\r\npub mod taskbar_tool_plugin;\r\npub mod taskbar_wheel_tool;\r\n\r\npub mod prelude {\r\n    pub use crate::taskbar_tool_plugin::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\tools\\src\\keyboard_tool.rs\r\n\r\n````rust\r\nuse crate::prelude::*;\r\nuse bevy::prelude::*;\r\nuse bevy::utils::HashMap;\r\nuse bevy_inspector_egui::prelude::ReflectInspectorOptions;\r\nuse bevy_inspector_egui::InspectorOptions;\r\nuse cursor_hero_character_types::prelude::*;\r\nuse cursor_hero_math::prelude::Lerp;\r\nuse cursor_hero_sprint_tool_types::sprint_tool_types_plugin::SprintEvent;\r\nuse cursor_hero_toolbelt_types::prelude::*;\r\nuse enigo::Direction::Press;\r\nuse enigo::Direction::Release;\r\nuse enigo::*;\r\nuse itertools::Itertools;\r\nuse leafwing_input_manager::prelude::*;\r\n\r\npub struct KeyboardToolPlugin;\r\n\r\nimpl Plugin for KeyboardToolPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_plugins(InputManagerPlugin::<KeyboardToolAction>::default());\r\n        app.add_systems(\r\n            Update,\r\n            (toolbelt_events, handle_input, handle_sprint_events),\r\n        );\r\n    }\r\n}\r\n\r\n#[derive(Component, InspectorOptions, Debug, Reflect)]\r\n#[reflect(Component, InspectorOptions)]\r\nstruct KeyboardTool {\r\n    #[inspector(min = 0.0)]\r\n    repeat_delay: f32,\r\n    #[inspector(min = 0.0)]\r\n    default_repeat_delay: f32,\r\n    #[inspector(min = 0.0)]\r\n    sprint_repeat_delay: f32,\r\n}\r\nimpl Default for KeyboardTool {\r\n    fn default() -> Self {\r\n        Self {\r\n            repeat_delay: 0.1,\r\n            default_repeat_delay: 0.1,\r\n            sprint_repeat_delay: 0.001,\r\n        }\r\n    }\r\n}\r\n\r\nfn toolbelt_events(\r\n    mut commands: Commands,\r\n    asset_server: Res<AssetServer>,\r\n    mut reader: EventReader<ToolbeltPopulateEvent>,\r\n) {\r\n    for event in reader.read() {\r\n        if event.loadout != ToolbeltLoadout::Keyboard {\r\n            continue;\r\n        }\r\n        ToolSpawnConfig::<KeyboardTool, KeyboardToolAction>::new(\r\n            KeyboardTool::default(),\r\n            event.id,\r\n            event,\r\n        )\r\n        .with_src_path(file!().into())\r\n        .guess_name(file!())\r\n        .guess_image(file!(), &asset_server, \"png\")\r\n        .with_description(\"Keyboard inputs\")\r\n        .spawn(&mut commands);\r\n    }\r\n}\r\n\r\n#[derive(Actionlike, PartialEq, Eq, Clone, Copy, Hash, Debug, Reflect)]\r\nenum KeyboardToolAction {\r\n    Ctrl,\r\n    Tab,\r\n    Enter,\r\n    Backspace,\r\n    // Escape,\r\n    Shift,\r\n    Space,\r\n    Windows,\r\n    UpArrow,\r\n    DownArrow,\r\n    LeftArrow,\r\n    RightArrow,\r\n}\r\n\r\nimpl KeyboardToolAction {\r\n    fn to_enigo(self) -> Key {\r\n        match self {\r\n            Self::Ctrl => Key::Control,\r\n            Self::Tab => Key::Tab,\r\n            Self::Enter => Key::Return,\r\n            Self::Backspace => Key::Backspace,\r\n            // Self::Escape => Key::Escape,\r\n            Self::Shift => Key::Shift,\r\n            Self::Space => Key::Space,\r\n            Self::Windows => Key::Meta,\r\n            Self::UpArrow => Key::UpArrow,\r\n            Self::DownArrow => Key::DownArrow,\r\n            Self::LeftArrow => Key::LeftArrow,\r\n            Self::RightArrow => Key::RightArrow,\r\n        }\r\n    }\r\n}\r\n\r\nimpl KeyboardToolAction {\r\n    fn default_gamepad_binding(&self) -> UserInput {\r\n        match self {\r\n            Self::Ctrl => GamepadButtonType::RightTrigger.into(),\r\n            Self::Tab => GamepadButtonType::West.into(),\r\n            Self::Enter => GamepadButtonType::North.into(),\r\n            Self::Backspace => GamepadButtonType::East.into(),\r\n            // Self::Escape => GamepadButtonType::Select.into(),\r\n            Self::Shift => GamepadButtonType::LeftTrigger.into(),\r\n            Self::Space => GamepadButtonType::South.into(),\r\n            Self::Windows => GamepadButtonType::Start.into(),\r\n            Self::UpArrow => GamepadButtonType::DPadUp.into(),\r\n            Self::DownArrow => GamepadButtonType::DPadDown.into(),\r\n            Self::LeftArrow => GamepadButtonType::DPadLeft.into(),\r\n            Self::RightArrow => GamepadButtonType::DPadRight.into(),\r\n        }\r\n    }\r\n\r\n    fn default_mkb_binding(&self) -> UserInput {\r\n        match self {\r\n            Self::Ctrl => KeyCode::ControlLeft.into(),\r\n            Self::Tab => KeyCode::Tab.into(),\r\n            Self::Enter => KeyCode::Return.into(),\r\n            Self::Backspace => KeyCode::Back.into(),\r\n            // Self::Escape => KeyCode::Escape.into(),\r\n            Self::Shift => KeyCode::ShiftLeft.into(),\r\n            Self::Space => KeyCode::Space.into(),\r\n            Self::Windows => KeyCode::SuperLeft.into(),\r\n            Self::UpArrow => KeyCode::Up.into(),\r\n            Self::DownArrow => KeyCode::Down.into(),\r\n            Self::LeftArrow => KeyCode::Left.into(),\r\n            Self::RightArrow => KeyCode::Right.into(),\r\n        }\r\n    }\r\n}\r\n\r\nimpl ToolAction for KeyboardToolAction {\r\n    fn default_input_map(_event: &ToolbeltPopulateEvent) -> Option<InputMap<KeyboardToolAction>> {\r\n        let mut input_map = InputMap::default();\r\n\r\n        for variant in KeyboardToolAction::variants() {\r\n            input_map.insert(variant.default_mkb_binding(), variant);\r\n            input_map.insert(variant.default_gamepad_binding(), variant);\r\n        }\r\n        Some(input_map)\r\n    }\r\n}\r\n\r\nfn handle_input(\r\n    tool_query: Query<(Entity, &ActionState<KeyboardToolAction>, &KeyboardTool), With<ActiveTool>>,\r\n    mut enigo: Local<Option<Enigo>>,\r\n    time: Res<Time>,\r\n    mut debounce: Local<HashMap<(Entity, KeyboardToolAction), Timer>>,\r\n) {\r\n    debounce.values_mut().for_each(|timer| {\r\n        timer.tick(time.delta());\r\n    });\r\n    debounce.retain(|_, timer| !timer.finished());\r\n\r\n    if enigo.is_none() {\r\n        *enigo = Enigo::new(&Settings::default()).ok();\r\n    }\r\n    let Some(ref mut enigo) = *enigo else {\r\n        warn!(\"Failed to create enigo\");\r\n        return;\r\n    };\r\n\r\n    for tool in tool_query.iter() {\r\n        let (tool_id, tool_actions, tool) = tool;\r\n        for variant in KeyboardToolAction::variants() {\r\n            if tool_actions.pressed(variant) {\r\n                if tool_actions.just_pressed(variant) {\r\n                    info!(\"{:?} key down\", variant);\r\n                }\r\n                if (*debounce).contains_key(&(tool_id, variant)) {\r\n                    continue;\r\n                } else {\r\n                    debounce.insert(\r\n                        (tool_id, variant),\r\n                        Timer::from_seconds(tool.repeat_delay, TimerMode::Once),\r\n                    );\r\n                }\r\n                if let Err(e) = enigo.key(variant.to_enigo(), Press) {\r\n                    warn!(\"Failed to send key: {:?}\", e);\r\n                }\r\n            }\r\n            if tool_actions.just_released(variant) {\r\n                info!(\"{:?} key up\", variant);\r\n                if let Err(e) = enigo.key(variant.to_enigo(), Release) {\r\n                    warn!(\"Failed to send key: {:?}\", e);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n#[cfg(test)]\r\nmod tests {\r\n    // test that sending shift + arrow keys is highlighting text\r\n    #[test]\r\n    fn test_shift_arrow() {\r\n        use enigo::Direction::Press;\r\n        use enigo::Direction::Release;\r\n        use enigo::Enigo;\r\n        use enigo::Key;\r\n        use enigo::Keyboard;\r\n        use enigo::Settings;\r\n        use std::thread::sleep;\r\n        use std::time::Duration;\r\n\r\n        let mut enigo = Enigo::new(&Settings::default()).unwrap();\r\n\r\n        sleep(Duration::from_secs(1));\r\n        enigo.key(Key::Shift, Press).unwrap();\r\n        enigo.key(Key::Control, Press).unwrap();\r\n        enigo.key(Key::RightArrow, Press).unwrap();\r\n\r\n        enigo.key(Key::RightArrow, Release).unwrap();\r\n        enigo.key(Key::Control, Release).unwrap();\r\n        enigo.key(Key::Shift, Release).unwrap();\r\n    }\r\n}\r\n\r\nfn handle_sprint_events(\r\n    mut sprint_events: EventReader<SprintEvent>,\r\n    character_query: Query<&Children, With<Character>>,\r\n    toolbelt_query: Query<&Children, With<Toolbelt>>,\r\n    mut tool_query: Query<&mut KeyboardTool>,\r\n) {\r\n    for event in sprint_events.read() {\r\n        let character_id = match event {\r\n            SprintEvent::Active { character_id, .. } => character_id,\r\n            SprintEvent::Stop { character_id } => character_id,\r\n        };\r\n        let Ok(character) = character_query.get(*character_id) else {\r\n            warn!(\"Character {:?} does not exist\", character_id);\r\n            continue;\r\n        };\r\n        let character_kids = character;\r\n        let tool_ids = character_kids\r\n            .iter()\r\n            .filter_map(|kid| toolbelt_query.get(*kid).ok())\r\n            .flat_map(|toolbelt| toolbelt.iter())\r\n            .filter(|kid| tool_query.contains(**kid))\r\n            .cloned()\r\n            .collect_vec();\r\n\r\n        match event {\r\n            SprintEvent::Active { throttle, .. } => {\r\n                let mut iter = tool_query.iter_many_mut(&tool_ids);\r\n                while let Some(mut tool) = iter.fetch_next() {\r\n                    tool.repeat_delay =\r\n                        (tool.default_repeat_delay, tool.sprint_repeat_delay).lerp(*throttle);\r\n                }\r\n            }\r\n            SprintEvent::Stop { .. } => {\r\n                let mut iter = tool_query.iter_many_mut(&tool_ids);\r\n                while let Some(mut tool) = iter.fetch_next() {\r\n                    tool.repeat_delay = tool.default_repeat_delay;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui_hover\\src\\lib.rs\r\n\r\n````rust\r\npub mod ui_hover_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::ui_hover_plugin::*;\r\n}\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ollama\\src\\lib.rs\r\n\r\n````rust\r\npub mod ollama;\r\npub mod ollama_button_plugin;\r\npub mod ollama_inference_plugin;\r\npub mod ollama_plugin;\r\npub mod ollama_status_plugin;\r\npub mod ollama_status_worker_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::ollama_plugin::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ollama\\src\\ollama_status_plugin.rs\r\n\r\n````rust\r\nuse std::time::Duration;\r\n\r\nuse bevy::prelude::*;\r\nuse bevy::utils::Instant;\r\nuse cursor_hero_ollama_types::prelude::*;\r\n\r\npub struct OllamaStatusPlugin;\r\n\r\nimpl Plugin for OllamaStatusPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.init_resource::<OllamaStatus>();\r\n        app.add_systems(Update, handle_startup_event);\r\n        app.add_systems(Update, periodic_ping);\r\n        app.add_systems(Update, handle_pong);\r\n    }\r\n}\r\n\r\nfn handle_startup_event(\r\n    mut status_events: ParamSet<(\r\n        EventReader<OllamaStatusEvent>,\r\n        EventWriter<OllamaStatusEvent>,\r\n    )>,\r\n    mut ollama_status: ResMut<OllamaStatus>,\r\n) {\r\n    let starting = status_events\r\n        .p0()\r\n        .read()\r\n        .any(|event| matches!(event, OllamaStatusEvent::Startup));\r\n    if !starting {\r\n        return;\r\n    }\r\n    status_events.p0().clear();\r\n\r\n    *ollama_status = OllamaStatus::Starting {\r\n        instant: Instant::now(),\r\n        timeout: Duration::from_secs(60),\r\n    };\r\n    let event = OllamaStatusEvent::Changed {\r\n        new_value: *ollama_status,\r\n    };\r\n    debug!(\"Sending event {:?}\", event);\r\n    status_events.p1().send(event);\r\n}\r\n\r\nfn periodic_ping(\r\n    mut ping_events: EventWriter<OllamaPingEvent>,\r\n    mut last_ping: Local<Option<Instant>>,\r\n) {\r\n    if let Some(instant) = *last_ping {\r\n        if instant.elapsed().as_secs() > 5 {\r\n            ping_events.send(OllamaPingEvent::Ping);\r\n            *last_ping = Some(Instant::now());\r\n        }\r\n    } else {\r\n        ping_events.send(OllamaPingEvent::Ping);\r\n        *last_ping = Some(Instant::now());\r\n    }\r\n}\r\n\r\nfn handle_pong(\r\n    mut ping_events: EventReader<OllamaPingEvent>,\r\n    mut status_events: EventWriter<OllamaStatusEvent>,\r\n    mut ollama_status: ResMut<OllamaStatus>,\r\n) {\r\n    for event in ping_events.read() {\r\n        let OllamaPingEvent::Pong { status } = event else {\r\n            continue;\r\n        };\r\n        // identify the new state based on the pong\r\n        let new_status = match (*ollama_status, *status) {\r\n            // if starting, only change to dead if the timeout has been exceeded\r\n            (OllamaStatus::Starting { instant, timeout }, status) => {\r\n                if status == OllamaStatus::Alive {\r\n                    OllamaStatus::Alive\r\n                } else if instant.elapsed() > timeout {\r\n                    OllamaStatus::Dead\r\n                } else {\r\n                    OllamaStatus::Starting { instant, timeout }\r\n                }\r\n            }\r\n            // respect the new status if it's not starting\r\n            _ => *status,\r\n        };\r\n\r\n        if *ollama_status != new_status {\r\n            *ollama_status = new_status;\r\n            let event = OllamaStatusEvent::Changed {\r\n                new_value: new_status,\r\n            };\r\n            debug!(\"Sending event {:?}\", event);\r\n            status_events.send(event);\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\tools\\src\\level_bounds_visibility_tool.rs\r\n\r\n````rust\r\nuse crate::prelude::*;\r\nuse bevy::prelude::*;\r\nuse cursor_hero_level_bounds::level_bounds_plugin::LevelBounds;\r\nuse cursor_hero_toolbelt_types::prelude::*;\r\n\r\npub struct LevelBoundsVisibilityToolPlugin;\r\n\r\nimpl Plugin for LevelBoundsVisibilityToolPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<LevelBoundsVisibilityTool>();\r\n        app.add_systems(Update, toolbelt_events);\r\n        app.add_systems(Update, tick);\r\n    }\r\n}\r\n\r\n#[derive(Component, Reflect, Default)]\r\nstruct LevelBoundsVisibilityTool;\r\n\r\nfn toolbelt_events(\r\n    mut commands: Commands,\r\n    asset_server: Res<AssetServer>,\r\n    mut reader: EventReader<ToolbeltPopulateEvent>,\r\n) {\r\n    for event in reader.read() {\r\n        let ToolbeltLoadout::Default = event.loadout else {\r\n            continue;\r\n        };\r\n        ToolSpawnConfig::<LevelBoundsVisibilityTool, NoInputs>::new(\r\n            LevelBoundsVisibilityTool,\r\n            event.id,\r\n            event,\r\n        )\r\n        .with_src_path(file!().into())\r\n        .guess_name(file!())\r\n        .guess_image(file!(), &asset_server, \"png\")\r\n        .with_description(\"Shows the play area.\")\r\n        .with_starting_state(StartingState::Inactive)\r\n        .spawn(&mut commands);\r\n    }\r\n}\r\n\r\nfn tick(\r\n    mut commands: Commands,\r\n    tool_query: Query<Entity, (Added<ActiveTool>, With<LevelBoundsVisibilityTool>)>,\r\n    mut level_bounds_query: Query<&mut Visibility, With<LevelBounds>>,\r\n) {\r\n    for tool_id in tool_query.iter() {\r\n        commands.entity(tool_id).remove::<ActiveTool>();\r\n        for mut visibility in level_bounds_query.iter_mut() {\r\n            *visibility = match *visibility {\r\n                Visibility::Visible => Visibility::Hidden,\r\n                Visibility::Hidden => Visibility::Visible,\r\n                Visibility::Inherited => Visibility::Visible,\r\n            };\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\toolbelt\\src\\tool_color.rs\r\n\r\n````rust\r\nuse cursor_hero_toolbelt_types::toolbelt_types::*;\r\n\r\nuse bevy::prelude::*;\r\nuse cursor_hero_cursor_types::prelude::*;\r\n\r\nenum ToolColor {\r\n    Active,\r\n    Hovered,\r\n    HoveredActive,\r\n    Disabled,\r\n}\r\n\r\nimpl ToolColor {\r\n    fn color(&self) -> Color {\r\n        match self {\r\n            ToolColor::Active => Color::WHITE,\r\n            ToolColor::Hovered => Color::YELLOW,\r\n            ToolColor::HoveredActive => Color::ORANGE,\r\n            ToolColor::Disabled => Color::GRAY,\r\n        }\r\n    }\r\n\r\n    fn from(hovered: bool, active: bool) -> Self {\r\n        match (hovered, active) {\r\n            (true, true) => ToolColor::HoveredActive,\r\n            (true, false) => ToolColor::Hovered,\r\n            (false, true) => ToolColor::Active,\r\n            (false, false) => ToolColor::Disabled,\r\n        }\r\n    }\r\n}\r\n\r\n#[allow(clippy::type_complexity)]\r\npub fn tool_color(\r\n    mut query: Query<(&mut Sprite, Option<&Hovered>, Option<&ActiveTool>), With<Tool>>,\r\n) {\r\n    for (mut sprite, hovered, active) in query.iter_mut() {\r\n        let color = ToolColor::from(hovered.is_some(), active.is_some()).color();\r\n        sprite.color = color;\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\pressure_plate\\src\\pressure_plate_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse bevy_xpbd_2d::components::CollidingEntities;\r\n\r\npub struct PressurePlatePlugin;\r\nimpl Plugin for PressurePlatePlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Update, update_plate)\r\n            .add_event::<PressurePlateActivationEvent>()\r\n            .register_type::<PressurePlate>();\r\n    }\r\n}\r\n\r\n#[derive(Event)]\r\npub struct PressurePlateActivationEvent(pub Entity);\r\n\r\n#[derive(Component, Reflect)]\r\npub struct PressurePlate {\r\n    active_time: f32,\r\n    debounce: bool,\r\n    indicator: Entity,\r\n}\r\n\r\n#[derive(Component, Default, Reflect)]\r\npub struct PressurePlateProgressIndicator {\r\n    visual_progress: f32,\r\n}\r\n\r\nimpl PressurePlate {\r\n    pub fn new(indicator: Entity) -> Self {\r\n        Self {\r\n            active_time: 0.0,\r\n            debounce: false,\r\n            indicator,\r\n        }\r\n    }\r\n}\r\n\r\n#[allow(clippy::type_complexity)]\r\nfn update_plate(\r\n    asset_server: Res<AssetServer>,\r\n    mut commands: Commands,\r\n    time: Res<Time>,\r\n    mut query: Query<\r\n        (\r\n            Entity,\r\n            &mut PressurePlate,\r\n            &mut Sprite,\r\n            &CollidingEntities,\r\n            Option<&SpatialAudioSink>,\r\n        ),\r\n        Without<PressurePlateProgressIndicator>,\r\n    >,\r\n    mut indicator_query: Query<\r\n        (&mut PressurePlateProgressIndicator, &mut Sprite),\r\n        Without<PressurePlate>,\r\n    >,\r\n    mut activation_writer: EventWriter<PressurePlateActivationEvent>,\r\n) {\r\n    for (entity, mut plate, mut sprite, colliding_entities, sink) in &mut query {\r\n        if colliding_entities.0.is_empty() {\r\n            sprite.color = Color::rgb(0.2, 0.7, 0.9);\r\n            plate.active_time = 0.0;\r\n            sink.map(SpatialAudioSink::stop);\r\n            plate.debounce = false;\r\n        } else {\r\n            if plate.debounce {\r\n                continue;\r\n            }\r\n            sprite.color = Color::rgb(0.9, 0.7, 0.2);\r\n            if plate.active_time == 0.0 {\r\n                let bundle = AudioBundle {\r\n                    source: asset_server.load(\"sounds/pressure plate activation.ogg\"),\r\n                    settings: PlaybackSettings::REMOVE.with_spatial(true),\r\n                };\r\n                commands.entity(entity).insert(bundle);\r\n                plate.active_time += time.delta_seconds();\r\n            } else {\r\n                plate.active_time += time.delta_seconds();\r\n                if plate.active_time > cursor_hero_data::sounds::PRESSURE_PLATE_ACTIVATION_DURATION\r\n                {\r\n                    plate.active_time = 0.0;\r\n                    plate.debounce = true;\r\n                    activation_writer.send(PressurePlateActivationEvent(entity));\r\n                }\r\n            }\r\n        }\r\n        if let Ok((mut indicator, mut indicator_sprite)) = indicator_query.get_mut(plate.indicator)\r\n        {\r\n            indicator.visual_progress =\r\n                plate.active_time / cursor_hero_data::sounds::PRESSURE_PLATE_ACTIVATION_DURATION;\r\n            indicator_sprite.color = Color::rgb(0.2, 0.7, 0.9) * indicator.visual_progress;\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\toolbelt\\src\\toolbelt_opening_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse cursor_hero_toolbelt_types::toolbelt_types::*;\r\nuse leafwing_input_manager::action_state::ActionState;\r\n\r\npub struct ToolbeltOpeningPlugin;\r\n\r\nimpl Plugin for ToolbeltOpeningPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Update, opening);\r\n    }\r\n}\r\n\r\n#[allow(clippy::type_complexity)]\r\npub fn opening(\r\n    mut toolbelt_query: Query<(Entity, &mut Toolbelt, &ActionState<ToolbeltAction>), Without<Tool>>,\r\n    mut toolbelt_events: EventWriter<ToolbeltOpeningEvent>,\r\n) {\r\n    for toolbelt in toolbelt_query.iter_mut() {\r\n        let (toolbelt_id, mut toolbelt, toolbelt_actions) = toolbelt;\r\n        match (\r\n            toolbelt.open,\r\n            toolbelt_actions.pressed(ToolbeltAction::Show),\r\n        ) {\r\n            (false, true) => {\r\n                // Not open but we are holding the open button\r\n                toolbelt_events.send(ToolbeltOpeningEvent::Opened { toolbelt_id });\r\n                toolbelt.open = true;\r\n            }\r\n            (true, false) => {\r\n                // Open but we are not holding the open button\r\n                toolbelt_events.send(ToolbeltOpeningEvent::Closed { toolbelt_id });\r\n                toolbelt.open = false;\r\n            }\r\n            _ => {}\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\toolbelt_types\\src\\toolbelt_types_plugin.rs\r\n\r\n````rust\r\nuse crate::toolbelt_types::*;\r\nuse bevy::prelude::*;\r\n\r\npub struct ToolbeltTypesPlugin;\r\n\r\nimpl Plugin for ToolbeltTypesPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<Toolbelt>();\r\n        app.register_type::<Wheel>();\r\n        app.register_type::<Tool>();\r\n        app.register_type::<ActiveTool>();\r\n        app.add_event::<ToolbeltPopulateEvent>();\r\n        app.add_event::<ToolbeltOpeningEvent>();\r\n        app.add_event::<ToolActivationEvent>();\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ollama_types\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_ollama_types\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\taskbar_types\\src\\taskbar_types.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse bevy::reflect::TypePath;\r\nuse bevy::render::render_resource::AsBindGroup;\r\nuse bevy::render::render_resource::ShaderRef;\r\nuse bevy::sprite::Material2d;\r\n\r\n#[derive(Component, Debug, Reflect)]\r\npub struct AppWindow;\r\n\r\n#[derive(Component, Debug, Reflect)]\r\npub struct Taskbar {\r\n    pub size: Vec2,\r\n}\r\n\r\n#[derive(Event, Debug, Reflect)]\r\npub enum TaskbarEvent {\r\n    Populate { taskbar_id: Entity },\r\n}\r\n\r\n#[derive(Asset, TypePath, AsBindGroup, Debug, Clone)]\r\npub struct TaskbarMaterial {\r\n    #[uniform(0)]\r\n    pub taskbar_height: f32,\r\n    // pub taskbar_blur_radius: u32,\r\n    // pub taskbar_blur_total_samples: u32,\r\n    #[uniform(0)]\r\n    pub taskbar_color: Color,\r\n    #[texture(1)]\r\n    #[sampler(2)]\r\n    pub wallpaper_texture: Option<Handle<Image>>,\r\n    #[uniform(0)]\r\n    pub wallpaper_size: Vec2,\r\n    pub alpha_mode: AlphaMode,\r\n}\r\n\r\nimpl Material2d for TaskbarMaterial {\r\n    fn fragment_shader() -> ShaderRef {\r\n        \"shaders/taskbar_material.wgsl\".into()\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\tools\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_tools\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\ncursor_hero_toolbelt_types = { workspace = true }\r\ncursor_hero_input = { workspace = true }\r\ncursor_hero_bevy = { workspace = true }\r\ncursor_hero_screen = { workspace = true }\r\ncursor_hero_cursor_types = { workspace = true }\r\ncursor_hero_agent_types = { workspace = true }\r\ncursor_hero_winutils = { workspace = true }\r\ncursor_hero_camera = { workspace = true }\r\ncursor_hero_host_fs_types = { workspace = true }\r\ncursor_hero_inference_types = { workspace = true }\r\ncursor_hero_level_bounds = { workspace = true }\r\ncursor_hero_voice_to_text_types = { workspace = true }\r\ncursor_hero_environment_types = { workspace = true }\r\ncursor_hero_character_types = { workspace = true }\r\ncursor_hero_sprint_tool_types = { workspace = true }\r\ncursor_hero_data = { workspace = true }\r\ncursor_hero_math = { workspace = true }\r\ncursor_hero_movement_tool_types = { workspace = true }\r\ncursor_hero_click_drag_character_movement = { workspace = true }\r\ncursor_hero_physics = { workspace = true }\r\nbevy = { workspace = true, features=[\"webp\"] }\r\nbevy-inspector-egui = { workspace = true }\r\nbevy_xpbd_2d = { workspace = true }\r\ncrossbeam-channel = {workspace = true }\r\nitertools = {workspace = true }\r\nraw-window-handle = {workspace = true }\r\nleafwing-input-manager = { workspace = true }\r\nwindows = { workspace = true, features = [\r\n    \"Win32_Foundation\",\r\n    \"Win32_Graphics_Gdi\",\r\n    \"Win32_UI_WindowsAndMessaging\",\r\n    \"Win32_System_Com\",\r\n    \"Win32_UI_Accessibility\",\r\n    \"Win32_UI_Input_KeyboardAndMouse\",\r\n    \"Gaming_Input\",\r\n    \"Win32_Gaming\",\r\n    \"Win32_System_Threading\",\r\n] }\r\nenigo = { workspace = true }\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\text_asset\\src\\lib.rs\r\n\r\n````rust\r\npub mod text_asset_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::text_asset_plugin::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\start_menu_types\\src\\start_menu_types_plugin.rs\r\n\r\n````rust\r\nuse crate::prelude::*;\r\nuse bevy::prelude::*;\r\n\r\npub struct StartMenuTypesPlugin;\r\n\r\nimpl Plugin for StartMenuTypesPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<StartMenuButton>();\r\n\r\n        app.register_type::<StartMenu>();\r\n        app.add_event::<StartMenuEvent>();\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\pressure_plate\\src\\lib.rs\r\n\r\n````rust\r\npub mod pressure_plate_plugin;\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui\\src\\about_text_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse cursor_hero_version::version_plugin::Version;\r\n\r\npub struct AboutTextPlugin;\r\n\r\nimpl Plugin for AboutTextPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Startup, spawn_text);\r\n    }\r\n}\r\n\r\nfn spawn_text(mut commands: Commands, asset_server: Res<AssetServer>, version: Res<Version>) {\r\n    commands.spawn((\r\n        TextBundle::from_section(\r\n            format!(\"Cursor Hero v{}\\nby @TeamDman\", version.0),\r\n            TextStyle {\r\n                font: asset_server.load(\"fonts/FiraSans-Bold.ttf\"),\r\n                font_size: 16.0,\r\n                ..default()\r\n            },\r\n        )\r\n        .with_style(Style {\r\n            position_type: PositionType::Absolute,\r\n            bottom: Val::Px(5.0),\r\n            right: Val::Px(5.0),\r\n            ..default()\r\n        }),\r\n        Name::new(\"About Text\"),\r\n    ));\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\toolbelt\\src\\lib.rs\r\n\r\n````rust\r\n#![feature(let_chains)]\r\n\r\npub mod hover_frame;\r\npub mod tool_activation;\r\npub mod tool_color;\r\npub mod tool_help_activate;\r\npub mod tool_help_cleanup;\r\npub mod tool_help_click;\r\npub mod tool_help_populate;\r\npub mod tool_visibility;\r\npub mod toolbelt_circle_layout_plugin;\r\npub mod toolbelt_opening_plugin;\r\npub mod toolbelt_plugin;\r\npub mod toolbelt_properties_plugin;\r\npub mod toolbelt_taskbar_layout_plugin;\r\npub mod wheel_audio;\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\screen\\src\\lib.rs\r\n\r\n````rust\r\nuse bevy::math::IRect;\r\nuse bevy::math::IVec2;\r\nuse screenshots::display_info::DisplayInfo;\r\n\r\npub mod get_image;\r\npub mod screen_plugin;\r\npub mod screen_capture_and_update_plugin;\r\n\r\npub trait ToBevyIRect {\r\n    fn to_bevy_irect(&self) -> IRect;\r\n}\r\nimpl ToBevyIRect for DisplayInfo {\r\n    fn to_bevy_irect(&self) -> IRect {\r\n        IRect {\r\n            min: IVec2::new(self.x, self.y),\r\n            max: IVec2::new(self.x + self.width as i32, self.y + self.height as i32),\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\taskbar\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_taskbar\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\nimage = { workspace = true}\r\ncursor_hero_environment_types = { workspace = true }\r\ncursor_hero_bevy = { workspace = true }\r\ncursor_hero_cursor_types = { workspace = true }\r\ncursor_hero_screen = { workspace = true }\r\ncursor_hero_toolbelt_types = { workspace = true }\r\ncursor_hero_taskbar_types = { workspace = true }\r\ncursor_hero_tools = { workspace = true }\r\nbevy_xpbd_2d = { workspace = true }\r\ncursor_hero_winutils = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_ui\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\ncursor_hero_camera = { workspace = true }\r\ncursor_hero_character_types = { workspace = true }\r\ncursor_hero_version = { workspace = true }\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui_automation_types\\src\\lib.rs\r\n\r\n````rust\r\n#![feature(trivial_bounds)]\r\n\r\nmod calculator_ui_types;\r\nmod taskbar_ui_types;\r\nmod ui_automation_drill;\r\nmod ui_automation_error_types;\r\nmod ui_automation_types;\r\nmod ui_automation_types_plugin;\r\nmod vscode_ui_types;\r\n\r\npub mod prelude {\r\n    pub use crate::calculator_ui_types::*;\r\n    pub use crate::taskbar_ui_types::*;\r\n    pub use crate::ui_automation_drill::*;\r\n    pub use crate::ui_automation_error_types::*;\r\n    pub use crate::ui_automation_types::*;\r\n    pub use crate::ui_automation_types_plugin::*;\r\n    pub use crate::vscode_ui_types::*;\r\n    // pub use uiautomation;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\tools\\src\\tool_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n\r\nuse crate::click_tool::ClickToolPlugin;\r\nuse crate::cube_tool::CubeToolPlugin;\r\nuse crate::default_wheel_tool::DefaultWheelToolPlugin;\r\nuse crate::focus_tool::FocusToolPlugin;\r\nuse crate::keyboard_tool::KeyboardToolPlugin;\r\nuse crate::keyboard_wheel_tool::KeyboardWheelToolPlugin;\r\nuse crate::level_bounds_visibility_tool::LevelBoundsVisibilityToolPlugin;\r\n// use crate::placeholder_tool::PlaceholderToolPlugin;\r\n#[cfg(debug_assertions)]\r\nuse crate::restart_tool::RestartToolPlugin;\r\nuse crate::scroll_tool::ScrollToolPlugin;\r\nuse crate::talk_tool::TalkToolPlugin;\r\n// use crate::window_drag_tool::WindowDragToolPlugin;\r\nuse crate::zoom_tool::ZoomToolPlugin;\r\n\r\npub struct ToolPlugin;\r\nimpl Plugin for ToolPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_plugins(CubeToolPlugin);\r\n        // app.add_plugins(PlaceholderToolPlugin);\r\n        app.add_plugins(ClickToolPlugin);\r\n        app.add_plugins(ScrollToolPlugin);\r\n        app.add_plugins(TalkToolPlugin);\r\n        app.add_plugins(ZoomToolPlugin);\r\n        app.add_plugins(FocusToolPlugin);\r\n        app.add_plugins(DefaultWheelToolPlugin);\r\n        // app.add_plugins(WindowDragToolPlugin);\r\n        app.add_plugins(KeyboardToolPlugin);\r\n        app.add_plugins(KeyboardWheelToolPlugin);\r\n        app.add_plugins(LevelBoundsVisibilityToolPlugin);\r\n        #[cfg(debug_assertions)]\r\n        app.add_plugins(RestartToolPlugin);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui_automation_types\\src\\calculator_ui_types.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse serde::Deserialize;\r\nuse serde::Serialize;\r\n\r\nuse crate::prelude::ElementInfo;\r\n\r\n#[derive(Debug, Reflect, Default, Clone, Serialize, Deserialize, PartialEq)]\r\npub struct CalculatorState {\r\n    pub expression: (ElementInfo, String),\r\n    pub display: (ElementInfo, String),\r\n    pub one_button: (ElementInfo, String),\r\n    pub two_button: (ElementInfo, String),\r\n    pub three_button: (ElementInfo, String),\r\n    pub four_button: (ElementInfo, String),\r\n    pub five_button: (ElementInfo, String),\r\n    pub six_button: (ElementInfo, String),\r\n    pub seven_button: (ElementInfo, String),\r\n    pub eight_button: (ElementInfo, String),\r\n    pub nine_button: (ElementInfo, String),\r\n    pub zero_button: (ElementInfo, String),\r\n    pub add_button: (ElementInfo, String),\r\n    pub subtract_button: (ElementInfo, String),\r\n    pub multiply_button: (ElementInfo, String),\r\n    pub divide_button: (ElementInfo, String),\r\n    pub equals_button: (ElementInfo, String),\r\n    pub clear_button: (ElementInfo, String),\r\n    pub backspace_button: (ElementInfo, String),\r\n    pub memory_clear_button: (ElementInfo, String),\r\n    pub memory_recall_button: (ElementInfo, String),\r\n    pub memory_store_button: (ElementInfo, String),\r\n    pub memory_add_button: (ElementInfo, String),\r\n    pub memory_subtract_button: (ElementInfo, String),\r\n    pub period_button: (ElementInfo, String),\r\n    pub left_paren_button: (ElementInfo, String),\r\n    pub right_paren_button: (ElementInfo, String),\r\n    pub square_root_button: (ElementInfo, String),\r\n    pub factorial_button: (ElementInfo, String),\r\n    pub ln_button: (ElementInfo, String),\r\n    pub log_button: (ElementInfo, String),\r\n    pub pi_button: (ElementInfo, String),\r\n    pub e_button: (ElementInfo, String),\r\n    pub abs_button: (ElementInfo, String),\r\n    pub x_y_button: (ElementInfo, String),\r\n    pub ten_to_x_button: (ElementInfo, String),\r\n    pub square_button: (ElementInfo, String),\r\n\r\n}\r\nimpl std::fmt::Display for CalculatorState {\r\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\r\n        write!(f, \"Calculator ({}{})\", self.expression.1, self.display.1)\r\n    }\r\n}\r\n\r\n\r\n#[derive(Event, Debug, Reflect, Default)]\r\npub struct SpawnCalculatorRequest {\r\n    calculator_state: CalculatorState,\r\n}\r\n\r\n\r\n#[derive(Component, Debug, Reflect, Default, Clone, Serialize, Deserialize, PartialEq)]\r\npub struct Calculator;\r\n\r\n#[derive(Component, Debug, Reflect, Default)]\r\npub struct NumberDisplayPanel;\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\sprint_tool\\src\\sprint_tool_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse cursor_hero_character_types::prelude::*;\r\nuse cursor_hero_sprint_tool_types::sprint_tool_types_plugin::SprintEvent;\r\nuse cursor_hero_toolbelt_types::prelude::*;\r\nuse cursor_hero_tools::prelude::*;\r\nuse leafwing_input_manager::prelude::*;\r\n\r\npub struct SprintToolPlugin;\r\n\r\nimpl Plugin for SprintToolPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        // TODO: move to sprint_tool_types crate\r\n        app.register_type::<SprintTool>();\r\n        app.register_type::<SpawnedCube>();\r\n        app.add_plugins(InputManagerPlugin::<SprintToolAction>::default());\r\n        app.add_systems(Update, (toolbelt_events, handle_input));\r\n    }\r\n}\r\n\r\n#[derive(Component, Reflect, Default)]\r\nstruct SprintTool;\r\n#[derive(Actionlike, PartialEq, Eq, Clone, Copy, Hash, Debug, Reflect)]\r\nenum SprintToolAction {\r\n    Sprint,\r\n}\r\n\r\nimpl SprintToolAction {\r\n    fn default_gamepad_binding(&self) -> UserInput {\r\n        match self {\r\n            Self::Sprint => GamepadButtonType::LeftTrigger2.into(),\r\n        }\r\n    }\r\n\r\n    fn default_mkb_binding(&self) -> UserInput {\r\n        match self {\r\n            Self::Sprint => KeyCode::ShiftLeft.into(),\r\n        }\r\n    }\r\n}\r\nimpl ToolAction for SprintToolAction {\r\n    fn default_input_map(_event: &ToolbeltPopulateEvent) -> Option<InputMap<SprintToolAction>> {\r\n        let mut input_map = InputMap::default();\r\n\r\n        for variant in SprintToolAction::variants() {\r\n            input_map.insert(variant.default_mkb_binding(), variant);\r\n            input_map.insert(variant.default_gamepad_binding(), variant);\r\n        }\r\n        Some(input_map)\r\n    }\r\n}\r\n\r\nfn toolbelt_events(\r\n    mut commands: Commands,\r\n    asset_server: Res<AssetServer>,\r\n    mut reader: EventReader<ToolbeltPopulateEvent>,\r\n) {\r\n    for event in reader.read() {\r\n        let (ToolbeltLoadout::Default | ToolbeltLoadout::Keyboard) =\r\n            event.loadout\r\n        else {\r\n            continue;\r\n        };\r\n        ToolSpawnConfig::<SprintTool, SprintToolAction>::new(SprintTool, event.id, event)\r\n            .with_src_path(file!().into())\r\n            .guess_name(file!())\r\n            .guess_image(file!(), &asset_server, \"png\")\r\n            .with_description(\"Go faster, reach further\")\r\n            .spawn(&mut commands);\r\n    }\r\n}\r\n\r\n#[derive(Component, Reflect)]\r\npub struct SpawnedCube;\r\n\r\nfn handle_input(\r\n    sprint_tool_query: Query<(&ActionState<SprintToolAction>, &Parent), With<ActiveTool>>,\r\n    toolbelt_query: Query<&Parent, With<Toolbelt>>,\r\n    mut character_query: Query<Entity, With<Character>>,\r\n    mut sprint_events: EventWriter<SprintEvent>,\r\n) {\r\n    for sprint_tool in sprint_tool_query.iter() {\r\n        let (tool_actions, tool_parent) = sprint_tool;\r\n\r\n        let Ok(toolbelt) = toolbelt_query.get(tool_parent.get()) else {\r\n            warn!(\"Tool not inside a toolbelt?\");\r\n            continue;\r\n        };\r\n        let toolbelt_parent = toolbelt;\r\n        let Ok(character) = character_query.get_mut(toolbelt_parent.get()) else {\r\n            warn!(\"Toolbelt parent not a character?\");\r\n            continue;\r\n        };\r\n        let character_id = character;\r\n\r\n        if tool_actions.pressed(SprintToolAction::Sprint) {\r\n            if tool_actions.just_pressed(SprintToolAction::Sprint) {\r\n                debug!(\"Sprint tool action just pressed\");\r\n            }\r\n            let mut throttle = tool_actions.value(SprintToolAction::Sprint);\r\n            throttle = throttle.powf(2.0);\r\n            sprint_events.send(SprintEvent::Active {\r\n                character_id,\r\n                throttle,\r\n            });\r\n        } else if tool_actions.just_released(SprintToolAction::Sprint) {\r\n            debug!(\"Sprint tool action released\");\r\n            sprint_events.send(SprintEvent::Stop { character_id });\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui_hover_types\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_ui_hover_types\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\ncursor_hero_ui_automation_types = { workspace = true }\r\ncursor_hero_worker_types = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\tools\\src\\window_drag_tool.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse bevy::window::PrimaryWindow;\r\nuse bevy::winit::WinitWindows;\r\nuse bevy_inspector_egui::bevy_egui::EguiContext;\r\nuse cursor_hero_toolbelt_types::prelude::*;\r\nuse leafwing_input_manager::prelude::*;\r\n\r\nuse crate::prelude::*;\r\n\r\npub struct WindowDragToolPlugin;\r\n\r\nimpl Plugin for WindowDragToolPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<WindowDragTool>();\r\n        app.register_type::<WindowDragToolInteractable>();\r\n        app.add_plugins(InputManagerPlugin::<WindowDragToolAction>::default());\r\n        app.add_systems(Update, toolbelt_events);\r\n        app.add_systems(Update, handle_input);\r\n    }\r\n}\r\n\r\n#[derive(Component, Reflect, Default)]\r\nstruct WindowDragTool;\r\n\r\nfn toolbelt_events(\r\n    mut commands: Commands,\r\n    asset_server: Res<AssetServer>,\r\n    mut reader: EventReader<ToolbeltPopulateEvent>,\r\n) {\r\n    for event in reader.read() {\r\n        let ToolbeltLoadout::Default = event.loadout else {\r\n            continue;\r\n        };\r\n        ToolSpawnConfig::<WindowDragTool, WindowDragToolAction>::new(\r\n            WindowDragTool,\r\n            event.id,\r\n            event,\r\n        )\r\n        .with_src_path(file!().into())\r\n        .guess_name(file!())\r\n        .guess_image(file!(), &asset_server, \"png\")\r\n        .with_description(\"Drag the window from its body\")\r\n        .spawn(&mut commands);\r\n    }\r\n}\r\n\r\n#[derive(Actionlike, PartialEq, Eq, Clone, Copy, Hash, Debug, Reflect)]\r\nenum WindowDragToolAction {\r\n    Drag,\r\n}\r\n\r\nimpl WindowDragToolAction {\r\n    fn default_gamepad_binding(&self) -> UserInput {\r\n        match self {\r\n            Self::Drag => GamepadButtonType::LeftThumb.into(),\r\n        }\r\n    }\r\n\r\n    fn default_mkb_binding(&self) -> UserInput {\r\n        match self {\r\n            Self::Drag => MouseButton::Left.into(),\r\n        }\r\n    }\r\n}\r\nimpl ToolAction for WindowDragToolAction {\r\n    fn default_input_map(_event: &ToolbeltPopulateEvent) -> Option<InputMap<WindowDragToolAction>> {\r\n        let mut input_map = InputMap::default();\r\n\r\n        for variant in WindowDragToolAction::variants() {\r\n            input_map.insert(variant.default_mkb_binding(), variant);\r\n            input_map.insert(variant.default_gamepad_binding(), variant);\r\n        }\r\n        Some(input_map)\r\n    }\r\n}\r\n\r\n#[derive(Component, Reflect)]\r\npub struct WindowDragToolInteractable;\r\n\r\nfn handle_input(\r\n    tool_query: Query<&ActionState<WindowDragToolAction>, With<ActiveTool>>,\r\n    window_query: Query<Entity, With<PrimaryWindow>>,\r\n    winit_windows: NonSend<WinitWindows>,\r\n    egui_context_query: Query<&EguiContext, With<PrimaryWindow>>,\r\n) {\r\n    let Ok(egui_context) = egui_context_query.get_single() else {\r\n        return;\r\n    };\r\n    let hovering_over_egui = egui_context.clone().get_mut().is_pointer_over_area();\r\n    for action_state in tool_query.iter() {\r\n        if action_state.just_pressed(WindowDragToolAction::Drag) {\r\n            if hovering_over_egui {\r\n                continue;\r\n            }\r\n            let Ok(window_id) = window_query.get_single() else {\r\n                error!(\"No primary window found\");\r\n                return;\r\n            };\r\n            if let Some(winit_window) = winit_windows.get_window(window_id) {\r\n                // winit_window.window_state_lock\r\n                if let Err(x) = winit_window.drag_window() {\r\n                    error!(\"Failed to drag window: {:?}\", x);\r\n                }\r\n            }\r\n            return;\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ollama\\src\\ollama_button_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse bevy_xpbd_2d::prelude::*;\r\nuse cursor_hero_environment_types::prelude::*;\r\nuse cursor_hero_math::prelude::Lerp;\r\nuse cursor_hero_ollama_types::prelude::*;\r\nuse cursor_hero_cursor_types::prelude::*;\r\npub struct OllamaButtonPlugin;\r\n\r\nimpl Plugin for OllamaButtonPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Update, populate_new_host_environments);\r\n        app.add_systems(Update, update_visuals);\r\n        app.add_systems(Update, status_click_listener);\r\n        app.add_systems(Update, terminal_click_listener);\r\n        app.add_systems(Update, handle_terminal_events);\r\n    }\r\n}\r\n\r\nfn populate_new_host_environments(\r\n    mut commands: Commands,\r\n    mut environment_events: EventReader<PopulateEnvironmentEvent>,\r\n    environment_query: Query<(), With<HostEnvironment>>,\r\n    asset_server: Res<AssetServer>,\r\n) {\r\n    for event in environment_events.read() {\r\n        if !environment_query.contains(event.environment_id) {\r\n            continue;\r\n        };\r\n        let environment_id = event.environment_id;\r\n        info!(\r\n            \"Adding Ollama Server Control to new host environment {:?}\",\r\n            environment_id\r\n        );\r\n        commands.entity(environment_id).with_children(|parent| {\r\n            parent\r\n                .spawn((\r\n                    OllamaStatusButton::default(),\r\n                    Name::new(\"Ollama Server Control\"),\r\n                    SpriteBundle {\r\n                        sprite: Sprite {\r\n                            custom_size: Some(Vec2::new(200.0, 100.0)),\r\n                            color: Color::PURPLE,\r\n                            ..default()\r\n                        },\r\n                        transform: Transform::from_translation(Vec3::new(\r\n                            1920.0 / 2.0,\r\n                            -1080.0 - 200.0,\r\n                            0.0,\r\n                        )),\r\n                        ..default()\r\n                    },\r\n                    Clickable,\r\n                    Hoverable,\r\n                    RigidBody::Static,\r\n                    Sensor,\r\n                    Collider::cuboid(200.0, 100.0),\r\n                ))\r\n                .with_children(|parent| {\r\n                    parent.spawn((Text2dBundle {\r\n                        text: Text::from_section(\r\n                            \"Ollama Server Control\".to_string(),\r\n                            TextStyle {\r\n                                font: asset_server.load(\"fonts/FiraSans-Bold.ttf\"),\r\n                                font_size: 32.0,\r\n                                color: Color::WHITE,\r\n                            },\r\n                        )\r\n                        .with_alignment(TextAlignment::Center),\r\n                        transform: Transform::from_xyz(0.0, 70.0, 1.0),\r\n                        ..default()\r\n                    },));\r\n                });\r\n            parent\r\n                .spawn((\r\n                    OllamaTerminalButton::default(),\r\n                    Name::new(\"Ollama Terminal Button\"),\r\n                    SpriteBundle {\r\n                        sprite: Sprite {\r\n                            custom_size: Some(Vec2::new(200.0, 100.0)),\r\n                            color: Color::rgb(0.0, 0.6, 0.8),\r\n                            ..default()\r\n                        },\r\n                        transform: Transform::from_translation(Vec3::new(\r\n                            1920.0 / 2.0,\r\n                            -1080.0 - 350.0,\r\n                            0.0,\r\n                        )),\r\n                        ..default()\r\n                    },\r\n                    Clickable,\r\n                    Hoverable,\r\n                    RigidBody::Static,\r\n                    Sensor,\r\n                    Collider::cuboid(200.0, 100.0),\r\n                ))\r\n                .with_children(|parent| {\r\n                    parent.spawn((Text2dBundle {\r\n                        text: Text::from_section(\r\n                            \"open terminal\".to_string(),\r\n                            TextStyle {\r\n                                font: asset_server.load(\"fonts/FiraSans-Bold.ttf\"),\r\n                                font_size: 32.0,\r\n                                color: Color::WHITE,\r\n                            },\r\n                        )\r\n                        .with_alignment(TextAlignment::Center),\r\n                        transform: Transform::from_xyz(0.0, 0.0, 1.0),\r\n                        ..default()\r\n                    },));\r\n                });\r\n        });\r\n    }\r\n}\r\n\r\nfn update_visuals(\r\n    mut events: EventReader<OllamaStatusEvent>,\r\n    mut button_query: Query<(&mut Sprite, &Children, &mut OllamaStatusButton)>,\r\n    mut button_text_query: Query<&mut Text>,\r\n) {\r\n    for event in events.read() {\r\n        let OllamaStatusEvent::Changed { new_value: status } = event else {\r\n            continue;\r\n        };\r\n        debug!(\"Updating Ollama Server Control visuals to {:?}\", status);\r\n        for button in button_query.iter_mut() {\r\n            let (mut button_sprite, button_children, mut button) = button;\r\n            button.visual_state = match button.visual_state {\r\n                OllamaStatusButtonVisualState::Default { .. } => {\r\n                    OllamaStatusButtonVisualState::Default { status: *status }\r\n                }\r\n                OllamaStatusButtonVisualState::Hovered { .. } => {\r\n                    OllamaStatusButtonVisualState::Hovered { status: *status }\r\n                }\r\n                OllamaStatusButtonVisualState::Pressed { .. } => {\r\n                    OllamaStatusButtonVisualState::Pressed { status: *status }\r\n                }\r\n            };\r\n            match status {\r\n                OllamaStatus::Alive => {\r\n                    button_sprite.color = Color::GREEN;\r\n                }\r\n                OllamaStatus::Dead => {\r\n                    button_sprite.color = Color::RED;\r\n                }\r\n                OllamaStatus::Unknown => {\r\n                    button_sprite.color = Color::PURPLE;\r\n                }\r\n                OllamaStatus::Starting { instant, timeout } => {\r\n                    button_sprite.color = Color::YELLOW\r\n                        * (1.0, 0.1).lerp(instant.elapsed().as_secs_f32() / timeout.as_secs_f32());\r\n                }\r\n            }\r\n            for child in button_children.iter() {\r\n                if let Ok(mut text) = button_text_query.get_mut(*child) {\r\n                    match status {\r\n                        OllamaStatus::Alive => {\r\n                            text.sections[0].value = \"Ollama Server Control (Alive)\".to_string();\r\n                        }\r\n                        OllamaStatus::Dead => {\r\n                            text.sections[0].value = \"Ollama Server Control (Dead)\".to_string();\r\n                        }\r\n                        OllamaStatus::Unknown => {\r\n                            text.sections[0].value = \"Ollama Server Control (Unknown)\".to_string();\r\n                        }\r\n                        OllamaStatus::Starting { instant, .. } => {\r\n                            text.sections[0].value = format!(\r\n                                \"Ollama Server Control (Starting {}s ago)\",\r\n                                instant.elapsed().as_secs()\r\n                            );\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    for button in button_query.iter_mut() {\r\n        let (mut sprite, children, button) = button;\r\n        // if the visual state status is starting, update the text to show the time elapsed\r\n        let (OllamaStatusButtonVisualState::Default {\r\n            status: OllamaStatus::Starting { instant, timeout },\r\n        }\r\n        | OllamaStatusButtonVisualState::Hovered {\r\n            status: OllamaStatus::Starting { instant, timeout },\r\n        }\r\n        | OllamaStatusButtonVisualState::Pressed {\r\n            status: OllamaStatus::Starting { instant, timeout },\r\n        }) = button.visual_state\r\n        else {\r\n            continue;\r\n        };\r\n        sprite.color = Color::YELLOW\r\n            * (1.0, 0.1).lerp(instant.elapsed().as_secs_f32() / timeout.as_secs_f32());\r\n        for child in children.iter() {\r\n            if let Ok(mut text) = button_text_query.get_mut(*child) {\r\n                text.sections[0].value = format!(\r\n                    \"Ollama Server Control (Starting {}s ago)\",\r\n                    instant.elapsed().as_secs()\r\n                );\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfn status_click_listener(\r\n    mut click_events: EventReader<ClickEvent>,\r\n    button_query: Query<&OllamaStatusButton>,\r\n    mut status_events: EventWriter<OllamaStatusEvent>,\r\n) {\r\n    for event in click_events.read() {\r\n        let ClickEvent::Clicked {\r\n            target_id,\r\n            cursor_id: _,\r\n            way,\r\n        } = event\r\n        else {\r\n            continue;\r\n        };\r\n        if way != &Way::Left {\r\n            continue;\r\n        }\r\n        if let Ok(button) = button_query.get(*target_id) {\r\n            info!(\"Ollama Server Control clicked\");\r\n            // if the button visual status is alive, do nothing\r\n            match button.visual_state {\r\n                OllamaStatusButtonVisualState::Default {\r\n                    status: OllamaStatus::Alive,\r\n                }\r\n                | OllamaStatusButtonVisualState::Hovered {\r\n                    status: OllamaStatus::Alive,\r\n                }\r\n                | OllamaStatusButtonVisualState::Pressed {\r\n                    status: OllamaStatus::Alive,\r\n                } => {\r\n                    warn!(\"Ollama Server Control is already alive\");\r\n                    continue;\r\n                }\r\n                _ => {}\r\n            }\r\n            let event = OllamaStatusEvent::Startup;\r\n            debug!(\"Sending event {:?}\", event);\r\n            status_events.send(event);\r\n        }\r\n    }\r\n}\r\n\r\nfn terminal_click_listener(\r\n    mut click_events: EventReader<ClickEvent>,\r\n    button_query: Query<&OllamaTerminalButton>,\r\n    mut terminal_events: EventWriter<OllamaTerminalEvent>,\r\n) {\r\n    for event in click_events.read() {\r\n        let ClickEvent::Clicked {\r\n            target_id,\r\n            cursor_id: _,\r\n            way,\r\n        } = event\r\n        else {\r\n            continue;\r\n        };\r\n        if way != &Way::Left {\r\n            continue;\r\n        }\r\n        if button_query.get(*target_id).is_ok() {\r\n            info!(\"Ollama terminal clicked\");\r\n            let event = OllamaTerminalEvent::Startup;\r\n            debug!(\"Sending event {:?}\", event);\r\n            terminal_events.send(event);\r\n        }\r\n    }\r\n}\r\n\r\nfn handle_terminal_events(mut terminal_events: EventReader<OllamaTerminalEvent>) {\r\n    let should_start = terminal_events\r\n        .read()\r\n        .any(|event| matches!(event, OllamaTerminalEvent::Startup));\r\n    if should_start {\r\n        info!(\"Opening terminal\");\r\n        if let Err(e) = crate::ollama::start_terminal() {\r\n            error!(\"Failed to start terminal: {:?}\", e);\r\n        }\r\n    }\r\n    terminal_events.clear();\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui_automation\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_ui_automation\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\nuiautomation = { workspace = true }\r\nitertools = { workspace = true }\r\ncursor_hero_ui_automation_types = { workspace = true }\r\ncursor_hero_winutils = { workspace = true }\r\ncursor_hero_metrics = { workspace = true }\r\nwindows = { workspace = true, features = [\r\n    \"Win32_Foundation\",\r\n    \"Win32_Security\",\r\n    \"Win32_System_Com\",\r\n    \"Win32_System_Diagnostics_ToolHelp\",\r\n    \"Win32_System_ProcessStatus\",\r\n    \"Win32_System_Threading\",\r\n    \"Win32_UI_WindowsAndMessaging\",\r\n] }\r\nimage = { workspace = true }\r\nanyhow = {workspace = true}\r\n\r\n[dev-dependencies]\r\ncursor_hero_memory_types = { workspace = true }\r\ncursor_hero_memory = { workspace = true }\r\ncursor_hero_worker = { workspace = true }\r\nbevy_egui = {workspace = true}\r\nbevy-inspector-egui = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui\\src\\lib.rs\r\n\r\n````rust\r\npub mod about_text_plugin;\r\npub mod fps_text_plugin;\r\npub mod position_text_plugin;\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\toolbelt\\src\\tool_activation.rs\r\n\r\n````rust\r\nuse cursor_hero_toolbelt_types::toolbelt_types::*;\r\n\r\nuse bevy::prelude::*;\r\nuse cursor_hero_cursor_types::prelude::*;\r\n\r\nuse leafwing_input_manager::action_state::ActionState;\r\n\r\n#[allow(clippy::type_complexity)]\r\npub fn tool_activation(\r\n    mut commands: Commands,\r\n    hovered_query: Query<(Entity, Option<&ActiveTool>, Option<&Name>), With<Hovered>>,\r\n    toolbelt_query: Query<(&ActionState<ToolbeltAction>, &Children)>,\r\n    mut events: EventWriter<ToolActivationEvent>,\r\n) {\r\n    for (toolbelt_actions, toolbelt_kids) in toolbelt_query.iter() {\r\n        if toolbelt_actions.just_released(ToolbeltAction::Show) {\r\n            for (hovered_id, hovered_active, hovered_name) in toolbelt_kids\r\n                .iter()\r\n                .filter_map(|h| hovered_query.get(*h).ok())\r\n            {\r\n                if hovered_active.is_some() {\r\n                    commands.entity(hovered_id).remove::<ActiveTool>();\r\n                    events.send(ToolActivationEvent::Deactivate(hovered_id));\r\n                    info!(\"Deactivating tool: {:?} ({:?})\", hovered_name, hovered_id);\r\n                } else {\r\n                    commands.entity(hovered_id).insert(ActiveTool);\r\n                    events.send(ToolActivationEvent::Activate(hovered_id));\r\n                    info!(\"Activating tool: {:?} ({:?})\", hovered_name, hovered_id);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\tools\\src\\placeholder_tool.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse leafwing_input_manager::action_state::ActionState;\r\nuse leafwing_input_manager::input_map::InputMap;\r\nuse leafwing_input_manager::prelude::*;\r\nuse leafwing_input_manager::user_input::UserInput;\r\nuse leafwing_input_manager::Actionlike;\r\n\r\nuse cursor_hero_toolbelt_types::prelude::*;\r\n\r\nuse crate::prelude::*;\r\npub struct PlaceholderToolPlugin;\r\n\r\nimpl Plugin for PlaceholderToolPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<PlaceholderTool>();\r\n        app.add_plugins(InputManagerPlugin::<PlaceholderToolAction>::default());\r\n        app.add_systems(Update, toolbelt_events);\r\n        app.add_systems(Update, handle_input);\r\n    }\r\n}\r\n\r\n#[derive(Component, Reflect, Default)]\r\nstruct PlaceholderTool;\r\n\r\n#[derive(Actionlike, PartialEq, Eq, Clone, Copy, Hash, Debug, Reflect)]\r\nenum PlaceholderToolAction {\r\n    Action1,\r\n    Action2,\r\n    Action3,\r\n}\r\n\r\nimpl PlaceholderToolAction {\r\n    fn default_gamepad_binding(&self) -> UserInput {\r\n        match self {\r\n            Self::Action1 => GamepadButtonType::South.into(),\r\n            Self::Action2 => GamepadButtonType::East.into(),\r\n            Self::Action3 => GamepadButtonType::West.into(),\r\n        }\r\n    }\r\n\r\n    fn default_mkb_binding(&self) -> UserInput {\r\n        match self {\r\n            Self::Action1 => KeyCode::ControlLeft.into(),\r\n            Self::Action2 => KeyCode::ControlRight.into(),\r\n            Self::Action3 => KeyCode::AltRight.into(),\r\n        }\r\n    }\r\n}\r\nimpl ToolAction for PlaceholderToolAction {\r\n    fn default_input_map(\r\n        _event: &ToolbeltPopulateEvent,\r\n    ) -> Option<InputMap<PlaceholderToolAction>> {\r\n        let mut input_map = InputMap::default();\r\n\r\n        for variant in PlaceholderToolAction::variants() {\r\n            input_map.insert(variant.default_mkb_binding(), variant);\r\n            input_map.insert(variant.default_gamepad_binding(), variant);\r\n        }\r\n        Some(input_map)\r\n    }\r\n}\r\n\r\nfn toolbelt_events(\r\n    mut commands: Commands,\r\n    asset_server: Res<AssetServer>,\r\n    mut reader: EventReader<ToolbeltPopulateEvent>,\r\n) {\r\n    for event in reader.read() {\r\n        let ToolbeltLoadout::Default = event.loadout else {\r\n            continue;\r\n        };\r\n        for _ in 0..1 {\r\n            // disabled for now\r\n            ToolSpawnConfig::<PlaceholderTool, PlaceholderToolAction>::new(\r\n                PlaceholderTool,\r\n                event.id,\r\n                event,\r\n            )\r\n            .with_src_path(file!().into())\r\n            .guess_name(file!())\r\n            .guess_image(file!(), &asset_server, \"png\")\r\n            .with_description(\"Balances the wheel\")\r\n            .spawn(&mut commands);\r\n        }\r\n    }\r\n}\r\n\r\nfn handle_input(actors: Query<(&ActionState<PlaceholderToolAction>, Option<&ActiveTool>)>) {\r\n    for (action_state, active_tool_tag) in actors.iter() {\r\n        if active_tool_tag.is_none() {\r\n            continue;\r\n        }\r\n        if action_state.just_pressed(PlaceholderToolAction::Action1) {\r\n            info!(\"Just pressed Action1\");\r\n        }\r\n        if action_state.just_pressed(PlaceholderToolAction::Action2) {\r\n            info!(\"Just pressed Action2\");\r\n        }\r\n        if action_state.just_pressed(PlaceholderToolAction::Action3) {\r\n            info!(\"Just pressed Action3\");\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\toolbelt\\src\\toolbelt_circle_layout_plugin.rs\r\n\r\n````rust\r\nuse std::f32::consts::PI;\r\n\r\nuse bevy_xpbd_2d::components::Position;\r\nuse bevy_xpbd_2d::components::Rotation;\r\nuse bevy_xpbd_2d::PhysicsSet;\r\nuse cursor_hero_toolbelt_types::toolbelt_types::*;\r\n\r\nuse bevy::prelude::*;\r\nuse bevy::transform::TransformSystem;\r\nuse cursor_hero_input::update_gamepad_settings::PRESS_THRESHOLD;\r\nuse cursor_hero_cursor_types::prelude::*;\r\n\r\nuse itertools::Itertools;\r\nuse leafwing_input_manager::action_state::ActionState;\r\n\r\npub struct ToolbeltCircleLayoutPlugin;\r\n\r\nimpl Plugin for ToolbeltCircleLayoutPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Update, update_render_data);\r\n        app.add_systems(Update, reset_reach);\r\n        app.add_systems(\r\n            PostUpdate,\r\n            position_tools\r\n                .after(PhysicsSet::Sync)\r\n                .after(TransformSystem::TransformPropagate),\r\n        );\r\n    }\r\n}\r\n\r\n#[allow(clippy::type_complexity)]\r\npub fn update_render_data(\r\n    mut toolbelt_query: Query<\r\n        (\r\n            &mut Toolbelt,\r\n            &ActionState<ToolbeltAction>,\r\n            &Parent,\r\n            &Children,\r\n        ),\r\n        Without<Tool>,\r\n    >,\r\n    tool_query: Query<Entity, With<Tool>>,\r\n    mut cursor_reach_events: EventWriter<CursorReachEvent>,\r\n) {\r\n    for toolbelt in toolbelt_query.iter_mut() {\r\n        let (mut toolbelt, toolbelt_actions, toolbelt_parent, toolbelt_children) = toolbelt;\r\n        if !toolbelt.open {\r\n            continue;\r\n        }\r\n        let ToolbeltLayout::Circle { wheel, .. } = &mut toolbelt.layout else {\r\n            continue;\r\n        };\r\n        let tool_count = toolbelt_children\r\n            .iter()\r\n            .filter(|e| tool_query.get(**e).is_ok())\r\n            .count();\r\n        let open = ((toolbelt_actions.value(ToolbeltAction::Show) - PRESS_THRESHOLD)\r\n            / (1.0 - PRESS_THRESHOLD)\r\n            * 1.01)\r\n            .min(1.0);\r\n        wheel.radius = wheel.radius_start\r\n            + ((wheel.radius_end\r\n                + wheel.radius_end_bonus_per_tool_after_8\r\n                    * (tool_count as isize - 8).max(0) as f32)\r\n                - wheel.radius_start)\r\n                * open;\r\n        wheel.spin = wheel.spin_start + (wheel.spin_end - wheel.spin_start) * open;\r\n        wheel.scale = wheel.scale_start + (wheel.scale_end - wheel.scale_start) * open;\r\n        wheel.alpha = wheel.alpha_start + (wheel.alpha_end - wheel.alpha_start) * open;\r\n        cursor_reach_events.send(CursorReachEvent::SetCharacter {\r\n            character_id: toolbelt_parent.get(),\r\n            reach: wheel.radius,\r\n        });\r\n    }\r\n}\r\n\r\nfn reset_reach(\r\n    mut cursor_reach_events: EventWriter<CursorReachEvent>,\r\n    mut toolbelt_opening_events: EventReader<ToolbeltOpeningEvent>,\r\n    toolbelt_query: Query<&Parent, With<Toolbelt>>,\r\n) {\r\n    for event in toolbelt_opening_events.read() {\r\n        let ToolbeltOpeningEvent::Closed { toolbelt_id } = event else {\r\n            continue;\r\n        };\r\n        let Ok(toolbelt) = toolbelt_query.get(*toolbelt_id) else {\r\n            continue;\r\n        };\r\n        let character_id = toolbelt.get();\r\n        cursor_reach_events.send(CursorReachEvent::ResetCharacter { character_id });\r\n    }\r\n}\r\n\r\n#[allow(clippy::type_complexity)]\r\npub fn position_tools(\r\n    toolbelt_query: Query<(Ref<Toolbelt>, &Children, &Parent), Without<Tool>>,\r\n    character_query: Query<&GlobalTransform>,\r\n    mut tool_query: Query<\r\n        (&mut Transform, &mut Position, &mut Rotation, &Children),\r\n        (With<Tool>, Without<ToolHelpTrigger>),\r\n    >,\r\n    mut tool_help_query: Query<\r\n        (&mut Transform, &mut Position, &mut Rotation),\r\n        (With<ToolHelpTrigger>, Without<Tool>),\r\n    >,\r\n) {\r\n    for (toolbelt, toolbelt_kids, toolbelt_parent) in toolbelt_query.iter() {\r\n        if !toolbelt.is_changed() {\r\n            continue;\r\n        }\r\n        let ToolbeltLayout::Circle { wheel } = toolbelt.layout else {\r\n            continue;\r\n        };\r\n        if let Ok(character_position) = character_query.get(**toolbelt_parent) {\r\n            let tool_ids = toolbelt_kids\r\n                .iter()\r\n                .filter(|e| tool_query.contains(**e))\r\n                .collect_vec();\r\n            position_tools_helper(\r\n                character_position,\r\n                tool_ids,\r\n                &mut tool_query,\r\n                &mut tool_help_query,\r\n                &wheel,\r\n            );\r\n        }\r\n    }\r\n}\r\n\r\n#[allow(clippy::type_complexity)]\r\nfn position_tools_helper(\r\n    character_position: &GlobalTransform,\r\n    tool_ids: Vec<&Entity>,\r\n    tool_query: &mut Query<\r\n        (&mut Transform, &mut Position, &mut Rotation, &Children),\r\n        (With<Tool>, Without<ToolHelpTrigger>),\r\n    >,\r\n    tool_help_query: &mut Query<\r\n        (&mut Transform, &mut Position, &mut Rotation),\r\n        (With<ToolHelpTrigger>, Without<Tool>),\r\n    >,\r\n    wheel: &Wheel,\r\n) {\r\n    let count = tool_ids.len();\r\n    for (i, tool_id) in tool_ids.iter().enumerate() {\r\n        if let Ok((mut tool_transform, mut tool_position, mut tool_rotation, tool_children)) =\r\n            tool_query.get_mut(**tool_id)\r\n        {\r\n            let angle = 2.0 * PI / (count as f32) * i as f32;\r\n            let x = angle.cos();\r\n            let y = angle.sin();\r\n            tool_transform.scale = Vec2::splat(wheel.scale).extend(1.0);\r\n            let character_position = character_position.translation().xy();\r\n            tool_position.0 = character_position + Vec2::new(x * wheel.radius, y * wheel.radius);\r\n            *tool_rotation = Rotation::from_degrees(wheel.spin);\r\n            for tool_child in tool_children.iter() {\r\n                if let Ok((\r\n                    mut tool_help_transform,\r\n                    mut tool_help_position,\r\n                    mut tool_help_rotation,\r\n                )) = tool_help_query.get_mut(*tool_child)\r\n                {\r\n                    tool_help_transform.scale = Vec2::splat(wheel.scale).extend(1.0);\r\n                    tool_help_position.0 = tool_position.xy()\r\n                        + Vec2::new(x * -wheel.radius * 0.5, y * -wheel.radius * 0.5);\r\n                    *tool_help_rotation = Rotation::from_degrees(wheel.spin);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\secret_types\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_secret_types\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\nzeroize = { workspace = true }\r\nserde = { workspace = true }\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\tools\\src\\restart_tool.rs\r\n\r\n````rust\r\nuse std::os::windows::process::CommandExt;\r\nuse std::path::PathBuf;\r\n\r\nuse bevy::prelude::*;\r\nuse leafwing_input_manager::prelude::*;\r\n\r\nuse windows::Win32::System::Threading::CREATE_NEW_PROCESS_GROUP;\r\n\r\nuse cursor_hero_data::paths::CURSOR_HERO_GIT_DIR;\r\nuse cursor_hero_toolbelt_types::prelude::*;\r\n\r\nuse crate::prelude::*;\r\npub struct RestartToolPlugin;\r\n\r\nimpl Plugin for RestartToolPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<RestartTool>();\r\n        app.add_plugins(InputManagerPlugin::<RestartToolAction>::default());\r\n        app.add_systems(Update, toolbelt_events);\r\n        app.add_systems(Update, handle_input);\r\n    }\r\n}\r\n\r\n#[derive(Component, Reflect, Default)]\r\nstruct RestartTool;\r\n\r\nfn toolbelt_events(\r\n    mut commands: Commands,\r\n    asset_server: Res<AssetServer>,\r\n    mut reader: EventReader<ToolbeltPopulateEvent>,\r\n) {\r\n    for event in reader.read() {\r\n        let ToolbeltLoadout::Default = event.loadout else {\r\n            continue;\r\n        };\r\n        {\r\n            ToolSpawnConfig::<RestartTool, RestartToolAction>::new(RestartTool, event.id, event)\r\n                .with_src_path(file!().into())\r\n                .guess_name(file!())\r\n                .guess_image(file!(), &asset_server, \"png\")\r\n                .with_description(\"Send Ctrl+C, uparrow, enter\")\r\n                .spawn(&mut commands);\r\n        }\r\n    }\r\n}\r\n\r\n#[derive(Actionlike, PartialEq, Eq, Clone, Copy, Hash, Debug, Reflect)]\r\nenum RestartToolAction {\r\n    CancelAndRunPreviousTerminalCommand,\r\n}\r\n\r\nimpl RestartToolAction {\r\n    fn default_gamepad_binding(&self) -> UserInput {\r\n        match self {\r\n            Self::CancelAndRunPreviousTerminalCommand => GamepadButtonType::Start.into(),\r\n        }\r\n    }\r\n\r\n    fn default_mkb_binding(&self) -> UserInput {\r\n        match self {\r\n            Self::CancelAndRunPreviousTerminalCommand => KeyCode::Plus.into(),\r\n        }\r\n    }\r\n}\r\nimpl ToolAction for RestartToolAction {\r\n    fn default_input_map(_event: &ToolbeltPopulateEvent) -> Option<InputMap<RestartToolAction>> {\r\n        let mut input_map = InputMap::default();\r\n\r\n        for variant in RestartToolAction::variants() {\r\n            input_map.insert(variant.default_mkb_binding(), variant);\r\n            input_map.insert(variant.default_gamepad_binding(), variant);\r\n        }\r\n        Some(input_map)\r\n    }\r\n}\r\n\r\n#[allow(clippy::type_complexity)]\r\nfn handle_input(tools: Query<&ActionState<RestartToolAction>, With<ActiveTool>>) {\r\n    for t_act in tools.iter() {\r\n        if t_act.just_pressed(RestartToolAction::CancelAndRunPreviousTerminalCommand) {\r\n            // run target/release/uparrow-enter.exe\r\n\r\n            let mut path = PathBuf::from(CURSOR_HERO_GIT_DIR);\r\n            path.push(\"target/release/uparrow-enter.exe\");\r\n\r\n            // if it doesn't exist\r\n            if !path.exists() {\r\n                let mut other_project_path = PathBuf::from(CURSOR_HERO_GIT_DIR);\r\n                other_project_path.push(\"other/uparrow-enter\");\r\n                // run cargo build --release\r\n                match std::process::Command::new(\"cargo\")\r\n                    .arg(\"build\")\r\n                    .arg(\"--release\")\r\n                    .current_dir(other_project_path)\r\n                    .spawn()\r\n                {\r\n                    Ok(_) => info!(\"Successfully ran cargo build --release\"),\r\n                    Err(e) => error!(\"Failed to run cargo build --release: {}\", e),\r\n                }\r\n            }\r\n\r\n            match std::process::Command::new(path)\r\n                .creation_flags(CREATE_NEW_PROCESS_GROUP.0)\r\n                .spawn()\r\n            {\r\n                Ok(_) => info!(\"Successfully ran uparrow-enter.exe\"),\r\n                Err(e) => error!(\"Failed to run uparrow-enter.exe: {}\", e),\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\secret_types\\src\\secrets_types.rs\r\n\r\n````rust\r\nuse std::fmt::Debug;\r\nuse zeroize::Zeroize;\r\n\r\nuse serde::Deserialize;\r\nuse serde::Serialize;\r\n\r\n// shout out to the secrecy crate\r\n// ran into some issues with reflect so had to roll my own tho\r\n// https://github.com/iqlusioninc/crates/issues/632\r\n\r\nuse bevy::prelude::*;\r\n\r\n#[derive(Reflect, Clone, Default, Eq, PartialEq, Serialize, Deserialize)]\r\npub struct SecretString {\r\n    inner: String,\r\n}\r\n\r\nimpl SecretString {\r\n    pub fn new(secret: String) -> Self {\r\n        SecretString { inner: secret }\r\n    }\r\n    pub fn expose_secret(&self) -> &String {\r\n        &self.inner\r\n    }\r\n}\r\n\r\nimpl Debug for SecretString {\r\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\r\n        write!(\r\n            f,\r\n            \"{}\",\r\n            match self.inner.len() {\r\n                0 => \"<empty>\",\r\n                _ => \"<redacted>\",\r\n            }\r\n        )\r\n    }\r\n}\r\nimpl Drop for SecretString {\r\n    fn drop(&mut self) {\r\n        self.inner.zeroize();\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\secret\\src\\lib.rs\r\n\r\n````rust\r\npub mod secrets_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::secrets_plugin::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\tools\\src\\focus_tool.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse bevy::window::PrimaryWindow;\r\nuse bevy::window::RawHandleWrapper;\r\nuse cursor_hero_camera::camera_plugin::FollowWithMainCamera;\r\nuse cursor_hero_camera::camera_plugin::MainCamera;\r\nuse cursor_hero_winutils::win_mouse::set_cursor_position;\r\nuse cursor_hero_winutils::win_window::get_window_title_bar_center_position;\r\nuse leafwing_input_manager::prelude::*;\r\n\r\nuse cursor_hero_camera::camera_plugin::CameraEvent;\r\nuse cursor_hero_character_types::prelude::*;\r\nuse cursor_hero_winutils::win_window::focus_window;\r\n\r\nuse cursor_hero_toolbelt_types::prelude::*;\r\n\r\nuse crate::prelude::*;\r\nuse cursor_hero_movement_tool_types::prelude::*;\r\n\r\npub struct FocusToolPlugin;\r\n\r\nimpl Plugin for FocusToolPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<FocusTool>();\r\n        app.add_plugins(InputManagerPlugin::<FocusToolAction>::default());\r\n        app.add_systems(Update, toolbelt_events);\r\n        app.add_systems(Update, handle_input);\r\n    }\r\n}\r\n#[derive(Component, Reflect, Default)]\r\nstruct FocusTool;\r\n\r\nfn toolbelt_events(\r\n    mut commands: Commands,\r\n    asset_server: Res<AssetServer>,\r\n    mut reader: EventReader<ToolbeltPopulateEvent>,\r\n) {\r\n    for event in reader.read() {\r\n        let ToolbeltLoadout::Default = event.loadout else {\r\n            continue;\r\n        };\r\n        {\r\n            ToolSpawnConfig::<FocusTool, FocusToolAction>::new(FocusTool, event.id, event)\r\n                .with_src_path(file!().into())\r\n                .guess_name(file!())\r\n                .guess_image(file!(), &asset_server, \"png\")\r\n                .with_description(\"Camera follows the character\")\r\n                .spawn(&mut commands);\r\n        }\r\n    }\r\n}\r\n\r\n#[derive(Actionlike, PartialEq, Eq, Clone, Copy, Hash, Debug, Reflect)]\r\nenum FocusToolAction {\r\n    ToggleFollowCharacter,\r\n    FocusMainWindow,\r\n}\r\n// TODO: add an action to focus the character without teleporting it to the camera.\r\n\r\nimpl FocusToolAction {\r\n    fn default_gamepad_binding(&self) -> UserInput {\r\n        match self {\r\n            Self::ToggleFollowCharacter => GamepadButtonType::LeftThumb.into(),\r\n            Self::FocusMainWindow => GamepadButtonType::RightThumb.into(),\r\n        }\r\n    }\r\n\r\n    fn default_mkb_binding(&self) -> UserInput {\r\n        match self {\r\n            Self::ToggleFollowCharacter => KeyCode::Space.into(),\r\n            Self::FocusMainWindow => KeyCode::Home.into(),\r\n        }\r\n    }\r\n}\r\nimpl ToolAction for FocusToolAction {\r\n    fn default_input_map(_event: &ToolbeltPopulateEvent) -> Option<InputMap<FocusToolAction>> {\r\n        let mut input_map = InputMap::default();\r\n\r\n        for variant in FocusToolAction::variants() {\r\n            input_map.insert(variant.default_mkb_binding(), variant);\r\n            input_map.insert(variant.default_gamepad_binding(), variant);\r\n        }\r\n        Some(input_map)\r\n    }\r\n}\r\n\r\n#[allow(clippy::type_complexity)]\r\n#[allow(clippy::too_many_arguments)]\r\nfn handle_input(\r\n    focus_tool_query: Query<(&ActionState<FocusToolAction>, &Parent), With<ActiveTool>>,\r\n    movement_tool_query: Query<Entity, With<MovementTool>>,\r\n    toolbelt_query: Query<(&Parent, &Children), With<Toolbelt>>,\r\n    mut character_query: Query<\r\n        (Entity, &mut Transform, Option<&FollowWithMainCamera>),\r\n        (With<Character>, Without<MainCamera>),\r\n    >,\r\n    camera_query: Query<(Entity, &Transform), (With<MainCamera>, Without<Character>)>,\r\n    window_query: Query<&RawHandleWrapper, With<PrimaryWindow>>,\r\n    mut camera_events: EventWriter<CameraEvent>,\r\n    mut movement_target_events: EventWriter<MovementTargetEvent>,\r\n) {\r\n    for tool in focus_tool_query.iter() {\r\n        let (tool_actions, tool_parent) = tool;\r\n\r\n        if tool_actions.just_pressed(FocusToolAction::ToggleFollowCharacter) {\r\n            info!(\"Toggle follow character\");\r\n            let Ok(toolbelt) = toolbelt_query.get(tool_parent.get()) else {\r\n                warn!(\"Toolbelt should have a parent\");\r\n                continue;\r\n            };\r\n\r\n            let (toolbelt_parent, toolbelt_children) = toolbelt;\r\n            let movement_tool_ids = toolbelt_children\r\n                .iter()\r\n                .filter_map(|child| movement_tool_query.get(*child).ok());\r\n\r\n            let Ok(character) = character_query.get_mut(toolbelt_parent.get()) else {\r\n                warn!(\"Toolbelt should have a character\");\r\n                continue;\r\n            };\r\n            let (character_id, mut character_transform, character_is_followed) = character;\r\n\r\n            let camera = camera_query.single();\r\n            let (camera_id, camera_transform) = camera;\r\n            if character_is_followed.is_none() {\r\n                camera_events.send(CameraEvent::BeginFollowing {\r\n                    target_id: character_id,\r\n                });\r\n                movement_tool_ids.for_each(|id| {\r\n                    movement_target_events.send(MovementTargetEvent::SetTarget {\r\n                        tool_id: id,\r\n                        target: MovementTarget::Character,\r\n                    });\r\n                });\r\n                info!(\"Sent follow events\");\r\n                info!(\"Updating character to be at camera position\");\r\n                character_transform.translation = camera_transform.translation;\r\n            } else {\r\n                camera_events.send(CameraEvent::StopFollowing {\r\n                    target_id: character_id,\r\n                });\r\n                movement_tool_ids.for_each(|id| {\r\n                    movement_target_events.send(MovementTargetEvent::SetTarget {\r\n                        tool_id: id,\r\n                        target: MovementTarget::Camera(camera_id),\r\n                    });\r\n                });\r\n                info!(\"Sent unfollow events\");\r\n            }\r\n        }\r\n        if tool_actions.just_pressed(FocusToolAction::FocusMainWindow) {\r\n            info!(\"Focus main window\");\r\n            let Ok(window_handle) = window_query.get_single() else {\r\n                error!(\"No primary window found\");\r\n                return;\r\n            };\r\n            let win32handle = match window_handle.window_handle {\r\n                raw_window_handle::RawWindowHandle::Win32(handle) => handle,\r\n                _ => panic!(\"Unsupported window handle\"),\r\n            };\r\n            focus_window(win32handle.hwnd as isize);\r\n            if let Ok(position) = get_window_title_bar_center_position(win32handle.hwnd as isize) {\r\n                match set_cursor_position(position) {\r\n                    Ok(_) => info!(\"Moved cursor to window title bar\"),\r\n                    Err(e) => error!(\"Failed to move cursor to window title bar: {:?}\", e),\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui_automation\\src\\gather_root_children.rs\r\n\r\n````rust\r\nuse std::collections::VecDeque;\r\n\r\nuse uiautomation::UIAutomation;\r\nuse uiautomation::UIElement;\r\nuse uiautomation::UITreeWalker;\r\n\r\nuse crate::gather_children::gather_children;\r\nuse crate::gather_children::StopBehaviour;\r\n\r\npub fn gather_root_children(\r\n    automation: &UIAutomation,\r\n    walker: &UITreeWalker,\r\n) -> Result<VecDeque<UIElement>, uiautomation::Error> {\r\n    let root = automation.get_root_element()?;\r\n    // println!(\"Boutta gather top level children\");\r\n    let top_level_children = gather_children(walker, &root, &StopBehaviour::RootEndEncountered);\r\n    // let condition = &automation.create_true_condition()?;\r\n    // let found = root.find_all(TreeScope::Children, condition)?;\r\n    // println!(\"Found {} top level children\", top_level_children.len());\r\n    Ok(top_level_children)\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n    use uiautomation::UIAutomation;\r\n\r\n    #[test]\r\n    fn test_gather_root_children() {\r\n        let automation = UIAutomation::new().unwrap();\r\n        let walker = automation.create_tree_walker().unwrap();\r\n        for _ in 0..100 {\r\n            let start = std::time::Instant::now();\r\n            let children = gather_root_children(&automation, &walker).unwrap();\r\n            let end = std::time::Instant::now();\r\n            let elapsed = end - start;\r\n            println!(\"Gathered {} children in {:?}\", children.len(), elapsed);\r\n            assert!(!children.is_empty());\r\n            assert!(elapsed.as_millis() < 1000);\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\taskbar\\src\\taskbar_spawn_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse bevy::sprite::MaterialMesh2dBundle;\r\nuse cursor_hero_screen::screen_plugin::GameScreen;\r\nuse cursor_hero_taskbar_types::prelude::*;\r\nuse cursor_hero_winutils::win_colors::get_start_color;\r\n\r\npub struct TaskbarSpawnPlugin;\r\n\r\nimpl Plugin for TaskbarSpawnPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Update, spawn_taskbar);\r\n        app.add_systems(Update, populate_taskbar);\r\n    }\r\n}\r\n\r\nfn spawn_taskbar(\r\n    mut commands: Commands,\r\n    screen_query: Query<(Entity, &Sprite), Added<GameScreen>>,\r\n    mut materials: ResMut<Assets<TaskbarMaterial>>,\r\n    mut meshes: ResMut<Assets<Mesh>>,\r\n    asset_server: Res<AssetServer>,\r\n) {\r\n    for screen in screen_query.iter() {\r\n        let (screen_id, screen_sprite) = screen;\r\n        let Some(screen_size) = screen_sprite.custom_size else {\r\n            warn!(\"Screen {:?} has no custom size\", screen_id);\r\n            continue;\r\n        };\r\n        // let taskbar_size = Vec3::new(screen_size.x, 40.0, 1.0);\r\n        let taskbar_size = Vec3::new(screen_size.x, 40.0, 1.0);\r\n        let taskbar_translation = Vec3::new(0.0, -screen_size.y / 2.0 + taskbar_size.y / 2.0, 5.0);\r\n\r\n        let taskbar_color = match get_start_color() {\r\n            Ok(color) => color,\r\n            Err(err) => {\r\n                warn!(\"Couldn't get accent color: {:?}\", err);\r\n                Color::rgba(0.0, 0.0, 0.0, 1.0)\r\n            }\r\n        };\r\n        // color *= Vec3::new(1.0 / 2.5, 2.0, 0.5);\r\n        // color.set_a(0.9);\r\n        // let taskbar_blur_radius = 5;\r\n        // let taskbar_blur_total_samples = ((taskbar_blur_radius * 2 + 1) * (taskbar_blur_radius * 2 + 1));\r\n        commands.entity(screen_id).with_children(|parent| {\r\n            parent.spawn((\r\n                Taskbar {\r\n                    size: taskbar_size.xy(),\r\n                },\r\n                Name::new(\"Taskbar\"),\r\n                // SpriteBundle {\r\n                //     sprite: Sprite {\r\n                //         custom_size: Some(taskbar_size.xy()),\r\n                //         color,\r\n                //         ..default()\r\n                //     },\r\n                //     transform: Transform::from_translation(taskbar_translation),\r\n                //     ..default()\r\n                // },\r\n                MaterialMesh2dBundle {\r\n                    mesh: meshes.add(Mesh::from(shape::Cube::default())).into(),\r\n                    transform: Transform::from_translation(taskbar_translation)\r\n                        .with_scale(taskbar_size),\r\n                    material: materials.add(TaskbarMaterial {\r\n                        // taskbar_blur_radius,\r\n                        // taskbar_blur_total_samples,\r\n                        taskbar_height: taskbar_size.y,\r\n                        taskbar_color,\r\n                        wallpaper_size: screen_size.xy(),\r\n                        wallpaper_texture: Some(\r\n                            asset_server.load(\"textures/environment/game/wallpaper.png\"),\r\n                        ),\r\n                        alpha_mode: AlphaMode::Opaque,\r\n                    }),\r\n                    ..default()\r\n                },\r\n            ));\r\n        });\r\n    }\r\n}\r\n\r\nfn populate_taskbar(\r\n    taskbar_query: Query<Entity, Added<Taskbar>>,\r\n    mut taskbar_events: EventWriter<TaskbarEvent>,\r\n) {\r\n    for taskbar_id in taskbar_query.iter() {\r\n        let event = TaskbarEvent::Populate { taskbar_id };\r\n        debug!(\"Sending taskbar event: {:?}\", event);\r\n        taskbar_events.send(event);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui\\src\\fps_text_plugin.rs\r\n\r\n````rust\r\nuse bevy::diagnostic::DiagnosticsStore;\r\nuse bevy::diagnostic::FrameTimeDiagnosticsPlugin;\r\nuse bevy::prelude::*;\r\npub struct FpsTextPlugin;\r\nimpl Plugin for FpsTextPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Startup, setup);\r\n        app.add_systems(Update, update_fps_text);\r\n    }\r\n}\r\n\r\n#[derive(Component)]\r\nstruct FpsText;\r\n\r\nfn setup(mut commands: Commands) {\r\n    commands.spawn((\r\n        TextBundle::from_section(\r\n            \"FPS: \",\r\n            TextStyle {\r\n                font: default(),\r\n                font_size: 20.0,\r\n                color: Color::TOMATO,\r\n            },\r\n        )\r\n        .with_style(Style {\r\n            position_type: PositionType::Absolute,\r\n            top: Val::Px(5.0),\r\n            left: Val::Px(5.0),\r\n            ..default()\r\n        }),\r\n        FpsText,\r\n    ));\r\n}\r\n\r\nfn update_fps_text(diagnostics: Res<DiagnosticsStore>, mut query: Query<&mut Text, With<FpsText>>) {\r\n    for mut text in &mut query {\r\n        if let Some(fps) = diagnostics.get(FrameTimeDiagnosticsPlugin::FPS) {\r\n            if let Some(value) = fps.smoothed() {\r\n                // Update the value of the second section\r\n                text.sections[0].value = format!(\"FPS: {value:.2}\");\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\sprint_tool_types\\src\\lib.rs\r\n\r\n````rust\r\npub mod sprint_tool_types_plugin;\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\plugins\\src\\lib.rs\r\n\r\n````rust\r\nmod default_launch_mode_plugin;\r\nmod inspect_launch_mode_plugin;\r\npub mod prelude {\r\n    pub use crate::default_launch_mode_plugin::DefaultLaunchModePlugin;\r\n    pub use crate::inspect_launch_mode_plugin::HeadlessLaunchModePlugin;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\toolbelt\\src\\tool_visibility.rs\r\n\r\n````rust\r\nuse cursor_hero_toolbelt_types::toolbelt_types::*;\r\n\r\nuse bevy::prelude::*;\r\nuse leafwing_input_manager::action_state::ActionState;\r\n\r\n#[allow(clippy::type_complexity)]\r\npub fn tool_visibility(\r\n    mut toolbelts: Query<\r\n        (&ActionState<ToolbeltAction>, &mut Wheel, &Children),\r\n        (Without<Tool>, With<Toolbelt>),\r\n    >,\r\n    mut tool_query: Query<(Entity, &mut Transform, &mut Visibility, &mut Sprite), With<Tool>>,\r\n) {\r\n    for (toolbelt_actions, wheel, toolbelt_kids) in toolbelts.iter_mut() {\r\n        if toolbelt_actions.just_pressed(ToolbeltAction::Show) {\r\n            debug!(\"Updating toolbelt visibility => visible\");\r\n            for child_id in toolbelt_kids.iter() {\r\n                if let Ok((_, _, mut tool_visibility, _)) = tool_query.get_mut(*child_id) {\r\n                    *tool_visibility = Visibility::Visible;\r\n                }\r\n            }\r\n        } else if toolbelt_actions.just_released(ToolbeltAction::Show) {\r\n            debug!(\"Updating toolbelt visibility => hidden\");\r\n            for child_id in toolbelt_kids.iter() {\r\n                if let Ok((_, _, mut tool_visibility, _)) = tool_query.get_mut(*child_id) {\r\n                    *tool_visibility = Visibility::Hidden;\r\n                }\r\n            }\r\n        }\r\n        if wheel.open {\r\n            for child_id in toolbelt_kids.iter() {\r\n                if let Ok((_, _, _, mut tool_sprite)) = tool_query.get_mut(*child_id) {\r\n                    tool_sprite.color = tool_sprite.color.with_a(wheel.alpha);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\start_menu\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_start_menu\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\ncursor_hero_start_menu_types = { workspace = true }\r\ncursor_hero_winutils = { workspace = true }\r\ncursor_hero_taskbar_types = { workspace = true }\r\ncursor_hero_cursor_types = { workspace = true }\r\nbevy_xpbd_2d = { workspace = true }\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui_automation_types\\src\\ui_automation_error_types.rs\r\n\r\n````rust\r\nuse crate::prelude::VSCodeResolveError;\r\nuse crate::ui_automation_drill::DrillError;\r\nuse std::fmt;\r\n\r\n#[derive(Debug)]\r\npub enum AppResolveError {\r\n    UI(uiautomation::Error),\r\n    BadStructure(String),\r\n}\r\nimpl From<uiautomation::Error> for AppResolveError {\r\n    fn from(e: uiautomation::Error) -> Self {\r\n        AppResolveError::UI(e)\r\n    }\r\n}\r\nimpl From<DrillError> for AppResolveError {\r\n    fn from(e: DrillError) -> Self {\r\n        match e {\r\n            DrillError::UI(e) => AppResolveError::UI(e),\r\n            DrillError::EmptyPath => AppResolveError::BadStructure(\"Empty path\".to_string()),\r\n            DrillError::BadPath => AppResolveError::BadStructure(\"Bad path\".to_string()),\r\n            DrillError::OutOfBounds {\r\n                given,\r\n                max,\r\n                error: e,\r\n            } => AppResolveError::BadStructure(format!(\r\n                \"Out of bounds: given: {}, max: {}, error: {}\",\r\n                given, max, e\r\n            )),\r\n        }\r\n    }\r\n}\r\nimpl From<VSCodeResolveError> for AppResolveError {\r\n    fn from(e: VSCodeResolveError) -> Self {\r\n        match e {\r\n            VSCodeResolveError::UnknownSideTabKind(s) => {\r\n                AppResolveError::BadStructure(format!(\"Unknown VSCode side tab kind: {}\", s))\r\n            }\r\n            VSCodeResolveError::UnknownState { kids } => {\r\n                AppResolveError::BadStructure(format!(\"Unknown VSCode state, kids: {:?}\", kids))\r\n            }\r\n            VSCodeResolveError::UI(e) => AppResolveError::UI(e),\r\n        }\r\n    }\r\n}\r\n\r\nimpl fmt::Display for AppResolveError {\r\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\r\n        // Write a descriptive message for the error.\r\n        write!(f, \"{:?}\", self)\r\n    }\r\n}\r\nimpl std::error::Error for AppResolveError {}\r\n\r\n#[derive(Debug)]\r\npub enum GatherAppsError {\r\n    UI(uiautomation::Error),\r\n    NoneMatch,\r\n    ResolveFailed(Vec<anyhow::Error>),\r\n}\r\nimpl From<uiautomation::Error> for GatherAppsError {\r\n    fn from(e: uiautomation::Error) -> Self {\r\n        GatherAppsError::UI(e)\r\n    }\r\n}\r\n\r\nimpl fmt::Display for GatherAppsError {\r\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\r\n        // Write a descriptive message for the error.\r\n        write!(f, \"{:?}\", self)\r\n    }\r\n}\r\nimpl std::error::Error for GatherAppsError {}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\tools\\src\\click_tool.rs\r\n\r\n````rust\r\nuse std::thread;\r\n\r\nuse bevy::audio::Volume;\r\nuse bevy::audio::VolumeLevel;\r\nuse bevy::prelude::*;\r\nuse bevy::window::PrimaryWindow;\r\nuse bevy_inspector_egui::bevy_egui::EguiContext;\r\nuse cursor_hero_cursor_types::prelude::*;\r\n\r\nuse leafwing_input_manager::prelude::*;\r\n\r\nuse crossbeam_channel::bounded;\r\nuse crossbeam_channel::Sender;\r\nuse cursor_hero_character_types::prelude::*;\r\n\r\nuse cursor_hero_winutils::win_mouse::left_mouse_down;\r\nuse cursor_hero_winutils::win_mouse::left_mouse_up;\r\nuse cursor_hero_winutils::win_mouse::right_mouse_down;\r\nuse cursor_hero_winutils::win_mouse::right_mouse_up;\r\n\r\nuse cursor_hero_toolbelt_types::prelude::*;\r\n\r\nuse crate::prelude::*;\r\n\r\npub struct ClickToolPlugin;\r\n\r\nimpl Plugin for ClickToolPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<ClickTool>();\r\n        app.add_plugins(InputManagerPlugin::<ClickToolAction>::default());\r\n        app.add_systems(Startup, spawn_worker_thread);\r\n        app.add_systems(Update, (toolbelt_events, handle_input));\r\n    }\r\n}\r\n\r\n#[derive(Component, Reflect, Default)]\r\nstruct ClickTool;\r\n\r\nfn toolbelt_events(\r\n    mut commands: Commands,\r\n    asset_server: Res<AssetServer>,\r\n    mut reader: EventReader<ToolbeltPopulateEvent>,\r\n) {\r\n    for event in reader.read() {\r\n        if let ToolbeltLoadout::Default | ToolbeltLoadout::Keyboard = event.loadout {\r\n            ToolSpawnConfig::<ClickTool, ClickToolAction>::new(ClickTool, event.id, event)\r\n                .with_src_path(file!().into())\r\n                .guess_name(file!())\r\n                .guess_image(file!(), &asset_server, \"png\")\r\n                .with_description(\"Send mouse clicks\")\r\n                .spawn(&mut commands);\r\n        }\r\n    }\r\n}\r\n\r\n#[derive(Actionlike, PartialEq, Eq, Clone, Copy, Hash, Debug, Reflect)]\r\nenum ClickToolAction {\r\n    LeftClick,\r\n    RightClick,\r\n}\r\nimpl ClickToolAction {\r\n    fn get_audio_path(&self, motion: Motion) -> &'static str {\r\n        match (self, motion) {\r\n            (Self::LeftClick, Motion::Down) => \"sounds/mouse1down.ogg\",\r\n            (Self::LeftClick, Motion::Up) => \"sounds/mouse1up.ogg\",\r\n            (Self::RightClick, Motion::Down) => \"sounds/mouse2down.ogg\",\r\n            (Self::RightClick, Motion::Up) => \"sounds/mouse2up.ogg\",\r\n        }\r\n    }\r\n    fn get_thread_message(&self, motion: Motion) -> ClickThreadMessage {\r\n        match (self, motion) {\r\n            (Self::LeftClick, Motion::Down) => ClickThreadMessage::LeftMouse(Motion::Down),\r\n            (Self::LeftClick, Motion::Up) => ClickThreadMessage::LeftMouse(Motion::Up),\r\n            (Self::RightClick, Motion::Down) => ClickThreadMessage::RightMouse(Motion::Down),\r\n            (Self::RightClick, Motion::Up) => ClickThreadMessage::RightMouse(Motion::Up),\r\n        }\r\n    }\r\n}\r\nimpl From<ClickToolAction> for Way {\r\n    fn from(action: ClickToolAction) -> Self {\r\n        match action {\r\n            ClickToolAction::LeftClick => Way::Left,\r\n            ClickToolAction::RightClick => Way::Right,\r\n        }\r\n    }\r\n}\r\n\r\n#[derive(Debug)]\r\nenum Motion {\r\n    Up,\r\n    Down,\r\n}\r\n\r\n#[derive(Debug)]\r\nenum ClickThreadMessage {\r\n    LeftMouse(Motion),\r\n    RightMouse(Motion),\r\n}\r\n\r\n#[derive(Resource)]\r\nstruct ClickBridge {\r\n    pub sender: Sender<(ClickThreadMessage, i32, i32)>,\r\n}\r\n\r\nimpl ClickToolAction {\r\n    fn default_wheel_gamepad_binding(&self) -> UserInput {\r\n        match self {\r\n            Self::LeftClick => GamepadButtonType::RightTrigger.into(),\r\n            Self::RightClick => GamepadButtonType::LeftTrigger.into(),\r\n        }\r\n    }\r\n\r\n    fn default_wheel_keyboard_binding(&self) -> UserInput {\r\n        match self {\r\n            Self::LeftClick => MouseButton::Left.into(),\r\n            Self::RightClick => MouseButton::Right.into(),\r\n        }\r\n    }\r\n    fn keyboard_wheel_gamepad_binding(&self) -> UserInput {\r\n        match self {\r\n            Self::LeftClick => GamepadButtonType::RightThumb.into(),\r\n            Self::RightClick => GamepadButtonType::LeftThumb.into(),\r\n        }\r\n    }\r\n\r\n    fn keyboard_wheel_keyboard_binding(&self) -> UserInput {\r\n        match self {\r\n            Self::LeftClick => MouseButton::Left.into(),\r\n            Self::RightClick => MouseButton::Right.into(),\r\n        }\r\n    }\r\n}\r\n\r\nimpl ToolAction for ClickToolAction {\r\n    fn default_input_map(event: &ToolbeltPopulateEvent) -> Option<InputMap<ClickToolAction>> {\r\n        match event.loadout {\r\n            ToolbeltLoadout::Default => Some(Self::with_defaults(\r\n                Self::default_wheel_gamepad_binding,\r\n                Self::default_wheel_keyboard_binding,\r\n            )),\r\n            ToolbeltLoadout::Keyboard => Some(Self::with_defaults(\r\n                Self::keyboard_wheel_gamepad_binding,\r\n                Self::keyboard_wheel_keyboard_binding,\r\n            )),\r\n            _ => None,\r\n        }\r\n    }\r\n}\r\n\r\nfn spawn_worker_thread(mut commands: Commands) {\r\n    let (tx, rx) = bounded::<_>(10);\r\n    commands.insert_resource(ClickBridge { sender: tx });\r\n    thread::spawn(move || loop {\r\n        let (action, x, y) = match rx.recv() {\r\n            Ok(v) => v,\r\n            Err(e) => {\r\n                error!(\"Failed to receive thread message, exiting: {:?}\", e);\r\n                break;\r\n            }\r\n        };\r\n        debug!(\"Worker received click: {:?} {} {}\", action, x, y);\r\n        match match action {\r\n            ClickThreadMessage::LeftMouse(Motion::Down) => left_mouse_down(),\r\n            ClickThreadMessage::LeftMouse(Motion::Up) => left_mouse_up(),\r\n            ClickThreadMessage::RightMouse(Motion::Down) => right_mouse_down(),\r\n            ClickThreadMessage::RightMouse(Motion::Up) => right_mouse_up(),\r\n        } {\r\n            Ok(_) => {}\r\n            Err(e) => {\r\n                error!(\"Failed to handle event {:?}: {:?}\", action, e);\r\n            }\r\n        }\r\n    });\r\n}\r\n\r\n#[allow(clippy::too_many_arguments)]\r\n#[allow(clippy::type_complexity)]\r\nfn handle_input(\r\n    mut commands: Commands,\r\n    tools: Query<(&ActionState<ClickToolAction>, &Parent), (With<ActiveTool>, With<ClickTool>)>,\r\n    toolbelts: Query<&Parent, With<Toolbelt>>,\r\n    characters: Query<&Children, With<Character>>,\r\n    cursors: Query<(Entity, &GlobalTransform), With<Cursor>>,\r\n    bridge: ResMut<ClickBridge>,\r\n    asset_server: Res<AssetServer>,\r\n    mut tool_click_event_writer: EventWriter<ToolClickEvent>,\r\n    window_query: Query<&Window, With<PrimaryWindow>>,\r\n    egui_context_query: Query<&EguiContext, With<PrimaryWindow>>,\r\n) {\r\n    for tool in tools.iter() {\r\n        let (tool_actions, tool_parent) = tool;\r\n\r\n        if !ClickToolAction::variants()\r\n            .any(|action| tool_actions.just_pressed(action) || tool_actions.just_released(action))\r\n        {\r\n            continue;\r\n        }\r\n\r\n        let Ok(toolbelt) = toolbelts.get(tool_parent.get()) else {\r\n            warn!(\"Tool not inside a toolbelt?\");\r\n            continue;\r\n        };\r\n        let toolbelt_parent = toolbelt;\r\n\r\n        let Ok(character) = characters.get(toolbelt_parent.get()) else {\r\n            warn!(\"Toolbelt parent not a character?\");\r\n            continue;\r\n        };\r\n        let character_children = character;\r\n\r\n        let Some(cursor) = character_children\r\n            .iter()\r\n            .filter_map(|x| cursors.get(*x).ok())\r\n            .next()\r\n        else {\r\n            //TODO: warn if more than one cursor found\r\n            warn!(\"Character {:?} missing a cursor?\", toolbelt_parent.get());\r\n            debug!(\"Character children: {:?}\", character_children);\r\n            continue;\r\n        };\r\n        let (cursor_id, cursor_transform) = cursor;\r\n        let cursor_pos = cursor_transform.translation();\r\n\r\n        let window = window_query.get_single().expect(\"Need a single window\");\r\n\r\n        let Ok(egui_context) = egui_context_query.get_single() else {\r\n            return;\r\n        };\r\n        let disable_sfx = egui_context.clone().get_mut().is_pointer_over_area();\r\n        if window.cursor_position().is_some() {\r\n            // The host cursor is over the window\r\n            // Perform virtual click instead of sending a message to the worker thread\r\n            // debug!(\"Performing virtual click\");\r\n            for action in ClickToolAction::variants() {\r\n                if tool_actions.just_pressed(action) {\r\n                    debug!(\"{:?} pressed\", action);\r\n                    if !disable_sfx {\r\n                        commands.spawn((\r\n                            SpatialBundle {\r\n                                transform: Transform::from_translation(cursor_pos),\r\n                                ..default()\r\n                            },\r\n                            Name::new(\"Click sound\"),\r\n                            AudioBundle {\r\n                                source: asset_server.load(action.get_audio_path(Motion::Down)),\r\n                                settings: PlaybackSettings::DESPAWN\r\n                                    .with_spatial(true)\r\n                                    .with_volume(Volume::Relative(VolumeLevel::new(0.5))),\r\n                            },\r\n                        ));\r\n                    }\r\n                    tool_click_event_writer.send(ToolClickEvent::Pressed {\r\n                        cursor_id,\r\n                        way: action.into(),\r\n                    });\r\n                }\r\n                if tool_actions.just_released(action) {\r\n                    debug!(\"{:?} released\", action);\r\n                    if !disable_sfx {\r\n                        commands.spawn((\r\n                            SpatialBundle {\r\n                                transform: Transform::from_translation(cursor_pos),\r\n                                ..default()\r\n                            },\r\n                            Name::new(\"Click sound\"),\r\n                            AudioBundle {\r\n                                source: asset_server.load(action.get_audio_path(Motion::Up)),\r\n                                settings: PlaybackSettings::DESPAWN\r\n                                    .with_spatial(true)\r\n                                    .with_volume(Volume::Relative(VolumeLevel::new(0.5))),\r\n                            },\r\n                        ));\r\n                    }\r\n                    tool_click_event_writer.send(ToolClickEvent::Released {\r\n                        cursor_id,\r\n                        way: action.into(),\r\n                    });\r\n                }\r\n            }\r\n        } else {\r\n            // The host cursor is outside the window\r\n            // Send a message to the worker thread\r\n            // debug!(\"Performing host click\");\r\n            for action in ClickToolAction::variants() {\r\n                if tool_actions.just_pressed(action) {\r\n                    debug!(\"{:?} pressed\", action);\r\n                    match bridge.sender.send((\r\n                        action.get_thread_message(Motion::Down),\r\n                        cursor_pos.x as i32,\r\n                        -cursor_pos.y as i32,\r\n                    )) {\r\n                        Ok(_) => {\r\n                            commands.spawn((\r\n                                SpatialBundle {\r\n                                    transform: Transform::from_translation(cursor_pos),\r\n                                    ..default()\r\n                                },\r\n                                Name::new(\"Click sound\"),\r\n                                AudioBundle {\r\n                                    source: asset_server.load(action.get_audio_path(Motion::Down)),\r\n                                    settings: PlaybackSettings::DESPAWN\r\n                                        .with_spatial(true)\r\n                                        .with_volume(Volume::Relative(VolumeLevel::new(0.5))),\r\n                                },\r\n                            ));\r\n                        }\r\n                        Err(e) => {\r\n                            error!(\"Failed to send click: {:?}\", e);\r\n                        }\r\n                    }\r\n                }\r\n                if tool_actions.just_released(action) {\r\n                    debug!(\"{:?} released\", action);\r\n                    match bridge.sender.send((\r\n                        action.get_thread_message(Motion::Up),\r\n                        cursor_pos.x as i32,\r\n                        -cursor_pos.y as i32,\r\n                    )) {\r\n                        Ok(_) => {\r\n                            commands.spawn((\r\n                                SpatialBundle {\r\n                                    transform: Transform::from_translation(cursor_pos),\r\n                                    ..default()\r\n                                },\r\n                                Name::new(\"Click sound\"),\r\n                                AudioBundle {\r\n                                    source: asset_server.load(action.get_audio_path(Motion::Up)),\r\n                                    settings: PlaybackSettings::DESPAWN\r\n                                        .with_spatial(true)\r\n                                        .with_volume(Volume::Relative(VolumeLevel::new(0.5))),\r\n                                },\r\n                            ));\r\n                        }\r\n\r\n                        Err(e) => {\r\n                            error!(\"Failed to send click: {:?}\", e);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\toolbelt\\src\\tool_help_cleanup.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n\r\nuse cursor_hero_toolbelt_types::toolbelt_types::ToolHelp;\r\n\r\npub fn tool_help_cleanup(\r\n    mut commands: Commands,\r\n    mut tool_help_query: Query<(Entity, &mut ToolHelp)>,\r\n    time: Res<Time>,\r\n) {\r\n    for (tool_help_id, mut tool_help) in &mut tool_help_query {\r\n        if tool_help.timer.tick(time.delta()).just_finished() {\r\n            commands.entity(tool_help_id).despawn_recursive();\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\pressure_plate\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_pressure_plate\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\ncursor_hero_data = { workspace = true }\r\nbevy = { workspace = true }\r\nbevy_xpbd_2d = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\physics\\src\\damping_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse bevy_xpbd_2d::math::*;\r\nuse bevy_xpbd_2d::prelude::*;\r\n\r\npub struct DampingPlugin;\r\n\r\n#[derive(SystemSet, Clone, Hash, Debug, PartialEq, Eq)]\r\npub enum DampingSystemSet {\r\n    Dampen,\r\n}\r\n\r\nimpl Plugin for DampingPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<MovementDamping>();\r\n        app.configure_sets(Update, DampingSystemSet::Dampen);\r\n        app.add_systems(\r\n            Update,\r\n            apply_movement_damping.in_set(DampingSystemSet::Dampen),\r\n        );\r\n    }\r\n}\r\n\r\n#[derive(Component, Reflect, Debug)]\r\npub struct MovementDamping {\r\n    pub factor: Scalar,\r\n}\r\n\r\nimpl Default for MovementDamping {\r\n    fn default() -> Self {\r\n        Self { factor: 0.95 }\r\n    }\r\n}\r\n\r\n#[allow(clippy::type_complexity)]\r\nfn apply_movement_damping(\r\n    mut query: Query<\r\n        (&MovementDamping, &mut LinearVelocity, &mut AngularVelocity),\r\n        Without<Sleeping>,\r\n    >,\r\n    time: Res<Time<Physics>>,\r\n) {\r\n    if time.is_paused() {\r\n        return;\r\n    }\r\n    for (damping, mut linear_velocity, mut angular_velocity) in &mut query {\r\n        linear_velocity.x *= damping.factor;\r\n        if linear_velocity.x.abs() < 10.0 {\r\n            linear_velocity.x = 0.0;\r\n        }\r\n        linear_velocity.y *= damping.factor;\r\n        if linear_velocity.y.abs() < 10.0 {\r\n            linear_velocity.y = 0.0;\r\n        }\r\n        angular_velocity.0 *= damping.factor;\r\n        if angular_velocity.0.abs() < 10.0 {\r\n            angular_velocity.0 = 0.0;\r\n        }\r\n        // if linear_velocity.x != 0.0 && linear_velocity.y != 0.0 {\r\n        //     debug!(\"linear_velocity: {:?}\", linear_velocity);\r\n        // }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\taskbar\\src\\lib.rs\r\n\r\n````rust\r\npub mod taskbar_plugin;\r\npub mod taskbar_spawn_plugin;\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ollama\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_ollama\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\ncursor_hero_ollama_types = { workspace = true }\r\nollama-rs = { workspace = true }\r\ncrossbeam-channel = { workspace = true }\r\ncursor_hero_inference_types = {workspace = true}\r\ncursor_hero_math = {workspace = true}\r\ncursor_hero_cursor_types = {workspace = true}\r\ncursor_hero_environment_types = {workspace = true}\r\ncursor_hero_text_asset_types = {workspace = true}\r\ntokio = {workspace = true}\r\nreqwest = {workspace = true, features=[\"json\"]}\r\nserde = { version = \"1.0\", features = [\"derive\"] }\r\nserde_json = \"1.0\"\r\nbevy_xpbd_2d = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\secret_types\\src\\lib.rs\r\n\r\n````rust\r\npub mod secrets_types;\r\npub mod secrets_types_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::secrets_types::*;\r\n    pub use crate::secrets_types_plugin::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\sprint_tool\\src\\lib.rs\r\n\r\n````rust\r\npub mod sprint_tool_plugin;\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\screen\\src\\get_image.rs\r\n\r\n````rust\r\nuse bevy::ecs::system::SystemParam;\r\nuse bevy::prelude::*;\r\nuse image::DynamicImage;\r\nuse image::RgbImage;\r\n\r\nuse crate::screen_plugin::Screen;\r\n\r\npub enum GetImageError {\r\n    ElementEmpty,\r\n}\r\n\r\n#[derive(SystemParam)]\r\npub struct ScreensToImageParam<'w, 's> {\r\n    pub images: Res<'w, Assets<Image>>,\r\n    pub screens: Query<'w, 's, (&'static Handle<Image>, &'static GlobalTransform), With<Screen>>,\r\n}\r\n\r\npub fn get_image(\r\n    bounds: IRect,\r\n    screen_access: &ScreensToImageParam,\r\n) -> Result<Image, GetImageError> {\r\n    if bounds.is_empty() {\r\n        return Err(GetImageError::ElementEmpty);\r\n    }\r\n    let mut tex = RgbImage::new(bounds.width() as u32, bounds.height() as u32);\r\n\r\n    // find out what parts of each screen are intersecting with the element\r\n    for (screen_image_handle, screen_trans) in screen_access.screens.iter() {\r\n        // find out the image size\r\n        let screen_center_pos = screen_trans.translation();\r\n        match screen_access.images.get(screen_image_handle) {\r\n            None => {}\r\n            Some(screen_image) => {\r\n                // Calculate the overlapping area\r\n                let screen_size = screen_image.texture_descriptor.size;\r\n                let mut screen_origin = screen_center_pos.xy();\r\n                screen_origin.y *= -1.0;\r\n                let screen_rect = Rect::from_center_size(\r\n                    screen_origin,\r\n                    Vec2::new(screen_size.width as f32, screen_size.height as f32),\r\n                );\r\n\r\n                // find the overlap\r\n                // debug!(\"screen_rect: {:?}\", screen_rect);\r\n                let intersection = screen_rect.intersect(bounds.as_rect());\r\n                // debug!(\"intersection rect: {:?}\", intersection);\r\n\r\n                // convert to monitor coordinates\r\n                let origin = intersection.center() - screen_rect.min.xy();\r\n                let tex_grab_rect = Rect::from_center_size(origin, intersection.size());\r\n                // debug!(\"tex_grab_rect: {:?}\", tex_grab_rect);\r\n\r\n                if !tex_grab_rect.is_empty() {\r\n                    // debug!(\r\n                    //     \"Copying pixel range {} by {}\",\r\n                    //     tex_grab_rect.size().x,\r\n                    //     tex_grab_rect.size().y\r\n                    // );\r\n\r\n                    // Calculate where to start placing pixels in the element's texture\r\n                    let texture_start_x = (intersection.min.x - bounds.min.x as f32) as u32;\r\n                    let texture_start_y = (intersection.min.y - bounds.min.y as f32) as u32;\r\n                    // debug!(\"Texture start: {} {}\", texture_start_x, texture_start_y);\r\n                    // Copy the overlapping part of the screen texture to the element's texture.\r\n                    for y in tex_grab_rect.min.y as usize..tex_grab_rect.max.y as usize {\r\n                        for x in tex_grab_rect.min.x as usize..tex_grab_rect.max.x as usize {\r\n                            let start = (y * screen_size.width as usize + x) * 4;\r\n                            if start + 4 <= screen_image.data.len() {\r\n                                let pixel: [u8; 3] = [\r\n                                    screen_image.data[start],\r\n                                    screen_image.data[start + 1],\r\n                                    screen_image.data[start + 2],\r\n                                    // screen_image.data[start + 3],\r\n                                ];\r\n                                tex.put_pixel(\r\n                                    texture_start_x + x as u32 - tex_grab_rect.min.x as u32,\r\n                                    texture_start_y + y as u32 - tex_grab_rect.min.y as u32,\r\n                                    image::Rgb(pixel),\r\n                                );\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    let dynamic_image = DynamicImage::ImageRgb8(tex);\r\n    let image = Image::from_dynamic(dynamic_image, true);\r\n    Ok(image)\r\n    // let texture_handle = images.add(image);\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\start_menu_types\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_start_menu_types\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\toolbelt\\src\\toolbelt_taskbar_layout_plugin.rs\r\n\r\n````rust\r\nuse std::f32::consts::PI;\r\n\r\nuse bevy::prelude::*;\r\nuse bevy::transform::TransformSystem;\r\nuse bevy::utils::HashSet;\r\nuse bevy_xpbd_2d::components::Position;\r\nuse bevy_xpbd_2d::components::Rotation;\r\nuse bevy_xpbd_2d::PhysicsSet;\r\nuse cursor_hero_math::prelude::Corner;\r\nuse cursor_hero_toolbelt_types::toolbelt_types::Tool;\r\nuse cursor_hero_toolbelt_types::toolbelt_types::ToolHelpTrigger;\r\nuse cursor_hero_toolbelt_types::toolbelt_types::Toolbelt;\r\nuse cursor_hero_toolbelt_types::toolbelt_types::ToolbeltLayout;\r\nuse cursor_hero_window_position_types::prelude::WindowPositionTool;\r\nuse cursor_hero_window_position_types::window_position_types::HostWindowPosition;\r\nuse itertools::Itertools;\r\n\r\npub struct ToolbeltTaskbarLayoutPlugin;\r\n\r\nimpl Plugin for ToolbeltTaskbarLayoutPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(\r\n            PostUpdate,\r\n            position_tools\r\n                .after(PhysicsSet::Sync)\r\n                .after(TransformSystem::TransformPropagate),\r\n        );\r\n    }\r\n}\r\n\r\n#[allow(clippy::type_complexity)]\r\npub fn position_tools(\r\n    toolbelt_query: Query<(Ref<Toolbelt>, &Children, &Parent), Without<Tool>>,\r\n    character_query: Query<&GlobalTransform>,\r\n    mut tool_query: Query<\r\n        (\r\n            Entity,\r\n            Option<&WindowPositionTool>,\r\n            &mut Transform,\r\n            &mut Position,\r\n            &mut Rotation,\r\n            &Children,\r\n        ),\r\n        (With<Tool>, Without<ToolHelpTrigger>),\r\n    >,\r\n    mut tool_help_query: Query<\r\n        (&mut Transform, &mut Position, &mut Rotation),\r\n        (With<ToolHelpTrigger>, Without<Tool>),\r\n    >,\r\n) {\r\n    for toolbelt in toolbelt_query.iter() {\r\n        let (toolbelt, toolbelt_kids, toolbelt_parent) = toolbelt;\r\n        if !toolbelt.is_changed() {\r\n            continue;\r\n        }\r\n        let ToolbeltLayout::Taskbar { wheel, .. } = toolbelt.layout else {\r\n            continue;\r\n        };\r\n        if let Ok(character_position) = character_query.get(**toolbelt_parent) {\r\n            let sorted_window_tools = toolbelt_kids\r\n                .iter()\r\n                .filter(|e| tool_query.contains(**e))\r\n                .filter_map(|e| tool_query.get(*e).ok())\r\n                .filter_map(|(entity, window_position_tool, ..)| {\r\n                    window_position_tool.map(|window_position_tool| (entity, window_position_tool))\r\n                })\r\n                .sorted_by_key(|(_, window_position_tool)| {\r\n                    match window_position_tool.window_position {\r\n                        HostWindowPosition::Corner {\r\n                            ref corner,\r\n                            monitor,\r\n                        } => {\r\n                            monitor * 100\r\n                                + match corner {\r\n                                    Corner::TopLeft => 0,\r\n                                    Corner::TopRight => 1,\r\n                                    Corner::BottomLeft => 2,\r\n                                    Corner::BottomRight => 3,\r\n                                }\r\n                        }\r\n                        HostWindowPosition::Fullscreen { monitor } => 100000 + monitor,\r\n                    }\r\n                })\r\n                .map(|(entity, _)| entity)\r\n                .collect_vec();\r\n            let window_tools = sorted_window_tools.iter().collect::<HashSet<_>>();\r\n            let remaining_tools = toolbelt_kids\r\n                .iter()\r\n                .filter(|e| tool_query.contains(**e))\r\n                .filter(|e| !window_tools.contains(e))\r\n                .collect_vec();\r\n\r\n            let count = remaining_tools.len();\r\n            for (i, tool_id) in remaining_tools.iter().enumerate() {\r\n                let Ok(tool) = tool_query.get_mut(**tool_id) else {\r\n                    continue;\r\n                };\r\n\r\n                let (\r\n                    _tool_id,\r\n                    _position_tool,\r\n                    mut tool_transform,\r\n                    mut tool_position,\r\n                    mut tool_rotation,\r\n                    tool_children,\r\n                ) = tool;\r\n                let angle = 2.0 * PI / (count as f32) * i as f32;\r\n                let x = angle.cos();\r\n                let y = angle.sin();\r\n                tool_transform.scale = Vec2::splat(wheel.scale).extend(1.0);\r\n                let character_position = character_position.translation().xy();\r\n                tool_position.0 =\r\n                    character_position + Vec2::new(x * wheel.radius, y * wheel.radius);\r\n                *tool_rotation = Rotation::from_degrees(wheel.spin);\r\n                for tool_child in tool_children.iter() {\r\n                    if let Ok((\r\n                        mut tool_help_transform,\r\n                        mut tool_help_position,\r\n                        mut tool_help_rotation,\r\n                    )) = tool_help_query.get_mut(*tool_child)\r\n                    {\r\n                        tool_help_transform.scale = Vec2::splat(wheel.scale).extend(1.0);\r\n                        tool_help_position.0 = tool_position.xy()\r\n                            + Vec2::new(x * -wheel.radius * 0.5, y * -wheel.radius * 0.5);\r\n                        *tool_help_rotation = Rotation::from_degrees(wheel.spin);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ollama\\src\\ollama_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n\r\nuse crate::ollama_button_plugin::OllamaButtonPlugin;\r\nuse crate::ollama_inference_plugin::OllamaInferencePlugin;\r\nuse crate::ollama_status_plugin::OllamaStatusPlugin;\r\nuse crate::ollama_status_worker_plugin::OllamaStatusWorkerPlugin;\r\n\r\npub struct OllamaPlugin;\r\n\r\nimpl Plugin for OllamaPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_plugins(OllamaInferencePlugin);\r\n        app.add_plugins(OllamaButtonPlugin);\r\n        app.add_plugins(OllamaStatusPlugin);\r\n        app.add_plugins(OllamaStatusWorkerPlugin);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ollama\\src\\ollama_status_worker_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse crossbeam_channel::bounded;\r\nuse crossbeam_channel::Receiver;\r\nuse crossbeam_channel::Sender;\r\nuse cursor_hero_ollama_types::prelude::*;\r\nuse std::thread;\r\n\r\npub struct OllamaStatusWorkerPlugin;\r\n\r\nimpl Plugin for OllamaStatusWorkerPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Startup, create_worker_thread);\r\n        app.add_systems(Update, events_to_bridge);\r\n        app.add_systems(Update, bridge_to_events);\r\n    }\r\n}\r\n\r\n#[derive(Debug)]\r\nenum GameboundMessage {\r\n    Pong { status: OllamaStatus },\r\n}\r\n\r\n#[derive(Debug)]\r\nenum ThreadboundMessage {\r\n    Ping,\r\n    Startup,\r\n}\r\n\r\n#[derive(Resource)]\r\nstruct Bridge {\r\n    pub sender: Sender<ThreadboundMessage>,\r\n    pub receiver: Receiver<GameboundMessage>,\r\n}\r\n\r\nfn create_worker_thread(mut commands: Commands) {\r\n    let (game_tx, game_rx) = bounded::<_>(10);\r\n    let (thread_tx, thread_rx) = bounded::<_>(10);\r\n    commands.insert_resource(Bridge {\r\n        sender: thread_tx,\r\n        receiver: game_rx,\r\n    });\r\n\r\n    let game_tx_clone = game_tx.clone();\r\n    thread::Builder::new()\r\n        .name(\"Ollama status thread\".to_string())\r\n        .spawn(move || {\r\n            let rt = tokio::runtime::Runtime::new().unwrap();\r\n            rt.block_on(async {\r\n                let game_tx = game_tx_clone;\r\n                loop {\r\n                    let msg = match thread_rx.recv() {\r\n                        Ok(msg) => msg,\r\n                        Err(_) => {\r\n                            error!(\"Threadbound channel failure, exiting\");\r\n                            break;\r\n                        }\r\n                    };\r\n                    match msg {\r\n                        ThreadboundMessage::Ping => {\r\n                            debug!(\"Worker received ping request, pinging Ollama API\");\r\n                            let status = match crate::ollama::get_status().await {\r\n                                Ok(status) => status,\r\n                                Err(e) => {\r\n                                    error!(\"Failed to get status: {:?}\", e);\r\n                                    OllamaStatus::Unknown\r\n                                }\r\n                            };\r\n                            if let Err(e) = game_tx.send(GameboundMessage::Pong { status }) {\r\n                                error!(\"Gamebound channel failure, exiting: {}\", e);\r\n                                break;\r\n                            }\r\n                        }\r\n                        ThreadboundMessage::Startup => {\r\n                            debug!(\"Worker received startup request, starting Ollama API\");\r\n                            if let Err(e) = crate::ollama::start() {\r\n                                error!(\"Failed to start: {:?}\", e);\r\n                            };\r\n                        }\r\n                    }\r\n                    std::thread::sleep(std::time::Duration::from_millis(50));\r\n                }\r\n            });\r\n        })\r\n        .expect(\"Failed to spawn thread\");\r\n}\r\n\r\nfn events_to_bridge(\r\n    bridge: ResMut<Bridge>,\r\n    mut ping_events: EventReader<OllamaPingEvent>,\r\n    mut status_events: EventReader<OllamaStatusEvent>,\r\n) {\r\n    // Detect ping requests\r\n    for event in ping_events.read() {\r\n        let OllamaPingEvent::Ping = event else {\r\n            continue;\r\n        };\r\n        let msg = ThreadboundMessage::Ping;\r\n        debug!(\"Sending bridge message: {:?}\", msg);\r\n        if let Err(e) = bridge.sender.send(msg) {\r\n            error!(\"Threadbound channel failure: {}\", e);\r\n        }\r\n    }\r\n\r\n    // Detect startup requests\r\n    let starting = status_events\r\n        .read()\r\n        .any(|event| matches!(event, OllamaStatusEvent::Startup));\r\n    if starting {\r\n        status_events.clear();\r\n        let msg = ThreadboundMessage::Startup;\r\n        debug!(\"Sending bridge message: {:?}\", msg);\r\n        if let Err(e) = bridge.sender.send(msg) {\r\n            error!(\"Threadbound channel failure: {}\", e);\r\n        }\r\n    }\r\n}\r\n\r\nfn bridge_to_events(bridge: ResMut<Bridge>, mut events: EventWriter<OllamaPingEvent>) {\r\n    for msg in bridge.receiver.try_iter() {\r\n        match msg {\r\n            GameboundMessage::Pong { status } => {\r\n                let event = OllamaPingEvent::Pong { status };\r\n                debug!(\"Received bridge response, sending game event {:?}\", event);\r\n                events.send(event);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\physics_debug\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_physics_debug\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\nbevy_xpbd_2d = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\screen\\src\\screen_capture_and_update_plugin.rs\r\n\r\n````rust\r\nuse crate::screen_plugin::Screen;\r\nuse bevy::prelude::*;\r\nuse bevy::utils::HashMap;\r\nuse bevy::window::PrimaryWindow;\r\nuse bevy::winit::WinitWindows;\r\nuse cursor_hero_metrics::Metrics;\r\nuse cursor_hero_winutils::win_screen_capture::get_full_monitor_capturers;\r\nuse cursor_hero_winutils::win_screen_capture::MonitorId;\r\nuse cursor_hero_winutils::win_screen_capture::MonitorRegionCapturer;\r\nuse cursor_hero_worker::prelude::anyhow::Error;\r\nuse cursor_hero_worker::prelude::anyhow::Result;\r\nuse cursor_hero_worker::prelude::Sender;\r\nuse cursor_hero_worker::prelude::WorkerConfig;\r\nuse cursor_hero_worker::prelude::WorkerMessage;\r\nuse cursor_hero_worker::prelude::WorkerPlugin;\r\nuse cursor_hero_worker::prelude::WorkerState;\r\n\r\npub struct ScreenCaptureAndUpdatePlugin;\r\n\r\nimpl Plugin for ScreenCaptureAndUpdatePlugin {\r\n    fn build(&self, app: &mut App) {\r\n        #[cfg(debug_assertions)]\r\n        let refresh_fps = 10;\r\n        #[cfg(not(debug_assertions))]\r\n        let refresh_fps = 144;\r\n\r\n        app.add_plugins(WorkerPlugin {\r\n            config: WorkerConfig::<ThreadboundMessage, GameboundMessage, ThreadState> {\r\n                name: \"screen_update_plugin\".to_string(),\r\n                threadbound_message_receiver: |thread_rx, _state| {\r\n                    // Continuously capture frames when no messages present\r\n                    match thread_rx.try_recv() {\r\n                        Ok(x) => Ok(x),\r\n                        _ => Ok(ThreadboundMessage::CaptureFrames),\r\n                    }\r\n                },\r\n                handle_threadbound_message,\r\n                sleep_duration: std::time::Duration::from_nanos(1_000_000_000 / refresh_fps),\r\n                ..default()\r\n            },\r\n        });\r\n        app.add_systems(Update, update_screens);\r\n    }\r\n}\r\n\r\n#[derive(Debug, Clone)]\r\nstruct CapturedFrame {\r\n    data: Vec<u8>,\r\n}\r\n\r\nstruct ThreadState {\r\n    capturers: Vec<MonitorRegionCapturer>,\r\n    enabled: bool,\r\n}\r\nimpl WorkerState for ThreadState {\r\n    fn try_default() -> Result<Self> {\r\n        Ok(ThreadState {\r\n            capturers: get_full_monitor_capturers()?,\r\n            enabled: true,\r\n        })\r\n    }\r\n}\r\n\r\n#[derive(Debug, Reflect, Clone, Event)]\r\nenum ThreadboundMessage {\r\n    SetEnabled(bool),\r\n    CaptureFrames,\r\n}\r\nimpl WorkerMessage for ThreadboundMessage {}\r\n\r\n#[derive(Clone, Event)]\r\nenum GameboundMessage {\r\n    Frames(HashMap<MonitorId, CapturedFrame>),\r\n}\r\nimpl WorkerMessage for GameboundMessage {}\r\nimpl std::fmt::Debug for GameboundMessage {\r\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\r\n        match self {\r\n            GameboundMessage::Frames(frames) => {\r\n                write!(f, \"GameboundMessage::Frames(len={})\", frames.len())\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfn handle_threadbound_message(\r\n    msg: &ThreadboundMessage,\r\n    reply_tx: &Sender<GameboundMessage>,\r\n    state: &mut ThreadState,\r\n) -> Result<()> {\r\n    match msg {\r\n        ThreadboundMessage::SetEnabled(enabled) => {\r\n            state.enabled = *enabled;\r\n            info!(\"Screen capture enabled: {}\", enabled)\r\n        }\r\n        ThreadboundMessage::CaptureFrames => {\r\n            if !state.enabled {\r\n                return Ok(());\r\n            }\r\n            let frames = state\r\n                .capturers\r\n                .iter_mut()\r\n                .map(|capturer| {\r\n                    // let mut metrics = Metrics::default();\r\n                    // let frame = capturer.capture(&mut Some(metrics)).unwrap();\r\n                    let frame = capturer.capture(&mut None)?;\r\n                    let frame = CapturedFrame {\r\n                        data: frame.to_vec(),\r\n                    };\r\n                    Ok::<(u32, CapturedFrame), Error>((capturer.monitor.info.id, frame))\r\n                })\r\n                .filter_map(Result::ok)\r\n                .collect::<HashMap<u32, CapturedFrame>>();\r\n            reply_tx.send(GameboundMessage::Frames(frames))?;\r\n        }\r\n    }\r\n    Ok(())\r\n}\r\n\r\nfn update_screens(\r\n    mut query: Query<(&mut Screen, &Handle<Image>)>,\r\n    mut textures: ResMut<Assets<Image>>,\r\n    mut gamebound_messages: EventReader<GameboundMessage>,\r\n    mut threadbound_messages: EventWriter<ThreadboundMessage>,\r\n    window_query: Query<Entity, With<PrimaryWindow>>,\r\n    winit_windows: NonSend<WinitWindows>,\r\n    mut sent_disabled: Local<bool>,\r\n) {\r\n    let window_id = window_query.single();\r\n    let Some(winit_window) = winit_windows.get_window(window_id) else {\r\n        error!(\"Window not found\");\r\n        return;\r\n    };\r\n    if winit_window.is_minimized().unwrap_or(false) {\r\n        if !*sent_disabled {\r\n            threadbound_messages.send(ThreadboundMessage::SetEnabled(false));\r\n            *sent_disabled = true;\r\n        }\r\n        return;\r\n    } else {\r\n        if *sent_disabled {\r\n            threadbound_messages.send(ThreadboundMessage::SetEnabled(true));\r\n            *sent_disabled = false;\r\n        }\r\n    }\r\n    let Some(msg) = gamebound_messages.read().last() else {\r\n        return;\r\n    };\r\n    let GameboundMessage::Frames(frames) = msg;\r\n    for screen in &mut query {\r\n        let (screen, texture) = screen;\r\n        // find the frame captured in the other thread\r\n        let mut metrics = Metrics::default();\r\n        metrics.begin(\"lookup\");\r\n        if let Some(frame) = frames.get(&screen.id) {\r\n            // update the texture\r\n            metrics.begin(\"texture\");\r\n            textures.get_mut(texture).map(|t| t.data = frame.data.clone());\r\n            metrics.end(\"texture\");\r\n        }\r\n        metrics.end(\"lookup\");\r\n\r\n        // report metrics\r\n        // println!(\"{}\", metrics.report());\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\observation_types\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_observation_types\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\nchrono = {workspace = true, features=[\"serde\"]}\r\nserde = {workspace = true}\r\ncursor_hero_ui_automation_types = { workspace = true}\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\text_asset\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_text_asset\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\ncursor_hero_text_asset_types = { workspace = true }\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\observation_types\\src\\lib.rs\r\n\r\n````rust\r\n#![feature(trivial_bounds)]\r\npub mod observation_types;\r\npub mod observation_types_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::observation_types::*;\r\n    pub use crate::observation_types_plugin::ObservationTypesPlugin;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\sprint_tool\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_sprint_tool\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\ncursor_hero_character_types = { workspace = true }\r\ncursor_hero_sprint_tool_types = { workspace = true }\r\nbevy_xpbd_2d = { workspace = true }\r\ncursor_hero_toolbelt_types = { workspace = true }\r\ncursor_hero_tools = { workspace = true }\r\ncursor_hero_cursor_types = { workspace = true }\r\nleafwing-input-manager = { workspace = true }\r\nbevy-inspector-egui = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\text_asset_types\\src\\lib.rs\r\n\r\n````rust\r\npub mod text_asset_loader_types;\r\npub mod text_asset_types_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::text_asset_loader_types::*;\r\n    pub use crate::text_asset_types_plugin::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\plugins\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_plugins\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n\r\n[dependencies]\r\ncursor_hero_ui_hover = { workspace = true }\r\ncursor_hero_ui_hover_types = { workspace = true }\r\ncursor_hero_ui_inspector = { workspace = true }\r\ncursor_hero_ui_inspector_types = { workspace = true }\r\ncursor_hero_worker = { workspace = true }\r\ncursor_hero_worker_types = { workspace = true }\r\ncursor_hero_memory = { workspace = true }\r\ncursor_hero_memory_types = { workspace = true }\r\ncursor_hero_window_swap_tool = { workspace = true }\r\ncursor_hero_window_swap_tool_types = { workspace = true }\r\ncursor_hero_host_fs = { workspace = true }\r\ncursor_hero_host_fs_types = { workspace = true }\r\ncursor_hero_window_position = { workspace = true }\r\ncursor_hero_window_position_types = { workspace = true }\r\ncursor_hero_ui_automation = { workspace = true }\r\ncursor_hero_ui_automation_types = { workspace = true }\r\ncursor_hero_brick = { workspace = true }\r\ncursor_hero_brick_types = { workspace = true }\r\ncursor_hero_fullscreen_tool = { workspace = true }\r\ncursor_hero_fullscreen_tool_types = { workspace = true }\r\ncursor_hero_ui_watcher = { workspace = true }\r\ncursor_hero_ui_watcher_types = { workspace = true }\r\ncursor_hero_floaty_nametag = { workspace = true }\r\ncursor_hero_floaty_nametag_types = { workspace = true }\r\ncursor_hero_host_event = { workspace = true }\r\ncursor_hero_host_event_types = { workspace = true }\r\ncursor_hero_start_menu = { workspace = true }\r\ncursor_hero_start_menu_types = { workspace = true }\r\ncursor_hero_calculator_app = { workspace = true }\r\ncursor_hero_calculator_app_types = { workspace = true }\r\ncursor_hero_app = { workspace = true }\r\ncursor_hero_app_types = { workspace = true }\r\ncursor_hero_secret = { workspace = true }\r\ncursor_hero_secret_types = { workspace = true }\r\ncursor_hero_voice_to_text = { workspace = true }\r\ncursor_hero_voice_to_text_types = { workspace = true }\r\ncursor_hero_glados_tts = { workspace = true }\r\ncursor_hero_glados_tts_types = { workspace = true }\r\ncursor_hero_ollama = { workspace = true }\r\ncursor_hero_ollama_types = { workspace = true }\r\ncursor_hero_text_asset = { workspace = true }\r\ncursor_hero_text_asset_types = { workspace = true }\r\ncursor_hero_environment_types = { workspace = true }\r\ncursor_hero_chat_types = { workspace = true }\r\ncursor_hero_chat = { workspace = true }\r\ncursor_hero_observation_types = { workspace = true }\r\ncursor_hero_observation = { workspace = true }\r\ncursor_hero_inference_types = { workspace = true }\r\ncursor_hero_inference = { workspace = true }\r\ncursor_hero_movement_tool_types = { workspace = true }\r\ncursor_hero_movement_tool = { workspace = true }\r\ncursor_hero_character_types = { workspace = true }\r\ncursor_hero_agent_types = { workspace = true }\r\ncursor_hero_physics_debug = { workspace = true }\r\ncursor_hero_math = { workspace = true }\r\ncursor_hero_version = { workspace = true }\r\ncursor_hero_cursor_types = { workspace = true }\r\ncursor_hero_toolbelt_types = { workspace = true }\r\ncursor_hero_sprint_tool_types = { workspace = true }\r\ncursor_hero_sprint_tool = { workspace = true }\r\ncursor_hero_agent = { workspace = true }\r\ncursor_hero_taskbar = { workspace = true }\r\ncursor_hero_taskbar_tool = { workspace = true }\r\ncursor_hero_taskbar_types = { workspace = true }\r\ncursor_hero_environment_nametag = { workspace = true }\r\ncursor_hero_environment = { workspace = true }\r\ncursor_hero_xelu_prompts = { workspace = true }\r\ncursor_hero_wallpaper = { workspace = true }\r\ncursor_hero_hover = {workspace = true}\r\ncursor_hero_pressure_plate = {workspace = true}\r\ncursor_hero_level_bounds = {workspace = true}\r\ncursor_hero_input = {workspace = true}\r\ncursor_hero_camera = {workspace = true}\r\ncursor_hero_character = {workspace = true}\r\ncursor_hero_data = {workspace = true}\r\ncursor_hero_metrics = {workspace = true}\r\ncursor_hero_click_drag_character_movement = {workspace = true}\r\ncursor_hero_physics = {workspace = true}\r\ncursor_hero_cursor = {workspace = true}\r\ncursor_hero_screen = {workspace = true}\r\ncursor_hero_toolbelt = {workspace = true}\r\ncursor_hero_tools = {workspace = true}\r\ncursor_hero_ui = {workspace = true}\r\ncursor_hero_icon = {workspace = true}\r\ncursor_hero_winutils = {workspace = true}\r\nbevy = {workspace = true}\r\nbevy_embedded_assets = { workspace = true }\r\nbevy-inspector-egui = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\observation_types\\src\\observation_types_plugin.rs\r\n\r\n````rust\r\nuse crate::prelude::*;\r\nuse bevy::prelude::*;\r\npub struct ObservationTypesPlugin;\r\n\r\nimpl Plugin for ObservationTypesPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<ObservationTool>();\r\n        app.register_type::<ObservationBuffer>();\r\n        app.register_type::<ObservationBufferEntry>();\r\n        app.register_type::<WhatsNew>();\r\n        app.add_event::<SomethingObservableHappenedEvent>();\r\n        app.add_event::<ObservationBufferEvent>();\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui\\src\\position_text_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse bevy::window::PrimaryWindow;\r\nuse cursor_hero_camera::camera_plugin::MainCamera;\r\nuse cursor_hero_character_types::prelude::*;\r\n\r\npub struct PositionTextPlugin;\r\n\r\nimpl Plugin for PositionTextPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<CharacterPositionText>();\r\n        app.register_type::<MouseWorldPositionText>();\r\n        app.register_type::<MouseScreenPositionText>();\r\n        app.add_systems(Startup, setup_position_text);\r\n        app.add_systems(Update, update_position_text);\r\n    }\r\n}\r\n\r\n#[derive(Component, Reflect)]\r\nstruct CharacterPositionText;\r\n#[derive(Component, Reflect)]\r\nstruct MouseWorldPositionText;\r\n#[derive(Component, Reflect)]\r\nstruct MouseScreenPositionText;\r\n\r\nfn setup_position_text(mut commands: Commands, asset_server: Res<AssetServer>) {\r\n    commands.spawn((\r\n        TextBundle::from_section(\r\n            \"Character: \",\r\n            TextStyle {\r\n                font: asset_server.load(\"fonts/FiraSans-Bold.ttf\"),\r\n                font_size: 16.0,\r\n                ..default()\r\n            },\r\n        )\r\n        .with_style(Style {\r\n            position_type: PositionType::Absolute,\r\n            bottom: Val::Px(5.0),\r\n            left: Val::Px(5.0),\r\n            ..default()\r\n        }),\r\n        CharacterPositionText,\r\n        Name::new(\"Character Position Text\"),\r\n    ));\r\n    commands.spawn((\r\n        TextBundle::from_section(\r\n            \"Mouse Cursor: \",\r\n            TextStyle {\r\n                font: asset_server.load(\"fonts/FiraSans-Bold.ttf\"),\r\n                font_size: 16.0,\r\n                ..default()\r\n            },\r\n        )\r\n        .with_style(Style {\r\n            position_type: PositionType::Absolute,\r\n            bottom: Val::Px(15.0),\r\n            left: Val::Px(5.0),\r\n            ..default()\r\n        }),\r\n        MouseWorldPositionText,\r\n        Name::new(\"Mouse Cursor Position Text\"),\r\n    ));\r\n    commands.spawn((\r\n        TextBundle::from_section(\r\n            \"Mouse Screen: \",\r\n            TextStyle {\r\n                font: asset_server.load(\"fonts/FiraSans-Bold.ttf\"),\r\n                font_size: 16.0,\r\n                ..default()\r\n            },\r\n        )\r\n        .with_style(Style {\r\n            position_type: PositionType::Absolute,\r\n            bottom: Val::Px(25.0),\r\n            left: Val::Px(5.0),\r\n            ..default()\r\n        }),\r\n        MouseScreenPositionText,\r\n        Name::new(\"Mouse Screen Position Text\"),\r\n    ));\r\n}\r\n\r\n#[allow(clippy::type_complexity)]\r\nfn update_position_text(\r\n    character_query: Query<(&Character, &Transform), With<Character>>,\r\n    camera_query: Query<(&Camera, &GlobalTransform), With<MainCamera>>,\r\n    window_query: Query<&Window, With<PrimaryWindow>>,\r\n    mut character_position_text_query: Query<\r\n        &mut Text,\r\n        (\r\n            With<CharacterPositionText>,\r\n            Without<MouseWorldPositionText>,\r\n            Without<MouseScreenPositionText>,\r\n        ),\r\n    >,\r\n    mut mouse_world_position_text_query: Query<\r\n        &mut Text,\r\n        (\r\n            With<MouseWorldPositionText>,\r\n            Without<CharacterPositionText>,\r\n            Without<MouseScreenPositionText>,\r\n        ),\r\n    >,\r\n    mut mouse_screen_position_text_query: Query<\r\n        &mut Text,\r\n        (\r\n            With<MouseScreenPositionText>,\r\n            Without<CharacterPositionText>,\r\n            Without<MouseWorldPositionText>,\r\n        ),\r\n    >,\r\n    // mut text_query: Query<&mut Text, With<CharacterPositionText>>,\r\n) {\r\n    for (_character, transform) in character_query.iter() {\r\n        character_position_text_query.single_mut().sections[0].value = format!(\r\n            \"Character: {:.2}, {:.2}, {:.2}\",\r\n            transform.translation.x, transform.translation.y, transform.translation.z\r\n        );\r\n    }\r\n\r\n    let (camera, camera_transform) = camera_query.single();\r\n    let window = window_query.single();\r\n    // check if the cursor is inside the window and get its position\r\n    // then, ask bevy to convert into world coordinates, and truncate to discard Z\r\n    if let Some(world_position) = window\r\n        .cursor_position()\r\n        .and_then(|cursor| camera.viewport_to_world(camera_transform, cursor))\r\n        .map(|ray| ray.origin.truncate())\r\n    {\r\n        mouse_world_position_text_query.single_mut().sections[0].value = format!(\r\n            \"Mouse world: {:.2}, {:.2}\",\r\n            world_position.x, world_position.y,\r\n        );\r\n    } else {\r\n        mouse_world_position_text_query.single_mut().sections[0].value =\r\n            \"Mouse world: None\".to_string();\r\n    }\r\n    if let Some(cursor_position) = window.cursor_position() {\r\n        mouse_screen_position_text_query.single_mut().sections[0].value = format!(\r\n            \"Mouse screen: {:.2}, {:.2}\",\r\n            cursor_position.x, cursor_position.y,\r\n        );\r\n    } else {\r\n        mouse_screen_position_text_query.single_mut().sections[0].value =\r\n            \"Mouse screen: None\".to_string();\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ollama_types\\src\\ollama_types.rs\r\n\r\n````rust\r\nuse std::time::Duration;\r\n\r\nuse bevy::prelude::*;\r\nuse bevy::utils::Instant;\r\n\r\n#[derive(Reflect, Resource, Default, Debug, Eq, PartialEq, Clone, Copy)]\r\n#[reflect(Resource)]\r\npub enum OllamaStatus {\r\n    #[default]\r\n    Unknown,\r\n    Alive,\r\n    Dead,\r\n    Starting {\r\n        instant: Instant,\r\n        timeout: Duration,\r\n    },\r\n}\r\n\r\n#[derive(Component, Debug, Reflect, Default)]\r\npub struct OllamaStatusButton {\r\n    pub visual_state: OllamaStatusButtonVisualState,\r\n}\r\n\r\n#[derive(Debug, Reflect, Eq, PartialEq)]\r\npub enum OllamaStatusButtonVisualState {\r\n    Default { status: OllamaStatus },\r\n    Hovered { status: OllamaStatus },\r\n    Pressed { status: OllamaStatus },\r\n}\r\nimpl Default for OllamaStatusButtonVisualState {\r\n    fn default() -> Self {\r\n        OllamaStatusButtonVisualState::Default {\r\n            status: OllamaStatus::Unknown,\r\n        }\r\n    }\r\n}\r\n\r\n#[derive(Event, Debug, Reflect)]\r\npub enum OllamaPingEvent {\r\n    Ping,\r\n    Pong { status: OllamaStatus },\r\n}\r\n\r\n#[derive(Event, Debug, Reflect)]\r\npub enum OllamaStatusEvent {\r\n    Changed { new_value: OllamaStatus },\r\n    Startup,\r\n}\r\n\r\n#[derive(Component, Debug, Reflect, Default)]\r\npub struct OllamaTerminalButton {\r\n    pub visual_state: OllamaTerminalButtonVisualState,\r\n}\r\n#[derive(Debug, Reflect, Eq, PartialEq, Default)]\r\npub enum OllamaTerminalButtonVisualState {\r\n    #[default]\r\n    Default,\r\n}\r\n#[derive(Event, Debug, Reflect)]\r\npub enum OllamaTerminalEvent {\r\n    Startup,\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui_automation\\src\\lib.rs\r\n\r\n````rust\r\nmod elements_at_point;\r\nmod formatting;\r\nmod gather_children;\r\nmod gather_element_info;\r\nmod gather_root_children;\r\nmod resolve_app;\r\nmod resolve_calculator;\r\nmod resolve_vscode;\r\nmod take_snapshot;\r\nmod taskbar;\r\nmod ui_automation_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::elements_at_point::*;\r\n    pub use crate::formatting::*;\r\n    pub use crate::gather_children::*;\r\n    pub use crate::gather_element_info::*;\r\n    pub use crate::take_snapshot::*;\r\n    pub use crate::taskbar::*;\r\n    pub use crate::ui_automation_plugin::*;\r\n    pub use cursor_hero_ui_automation_types::prelude::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui_hover\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_ui_hover\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\ncursor_hero_ui_hover_types = { workspace = true }\r\ncursor_hero_ui_automation = { workspace = true }\r\ncursor_hero_camera = { workspace = true }\r\ncursor_hero_worker = { workspace = true }\r\ncursor_hero_winutils = { workspace = true }\r\ncursor_hero_cursor_types = { workspace = true }\r\ncursor_hero_bevy = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\text_asset_types\\src\\text_asset_loader_types.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n\r\nuse bevy::asset::io::Reader;\r\nuse bevy::asset::AssetLoader;\r\nuse bevy::asset::AsyncReadExt;\r\nuse bevy::asset::LoadContext;\r\nuse bevy::utils::thiserror;\r\nuse bevy::utils::BoxedFuture;\r\nuse serde::Deserialize;\r\nuse thiserror::Error;\r\n\r\n#[derive(Asset, Reflect, Debug, Deserialize)]\r\npub struct TextAsset {\r\n    pub value: String,\r\n}\r\n\r\n#[derive(Default)]\r\npub struct TextAssetLoader;\r\n\r\n/// Possible errors that can be produced by [`TextAssetLoader`]\r\n#[non_exhaustive]\r\n#[derive(Debug, Error)]\r\npub enum TextAssetLoaderError {\r\n    /// An [IO](std::io) Error\r\n    #[error(\"Could not load asset: {0}\")]\r\n    Io(#[from] std::io::Error),\r\n}\r\n\r\nimpl AssetLoader for TextAssetLoader {\r\n    type Asset = TextAsset;\r\n    type Settings = ();\r\n    type Error = TextAssetLoaderError;\r\n    fn load<'a>(\r\n        &'a self,\r\n        reader: &'a mut Reader,\r\n        _settings: &'a (),\r\n        _load_context: &'a mut LoadContext,\r\n    ) -> BoxedFuture<'a, Result<Self::Asset, Self::Error>> {\r\n        Box::pin(async move {\r\n            let mut bytes = Vec::new();\r\n            reader.read_to_end(&mut bytes).await?;\r\n            let custom_asset = TextAsset {\r\n                value: String::from_utf8(bytes).unwrap(),\r\n            };\r\n            Ok(custom_asset)\r\n        })\r\n    }\r\n\r\n    fn extensions(&self) -> &[&str] {\r\n        &[\"txt\"]\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui_hover_types\\src\\ui_hover_types_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse crate::prelude::*;\r\n\r\npub struct UiHoverTypesPlugin;\r\n\r\nimpl Plugin for UiHoverTypesPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<HoverInfo>();\r\n        app.register_type::<HostHoveredIndicator>();\r\n        app.register_type::<GameHoveredIndicator>();\r\n    }\r\n}\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ollama\\src\\ollama_inference_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse crossbeam_channel::bounded;\r\nuse crossbeam_channel::Receiver;\r\nuse crossbeam_channel::Sender;\r\nuse cursor_hero_inference_types::prelude::*;\r\nuse cursor_hero_text_asset_types::prelude::*;\r\nuse std::thread;\r\n\r\npub struct OllamaInferencePlugin;\r\n\r\nimpl Plugin for OllamaInferencePlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Startup, create_worker_thread);\r\n        app.add_systems(Update, bridge_generate_requests);\r\n        app.add_systems(Update, bridge_generate_responses);\r\n    }\r\n}\r\n\r\n#[derive(Debug)]\r\nenum GameboundMessage {\r\n    Response {\r\n        session_id: Entity,\r\n        prompt: MaterializedTextPrompt,\r\n        response: String,\r\n    },\r\n}\r\n\r\n#[derive(Debug)]\r\nenum ThreadboundMessage {\r\n    Generate {\r\n        session_id: Entity,\r\n        prompt: MaterializedTextPrompt,\r\n    },\r\n}\r\n\r\n#[derive(Resource)]\r\nstruct Bridge {\r\n    pub sender: Sender<ThreadboundMessage>,\r\n    pub receiver: Receiver<GameboundMessage>,\r\n}\r\n\r\nfn create_worker_thread(mut commands: Commands) {\r\n    let (game_tx, game_rx) = bounded::<_>(10);\r\n    let (thread_tx, thread_rx) = bounded::<_>(10);\r\n    commands.insert_resource(Bridge {\r\n        sender: thread_tx,\r\n        receiver: game_rx,\r\n    });\r\n\r\n    let game_tx_clone = game_tx.clone();\r\n    thread::Builder::new()\r\n        .name(\"Ollama thread\".to_string())\r\n        .spawn(move || {\r\n            let rt = tokio::runtime::Runtime::new().unwrap();\r\n            rt.block_on(async {\r\n                let game_tx = game_tx_clone;\r\n                loop {\r\n                    let msg = match thread_rx.recv() {\r\n                        Ok(msg) => msg,\r\n                        Err(_) => {\r\n                            error!(\"Threadbound channel failure, exiting\");\r\n                            break;\r\n                        }\r\n                    };\r\n                    match msg {\r\n                        ThreadboundMessage::Generate { session_id, prompt } => {\r\n                            debug!(\"Worker received generate request for session {:?}, generating response\", session_id);\r\n                            let data = match crate::ollama::generate(&prompt.materialized, prompt.prompt.options()).await {\r\n                                Ok(data) => data,\r\n                                Err(e) => {\r\n                                    error!(\"Failed to generate: {:?}\", e);\r\n                                    continue;\r\n                                }\r\n                            };\r\n                            if let Err(e) = game_tx.send(GameboundMessage::Response {\r\n                                session_id,\r\n                                prompt: prompt.clone(),\r\n                                response: data,\r\n                            }) {\r\n                                error!(\"Gamebound channel failure, exiting: {:?}\", e);\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                    std::thread::sleep(std::time::Duration::from_millis(50));\r\n                }\r\n            });\r\n        })\r\n        .expect(\"Failed to spawn thread\");\r\n}\r\n\r\nfn bridge_generate_requests(\r\n    bridge: ResMut<Bridge>,\r\n    mut events: EventReader<TextInferenceEvent>,\r\n    prompts: Res<TextPromptHandles>,\r\n    text_assets: Res<Assets<TextAsset>>,\r\n) {\r\n    for event in events.read() {\r\n        if let TextInferenceEvent::Request { session_id, prompt } = event {\r\n            debug!(\r\n                \"Received generate request for session {:?}, sending over bridge to worker thread\",\r\n                session_id\r\n            );\r\n\r\n            // we gotta load the prompt from the asset server to materialize it before we can send it\r\n            let handle = match prompt {\r\n                TextPrompt::Raw { .. } => &prompts.raw,\r\n                TextPrompt::Chat { .. } => &prompts.chat,\r\n            };\r\n            let prompt_asset = match text_assets.get(handle) {\r\n                Some(asset) => asset,\r\n                None => {\r\n                    error!(\r\n                        \"Failed to load prompt asset {:?} for prompt type {:?}\",\r\n                        handle,\r\n                        std::any::type_name_of_val(&prompt)\r\n                    );\r\n                    continue;\r\n                }\r\n            };\r\n            let materialized_prompt = MaterializedTextPrompt {\r\n                prompt: prompt.clone(),\r\n                materialized: match prompt {\r\n                    TextPrompt::Raw { content, .. } => {\r\n                        prompt_asset.value.replace(\"{{content}}\", content)\r\n                    }\r\n                    TextPrompt::Chat { chat_history, .. } => {\r\n                        prompt_asset.value.replace(\"{{chat_history}}\", chat_history)\r\n                    }\r\n                },\r\n            };\r\n\r\n            info!(\r\n                \"Sending prompt to text generation worker:\\n{}\",\r\n                materialized_prompt.materialized\r\n            );\r\n\r\n            if let Err(e) = bridge.sender.send(ThreadboundMessage::Generate {\r\n                session_id: *session_id,\r\n                prompt: materialized_prompt,\r\n            }) {\r\n                error!(\"Threadbound channel failure: {}\", e);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfn bridge_generate_responses(bridge: ResMut<Bridge>, mut events: EventWriter<TextInferenceEvent>) {\r\n    for msg in bridge.receiver.try_iter() {\r\n        match msg {\r\n            GameboundMessage::Response {\r\n                session_id,\r\n                prompt,\r\n                response,\r\n            } => {\r\n                let event = TextInferenceEvent::Response {\r\n                    session_id,\r\n                    response,\r\n                    prompt,\r\n                };\r\n                debug!(\"Received bridge response, sending game event {:?}\", event);\r\n                events.send(event);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\plugins\\src\\inspect_launch_mode_plugin.rs\r\n\r\n````rust\r\nuse bevy::input::common_conditions::input_toggle_active;\r\nuse bevy::log::LogPlugin;\r\nuse bevy::prelude::*;\r\nuse bevy_inspector_egui::quick::WorldInspectorPlugin;\r\nuse cursor_hero_camera::camera_plugin::CameraPlugin;\r\nuse cursor_hero_memory::prelude::MemoryPlugin;\r\nuse cursor_hero_memory::primary_window_memory_plugin::restore_window;\r\nuse cursor_hero_memory_types::prelude::MemoryConfig;\r\nuse cursor_hero_memory_types::prelude::MemoryPluginBuildConfig;\r\nuse cursor_hero_memory_types::prelude::MemoryTypesPlugin;\r\nuse cursor_hero_observation_types::observation_types_plugin::ObservationTypesPlugin;\r\nuse cursor_hero_ui_automation::prelude::UiAutomationPlugin;\r\nuse cursor_hero_ui_automation::prelude::UiAutomationTypesPlugin;\r\nuse cursor_hero_ui_watcher::ui_watcher_plugin::UiWatcherPlugin;\r\nuse cursor_hero_ui_watcher_types::ui_watcher_types_plugin::UiWatcherTypesPlugin;\r\nuse cursor_hero_version::version_plugin::Version;\r\npub struct HeadlessLaunchModePlugin;\r\n\r\nimpl Plugin for HeadlessLaunchModePlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_plugins(MemoryTypesPlugin);\r\n\r\n        let memory_config = MemoryConfig {\r\n            save_dir: \"Cursor Hero Memory (inspect mode)\".to_string(),\r\n        };\r\n        app.add_plugins(MemoryPlugin {\r\n            config: memory_config.clone(),\r\n            build_config: MemoryPluginBuildConfig {\r\n                primary_window_memory_enabled: true,\r\n                ..default()\r\n            },\r\n        });\r\n        app.add_plugins(ObservationTypesPlugin);\r\n        app.add_plugins(UiWatcherTypesPlugin);\r\n        app.add_plugins(UiWatcherPlugin);\r\n        app.add_plugins(UiAutomationTypesPlugin);\r\n        app.add_plugins(UiAutomationPlugin);\r\n        app.add_plugins(CameraPlugin);\r\n\r\n        let version = match app.world.get_resource::<Version>() {\r\n            Some(version) => version.0.clone(),\r\n            None => {\r\n                warn!(\"Version resource not found\");\r\n                \"Unknown\".to_string()\r\n            }\r\n        };\r\n        let mut window = Window {\r\n            title: format!(\"Cursor Hero Inspector v{}\", version),\r\n            resizable: true,\r\n            ..default()\r\n        };\r\n        if let Err(e) = restore_window(&memory_config, &mut window) {\r\n            error!(\"Failed to restore window: {:?}\", e);\r\n        }\r\n        app.add_plugins(\r\n            DefaultPlugins\r\n                .set(LogPlugin {\r\n                    level: bevy::log::Level::DEBUG,\r\n                    filter: \"\r\nwgpu_core=warn,\r\nwgpu_hal=warn,\r\n\"\r\n// cursor_hero=debug,\r\n                    .replace('\\n', \"\")\r\n                    .trim()\r\n                    .into(),\r\n                })\r\n                .set(WindowPlugin {\r\n                    primary_window: Some(window),\r\n                    ..default()\r\n                })\r\n                .build(),\r\n        );\r\n        // app.add_plugins(WorkerPlugin {\r\n        //     config: WorkerConfig::<ThreadboundUISnapshotMessage, GameboundUISnapshotMessage> {\r\n        //         name: \"ui_hover\".to_string(),\r\n        //         is_ui_automation_thread: true,\r\n        //         handle_threadbound_message: handle_threadbound_message,\r\n        //         handle_threadbound_message_error_handler: handle_threadbound_message_error_handler,\r\n        //         ..default()\r\n        //     },\r\n        // });\r\n        app.add_plugins(\r\n            WorldInspectorPlugin::default().run_if(input_toggle_active(false, KeyCode::Grave)),\r\n        );\r\n        app.insert_resource(ClearColor(Color::rgb(0.992, 0.714, 0.69)));\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui_automation\\src\\resolve_calculator.rs\r\n\r\n````rust\r\nuse anyhow::Result;\r\nuse cursor_hero_ui_automation_types::prelude::*;\r\nuse uiautomation::UIAutomation;\r\nuse uiautomation::UIElement;\r\npub(crate) fn resolve_calculator(\r\n    elem: &UIElement,\r\n    automation: &UIAutomation,\r\n    _focused: bool,\r\n) -> Result<AppWindow> {\r\n    let walker = automation.create_tree_walker()?;\r\n    let root = elem;\r\n\r\n    let group = root.drill(&walker, vec![1, 2, 1])?;\r\n    let expression_elem = group.drill(&walker, vec![0])?;\r\n    let expression = expression_elem\r\n        .get_name()?\r\n        .strip_prefix(\"Expression is \")\r\n        .unwrap_or_default()\r\n        .to_string();\r\n    let display = group.drill(&walker, vec![1, 0])?;\r\n    let display_text = display.get_name()?;\r\n\r\n\r\n    Ok(AppWindow::Calculator(CalculatorState {\r\n        expression: (expression_elem.try_into()?, expression),\r\n        display: (display.try_into()?, display_text),\r\n        one_button: (ElementInfo::default(), \"todo\".to_string()),\r\n        two_button: (ElementInfo::default(), \"todo\".to_string()),\r\n        three_button: (ElementInfo::default(), \"todo\".to_string()),\r\n        four_button: (ElementInfo::default(), \"todo\".to_string()),\r\n        five_button: (ElementInfo::default(), \"todo\".to_string()),\r\n        six_button: (ElementInfo::default(), \"todo\".to_string()),\r\n        seven_button: (ElementInfo::default(), \"todo\".to_string()),\r\n        eight_button: (ElementInfo::default(), \"todo\".to_string()),\r\n        nine_button: (ElementInfo::default(), \"todo\".to_string()),\r\n        zero_button: (ElementInfo::default(), \"todo\".to_string()),\r\n        add_button: (ElementInfo::default(), \"todo\".to_string()),\r\n        subtract_button: (ElementInfo::default(), \"todo\".to_string()),\r\n        multiply_button: (ElementInfo::default(), \"todo\".to_string()),\r\n        divide_button: (ElementInfo::default(), \"todo\".to_string()),\r\n        equals_button: (ElementInfo::default(), \"todo\".to_string()),\r\n        clear_button: (ElementInfo::default(), \"todo\".to_string()),\r\n        backspace_button: (ElementInfo::default(), \"todo\".to_string()),\r\n        memory_clear_button: (ElementInfo::default(), \"todo\".to_string()),\r\n        memory_recall_button: (ElementInfo::default(), \"todo\".to_string()),\r\n        memory_store_button: (ElementInfo::default(), \"todo\".to_string()),\r\n        memory_add_button: (ElementInfo::default(), \"todo\".to_string()),\r\n        memory_subtract_button: (ElementInfo::default(), \"todo\".to_string()),\r\n        period_button: (ElementInfo::default(), \"todo\".to_string()),\r\n        left_paren_button: (ElementInfo::default(), \"todo\".to_string()),\r\n        right_paren_button: (ElementInfo::default(), \"todo\".to_string()),\r\n        square_root_button: (ElementInfo::default(), \"todo\".to_string()),\r\n        factorial_button: (ElementInfo::default(), \"todo\".to_string()),\r\n        ln_button: (ElementInfo::default(), \"todo\".to_string()),\r\n        log_button: (ElementInfo::default(), \"todo\".to_string()),\r\n        pi_button: (ElementInfo::default(), \"todo\".to_string()),\r\n        e_button: (ElementInfo::default(), \"todo\".to_string()),\r\n        abs_button: (ElementInfo::default(), \"todo\".to_string()),\r\n        x_y_button: (ElementInfo::default(), \"todo\".to_string()),\r\n        ten_to_x_button: (ElementInfo::default(), \"todo\".to_string()),\r\n        square_button: (ElementInfo::default(), \"todo\".to_string()),\r\n    }))\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui_automation\\src\\formatting.rs\r\n\r\n````rust\r\nuse uiautomation::UIAutomation;\r\nuse uiautomation::UIElement;\r\n\r\npub fn get_tree_string(element: &UIElement) -> Result<String, uiautomation::Error> {\r\n    let automation = UIAutomation::new()?;\r\n    format_tree_recursive(element, &automation, 0)\r\n}\r\nfn format_tree_recursive(\r\n    element: &UIElement,\r\n    automation: &UIAutomation,\r\n    depth: usize,\r\n) -> Result<String, uiautomation::Error> {\r\n    // Format the current element's label.\r\n    let mut result = format!(\r\n        \"{}{}\\n\",\r\n        \" \".repeat(depth * 2), // Increase indentation with depth.\r\n        format_tree_label(element)\r\n    );\r\n\r\n    // Use the TreeWalker to navigate the children.\r\n    let walker = automation.create_tree_walker()?;\r\n    if let Ok(child) = walker.get_first_child(element) {\r\n        // Recursively format the child and any siblings.\r\n        result.push_str(&format_tree_recursive(&child, automation, depth + 1)?);\r\n        let mut next_sibling = child;\r\n        while let Ok(sibling) = walker.get_next_sibling(&next_sibling) {\r\n            result.push_str(&format_tree_recursive(&sibling, automation, depth + 1)?);\r\n            next_sibling = sibling;\r\n        }\r\n    }\r\n    Ok(result)\r\n}\r\nfn format_tree_label(element: &UIElement) -> String {\r\n    format!(\r\n        \"name={} control_type={} class_name={} runtime_id={} rect={}\",\r\n        element\r\n            .get_name()\r\n            .map(|name| format!(\"{:?}\", name))\r\n            .unwrap_or_else(|_| \"(null)\".to_string()),\r\n        element\r\n            .get_control_type()\r\n            .map(|ct| format!(\"{:?}\", ct))\r\n            .unwrap_or_else(|_| \"unknown control type\".to_string()),\r\n        element\r\n            .get_classname()\r\n            .map(|name| format!(\"{:?}\", name))\r\n            .unwrap_or_else(|_| \"(null)\".to_string()),\r\n        element\r\n            .get_runtime_id()\r\n            .map(|id| format!(\"{:?}\", id))\r\n            .unwrap_or_else(|_| \"(null)\".to_string()),\r\n        element\r\n            .get_bounding_rectangle()\r\n            .map(|rect| format!(\"{:?}\", rect))\r\n            .unwrap_or_else(|_| \"(null)\".to_string()),\r\n    )\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\sprint_tool_types\\src\\sprint_tool_types_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n\r\npub struct SprintToolTypesPlugin;\r\n\r\nimpl Plugin for SprintToolTypesPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_event::<SprintEvent>();\r\n    }\r\n}\r\n\r\n#[derive(Event, Debug, Reflect)]\r\npub enum SprintEvent {\r\n    Active { character_id: Entity, throttle: f32 },\r\n    Stop { character_id: Entity },\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\physics\\src\\lib.rs\r\n\r\n````rust\r\npub mod damping_plugin;\r\npub mod physics_plugin;\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\secret\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_secret\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\ncursor_hero_secret_types = { workspace = true }\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\text_asset_types\\src\\text_asset_types_plugin.rs\r\n\r\n````rust\r\nuse crate::prelude::*;\r\nuse bevy::prelude::*;\r\n\r\npub struct TextAssetTypesPlugin;\r\n\r\nimpl Plugin for TextAssetTypesPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<TextAsset>();\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\start_menu\\src\\start_menu_button_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse bevy_xpbd_2d::components::Collider;\r\nuse bevy_xpbd_2d::components::RigidBody;\r\nuse bevy_xpbd_2d::components::Sensor;\r\nuse cursor_hero_cursor_types::prelude::*;\r\nuse cursor_hero_start_menu_types::prelude::*;\r\nuse cursor_hero_taskbar_types::prelude::*;\r\n\r\npub struct StartMenuButtonPlugin;\r\n\r\nimpl Plugin for StartMenuButtonPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Update, add_start_menu_button_to_new_taskbars);\r\n        app.add_systems(Update, click_listener);\r\n        app.add_systems(Update, visuals);\r\n    }\r\n}\r\n\r\nfn add_start_menu_button_to_new_taskbars(\r\n    asset_server: Res<AssetServer>,\r\n    mut commands: Commands,\r\n    mut taskbar_events: EventReader<TaskbarEvent>,\r\n    taskbar_query: Query<(&Taskbar, &Transform, &Parent)>,\r\n) {\r\n    for event in taskbar_events.read() {\r\n        let TaskbarEvent::Populate { taskbar_id } = event;\r\n        let Ok(taskbar) = taskbar_query.get(*taskbar_id) else {\r\n            warn!(\"Taskbar {:?} not found\", taskbar_id);\r\n            continue;\r\n        };\r\n        let (taskbar, taskbar_transform, taskbar_parent) = taskbar;\r\n        let taskbar_size = taskbar.size;\r\n        let start_menu_button_size = Vec2::new(48.0, 40.0);\r\n        let start_menu_button_translation = Vec3::new(\r\n            -taskbar_size.x / 2.0 + start_menu_button_size.x / 2.0,\r\n            0.0,\r\n            1.0,\r\n        ) + taskbar_transform.translation;\r\n        info!(\"Adding start menu button for taskbar {:?}\", taskbar_id);\r\n        commands\r\n            .entity(taskbar_parent.get())\r\n            .with_children(|parent| {\r\n                parent.spawn((\r\n                    SpriteBundle {\r\n                        sprite: Sprite {\r\n                            custom_size: Some(start_menu_button_size),\r\n                            ..default()\r\n                        },\r\n                        texture: asset_server\r\n                            .load(\"textures/environment/game/start_menu_button.png\"),\r\n                        transform: Transform::from_translation(start_menu_button_translation),\r\n                        ..Default::default()\r\n                    },\r\n                    RigidBody::Static,\r\n                    Collider::cuboid(start_menu_button_size.x, start_menu_button_size.y),\r\n                    Sensor,\r\n                    Name::new(\"Start Menu Button\"),\r\n                    StartMenuButton,\r\n                    Hoverable,\r\n                    Clickable,\r\n                ));\r\n            });\r\n    }\r\n}\r\n\r\nfn click_listener(\r\n    mut click_events: EventReader<ClickEvent>,\r\n    start_menu_button_query: Query<&Children, With<StartMenuButton>>,\r\n    start_menu_query: Query<(), With<StartMenu>>,\r\n    mut start_menu_events: EventWriter<StartMenuEvent>,\r\n) {\r\n    for event in click_events.read() {\r\n        let ClickEvent::Clicked {\r\n            target_id,\r\n            cursor_id: _,\r\n            way,\r\n        } = event\r\n        else {\r\n            continue;\r\n        };\r\n        if way != &Way::Left {\r\n            continue;\r\n        }\r\n        if let Ok(children) = start_menu_button_query.get(*target_id) {\r\n            info!(\"Start menu button clicked\");\r\n            let open = children\r\n                .iter()\r\n                .any(|child| start_menu_query.get(*child).is_ok());\r\n            if open {\r\n                start_menu_events.send(StartMenuEvent::Close {\r\n                    start_menu_button_id: *target_id,\r\n                });\r\n            } else {\r\n                start_menu_events.send(StartMenuEvent::Open {\r\n                    start_menu_button_id: *target_id,\r\n                });\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nenum VisualState {\r\n    Normal,\r\n    Hovered,\r\n    Pressed,\r\n}\r\n\r\n#[allow(clippy::type_complexity)]\r\nfn visuals(\r\n    mut start_menu_button_query: Query<\r\n        (&mut Sprite, Option<&Pressed>, Option<&Hovered>),\r\n        With<StartMenuButton>,\r\n    >,\r\n) {\r\n    for (mut sprite, pressed, hovered) in start_menu_button_query.iter_mut() {\r\n        let mut visual_state = VisualState::Normal;\r\n        if pressed.is_some() {\r\n            visual_state = VisualState::Pressed;\r\n        } else if hovered.is_some() {\r\n            visual_state = VisualState::Hovered;\r\n        }\r\n        match visual_state {\r\n            VisualState::Normal => {\r\n                sprite.color = Color::WHITE;\r\n            }\r\n            VisualState::Hovered => {\r\n                sprite.color = Color::ORANGE_RED;\r\n            }\r\n            VisualState::Pressed => {\r\n                sprite.color = Color::RED;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ollama_types\\src\\lib.rs\r\n\r\n````rust\r\npub mod ollama_types;\r\npub mod ollama_types_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::ollama_types::*;\r\n    pub use crate::ollama_types_plugin::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui_automation\\src\\resolve_app.rs\r\n\r\n````rust\r\nuse cursor_hero_ui_automation_types::prelude::*;\r\nuse uiautomation::controls::ControlType;\r\nuse uiautomation::UIAutomation;\r\nuse uiautomation::UIElement;\r\n\r\nuse anyhow::Context;\r\nuse anyhow::Result;\r\n\r\nuse crate::resolve_calculator::resolve_calculator;\r\nuse crate::resolve_vscode::resolve_vscode;\r\n\r\npub(crate) fn resolve_app(\r\n    elem: &UIElement,\r\n    automation: &UIAutomation,\r\n    focused: bool,\r\n) -> Result<AppWindow> {\r\n    match (\r\n        elem.get_name(),\r\n        elem.get_control_type(),\r\n        elem.get_classname(),\r\n    ) {\r\n        // (Ok(name), Ok(ControlType::Pane), Ok(class_name))\r\n        //     if name.ends_with(\"Visual Studio Code\") && class_name == \"Chrome_WidgetWin_1\" =>\r\n        // {\r\n        //     resolve_vscode(elem, automation, focused).context(\"resolving vscode\")\r\n        // }\r\n        (Ok(name), Ok(ControlType::Window), Ok(class_name))\r\n            if name == \"Calculator\" && class_name == \"ApplicationFrameWindow\" =>\r\n        {\r\n            resolve_calculator(elem, automation, focused).context(\"resolving calculator\")\r\n        }\r\n        _ => Ok(AppWindow::Unknown),\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\taskbar_types\\src\\lib.rs\r\n\r\n````rust\r\npub mod taskbar_types;\r\npub mod taskbar_types_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::taskbar_types::*;\r\n    pub use crate::taskbar_types_plugin::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\taskbar\\src\\taskbar_plugin.rs\r\n\r\n````rust\r\nuse crate::taskbar_spawn_plugin::TaskbarSpawnPlugin;\r\nuse bevy::prelude::*;\r\n\r\npub struct TaskbarPlugin;\r\n\r\nimpl Plugin for TaskbarPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_plugins(TaskbarSpawnPlugin);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui_automation\\examples\\calculator_example.rs\r\n\r\n````rust\r\n#![feature(let_chains)]\r\nuse anyhow::Result;\r\nuse bevy::input::common_conditions::input_toggle_active;\r\nuse bevy::log::LogPlugin;\r\nuse bevy::prelude::*;\r\nuse bevy::window::PrimaryWindow;\r\nuse bevy_inspector_egui::quick::WorldInspectorPlugin;\r\nuse cursor_hero_memory::primary_window_memory_plugin::PrimaryWindowMemoryPlugin;\r\nuse cursor_hero_ui_automation::prelude::*;\r\nuse cursor_hero_worker::prelude::WorkerMessage;\r\nuse cursor_hero_worker::prelude::Sender;\r\nuse cursor_hero_worker::prelude::WorkerConfig;\r\nuse cursor_hero_worker::prelude::WorkerPlugin;\r\nfn main() {\r\n    let mut app = App::new();\r\n    app.add_plugins(\r\n        DefaultPlugins\r\n            .set(LogPlugin {\r\n                level: bevy::log::Level::DEBUG,\r\n                filter: \"\r\ninfo,\r\nwgpu_core=warn,\r\nwgpu_hal=warn,\r\ncalculator_example=trace,\r\ncursor_hero_worker=debug,\r\n\"\r\n                .replace('\\n', \"\")\r\n                .trim()\r\n                .into(),\r\n            })\r\n            .build(),\r\n    );\r\n    app.add_plugins(WorkerPlugin {\r\n        config: WorkerConfig::<ThreadboundUISnapshotMessage, GameboundUISnapshotMessage> {\r\n            name: \"calculator\".to_string(),\r\n            is_ui_automation_thread: true,\r\n            handle_threadbound_message: handle_threadbound_message,\r\n            ..default()\r\n        },\r\n    });\r\n    app.add_plugins(\r\n        WorldInspectorPlugin::default().run_if(input_toggle_active(false, KeyCode::Grave)),\r\n    );\r\n    app.add_plugins(PrimaryWindowMemoryPlugin);\r\n    app.insert_resource(ClearColor(Color::rgb(0.992, 0.714, 0.69)));\r\n    app.add_systems(Startup, spawn_camera);\r\n    app.add_systems(\r\n        Update,\r\n        step_1_of_making_the_calculators_in_the_game_match_the_calculator_apps_running_in_the_host,\r\n    );\r\n    app.add_systems(\r\n        Update,\r\n        step_2_of_making_the_calculators_in_the_game_match_the_calculator_apps_running_in_the_host,\r\n    );\r\n    app.run();\r\n}\r\n\r\nfn spawn_camera(mut commands: Commands) {\r\n    commands.spawn(Camera2dBundle::default());\r\n}\r\n\r\n#[derive(Debug, Reflect, Clone, Event)]\r\nenum ThreadboundUISnapshotMessage {\r\n    RequestUISnapshot,\r\n}\r\nimpl WorkerMessage for ThreadboundUISnapshotMessage {}\r\n\r\n#[derive(Debug, Reflect, Clone, Event)]\r\nenum GameboundUISnapshotMessage {\r\n    UISnapshot(UiSnapshot),\r\n}\r\nimpl WorkerMessage for GameboundUISnapshotMessage {}\r\n\r\nfn handle_threadbound_message(\r\n    msg: &ThreadboundUISnapshotMessage,\r\n    reply_tx: &Sender<GameboundUISnapshotMessage>,\r\n) -> Result<()> {\r\n    let ThreadboundUISnapshotMessage::RequestUISnapshot = msg;\r\n    debug!(\"getting state of host calculators\");\r\n    let snapshot = take_snapshot()?;\r\n    if let Err(e) = reply_tx.send(GameboundUISnapshotMessage::UISnapshot(snapshot)) {\r\n        error!(\"Failed to send snapshot: {:?}\", e);\r\n    }\r\n    Ok(())\r\n}\r\n\r\nfn step_1_of_making_the_calculators_in_the_game_match_the_calculator_apps_running_in_the_host(\r\n    // mut data: ResMut<UIData>,\r\n    mut cooldown: Local<Option<Timer>>,\r\n    time: Res<Time>,\r\n    mut events: EventWriter<ThreadboundUISnapshotMessage>,\r\n    window: Query<&Window, With<PrimaryWindow>>,\r\n) {\r\n    let Ok(window) = window.get_single() else {\r\n        return;\r\n    };\r\n    if window.cursor_position().is_some() {\r\n        return;\r\n    }\r\n    let cooldown_over = if let Some(cooldown) = cooldown.as_mut() {\r\n        if cooldown.tick(time.delta()).just_finished() {\r\n            cooldown.reset();\r\n            true\r\n        } else {\r\n            false\r\n        }\r\n    } else {\r\n        cooldown.replace(Timer::from_seconds(0.5, TimerMode::Repeating));\r\n        true\r\n    };\r\n    if !cooldown_over {\r\n        return;\r\n    }\r\n\r\n    // if data.in_flight {\r\n    //     warn!(\"Too fast!\");\r\n    //     return;\r\n    // }\r\n\r\n    events.send(ThreadboundUISnapshotMessage::RequestUISnapshot);\r\n    // data.in_flight = true;\r\n}\r\n\r\nfn step_2_of_making_the_calculators_in_the_game_match_the_calculator_apps_running_in_the_host(\r\n    mut snapshot: EventReader<GameboundUISnapshotMessage>,\r\n    calculator_query: Query<&Calculator>,\r\n    mut commands: Commands,\r\n) {\r\n    for msg in snapshot.read() {\r\n        let GameboundUISnapshotMessage::UISnapshot(snapshot) = msg;\r\n        // debug!(\"Received snapshot: {:?}\", snapshot);\r\n        for app in snapshot.app_windows.iter() {\r\n            let AppWindow::Calculator(calculator) = app else {\r\n                continue;\r\n            };\r\n            debug!(\"Received calculator: {:?}\", calculator);\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui_inspector\\src\\ui_inspector_plugin.rs\r\n\r\n````rust\r\nuse std::time::Duration;\r\n\r\nuse bevy::input::common_conditions::input_toggle_active;\r\nuse bevy::prelude::*;\r\nuse bevy::window::PrimaryWindow;\r\nuse bevy_egui::egui;\r\nuse bevy_egui::egui::Align2;\r\nuse bevy_egui::EguiContexts;\r\nuse bevy_inspector_egui::reflect_inspector::InspectorUi;\r\nuse cursor_hero_ui_automation::prelude::*;\r\nuse cursor_hero_ui_hover_types::prelude::GameHoveredIndicator;\r\nuse cursor_hero_ui_hover_types::prelude::HostHoveredIndicator;\r\nuse cursor_hero_ui_inspector_types::prelude::FetchingState;\r\nuse cursor_hero_ui_inspector_types::prelude::UIData;\r\nuse cursor_hero_winutils::win_mouse::get_cursor_position;\r\nuse cursor_hero_worker::prelude::anyhow::Context;\r\nuse cursor_hero_worker::prelude::anyhow::Error;\r\nuse cursor_hero_worker::prelude::anyhow::Result;\r\nuse cursor_hero_worker::prelude::Sender;\r\nuse cursor_hero_worker::prelude::WorkerConfig;\r\nuse cursor_hero_worker::prelude::WorkerMessage;\r\nuse cursor_hero_worker::prelude::WorkerPlugin;\r\nuse itertools::Itertools;\r\nuse uiautomation::UIAutomation;\r\n\r\npub struct UiInspectorPlugin;\r\n\r\nimpl Plugin for UiInspectorPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_plugins(WorkerPlugin {\r\n            config: WorkerConfig::<ThreadboundUISnapshotMessage, GameboundUISnapshotMessage, ()> {\r\n                name: \"ui_hover\".to_string(),\r\n                is_ui_automation_thread: true,\r\n                handle_threadbound_message: handle_threadbound_message,\r\n                handle_threadbound_message_error_handler: handle_threadbound_message_error_handler,\r\n                ..default()\r\n            },\r\n        });\r\n        let condition = input_toggle_active(false, KeyCode::Grave);\r\n        app.add_systems(Update, periodic_snapshot.run_if(condition.clone()));\r\n        app.add_systems(Update, fetch_requested.run_if(condition.clone()));\r\n        app.add_systems(Update, receive.run_if(condition.clone()));\r\n        app.add_systems(Update, gui.run_if(condition));\r\n        // app.add_systems(Update, gui.after(EguiSet::InitContexts));\r\n    }\r\n}\r\n\r\n#[derive(Debug, Reflect, Clone, Event)]\r\nenum ThreadboundUISnapshotMessage {\r\n    CaptureHovered {\r\n        pos: IVec2,\r\n    },\r\n    ChildrenFetchRequest {\r\n        drill_id: DrillId,\r\n        runtime_id: RuntimeId,\r\n    },\r\n}\r\nimpl WorkerMessage for ThreadboundUISnapshotMessage {}\r\n\r\n#[derive(Debug, Reflect, Clone, Event)]\r\nenum GameboundUISnapshotMessage {\r\n    Hovered {\r\n        ui_tree: ElementInfo,\r\n        start: ElementInfo,\r\n        hovered: ElementInfo,\r\n    },\r\n    ChildrenFetchResponse {\r\n        drill_id: DrillId,\r\n        runtime_id: RuntimeId,\r\n        children: Vec<ElementInfo>,\r\n    },\r\n    Error,\r\n}\r\nimpl WorkerMessage for GameboundUISnapshotMessage {}\r\n\r\nfn handle_threadbound_message_error_handler(\r\n    _msg: &ThreadboundUISnapshotMessage,\r\n    reply_tx: &Sender<GameboundUISnapshotMessage>,\r\n    _state: &mut (),\r\n    _error: &Error,\r\n) -> Result<()> {\r\n    reply_tx.send(GameboundUISnapshotMessage::Error)?;\r\n    Ok(())\r\n}\r\nfn handle_threadbound_message(\r\n    msg: &ThreadboundUISnapshotMessage,\r\n    reply_tx: &Sender<GameboundUISnapshotMessage>,\r\n    _state: &mut (),\r\n) -> Result<()> {\r\n    match msg {\r\n        ThreadboundUISnapshotMessage::CaptureHovered { pos } => {\r\n            debug!(\"taking snapshot\");\r\n            let hovered = find_element_at(*pos)?;\r\n            let hovered_info = gather_single_element_info(&hovered)?;\r\n            let gathered = gather_incomplete_ui_tree_starting_deep(hovered)?;\r\n            if let Err(e) = reply_tx.send(GameboundUISnapshotMessage::Hovered {\r\n                ui_tree: gathered.ui_tree,\r\n                start: gathered.start_info,\r\n                hovered: hovered_info,\r\n            }) {\r\n                error!(\"Failed to send snapshot: {:?}\", e);\r\n            }\r\n        }\r\n        ThreadboundUISnapshotMessage::ChildrenFetchRequest {\r\n            drill_id,\r\n            runtime_id,\r\n        } => {\r\n            debug!(\"fetching children for {:?}\", drill_id);\r\n            let automation = UIAutomation::new().context(\"creating automation\")?;\r\n            let walker = automation.create_tree_walker().context(\"creating walker\")?;\r\n            let root = automation.get_root_element().context(\"getting root\")?;\r\n            let found = root.drill(&walker, drill_id.clone()).context(\"drilling\")?;\r\n            let mut children = found\r\n                .gather_children(&walker, &StopBehaviour::EndOfSiblings)\r\n                .into_iter()\r\n                .enumerate()\r\n                .filter_map(|(i, child)| {\r\n                    gather_single_element_info(&child)\r\n                        .ok()\r\n                        .map(|mut child_info| {\r\n                            child_info.drill_id = DrillId::Child(vec![i].into_iter().collect());\r\n                            child_info\r\n                        })\r\n                })\r\n                .collect_vec();\r\n\r\n            update_drill_ids(Some(&mut children), &drill_id);\r\n            if let Err(e) = reply_tx.send(GameboundUISnapshotMessage::ChildrenFetchResponse {\r\n                drill_id: drill_id.clone(),\r\n                runtime_id: runtime_id.clone(),\r\n                children,\r\n            }) {\r\n                error!(\"Failed to send ChildrenFetchResponse: {:?}\", e);\r\n            }\r\n        }\r\n    }\r\n    Ok(())\r\n}\r\n\r\nfn fetch_requested(\r\n    mut data: ResMut<UIData>,\r\n    mut events: EventWriter<ThreadboundUISnapshotMessage>,\r\n) {\r\n    for (key, state) in data.fetching.iter_mut() {\r\n        if let FetchingState::FetchRequest = state {\r\n            *state = FetchingState::FetchDispatched;\r\n            events.send(ThreadboundUISnapshotMessage::ChildrenFetchRequest {\r\n                drill_id: key.0.clone(),\r\n                runtime_id: key.1.clone(),\r\n            });\r\n        }\r\n    }\r\n}\r\n\r\nfn periodic_snapshot(\r\n    mut data: ResMut<UIData>,\r\n    mut cooldown: Local<Option<Timer>>,\r\n    time: Res<Time>,\r\n    mut events: EventWriter<ThreadboundUISnapshotMessage>,\r\n    game_hovered_query: Query<&GameHoveredIndicator>,\r\n    host_hovered_query: Query<&HostHoveredIndicator>,\r\n) {\r\n    // Check cooldown\r\n    let default_duration = Duration::from_secs_f32(0.5);\r\n    let Some(cooldown) = cooldown.as_mut() else {\r\n        cooldown.replace(Timer::new(default_duration, TimerMode::Repeating));\r\n        return;\r\n    };\r\n    if cooldown.tick(time.delta()).just_finished() {\r\n        cooldown.reset();\r\n    } else {\r\n        return;\r\n    }\r\n\r\n    // Check other conditions\r\n    if data.paused {\r\n        return;\r\n    }\r\n    if data.in_flight {\r\n        return;\r\n    }\r\n    let pos = match (\r\n        game_hovered_query.get_single(),\r\n        host_hovered_query.get_single(),\r\n    ) {\r\n        (Ok(GameHoveredIndicator { cursor_pos, .. }), _) => *cursor_pos,\r\n        (_, Ok(HostHoveredIndicator { cursor_pos, .. })) => *cursor_pos,\r\n        _ => return,\r\n    };\r\n\r\n\r\n    // Send snapshot request\r\n    events.send(ThreadboundUISnapshotMessage::CaptureHovered { pos });\r\n    data.in_flight = true;\r\n}\r\n\r\nfn receive(mut snapshot: EventReader<GameboundUISnapshotMessage>, mut ui_data: ResMut<UIData>) {\r\n    for msg in snapshot.read() {\r\n        match msg {\r\n            GameboundUISnapshotMessage::Error => {\r\n                ui_data.in_flight = false;\r\n            }\r\n            GameboundUISnapshotMessage::Hovered {\r\n                ui_tree,\r\n                start,\r\n                hovered,\r\n            } => {\r\n                ui_data.in_flight = false;\r\n                ui_data.ui_tree = ui_tree.clone();\r\n                ui_data.start = start.clone();\r\n                ui_data.hovered = hovered.clone();\r\n                ui_data.selected = Some(start.drill_id.clone());\r\n                ui_data.expanded = ui_tree\r\n                    .get_descendents()\r\n                    .iter()\r\n                    .chain([ui_tree].iter())\r\n                    .filter(|x| x.children.is_some())\r\n                    .map(|x| x.drill_id.clone())\r\n                    .collect();\r\n                ui_data.fresh = true;\r\n                debug!(\"Received snapshot\");\r\n            }\r\n            GameboundUISnapshotMessage::ChildrenFetchResponse {\r\n                drill_id,\r\n                runtime_id,\r\n                children,\r\n            } => {\r\n                let key = (drill_id.clone(), runtime_id.clone());\r\n                if let Some(FetchingState::FetchDispatched) = ui_data.fetching.get(&key) {\r\n                    ui_data\r\n                        .fetching\r\n                        .insert(key, FetchingState::Fetched(children.clone()));\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfn gui(\r\n    mut contexts: EguiContexts,\r\n    mut ui_data: ResMut<UIData>,\r\n    type_registry: Res<AppTypeRegistry>,\r\n) {\r\n    let ctx = contexts.ctx_mut();\r\n\r\n    let mut cx = bevy_inspector_egui::reflect_inspector::Context {\r\n        world: None,\r\n        queue: None,\r\n    };\r\n\r\n    let type_registry = type_registry.0.clone();\r\n    let type_registry = type_registry.read();\r\n    let mut inspector = InspectorUi::for_bevy(&type_registry, &mut cx);\r\n\r\n    let id = egui::Id::new(\"Inspector\");\r\n    egui::Window::new(\"Inspector\")\r\n        .title_bar(false)\r\n        .id(id)\r\n        .default_pos((5.0, 5.0))\r\n        .default_width(1200.0)\r\n        .default_height(1000.0)\r\n        .show(ctx, |ui| {\r\n            egui::SidePanel::left(id.with(\"tree\"))\r\n                .resizable(true)\r\n                .width_range(100.0..=4000.0)\r\n                .default_width(600.0)\r\n                .show_inside(ui, |ui| {\r\n                    ui.vertical_centered(|ui| {\r\n                        ui.heading(\"UI Tree\");\r\n                    });\r\n                    egui::ScrollArea::both().show(ui, |ui| {\r\n                        let id = id.with(ui_data.ui_tree.runtime_id.clone());\r\n                        let mut elem = ui_data.ui_tree.clone();\r\n                        ui_for_element_info(id, ui, &mut ui_data, &mut elem, &mut inspector);\r\n                        ui_data.ui_tree = elem;\r\n                        ui.allocate_space(ui.available_size());\r\n                    });\r\n                });\r\n\r\n            egui::TopBottomPanel::bottom(id.with(\"invisible bottom panel\"))\r\n                .show_separator_line(false)\r\n                .show_inside(ui, |_| ());\r\n\r\n            egui::CentralPanel::default().show_inside(ui, |ui| {\r\n                ui.vertical_centered(|ui| {\r\n                    ui.heading(\"Properties\");\r\n                });\r\n                let id = ui_data.selected.clone();\r\n                let Some(id) = id else {\r\n                    return;\r\n                };\r\n                let found = ui_data.ui_tree.lookup_drill_id_mut(id);\r\n                debug!(\"found {:?}\", found);\r\n                let Some(x) = found else {\r\n                    return;\r\n                };\r\n                inspector.ui_for_reflect_readonly(x, ui);\r\n                ui.separator();\r\n                ui.label(\"drill_id\");\r\n                let drill_id = x.drill_id.to_string();\r\n                inspector.ui_for_reflect_readonly(&drill_id, ui);\r\n                if ui.button(\"copy\").clicked() {\r\n                    ui.output_mut(|out| {\r\n                        out.copied_text = drill_id.clone();\r\n                    });\r\n                    info!(\"Copied drill_id {} to clipboard\", drill_id);\r\n                }\r\n                ui.label(\"runtime_id\");\r\n                let runtime_id = x.runtime_id.to_string();\r\n                inspector.ui_for_reflect_readonly(&runtime_id, ui);\r\n                if ui.button(\"copy\").clicked() {\r\n                    ui.output_mut(|out| {\r\n                        out.copied_text = runtime_id.clone();\r\n                    });\r\n                    info!(\"Copied runtime_id {} to clipboard\", runtime_id);\r\n                }\r\n                // inspector.ui_for_reflect_readonly(&data, ui);\r\n            }); \r\n        });\r\n\r\n    let id = egui::Id::new(\"Paused\");\r\n    egui::Window::new(\"Paused\")\r\n        .id(id)\r\n        .title_bar(false)\r\n        .default_pos((ctx.screen_rect().max.x - 200.0, 5.0))\r\n        .show(ctx, |ui| {\r\n            ui.checkbox(&mut ui_data.paused, \"Paused\");\r\n        });\r\n    ui_data.fresh = false;\r\n}\r\n\r\n#[allow(clippy::too_many_arguments)]\r\nfn ui_for_element_info(\r\n    id: egui::Id,\r\n    ui: &mut egui::Ui,\r\n    data: &mut UIData,\r\n    element_info: &mut ElementInfo,\r\n    _inspector: &mut InspectorUi,\r\n) {\r\n    let default_open = data.expanded.contains(&element_info.drill_id);\r\n    let mut expando = egui::collapsing_header::CollapsingState::load_with_default_open(\r\n        ui.ctx(),\r\n        id,\r\n        default_open,\r\n    );\r\n    if data.fresh {\r\n        expando.set_open(default_open);\r\n        data.fetching.clear();\r\n    }\r\n    if expando.is_open() && element_info.children.is_none() {\r\n        let key = (\r\n            element_info.drill_id.clone(),\r\n            element_info.runtime_id.clone(),\r\n        );\r\n        let found = data.fetching.get_mut(&key);\r\n        if !found.is_some() {\r\n            data.fetching.insert(key, FetchingState::FetchRequest);\r\n        } else if let Some(FetchingState::Fetched(ref mut children)) = found {\r\n            element_info.children = Some(std::mem::take(children));\r\n            data.fetching.remove(&key);\r\n        } else {\r\n            ui.label(\"fetching...\");\r\n        }\r\n    }\r\n    expando\r\n        .show_header(ui, |ui| {\r\n            let mut selected = data.selected == Some(element_info.drill_id.clone());\r\n            if selected && data.fresh {\r\n                ui.scroll_to_cursor(Some(egui::Align::Center));\r\n            }\r\n            let label = if element_info.automation_id.is_empty() {\r\n                format!(\r\n                    \"{:?} | {}\",\r\n                    element_info.name, element_info.localized_control_type\r\n                )\r\n            } else {\r\n                format!(\r\n                    \"{:?} | {} | {}\",\r\n                    element_info.name,\r\n                    element_info.localized_control_type,\r\n                    element_info.automation_id\r\n                )\r\n            };\r\n            if ui.toggle_value(&mut selected, label).changed() {\r\n                data.selected = if selected {\r\n                    Some(element_info.drill_id.clone())\r\n                } else {\r\n                    None\r\n                };\r\n            };\r\n        })\r\n        .body(|ui| {\r\n            if let Some(ref mut children) = element_info.children {\r\n                for child in children.iter_mut() {\r\n                    ui_for_element_info(\r\n                        id.with(child.runtime_id.clone()),\r\n                        ui,\r\n                        data,\r\n                        child,\r\n                        _inspector,\r\n                    );\r\n                }\r\n            }\r\n        });\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\toolbelt\\src\\hover_frame.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse cursor_hero_cursor_types::prelude::*;\r\n\r\n#[derive(Component, Debug)]\r\npub struct ToolFrame;\r\n\r\n#[allow(clippy::type_complexity)]\r\npub fn insert_hover_frame(\r\n    mut reader: EventReader<HoverEvent>,\r\n    mut commands: Commands,\r\n    asset_server: Res<AssetServer>,\r\n    hovered_query: Query<&Sprite>,\r\n) {\r\n    for event in reader.read() {\r\n        if let HoverEvent::Start {\r\n            target_id,\r\n            cursor_id: _,\r\n        } = event\r\n        {\r\n            // Ensure the entity hasn't despawned since the event was sent\r\n            if commands.get_entity(*target_id).is_none() {\r\n                warn!(\"Hovered entity {:?} has despawned\", target_id);\r\n                continue;\r\n            }\r\n            let mut size = Vec2::new(200.0, 200.0);\r\n            if let Ok(hovered_sprite) = hovered_query.get(*target_id)\r\n                && let Some(hovered_size) = hovered_sprite.custom_size\r\n            {\r\n                size = hovered_size * 2.0;\r\n            }\r\n\r\n            commands.entity(*target_id).with_children(|hovered| {\r\n                hovered.spawn((\r\n                    SpriteBundle {\r\n                        sprite: Sprite {\r\n                            custom_size: Some(size),\r\n                            ..default()\r\n                        },\r\n                        texture: asset_server.load(\"textures/wood frame.png\"),\r\n                        ..default()\r\n                    },\r\n                    ToolFrame,\r\n                ));\r\n            });\r\n        }\r\n    }\r\n}\r\n#[allow(clippy::type_complexity)]\r\npub fn remove_hover_frame(\r\n    mut reader: EventReader<HoverEvent>,\r\n    mut commands: Commands,\r\n    tool_query: Query<&Children>,\r\n    frame_query: Query<Entity, With<ToolFrame>>,\r\n) {\r\n    for event in reader.read() {\r\n        if let HoverEvent::End {\r\n            target_id,\r\n            cursor_id: _,\r\n        } = event\r\n        {\r\n            if let Ok(tool_children) = tool_query.get(*target_id) {\r\n                for tool_child in tool_children.iter() {\r\n                    if let Ok(frame_id) = frame_query.get(*tool_child) {\r\n                        commands.entity(*target_id).remove_children(&[frame_id]);\r\n                        commands.entity(frame_id).despawn();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui_automation_types\\src\\ui_automation_types.rs\r\n\r\n````rust\r\nuse crate::prelude::CalculatorState;\r\nuse crate::vscode_ui_types::*;\r\nuse bevy::prelude::*;\r\nuse itertools::Itertools;\r\nuse serde::Deserialize;\r\nuse serde::Serialize;\r\nuse std::collections::VecDeque;\r\nuse std::fmt;\r\nuse std::fmt::Display;\r\nuse std::fmt::Formatter;\r\nuse uiautomation::core::UICondition;\r\nuse uiautomation::UIAutomation;\r\nuse uiautomation::UIElement;\r\n\r\npub trait HexList {\r\n    fn to_hex_list(&self) -> String;\r\n}\r\nimpl HexList for Vec<i32> {\r\n    fn to_hex_list(&self) -> String {\r\n        format!(\r\n            \"[{}]\",\r\n            self.iter()\r\n                .map(|x| format!(\"{:X}\", x).to_string())\r\n                .collect::<Vec<String>>()\r\n                .join(\",\")\r\n        )\r\n    }\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Reflect)]\r\npub struct UiSnapshot {\r\n    pub app_windows: Vec<AppWindow>,\r\n}\r\nimpl UiSnapshot {\r\n    fn as_long_string(&self) -> String {\r\n        let mut s = String::new();\r\n        s.push_str(\"# UI Snapshot\\n\");\r\n        for window in self.app_windows.iter() {\r\n            s.push_str(&format!(\"## {}\\n\\n{}\\n\", window.variant_name(), window));\r\n        }\r\n        s\r\n    }\r\n}\r\nimpl Display for UiSnapshot {\r\n    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {\r\n        writeln!(f, \"UI Snapshot ({} windows)\", self.app_windows.len())?;\r\n        fmt::Result::Ok(())\r\n    }\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Reflect)]\r\npub enum AppWindow {\r\n    VSCode(VSCodeWindow),\r\n    Calculator(CalculatorState),\r\n    Unknown,\r\n}\r\n\r\nimpl AppWindow {\r\n    pub fn variant_name(&self) -> String {\r\n        match self {\r\n            AppWindow::VSCode(_) => \"VSCode\".to_string(),\r\n            AppWindow::Calculator(_) => \"Calculator\".to_string(),\r\n            AppWindow::Unknown => \"Unknown\".to_string(),\r\n        }\r\n    }\r\n}\r\n\r\nimpl Display for AppWindow {\r\n    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {\r\n        match self {\r\n            AppWindow::VSCode(window) => write!(f, \"{}\", window),\r\n            AppWindow::Calculator(window) => write!(f, \"{}\", window),\r\n            AppWindow::Unknown => write!(f, \"Unknown\"),\r\n        }\r\n    }\r\n}\r\n\r\npub fn all_of(\r\n    automation: &UIAutomation,\r\n    conditions: Vec<UICondition>,\r\n) -> Result<UICondition, uiautomation::Error> {\r\n    let iter = conditions.into_iter();\r\n    let mut current = automation.create_true_condition()?;\r\n\r\n    for condition in iter {\r\n        current = automation.create_and_condition(current, condition)?;\r\n    }\r\n\r\n    Ok(current)\r\n}\r\n\r\npub trait ToBevyIRect {\r\n    fn to_bevy_irect(&self) -> IRect;\r\n}\r\nimpl ToBevyIRect for uiautomation::types::Rect {\r\n    fn to_bevy_irect(&self) -> IRect {\r\n        IRect {\r\n            min: IVec2::new(self.get_left(), self.get_top()),\r\n            max: IVec2::new(self.get_right(), self.get_bottom()),\r\n        }\r\n    }\r\n}\r\n\r\n/// Defines enum for `windows::Win32::UI::Accessibility::UIA_CONTROLTYPE_ID`.\r\n///\r\n/// Contains the named constants used to identify Microsoft UI Automation control types.\r\n#[repr(u32)]\r\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Reflect, Serialize, Deserialize)]\r\npub enum ControlType {\r\n    /// Identifies the\u00a0Button\u00a0control type.\r\n    Button = 50000u32,\r\n    /// Identifies the\u00a0Calendar\u00a0control type.\r\n    Calendar = 50001u32,\r\n    /// Identifies the\u00a0CheckBox\u00a0control type.\r\n    CheckBox = 50002u32,\r\n    /// Identifies the\u00a0ComboBox\u00a0control type.\r\n    ComboBox = 50003u32,\r\n    /// Identifies the\u00a0Edit\u00a0control type.\r\n    Edit = 50004u32,\r\n    /// Identifies the\u00a0Hyperlink\u00a0control type.\r\n    Hyperlink = 50005u32,\r\n    /// Identifies the\u00a0Image\u00a0control type.\r\n    Image = 50006u32,\r\n    /// Identifies the\u00a0ListItem\u00a0control type.\r\n    ListItem = 50007u32,\r\n    /// Identifies the\u00a0List\u00a0control type.\r\n    List = 50008u32,\r\n    /// Identifies the\u00a0Menu\u00a0control type.\r\n    Menu = 50009u32,\r\n    /// Identifies the\u00a0MenuBar\u00a0control type.\r\n    MenuBar = 50010u32,\r\n    /// Identifies the\u00a0MenuItem\u00a0control type.\r\n    MenuItem = 50011u32,\r\n    /// Identifies the\u00a0ProgressBar\u00a0control type.\r\n    ProgressBar = 50012u32,\r\n    /// Identifies the\u00a0RadioButton\u00a0control type.\r\n    RadioButton = 50013u32,\r\n    /// Identifies the\u00a0ScrollBar\u00a0control type.\r\n    ScrollBar = 50014u32,\r\n    /// Identifies the\u00a0Slider\u00a0control type.\r\n    Slider = 50015u32,\r\n    /// Identifies the\u00a0Spinner\u00a0control type.\r\n    Spinner = 50016u32,\r\n    /// Identifies the\u00a0StatusBar\u00a0control type.\r\n    StatusBar = 50017u32,\r\n    /// Identifies the\u00a0Tab\u00a0control type.\r\n    Tab = 50018u32,\r\n    /// Identifies the\u00a0TabItem\u00a0control type.\r\n    TabItem = 50019u32,\r\n    /// Identifies the\u00a0Text\u00a0control type.\r\n    Text = 50020u32,\r\n    /// Identifies the\u00a0ToolBar\u00a0control type.\r\n    ToolBar = 50021u32,\r\n    /// Identifies the\u00a0ToolTip\u00a0control type.\r\n    ToolTip = 50022u32,\r\n    /// Identifies the\u00a0Tree\u00a0control type.\r\n    Tree = 50023u32,\r\n    /// Identifies the\u00a0TreeItem\u00a0control type.\r\n    TreeItem = 50024u32,\r\n    /// Identifies the Custom control type. For more information, see\u00a0Custom Properties, Events, and Control Patterns.\r\n    Custom = 50025u32,\r\n    /// Identifies the\u00a0Group\u00a0control type.\r\n    Group = 50026u32,\r\n    /// Identifies the\u00a0Thumb\u00a0control type.\r\n    Thumb = 50027u32,\r\n    /// Identifies the\u00a0DataGrid\u00a0control type.\r\n    DataGrid = 50028u32,\r\n    /// Identifies the\u00a0DataItem\u00a0control type.\r\n    DataItem = 50029u32,\r\n    /// Identifies the\u00a0Document\u00a0control type.\r\n    Document = 50030u32,\r\n    /// Identifies the\u00a0SplitButton\u00a0control type.\r\n    SplitButton = 50031u32,\r\n    /// Identifies the\u00a0Window\u00a0control type.\r\n    Window = 50032u32,\r\n    /// Identifies the\u00a0Pane\u00a0control type.\r\n    Pane = 50033u32,\r\n    /// Identifies the\u00a0Header\u00a0control type.\r\n    Header = 50034u32,\r\n    /// Identifies the\u00a0HeaderItem\u00a0control type.\r\n    HeaderItem = 50035u32,\r\n    /// Identifies the\u00a0Table\u00a0control type.\r\n    Table = 50036u32,\r\n    /// Identifies the\u00a0TitleBar\u00a0control type.\r\n    TitleBar = 50037u32,\r\n    /// Identifies the\u00a0Separator\u00a0control type.\r\n    Separator = 50038u32,\r\n    /// Identifies the\u00a0SemanticZoom\u00a0control type. Supported starting with Windows 8.\r\n    SemanticZoom = 50039u32,\r\n    /// Identifies the\u00a0AppBar\u00a0control type. Supported starting with Windows 8.1.\r\n    AppBar = 50040u32,\r\n}\r\nimpl From<uiautomation::controls::ControlType> for ControlType {\r\n    fn from(value: uiautomation::controls::ControlType) -> Self {\r\n        match value {\r\n            uiautomation::controls::ControlType::Button => ControlType::Button,\r\n            uiautomation::controls::ControlType::Calendar => ControlType::Calendar,\r\n            uiautomation::controls::ControlType::CheckBox => ControlType::CheckBox,\r\n            uiautomation::controls::ControlType::ComboBox => ControlType::ComboBox,\r\n            uiautomation::controls::ControlType::Edit => ControlType::Edit,\r\n            uiautomation::controls::ControlType::Hyperlink => ControlType::Hyperlink,\r\n            uiautomation::controls::ControlType::Image => ControlType::Image,\r\n            uiautomation::controls::ControlType::ListItem => ControlType::ListItem,\r\n            uiautomation::controls::ControlType::List => ControlType::List,\r\n            uiautomation::controls::ControlType::Menu => ControlType::Menu,\r\n            uiautomation::controls::ControlType::MenuBar => ControlType::MenuBar,\r\n            uiautomation::controls::ControlType::MenuItem => ControlType::MenuItem,\r\n            uiautomation::controls::ControlType::ProgressBar => ControlType::ProgressBar,\r\n            uiautomation::controls::ControlType::RadioButton => ControlType::RadioButton,\r\n            uiautomation::controls::ControlType::ScrollBar => ControlType::ScrollBar,\r\n            uiautomation::controls::ControlType::Slider => ControlType::Slider,\r\n            uiautomation::controls::ControlType::Spinner => ControlType::Spinner,\r\n            uiautomation::controls::ControlType::StatusBar => ControlType::StatusBar,\r\n            uiautomation::controls::ControlType::Tab => ControlType::Tab,\r\n            uiautomation::controls::ControlType::TabItem => ControlType::TabItem,\r\n            uiautomation::controls::ControlType::Text => ControlType::Text,\r\n            uiautomation::controls::ControlType::ToolBar => ControlType::ToolBar,\r\n            uiautomation::controls::ControlType::ToolTip => ControlType::ToolTip,\r\n            uiautomation::controls::ControlType::Tree => ControlType::Tree,\r\n            uiautomation::controls::ControlType::TreeItem => ControlType::TreeItem,\r\n            uiautomation::controls::ControlType::Custom => ControlType::Custom,\r\n            uiautomation::controls::ControlType::Group => ControlType::Group,\r\n            uiautomation::controls::ControlType::Thumb => ControlType::Thumb,\r\n            uiautomation::controls::ControlType::DataGrid => ControlType::DataGrid,\r\n            uiautomation::controls::ControlType::DataItem => ControlType::DataItem,\r\n            uiautomation::controls::ControlType::Document => ControlType::Document,\r\n            uiautomation::controls::ControlType::SplitButton => ControlType::SplitButton,\r\n            uiautomation::controls::ControlType::Window => ControlType::Window,\r\n            uiautomation::controls::ControlType::Pane => ControlType::Pane,\r\n            uiautomation::controls::ControlType::Header => ControlType::Header,\r\n            uiautomation::controls::ControlType::HeaderItem => ControlType::HeaderItem,\r\n            uiautomation::controls::ControlType::Table => ControlType::Table,\r\n            uiautomation::controls::ControlType::TitleBar => ControlType::TitleBar,\r\n            uiautomation::controls::ControlType::Separator => ControlType::Separator,\r\n            uiautomation::controls::ControlType::SemanticZoom => ControlType::SemanticZoom,\r\n            uiautomation::controls::ControlType::AppBar => ControlType::AppBar,\r\n        }\r\n    }\r\n}\r\n\r\n#[derive(Eq, PartialEq, Clone, Reflect, Hash, Default, Serialize, Deserialize)]\r\npub struct RuntimeId(pub Vec<i32>);\r\nimpl std::fmt::Display for RuntimeId {\r\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\r\n        write!(\r\n            f,\r\n            \"{}\",\r\n            self.0\r\n                .iter()\r\n                .map(|x| format!(\"{:X}\", x).to_string())\r\n                .collect::<Vec<String>>()\r\n                .join(\",\")\r\n        )\r\n    }\r\n}\r\nimpl std::fmt::Debug for RuntimeId {\r\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\r\n        write!(f, \"{}\", self)\r\n    }\r\n}\r\n\r\n#[derive(Debug, Eq, PartialEq, Clone, Reflect, Default, Hash, Serialize, Deserialize)]\r\npub enum DrillId {\r\n    Root,\r\n    Child(VecDeque<usize>),\r\n    #[default]\r\n    Unknown,\r\n}\r\nimpl FromIterator<usize> for DrillId {\r\n    fn from_iter<T: IntoIterator<Item = usize>>(iter: T) -> Self {\r\n        DrillId::Child(iter.into_iter().collect())\r\n    }\r\n}\r\nimpl From<Vec<usize>> for DrillId {\r\n    fn from(value: Vec<usize>) -> Self {\r\n        DrillId::Child(value.into())\r\n    }\r\n}\r\nimpl From<VecDeque<usize>> for DrillId {\r\n    fn from(value: VecDeque<usize>) -> Self {\r\n        DrillId::Child(value)\r\n    }\r\n}\r\nimpl From<Vec<i32>> for DrillId {\r\n    fn from(value: Vec<i32>) -> Self {\r\n        DrillId::Child(value.into_iter().map(|x| x as usize).collect())\r\n    }\r\n}\r\nimpl From<VecDeque<i32>> for DrillId {\r\n    fn from(value: VecDeque<i32>) -> Self {\r\n        DrillId::Child(value.into_iter().map(|x| x as usize).collect())\r\n    }\r\n}\r\nimpl std::fmt::Display for DrillId {\r\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\r\n        match self {\r\n            DrillId::Root => write!(f, \"DrillId::Root\"),\r\n            DrillId::Child(drill_id) => write!(\r\n                f,\r\n                \"DrillId::Child({})\",\r\n                drill_id\r\n                    .iter()\r\n                    .map(|x| x.to_string())\r\n                    .collect::<Vec<String>>()\r\n                    .join(\",\")\r\n            ),\r\n            DrillId::Unknown => write!(f, \"DrillId::Unknown\"),\r\n        }\r\n    }\r\n}\r\n\r\n#[derive(Debug, Clone, Reflect, PartialEq, Serialize, Deserialize)]\r\n// #[reflect(no_field_bounds)] //https://github.com/bevyengine/bevy/issues/8965\r\npub struct ElementInfo {\r\n    pub name: String,\r\n    pub bounding_rect: IRect,\r\n    pub control_type: ControlType,\r\n    pub localized_control_type: String,\r\n    pub class_name: String,\r\n    pub automation_id: String,\r\n    #[reflect(ignore)]\r\n    pub runtime_id: RuntimeId,\r\n    #[reflect(ignore)]\r\n    pub drill_id: DrillId,\r\n    #[reflect(ignore)]\r\n    pub children: Option<Vec<ElementInfo>>,\r\n}\r\nimpl std::fmt::Display for ElementInfo {\r\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\r\n        write!(\r\n            f,\r\n            \"'{}' - {}\",\r\n            self.name, self.drill_id\r\n        )\r\n    }\r\n}\r\nimpl Default for ElementInfo {\r\n    fn default() -> Self {\r\n        ElementInfo {\r\n            name: \"UNKNOWN ELEMENT INFO\".to_string(),\r\n            bounding_rect: IRect::new(0, 0, 0, 0),\r\n            control_type: ControlType::Pane,\r\n            localized_control_type: \"\".to_string(),\r\n            class_name: \"\".to_string(),\r\n            automation_id: \"\".to_string(),\r\n            runtime_id: RuntimeId::default(),\r\n            drill_id: DrillId::Unknown,\r\n            children: None,\r\n        }\r\n    }\r\n}\r\nimpl TryFrom<UIElement> for ElementInfo {\r\n    type Error = uiautomation::Error;\r\n    fn try_from(value: UIElement) -> Result<Self, Self::Error> {\r\n        let name = value.get_name()?;\r\n        let bounding_rect = value.get_bounding_rectangle()?.to_bevy_irect();\r\n        let control_type = value.get_control_type()?;\r\n        let localized_control_type = value.get_localized_control_type()?;\r\n        let class_name = value.get_classname()?;\r\n        let automation_id = value.get_automation_id()?;\r\n        let runtime_id = value.get_runtime_id()?;\r\n        Ok(ElementInfo {\r\n            name,\r\n            bounding_rect,\r\n            control_type: control_type.into(),\r\n            localized_control_type,\r\n            class_name,\r\n            automation_id,\r\n            runtime_id: RuntimeId(runtime_id),\r\n            drill_id: DrillId::Unknown,\r\n            children: None,\r\n        })\r\n    }\r\n}\r\nimpl ElementInfo {\r\n    pub fn lookup_drill_id(&self, drill_id: DrillId) -> Option<&ElementInfo> {\r\n        self.lookup_drill_id_inner(drill_id, 0)\r\n    }\r\n    fn lookup_drill_id_inner(&self, drill_id: DrillId, skip: usize) -> Option<&ElementInfo> {\r\n        // println!(\"Looking in {} for {:?} ({:?})\", self.name, drill_id.map(|x| x.iter().skip(skip).collect::<Vec<&usize>>()), drill_id);\r\n        if self.drill_id == drill_id {\r\n            return Some(self);\r\n        }\r\n        let DrillId::Child(drill_id) = drill_id else {\r\n            return None;\r\n        };\r\n        if drill_id.is_empty() {\r\n            return None;\r\n        }\r\n        // println!(\"found children {:?}\", children.children.iter().map(|x| x.drill_id.clone()).collect_vec());\r\n        for child in self.children.as_ref()? {\r\n            let DrillId::Child(child_drill_id) = &child.drill_id else {\r\n                continue;\r\n            };\r\n            if child_drill_id.back() == drill_id.get(skip + 1) {\r\n                if skip == drill_id.len() - 1 {\r\n                    return Some(child);\r\n                } else {\r\n                    return child.lookup_drill_id_inner(DrillId::Child(drill_id.clone()), skip + 1);\r\n                }\r\n            }\r\n        }\r\n        None\r\n    }\r\n    pub fn lookup_drill_id_mut(&mut self, drill_id: DrillId) -> Option<&mut ElementInfo> {\r\n        self.lookup_drill_id_mut_inner(drill_id, 0)\r\n    }\r\n\r\n    fn lookup_drill_id_mut_inner(\r\n        &mut self,\r\n        target_drill_id: DrillId,\r\n        skip: usize,\r\n    ) -> Option<&mut ElementInfo> {\r\n        let next_drill_id = match target_drill_id {\r\n            DrillId::Child(ref drill_id) => {\r\n                drill_id.clone().into_iter().skip(skip).collect::<DrillId>()\r\n            }\r\n            _ => DrillId::Unknown,\r\n        };\r\n        trace!(\r\n            \"Looking in {} for {} (full: {})\",\r\n            self, next_drill_id, target_drill_id\r\n        );\r\n        if self.drill_id == target_drill_id {\r\n            return Some(self);\r\n        }\r\n        let DrillId::Child(inner_id) = target_drill_id else {\r\n            return None;\r\n        };\r\n        if inner_id.is_empty() {\r\n            return None;\r\n        }\r\n\r\n        trace!(\r\n            \"found children {:?}\",\r\n            self.children.as_ref().map(|c| c\r\n                .iter()\r\n                .map(|x| format!(\"{} - {}\", x.name, x.drill_id.to_string()))\r\n                .collect_vec())\r\n        );\r\n        for child in self.children.as_deref_mut()?.iter_mut() {\r\n            let DrillId::Child(child_drill_id) = &child.drill_id else {\r\n                continue;\r\n            };\r\n            if child_drill_id.back() == inner_id.get(skip + 1) {\r\n                if skip == inner_id.len() - 1 {\r\n                    trace!(\"Found {}\", child);\r\n                    return Some(child);\r\n                } else {\r\n                    return child\r\n                        .lookup_drill_id_mut_inner(DrillId::Child(inner_id.clone()), skip + 1);\r\n                }\r\n            }\r\n        }\r\n        None\r\n    }\r\n    pub fn get_descendents(&self) -> Vec<&ElementInfo> {\r\n        let mut descendents = vec![];\r\n        if let Some(children) = &self.children {\r\n            for child in children {\r\n                descendents.push(child);\r\n                descendents.extend(child.get_descendents());\r\n            }\r\n        }\r\n        descendents\r\n    }\r\n}\r\n// test lookup_drill_id\r\n#[cfg(test)]\r\nmod tests {\r\n    #[test]\r\n    fn test_lookup_drill_id() {\r\n        use super::*;\r\n        fn new_elem(name: &str, drill_id: Vec<usize>) -> ElementInfo {\r\n            ElementInfo {\r\n                name: name.to_string(),\r\n                bounding_rect: IRect::new(0, 0, 100, 100),\r\n                control_type: ControlType::Button,\r\n                localized_control_type: \"Button\".to_string(),\r\n                class_name: \"Button\".to_string(),\r\n                automation_id: \"Button\".to_string(),\r\n                runtime_id: RuntimeId::default(),\r\n                drill_id: match drill_id.is_empty() {\r\n                    true => DrillId::Root,\r\n                    false => DrillId::Child(drill_id.into()),\r\n                },\r\n                children: None,\r\n            }\r\n        }\r\n        let mut root = new_elem(\"root\", vec![]);\r\n\r\n        let mut a = new_elem(\"a\", vec![0]);\r\n        let a_a = new_elem(\"a_a\", vec![0, 0]);\r\n        let a_b = new_elem(\"a_b\", vec![0, 1]);\r\n        a.children = Some(vec![a_a.clone(), a_b.clone()]);\r\n\r\n        let mut b = new_elem(\"b\", vec![1]);\r\n        let mut b_a = new_elem(\"b_a\", vec![1, 0]);\r\n        let b_a_a = new_elem(\"b_a_a\", vec![1, 0, 0]);\r\n        let b_a_b = new_elem(\"b_a_b\", vec![1, 0, 1]);\r\n        b_a.children = Some(vec![b_a_a.clone(), b_a_b.clone()]);\r\n        let b_b = new_elem(\"b_b\", vec![1, 1]);\r\n        b.children = Some(vec![b_a.clone(), b_b.clone()]);\r\n\r\n        root.children = Some(vec![a.clone(), b.clone()]);\r\n\r\n        let items = vec![&root, &a, &a_a, &a_b, &b, &b_a, &b_a_a, &b_a_b, &b_b];\r\n        for item in items {\r\n            println!(\"Looking for {}\", item.name);\r\n            let found = root.lookup_drill_id(item.drill_id.clone());\r\n            assert_eq!(found, Some(item));\r\n            println!();\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\toolbelt_types\\src\\toolbelt_types.rs\r\n\r\n````rust\r\nuse std::fmt::Debug;\r\n\r\nuse bevy::prelude::*;\r\nuse bevy::utils::HashMap;\r\nuse leafwing_input_manager::prelude::*;\r\nuse leafwing_input_manager::user_input::InputKind;\r\nuse serde::Deserialize;\r\nuse serde::Serialize;\r\n\r\n#[derive(Actionlike, PartialEq, Eq, Clone, Copy, Hash, Debug, Reflect)]\r\npub enum ToolbeltAction {\r\n    Show,\r\n}\r\n\r\nimpl ToolbeltAction {\r\n    fn default_mkb_binding(&self) -> UserInput {\r\n        match self {\r\n            Self::Show => UserInput::Single(InputKind::Keyboard(KeyCode::AltLeft)),\r\n        }\r\n    }\r\n    fn default_gamepad_binding(&self) -> UserInput {\r\n        match self {\r\n            Self::Show => GamepadButtonType::RightTrigger2.into(),\r\n        }\r\n    }\r\n\r\n    // TODO: convert toolbelt to normal tool structure\r\n    pub fn default_input_map() -> InputMap<ToolbeltAction> {\r\n        let mut input_map = InputMap::default();\r\n\r\n        for variant in ToolbeltAction::variants() {\r\n            input_map.insert(variant.default_mkb_binding(), variant);\r\n            input_map.insert(variant.default_gamepad_binding(), variant);\r\n        }\r\n        input_map\r\n    }\r\n}\r\n\r\n#[derive(Component, Reflect, Clone, Copy, Debug, Serialize, Deserialize, PartialEq)]\r\npub struct Toolbelt {\r\n    pub open: bool,\r\n    pub loadout: ToolbeltLoadout,\r\n    pub layout: ToolbeltLayout,\r\n}\r\nimpl Default for Toolbelt {\r\n    fn default() -> Self {\r\n        Self {\r\n            open: false,\r\n            loadout: ToolbeltLoadout::Default,\r\n            layout: ToolbeltLoadout::Default.layout(),\r\n        }\r\n    }\r\n}\r\n\r\n#[derive(Bundle)]\r\npub struct ToolbeltBundle {\r\n    pub circle: Wheel,\r\n    pub spatial: SpatialBundle,\r\n    pub name: Name,\r\n    pub input_manager: InputManagerBundle<ToolbeltAction>,\r\n    pub toolbelt: Toolbelt,\r\n}\r\nimpl Default for ToolbeltBundle {\r\n    fn default() -> Self {\r\n        Self {\r\n            circle: Wheel::default(),\r\n            spatial: SpatialBundle {\r\n                visibility: Visibility::Hidden,\r\n                ..default()\r\n            },\r\n            name: Name::new(\"Toolbelt\"),\r\n            input_manager: InputManagerBundle::<ToolbeltAction> {\r\n                input_map: ToolbeltAction::default_input_map(),\r\n                ..Default::default()\r\n            },\r\n            toolbelt: Toolbelt::default(),\r\n        }\r\n    }\r\n}\r\n\r\n#[derive(Reflect, Clone, Copy, Debug, Default, Eq, PartialEq, Serialize, Deserialize)]\r\n#[non_exhaustive]\r\npub enum ToolbeltLoadout {\r\n    #[default]\r\n    Default,\r\n    Taskbar,\r\n    Keyboard,\r\n    Agent,\r\n    WindowPosition,\r\n}\r\nimpl ToolbeltLoadout {\r\n    pub fn layout(&self) -> ToolbeltLayout {\r\n        match self {\r\n            Self::Taskbar => ToolbeltLayout::Taskbar {\r\n                wheel: Wheel::default(),\r\n            },\r\n            _ => ToolbeltLayout::default(),\r\n        }\r\n    }\r\n}\r\n\r\n#[derive(Reflect, Clone, Copy, Debug, Serialize, Deserialize, PartialEq)]\r\npub enum ToolbeltLayout {\r\n    Circle { wheel: Wheel },\r\n    Taskbar { wheel: Wheel },\r\n}\r\nimpl Default for ToolbeltLayout {\r\n    fn default() -> Self {\r\n        Self::Circle {\r\n            wheel: Wheel::default(),\r\n        }\r\n    }\r\n}\r\n\r\n#[derive(Event, Debug, Reflect, Clone, Copy)]\r\npub struct ToolbeltPopulateEvent {\r\n    pub id: Entity,\r\n    pub loadout: ToolbeltLoadout,\r\n}\r\n\r\n#[derive(Event, Debug, Reflect)]\r\npub enum ToolbeltOpeningEvent {\r\n    Opened { toolbelt_id: Entity },\r\n    Closed { toolbelt_id: Entity },\r\n}\r\n\r\n#[derive(Component, Reflect, Clone, Copy, Debug, Serialize, Deserialize, PartialEq)]\r\npub struct Wheel {\r\n    pub radius: f32,\r\n    pub radius_start: f32,\r\n    pub radius_end: f32,\r\n    pub radius_end_bonus_per_tool_after_8: f32,\r\n    pub spin: f32,\r\n    pub spin_start: f32,\r\n    pub spin_end: f32,\r\n    pub scale: f32,\r\n    pub scale_start: f32,\r\n    pub scale_end: f32,\r\n    pub alpha: f32,\r\n    pub alpha_start: f32,\r\n    pub alpha_end: f32,\r\n    pub open: bool,\r\n}\r\nimpl Default for Wheel {\r\n    fn default() -> Self {\r\n        Self {\r\n            radius: 200.0,\r\n            // min_radius: 50.0,\r\n            radius_start: 200.0,\r\n            radius_end: 200.0,\r\n            radius_end_bonus_per_tool_after_8: 10.0,\r\n            spin: 0.0,\r\n            spin_start: 300.0,\r\n            spin_end: 360.0,\r\n            scale: 1.0,\r\n            scale_start: 0.5,\r\n            scale_end: 1.0,\r\n            alpha: 0.0,\r\n            alpha_start: 0.0,\r\n            alpha_end: 1.0,\r\n            open: false,\r\n        }\r\n    }\r\n}\r\n\r\n#[derive(Component, Reflect, Clone, Debug)]\r\npub struct Tool {\r\n    pub name: String,\r\n    pub description: String,\r\n    pub actions: HashMap<String, Vec<UserInput>>,\r\n    pub texture: Handle<Image>,\r\n}\r\n\r\n#[derive(Component, Reflect, Clone, Copy, Debug)]\r\npub struct ToolHelpTrigger;\r\n\r\npub trait ToolAction: Actionlike {\r\n    fn default_input_map(_event: &ToolbeltPopulateEvent) -> Option<InputMap<Self>>;\r\n    fn with_defaults<G, K>(gamepad: G, keyboard: K) -> InputMap<Self>\r\n    where\r\n        G: Fn(&Self) -> UserInput,\r\n        K: Fn(&Self) -> UserInput,\r\n        Self: Clone,\r\n    {\r\n        let mut input_map = InputMap::default();\r\n\r\n        for variant in Self::variants() {\r\n            let g = gamepad(&variant);\r\n            let k = keyboard(&variant);\r\n            input_map.insert(g, variant.clone());\r\n            input_map.insert(k, variant);\r\n        }\r\n        input_map\r\n    }\r\n}\r\n\r\n#[derive(Component, Reflect, Debug, PartialEq, Eq)]\r\npub struct ActiveTool;\r\n\r\n#[derive(Event, Debug, Reflect)]\r\npub enum ToolActivationEvent {\r\n    Activate(Entity),\r\n    Deactivate(Entity),\r\n}\r\n\r\n#[derive(Component, Reflect, Debug)]\r\npub struct ToolHelp {\r\n    pub timer: Timer,\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\toolbelt\\src\\tool_help_activate.rs\r\n\r\n````rust\r\nuse cursor_hero_toolbelt_types::toolbelt_types::*;\r\n\r\nuse bevy::prelude::*;\r\nuse bevy_xpbd_2d::components::Collider;\r\nuse bevy_xpbd_2d::components::RigidBody;\r\nuse cursor_hero_cursor_types::prelude::*;\r\n\r\nuse cursor_hero_xelu_prompts::texture_path_for_input;\r\nuse leafwing_input_manager::prelude::*;\r\n\r\npub fn tool_help_activation(\r\n    mut commands: Commands,\r\n    toolbelt_query: Query<(&ActionState<ToolbeltAction>, &Children, &GlobalTransform)>,\r\n    tool_query: Query<(&Tool, &Children)>,\r\n    hovered_query: Query<&GlobalTransform, (With<Hovered>, With<ToolHelpTrigger>)>,\r\n    asset_server: Res<AssetServer>,\r\n) {\r\n    for (toolbelt_actions, toolbelt_children, toolbelt_transform) in toolbelt_query.iter() {\r\n        if toolbelt_actions.just_released(ToolbeltAction::Show) {\r\n            // check all the toolbelt children\r\n            for tool_id in toolbelt_children {\r\n                // if the child is a tool\r\n                if let Ok((tool, tool_children)) = tool_query.get(*tool_id) {\r\n                    // and the tool has children\r\n                    for tool_child_id in tool_children.iter() {\r\n                        // and the hovered child is a tool help trigger\r\n                        if let Ok(hovered_transform) = hovered_query.get(*tool_child_id) {\r\n                            let toolbelt_position = toolbelt_transform.translation();\r\n                            let hovered_position = hovered_transform.translation();\r\n                            let look = hovered_position - toolbelt_position;\r\n                            let position = hovered_position + look;\r\n                            spawn_help_for_tool(&mut commands, position, tool, &asset_server);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\npub fn spawn_help_for_tool(\r\n    commands: &mut Commands,\r\n    position: Vec3,\r\n    tool: &Tool,\r\n    asset_server: &Res<AssetServer>,\r\n) {\r\n    info!(\"Spawning help for tool: {:?}\", tool.name);\r\n    let mut parent_commands = commands.spawn((\r\n        Name::new(format!(\"Help for {}\", tool.name)),\r\n        SpriteBundle {\r\n            sprite: Sprite {\r\n                custom_size: Some(Vec2::new(100.0, 100.0)),\r\n                color: Color::rgba(0.5, 0.5, 1.0, 0.8),\r\n                ..default()\r\n            },\r\n            transform: Transform::from_translation(position),\r\n            ..default()\r\n        },\r\n        ToolHelp {\r\n            timer: Timer::from_seconds(25.0, TimerMode::Once),\r\n        },\r\n        RigidBody::Dynamic,\r\n        Collider::cuboid(100.0, 100.0),\r\n    ));\r\n    parent_commands.with_children(|parent| {\r\n        // image\r\n        parent.spawn(SpriteBundle {\r\n            sprite: Sprite {\r\n                custom_size: Some(Vec2::new(100.0, 100.0)),\r\n                ..default()\r\n            },\r\n            texture: tool.texture.clone(),\r\n            transform: Transform::from_xyz(0.0, 0.0, 1.0),\r\n            ..default()\r\n        });\r\n        // name\r\n        parent.spawn(Text2dBundle {\r\n            text: Text::from_section(\r\n                tool.name.clone(),\r\n                TextStyle {\r\n                    font_size: 20.0,\r\n                    color: Color::WHITE,\r\n                    ..default()\r\n                },\r\n            )\r\n            .with_alignment(TextAlignment::Center),\r\n            transform: Transform::from_xyz(0.0, 60.0, 1.0),\r\n            ..default()\r\n        });\r\n        // description\r\n        parent.spawn(Text2dBundle {\r\n            text: Text::from_section(\r\n                tool.description.clone(),\r\n                TextStyle {\r\n                    font_size: 20.0,\r\n                    color: Color::WHITE,\r\n                    ..default()\r\n                },\r\n            )\r\n            .with_alignment(TextAlignment::Center),\r\n            transform: Transform::from_xyz(0.0, -60.0, 1.0),\r\n            ..default()\r\n        });\r\n\r\n        // actions\r\n        let action_start_y = -100.0; // Starting y position for actions\r\n        let action_spacing_y = 40.0; // Space between each action\r\n        let action_name_x = -150.0;\r\n        let key_size = 50.0; // Size of each key\r\n        let key_spacing_x = key_size + 15.0; // Space between each key\r\n        for (i, (action_name, action_inputs)) in tool.actions.iter().enumerate() {\r\n            let action_y = action_start_y - (i as f32 * action_spacing_y);\r\n\r\n            // Action name text\r\n            parent.spawn(Text2dBundle {\r\n                text: Text::from_section(\r\n                    format!(\"{:?}\", action_name),\r\n                    TextStyle {\r\n                        font_size: 20.0,\r\n                        color: Color::WHITE,\r\n                        ..default()\r\n                    },\r\n                )\r\n                .with_alignment(TextAlignment::Center),\r\n                transform: Transform::from_xyz(action_name_x, action_y, 0.2), // Place text to the left\r\n                ..default()\r\n            });\r\n\r\n            // Keys for action\r\n            let mut key_x = 25.0; // Starting x position for keys\r\n            for action in action_inputs.iter() {\r\n                let key_position = Vec3::new(key_x, action_y, 0.2); // Calculate the position for the key\r\n                key_x += key_spacing_x; // Move the x position for the next key\r\n\r\n                match action {\r\n                    UserInput::Single(kind) => match texture_path_for_input(kind) {\r\n                        Some(path) => {\r\n                            parent.spawn(SpriteBundle {\r\n                                sprite: Sprite {\r\n                                    custom_size: Some(Vec2::new(key_size, key_size)),\r\n                                    ..default()\r\n                                },\r\n                                texture: asset_server.load(path),\r\n                                transform: Transform::from_translation(key_position),\r\n                                ..default()\r\n                            });\r\n                        }\r\n                        None => {\r\n                            warn!(\"No texture for input: {:?}\", kind);\r\n                        }\r\n                    },\r\n                    _ => {\r\n                        warn!(\r\n                            \"Only single inputs are supported for tool help, got {:?}\",\r\n                            action\r\n                        );\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    });\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui_automation\\examples\\ui_snapshot_example.rs\r\n\r\n````rust\r\nuse bevy::log::LogPlugin;\r\nuse bevy::prelude::*;\r\nuse bevy::window::ExitCondition;\r\nuse cursor_hero_memory_types::prelude::get_persist_file;\r\nuse cursor_hero_memory_types::prelude::MemoryConfig;\r\nuse cursor_hero_memory_types::prelude::Usage;\r\nuse cursor_hero_ui_automation::prelude::*;\r\nuse cursor_hero_worker::prelude::*;\r\nuse std::io::Write;\r\nfn main() {\r\n    let mut app = App::new();\r\n    app.add_plugins(\r\n        DefaultPlugins\r\n            .set(LogPlugin {\r\n                level: bevy::log::Level::DEBUG,\r\n                filter: \"\r\ninfo,\r\nwgpu_core=warn,\r\nwgpu_hal=warn,\r\nui_snapshot_example=trace,\r\ncursor_hero_worker=debug,\r\n\"\r\n                .replace('\\n', \"\")\r\n                .trim()\r\n                .into(),\r\n            })\r\n            .set(WindowPlugin {\r\n                primary_window: None,\r\n                exit_condition: ExitCondition::DontExit,\r\n                ..default()\r\n            })\r\n            .build(),\r\n    );\r\n    app.add_plugins(WorkerPlugin {\r\n        config: WorkerConfig::<ThreadboundUISnapshotMessage, GameboundUISnapshotMessage, ()> {\r\n            name: \"ui_snapshot\".to_string(),\r\n            is_ui_automation_thread: true,\r\n            handle_threadbound_message: handle_threadbound_message,\r\n            ..default()\r\n        },\r\n    });\r\n    app.add_systems(Update, trigger);\r\n    app.add_systems(Update, receive);\r\n    app.run();\r\n}\r\n\r\n#[derive(Debug, Reflect, Clone, Event)]\r\nenum ThreadboundUISnapshotMessage {\r\n    TakeSnapshot,\r\n}\r\nimpl WorkerMessage for ThreadboundUISnapshotMessage {}\r\n\r\n#[derive(Debug, Reflect, Clone, Event)]\r\nenum GameboundUISnapshotMessage {\r\n    Snapshot(UiSnapshot),\r\n}\r\nimpl WorkerMessage for GameboundUISnapshotMessage {}\r\n\r\nfn handle_threadbound_message(\r\n    msg: &ThreadboundUISnapshotMessage,\r\n    reply_tx: &Sender<GameboundUISnapshotMessage>,\r\n    _state: &mut (),\r\n) -> anyhow::Result<()> {\r\n    let ThreadboundUISnapshotMessage::TakeSnapshot = msg;\r\n    debug!(\"taking snapshot\");\r\n    let snapshot = take_snapshot()?;\r\n    if let Err(e) = reply_tx.send(GameboundUISnapshotMessage::Snapshot(snapshot)) {\r\n        error!(\"Failed to send snapshot: {:?}\", e);\r\n    }\r\n    Ok(())\r\n}\r\n\r\nfn trigger(\r\n    mut cooldown: Local<Option<Timer>>,\r\n    time: Res<Time>,\r\n    mut events: EventWriter<ThreadboundUISnapshotMessage>,\r\n) {\r\n    let should_tick = if let Some(cooldown) = cooldown.as_mut() {\r\n        if cooldown.tick(time.delta()).just_finished() {\r\n            cooldown.reset();\r\n            true\r\n        } else {\r\n            false\r\n        }\r\n    } else {\r\n        cooldown.replace(Timer::from_seconds(3.0, TimerMode::Repeating));\r\n        true\r\n    };\r\n    if !should_tick {\r\n        return;\r\n    }\r\n    events.send(ThreadboundUISnapshotMessage::TakeSnapshot);\r\n}\r\n\r\nfn receive(mut snapshot: EventReader<GameboundUISnapshotMessage>, memory_config: Res<MemoryConfig>) {\r\n    for msg in snapshot.read() {\r\n        match msg {\r\n            GameboundUISnapshotMessage::Snapshot(snapshot) => {\r\n                debug!(\"received snapshot, writing to file\");\r\n                match get_persist_file(\r\n                    memory_config.as_ref(),\r\n                    \"ui_snapshot.txt\",\r\n                    Usage::Persist,\r\n                ) {\r\n                    Ok(mut file) => {\r\n                        if let Err(e) = file.write_all(snapshot.to_string().as_bytes()) {\r\n                            debug!(\"Failed to write to file: {:?}\", e);\r\n                        }\r\n                    }\r\n                    Err(e) => {\r\n                        error!(\"Failed to open file: {:?}\", e);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\taskbar_tool\\src\\taskbar_wheel_tool.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse bevy_xpbd_2d::components::Position;\r\nuse cursor_hero_bevy::prelude::NegativeYVec2;\r\nuse cursor_hero_screen::get_image::get_image;\r\nuse cursor_hero_screen::get_image::ScreensToImageParam;\r\nuse cursor_hero_toolbelt_types::prelude::*;\r\nuse cursor_hero_tools::prelude::*;\r\nuse cursor_hero_ui_automation::prelude::find_element_at;\r\nuse cursor_hero_ui_automation::prelude::get_taskbar;\r\nuse cursor_hero_ui_automation::prelude::TaskbarEntry;\r\n\r\npub struct TaskbarWheelToolPlugin;\r\n\r\nimpl Plugin for TaskbarWheelToolPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<TaskbarWheelTool>();\r\n        app.register_type::<TaskbarEntryTool>();\r\n        app.add_systems(Update, toolbelt_events);\r\n        app.add_systems(Update, tick_wheel_switcher);\r\n        app.add_systems(Update, tick_taskbar_switcher);\r\n    }\r\n}\r\n\r\n#[derive(Component, Reflect, Default)]\r\nstruct TaskbarWheelTool;\r\n\r\n#[derive(Component, Reflect)]\r\nstruct TaskbarEntryTool {\r\n    entry: TaskbarEntry,\r\n}\r\n\r\nfn toolbelt_events(\r\n    mut commands: Commands,\r\n    asset_server: Res<AssetServer>,\r\n    mut reader: EventReader<ToolbeltPopulateEvent>,\r\n    access: ScreensToImageParam,\r\n) {\r\n    for event in reader.read() {\r\n        match event.loadout {\r\n            ToolbeltLoadout::Default => {\r\n                ToolSpawnConfig::<TaskbarWheelTool, NoInputs>::new(\r\n                    TaskbarWheelTool,\r\n                    event.id,\r\n                    event,\r\n                )\r\n                .with_src_path(file!().into())\r\n                .guess_name(file!())\r\n                .guess_image(file!(), &asset_server, \"png\")\r\n                .with_description(\"Swaps to taskbar tools\")\r\n                .with_starting_state(StartingState::Inactive)\r\n                .spawn(&mut commands);\r\n            }\r\n            ToolbeltLoadout::Taskbar => {\r\n                let Ok(taskbar) = get_taskbar() else {\r\n                    continue;\r\n                };\r\n                for entry in taskbar.entries {\r\n                    let Ok(image) = get_image(entry.bounds, &access) else {\r\n                        warn!(\"Failed to get image for {:?}\", &entry);\r\n                        continue;\r\n                    };\r\n                    ToolSpawnConfig::<TaskbarEntryTool, NoInputs>::new(\r\n                        TaskbarEntryTool {\r\n                            entry: entry.clone(),\r\n                        },\r\n                        event.id,\r\n                        event,\r\n                    )\r\n                    .with_src_path(file!().into())\r\n                    .with_name(entry.name)\r\n                    .with_description(\"Swaps to taskbar tools\")\r\n                    .with_image(asset_server.add(image))\r\n                    .with_size(entry.bounds.size().as_vec2())\r\n                    .with_starting_state(StartingState::Inactive)\r\n                    .spawn(&mut commands);\r\n                }\r\n            }\r\n            _ => {}\r\n        }\r\n    }\r\n}\r\n\r\nfn tick_wheel_switcher(\r\n    mut commands: Commands,\r\n    tool_query: Query<&Parent, (Added<ActiveTool>, With<TaskbarWheelTool>)>,\r\n    mut toolbelt_events: EventWriter<ToolbeltPopulateEvent>,\r\n) {\r\n    for toolbelt_id in tool_query.iter() {\r\n        let toolbelt_id = toolbelt_id.get();\r\n        commands.entity(toolbelt_id).despawn_descendants();\r\n        toolbelt_events.send(ToolbeltPopulateEvent {\r\n            id: toolbelt_id,\r\n            loadout: ToolbeltLoadout::Taskbar,\r\n        });\r\n    }\r\n}\r\n\r\nfn tick_taskbar_switcher(\r\n    mut commands: Commands,\r\n    tool_query: Query<(&Parent, &TaskbarEntryTool), Added<ActiveTool>>,\r\n    toolbelt_query: Query<&Parent, With<Toolbelt>>,\r\n    mut character_query: Query<&mut Position>,\r\n    mut toolbelt_events: EventWriter<ToolbeltPopulateEvent>,\r\n) {\r\n    for (toolbelt_id, tool) in tool_query.iter() {\r\n        let toolbelt_id = toolbelt_id.get();\r\n        if let Ok(character_id) = toolbelt_query.get(toolbelt_id) {\r\n            info!(\"Switching toolbelt {:?} to default tools\", toolbelt_id);\r\n            let character_id = character_id.get();\r\n            commands.entity(toolbelt_id).despawn_descendants();\r\n            toolbelt_events.send(ToolbeltPopulateEvent {\r\n                id: toolbelt_id,\r\n                loadout: ToolbeltLoadout::Default,\r\n            });\r\n            if let Ok(mut position) = character_query.get_mut(character_id) {\r\n                let center = tool.entry.bounds.center();\r\n                position.0 = center.as_vec2().neg_y();\r\n                if let Ok(elem) = find_element_at(center) {\r\n                    if let Err(e) = elem.click() {\r\n                        warn!(\"Failed to click taskbar entry: {:?}\", e);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui_hover\\src\\ui_hover_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse bevy::window::PrimaryWindow;\r\nuse cursor_hero_bevy::prelude::NegativeYIVec2;\r\nuse cursor_hero_cursor_types::cursor_types::MainCursor;\r\nuse cursor_hero_ui_automation::prelude::find_element_at;\r\nuse cursor_hero_ui_automation::prelude::gather_single_element_info;\r\nuse cursor_hero_ui_hover_types::prelude::GameHoveredIndicator;\r\nuse cursor_hero_ui_hover_types::prelude::GameboundHoverMessage;\r\nuse cursor_hero_ui_hover_types::prelude::HostHoveredIndicator;\r\nuse cursor_hero_ui_hover_types::prelude::HoverInfo;\r\nuse cursor_hero_ui_hover_types::prelude::ThreadboundHoverMessage;\r\nuse cursor_hero_winutils::win_mouse::get_cursor_position;\r\nuse cursor_hero_worker::prelude::anyhow::Error;\r\nuse cursor_hero_worker::prelude::anyhow::Result;\r\nuse cursor_hero_worker::prelude::Sender;\r\nuse cursor_hero_worker::prelude::WorkerConfig;\r\nuse cursor_hero_worker::prelude::WorkerPlugin;\r\n\r\npub struct UiHoverPlugin;\r\n\r\nimpl Plugin for UiHoverPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.insert_resource(HoverInfo::default());\r\n\r\n        app.add_plugins(WorkerPlugin {\r\n            config: WorkerConfig::<ThreadboundHoverMessage, GameboundHoverMessage, ()> {\r\n                name: \"hover\".to_string(),\r\n                handle_threadbound_message,\r\n                handle_threadbound_message_error_handler,\r\n                sleep_duration: std::time::Duration::from_millis(10),\r\n                ..default()\r\n            },\r\n        });\r\n        app.add_systems(Update, trigger_host_hover_info_update);\r\n        app.add_systems(Update, trigger_game_hover_info_update);\r\n        app.add_systems(Update, handle_gamebound_messages);\r\n        app.add_systems(Update, update_visuals);\r\n    }\r\n}\r\n\r\nfn handle_threadbound_message_error_handler(\r\n    msg: &ThreadboundHoverMessage,\r\n    reply_tx: &Sender<GameboundHoverMessage>,\r\n    _state: &mut (),\r\n    _error: &Error,\r\n) -> Result<()> {\r\n    match msg {\r\n        ThreadboundHoverMessage::AtHostCursorPosition => {\r\n            reply_tx.send(GameboundHoverMessage::ClearHostHoverInfo)?;\r\n        }\r\n        ThreadboundHoverMessage::AtPositionFromGame(_) => {\r\n            reply_tx.send(GameboundHoverMessage::ClearGameHoverInfo)?;\r\n        }\r\n        _ => (),\r\n    }\r\n    Ok(())\r\n}\r\n\r\nfn handle_threadbound_message(\r\n    msg: &ThreadboundHoverMessage,\r\n    reply_tx: &Sender<GameboundHoverMessage>,\r\n    _state: &mut (),\r\n) -> Result<()> {\r\n    let reply = match msg {\r\n        ThreadboundHoverMessage::AtPositionFromGame(cursor_pos) => {\r\n            let root = find_element_at(*cursor_pos)?;\r\n            let info = gather_single_element_info(&root)?;\r\n            GameboundHoverMessage::GameHoverInfo {\r\n                info,\r\n                cursor_pos: *cursor_pos,\r\n            }\r\n        }\r\n        ThreadboundHoverMessage::AtHostCursorPosition => {\r\n            let cursor_pos = get_cursor_position()?;\r\n            let root = find_element_at(cursor_pos)?;\r\n            let info = gather_single_element_info(&root)?;\r\n            GameboundHoverMessage::HostHoverInfo {\r\n                info,\r\n                cursor_pos,\r\n            }\r\n        }\r\n        ThreadboundHoverMessage::ClearHost => GameboundHoverMessage::ClearHostHoverInfo,\r\n        ThreadboundHoverMessage::ClearGame => GameboundHoverMessage::ClearGameHoverInfo,\r\n    };\r\n    reply_tx.send(reply)?;\r\n    Ok(())\r\n}\r\n\r\nfn trigger_host_hover_info_update(\r\n    mut messages: EventWriter<ThreadboundHoverMessage>,\r\n    mut cooldown: Local<Option<Timer>>,\r\n    hover_info: Res<HoverInfo>,\r\n    time: Res<Time>,\r\n) {\r\n    if !hover_info.enabled {\r\n        return;\r\n    }\r\n\r\n    let Some(cooldown) = cooldown.as_mut() else {\r\n        cooldown.replace(Timer::from_seconds(0.1, TimerMode::Repeating));\r\n        return;\r\n    };\r\n    if !cooldown.tick(time.delta()).just_finished() {\r\n        return;\r\n    }\r\n\r\n    let msg = ThreadboundHoverMessage::AtHostCursorPosition;\r\n    messages.send(msg);\r\n}\r\n\r\nfn trigger_game_hover_info_update(\r\n    cursor_query: Query<&GlobalTransform, With<MainCursor>>,\r\n    window_query: Query<&Window, With<PrimaryWindow>>,\r\n    mut hover_info: ResMut<HoverInfo>,\r\n    mut messages: EventWriter<ThreadboundHoverMessage>,\r\n    mut debounce: Local<Option<ThreadboundHoverMessage>>,\r\n    mut cooldown: Local<Option<Timer>>,\r\n    time: Res<Time>,\r\n) {\r\n    if !hover_info.enabled {\r\n        return;\r\n    }\r\n\r\n    let window = match window_query.get_single() {\r\n        Ok(window) => window,\r\n        Err(e) => {\r\n            warn!(\"Expected a single primary window, got error: {:?}\", e);\r\n            return;\r\n        }\r\n    };\r\n\r\n    if window.cursor_position().is_none() {\r\n        let msg = ThreadboundHoverMessage::ClearGame;\r\n        let check = Some(msg.clone());\r\n        if *debounce != check {\r\n            *debounce = check;\r\n            hover_info.game_element = None;\r\n        }\r\n        return;\r\n    }\r\n\r\n    let Some(cooldown) = cooldown.as_mut() else {\r\n        cooldown.replace(Timer::from_seconds(0.1, TimerMode::Repeating));\r\n        return;\r\n    };\r\n    if !cooldown.tick(time.delta()).just_finished() {\r\n        return;\r\n    }\r\n\r\n    let cursor = match cursor_query.get_single() {\r\n        Ok(cursor) => cursor,\r\n        Err(e) => {\r\n            warn!(\"Expected a single main cursor, got error: {:?}\", e);\r\n            return;\r\n        }\r\n    };\r\n\r\n    let cursor_pos = cursor.translation().truncate().as_ivec2().neg_y();\r\n    let msg = ThreadboundHoverMessage::AtPositionFromGame(cursor_pos);\r\n    let check = Some(msg.clone());\r\n    if *debounce != check {\r\n        *debounce = check;\r\n        messages.send(msg);\r\n    }\r\n}\r\n\r\nfn handle_gamebound_messages(\r\n    mut messages: EventReader<GameboundHoverMessage>,\r\n    mut hover_info: ResMut<HoverInfo>,\r\n) {\r\n    for msg in messages.read() {\r\n        match msg {\r\n            GameboundHoverMessage::HostHoverInfo { info, cursor_pos }=> {\r\n                hover_info.host_element = Some(HostHoveredIndicator {\r\n                    info: info.clone(),\r\n                    cursor_pos: *cursor_pos,\r\n                });\r\n            }\r\n            GameboundHoverMessage::ClearHostHoverInfo => {\r\n                hover_info.host_element = None;\r\n            }\r\n            GameboundHoverMessage::GameHoverInfo { info, cursor_pos } => {\r\n                hover_info.game_element = Some(GameHoveredIndicator {\r\n                    info: info.clone(),\r\n                    cursor_pos: *cursor_pos,\r\n                });\r\n            }\r\n            GameboundHoverMessage::ClearGameHoverInfo => {\r\n                hover_info.game_element = None;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n#[allow(clippy::type_complexity)]\r\nfn update_visuals(\r\n    mut host_indicator: Query<\r\n        (\r\n            Entity,\r\n            &mut Sprite,\r\n            &mut Transform,\r\n            &mut HostHoveredIndicator,\r\n        ),\r\n        Without<GameHoveredIndicator>,\r\n    >,\r\n    mut game_indicator: Query<\r\n        (\r\n            Entity,\r\n            &mut Sprite,\r\n            &mut Transform,\r\n            &mut GameHoveredIndicator,\r\n        ),\r\n        Without<HostHoveredIndicator>,\r\n    >,\r\n    hovered: Res<HoverInfo>,\r\n    mut commands: Commands,\r\n) {\r\n    if let Ok(host_indicator) = host_indicator.get_single_mut() {\r\n        let (entity, mut sprite, mut transform, mut indicator) = host_indicator;\r\n        if let Some(existing) = &hovered.host_element {\r\n            let bounds = existing.info.bounding_rect.as_rect();\r\n            sprite.custom_size = Some(Vec2::new(bounds.width(), bounds.height()));\r\n            transform.translation = Vec3::new(\r\n                bounds.min.x + bounds.width() / 2.,\r\n                -bounds.min.y - bounds.height() / 2.,\r\n                0.,\r\n            );\r\n            *indicator = existing.clone();\r\n        } else {\r\n            commands.entity(entity).despawn_recursive();\r\n        }\r\n    } else if let Some(existing) = &hovered.host_element {\r\n        let bounds = existing.info.bounding_rect.as_rect();\r\n        let indicator = existing.clone();\r\n        commands.spawn((\r\n            SpriteBundle {\r\n                transform: Transform::from_xyz(\r\n                    bounds.min.x + bounds.width() / 2.,\r\n                    -bounds.min.y - bounds.height() / 2.,\r\n                    0.,\r\n                ),\r\n                sprite: Sprite {\r\n                    custom_size: Some(Vec2::new(bounds.width(), bounds.height())),\r\n                    color: Color::rgba(0.141, 0.675, 0.949, 0.05),\r\n                    ..default()\r\n                },\r\n                ..default()\r\n            },\r\n            Name::new(\"Screen Hovered Indicator\"),\r\n            indicator\r\n        ));\r\n    }\r\n\r\n    if let Ok(game_indicator) = game_indicator.get_single_mut() {\r\n        let (entity, mut sprite, mut transform, mut indicator) = game_indicator;\r\n        if let Some(existing) = &hovered.game_element {\r\n            let bounds = existing.info.bounding_rect.as_rect();\r\n            sprite.custom_size = Some(Vec2::new(bounds.width(), bounds.height()));\r\n            transform.translation = Vec3::new(\r\n                bounds.min.x + bounds.width() / 2.,\r\n                -bounds.min.y - bounds.height() / 2.,\r\n                0.,\r\n            );\r\n            *indicator = existing.clone();\r\n        } else {\r\n            commands.entity(entity).despawn_recursive();\r\n        }\r\n    } else if let Some(existing) = &hovered.game_element {\r\n        let bounds = existing.info.bounding_rect.as_rect();\r\n        let indicator = existing.clone();\r\n        commands.spawn((\r\n            SpriteBundle {\r\n                transform: Transform::from_xyz(\r\n                    bounds.min.x + bounds.width() / 2.,\r\n                    -bounds.min.y - bounds.height() / 2.,\r\n                    0.,\r\n                ),\r\n                sprite: Sprite {\r\n                    custom_size: Some(Vec2::new(bounds.width(), bounds.height())),\r\n                    color: Color::rgba(0.641, 0.275, 0.649, 0.05),\r\n                    ..default()\r\n                },\r\n                ..default()\r\n            },\r\n            Name::new(\"Game Hovered Indicator\"),   \r\n            indicator\r\n        ));\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\toolbelt_types\\src\\lib.rs\r\n\r\n````rust\r\npub mod toolbelt_types;\r\npub mod toolbelt_types_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::toolbelt_types::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\sprint_tool_types\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_sprint_tool_types\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\nbevy-inspector-egui = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui_automation\\src\\ui_automation_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n\r\npub struct UiAutomationPlugin;\r\n\r\nimpl Plugin for UiAutomationPlugin {\r\n    fn build(&self, _app: &mut App) {}\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui_automation_types\\src\\edge_ui_types.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse itertools::Itertools;\r\nuse serde::Deserialize;\r\nuse serde::Serialize;\r\nuse std::collections::VecDeque;\r\nuse std::fmt;\r\nuse std::fmt::Display;\r\nuse std::fmt::Formatter;\r\nuse uiautomation::UIElement;\r\n\r\npub enum EdgeResolveError {\r\n    BadChildCount { tried_accessing: u32 },\r\n    UI(uiautomation::Error),\r\n    UnknownSideTabKind(String),\r\n    UnknownState,\r\n}\r\nimpl From<u32> for EdgeResolveError {\r\n    fn from(tried_accessing: u32) -> Self {\r\n        EdgeResolveError::BadChildCount { tried_accessing }\r\n    }\r\n}\r\n\r\nimpl From<uiautomation::Error> for EdgeResolveError {\r\n    fn from(e: uiautomation::Error) -> Self {\r\n        EdgeResolveError::UI(e)\r\n    }\r\n}\r\nimpl TryFrom<VecDeque<UIElement>> for EdgeCrawlState {\r\n    type Error = EdgeResolveError;\r\n    fn try_from(mut kids: VecDeque<UIElement>) -> Result<Self, Self::Error> {\r\n        let state = match kids.len() {\r\n            2 => EdgeCrawlState::LeftTabClosed {\r\n                tabs: kids.pop_front().ok_or(0u32)?,\r\n                editor: kids.pop_front().ok_or(1u32)?,\r\n            },\r\n            3 => EdgeCrawlState::LeftTabOpen {\r\n                side_nav_tabs: kids.pop_front().ok_or(0u32)?,\r\n                side_nav_view: kids.pop_front().ok_or(1u32)?,\r\n                editor: kids.pop_front().ok_or(2u32)?,\r\n            },\r\n            _ => EdgeCrawlState::Unknown,\r\n        };\r\n        Ok(state)\r\n    }\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]\r\npub enum View {\r\n    Explorer {\r\n        sticky: Vec<ExplorerItem>,\r\n        items: Vec<ExplorerItem>,\r\n    },\r\n    Unknown {},\r\n}\r\nimpl Display for View {\r\n    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {\r\n        match self {\r\n            View::Explorer { sticky, items } => {\r\n                writeln!(f, \"Explorer entries:\")?;\r\n                writeln!(f, \"=== BEGIN STICKY ===\")?;\r\n                for item in sticky.iter().sorted_by_key(|x| x.bounds.min.y) {\r\n                    writeln!(\r\n                        f,\r\n                        \"{}- {} ({})\",\r\n                        \" \".repeat(item.ui_level as usize),\r\n                        item.label.clone()\r\n                            + if matches!(item.kind, ExplorerItemKind::Directory { .. }) {\r\n                                \"/\"\r\n                            } else {\r\n                                \"\"\r\n                            },\r\n                        item.path\r\n                    )?;\r\n                }\r\n                writeln!(f, \"=== END STICKY ===\")?;\r\n                for item in items.iter().sorted_by_key(|x| x.bounds.min.y) {\r\n                    writeln!(\r\n                        f,\r\n                        \"{}- {} ({})\",\r\n                        \" \".repeat(item.ui_level as usize),\r\n                        item.label.clone()\r\n                            + if matches!(item.kind, ExplorerItemKind::Directory { .. }) {\r\n                                \"/\"\r\n                            } else {\r\n                                \"\"\r\n                            },\r\n                        item.path\r\n                    )?;\r\n                }\r\n                fmt::Result::Ok(())\r\n            }\r\n            View::Unknown {} => {\r\n                writeln!(f, \"Unknown view\")?;\r\n                fmt::Result::Ok(())\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\npub enum EdgeCrawlState {\r\n    LeftTabClosed {\r\n        tabs: UIElement,\r\n        editor: UIElement,\r\n    },\r\n    LeftTabOpen {\r\n        side_nav_tabs: UIElement,\r\n        side_nav_view: UIElement,\r\n        editor: UIElement,\r\n    },\r\n    Unknown,\r\n}\r\nimpl EdgeCrawlState {\r\n    pub fn get_side_nav_tabs_root_elem(&self) -> Result<&UIElement, EdgeResolveError> {\r\n        match self {\r\n            EdgeCrawlState::LeftTabClosed { tabs, .. } => Ok(tabs),\r\n            EdgeCrawlState::LeftTabOpen {\r\n                side_nav_tabs: tabs,\r\n                ..\r\n            } => Ok(tabs),\r\n            EdgeCrawlState::Unknown => Err(EdgeResolveError::UnknownState),\r\n        }\r\n    }\r\n    pub fn get_side_nav_view_root_elem(&self) -> Result<&UIElement, EdgeResolveError> {\r\n        match self {\r\n            EdgeCrawlState::LeftTabClosed { tabs, .. } => Ok(tabs),\r\n            EdgeCrawlState::LeftTabOpen {\r\n                side_nav_view: view,\r\n                ..\r\n            } => Ok(view),\r\n            EdgeCrawlState::Unknown => Err(EdgeResolveError::UnknownState),\r\n        }\r\n    }\r\n    pub fn get_editor_root_elem(&self) -> Result<&UIElement, EdgeResolveError> {\r\n        match self {\r\n            EdgeCrawlState::LeftTabClosed { editor, .. } => Ok(editor),\r\n            EdgeCrawlState::LeftTabOpen { editor, .. } => Ok(editor),\r\n            EdgeCrawlState::Unknown => Err(EdgeResolveError::UnknownState),\r\n        }\r\n    }\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]\r\npub struct EdgeWindowHeader {}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]\r\npub struct EdgeWindowBody {\r\n    pub editor_area: EditorArea,\r\n    pub side_nav: Vec<SideTab>,\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]\r\npub struct EdgeWindowFooter {\r\n    pub cursor_position: IVec2,\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]\r\npub struct EdgeWindow {\r\n    pub focused: bool,\r\n    pub header: EdgeWindowHeader,\r\n    pub body: EdgeWindowBody,\r\n    pub footer: EdgeWindowFooter,\r\n}\r\n\r\nimpl Display for EdgeWindow {\r\n    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {\r\n        writeln!(\r\n            f,\r\n            \":D :D :D Visual Studio Code {} owo owo owo\",\r\n            if self.focused { \"(focused)\" } else { \"\" }\r\n        )?;\r\n\r\n        writeln!(f, \"Side tabs:\")?;\r\n        for tab in self.body.side_nav.iter() {\r\n            match tab {\r\n                SideTab::Open { kind, view } => {\r\n                    writeln!(f, \"- (open) {:?} {{{{\\n{}}}}}\", kind, view)?;\r\n                }\r\n                SideTab::Closed { kind } => {\r\n                    writeln!(f, \"- {:?}\", kind)?;\r\n                }\r\n            }\r\n        }\r\n\r\n        writeln!(f, \"Editor groups:\")?;\r\n        for (i, group) in self.body.editor_area.groups.iter().enumerate() {\r\n            writeln!(f, \"Group {} tabs:\", i + 1)?;\r\n            for tab in group.tabs.iter() {\r\n                if tab.active {\r\n                    writeln!(f, \"- (active) {}\", tab.title)?;\r\n                } else {\r\n                    writeln!(f, \"- {}\", tab.title)?;\r\n                }\r\n            }\r\n            if let Some(ref content) = group.content {\r\n                writeln!(\r\n                    f,\r\n                    \"Group {} buffer:\\n=======\\n{}\\n=======\",\r\n                    i + 1,\r\n                    content.content\r\n                )?;\r\n            }\r\n        }\r\n\r\n        writeln!(f, \"Cursor position: {:?}\", self.footer.cursor_position)?;\r\n\r\n        fmt::Result::Ok(())\r\n    }\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]\r\npub enum SideTab {\r\n    Closed { kind: SideTabKind },\r\n    Open { kind: SideTabKind, view: View },\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]\r\npub enum ExplorerItemKind {\r\n    File,\r\n    Directory { expanded: bool },\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]\r\npub struct ExplorerItem {\r\n    pub label: String,\r\n    pub path: String,\r\n    pub ui_position_in_set: u32,\r\n    pub ui_size_of_set: u32,\r\n    pub ui_level: u32,\r\n    pub bounds: IRect,\r\n    pub kind: ExplorerItemKind,\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]\r\npub struct EditorArea {\r\n    pub groups: Vec<EditorGroup>,\r\n}\r\nimpl EditorArea {\r\n    pub fn get_expected_automation_id() -> &'static str {\r\n        \"workbench.parts.editor\"\r\n    }\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]\r\npub struct EditorGroup {\r\n    pub tabs: Vec<EditorTab>,\r\n    pub content: Option<EditorContent>,\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]\r\npub struct EditorTab {\r\n    pub title: String,\r\n    pub active: bool,\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]\r\npub struct EditorContent {\r\n    pub content: String,\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]\r\npub enum SideTabKind {\r\n    Explorer,\r\n    Search,\r\n    SourceControl,\r\n    RunAndDebug,\r\n    Extensions,\r\n    GitLens,\r\n    Azure,\r\n    Jupyter,\r\n    Chat,\r\n    GitHubActions,\r\n    Todo,\r\n}\r\nimpl SideTabKind {\r\n    pub fn variants() -> Vec<SideTabKind> {\r\n        vec![\r\n            SideTabKind::Explorer,\r\n            SideTabKind::Search,\r\n            SideTabKind::SourceControl,\r\n            SideTabKind::RunAndDebug,\r\n            SideTabKind::Extensions,\r\n            SideTabKind::GitLens,\r\n            SideTabKind::Azure,\r\n            SideTabKind::Jupyter,\r\n            SideTabKind::Chat,\r\n            SideTabKind::GitHubActions,\r\n            SideTabKind::Todo,\r\n        ]\r\n    }\r\n    pub fn get_view_automation_id(&self) -> Option<&str> {\r\n        match self {\r\n            SideTabKind::Explorer => Some(\"workbench.view.explorer\"),\r\n            _ => None,\r\n        }\r\n    }\r\n}\r\nimpl TryFrom<String> for SideTabKind {\r\n    type Error = EdgeResolveError;\r\n    fn try_from(s: String) -> Result<Self, Self::Error> {\r\n        let before_first_lparen = s.split_once(\" (\").map(|x| x.0).unwrap_or(s.as_str());\r\n        match before_first_lparen {\r\n            \"Explorer\" => Ok(SideTabKind::Explorer),\r\n            \"Search\" => Ok(SideTabKind::Search),\r\n            \"Source Control\" => Ok(SideTabKind::SourceControl),\r\n            \"Run and Debug\" => Ok(SideTabKind::RunAndDebug),\r\n            \"Extensions\" => Ok(SideTabKind::Extensions),\r\n            \"GitLens\" => Ok(SideTabKind::GitLens),\r\n            \"Azure\" => Ok(SideTabKind::Azure),\r\n            \"Jupyter\" => Ok(SideTabKind::Jupyter),\r\n            \"Chat\" => Ok(SideTabKind::Chat),\r\n            \"GitHub Actions\" => Ok(SideTabKind::GitHubActions),\r\n            \"TODOs\" => Ok(SideTabKind::Todo),\r\n            _ => Err(EdgeResolveError::UnknownSideTabKind(s)),\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\start_menu_types\\src\\lib.rs\r\n\r\n````rust\r\npub mod start_menu_types;\r\npub mod start_menu_types_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::start_menu_types::*;\r\n    pub use crate::start_menu_types_plugin::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui_hover_types\\src\\lib.rs\r\n\r\n````rust\r\nmod ui_hover_types_plugin;\r\nmod ui_hover_types;\r\n\r\npub mod prelude {\r\n    pub use crate::ui_hover_types::*;\r\n    pub use crate::ui_hover_types_plugin::*;\r\n}\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\toolbelt\\src\\tool_help_populate.rs\r\n\r\n````rust\r\nuse cursor_hero_host_fs_types::host_fs_types::HostPath;\r\nuse cursor_hero_toolbelt_types::toolbelt_types::*;\r\n\r\nuse bevy::prelude::*;\r\nuse bevy_xpbd_2d::components::Collider;\r\nuse bevy_xpbd_2d::components::RigidBody;\r\nuse bevy_xpbd_2d::components::Sensor;\r\nuse cursor_hero_cursor_types::prelude::*;\r\n\r\nuse leafwing_input_manager::action_state::ActionState;\r\n\r\n#[allow(clippy::type_complexity)]\r\npub fn tool_help_lifecycle(\r\n    mut commands: Commands,\r\n    toolbelt_query: Query<\r\n        (&ActionState<ToolbeltAction>, &Children),\r\n        (Without<Tool>, With<Toolbelt>),\r\n    >,\r\n    tool_query: Query<(Entity, Option<&HostPath>, Option<&Children>, Option<&Name>), With<Tool>>,\r\n    tool_help_triggger_query: Query<Entity, With<ToolHelpTrigger>>,\r\n    asset_server: Res<AssetServer>,\r\n) {\r\n    for (toolbelt_actions, toolbelt_kids) in toolbelt_query.iter() {\r\n        if toolbelt_actions.just_pressed(ToolbeltAction::Show) {\r\n            for child_id in toolbelt_kids.iter() {\r\n                let Ok(tool) = tool_query.get(*child_id) else {\r\n                    continue;\r\n                };\r\n\r\n                let (tool_id, tool_src_path, _, tool_name) = tool;\r\n                commands.entity(tool_id).with_children(|parent| {\r\n                    let mut help = parent.spawn((\r\n                        Name::new(format!(\"Help Trigger for {:?} ({:?})\", tool_name, tool_id)),\r\n                        SpriteBundle {\r\n                            sprite: Sprite {\r\n                                custom_size: Some(Vec2::new(50.0, 50.0)),\r\n                                ..default()\r\n                            },\r\n                            transform: Transform::from_xyz(0.0, 0.0, 1.0),\r\n                            texture: asset_server.load(\"textures/toolbelt_wheel/help_trigger.png\"),\r\n                            ..default()\r\n                        },\r\n                        Hoverable,\r\n                        Clickable,\r\n                        ToolHelpTrigger,\r\n                        Sensor,\r\n                        RigidBody::Kinematic,\r\n                        Collider::cuboid(50.0, 50.0),\r\n                    ));\r\n                    if let Some(src_path) = tool_src_path {\r\n                        help.insert(src_path.clone());\r\n                    }\r\n                });\r\n            }\r\n        } else if toolbelt_actions.just_released(ToolbeltAction::Show) {\r\n            for child_id in toolbelt_kids.iter() {\r\n                let Ok(tool) = tool_query.get(*child_id) else {\r\n                    continue;\r\n                };\r\n                let (tool_id, _, Some(tool_children), _) = tool else {\r\n                    continue;\r\n                };\r\n                for child_id in tool_children.iter() {\r\n                    if let Ok(tool_help_trigger_id) = tool_help_triggger_query.get(*child_id) {\r\n                        commands\r\n                            .entity(tool_id)\r\n                            .remove_children(&[tool_help_trigger_id]);\r\n                        commands.entity(tool_help_trigger_id).despawn_recursive();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\tools\\src\\keyboard_wheel_tool.rs\r\n\r\n````rust\r\nuse crate::prelude::*;\r\nuse bevy::prelude::*;\r\nuse cursor_hero_toolbelt_types::prelude::*;\r\n\r\npub struct KeyboardWheelToolPlugin;\r\n\r\nimpl Plugin for KeyboardWheelToolPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<KeyboardWheelTool>();\r\n        app.add_systems(Update, toolbelt_events);\r\n        app.add_systems(Update, tick);\r\n    }\r\n}\r\n\r\n#[derive(Component, Reflect, Default)]\r\nstruct KeyboardWheelTool;\r\n\r\nfn toolbelt_events(\r\n    mut commands: Commands,\r\n    asset_server: Res<AssetServer>,\r\n    mut reader: EventReader<ToolbeltPopulateEvent>,\r\n) {\r\n    for event in reader.read() {\r\n        let ToolbeltLoadout::Default = event.loadout else {\r\n            continue;\r\n        };\r\n        ToolSpawnConfig::<KeyboardWheelTool, NoInputs>::new(KeyboardWheelTool, event.id, event)\r\n            .with_src_path(file!().into())\r\n            .guess_name(file!())\r\n            .guess_image(file!(), &asset_server, \"png\")\r\n            .with_description(\"Swaps to keyboard tools\")\r\n            .with_starting_state(StartingState::Inactive)\r\n            .spawn(&mut commands);\r\n    }\r\n}\r\n\r\nfn tick(\r\n    mut commands: Commands,\r\n    tool_query: Query<&Parent, (Added<ActiveTool>, With<KeyboardWheelTool>)>,\r\n    mut toolbelt_events: EventWriter<ToolbeltPopulateEvent>,\r\n) {\r\n    for toolbelt_id in tool_query.iter() {\r\n        info!(\"Switching toolbelt {:?} to keyboard tools\", toolbelt_id);\r\n        let toolbelt_id = toolbelt_id.get();\r\n        commands.entity(toolbelt_id).despawn_descendants();\r\n        toolbelt_events.send(ToolbeltPopulateEvent {\r\n            id: toolbelt_id,\r\n            loadout: ToolbeltLoadout::Keyboard,\r\n        });\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\tools\\src\\scroll_tool.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse bevy_inspector_egui::prelude::ReflectInspectorOptions;\r\nuse bevy_inspector_egui::InspectorOptions;\r\nuse cursor_hero_character_types::prelude::*;\r\nuse cursor_hero_math::prelude::Lerp;\r\nuse cursor_hero_sprint_tool_types::sprint_tool_types_plugin::SprintEvent;\r\nuse cursor_hero_toolbelt_types::prelude::*;\r\nuse cursor_hero_winutils::win_mouse::scroll_wheel;\r\nuse itertools::Itertools;\r\nuse leafwing_input_manager::prelude::*;\r\n\r\nuse crate::prelude::*;\r\n\r\npub struct ScrollToolPlugin;\r\n\r\nimpl Plugin for ScrollToolPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<ScrollTool>();\r\n        app.add_plugins(InputManagerPlugin::<ScrollToolAction>::default());\r\n        app.add_systems(Update, toolbelt_events);\r\n        app.add_systems(Update, handle_input);\r\n        app.add_systems(Update, handle_sprint_events);\r\n    }\r\n}\r\n\r\n#[derive(Component, InspectorOptions, Reflect)]\r\n#[reflect(Component, InspectorOptions)]\r\nstruct ScrollTool {\r\n    #[inspector(min = 0.0)]\r\n    pub speed: f32,\r\n    #[inspector(min = 0.0)]\r\n    pub default_speed: f32,\r\n    #[inspector(min = 0.0)]\r\n    pub sprint_speed: f32,\r\n}\r\nimpl Default for ScrollTool {\r\n    fn default() -> Self {\r\n        Self {\r\n            speed: 1.0,\r\n            default_speed: 1.0,\r\n            sprint_speed: 100.0,\r\n        }\r\n    }\r\n}\r\n\r\nfn toolbelt_events(\r\n    mut commands: Commands,\r\n    asset_server: Res<AssetServer>,\r\n    mut reader: EventReader<ToolbeltPopulateEvent>,\r\n) {\r\n    for event in reader.read() {\r\n        let ToolbeltLoadout::Default = event.loadout else {\r\n            continue;\r\n        };\r\n        ToolSpawnConfig::<_, ScrollToolAction>::new(ScrollTool::default(), event.id, event)\r\n            .with_src_path(file!().into())\r\n            .guess_name(file!())\r\n            .guess_image(file!(), &asset_server, \"png\")\r\n            .with_description(\"Send scroll events\")\r\n            .spawn(&mut commands);\r\n    }\r\n}\r\n\r\n#[derive(Actionlike, PartialEq, Eq, Clone, Copy, Hash, Debug, Reflect)]\r\nenum ScrollToolAction {\r\n    ScrollUp,\r\n    ScrollDown,\r\n}\r\n\r\nimpl ScrollToolAction {\r\n    fn default_gamepad_binding(&self) -> UserInput {\r\n        match self {\r\n            Self::ScrollUp => GamepadButtonType::DPadUp.into(),\r\n            Self::ScrollDown => GamepadButtonType::DPadDown.into(),\r\n        }\r\n    }\r\n\r\n    fn default_mkb_binding(&self) -> UserInput {\r\n        match self {\r\n            Self::ScrollUp => KeyCode::PageDown.into(),\r\n            Self::ScrollDown => KeyCode::PageUp.into(),\r\n        }\r\n    }\r\n}\r\nimpl ToolAction for ScrollToolAction {\r\n    fn default_input_map(_event: &ToolbeltPopulateEvent) -> Option<InputMap<ScrollToolAction>> {\r\n        let mut input_map = InputMap::default();\r\n\r\n        for variant in ScrollToolAction::variants() {\r\n            input_map.insert(variant.default_mkb_binding(), variant);\r\n            input_map.insert(variant.default_gamepad_binding(), variant);\r\n        }\r\n        Some(input_map)\r\n    }\r\n}\r\n\r\nfn handle_input(\r\n    tool_query: Query<(&ActionState<ScrollToolAction>, &ScrollTool), With<ActiveTool>>,\r\n    time: Res<Time>,\r\n) {\r\n    for zoom_tool in tool_query.iter() {\r\n        let (tool_actions, tool) = zoom_tool;\r\n        let mut amount = None;\r\n        if tool_actions.pressed(ScrollToolAction::ScrollUp) {\r\n            if tool_actions.just_pressed(ScrollToolAction::ScrollUp) {\r\n                info!(\"Scrolling up\");\r\n            }\r\n            amount = Some(tool.speed * time.delta_seconds());\r\n        }\r\n        if tool_actions.pressed(ScrollToolAction::ScrollDown) {\r\n            if tool_actions.just_pressed(ScrollToolAction::ScrollDown) {\r\n                info!(\"Scrolling down\");\r\n            }\r\n            amount = Some(-tool.speed * time.delta_seconds());\r\n        }\r\n        if let Some(amount) = amount {\r\n            match scroll_wheel(amount) {\r\n                Ok(_) => {}\r\n                Err(e) => {\r\n                    error!(\"Error scrolling up: {:?}\", e);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfn handle_sprint_events(\r\n    mut sprint_events: EventReader<SprintEvent>,\r\n    character_query: Query<&Children, With<Character>>,\r\n    toolbelt_query: Query<&Children, With<Toolbelt>>,\r\n    mut tool_query: Query<&mut ScrollTool>,\r\n) {\r\n    for event in sprint_events.read() {\r\n        let character_id = match event {\r\n            SprintEvent::Active { character_id, .. } => character_id,\r\n            SprintEvent::Stop { character_id } => character_id,\r\n        };\r\n        let Ok(character) = character_query.get(*character_id) else {\r\n            warn!(\"Character {:?} does not exist\", character_id);\r\n            continue;\r\n        };\r\n        let character_kids = character;\r\n        let tool_ids = character_kids\r\n            .iter()\r\n            .filter_map(|kid| toolbelt_query.get(*kid).ok())\r\n            .flat_map(|toolbelt| toolbelt.iter())\r\n            .filter(|kid| tool_query.contains(**kid))\r\n            .cloned()\r\n            .collect_vec();\r\n\r\n        match event {\r\n            SprintEvent::Active { throttle, .. } => {\r\n                let mut iter = tool_query.iter_many_mut(&tool_ids);\r\n                while let Some(mut tool) = iter.fetch_next() {\r\n                    tool.speed = (tool.default_speed, tool.sprint_speed).lerp(*throttle);\r\n                }\r\n            }\r\n            SprintEvent::Stop { .. } => {\r\n                let mut iter = tool_query.iter_many_mut(&tool_ids);\r\n                while let Some(mut tool) = iter.fetch_next() {\r\n                    tool.speed = tool.default_speed;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui_automation_types\\src\\vscode_ui_types.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse itertools::Itertools;\r\nuse serde::Deserialize;\r\nuse serde::Serialize;\r\nuse std::fmt;\r\nuse std::fmt::Display;\r\nuse std::fmt::Formatter;\r\n\r\nuse crate::prelude::ElementInfo;\r\n\r\n#[derive(Debug)]\r\npub enum VSCodeResolveError {\r\n    UI(uiautomation::Error),\r\n    UnknownSideTabKind(String),\r\n    UnknownState { kids: Vec<ElementInfo> },\r\n}\r\nimpl std::error::Error for VSCodeResolveError {}\r\nimpl std::fmt::Display for VSCodeResolveError {\r\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\r\n        match self {\r\n            VSCodeResolveError::UI(e) => write!(f, \"UIAutomation error: {}\", e),\r\n            VSCodeResolveError::UnknownSideTabKind(s) => {\r\n                write!(f, \"Unknown side tab kind: {}\", s)\r\n            }\r\n            VSCodeResolveError::UnknownState { kids } => {\r\n                write!(f, \"Unknown state with {} children: {:?}\", kids.len(), kids)\r\n            }\r\n        }\r\n    }\r\n}\r\nimpl From<uiautomation::Error> for VSCodeResolveError {\r\n    fn from(e: uiautomation::Error) -> Self {\r\n        VSCodeResolveError::UI(e)\r\n    }\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]\r\npub enum View {\r\n    Explorer {\r\n        sticky: Vec<ExplorerItem>,\r\n        items: Vec<ExplorerItem>,\r\n    },\r\n    Unknown {},\r\n}\r\nimpl Display for View {\r\n    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {\r\n        match self {\r\n            View::Explorer { sticky, items } => {\r\n                writeln!(f, \"Explorer entries:\")?;\r\n                writeln!(f, \"=== BEGIN STICKY ===\")?;\r\n                for item in sticky.iter().sorted_by_key(|x| x.bounds.min.y) {\r\n                    writeln!(\r\n                        f,\r\n                        \"{}- {} ({})\",\r\n                        \" \".repeat(item.ui_level as usize),\r\n                        item.label.clone()\r\n                            + if matches!(item.kind, ExplorerItemKind::Directory { .. }) {\r\n                                \"/\"\r\n                            } else {\r\n                                \"\"\r\n                            },\r\n                        item.path\r\n                    )?;\r\n                }\r\n                writeln!(f, \"=== END STICKY ===\")?;\r\n                for item in items.iter().sorted_by_key(|x| x.bounds.min.y) {\r\n                    writeln!(\r\n                        f,\r\n                        \"{}- {} ({})\",\r\n                        \" \".repeat(item.ui_level as usize),\r\n                        item.label.clone()\r\n                            + if matches!(item.kind, ExplorerItemKind::Directory { .. }) {\r\n                                \"/\"\r\n                            } else {\r\n                                \"\"\r\n                            },\r\n                        item.path\r\n                    )?;\r\n                }\r\n                fmt::Result::Ok(())\r\n            }\r\n            View::Unknown {} => {\r\n                writeln!(f, \"Unknown view\")?;\r\n                fmt::Result::Ok(())\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]\r\npub struct VSCodeWindowHeader {}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]\r\npub struct VSCodeWindowBody {\r\n    pub editor_area: EditorArea,\r\n    pub right_tab: SideTab,\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]\r\npub struct VSCodeWindowFooter {\r\n    pub cursor_position: IVec2,\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]\r\npub struct VSCodeWindow {\r\n    pub focused: bool,\r\n    pub header: VSCodeWindowHeader,\r\n    pub body: VSCodeWindowBody,\r\n    pub footer: VSCodeWindowFooter,\r\n}\r\n\r\nimpl Display for VSCodeWindow {\r\n    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {\r\n        writeln!(\r\n            f,\r\n            \"Visual Studio Code{}\",\r\n            if self.focused { \" (focused)\" } else { \"\" }\r\n        )?;\r\n\r\n        // writeln!(f, \"Side tabs:\")?;\r\n        // for tab in self.body.side_nav.iter() {\r\n        //     match tab {\r\n        //         SideTab::Open { kind, view } => {\r\n        //             writeln!(f, \"- (open) {:?} {{{{\\n{}}}}}\", kind, view)?;\r\n        //         }\r\n        //         SideTab::Closed { kind } => {\r\n        //             writeln!(f, \"- {:?}\", kind)?;\r\n        //         }\r\n        //     }\r\n        // }\r\n\r\n        writeln!(f, \"Editor groups:\")?;\r\n        for (i, group) in self.body.editor_area.groups.iter().enumerate() {\r\n            writeln!(f, \"Group {} tabs:\", i + 1)?;\r\n            for tab in group.tabs.iter() {\r\n                if tab.active {\r\n                    writeln!(f, \"- (active) {}\", tab.title)?;\r\n                } else {\r\n                    writeln!(f, \"- {}\", tab.title)?;\r\n                }\r\n            }\r\n            if let Some(ref content) = group.content {\r\n                writeln!(\r\n                    f,\r\n                    \"Group {} buffer:\\n=======\\n{}\\n=======\",\r\n                    i + 1,\r\n                    content.content\r\n                )?;\r\n            }\r\n        }\r\n\r\n        writeln!(f, \"Cursor position: {:?}\", self.footer.cursor_position)?;\r\n\r\n        fmt::Result::Ok(())\r\n    }\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]\r\npub enum SideTab {\r\n    Closed { kind: SideTabKind },\r\n    Open { kind: SideTabKind, view: View },\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]\r\npub enum ExplorerItemKind {\r\n    File,\r\n    Directory { expanded: bool },\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]\r\npub struct ExplorerItem {\r\n    pub label: String,\r\n    pub path: String,\r\n    pub ui_position_in_set: u32,\r\n    pub ui_size_of_set: u32,\r\n    pub ui_level: u32,\r\n    pub bounds: IRect,\r\n    pub kind: ExplorerItemKind,\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]\r\npub struct EditorArea {\r\n    pub groups: Vec<EditorGroup>,\r\n}\r\nimpl EditorArea {\r\n    pub fn get_expected_automation_id() -> &'static str {\r\n        \"workbench.parts.editor\"\r\n    }\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]\r\npub struct EditorGroup {\r\n    pub tabs: Vec<EditorTab>,\r\n    pub content: Option<EditorContent>,\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]\r\npub struct EditorTab {\r\n    pub title: String,\r\n    pub active: bool,\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]\r\npub struct EditorContent {\r\n    pub content: String,\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]\r\npub enum SideTabKind {\r\n    Explorer,\r\n    Search,\r\n    SourceControl,\r\n    RunAndDebug,\r\n    Extensions,\r\n    GitLens,\r\n    Azure,\r\n    Jupyter,\r\n    Chat,\r\n    GitHubActions,\r\n    Todo,\r\n}\r\nimpl SideTabKind {\r\n    pub fn variants() -> Vec<SideTabKind> {\r\n        vec![\r\n            SideTabKind::Explorer,\r\n            SideTabKind::Search,\r\n            SideTabKind::SourceControl,\r\n            SideTabKind::RunAndDebug,\r\n            SideTabKind::Extensions,\r\n            SideTabKind::GitLens,\r\n            SideTabKind::Azure,\r\n            SideTabKind::Jupyter,\r\n            SideTabKind::Chat,\r\n            SideTabKind::GitHubActions,\r\n            SideTabKind::Todo,\r\n        ]\r\n    }\r\n    pub fn get_view_automation_id(&self) -> Option<&str> {\r\n        match self {\r\n            SideTabKind::Explorer => Some(\"workbench.view.explorer\"),\r\n            _ => None,\r\n        }\r\n    }\r\n}\r\nimpl TryFrom<String> for SideTabKind {\r\n    type Error = VSCodeResolveError;\r\n    fn try_from(s: String) -> Result<Self, Self::Error> {\r\n        let before_first_lparen = s.split_once(\" (\").map(|x| x.0).unwrap_or(s.as_str());\r\n        match before_first_lparen {\r\n            \"Explorer\" => Ok(SideTabKind::Explorer),\r\n            \"Search\" => Ok(SideTabKind::Search),\r\n            \"Source Control\" => Ok(SideTabKind::SourceControl),\r\n            \"Run and Debug\" => Ok(SideTabKind::RunAndDebug),\r\n            \"Extensions\" => Ok(SideTabKind::Extensions),\r\n            \"GitLens\" => Ok(SideTabKind::GitLens),\r\n            \"Azure\" => Ok(SideTabKind::Azure),\r\n            \"Jupyter\" => Ok(SideTabKind::Jupyter),\r\n            \"Chat\" => Ok(SideTabKind::Chat),\r\n            \"GitHub Actions\" => Ok(SideTabKind::GitHubActions),\r\n            \"TODOs\" => Ok(SideTabKind::Todo),\r\n            _ => Err(VSCodeResolveError::UnknownSideTabKind(s)),\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\text_asset_types\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_text_asset_types\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\nserde = { workspace = true }\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\taskbar_tool\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_taskbar_tool\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\ncursor_hero_taskbar_types = { workspace = true }\r\ncursor_hero_ui_automation = { workspace = true }\r\ncursor_hero_toolbelt_types = { workspace = true }\r\ncursor_hero_screen = { workspace = true }\r\ncursor_hero_bevy = { workspace = true }\r\ncursor_hero_tools = { workspace = true }\r\nbevy_xpbd_2d = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui_automation\\src\\taskbar.rs\r\n\r\n````rust\r\nuse crate::gather_children::gather_children;\r\nuse crate::gather_children::StopBehaviour;\r\nuse crate::prelude::*;\r\nuse uiautomation::controls::ControlType;\r\nuse uiautomation::UIAutomation;\r\n\r\npub fn get_taskbar() -> Result<Taskbar, uiautomation::Error> {\r\n    let automation = UIAutomation::new()?;\r\n    let root = automation.get_root_element()?;\r\n    let taskbar_matcher = automation\r\n        .create_matcher()\r\n        .from(root)\r\n        .classname(\"MSTaskListWClass\")\r\n        .control_type(ControlType::ToolBar);\r\n    let taskbar = taskbar_matcher.find_first()?;\r\n    let taskbar_entry_walker = automation.create_tree_walker()?;\r\n    let taskbar_entries = gather_children(\r\n        &taskbar_entry_walker,\r\n        &taskbar,\r\n        &StopBehaviour::TaskbarEndEncountered,\r\n    );\r\n    let entries = taskbar_entries\r\n        .into_iter()\r\n        .map(|entry| TaskbarEntry {\r\n            name: entry.get_name().unwrap_or_default(),\r\n            bounds: entry\r\n                .get_bounding_rectangle()\r\n                .unwrap_or_default()\r\n                .to_bevy_irect(),\r\n        })\r\n        .collect();\r\n    Ok(Taskbar { entries })\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use crate::prelude::get_taskbar;\r\n\r\n    #[test]\r\n    fn test_get_taskbar() {\r\n        let taskbar = get_taskbar().unwrap();\r\n        assert!(taskbar.entries.len() > 0);\r\n        // print the entries\r\n        for entry in taskbar.entries {\r\n            println!(\"entry: {:?}\", entry);\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\physics_debug\\src\\physics_debug_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n\r\npub struct PhysicsDebugPlugin;\r\n\r\nimpl Plugin for PhysicsDebugPlugin {\r\n    #[allow(unused_variables)]\r\n    fn build(&self, app: &mut App) {\r\n        // side effect: enabling this will cause tools to spawn visible instead of hidden\r\n        // app.add_plugins(bevy_xpbd_2d::plugins::PhysicsDebugPlugin::default());\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\taskbar_types\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_taskbar_types\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui_automation\\src\\resolve_vscode.rs\r\n\r\n````rust\r\nuse crate::gather_children::GatherChildrenable;\r\nuse crate::gather_children::StopBehaviour;\r\nuse anyhow::Context;\r\nuse anyhow::Result;\r\nuse bevy::math::IVec2;\r\nuse cursor_hero_ui_automation_types::prelude::*;\r\nuse itertools::Itertools;\r\nuse uiautomation::types::TreeScope;\r\nuse uiautomation::types::UIProperty;\r\nuse uiautomation::variants::Variant;\r\nuse uiautomation::UIAutomation;\r\nuse uiautomation::UIElement;\r\nuse uiautomation::UITreeWalker;\r\n\r\npub(crate) fn resolve_vscode(\r\n    elem: &UIElement,\r\n    automation: &UIAutomation,\r\n    focused: bool,\r\n) -> Result<AppWindow> {\r\n    let walker = automation.create_tree_walker().context(\"creating walker\")?;\r\n    let root = elem;\r\n\r\n    let temp = root\r\n        .drill(&walker, vec![0, 0, 0, 0, 0, 1])\r\n        .context(\"drilling temp\")?;\r\n\r\n    let body = temp\r\n        .drill(&walker, vec![1, 0, 1])\r\n        .context(\"drilling body\")?;\r\n    let body = match resolve_body(&body, &walker) {\r\n        Ok(body) => body,\r\n        Err(e) => {\r\n            return Err(e.context(\"resolving body\"));\r\n        }\r\n    };\r\n\r\n    let footer = temp.drill(&walker, vec![2, 0]).context(\"drilling footer\")?;\r\n    let footer = resolve_footer(&footer, automation).context(\"resolving footer\")?;\r\n    drop(temp);\r\n\r\n    Ok(AppWindow::VSCode(VSCodeWindow {\r\n        focused,\r\n        header: VSCodeWindowHeader {},\r\n        body,\r\n        footer,\r\n    }))\r\n}\r\n\r\nfn resolve_body(body: &UIElement, walker: &UITreeWalker) -> Result<VSCodeWindowBody> {\r\n    let workbench_parts_editor = body\r\n        .drill(walker, vec![0, 0, 1, 0, 0])\r\n        .context(\"drilling to find editor area\")?;\r\n    if workbench_parts_editor.get_automation_id()? != EditorArea::get_expected_automation_id() {\r\n        return Err(AppResolveError::BadStructure(format!(\r\n            \"workbench_parts_editor has wrong automation id, got unexpected element {:?}\",\r\n            workbench_parts_editor.get_runtime_id(),\r\n        ))\r\n        .into());\r\n    }\r\n    let editor_groups = workbench_parts_editor\r\n        .drill(walker, vec![0, 0, 0, 1])\r\n        .context(\"drilling to find editor groups\")?\r\n        .gather_children(walker, &StopBehaviour::EndOfSiblings)\r\n        .into_iter()\r\n        .map(|group_elem| {\r\n            let tab_container = group_elem\r\n                .drill(walker, vec![0, 0, 0])\r\n                .context(\"drilling to find editor groups tab container\")?;\r\n            let selected: Option<String> = tab_container\r\n                .get_property_value(UIProperty::SelectionSelection)?\r\n                .try_into()\r\n                .ok();\r\n            let group_tabs = tab_container\r\n                .gather_children(walker, &StopBehaviour::EndOfSiblings)\r\n                .into_iter()\r\n                .map(|group_tab_elem| {\r\n                    let title = group_tab_elem.get_name()?;\r\n                    let active = selected == Some(title.clone());\r\n                    Ok(EditorTab { title, active })\r\n                })\r\n                .filter_map(|r: Result<EditorTab>| r.ok())\r\n                .collect();\r\n            let content_elem = group_elem\r\n                .drill(walker, vec![1, 0, 0, 1])\r\n                .context(\"drilling to find group content\")?;\r\n            let content = content_elem\r\n                .get_property_value(UIProperty::LegacyIAccessibleValue)\r\n                .map(|variant| variant.to_string())\r\n                .map(|text_content| EditorContent {\r\n                    content: text_content,\r\n                })\r\n                .ok();\r\n\r\n            Ok(EditorGroup {\r\n                tabs: group_tabs,\r\n                content,\r\n            })\r\n        })\r\n        .filter_map(|r: Result<EditorGroup>| r.ok())\r\n        .collect();\r\n    let editor_area = EditorArea {\r\n        groups: editor_groups,\r\n    };\r\n\r\n    // let side_nav = state\r\n    //     .get_side_nav_tabs_root_elem()\r\n    //     .drill(walker, vec![0, 0]).context(\"drilling to find side_nav\")?\r\n    //     .gather_children(walker, &StopBehaviour::LastChildEncountered);\r\n    // // println!(\"side_nav: {:?}\", side_nav);\r\n    // let side_nav = side_nav\r\n    //     .into_iter()\r\n    //     .filter(|elem| elem.get_control_type() == Ok(ControlType::TabItem))\r\n    //     .map(|elem| {\r\n    //         let name = elem.get_name()?;\r\n    //         let kind: SideTabKind = SideTabKind::try_from(name)?;\r\n    //         let active = elem\r\n    //             .get_property_value(UIProperty::ExpandCollapseExpandCollapseState)\r\n    //             .map(|v| v.try_into() == Ok(ExpandCollapseState::Expanded as i32))\r\n    //             .unwrap_or_default();\r\n    //         if active {\r\n    //             let view = state\r\n    //                 .get_side_nav_view_root_elem()\r\n    //                 .drill(walker, vec![1]).context(\"drilling to find side tab view\")?;\r\n    //             let view = match view.get_automation_id() {\r\n    //                 Ok(id)\r\n    //                     if Some(id.as_str()) == SideTabKind::Explorer.get_view_automation_id() =>\r\n    //                 {\r\n    //                     fn as_explorer_item(\r\n    //                         walker: &UITreeWalker,\r\n    //                         tree_item: UIElement,\r\n    //                     ) -> Result<ExplorerItem> {\r\n    //                         let label = tree_item.get_name()?;\r\n    //                         let ui_position_in_set = tree_item\r\n    //                             .get_property_value(UIProperty::PositionInSet)?\r\n    //                             .try_into()?;\r\n    //                         let ui_size_of_set = tree_item\r\n    //                             .get_property_value(UIProperty::SizeOfSet)?\r\n    //                             .try_into()?;\r\n    //                         let ui_level = tree_item\r\n    //                             .get_property_value(UIProperty::Level)?\r\n    //                             .try_into()?;\r\n    //                         let bounds = tree_item.get_bounding_rectangle()?.to_bevy_irect();\r\n    //                         let kind = tree_item\r\n    //                             .get_pattern::<UIExpandCollapsePattern>()\r\n    //                             .ok()\r\n    //                             .map(|p| ExplorerItemKind::Directory {\r\n    //                                 expanded: p.get_state() == Ok(ExpandCollapseState::Expanded),\r\n    //                             })\r\n    //                             .unwrap_or(ExplorerItemKind::File);\r\n    //                         let path = tree_item\r\n    //                             .drill(\r\n    //                                 walker,\r\n    //                                 match kind {\r\n    //                                     ExplorerItemKind::File => vec![0, 1, 0],\r\n    //                                     ExplorerItemKind::Directory { .. } => {\r\n    //                                         vec![0, 2, 0]\r\n    //                                     }\r\n    //                                 },\r\n    //                             ).context(\"drilling to find explorer item path\")?\r\n    //                             .get_name()?;\r\n    //                         Ok(ExplorerItem {\r\n    //                             label,\r\n    //                             path,\r\n    //                             ui_position_in_set,\r\n    //                             ui_size_of_set,\r\n    //                             ui_level,\r\n    //                             bounds,\r\n    //                             kind,\r\n    //                         })\r\n    //                     }\r\n    //                     let sticky = view\r\n    //                         .drill(walker, vec![0, 1, 0, 0, 1, 0, 3]).context(\"drilling to find explorer sticky\")?\r\n    //                         .gather_children(walker, &StopBehaviour::EndOfSiblings)\r\n    //                         .into_iter()\r\n    //                         .filter_map(|tree_item| as_explorer_item(walker, tree_item).ok())\r\n    //                         .collect();\r\n    //                     let items = view\r\n    //                         .drill(walker, vec![0, 1, 0, 0, 1, 0, 0]).context(\"drilling to find explorer items\")?\r\n    //                         .gather_children(walker, &StopBehaviour::EndOfSiblings)\r\n    //                         .into_iter()\r\n    //                         .filter_map(|tree_item| as_explorer_item(walker, tree_item).ok())\r\n    //                         .collect();\r\n    //                     View::Explorer { sticky, items }\r\n    //                 }\r\n    //                 _ => {\r\n    //                     View::Unknown {}\r\n    //                     // elem: view.into()\r\n    //                 }\r\n    //             };\r\n\r\n    //             Ok(SideTab::Open {\r\n    //                 kind,\r\n    //                 // button: elem.into(),\r\n    //                 view,\r\n    //             })\r\n    //         } else {\r\n    //             Ok(SideTab::Closed {\r\n    //                 kind,\r\n    //                 // button: elem.into(),\r\n    //             })\r\n    //         }\r\n    //     })\r\n    //     .filter_map(|res: Result<SideTab>| res.ok())\r\n    //     .collect();\r\n\r\n    let right_tab = SideTab::Closed {\r\n        kind: SideTabKind::Explorer,\r\n    };\r\n\r\n    Ok(VSCodeWindowBody {\r\n        editor_area,\r\n        right_tab,\r\n    })\r\n}\r\n\r\nfn resolve_footer(footer: &UIElement, automation: &UIAutomation) -> Result<VSCodeWindowFooter> {\r\n    let condition = automation\r\n        .create_property_condition(\r\n            UIProperty::AutomationId,\r\n            Variant::from(\"status.editor.selection\"),\r\n            None,\r\n        )\r\n        .context(\"creating condition\")?;\r\n    let cursor_position_elem = footer\r\n        .find_first(TreeScope::Children, &condition)\r\n        .context(\"finding first\")?;\r\n    let text = cursor_position_elem.get_name().context(\"getting name\")?;\r\n    // \"Ln 218, Col 5\"\r\n    // \"Ln 218, Col 5 (15 selected)\"\r\n\r\n    let cursor_position = text\r\n        .split(\", \")\r\n        .map(|part| part.split(' ').nth(1).and_then(|s| s.parse::<usize>().ok()))\r\n        .collect_vec();\r\n    let cursor_position = match cursor_position.as_slice() {\r\n        [Some(line), Some(column)] => {\r\n            IVec2::new(*column as i32, *line as i32)\r\n        }\r\n        _ => {\r\n            return Err(AppResolveError::BadStructure(format!(\r\n                \"Bad cursor position {:?}\",\r\n                cursor_position\r\n            )))\r\n            .context(\"bad text cursor position composition\");\r\n        }\r\n    };\r\n    Ok(VSCodeWindowFooter { cursor_position })\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\tools\\src\\default_wheel_tool.rs\r\n\r\n````rust\r\nuse crate::prelude::*;\r\nuse bevy::prelude::*;\r\nuse cursor_hero_toolbelt_types::prelude::*;\r\n\r\npub struct DefaultWheelToolPlugin;\r\n\r\nimpl Plugin for DefaultWheelToolPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<DefaultWheelTool>();\r\n        app.add_systems(Update, toolbelt_events);\r\n        app.add_systems(Update, tick);\r\n    }\r\n}\r\n\r\n#[derive(Component, Reflect, Default)]\r\nstruct DefaultWheelTool;\r\n\r\nfn toolbelt_events(\r\n    mut commands: Commands,\r\n    asset_server: Res<AssetServer>,\r\n    mut reader: EventReader<ToolbeltPopulateEvent>,\r\n) {\r\n    for event in reader.read() {\r\n        let (ToolbeltLoadout::Taskbar\r\n        | ToolbeltLoadout::Keyboard\r\n        | ToolbeltLoadout::WindowPosition) = event.loadout\r\n        else {\r\n            continue;\r\n        };\r\n        ToolSpawnConfig::<DefaultWheelTool, NoInputs>::new(DefaultWheelTool, event.id, event)\r\n            .with_src_path(file!().into())\r\n            .guess_name(file!())\r\n            .guess_image(file!(), &asset_server, \"png\")\r\n            .with_description(\"Swaps to default tools\")\r\n            .with_starting_state(StartingState::Inactive)\r\n            .spawn(&mut commands);\r\n    }\r\n}\r\n\r\nfn tick(\r\n    mut commands: Commands,\r\n    tool_query: Query<&Parent, (Added<ActiveTool>, With<DefaultWheelTool>)>,\r\n    mut toolbelt_events: EventWriter<ToolbeltPopulateEvent>,\r\n) {\r\n    for toolbelt_id in tool_query.iter() {\r\n        info!(\"Switching toolbelt {:?} to default tools\", toolbelt_id);\r\n        let toolbelt_id = toolbelt_id.get();\r\n        commands.entity(toolbelt_id).despawn_descendants();\r\n        toolbelt_events.send(ToolbeltPopulateEvent {\r\n            id: toolbelt_id,\r\n            loadout: ToolbeltLoadout::Default,\r\n        });\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\observation_types\\src\\observation_types.rs\r\n\r\n````rust\r\nuse std::fmt;\r\nuse std::fmt::Display;\r\nuse std::fmt::Formatter;\r\nuse std::time::Duration;\r\n\r\nuse bevy::prelude::*;\r\nuse chrono::DateTime;\r\nuse chrono::Local;\r\nuse cursor_hero_ui_automation_types::prelude::UiSnapshot;\r\nuse serde::Deserialize;\r\nuse serde::Serialize;\r\n#[derive(Component, Reflect, Default)]\r\npub struct ObservationTool {\r\n    #[reflect(ignore)]\r\n    pub last_inference: Option<DateTime<Local>>,\r\n    pub _whats_new: Option<WhatsNew>, // latest value for visual inspection\r\n}\r\n\r\n#[derive(Debug, Reflect, PartialEq, Eq, Clone, Copy)]\r\npub enum WhatsNew {\r\n    Nothing,\r\n    SelfChat,\r\n    ChatReceived,\r\n    ChatReceivedButTheyProbablyStillThinking,\r\n    MemoryRestored,\r\n    UISnapshot,\r\n}\r\n\r\nimpl WhatsNew {\r\n    /// When the agent replies, it sends a chat, which becomes its own observation\r\n    /// Letting this trigger the inference again is a loop\r\n    /// We want to allow this loop, but only after a longer period of inactivity compared\r\n    /// to if a chat was received from another entity.\r\n    pub fn reply_delay(&self) -> Duration {\r\n        match self {\r\n            WhatsNew::SelfChat => Duration::from_secs(60),\r\n            WhatsNew::Nothing => Duration::MAX,\r\n            WhatsNew::ChatReceived => Duration::ZERO,\r\n            WhatsNew::ChatReceivedButTheyProbablyStillThinking => Duration::from_secs(25),\r\n            WhatsNew::MemoryRestored => Duration::from_secs(5),\r\n            WhatsNew::UISnapshot => Duration::from_secs(60 * 2),\r\n        }\r\n    }\r\n}\r\n\r\nimpl Ord for WhatsNew {\r\n    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\r\n        // In-declaration order of importance, higher is more important\r\n        (*self as u32).cmp(&(*other as u32))\r\n    }\r\n}\r\nimpl PartialOrd for WhatsNew {\r\n    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {\r\n        Some(self.cmp(other))\r\n    }\r\n}\r\n\r\n#[derive(Component, Reflect, Default, Serialize, Deserialize, Debug, Clone, PartialEq)]\r\npub struct ObservationBuffer {\r\n    pub observations: Vec<ObservationBufferEntry>,\r\n    pub log_level: ObservationLogLevel, // TODO: investigate always logging but updating the log filter instead of not logging based on level\r\n}\r\n\r\n#[derive(Debug, Reflect, Default, PartialEq, Eq, Serialize, Deserialize, Clone)]\r\npub enum ObservationLogLevel {\r\n    #[default]\r\n    Default,\r\n    All,\r\n}\r\n\r\n#[derive(Component, Reflect, Debug, Serialize, Deserialize, PartialEq, Clone)]\r\npub struct ObservationBufferEntry {\r\n    #[reflect(ignore)]\r\n    pub datetime: DateTime<Local>,\r\n    pub origin: SomethingObservableHappenedEvent,\r\n}\r\nimpl std::fmt::Display for ObservationBufferEntry {\r\n    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {\r\n        write!(f, \"{}: {}\", self.datetime, self.origin)\r\n    }\r\n}\r\n\r\n#[derive(Event, Debug, Clone, Reflect)]\r\npub enum ObservationBufferEvent {\r\n    Updated { buffer_id: Entity },\r\n}\r\n\r\n#[derive(Event, Debug, Clone, Reflect, Serialize, Deserialize, PartialEq)]\r\npub enum SomethingObservableHappenedEvent {\r\n    Chat {\r\n        environment_id: Option<Entity>,\r\n        character_id: Entity,\r\n        character_name: String,\r\n        message: String,\r\n    },\r\n    MemoryRestored {\r\n        observation_buffer_id: Entity,\r\n    },\r\n    UISnapshot {\r\n        environment_id: Option<Entity>,\r\n        snapshot: UiSnapshot,\r\n    },\r\n    // BrickEnteredEnvironment {\r\n\r\n    // }\r\n}\r\nimpl Display for SomethingObservableHappenedEvent {\r\n    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {\r\n        match self {\r\n            SomethingObservableHappenedEvent::Chat {\r\n                character_name,\r\n                message,\r\n                ..\r\n            } => {\r\n                write!(f, \"{}: {}\", character_name, message)\r\n            }\r\n            SomethingObservableHappenedEvent::MemoryRestored { .. } => {\r\n                write!(\r\n                    f,\r\n                    \"The game has restarted and the agent memory has been restored.\"\r\n                )\r\n            }\r\n            SomethingObservableHappenedEvent::UISnapshot { snapshot, .. } => {\r\n                write!(f, \"Snapshot with {} windows\", snapshot.app_windows.len())\r\n            }\r\n        }\r\n    }\r\n}\r\nimpl SomethingObservableHappenedEvent {\r\n    pub fn into_whats_new(&self, observation_buffer_id: Entity) -> WhatsNew {\r\n        match self {\r\n            SomethingObservableHappenedEvent::Chat {\r\n                character_id: event_character_id,\r\n                ..\r\n            } if *event_character_id == observation_buffer_id => WhatsNew::SelfChat,\r\n            SomethingObservableHappenedEvent::Chat { message, .. }\r\n                if message.ends_with(\"...\")\r\n                    || !message.ends_with('.')\r\n                        && !message.ends_with('!')\r\n                        && !message.ends_with('?') =>\r\n            {\r\n                WhatsNew::ChatReceivedButTheyProbablyStillThinking\r\n            }\r\n            SomethingObservableHappenedEvent::Chat { .. } => WhatsNew::ChatReceived,\r\n            SomethingObservableHappenedEvent::MemoryRestored { .. } => WhatsNew::MemoryRestored,\r\n            SomethingObservableHappenedEvent::UISnapshot { .. } => WhatsNew::UISnapshot,\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\physics\\src\\physics_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n\r\nuse bevy_xpbd_2d::math::Vector;\r\nuse bevy_xpbd_2d::plugins::setup::Physics;\r\nuse bevy_xpbd_2d::plugins::sync::SyncConfig;\r\nuse bevy_xpbd_2d::plugins::PhysicsPlugins;\r\nuse bevy_xpbd_2d::resources::Gravity;\r\n\r\npub struct PhysicsPlugin;\r\n\r\nimpl Plugin for PhysicsPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_plugins(PhysicsPlugins::default())\r\n            .insert_resource(Gravity(Vector::ZERO))\r\n            .insert_resource(Time::new_with(Physics::fixed_hz(144.0)))\r\n            .insert_resource(SyncConfig {\r\n                position_to_transform: true,\r\n                transform_to_position: true,\r\n            });\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\screen\\src\\screen_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse cursor_hero_bevy::prelude::IExpandable;\r\nuse cursor_hero_bevy::prelude::NegativeYIRect;\r\nuse cursor_hero_environment_types::prelude::*;\r\nuse cursor_hero_level_bounds::level_bounds_plugin::LevelBoundsEvent;\r\nuse cursor_hero_winutils::win_screen_capture::get_all_monitors;\r\nuse cursor_hero_winutils::win_screen_capture::MonitorId;\r\nuse image::DynamicImage;\r\nuse screenshots::Screen as ScreenLib;\r\nuse std::collections::VecDeque;\r\n\r\nuse crate::ToBevyIRect;\r\n\r\npub struct ScreenPlugin;\r\nimpl Plugin for ScreenPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Update, spawn_screens_in_new_environments)\r\n            .register_type::<Screen>()\r\n            .register_type::<ScreenParent>();\r\n    }\r\n}\r\n\r\n#[derive(Component, Default, Reflect)]\r\n#[reflect(Component)]\r\npub struct Screen {\r\n    pub id: MonitorId,\r\n    pub name: String,\r\n}\r\n#[derive(Component, Default, Reflect)]\r\npub struct GameScreen;\r\n#[derive(Component, Default, Reflect)]\r\npub struct HostScreen;\r\n\r\n#[derive(Component, Reflect)]\r\npub struct ScreenParent;\r\n\r\nfn spawn_screens_in_new_environments(\r\n    mut populate_events: EventReader<PopulateEnvironmentEvent>,\r\n    mut commands: Commands,\r\n    mut textures: ResMut<Assets<Image>>,\r\n    mut level_bounds_events: EventWriter<LevelBoundsEvent>,\r\n    environment_query: Query<(Option<&HostEnvironment>, Option<&AgentEnvironment>)>,\r\n) {\r\n    for event in populate_events.read() {\r\n        let environment_id = event.environment_id;\r\n        let Ok((is_host, is_game)) = environment_query.get(event.environment_id) else {\r\n            continue;\r\n        };\r\n        match (is_host, is_game) {\r\n            (Some(_), _) => {\r\n                info!(\"Populating host environment with screens\");\r\n                commands.entity(environment_id).with_children(|parent| {\r\n                    let mut screen_parent_commands = parent.spawn((\r\n                        SpatialBundle::default(),\r\n                        ScreenParent,\r\n                        Name::new(\"Screens\"),\r\n                    ));\r\n\r\n                    // create a Screen component for each screen\r\n                    let mut screen_names = get_all_monitors()\r\n                        .unwrap()\r\n                        .iter()\r\n                        .map(|monitor| monitor.info.name.clone())\r\n                        .collect::<VecDeque<String>>();\r\n                    // todo: remove this and use win_screen_capture\r\n\r\n                    let mut level_bounds = vec![];\r\n\r\n                    screen_parent_commands.with_children(|screen_parent| {\r\n                        for screen in ScreenLib::all().unwrap().iter() {\r\n                            let image_buf = screen.capture().unwrap();\r\n                            let dynamic_image = DynamicImage::ImageRgba8(image_buf);\r\n                            let image = Image::from_dynamic(dynamic_image, true);\r\n                            let texture = textures.add(image);\r\n                            let name = screen_names.pop_front().unwrap();\r\n                            let region = screen.display_info.to_bevy_irect().neg_y();\r\n                            screen_parent.spawn((\r\n                                SpriteBundle {\r\n                                    texture,\r\n                                    transform: Transform::from_translation(\r\n                                        region.center().extend(-1).as_vec3(),\r\n                                    ),\r\n                                    sprite: Sprite {\r\n                                        custom_size: Some(region.size().as_vec2()),\r\n                                        ..default()\r\n                                    },\r\n                                    ..Default::default()\r\n                                },\r\n                                Screen {\r\n                                    name: name.clone(),\r\n                                    id: screen.display_info.id,\r\n                                },\r\n                                HostScreen,\r\n                                Name::new(format!(\"Screen {}\", name)),\r\n                            ));\r\n\r\n                            level_bounds.push(region.expand((400, 400).into()));\r\n                        }\r\n                    });\r\n                    info!(\"Broadcasting {} level bounds events\", level_bounds.len());\r\n                    for area in level_bounds {\r\n                        level_bounds_events.send(LevelBoundsEvent::AddPlayArea {\r\n                            environment_id,\r\n                            area: area.as_rect(),\r\n                        });\r\n                    }\r\n                });\r\n            }\r\n            (_, Some(_)) => {\r\n                commands.entity(environment_id).with_children(|parent| {\r\n                    info!(\"Populating game environment with screens\");\r\n                    let mut screen_parent_commands = parent.spawn((\r\n                        SpatialBundle::default(),\r\n                        ScreenParent,\r\n                        Name::new(\"Screens\"),\r\n                    ));\r\n\r\n                    let mut level_bounds = vec![];\r\n\r\n                    screen_parent_commands.with_children(|screen_parent| {\r\n                        let region =\r\n                            IRect::from_corners(IVec2::new(0, 0), IVec2::new(1920, 1080)).neg_y();\r\n                        let name = \"Primary Screen\".to_string();\r\n                        screen_parent.spawn((\r\n                            SpriteBundle {\r\n                                sprite: Sprite {\r\n                                    custom_size: Some(region.size().as_vec2()),\r\n                                    ..default()\r\n                                },\r\n                                transform: Transform::from_translation(\r\n                                    region.center().extend(-1).as_vec3(),\r\n                                ),\r\n                                ..Default::default()\r\n                            },\r\n                            Screen {\r\n                                name: name.to_string(),\r\n                                id: 1,\r\n                            },\r\n                            GameScreen,\r\n                            Name::new(name),\r\n                        ));\r\n\r\n                        level_bounds.push(region.expand((400, 400).into()));\r\n                    });\r\n                    info!(\"Broadcasting {} level bounds events\", level_bounds.len());\r\n                    for area in level_bounds {\r\n                        level_bounds_events.send(LevelBoundsEvent::AddPlayArea {\r\n                            environment_id,\r\n                            area: area.as_rect(),\r\n                        });\r\n                    }\r\n                });\r\n            }\r\n            (None, None) => {\r\n                error!(\r\n                    \"Environment {:?} is not a host or game environment\",\r\n                    environment_id\r\n                );\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\taskbar_types\\src\\taskbar_types_plugin.rs\r\n\r\n````rust\r\nuse crate::prelude::*;\r\nuse bevy::prelude::*;\r\nuse bevy::sprite::Material2dPlugin;\r\n\r\npub struct TaskbarTypesPlugin;\r\n\r\nimpl Plugin for TaskbarTypesPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<Taskbar>();\r\n        app.add_event::<TaskbarEvent>();\r\n        app.add_plugins(Material2dPlugin::<TaskbarMaterial>::default());\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\start_menu_types\\src\\start_menu_types.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n\r\n#[derive(Component, Debug, Reflect)]\r\npub struct StartMenuButton;\r\n\r\n#[derive(Component, Debug, Reflect)]\r\npub struct StartMenu;\r\n\r\n#[derive(Event, Debug, Reflect)]\r\npub enum StartMenuEvent {\r\n    Open { start_menu_button_id: Entity },\r\n    Close { start_menu_button_id: Entity },\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui_automation\\src\\take_snapshot.rs\r\n\r\n````rust\r\nuse crate::gather_root_children::gather_root_children;\r\nuse crate::resolve_app::resolve_app;\r\nuse anyhow::Result;\r\nuse cursor_hero_ui_automation_types::prelude::*;\r\nuse uiautomation::UIAutomation;\r\n\r\npub fn take_snapshot() -> Result<UiSnapshot> {\r\n    let automation = UIAutomation::new()?;\r\n    let walker = automation.create_tree_walker()?;\r\n    // let walker = automation.get_raw_view_walker()?;\r\n    let top_level_children = gather_root_children(&automation, &walker)?;\r\n\r\n    let focused = automation.get_focused_element()?;\r\n    let focused_app = walker.normalize(&focused)?;\r\n\r\n    let mut apps = vec![];\r\n    for elem in top_level_children {\r\n        let focused = elem.get_runtime_id() == focused_app.get_runtime_id();\r\n        let resolved = resolve_app(&elem, &automation, focused)?;\r\n        if resolved != AppWindow::Unknown {\r\n            apps.push((elem, resolved));\r\n        }\r\n    }\r\n\r\n    let snapshot = UiSnapshot {\r\n        app_windows: apps.into_iter().map(|(_elem, app)| app).collect(),\r\n    };\r\n    Ok(snapshot)\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use windows::Win32::System::Com::CoInitializeEx;\r\n    use windows::Win32::System::Com::COINIT_MULTITHREADED;\r\n\r\n    use crate::prelude::take_snapshot;\r\n\r\n    #[test]\r\n    fn test_take_snapshot() {\r\n        //todo: put this in thread initialzed for COM like below\r\n        let snapshot = take_snapshot().unwrap();\r\n        assert!(snapshot.app_windows.len() > 0);\r\n    }\r\n\r\n    #[test]\r\n    fn test_take_snapshot_many() {\r\n        let handle = std::thread::spawn(move || -> windows::core::Result<()> {\r\n            unsafe {\r\n                // Initialize COM in MTA mode\r\n                // https://learn.microsoft.com/en-us/windows/win32/com/multithreaded-apartments\r\n                CoInitializeEx(None, COINIT_MULTITHREADED)?;\r\n\r\n                println!(\"COM initialized in MTA mode.\");\r\n\r\n                for i in 0..100 {\r\n                    let start = std::time::Instant::now();\r\n                    let snapshot = take_snapshot().unwrap();\r\n                    assert!(snapshot.app_windows.len() > 0);\r\n                    if i == 0 {\r\n                        println!(\"{}\", snapshot);\r\n                    }\r\n                    let end = std::time::Instant::now();\r\n                    println!(\"time: {:?}\", end - start);\r\n                    assert!(end - start < std::time::Duration::from_secs(1));\r\n                }\r\n\r\n                Ok(())\r\n            }\r\n        });\r\n\r\n        // Wait for the thread to complete its tasks and handle any errors\r\n        let _ = handle.join().unwrap();\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\physics_debug\\src\\lib.rs\r\n\r\n````rust\r\npub mod physics_debug_plugin;\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ollama\\src\\ollama.rs\r\n\r\n````rust\r\nuse cursor_hero_inference_types::inference_types::TextInferenceOptions;\r\nuse cursor_hero_ollama_types::ollama_types::OllamaStatus;\r\nuse reqwest::Client;\r\nuse std::error::Error;\r\n\r\nuse serde::Deserialize;\r\n\r\n#[derive(Debug, Deserialize)]\r\nstruct ApiResponse {\r\n    response: String,\r\n}\r\n\r\npub async fn generate(\r\n    prompt: &str,\r\n    options: Option<TextInferenceOptions>,\r\n) -> Result<String, Box<dyn Error>> {\r\n    let mut payload = serde_json::json!({\r\n        \"model\": \"whatevs\",\r\n        \"prompt\": prompt,\r\n        \"stream\": false\r\n    });\r\n    if let Some(options) = options {\r\n        // create empty object\r\n        let mut options_json = serde_json::json!({});\r\n\r\n        if let Some(num_predict) = options.num_predict {\r\n            options_json[\"num_predict\"] = serde_json::json!(num_predict);\r\n        }\r\n\r\n        if let Some(stop) = options.stop {\r\n            options_json[\"stop\"] = serde_json::json!(stop);\r\n        }\r\n\r\n        payload[\"options\"] = options_json;\r\n    }\r\n\r\n    let client = Client::new();\r\n\r\n    let res = client\r\n        .post(\"http://localhost:11434/api/generate\")\r\n        .json(&payload)\r\n        .send()\r\n        .await?;\r\n\r\n    if res.status().is_success() {\r\n        let api_response = res.json::<ApiResponse>().await?;\r\n        let mut text = api_response.response.as_str();\r\n        text = text.trim_end_matches(\"<dummy32000>\");\r\n        text = text.trim();\r\n        Ok(text.to_string())\r\n    } else {\r\n        let status = res.status();\r\n        let body = res.text().await?;\r\n        Err(Box::new(std::io::Error::new(\r\n            std::io::ErrorKind::Other,\r\n            format!(\"Failed to call API. Status: {} Body: {}\", status, body),\r\n        )))\r\n    }\r\n}\r\n\r\npub async fn get_status() -> Result<OllamaStatus, Box<dyn Error>> {\r\n    let client = Client::new();\r\n    match client.get(\"http://localhost:11434/\").send().await {\r\n        Ok(res) => match res.status().is_success() {\r\n            true => Ok(OllamaStatus::Alive),\r\n            false => Ok(OllamaStatus::Dead),\r\n        },\r\n        Err(_) => Ok(OllamaStatus::Dead),\r\n    }\r\n}\r\n\r\npub fn start() -> Result<(), Box<dyn Error>> {\r\n    // wt --window 0 --profile \"Ubuntu-22.04\" --colorScheme \"Ubuntu-22.04-ColorScheme\" --title \"Ollama Serve\" wsl -d Ubuntu-22.04 -- ollama serve\r\n    match std::process::Command::new(\"wt\")\r\n        .args([\r\n            \"--window\",\r\n            \"0\",\r\n            \"--profile\",\r\n            \"Ubuntu 22.04.3 LTS\",\r\n            \"--colorScheme\",\r\n            \"Ubuntu-22.04-ColorScheme\",\r\n            \"--title\",\r\n            \"Ollama Serve\",\r\n            \"wsl\",\r\n            \"-d\",\r\n            \"Ubuntu-22.04\",\r\n            \"--\",\r\n            \"ollama\",\r\n            \"serve\",\r\n        ])\r\n        .spawn()\r\n    {\r\n        Ok(_) => Ok(()),\r\n        Err(e) => Err(Box::new(e)),\r\n    }\r\n}\r\n\r\npub fn start_terminal() -> Result<(), Box<dyn Error>> {\r\n    match std::process::Command::new(\"wt\")\r\n        .args([\r\n            \"--window\",\r\n            \"0\",\r\n            \"--profile\",\r\n            \"Ubuntu 22.04.3 LTS\",\r\n            \"--colorScheme\",\r\n            \"Ubuntu-22.04-ColorScheme\",\r\n            \"--title\",\r\n            \"Ollama\",\r\n            \"wsl\",\r\n            \"-d\",\r\n            \"Ubuntu-22.04\",\r\n            \"--\",\r\n            \"bash\",\r\n            \"-l\",\r\n            \"-c\",\r\n            \"cd ~ && exec pwsh\",\r\n        ])\r\n        .spawn()\r\n    {\r\n        Ok(_) => Ok(()),\r\n        Err(e) => Err(Box::new(e)),\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\physics\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_physics\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\nbevy-inspector-egui = { workspace = true }\r\nbevy_xpbd_2d = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\start_menu\\src\\lib.rs\r\n\r\n````rust\r\npub mod start_menu_button_plugin;\r\npub mod start_menu_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::start_menu_plugin::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\tools\\src\\zoom_tool.rs\r\n\r\n````rust\r\nuse crate::prelude::*;\r\nuse bevy::prelude::*;\r\nuse bevy_inspector_egui::prelude::ReflectInspectorOptions;\r\nuse bevy_inspector_egui::InspectorOptions;\r\nuse cursor_hero_camera::camera_plugin::MainCamera;\r\nuse cursor_hero_character_types::prelude::*;\r\nuse cursor_hero_math::prelude::Lerp;\r\nuse cursor_hero_sprint_tool_types::sprint_tool_types_plugin::SprintEvent;\r\nuse cursor_hero_toolbelt_types::prelude::*;\r\nuse itertools::Itertools;\r\nuse leafwing_input_manager::prelude::*;\r\npub struct ZoomToolPlugin;\r\n\r\nimpl Plugin for ZoomToolPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<ZoomTool>();\r\n        app.add_plugins(InputManagerPlugin::<ZoomToolAction>::default());\r\n        app.add_systems(\r\n            Update,\r\n            (toolbelt_events, handle_input, handle_sprint_events),\r\n        );\r\n    }\r\n}\r\n\r\n#[derive(Component, InspectorOptions, Debug, Reflect)]\r\n#[reflect(Component, InspectorOptions)]\r\nstruct ZoomTool {\r\n    #[inspector(min = 0.0)]\r\n    speed: f32,\r\n    #[inspector(min = 0.0)]\r\n    default_speed: f32,\r\n    #[inspector(min = 0.0)]\r\n    sprint_speed: f32,\r\n    #[inspector(min = 0.0001, max = 10000.0)]\r\n    scale_min: f32,\r\n    #[inspector(min = 0.0001, max = 10000.0)]\r\n    scale_max: f32,\r\n}\r\nimpl Default for ZoomTool {\r\n    fn default() -> Self {\r\n        Self {\r\n            speed: 1.0,\r\n            default_speed: 1.0,\r\n            sprint_speed: 50.0,\r\n            scale_min: 0.001,\r\n            scale_max: 10.0,\r\n        }\r\n    }\r\n}\r\nfn toolbelt_events(\r\n    mut commands: Commands,\r\n    asset_server: Res<AssetServer>,\r\n    mut reader: EventReader<ToolbeltPopulateEvent>,\r\n) {\r\n    for event in reader.read() {\r\n        let ToolbeltLoadout::Default = event.loadout else {\r\n            continue;\r\n        };\r\n        ToolSpawnConfig::<_, ZoomToolAction>::new(ZoomTool::default(), event.id, event)\r\n            .with_src_path(file!().into())\r\n            .guess_name(file!())\r\n            .guess_image(file!(), &asset_server, \"png\")\r\n            .with_description(\"Send scroll events\")\r\n            .spawn(&mut commands);\r\n    }\r\n}\r\n\r\n#[derive(Actionlike, PartialEq, Eq, Clone, Copy, Hash, Debug, Reflect)]\r\nenum ZoomToolAction {\r\n    Out,\r\n    In,\r\n}\r\n\r\nimpl ZoomToolAction {\r\n    fn default_gamepad_binding(&self) -> UserInput {\r\n        match self {\r\n            Self::Out => GamepadButtonType::DPadLeft.into(),\r\n            Self::In => GamepadButtonType::DPadRight.into(),\r\n        }\r\n    }\r\n\r\n    fn default_mkb_binding(&self) -> UserInput {\r\n        match self {\r\n            Self::Out => KeyCode::Home.into(),\r\n            Self::In => KeyCode::End.into(),\r\n        }\r\n    }\r\n}\r\nimpl ToolAction for ZoomToolAction {\r\n    fn default_input_map(_event: &ToolbeltPopulateEvent) -> Option<InputMap<ZoomToolAction>> {\r\n        let mut input_map = InputMap::default();\r\n\r\n        for variant in ZoomToolAction::variants() {\r\n            input_map.insert(variant.default_mkb_binding(), variant);\r\n            input_map.insert(variant.default_gamepad_binding(), variant);\r\n        }\r\n        Some(input_map)\r\n    }\r\n}\r\n\r\nfn handle_input(\r\n    tool_query: Query<(&ActionState<ZoomToolAction>, &ZoomTool), With<ActiveTool>>,\r\n    mut camera_query: Query<&mut Transform, With<MainCamera>>,\r\n    time: Res<Time>,\r\n) {\r\n    for zoom_tool in tool_query.iter() {\r\n        let (tool_actions, tool) = zoom_tool;\r\n        let camera = camera_query.single_mut();\r\n        let mut camera_transform = camera;\r\n        if tool_actions.pressed(ZoomToolAction::Out) {\r\n            let mut scale = camera_transform.scale;\r\n            let diff = 0.1 * time.delta_seconds() * tool.speed;\r\n            scale *= Vec3::splat(1.0) + Vec2::splat(diff).extend(0.0);\r\n            debug!(\r\n                \"scale_min: {}, scale_max: {}\",\r\n                tool.scale_min, tool.scale_max\r\n            );\r\n            scale = scale.clamp(Vec3::splat(tool.scale_min), Vec3::splat(tool.scale_max));\r\n            camera_transform.scale = scale;\r\n            if tool_actions.just_pressed(ZoomToolAction::Out) {\r\n                info!(\"Zooming out\");\r\n            }\r\n        }\r\n        if tool_actions.pressed(ZoomToolAction::In) {\r\n            let mut scale = camera_transform.scale;\r\n            let diff = 0.1 * time.delta_seconds() * tool.speed;\r\n            scale *= Vec3::splat(1.0) - Vec2::splat(diff).extend(0.0);\r\n            debug!(\r\n                \"scale_min: {}, scale_max: {}\",\r\n                tool.scale_min, tool.scale_max\r\n            );\r\n            scale = scale.clamp(Vec3::splat(tool.scale_min), Vec3::splat(tool.scale_max));\r\n            camera_transform.scale = scale;\r\n            if tool_actions.just_pressed(ZoomToolAction::In) {\r\n                info!(\"Zooming in\");\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfn handle_sprint_events(\r\n    mut sprint_events: EventReader<SprintEvent>,\r\n    character_query: Query<&Children, With<Character>>,\r\n    toolbelt_query: Query<&Children, With<Toolbelt>>,\r\n    mut tool_query: Query<&mut ZoomTool>,\r\n) {\r\n    for event in sprint_events.read() {\r\n        let character_id = match event {\r\n            SprintEvent::Active { character_id, .. } => character_id,\r\n            SprintEvent::Stop { character_id } => character_id,\r\n        };\r\n        let Ok(character) = character_query.get(*character_id) else {\r\n            warn!(\"Character {:?} does not exist\", character_id);\r\n            continue;\r\n        };\r\n        let character_kids = character;\r\n        let tool_ids = character_kids\r\n            .iter()\r\n            .filter_map(|kid| toolbelt_query.get(*kid).ok())\r\n            .flat_map(|toolbelt| toolbelt.iter())\r\n            .filter(|kid| tool_query.contains(**kid))\r\n            .cloned()\r\n            .collect_vec();\r\n\r\n        match event {\r\n            SprintEvent::Active { throttle, .. } => {\r\n                let mut iter = tool_query.iter_many_mut(&tool_ids);\r\n                while let Some(mut tool) = iter.fetch_next() {\r\n                    tool.speed = (tool.default_speed, tool.sprint_speed).lerp(*throttle);\r\n                }\r\n            }\r\n            SprintEvent::Stop { .. } => {\r\n                let mut iter = tool_query.iter_many_mut(&tool_ids);\r\n                while let Some(mut tool) = iter.fetch_next() {\r\n                    tool.speed = tool.default_speed;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\tools\\src\\cube_tool.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse bevy_xpbd_2d::prelude::*;\r\nuse leafwing_input_manager::prelude::*;\r\n\r\nuse cursor_hero_character_types::prelude::*;\r\nuse cursor_hero_physics::damping_plugin::MovementDamping;\r\nuse cursor_hero_cursor_types::prelude::*;\r\n\r\nuse cursor_hero_toolbelt_types::prelude::*;\r\n\r\nuse crate::prelude::*;\r\n\r\npub struct CubeToolPlugin;\r\n\r\nimpl Plugin for CubeToolPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<CubeTool>();\r\n        app.register_type::<CubeToolInteractable>();\r\n        app.add_plugins(InputManagerPlugin::<CubeToolAction>::default());\r\n        app.add_systems(Update, (toolbelt_events, handle_input));\r\n    }\r\n}\r\n\r\n#[derive(Component, Reflect, Default)]\r\nstruct CubeTool;\r\n\r\nfn toolbelt_events(\r\n    mut commands: Commands,\r\n    asset_server: Res<AssetServer>,\r\n    mut reader: EventReader<ToolbeltPopulateEvent>,\r\n) {\r\n    for event in reader.read() {\r\n        let ToolbeltLoadout::Default = event.loadout else {\r\n            continue;\r\n        };\r\n        ToolSpawnConfig::<CubeTool, CubeToolAction>::new(CubeTool, event.id, event)\r\n            .with_src_path(file!().into())\r\n            .guess_name(file!())\r\n            .guess_image(file!(), &asset_server, \"png\")\r\n            .with_description(\"Spawn and attract cubes\")\r\n            .spawn(&mut commands);\r\n    }\r\n}\r\n\r\n#[derive(Actionlike, PartialEq, Eq, Clone, Copy, Hash, Debug, Reflect)]\r\nenum CubeToolAction {\r\n    Spawn,\r\n    Remove,\r\n    Attract,\r\n    KillAll,\r\n}\r\n\r\nimpl CubeToolAction {\r\n    fn default_gamepad_binding(&self) -> UserInput {\r\n        match self {\r\n            Self::Spawn => GamepadButtonType::South.into(),\r\n            Self::Remove => GamepadButtonType::East.into(),\r\n            Self::Attract => GamepadButtonType::LeftTrigger.into(),\r\n            Self::KillAll => GamepadButtonType::West.into(),\r\n        }\r\n    }\r\n\r\n    fn default_mkb_binding(&self) -> UserInput {\r\n        match self {\r\n            Self::Spawn => KeyCode::Q.into(),\r\n            Self::Remove => KeyCode::R.into(),\r\n            Self::Attract => KeyCode::F.into(),\r\n            Self::KillAll => KeyCode::X.into(),\r\n        }\r\n    }\r\n}\r\nimpl ToolAction for CubeToolAction {\r\n    fn default_input_map(_event: &ToolbeltPopulateEvent) -> Option<InputMap<CubeToolAction>> {\r\n        let mut input_map = InputMap::default();\r\n\r\n        for variant in CubeToolAction::variants() {\r\n            input_map.insert(variant.default_mkb_binding(), variant);\r\n            input_map.insert(variant.default_gamepad_binding(), variant);\r\n        }\r\n        Some(input_map)\r\n    }\r\n}\r\n\r\n#[derive(Component, Reflect)]\r\npub struct CubeToolInteractable;\r\n\r\nfn handle_input(\r\n    mut commands: Commands,\r\n    tools: Query<(&ActionState<CubeToolAction>, &Parent), With<ActiveTool>>,\r\n    toolbelts: Query<&Parent, With<Toolbelt>>,\r\n    characters: Query<&Children, With<Character>>,\r\n    cursors: Query<&GlobalTransform, With<Cursor>>,\r\n    mut cubes: Query<(Entity, &GlobalTransform, &mut LinearVelocity), With<CubeToolInteractable>>,\r\n) {\r\n    for tool in tools.iter() {\r\n        let (tool_actions, tool_parent) = tool;\r\n\r\n        let Ok(toolbelt) = toolbelts.get(tool_parent.get()) else {\r\n            warn!(\"Tool not inside a toolbelt?\");\r\n            continue;\r\n        };\r\n        let toolbelt_parent = toolbelt;\r\n\r\n        let Ok(character) = characters.get(toolbelt_parent.get()) else {\r\n            warn!(\"Toolbelt parent not a character?\");\r\n            continue;\r\n        };\r\n        let character_children = character;\r\n\r\n        let Some(cursor) = character_children\r\n            .iter()\r\n            .filter_map(|x| cursors.get(*x).ok())\r\n            .next()\r\n        else {\r\n            //TODO: warn if more than one cursor found\r\n            warn!(\"Character {:?} missing a cursor?\", toolbelt_parent.get());\r\n            debug!(\"Character children: {:?}\", character_children);\r\n            continue;\r\n        };\r\n        let cursor_transform = cursor;\r\n\r\n        if tool_actions.just_pressed(CubeToolAction::Spawn) {\r\n            info!(\"Spawn Cube\");\r\n            commands.spawn((\r\n                CubeToolInteractable,\r\n                MovementDamping { factor: 0.98 },\r\n                SpriteBundle {\r\n                    sprite: Sprite {\r\n                        custom_size: Some(Vec2::new(15.0, 15.0)),\r\n                        ..default()\r\n                    },\r\n                    transform: Transform::from_translation(cursor_transform.translation()),\r\n                    ..default()\r\n                },\r\n                RigidBody::Dynamic,\r\n                Collider::cuboid(15.0, 15.0),\r\n                Name::new(\"Cube\"),\r\n            ));\r\n        }\r\n        if tool_actions.just_pressed(CubeToolAction::Remove) {\r\n            info!(\"Remove Cube\");\r\n            // remove the cube closest to the cursor\r\n            let mut closest_cube = None;\r\n            let mut closest_dist = f32::MAX;\r\n            for (c_e, c_t, _) in cubes.iter() {\r\n                let dist = c_t.translation().distance(cursor_transform.translation());\r\n                if dist < closest_dist {\r\n                    closest_cube = Some(c_e);\r\n                    closest_dist = dist;\r\n                }\r\n            }\r\n            if let Some(cube) = closest_cube {\r\n                commands.entity(cube).despawn_recursive();\r\n            }\r\n        }\r\n        if tool_actions.just_pressed(CubeToolAction::KillAll) {\r\n            info!(\"Kill All Cubes\");\r\n            // remove all cubes\r\n            for (c_e, _, _) in cubes.iter() {\r\n                commands.entity(c_e).despawn_recursive();\r\n            }\r\n        }\r\n        if tool_actions.pressed(CubeToolAction::Attract) {\r\n            if tool_actions.just_pressed(CubeToolAction::Attract) {\r\n                info!(\"Attract Cube\");\r\n            }\r\n            // add a force to all cubes towards the cursor\r\n            for (_, c_t, mut c_v) in cubes.iter_mut() {\r\n                let diff = cursor.translation() - c_t.translation();\r\n                let force = diff.normalize() * 100.0;\r\n                c_v.x += force.x;\r\n                c_v.y += force.y;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui_inspector\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_ui_inspector\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\ncursor_hero_ui_inspector_types = { workspace = true }\r\ncursor_hero_ui_automation = { workspace = true }\r\nbevy_egui = {workspace = true}\r\nbevy-inspector-egui = { workspace = true }\r\ncursor_hero_worker = { workspace = true }\r\nuiautomation = { workspace = true }\r\nitertools = { workspace = true }\r\ncursor_hero_winutils = { workspace = true }\r\ncursor_hero_ui_hover_types = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui_automation\\src\\gather_element_info.rs\r\n\r\n````rust\r\nuse bevy::math::IRect;\r\nuse cursor_hero_ui_automation_types::prelude::DrillId;\r\nuse cursor_hero_ui_automation_types::prelude::ElementInfo;\r\nuse cursor_hero_ui_automation_types::prelude::RuntimeId;\r\nuse itertools::Itertools;\r\nuse std::collections::VecDeque;\r\nuse uiautomation::Error;\r\nuse uiautomation::UIAutomation;\r\nuse uiautomation::UIElement;\r\nuse uiautomation::UITreeWalker;\r\n\r\nuse crate::gather_children::GatherChildrenable;\r\nuse crate::gather_children::StopBehaviour;\r\n\r\npub struct GatherUITreeOkResult {\r\n    pub ui_tree: ElementInfo,\r\n    pub start_info: ElementInfo,\r\n}\r\npub fn gather_incomplete_ui_tree_starting_deep(\r\n    start_element: UIElement,\r\n) -> Result<GatherUITreeOkResult, Error> {\r\n    let automation = UIAutomation::new()?;\r\n    let walker = automation.create_tree_walker()?;\r\n    let ancestors = collect_ancestors(&start_element, &walker)?;\r\n    // println!(\"ancestors: {:?}\", ancestors);\r\n\r\n    let root_element = ancestors\r\n        .front()\r\n        .ok_or(Error::new(-1, \"No root element found\"))?\r\n        .clone();\r\n    let mut root_info = gather_tree(&root_element, &walker, &ancestors, 0)?;\r\n    root_info.drill_id = DrillId::Root;\r\n\r\n    update_drill_ids(root_info.children.as_mut(), &DrillId::Root);\r\n\r\n    let start_info = root_info\r\n        .get_descendents()\r\n        .into_iter()\r\n        .find(|info| match start_element.get_runtime_id() {\r\n            Ok(id) => info.runtime_id.0 == id,\r\n            Err(_) => false,\r\n        })\r\n        .cloned();\r\n    let Some(start_info) = start_info else {\r\n        return Err(Error::new(\r\n            -1,\r\n            format!(\r\n                \"Start element {:?} (id: {:?}) not found in tree: {:?}\",\r\n                start_element,\r\n                start_element.get_runtime_id(),\r\n                root_info\r\n            )\r\n            .as_str(),\r\n        ));\r\n    };\r\n    // let start_info = start_info.unwrap_or_else(|| root_info.clone());\r\n\r\n    Ok(GatherUITreeOkResult {\r\n        ui_tree: root_info,\r\n        start_info,\r\n    })\r\n}\r\n\r\nfn collect_ancestors(\r\n    element: &UIElement,\r\n    walker: &UITreeWalker,\r\n) -> Result<VecDeque<UIElement>, Error> {\r\n    let mut ancestors = VecDeque::new();\r\n    let mut current_element = Some(element.clone());\r\n    while let Some(elem) = current_element {\r\n        ancestors.push_front(elem.clone());\r\n        current_element = walker.get_parent(&elem).ok();\r\n    }\r\n    Ok(ancestors)\r\n}\r\n\r\nfn gather_tree(\r\n    element: &UIElement,\r\n    walker: &UITreeWalker,\r\n    ancestors: &VecDeque<UIElement>,\r\n    depth: usize,\r\n) -> Result<ElementInfo, Error> {\r\n    let is_ancestor = |element: &UIElement| {\r\n        ancestors\r\n            .iter()\r\n            .any(|ancestor| ancestor.get_runtime_id() == element.get_runtime_id())\r\n    };\r\n    let on_ancestor = is_ancestor(element);\r\n    let mut element_info = gather_single_element_info(element)?;\r\n\r\n    if on_ancestor {\r\n        let children = element\r\n            .gather_children(\r\n                walker,\r\n                if depth == 0 {\r\n                    &StopBehaviour::RootEndEncountered\r\n                } else {\r\n                    &StopBehaviour::EndOfSiblings\r\n                },\r\n            )\r\n            .into_iter()\r\n            .enumerate()\r\n            .filter_map(|(i, child)| {\r\n                if is_ancestor(&child) {\r\n                    gather_tree(&child, walker, ancestors, depth + 1).ok()\r\n                } else {\r\n                    gather_single_element_info(&child).ok()\r\n                }\r\n                .map(|mut child_info| {\r\n                    child_info.drill_id = DrillId::Child(vec![i].into_iter().collect());\r\n                    child_info\r\n                })\r\n            })\r\n            .collect_vec();\r\n\r\n        element_info.children = Some(children);\r\n    }\r\n\r\n    Ok(element_info)\r\n}\r\n\r\npub fn update_drill_ids(children: Option<&mut Vec<ElementInfo>>, ancestor_path: &DrillId) {\r\n    if let Some(children) = children {\r\n        for child_info in children.iter_mut() {\r\n            // Check if the child has a base drill_id set\r\n            if let DrillId::Child(base_drill_id) = &child_info.drill_id {\r\n                let mut new_path = ancestor_path.clone();\r\n                if let Some(&child_position) = base_drill_id.back() {\r\n                    new_path = match new_path {\r\n                        DrillId::Root | DrillId::Unknown => {\r\n                            DrillId::Child(vec![child_position].into())\r\n                        }\r\n                        DrillId::Child(ref mut path) => {\r\n                            let mut new_path = path.clone();\r\n                            new_path.push_back(child_position);\r\n                            DrillId::Child(new_path)\r\n                        }\r\n                    };\r\n\r\n                    // Update the child's drill_id by concatenating the ancestor_path with its own position\r\n                    child_info.drill_id = new_path.clone();\r\n                }\r\n\r\n                // Recursively update this child's children\r\n                update_drill_ids(child_info.children.as_mut(), &new_path);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\npub fn gather_single_element_info(element: &UIElement) -> Result<ElementInfo, uiautomation::Error> {\r\n    let name = element.get_name()?;\r\n    let bb = element.get_bounding_rectangle()?;\r\n    let class_name = element.get_classname()?;\r\n    let control_type = element.get_control_type()?.into();\r\n    let localized_control_type = element.get_localized_control_type()?;\r\n    let automation_id = element.get_automation_id()?;\r\n    let runtime_id = RuntimeId(element.get_runtime_id()?);\r\n\r\n    let info = ElementInfo {\r\n        name,\r\n        bounding_rect: IRect::new(bb.get_left(), bb.get_top(), bb.get_right(), bb.get_bottom()),\r\n        control_type,\r\n        localized_control_type,\r\n        class_name,\r\n        automation_id,\r\n        runtime_id,\r\n        children: None,\r\n        drill_id: DrillId::Unknown,\r\n    };\r\n    Ok(info)\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n    use uiautomation::UIAutomation;\r\n\r\n    /// Discord doesn't play nice with new UIAutomaion\r\n    ///\r\n    /// Element children aren't shown like they are in the MSAA tree\r\n    #[test]\r\n    fn test_gather_discord_element_info() {\r\n        let automation = UIAutomation::new().unwrap();\r\n        let walker = automation.create_tree_walker().unwrap();\r\n        let start = automation\r\n            .element_from_point(uiautomation::types::Point::new(2359, 959))\r\n            .unwrap();\r\n        println!(\"start {:#?}\", start);\r\n        let info = gather_single_element_info(&start).unwrap();\r\n        println!(\"info {:#?}\", info);\r\n\r\n        // let parent = walker.get_parent(&start).unwrap();\r\n        // let parent_info = gather_single_element_info(&parent).unwrap();\r\n        // println!(\"parent_info {:#?}\", parent_info);\r\n\r\n        let ancestors = collect_ancestors(&start, &walker).unwrap();\r\n        println!(\"got {} ancestors\", ancestors.len());\r\n        // println!(\"ancestors {:#?}\", ancestors);\r\n        for ancestor in ancestors.iter().skip(1) {\r\n            print!(\r\n                \"ancestor {:?} (runtimeid={:?})\\t\",\r\n                ancestor,\r\n                ancestor.get_runtime_id()\r\n            );\r\n            for behaviour in vec![\r\n                StopBehaviour::EndOfSiblings,\r\n                // StopBehaviour::LastChildEncountered,\r\n                // StopBehaviour::TaskbarEndEncountered,\r\n                // StopBehaviour::RootEndEncountered,\r\n            ] {\r\n                let children = ancestor\r\n                    .gather_children(&walker, &behaviour)\r\n                    .into_iter()\r\n                    .map(|child| gather_single_element_info(&child).unwrap())\r\n                    .collect::<Vec<_>>();\r\n                if children.is_empty() {\r\n                    eprintln!(\"No children found using {:?}\", behaviour);\r\n                }\r\n                println!(\"children using {:?} {:#?}\", behaviour, children.len());\r\n            }\r\n        }\r\n\r\n        let gathered = gather_incomplete_ui_tree_starting_deep(start).unwrap();\r\n        // println!(\"tree {:#?}\", gathered.ui_tree);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\screen\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_screen\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\ncursor_hero_metrics = { workspace = true }\r\ncursor_hero_bevy = { workspace = true }\r\ncursor_hero_environment_types = { workspace = true }\r\ncursor_hero_level_bounds = { workspace = true }\r\ncursor_hero_winutils = { workspace = true}\r\ncursor_hero_worker = { workspace = true}\r\nbevy = { workspace = true }\r\nbevy-inspector-egui = { workspace = true }\r\nbevy_xpbd_2d = { workspace = true }\r\nimage = { workspace = true}\r\nscreenshots = { workspace = true}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\tools\\src\\lib.rs\r\n\r\n````rust\r\n#![feature(let_chains)]\r\n\r\npub mod click_tool;\r\npub mod cube_tool;\r\npub mod default_wheel_tool;\r\npub mod focus_tool;\r\npub mod keyboard_tool;\r\npub mod keyboard_wheel_tool;\r\npub mod level_bounds_visibility_tool;\r\npub mod placeholder_tool;\r\npub mod restart_tool;\r\npub mod scroll_tool;\r\npub mod talk_tool;\r\npub mod tool_plugin;\r\npub mod tool_spawning;\r\npub mod window_drag_tool;\r\npub mod zoom_tool;\r\n\r\npub use crate::tool_plugin::ToolPlugin;\r\n\r\npub mod prelude {\r\n    pub use crate::tool_spawning::NoInputs;\r\n    pub use crate::tool_spawning::StartingState;\r\n    pub use crate::tool_spawning::ToolSpawnConfig;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui_automation_types\\src\\taskbar_ui_types.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n\r\n#[derive(Debug, Reflect, Clone)]\r\npub struct Taskbar {\r\n    pub entries: Vec<TaskbarEntry>,\r\n}\r\n#[derive(Debug, Reflect, Clone)]\r\npub struct TaskbarEntry {\r\n    pub name: String,\r\n    pub bounds: IRect,\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\secret_types\\src\\secrets_types_plugin.rs\r\n\r\n````rust\r\nuse crate::prelude::*;\r\nuse bevy::prelude::*;\r\n\r\npub struct SecretsTypesPlugin;\r\n\r\nimpl Plugin for SecretsTypesPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<SecretString>();\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui_hover_types\\src\\ui_hover_types.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse cursor_hero_ui_automation_types::prelude::ElementInfo;\r\nuse cursor_hero_worker_types::prelude::WorkerMessage;\r\n\r\n#[derive(Resource, Default, Reflect)]\r\npub struct HoverInfo {\r\n    pub host_element: Option<HostHoveredIndicator>,\r\n    pub game_element: Option<GameHoveredIndicator>,\r\n    pub enabled: bool,\r\n}\r\n\r\n#[derive(Component, Reflect, Debug, Clone)]\r\npub struct HostHoveredIndicator {\r\n    pub info: ElementInfo,\r\n    pub cursor_pos: IVec2,\r\n}\r\n#[derive(Component, Reflect, Debug, Clone)]\r\npub struct GameHoveredIndicator {\r\n    pub info: ElementInfo,\r\n    pub cursor_pos: IVec2,\r\n}\r\n\r\n\r\n\r\n#[derive(Debug, Reflect, Clone, Event)]\r\npub enum GameboundHoverMessage {\r\n    HostHoverInfo {\r\n        info: ElementInfo,\r\n        cursor_pos: IVec2,\r\n    },\r\n    ClearHostHoverInfo,\r\n    GameHoverInfo {\r\n        info: ElementInfo,\r\n        cursor_pos: IVec2,\r\n    },\r\n    ClearGameHoverInfo,\r\n}\r\nimpl WorkerMessage for GameboundHoverMessage {}\r\n\r\n#[derive(Debug, Reflect, Clone, Event, Eq, PartialEq)]\r\npub enum ThreadboundHoverMessage {\r\n    AtPositionFromGame(IVec2),\r\n    AtHostCursorPosition,\r\n    ClearHost,\r\n    ClearGame,\r\n}\r\nimpl WorkerMessage for ThreadboundHoverMessage {}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui_automation_types\\src\\ui_automation_types_plugin.rs\r\n\r\n````rust\r\nuse crate::prelude::*;\r\nuse bevy::prelude::*;\r\n\r\npub struct UiAutomationTypesPlugin;\r\n\r\nimpl Plugin for UiAutomationTypesPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<ElementInfo>();\r\n        app.register_type::<DrillId>();\r\n        app.register_type::<RuntimeId>();\r\n        app.register_type::<ControlType>();\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\toolbelt_types\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_toolbelt_types\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\nleafwing-input-manager = { workspace = true }\r\nserde = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\taskbar_tool\\src\\taskbar_tool_plugin.rs\r\n\r\n````rust\r\nuse crate::taskbar_wheel_tool::TaskbarWheelToolPlugin;\r\nuse bevy::prelude::*;\r\npub struct TaskbarToolPlugin;\r\n\r\nimpl Plugin for TaskbarToolPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_plugins(TaskbarWheelToolPlugin);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\toolbelt\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_toolbelt\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\ncursor_hero_character_types = { workspace = true }\r\ncursor_hero_bevy = { workspace = true }\r\ncursor_hero_cursor_types = { workspace = true }\r\ncursor_hero_input = { workspace = true }\r\ncursor_hero_math = { workspace = true }\r\ncursor_hero_sprint_tool_types = { workspace = true }\r\ncursor_hero_toolbelt_types = { workspace = true }\r\ncursor_hero_window_position_types = { workspace = true }\r\ncursor_hero_xelu_prompts = { workspace = true }\r\nbevy = { workspace = true }\r\nbevy-inspector-egui = { workspace = true }\r\nbevy_xpbd_2d = { workspace = true }\r\nleafwing-input-manager = { workspace = true }\r\nitertools = { workspace = true }\r\ncursor_hero_host_fs_types = { workspace = true }\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\toolbelt\\src\\toolbelt_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse leafwing_input_manager::prelude::*;\r\n\r\nuse crate::hover_frame::insert_hover_frame;\r\nuse crate::hover_frame::remove_hover_frame;\r\nuse crate::tool_activation::tool_activation;\r\nuse crate::tool_color::tool_color;\r\nuse crate::tool_help_activate::tool_help_activation;\r\nuse crate::tool_help_cleanup::tool_help_cleanup;\r\nuse crate::tool_help_click::help_click_listener;\r\nuse crate::tool_help_populate::tool_help_lifecycle;\r\nuse crate::tool_visibility::tool_visibility;\r\nuse crate::toolbelt_circle_layout_plugin::ToolbeltCircleLayoutPlugin;\r\nuse crate::toolbelt_opening_plugin::ToolbeltOpeningPlugin;\r\nuse crate::toolbelt_properties_plugin::ToolbeltPropertiesPlugin;\r\nuse crate::toolbelt_taskbar_layout_plugin::ToolbeltTaskbarLayoutPlugin;\r\nuse crate::wheel_audio::wheel_audio;\r\nuse cursor_hero_toolbelt_types::toolbelt_types::*;\r\npub struct ToolbeltPlugin;\r\n\r\nimpl Plugin for ToolbeltPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_plugins(ToolbeltOpeningPlugin);\r\n        app.add_plugins(ToolbeltPropertiesPlugin);\r\n        app.add_plugins(ToolbeltCircleLayoutPlugin);\r\n        app.add_plugins(ToolbeltTaskbarLayoutPlugin);\r\n        app.add_plugins(InputManagerPlugin::<ToolbeltAction>::default());\r\n        app.add_systems(Update, help_click_listener);\r\n        app.add_systems(Update, insert_hover_frame);\r\n        app.add_systems(Update, remove_hover_frame);\r\n        app.add_systems(Update, tool_color);\r\n        app.add_systems(Update, tool_activation);\r\n        app.add_systems(Update, tool_help_cleanup);\r\n        app.add_systems(\r\n            Update,\r\n            (\r\n                wheel_audio,\r\n                tool_visibility,\r\n                tool_help_activation,\r\n                tool_help_lifecycle,\r\n            )\r\n                .chain(),\r\n        );\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui_automation\\src\\gather_children.rs\r\n\r\n````rust\r\nuse std::collections::VecDeque;\r\n\r\nuse cursor_hero_metrics::Metrics;\r\nuse uiautomation::UIElement;\r\nuse uiautomation::UITreeWalker;\r\n\r\n#[allow(dead_code)]\r\n#[derive(Debug)]\r\npub enum StopBehaviour {\r\n    EndOfSiblings,\r\n    LastChildEncountered,\r\n    TaskbarEndEncountered,\r\n    RootEndEncountered, // Calling get_next_sibling on the last child of root will hang, so use this to mitigate\r\n}\r\nimpl StopBehaviour {\r\n    fn include_last_child(&self) -> bool {\r\n        !matches!(self, StopBehaviour::TaskbarEndEncountered)\r\n    }\r\n}\r\ntrait GatherChildrenStopBehaviourFn {\r\n    fn should_stop(&self, next: &UIElement) -> bool;\r\n}\r\n\r\n#[derive(Debug)]\r\nstruct EndOfSiblings;\r\nimpl GatherChildrenStopBehaviourFn for EndOfSiblings {\r\n    fn should_stop(&self, _element: &UIElement) -> bool {\r\n        false\r\n    }\r\n}\r\n\r\n#[derive(Debug)]\r\nstruct LastChildEncountered {\r\n    runtime_id_of_last: Vec<i32>,\r\n}\r\nimpl GatherChildrenStopBehaviourFn for LastChildEncountered {\r\n    fn should_stop(&self, element: &UIElement) -> bool {\r\n        element.get_runtime_id() == Ok(self.runtime_id_of_last.clone())\r\n    }\r\n}\r\n\r\n#[derive(Debug)]\r\nstruct TaskbarEndEncountered;\r\nimpl GatherChildrenStopBehaviourFn for TaskbarEndEncountered {\r\n    fn should_stop(&self, element: &UIElement) -> bool {\r\n        element.get_automation_id() == Ok(\"TaskbarEndAccessibilityElement\".to_string())\r\n    }\r\n}\r\n\r\n#[derive(Debug)]\r\nstruct RootEndEncountered;\r\nimpl GatherChildrenStopBehaviourFn for RootEndEncountered {\r\n    fn should_stop(&self, element: &UIElement) -> bool {\r\n        element.get_name() == Ok(\"Program Manager\".to_string())\r\n            && element.get_classname() == Ok(\"Progman\".to_string())\r\n        // This could be more specific, but until a false positive is encountered, this is fine\r\n    }\r\n}\r\n\r\npub trait GatherChildrenable {\r\n    fn gather_children(\r\n        &self,\r\n        walker: &UITreeWalker,\r\n        stop_behaviour: &StopBehaviour,\r\n    ) -> VecDeque<UIElement>;\r\n}\r\nimpl GatherChildrenable for UIElement {\r\n    fn gather_children(\r\n        &self,\r\n        walker: &UITreeWalker,\r\n        stop_behaviour: &StopBehaviour,\r\n    ) -> VecDeque<UIElement> {\r\n        gather_children(walker, self, stop_behaviour)\r\n    }\r\n}\r\n\r\npub fn gather_children(\r\n    walker: &UITreeWalker,\r\n    parent: &UIElement,\r\n    stop_behaviour: &StopBehaviour,\r\n) -> VecDeque<UIElement> {\r\n    // println!(\"Gathering children of {:?}\", parent);\r\n    let mut children = VecDeque::new();\r\n    let mut metrics = Metrics::default();\r\n\r\n    // println!(\"Constructing stop behaviour fn for {:?}\", stop_behaviour);\r\n    metrics.begin(\"construct stop behaviour\");\r\n    let stop: Box<dyn GatherChildrenStopBehaviourFn> = match stop_behaviour {\r\n        StopBehaviour::EndOfSiblings => Box::new(EndOfSiblings),\r\n        StopBehaviour::LastChildEncountered => {\r\n            // println!(\"Getting last child of {:?}\", parent);\r\n            let last = walker.get_last_child(parent);\r\n            let last = match last {\r\n                Ok(last) => last,\r\n                Err(_) => {\r\n                    eprintln!(\"Failed to get last child of {:?}\", parent);\r\n                    return children;\r\n                }\r\n            };\r\n            let runtime_id_of_last = last.get_runtime_id();\r\n            let runtime_id_of_last = match runtime_id_of_last {\r\n                Ok(runtime_id_of_last) => runtime_id_of_last,\r\n                Err(_) => {\r\n                    eprintln!(\r\n                        \"Failed to get runtime id of last child {:?} of {:?}\",\r\n                        last, parent\r\n                    );\r\n                    return children;\r\n                }\r\n            };\r\n            Box::new(LastChildEncountered { runtime_id_of_last })\r\n        }\r\n        StopBehaviour::TaskbarEndEncountered => Box::new(TaskbarEndEncountered),\r\n        StopBehaviour::RootEndEncountered => Box::new(RootEndEncountered),\r\n    };\r\n    metrics.end(\"construct stop behaviour\");\r\n    // println!(\"Constructed stop behaviour {:?}\", stop_behaviour);\r\n\r\n    // println!(\"Finding first child\");\r\n    metrics.begin(\"find first child\");\r\n    let first = walker.get_first_child(parent);\r\n    metrics.end(\"find first child\");\r\n    // println!(\"Found first child\");\r\n\r\n    let Ok(first) = first else {\r\n        return children;\r\n    };\r\n    children.push_back(first.clone());\r\n    let mut next = first;\r\n    let mut i = 0;\r\n    loop {\r\n        // println!(\"About to grab next sibling of {:?}\", next);\r\n        metrics.begin(format!(\"get next sibling {}\", i).as_str());\r\n        let sibling = walker.get_next_sibling(&next);\r\n        metrics.end(format!(\"get next sibling {}\", i).as_str());\r\n        i += 1;\r\n\r\n        if let Ok(sibling) = sibling {\r\n            // println!(\"Got sibling {:?}\", sibling);\r\n            // println!(\"Checking if should stop\");\r\n            if stop.should_stop(&sibling) {\r\n                // println!(\"Should stop\");\r\n                if stop_behaviour.include_last_child() {\r\n                    // println!(\"Including last child\");\r\n                    children.push_back(sibling.clone());\r\n                }\r\n                break;\r\n            } else {\r\n                // println!(\"Should not stop\");\r\n                children.push_back(sibling.clone());\r\n                next = sibling;\r\n            }\r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n    // println!(\"Gathered {} children\", children.len());\r\n    // println!(\"| {}\", metrics.report().split(\" | \").join(\"\\n| \"));\r\n    children\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ollama_types\\src\\ollama_types_plugin.rs\r\n\r\n````rust\r\nuse crate::prelude::*;\r\nuse bevy::prelude::*;\r\n\r\npub struct OllamaTypesPlugin;\r\n\r\nimpl Plugin for OllamaTypesPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<OllamaStatus>();\r\n        app.register_type::<OllamaStatusButton>();\r\n        app.register_type::<OllamaStatusButtonVisualState>();\r\n        app.register_type::<OllamaStatusEvent>();\r\n        app.add_event::<OllamaStatusEvent>();\r\n\r\n        app.register_type::<OllamaPingEvent>();\r\n        app.add_event::<OllamaPingEvent>();\r\n\r\n        app.register_type::<OllamaTerminalButton>();\r\n        app.register_type::<OllamaTerminalButtonVisualState>();\r\n        app.register_type::<OllamaTerminalEvent>();\r\n        app.add_event::<OllamaTerminalEvent>();\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\toolbelt\\src\\tool_help_click.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse cursor_hero_host_fs_types::host_fs_types::HostPath;\r\nuse cursor_hero_host_fs_types::host_fs_types::HostPathAction;\r\nuse cursor_hero_cursor_types::cursor_click_types::ClickEvent;\r\nuse cursor_hero_cursor_types::cursor_click_types::Way;\r\nuse cursor_hero_toolbelt_types::toolbelt_types::ToolHelpTrigger;\r\n\r\n/// Doesn't work with loadouts without the click tool lol\r\npub fn help_click_listener(\r\n    mut click_events: EventReader<ClickEvent>,\r\n    help_query: Query<&HostPath, With<ToolHelpTrigger>>,\r\n    mut host_fs_events: EventWriter<HostPathAction>,\r\n) {\r\n    for event in click_events.read() {\r\n        let ClickEvent::Clicked {\r\n            target_id,\r\n            way: Way::Left,\r\n            ..\r\n        } = event\r\n        else {\r\n            continue;\r\n        };\r\n        let Ok(help) = help_query.get(*target_id) else {\r\n            continue;\r\n        };\r\n        let src_path = help;\r\n        let msg = HostPathAction::OpenWithCode {\r\n            path: src_path.clone(),\r\n        };\r\n        info!(\"Sending message: {:?}\", msg);\r\n        host_fs_events.send(msg);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui_inspector\\src\\lib.rs\r\n\r\n````rust\r\n#![feature(let_chains, trivial_bounds)]\r\npub mod ui_inspector_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::ui_inspector_plugin::*;\r\n}\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\toolbelt\\src\\toolbelt_properties_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse cursor_hero_toolbelt_types::toolbelt_types::Toolbelt;\r\nuse cursor_hero_toolbelt_types::toolbelt_types::ToolbeltPopulateEvent;\r\n\r\npub struct ToolbeltPropertiesPlugin;\r\n\r\nimpl Plugin for ToolbeltPropertiesPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Update, switch_layout);\r\n    }\r\n}\r\npub fn switch_layout(\r\n    mut toolbelt_events: EventReader<ToolbeltPopulateEvent>,\r\n    mut toolbelt_query: Query<&mut Toolbelt>,\r\n) {\r\n    for event in toolbelt_events.read() {\r\n        let ToolbeltPopulateEvent { id, loadout } = event;\r\n        if let Ok(mut toolbelt) = toolbelt_query.get_mut(*id) {\r\n            toolbelt.loadout = *loadout;\r\n            toolbelt.layout = loadout.layout();\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\use cases\\flip comments.md\r\n\r\n````markdown\r\n```rust\r\n    log_behaviour: PointerLogBehaviour::Errors,\r\n    // log_behaviour: PointerLogBehaviour::ErrorsAndPositionUpdates,\r\n```\r\ncontext action to swap which line is commented\r\n- identify based on line matching except for different enum variant\r\n\r\nor just suggest switching the variant, flag the variant as toggleable from IDE?\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\winutils\\examples\\win_events_example.rs\r\n\r\n````rust\r\nuse cursor_hero_winutils::win_events::create_os_event_listener;\r\nuse cursor_hero_winutils::win_events::ProcMessage;\r\n\r\nfn main() {\r\n    let args: Vec<String> = std::env::args().collect();\r\n    if args.len() != 2 {\r\n        eprintln!(\"Usage: <command> [all|events|mouse|keyboard]\");\r\n        std::process::exit(1);\r\n    }\r\n\r\n    let result = match args[1].as_str() {\r\n        \"all\" => listen_all(),\r\n        \"events\" => listen_events(),\r\n        \"mouse\" => listen_mouse(),\r\n        \"keyboard\" => listen_keyboard(),\r\n        _ => {\r\n            eprintln!(\"Invalid argument: choose from [all|events|mouse|keyboard]\");\r\n            std::process::exit(1);\r\n        }\r\n    };\r\n\r\n    if let Err(e) = result {\r\n        eprintln!(\"Error occurred: {:?}\", e);\r\n        std::process::exit(1);\r\n    }\r\n}\r\n\r\npub fn listen_all() -> Result<(), windows::core::Error> {\r\n    let rx = create_os_event_listener()?;\r\n    while let Ok(msg) = rx.recv() {\r\n        println!(\"Received message: {:?}\", msg);\r\n    }\r\n    Ok(())\r\n}\r\n\r\npub fn listen_events() -> Result<(), windows::core::Error> {\r\n    let rx = create_os_event_listener()?;\r\n    while let Ok(msg) = rx.recv() {\r\n        if !matches!(msg, ProcMessage::Event { .. }) {\r\n            continue;\r\n        }\r\n        println!(\"Received message: {:?}\", msg);\r\n    }\r\n    Ok(())\r\n}\r\n\r\npub fn listen_mouse() -> Result<(), windows::core::Error> {\r\n    let rx = create_os_event_listener()?;\r\n    while let Ok(msg) = rx.recv() {\r\n        if !matches!(msg, ProcMessage::MouseMoved { .. }) {\r\n            continue;\r\n        }\r\n        println!(\"Received message: {:?}\", msg);\r\n    }\r\n    Ok(())\r\n}\r\n\r\npub fn listen_keyboard() -> Result<(), windows::core::Error> {\r\n    let rx = create_os_event_listener()?;\r\n    while let Ok(msg) = rx.recv() {\r\n        if !matches!(msg, ProcMessage::KeyDown { .. }) {\r\n            continue;\r\n        }\r\n        println!(\"Received message: {:?}\", msg);\r\n    }\r\n    Ok(())\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\worker_types\\src\\worker_types_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n// use crate::prelude::*;\r\n\r\npub struct WorkerTypesPlugin;\r\n\r\nimpl Plugin for WorkerTypesPlugin {\r\n    fn build(&self, _app: &mut App) {\r\n        // app.register_type::<MyComponent>();\r\n        // app.add_event::<MyEvent>();\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\window_swap_tool\\src\\window_swap_tool_plugin.rs\r\n\r\n````rust\r\nuse crate::window_swap_tool_populate_plugin::WindowSwapToolPopulatePlugin;\r\nuse bevy::prelude::*;\r\n\r\npub struct WindowSwapToolPlugin;\r\n\r\nimpl Plugin for WindowSwapToolPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_plugins(WindowSwapToolPopulatePlugin);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\templates\\patterns\\new_tool\\crates\\{{crate_name}}_tool\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_{{crate_name}}_tool\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\ncursor_hero_{{crate_name}}_tool_types = { workspace = true }\r\ncursor_hero_toolbelt_types = { workspace = true }\r\ncursor_hero_tools = { workspace = true }\r\nleafwing-input-manager = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\templates\\patterns\\new_tool\\crates\\plugins\\src\\default_launch_mode_plugin.rs\r\n\r\n````rust\r\n{{use_statements}}\r\nuse cursor_hero_{{crate_name}}_tool::prelude::*;\r\nuse cursor_hero_{{crate_name}}_tool_types::prelude::*;\r\n{{plugin_start}}\r\n        app.add_plugins({{crate_name_pascal}}ToolPlugin);\r\n        app.add_plugins({{crate_name_pascal}}ToolTypesPlugin);\r\n        {{plugin_remaining}}\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\templates\\patterns\\new_plugin_with_types\\crates\\plugins\\Cargo.toml\r\n\r\n````toml\r\n{{before_first_plugins_dependency}}\r\ncursor_hero_{{crate_name}} = { workspace = true }\r\ncursor_hero_{{crate_name}}_types = { workspace = true }\r\n{{first_plugins_dependency_onwards}}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\worker\\src\\worker_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse crossbeam_channel::bounded;\r\nuse cursor_hero_worker_types::prelude::*;\r\nuse std::thread;\r\n\r\nuse windows::Win32::System::Com::CoInitializeEx;\r\nuse windows::Win32::System::Com::COINIT_MULTITHREADED;\r\npub struct WorkerPlugin<T, G, S>\r\nwhere\r\n    T: WorkerMessage,\r\n    G: WorkerMessage,\r\n    S: WorkerState,\r\n{\r\n    pub config: WorkerConfig<T, G, S>,\r\n}\r\n\r\nimpl<T, G, S> Plugin for WorkerPlugin<T, G, S>\r\nwhere\r\n    T: WorkerMessage,\r\n    G: WorkerMessage,\r\n    S: WorkerState,\r\n{\r\n    fn build(&self, app: &mut App) {\r\n        // TODO: conditionally register if T or G support it\r\n        // app.register_type::<T>();\r\n        // app.register_type::<G>();\r\n        app.add_event::<T>();\r\n        app.add_event::<G>();\r\n        app.insert_resource(self.config.clone());\r\n        app.add_systems(Startup, create_worker_thread::<T, G, S>);\r\n        app.add_systems(Update, bridge_requests::<T, G, S>);\r\n        app.add_systems(Update, bridge_responses::<T, G, S>);\r\n    }\r\n}\r\n\r\nfn create_worker_thread<T: WorkerMessage, G: WorkerMessage, S: WorkerState>(\r\n    config: Res<WorkerConfig<T, G, S>>,\r\n    mut commands: Commands,\r\n) {\r\n    let (game_tx, game_rx) = bounded::<G>(config.gamebound_channel_capacity);\r\n    let (thread_tx, thread_rx) = bounded::<T>(config.threadbound_channel_capacity);\r\n\r\n    commands.insert_resource(Bridge {\r\n        sender: thread_tx,\r\n        receiver: game_rx,\r\n    });\r\n\r\n    let name = config.name.clone();\r\n    let handler = config.handle_threadbound_message;\r\n    let handler_error_handler = config.handle_threadbound_message_error_handler;\r\n    let sleep_duration = config.sleep_duration;\r\n    let is_ui_automation_thread = config.is_ui_automation_thread;\r\n    let receiver = config.threadbound_message_receiver;\r\n    if let Err(e) = thread::Builder::new().name(name.clone()).spawn(move || {\r\n        if is_ui_automation_thread {\r\n            unsafe {\r\n                // Initialize COM in MTA mode\r\n                // https://learn.microsoft.com/en-us/dotnet/framework/ui-automation/ui-automation-threading-issues\r\n                // https://learn.microsoft.com/en-us/windows/win32/com/multithreaded-apartments\r\n                if let Err(e) = CoInitializeEx(None, COINIT_MULTITHREADED) {\r\n                    error!(\"[{}] Failed to initialize COM: {:?}\", name, e);\r\n                }\r\n                debug!(\"[{}] COM initialized in MTA mode.\", name);\r\n            }\r\n        }\r\n\r\n        let Ok(mut state) = S::try_default() else {\r\n            error!(\"[{}] Failed to initialize state\", name);\r\n            return;\r\n        };\r\n\r\n        let rt = tokio::runtime::Runtime::new().unwrap();\r\n        rt.block_on(async {\r\n            loop {\r\n                let msg = match (receiver)(&thread_rx, &mut state) {\r\n                    Ok(msg) => msg,\r\n                    Err(e) => {\r\n                        error!(\"[{}] Threadbound channel receiver failure: {:?}, quitting loop\", name, e);\r\n                        break;\r\n                    }\r\n                };\r\n                if let Err(e) = (handler)(&msg, &game_tx, &mut state) {\r\n                    // TODO: leave logging the error to the handler\r\n                    error!(\r\n                        \"[{}] Failed to process thread message {:?}, got error {:?}\",\r\n                        name, msg, e\r\n                    );\r\n                    if let Err(ee) = (handler_error_handler)(&msg, &game_tx, &mut state, &e) {\r\n                        error!(\r\n                            \"[{}] BAD NEWS! Failed while processing error handler for message {:?} that produced error {:?}, got new error {:?}\",\r\n                            name, msg, e, ee\r\n                        );\r\n                    }\r\n                }\r\n                std::thread::sleep(sleep_duration);\r\n            }\r\n        });\r\n    }) {\r\n        error!(\"[{}] Failed to spawn thread: {:?}\", config.name, e);\r\n    } else {\r\n        info!(\"[{}] Thread created\", config.name);\r\n    }\r\n}\r\n\r\nfn bridge_requests<T: WorkerMessage, G: WorkerMessage, S: WorkerState>(\r\n    config: Res<WorkerConfig<T, G, S>>,\r\n    bridge: ResMut<Bridge<T, G>>,\r\n    mut events: EventReader<T>,\r\n) {\r\n    for event in events.read() {\r\n        trace!(\"[{}] Bevy => Thread: {:?}\", config.name, event);\r\n        if let Err(e) = bridge.sender.try_send(event.clone()) {\r\n            match e {\r\n                crossbeam_channel::TrySendError::Full(_) => {\r\n                    error!(\"[{}] Threadbound channel is full, dropping message: {:?}\", config.name, event);\r\n                }\r\n                crossbeam_channel::TrySendError::Disconnected(_) => {\r\n                    error!(\"[{}] Threadbound channel is disconnected, dropping message: {:?}\", config.name, event);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfn bridge_responses<T: WorkerMessage, G: WorkerMessage, S: WorkerState>(\r\n    config: Res<WorkerConfig<T, G, S>>,\r\n    bridge: ResMut<Bridge<T, G>>,\r\n    mut events: EventWriter<G>,\r\n) {\r\n    for msg in bridge.receiver.try_iter() {\r\n        trace!(\"[{}] Thread => Bevy: {:?}\", config.name, msg);\r\n        events.send(msg);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui_inspector_types\\src\\ui_inspector_types.rs\r\n\r\n````rust\r\nuse bevy::{prelude::*, utils::HashMap};\r\nuse cursor_hero_ui_automation_types::prelude::{DrillId, ElementInfo, RuntimeId};\r\n\r\n#[derive(Resource, Debug, Reflect, Default)]\r\n#[reflect(Resource)]\r\npub struct UIData {\r\n    pub start: ElementInfo,\r\n    pub hovered: ElementInfo,\r\n    pub ui_tree: ElementInfo,\r\n    pub selected: Option<DrillId>,\r\n    pub expanded: Vec<DrillId>,\r\n    pub fresh: bool,\r\n    pub in_flight: bool,\r\n    pub paused: bool,\r\n    // Include runtime id in case tree changes and we quickly fetch something with the same drill_id before the first request comes back\r\n    pub fetching: HashMap<(DrillId, RuntimeId), FetchingState>,\r\n}\r\n\r\n#[derive(Debug, Reflect)]\r\npub enum FetchingState {\r\n    FetchRequest,\r\n    FetchDispatched,\r\n    Fetched(Vec<ElementInfo>),\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\xelu_prompts\\src\\lib.rs\r\n\r\n````rust\r\n// https://thoseawesomeguys.com/prompts/\r\nuse bevy::input::gamepad::GamepadButtonType;\r\nuse bevy::input::keyboard::KeyCode;\r\nuse leafwing_input_manager::user_input::InputKind;\r\n\r\npub fn texture_path_for_input(kind: &InputKind) -> Option<&'static str> {\r\n    match kind {\r\n        InputKind::Keyboard(key) => {\r\n            match key {\r\n                KeyCode::Key0 => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/0_Key_Dark.png\"),\r\n                KeyCode::Key1 => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/1_Key_Dark.png\"),\r\n                KeyCode::Key2 => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/2_Key_Dark.png\"),\r\n                KeyCode::Key3 => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/3_Key_Dark.png\"),\r\n                KeyCode::Key4 => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/4_Key_Dark.png\"),\r\n                KeyCode::Key5 => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/5_Key_Dark.png\"),\r\n                KeyCode::Key6 => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/6_Key_Dark.png\"),\r\n                KeyCode::Key7 => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/7_Key_Dark.png\"),\r\n                KeyCode::Key8 => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/8_Key_Dark.png\"),\r\n                KeyCode::Key9 => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/9_Key_Dark.png\"),\r\n\r\n                KeyCode::Numpad0 => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/0_Key_Dark.png\")\r\n                }\r\n                KeyCode::Numpad1 => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/1_Key_Dark.png\")\r\n                }\r\n                KeyCode::Numpad2 => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/2_Key_Dark.png\")\r\n                }\r\n                KeyCode::Numpad3 => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/3_Key_Dark.png\")\r\n                }\r\n                KeyCode::Numpad4 => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/4_Key_Dark.png\")\r\n                }\r\n                KeyCode::Numpad5 => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/5_Key_Dark.png\")\r\n                }\r\n                KeyCode::Numpad6 => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/6_Key_Dark.png\")\r\n                }\r\n                KeyCode::Numpad7 => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/7_Key_Dark.png\")\r\n                }\r\n                KeyCode::Numpad8 => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/8_Key_Dark.png\")\r\n                }\r\n                KeyCode::Numpad9 => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/9_Key_Dark.png\")\r\n                }\r\n\r\n                KeyCode::F1 => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/F1_Key_Dark.png\"),\r\n                KeyCode::F2 => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/F2_Key_Dark.png\"),\r\n                KeyCode::F3 => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/F3_Key_Dark.png\"),\r\n                KeyCode::F4 => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/F4_Key_Dark.png\"),\r\n                KeyCode::F5 => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/F5_Key_Dark.png\"),\r\n                KeyCode::F6 => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/F6_Key_Dark.png\"),\r\n                KeyCode::F7 => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/F7_Key_Dark.png\"),\r\n                KeyCode::F8 => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/F8_Key_Dark.png\"),\r\n                KeyCode::F9 => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/F9_Key_Dark.png\"),\r\n                KeyCode::F10 => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/F10_Key_Dark.png\")\r\n                }\r\n                KeyCode::F11 => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/F11_Key_Dark.png\")\r\n                }\r\n                KeyCode::F12 => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/F12_Key_Dark.png\")\r\n                }\r\n                KeyCode::F13 => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/F13_Key_Dark.png\")\r\n                }\r\n                KeyCode::F14 => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/F14_Key_Dark.png\")\r\n                }\r\n                KeyCode::F15 => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/F15_Key_Dark.png\")\r\n                }\r\n                KeyCode::F16 => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/F16_Key_Dark.png\")\r\n                }\r\n                KeyCode::F17 => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/F17_Key_Dark.png\")\r\n                }\r\n                KeyCode::F18 => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/F18_Key_Dark.png\")\r\n                }\r\n                KeyCode::F19 => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/F19_Key_Dark.png\")\r\n                }\r\n                KeyCode::F20 => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/F20_Key_Dark.png\")\r\n                }\r\n                KeyCode::F21 => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/F21_Key_Dark.png\")\r\n                }\r\n                KeyCode::F22 => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/F22_Key_Dark.png\")\r\n                }\r\n                KeyCode::F23 => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/F23_Key_Dark.png\")\r\n                }\r\n                KeyCode::F24 => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/F24_Key_Dark.png\")\r\n                }\r\n\r\n                // Alt_Key_Dark.png\r\n                KeyCode::AltLeft => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Alt_Key_Dark.png\")\r\n                }\r\n                KeyCode::AltRight => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Alt_Key_Dark.png\")\r\n                }\r\n                // Arrow_Down_Key_Dark.png\r\n                KeyCode::Down => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Down_Key_Dark.png\")\r\n                }\r\n                // Arrow_Left_Key_Dark.png\r\n                KeyCode::Left => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Left_Key_Dark.png\")\r\n                }\r\n                // Arrow_Right_Key_Dark.png\r\n                KeyCode::Right => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Right_Key_Dark.png\")\r\n                }\r\n                // Arrow_Up_Key_Dark.png\r\n                KeyCode::Up => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Up_Key_Dark.png\"),\r\n                // Asterisk_Key_Dark.png\r\n                KeyCode::Asterisk => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Asterisk_Key_Dark.png\")\r\n                }\r\n                // Backspace_Alt_Key_Dark.png\r\n                // Backspace_Key_Dark.png\r\n                // KeyCode::Back => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Backspace_Alt_Key_Dark.png\"),\r\n                KeyCode::Back => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Backspace_Key_Dark.png\")\r\n                }\r\n                // Bracket_Left_Key_Dark.png\r\n                KeyCode::BracketLeft => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Bracket_Left_Key_Dark.png\")\r\n                }\r\n                // Bracket_Right_Key_Dark.png\r\n                KeyCode::BracketRight => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Bracket_Right_Key_Dark.png\")\r\n                }\r\n                // Caps_Lock_Key_Dark.png\r\n                KeyCode::Capital => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Caps_Lock_Key_Dark.png\")\r\n                }\r\n                // Command_Key_Dark.png\r\n                KeyCode::SuperLeft => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Command_Key_Dark.png\")\r\n                }\r\n                // Ctrl_Key_Dark.png\r\n                KeyCode::ControlLeft => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Ctrl_Key_Dark.png\")\r\n                }\r\n                KeyCode::ControlRight => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Ctrl_Key_Dark.png\")\r\n                }\r\n                // Del_Key_Dark.png\r\n                KeyCode::Delete => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Del_Key_Dark.png\")\r\n                }\r\n                // End_Key_Dark.png\r\n                KeyCode::End => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/End_Key_Dark.png\")\r\n                }\r\n                // Enter_Alt_Key_Dark.png\r\n                // KeyCode::Return => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Enter_Alt_Key_Dark.png\"),\r\n                // Enter_Tall_Key_Dark.png\r\n                // KeyCode::Return => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Enter_Tall_Key_Dark.png\"),\r\n                // Enter_Key_Dark.png\r\n                KeyCode::Return => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Enter_Key_Dark.png\")\r\n                }\r\n\r\n                // Esc_Key_Dark.png\r\n                KeyCode::Escape => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Esc_Key_Dark.png\")\r\n                }\r\n                // Home_Key_Dark.png\r\n                KeyCode::Home => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Home_Key_Dark.png\")\r\n                }\r\n                // Insert_Key_Dark.png\r\n                KeyCode::Insert => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Insert_Key_Dark.png\")\r\n                }\r\n                // Mark_Left_Key_Dark.png \"<\"\r\n                // Mark_Right_Key_Dark.png \">\"\r\n                // Minus_Key_Dark.png\r\n                KeyCode::Minus => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Minus_Key_Dark.png\")\r\n                }\r\n                // Mouse_Left_Key_Dark.png\r\n                // Mouse_Middle_Key_Dark.png\r\n                // Mouse_Right_Key_Dark.png\r\n                // Mouse_Simple_Key_Dark.png\r\n                // Num_Lock_Key_Dark.png\r\n                KeyCode::Numlock => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Num_Lock_Key_Dark.png\")\r\n                }\r\n                // Page_Down_Key_Dark.png\r\n                KeyCode::PageDown => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Page_Down_Key_Dark.png\")\r\n                }\r\n                // Page_Up_Key_Dark.png\r\n                KeyCode::PageUp => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Page_Up_Key_Dark.png\")\r\n                }\r\n                // Plus_Key_Dark.png\r\n                KeyCode::Plus => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Plus_Key_Dark.png\")\r\n                }\r\n                // Plus_Tall_Key_Dark.png\r\n                KeyCode::NumpadAdd => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Plus_Tall_Key_Dark.png\")\r\n                }\r\n                // Print_Screen_Key_Dark.png\r\n                KeyCode::Snapshot => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Print_Screen_Key_Dark.png\")\r\n                }\r\n                // Question_Key_Dark.png\r\n                KeyCode::Slash => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Question_Key_Dark.png\")\r\n                }\r\n                // Quote_Key_Dark.png\r\n                KeyCode::Apostrophe => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Quote_Key_Dark.png\")\r\n                }\r\n                // Semicolon_Key_Dark.png\r\n                KeyCode::Semicolon => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Semicolon_Key_Dark.png\")\r\n                }\r\n                // Shift_Alt_Key_Dark.png\r\n                KeyCode::ShiftLeft => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Shift_Alt_Key_Dark.png\")\r\n                }\r\n                // Shift_Key_Dark.png\r\n                KeyCode::ShiftRight => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Shift_Key_Dark.png\")\r\n                }\r\n                // Slash_Key_Dark.png\r\n                KeyCode::Backslash => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Slash_Key_Dark.png\")\r\n                }\r\n                // Space_Key_Dark.png\r\n                KeyCode::Space => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Space_Key_Dark.png\")\r\n                }\r\n                // Tab_Key_Dark.png\r\n                KeyCode::Tab => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Tab_Key_Dark.png\")\r\n                }\r\n                // Tilda_Key_Dark.png\r\n                KeyCode::Grave => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Tilda_Key_Dark.png\")\r\n                }\r\n                // Win_Key_Dark.png\r\n                KeyCode::SuperRight => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Win_Key_Dark.png\")\r\n                }\r\n\r\n                KeyCode::A => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/A_Key_Dark.png\"),\r\n                KeyCode::B => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/B_Key_Dark.png\"),\r\n                KeyCode::C => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/C_Key_Dark.png\"),\r\n                KeyCode::D => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/D_Key_Dark.png\"),\r\n                KeyCode::E => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/E_Key_Dark.png\"),\r\n                KeyCode::F => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/F_Key_Dark.png\"),\r\n                KeyCode::G => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/G_Key_Dark.png\"),\r\n                KeyCode::H => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/H_Key_Dark.png\"),\r\n                KeyCode::I => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/I_Key_Dark.png\"),\r\n                KeyCode::J => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/J_Key_Dark.png\"),\r\n                KeyCode::K => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/K_Key_Dark.png\"),\r\n                KeyCode::L => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/L_Key_Dark.png\"),\r\n                KeyCode::M => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/M_Key_Dark.png\"),\r\n                KeyCode::N => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/N_Key_Dark.png\"),\r\n                KeyCode::O => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/O_Key_Dark.png\"),\r\n                KeyCode::P => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/P_Key_Dark.png\"),\r\n                KeyCode::Q => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Q_Key_Dark.png\"),\r\n                KeyCode::R => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/R_Key_Dark.png\"),\r\n                KeyCode::S => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/S_Key_Dark.png\"),\r\n                KeyCode::T => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/T_Key_Dark.png\"),\r\n                KeyCode::U => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/U_Key_Dark.png\"),\r\n                KeyCode::V => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/V_Key_Dark.png\"),\r\n                KeyCode::W => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/W_Key_Dark.png\"),\r\n                KeyCode::X => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/X_Key_Dark.png\"),\r\n                KeyCode::Y => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Y_Key_Dark.png\"),\r\n                KeyCode::Z => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Z_Key_Dark.png\"),\r\n                _ => None,\r\n            }\r\n        }\r\n        InputKind::Mouse(button) => match button {\r\n            bevy::input::mouse::MouseButton::Left => {\r\n                Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Mouse_Left_Key_Dark.png\")\r\n            }\r\n            bevy::input::mouse::MouseButton::Right => {\r\n                Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Mouse_Right_Key_Dark.png\")\r\n            }\r\n            bevy::input::mouse::MouseButton::Middle => {\r\n                Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Mouse_Middle_Key_Dark.png\")\r\n            }\r\n            bevy::input::mouse::MouseButton::Other(_) => None,\r\n        },\r\n        InputKind::GamepadButton(button) => {\r\n            match button {\r\n                // XboxSeriesX_A.png\r\n                GamepadButtonType::South => {\r\n                    Some(\"textures/xelu_prompts/Xbox Series/XboxSeriesX_A.png\")\r\n                }\r\n                // XboxSeriesX_B.png\r\n                GamepadButtonType::East => {\r\n                    Some(\"textures/xelu_prompts/Xbox Series/XboxSeriesX_B.png\")\r\n                }\r\n                // XboxSeriesX_Diagram.png\r\n                // XboxSeriesX_Diagram_Simple.png\r\n                // XboxSeriesX_Dpad.png\r\n                // XboxSeriesX_Dpad_Down.png\r\n                GamepadButtonType::DPadDown => {\r\n                    Some(\"textures/xelu_prompts/Xbox Series/XboxSeriesX_Dpad_Down.png\")\r\n                }\r\n                // XboxSeriesX_Dpad_Left.png\r\n                GamepadButtonType::DPadLeft => {\r\n                    Some(\"textures/xelu_prompts/Xbox Series/XboxSeriesX_Dpad_Left.png\")\r\n                }\r\n                // XboxSeriesX_Dpad_Right.png\r\n                GamepadButtonType::DPadRight => {\r\n                    Some(\"textures/xelu_prompts/Xbox Series/XboxSeriesX_Dpad_Right.png\")\r\n                }\r\n                // XboxSeriesX_Dpad_Up.png\r\n                GamepadButtonType::DPadUp => {\r\n                    Some(\"textures/xelu_prompts/Xbox Series/XboxSeriesX_Dpad_Up.png\")\r\n                }\r\n                // XboxSeriesX_LB.png\r\n                GamepadButtonType::LeftTrigger => {\r\n                    Some(\"textures/xelu_prompts/Xbox Series/XboxSeriesX_LB.png\")\r\n                }\r\n                // XboxSeriesX_Left_Stick.png\r\n                // GamepadButtonType::LeftStick => Some(\"textures/xelu_prompts/Xbox Series/XboxSeriesX_Left_Stick.png\"),\r\n                // XboxSeriesX_Left_Stick_Click.png\r\n                GamepadButtonType::LeftThumb => {\r\n                    Some(\"textures/xelu_prompts/Xbox Series/XboxSeriesX_Left_Stick_Click.png\")\r\n                }\r\n                // XboxSeriesX_LT.png\r\n                GamepadButtonType::LeftTrigger2 => {\r\n                    Some(\"textures/xelu_prompts/Xbox Series/XboxSeriesX_LT.png\")\r\n                }\r\n                // XboxSeriesX_Menu.png\r\n                GamepadButtonType::Start => {\r\n                    Some(\"textures/xelu_prompts/Xbox Series/XboxSeriesX_Menu.png\")\r\n                }\r\n                // XboxSeriesX_RB.png\r\n                GamepadButtonType::RightTrigger => {\r\n                    Some(\"textures/xelu_prompts/Xbox Series/XboxSeriesX_RB.png\")\r\n                }\r\n                // XboxSeriesX_Right_Stick.png\r\n                // GamepadButtonType::RightStick => Some(\"textures/xelu_prompts/Xbox Series/XboxSeriesX_Right_Stick.png\"),\r\n                // XboxSeriesX_Right_Stick_Click.png\r\n                GamepadButtonType::RightThumb => {\r\n                    Some(\"textures/xelu_prompts/Xbox Series/XboxSeriesX_Right_Stick_Click.png\")\r\n                }\r\n                // XboxSeriesX_RT.png\r\n                GamepadButtonType::RightTrigger2 => {\r\n                    Some(\"textures/xelu_prompts/Xbox Series/XboxSeriesX_RT.png\")\r\n                }\r\n                // XboxSeriesX_Share.png\r\n                // XboxSeriesX_View.png\r\n                GamepadButtonType::Select => {\r\n                    Some(\"textures/xelu_prompts/Xbox Series/XboxSeriesX_View.png\")\r\n                }\r\n                // XboxSeriesX_X.png\r\n                GamepadButtonType::West => {\r\n                    Some(\"textures/xelu_prompts/Xbox Series/XboxSeriesX_X.png\")\r\n                }\r\n                // XboxSeriesX_Y.png\r\n                GamepadButtonType::North => {\r\n                    Some(\"textures/xelu_prompts/Xbox Series/XboxSeriesX_Y.png\")\r\n                }\r\n                _ => None,\r\n            }\r\n        }\r\n        _ => None,\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui_watcher_types\\src\\ui_watcher_types_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse crate::prelude::*;\r\n\r\npub struct UiWatcherTypesPlugin;\r\n\r\nimpl Plugin for UiWatcherTypesPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<ThreadboundUIWatcherMessage>();\r\n        app.add_event::<ThreadboundUIWatcherMessage>();\r\n        app.register_type::<GameboundUIWatcherMessage>();\r\n        app.add_event::<GameboundUIWatcherMessage>();\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\templates\\copy_notebook.ps1\r\n\r\n````powershell\r\nparam (\r\n    [Parameter(Mandatory=$true, Position=0)]\r\n    [ValidateScript({Test-Path $_ -PathType 'Leaf'})]\r\n    [string]$NotebookPath,\r\n\r\n    [Parameter(Position=1)]\r\n    [switch]$IncludeOutputs\r\n)\r\n\r\n# Load the notebook as JSON\r\n$notebook = Get-Content -Raw -Path $NotebookPath | ConvertFrom-Json\r\n\r\n# Function to format code cells as markdown entries, correctly handling the array of lines in $Content\r\nfunction Format-CodeCell {\r\n    param (\r\n        [Parameter(Mandatory=$true)]\r\n        [Object[]]$Content, # Changed to Object[] to handle both source and outputs correctly\r\n\r\n        [Parameter(Mandatory=$false)]\r\n        [Object[]]$Outputs\r\n    )\r\n\r\n    $formattedContent = $Content -join \"\"\r\n    $markdown = \"``````py`n$formattedContent`n``````\"\r\n\r\n    if ($IncludeOutputs -and $Outputs) {\r\n        $formattedOutputs = $Outputs | ForEach-Object {\r\n            if ($_.output_type -eq \"stream\") {\r\n                $_.text -join \"`n\"\r\n            }\r\n            elseif ($_.output_type -eq \"execute_result\" -or $_.output_type -eq \"display_data\") {\r\n                $_.data.\"text/plain\" -join \"`n\"\r\n            }\r\n        } -join \"`n\"\r\n\r\n        if ($formattedOutputs) {\r\n            $markdown += \"`n```````n$formattedOutputs`n``````\"\r\n        }\r\n    }\r\n\r\n    $markdown\r\n}\r\n\r\n# Map code cells to formatted markdown entries\r\n$markdownEntries = $notebook.cells | Where-Object { $_.cell_type -eq 'code' } | ForEach-Object {\r\n    $source = $_.source\r\n    $outputs = if ($IncludeOutputs) { $_.outputs } else { $null }\r\n    Format-CodeCell -Content $source -Outputs $outputs\r\n}\r\n\r\n# Copy the result to the clipboard\r\n$markdownEntries -join \"`n`n\" | Set-Clipboard\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\templates\\patterns\\new_plugin_with_types\\crates\\{{crate_name}}_types\\src\\{{crate_name}}_types_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse crate::prelude::*;\r\n\r\npub struct {{crate_name_pascal}}TypesPlugin;\r\n\r\nimpl Plugin for {{crate_name_pascal}}TypesPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<MyComponent>();\r\n        app.add_event::<MyEvent>();\r\n    }\r\n}\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\wallpaper\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_wallpaper\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\ncursor_hero_environment_types = { workspace = true }\r\ncursor_hero_winutils = { workspace = true }\r\nbevy = { workspace = true }\r\nwindows = { workspace = true, features = [\r\n    \"Win32_Foundation\",\r\n    \"Win32_UI_WindowsAndMessaging\",\r\n    \"Win32_UI_Input_KeyboardAndMouse\",\r\n] }\r\nimage = { workspace = true}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\winutils\\src\\win_cursor.rs\r\n\r\n````rust\r\nuse crate::win_errors::*;\r\nuse crate::win_icons::convert_hcursor_to_rgba_image;\r\nuse image::RgbaImage;\r\nuse windows::Win32::UI::WindowsAndMessaging::LoadCursorW;\r\nuse windows::Win32::UI::WindowsAndMessaging::IDC_APPSTARTING;\r\nuse windows::Win32::UI::WindowsAndMessaging::IDC_ARROW;\r\nuse windows::Win32::UI::WindowsAndMessaging::IDC_CROSS;\r\nuse windows::Win32::UI::WindowsAndMessaging::IDC_HAND;\r\nuse windows::Win32::UI::WindowsAndMessaging::IDC_HELP;\r\nuse windows::Win32::UI::WindowsAndMessaging::IDC_IBEAM;\r\nuse windows::Win32::UI::WindowsAndMessaging::IDC_NO;\r\nuse windows::Win32::UI::WindowsAndMessaging::IDC_SIZEALL;\r\nuse windows::Win32::UI::WindowsAndMessaging::IDC_SIZENESW;\r\nuse windows::Win32::UI::WindowsAndMessaging::IDC_SIZENS;\r\nuse windows::Win32::UI::WindowsAndMessaging::IDC_SIZENWSE;\r\nuse windows::Win32::UI::WindowsAndMessaging::IDC_SIZEWE;\r\nuse windows::Win32::UI::WindowsAndMessaging::IDC_UPARROW;\r\nuse windows::Win32::UI::WindowsAndMessaging::IDC_WAIT;\r\n\r\npub fn get_all_cursor_icons() -> Result<Vec<RgbaImage>> {\r\n    let mut icons = Vec::new();\r\n\r\n    // Load each cursor and convert it to an RgbaImage\r\n    for cursor_id in [\r\n        IDC_ARROW,\r\n        IDC_IBEAM,\r\n        IDC_WAIT,\r\n        IDC_CROSS,\r\n        IDC_UPARROW,\r\n        IDC_SIZEALL,\r\n        IDC_SIZENESW,\r\n        IDC_SIZENS,\r\n        IDC_SIZENWSE,\r\n        IDC_SIZEWE,\r\n        IDC_HAND,\r\n        IDC_HELP,\r\n        IDC_NO,\r\n        IDC_APPSTARTING,\r\n    ] {\r\n        let hcursor = unsafe { LoadCursorW(None, cursor_id)? };\r\n        if hcursor.is_invalid() {\r\n            return Err(Error::from_win32()\r\n                .with_description(format!(\"Failed to load cursor with ID {:?}\", cursor_id.0)));\r\n        }\r\n        let image = convert_hcursor_to_rgba_image(&hcursor)?;\r\n        icons.push(image);\r\n    }\r\n\r\n    Ok(icons)\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use std::path::PathBuf;\r\n\r\n    #[test]\r\n    fn test_get_all_cursor_icons() {\r\n        let icons = super::get_all_cursor_icons().unwrap();\r\n\r\n        // Ensure the expected amount is present\r\n        assert_eq!(icons.len(), 14);\r\n\r\n        // Save icons\r\n        let mut path = PathBuf::from(\"target/cursor_icons\");\r\n        std::fs::create_dir_all(&path).unwrap();\r\n        for (i, icon) in icons.iter().enumerate() {\r\n            let mut icon_path = path.clone();\r\n            icon_path.push(format!(\"{}.png\", i));\r\n            icon.save(icon_path).unwrap();\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\templates\\patterns\\new_tool\\crates\\{{crate_name}}_tool\\src\\{{crate_name}}_tool_tick_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse cursor_hero_{{crate_name_pascal}}_tool_types::prelude::*;\r\nuse cursor_hero_toolbelt_types::prelude::*;\r\nuse leafwing_input_manager::prelude::*;\r\n\r\npub struct {{crate_name_pascal}}ToolTickPlugin;\r\n\r\nimpl Plugin for {{crate_name_pascal}}ToolTickPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_plugins(InputManagerPlugin::<{{crate_name_pascal}}ToolAction>::default());\r\n        app.add_systems(Update, tick);\r\n    }\r\n}\r\n\r\nfn tick(\r\n    tool_query: Query<(&ActionState<{{crate_name_pascal}}ToolAction>, &{{crate_name_pascal}}Tool), With<ActiveTool>>,\r\n) {\r\n    for tool in tool_query.iter() {\r\n        let (tool_actions, tool) = tool;\r\n        if !tool_actions.pressed({{crate_name_pascal}}ToolAction::Use) {\r\n            continue;\r\n        }\r\n        info!(\"{{crate_name_pascal}}Tool used!\");\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\version\\src\\lib.rs\r\n\r\n````rust\r\npub mod version_plugin;\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\templates\\patterns\\new_plugin_with_types\\crates\\{{crate_name}}\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_{{crate_name}}\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\ncursor_hero_{{crate_name}}_types = { workspace = true }\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\research_notes.md\r\n\r\n````markdown\r\n# Research Notes\r\n\r\n## Inference\r\n\r\n- [LM Studio](https://lmstudio.ai/)\r\n\r\n## Fine Tuning\r\n\r\n- [allenai/OLMo: Modeling, training, eval, and inference code for OLMo (github.com)](https://github.com/allenai/OLMo)\r\n- [hiyouga/LLaMA-Factory: Unify Efficient Fine-tuning of 100+ LLMs (github.com)](https://github.com/hiyouga/LLaMA-Factory)\r\n- [OpenAccess-AI-Collective/axolotl: Go ahead and axolotl questions (github.com)](https://github.com/OpenAccess-AI-Collective/axolotl)\r\n- [LLaVA/docs/Finetune\\_Custom\\_Data.md at main - haotian-liu/LLaVA (github.com)](https://github.com/haotian-liu/LLaVA/blob/main/docs/Finetune_Custom_Data.md)\r\n\r\n\r\n## Vision\r\n\r\n- [PTA-Text: A Text Only Click Model - Prompt image, it tells you where it would click](https://huggingface.co/AskUI/pta-text-0.1) ([demo](https://huggingface.co/spaces/AskUI/pta-text-v0.1))\r\n- [Set-of-Mark Visual Prompting for GPT-4V](https://github.com/microsoft/SoM)\r\n- [LLaVA](https://llava.hliu.cc/)\r\n- [YOLOv9](https://github.com/WongKinYiu/yolov9)\r\n- [Ty on X: \"Open Interpreter 0.2.1 is out! -\u00a0 5X launch speed -\u00a0 Local OSS model for GUI control -\u00a0 Native control over Apple Mail, Calendar, Contacts, SMS -\u00a0 New LLM-first web browser (powered by @perplexity\\_ai) -\u00a0 Profiles, Docker, Jupyter export... \u2193 https://t.co/XU4gibTXWk\" / X (twitter.com)](https://twitter.com/FieroTy/status/1767328066290987470)\r\n\r\n## RPA\r\n\r\n- [OpenAdaptAI/OpenAdapt: AI-First Process Automation with Large Multimodal Models (LMMs)](https://github.com/OpenAdaptAI/OpenAdapt)\r\n- [askui/askui: \"What can be said can be solved-\"](https://docs.askui.com/docs/api/Element-Descriptions/text)\r\n- [ddupont808/GPT-4V-Act: AI agent using GPT-4V(ision) capable of using a mouse/keyboard to interact with web UI](https://www.reddit.com/r/MachineLearning/comments/17cy0j7/d_p_web_browsing_uibased_ai_agent_gpt4vact/?share_id=w5kHMEziP5LdHm_2NrlUc&rdt=49921)\r\n- [TobiasNorlund/UI-Act: An AI agent for interacting with a computer using the graphical user interface](https://www.reddit.com/r/MachineLearning/comments/1765v6i/d_p_uibased_ai_agents_uiact/)\r\n- [KillianLucas/open-interpreter: A natural language interface for computers](https://github.com/KillianLucas/open-interpreter)\r\n\r\n\r\n## Windows UI Automation\r\n\r\n- [Accessibility tools - AccEvent (Accessible Event Watcher) - Win32 apps | Microsoft Learn](https://learn.microsoft.com/en-us/windows/win32/winauto/accessible-event-watcher)\r\n- [Accessibility tools - Inspect - Win32 apps | Microsoft Learn](https://learn.microsoft.com/en-us/windows/win32/winauto/inspect-objects)\r\n- [Accessibility Insights](https://accessibilityinsights.io/)\r\n- [Navigation events for WebView2 apps - Microsoft Edge Developer documentation | Microsoft Learn](https://learn.microsoft.com/en-us/microsoft-edge/webview2/concepts/navigation-events)\r\n- [c# - UIAutomation won't retrieve children of an element - Stack Overflow](https://stackoverflow.com/questions/14187110/uiautomation-wont-retrieve-children-of-an-element)\r\n- [comEle = \\_AutomationClient.instance().dll.GetNextSiblingElement(self.Element) Hangs - Issue #30 - yinkaisheng/Python-UIAutomation-for-Windows (github.com)](https://github.com/yinkaisheng/Python-UIAutomation-for-Windows/issues/30)\r\n- [microsoft/WinAppDriver: Windows Application Driver (github.com)](https://github.com/microsoft/WinAppDriver)\r\n- [How to force UI automation tree refresh](https://stackoverflow.com/q/64120894/11141271)\r\n  - mostly interested in the screen reader flag mentioned\r\n    ```\r\n    SystemParametersInfo( SPI_SETSCREENREADER, TRUE, NULL, SPIF_UPDATEINIFILE | SPIF_SENDCHANGE);\r\n    PostMessage( HWND_BROADCAST, WM_WININICHANGE, SPI_SETSCREENREADER, 0);\r\n    ```\r\n- [UI Automation Fundamentals - .NET Framework | Microsoft Learn](https://learn.microsoft.com/en-us/dotnet/framework/ui-automation/ui-automation-fundamentals)\r\n- [Understanding Threading Issues - Win32 apps | Microsoft Learn](https://learn.microsoft.com/en-us/windows/win32/winauto/uiauto-threading)\r\n- [UI Automation Threading Issues - .NET Framework | Microsoft Learn](https://learn.microsoft.com/en-us/dotnet/framework/ui-automation/ui-automation-threading-issues)\r\n- [c# - System.Windows.Automation is extremely slow - Stack Overflow](https://stackoverflow.com/questions/41768046/system-windows-automation-is-extremely-slow)\r\n- [msdn-code-gallery-microsoft/Official Windows Platform Sample/UI Automation document content client sample at master - microsoftarchive/msdn-code-gallery-microsoft (github.com)](https://github.com/microsoftarchive/msdn-code-gallery-microsoft/tree/master/Official%20Windows%20Platform%20Sample/UI%20Automation%20document%20content%20client%20sample)\r\n  - [Browse code samples | Microsoft Learn](https://learn.microsoft.com/en-us/samples/browse/)\r\n- caching\r\n  - [UIAutomation not catching all elements - Microsoft Q&A](https://learn.microsoft.com/en-us/answers/questions/545180/uiautomation-not-catching-all-elements)\r\n  - [Caching UI Automation Properties and Control Patterns - Win32 apps | Microsoft Learn](https://learn.microsoft.com/en-us/windows/win32/winauto/uiauto-cachingforclients)\r\n  - [IUIAutomationElement::FindAllBuildCache (uiautomationclient.h) - Win32 apps | Microsoft Learn](https://learn.microsoft.com/en-us/windows/win32/api/uiautomationclient/nf-uiautomationclient-iuiautomationelement-findallbuildcache)\r\n\r\n## Win32\r\n\r\n- [How does Microsoft's \"inspect.exe\" application keep its window on top? - Microsoft Q&A === WS_EX_TOPMOST, UAC Bypass UI](https://learn.microsoft.com/en-us/answers/questions/1105704/how-does-microsofts-inspect-exe-application-keep-i)\r\n  - [\"Automatic dismissal of the start menu\" and other crazyness - Windows-classic-samples/Samples/DesktopAutomationDismiss at 27ffb0811ca761741502feaefdb591aebf592193 - microsoft/Windows-classic-samples (github.com)](https://github.com/microsoft/Windows-classic-samples/tree/27ffb0811ca761741502feaefdb591aebf592193/Samples/DesktopAutomationDismiss#build-the-sample)\r\n- `[Convert]::ToInt32(\"0x80070012\", 16)` then ctrl+F win32::Foundation to find the error code\r\n- [Process Hacker / Code / \\[r6350\\] /2.x/trunk (sourceforge.net)](https://sourceforge.net/p/processhacker/code/HEAD/tree/2.x/trunk/)\r\n- [Process Monitor - Sysinternals | Microsoft Learn](https://learn.microsoft.com/en-us/sysinternals/downloads/procmon)\r\n- [(1) Building 25+ years of SysInternals: Exploring ZoomIt | BRK200H - YouTube](https://www.youtube.com/watch?v=W2bNgFrj3Iw)\r\n- [c# - Getting icon of \"modern\" Windows app from a desktop application? - Stack Overflow](https://stackoverflow.com/questions/32122679/getting-icon-of-modern-windows-app-from-a-desktop-application)\r\n- [DLL Export Viewer - view exported functions list in Windows DLL (nirsoft.net)](https://www.nirsoft.net/utils/dll_export_viewer.html)\r\n\r\n## RL\r\n\r\n- [stillonearth/bevy_rl](https://github.com/stillonearth/bevy_rl/blob/main/src/render.rs)\r\n- [Saving RenderTarget image data to a file #5603](https://github.com/bevyengine/bevy/discussions/5603)\r\n- [paulkre/bevy_image_export: Bevy plugin for rendering image sequences](https://github.com/paulkre/bevy_image_export)\r\n\r\n\r\n## Prompting\r\n\r\n- [guidance-ai/guidance: A guidance language for controlling large language models.](https://github.com/guidance-ai/guidance)\r\n- [Eladlev/AutoPrompt: A framework for prompt tuning using Intent-based Prompt Calibration (github.com)](https://github.com/Eladlev/AutoPrompt)\r\n\r\n## RAG, Tools and Actions\r\n\r\n- [ACT-1: Transformer for Actions](https://www.adept.ai/blog/act-1)\r\n- [LlamaIndex \ud83e\udd99 v0.10.6](https://docs.llamaindex.ai/en/stable/)\r\n- [Supercharge Your RAG with Contextualized Late Interactions (youtube.com)](https://www.youtube.com/watch?v=xTzUn3G9YA0)\r\n  - [bclavie/RAGatouille](https://github.com/bclavie/RAGatouille)\r\n\r\n## Sandboxing\r\n\r\n- [copy/v86: x86 PC emulator and x86-to-wasm JIT, running in the browser](https://github.com/copy/v86) ([demo](https://copy.sh/v86/))\r\n\r\n## Speech to Text\r\n\r\n- [openai/whisper-large-v2: Hugging Face](https://huggingface.co/openai/whisper-large-v2)\r\n- [m-bain/whisperX: Automatic Speech Recognition with Word-level Timestamps (& Diarization)](https://github.com/m-bain/whisperX)\r\n- [SYSTRAN/faster-whisper: Faster Whisper transcription with CTranslate2](https://github.com/SYSTRAN/faster-whisper)\r\n- [collabora/WhisperLive: A nearly-live implementation of OpenAI's Whisper](https://github.com/collabora/WhisperLive)\r\n- [gaborvecsei/whisper-live-transcription: Live-Transcription (STT) with Whisper PoC (github.com)](https://github.com/gaborvecsei/whisper-live-transcription)\r\n- [FL33TW00D/whisper-turbo: Cross-Platform, GPU Accelerated Whisper \ud83c\udfce\ufe0f (github.com)](https://github.com/FL33TW00D/whisper-turbo)\r\n\r\n## Multiplayer\r\n\r\n- [Veilid: open-source, peer-to-peer, mobile-\ufb01rst, networked application framework.](https://veilid.com/)\r\n\r\n## Impl\r\n\r\n- [beartype](https://beartype.readthedocs.io/en/latest/)\r\n- [facebookresearch/torchdim: Named tensors with first-class dimensions for PyTorch](https://github.com/facebookresearch/torchdim)\r\n- [Are we learning yet? A work-in-progress to catalog the state of machine learning in Rust](https://www.arewelearningyet.com/)\r\n- [PyO3/pyo3: Rust bindings for the Python interpreter](https://github.com/PyO3/pyo3)\r\n\r\n## Assets\r\n\r\n- [Euphoric Heavy Regular](https://fontsgeek.com/fonts/Euphoric-Heavy-Regular)\r\n- [Kenney Fonts](https://kenney.nl/assets/kenney-fonts)\r\n- [Fira Mono - Google Fonts](https://fonts.google.com/specimen/Fira+Mono)\r\n- [Xelu's FREE Controller Prompts (thoseawesomeguys.com)](https://thoseawesomeguys.com/prompts/)\r\n\r\n## Bevy stuff\r\n\r\n- [janhohenheim/foxtrot: The all-in-one Bevy 3D game template for desktop. (github.com)](https://github.com/janhohenheim/foxtrot)\r\n- [StarArawn/bevy\\_ecs\\_tilemap: A tilemap rendering crate for bevy which is more ECS friendly. (github.com)](https://github.com/StarArawn/bevy_ecs_tilemap)\r\n- [djeedai/bevy\\_hanabi: \ud83c\udf86 Hanabi --- a GPU particle system plugin for the Bevy game engine. (github.com)](https://github.com/djeedai/bevy_hanabi)\r\n- [Added Audio Input Support by bushrat011899 - Pull Request #10072 - bevyengine/bevy (github.com)](https://github.com/bevyengine/bevy/pull/10072)\r\n\r\n## Game inspiration\r\n\r\n- [The Last Clockwinder](https://store.steampowered.com/app/1755100/The_Last_Clockwinder/)\r\n\r\n## Issues \ud83d\udc40\r\n\r\n- [Transparent example not working - Issue #2502 - rust-windowing/winit (github.com)](https://github.com/rust-windowing/winit/issues/2502)\r\n\r\n## SDF\r\n\r\n- [SDF arbitary 2D polygon (shadertoy.com)](https://www.shadertoy.com/view/WdSGRd)\r\n- [Arbitrary Polygons, Blur/Border (shadertoy.com)](https://www.shadertoy.com/view/ctBXDK)\r\n\r\n## Video making\r\n\r\n- [Quickstart | Motion Canvas](https://motioncanvas.io/docs/quickstart/)\r\n  - [examples/examples at master - motion-canvas/examples (github.com)](https://github.com/motion-canvas/examples/tree/master/examples)\r\n  - [reviewing your motion canvas animations ![](https://img.youtube.com/vi/lY6D9x9qCt4/0.jpg)](https://www.youtube.com/watch?v=lY6D9x9qCt4)\r\n\r\n## Art\r\n\r\n- [Aseprite - Animated sprite editor & pixel art tool](https://www.aseprite.org/)\r\n\r\n## UI\r\n\r\n- [linebender/vello: An experimental GPU compute-centric 2D renderer. (github.com)](https://github.com/linebender/vello)\r\n  - [loopystudios/bevy\\_vello: An integration to render with Vello in Bevy game engine. (github.com)](https://github.com/loopystudios/bevy_vello)\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\src\\main.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse cursor_hero_plugins::prelude::*;\r\nuse cursor_hero_version::version_plugin::VersionPlugin;\r\n\r\nenum LaunchMode {\r\n    Default,\r\n    Headless,\r\n}\r\n\r\nfn main() {\r\n    let args = std::env::args().collect::<Vec<String>>();\r\n    let launch_mode = match args.get(1).map(|s| s.as_str()) {\r\n        Some(\"headless\") => LaunchMode::Headless,\r\n        _ => LaunchMode::Default,\r\n    };\r\n\r\n    let mut app = App::new();\r\n    app.add_plugins(VersionPlugin(env!(\"CARGO_PKG_VERSION\").to_string()));\r\n\r\n    match launch_mode {\r\n        LaunchMode::Default => {\r\n            app.add_plugins(DefaultLaunchModePlugin);\r\n        }\r\n        LaunchMode::Headless => {\r\n            app.add_plugins(HeadlessLaunchModePlugin);\r\n        }\r\n    }\r\n    app.run();\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\winutils\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_winutils\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\ncursor_hero_metrics = { workspace = true }\r\nbevy = { workspace = true }\r\nwindows = { workspace = true, features = [\r\n    \"Win32_Devices_HumanInterfaceDevice\",\r\n    \"Win32_Foundation\",\r\n    \"Win32_Graphics_Gdi\",\r\n    \"Win32_Security\",\r\n    \"Win32_System_Com\",\r\n    \"Win32_System_Diagnostics_ToolHelp\",\r\n    \"Win32_System_LibraryLoader\",\r\n    \"Win32_System_Ole\",\r\n    \"Win32_System_ProcessStatus\",\r\n    \"Win32_System_Threading\",\r\n    \"Win32_System_Variant\",\r\n    \"Win32_UI_Input_KeyboardAndMouse\",\r\n    \"Win32_UI_WindowsAndMessaging\",\r\n    # \"Win32_UI_Accessibility\",\r\n    # \"Gaming_Input\",\r\n    # \"Win32_Gaming\",\r\n    # \"Win32_System_Threading\",\r\n] }\r\nimage = {workspace = true}\r\nanyhow = {workspace = true}\r\nuiautomation = {workspace = true}\r\nfxhash = {workspace = true}\r\nwidestring = {workspace = true}\r\nenigo = {workspace = true}\r\nonce_cell = {workspace = true}\r\nitertools = {workspace = true}\r\nwinreg = { workspace = true }\r\ncrossbeam-channel = { workspace = true }\r\ncursor_hero_bevy = { workspace = true }\r\ncursor_hero_math = { workspace = true }\r\nwinit = { workspace = true } # TODO: remove me\r\n\r\n[dev-dependencies]\r\ncursor_hero_memory_types = { workspace = true }\r\ncursor_hero_worker = { workspace = true }\r\nbevy-inspector-egui = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\templates\\patterns\\new_tool\\crates\\{{crate_name}}_tool_types\\src\\{{crate_name}}_tool_types.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse leafwing_input_manager::prelude::*;\r\nuse leafwing_input_manager::user_input::InputKind;\r\n\r\nuse bevy_inspector_egui::prelude::ReflectInspectorOptions;\r\nuse bevy_inspector_egui::InspectorOptions;\r\nuse cursor_hero_input::active_input_state_plugin::ActiveInput;\r\nuse cursor_hero_toolbelt_types::prelude::*;\r\n\r\n#[derive(Component, Reflect, Debug, InspectorOptions)]\r\n#[reflect(Component, InspectorOptions)]\r\npub struct {{crate_name_pascal}}Tool;\r\n\r\nimpl Default for {{crate_name_pascal}}Tool {\r\n    fn default() -> Self {\r\n        match ActiveInput::default() {\r\n            ActiveInput::MouseAndKeyboard => Self::default_mnk(),\r\n            ActiveInput::Gamepad => Self::default_gamepad(),\r\n        }\r\n    }\r\n}\r\nimpl {{crate_name_pascal}}Tool {\r\n    pub fn default_mnk() -> {{crate_name_pascal}}Tool {\r\n        {{crate_name_pascal}}Tool\r\n    }\r\n    pub fn default_gamepad() -> {{crate_name_pascal}}Tool {\r\n        {{crate_name_pascal}}Tool\r\n    }\r\n}\r\n\r\n#[derive(Actionlike, PartialEq, Eq, Clone, Copy, Hash, Debug, Reflect)]\r\npub enum {{crate_name_pascal}}ToolAction {\r\n    Use,\r\n}\r\n\r\nimpl {{crate_name_pascal}}ToolAction {\r\n    fn default_gamepad_binding(&self) -> UserInput {\r\n        match self {\r\n            Self::Use => GamepadButtonType::South.into(),\r\n        }\r\n    }\r\n\r\n    fn default_mkb_binding(&self) -> UserInput {\r\n        match self {\r\n            Self::Use => MouseButton::Left.into(),\r\n        }\r\n    }\r\n}\r\nimpl ToolAction for {{crate_name_pascal}}ToolAction {\r\n    fn default_input_map(_event: &PopulateToolbeltEvent) -> Option<InputMap<{{crate_name_pascal}}ToolAction>> {\r\n        let mut input_map = InputMap::default();\r\n\r\n        for variant in {{crate_name_pascal}}ToolAction::variants() {\r\n            input_map.insert(variant.default_mkb_binding(), variant);\r\n            input_map.insert(variant.default_gamepad_binding(), variant);\r\n        }\r\n        Some(input_map)\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\winutils\\src\\win_mouse.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse windows::Win32::Foundation::POINT;\r\nuse windows::Win32::UI::Input::KeyboardAndMouse::SendInput;\r\nuse windows::Win32::UI::Input::KeyboardAndMouse::INPUT;\r\nuse windows::Win32::UI::Input::KeyboardAndMouse::INPUT_0;\r\nuse windows::Win32::UI::Input::KeyboardAndMouse::INPUT_MOUSE;\r\nuse windows::Win32::UI::Input::KeyboardAndMouse::INPUT_TYPE;\r\nuse windows::Win32::UI::Input::KeyboardAndMouse::KEYBDINPUT;\r\nuse windows::Win32::UI::Input::KeyboardAndMouse::KEYBD_EVENT_FLAGS;\r\nuse windows::Win32::UI::Input::KeyboardAndMouse::MOUSEEVENTF_LEFTDOWN;\r\nuse windows::Win32::UI::Input::KeyboardAndMouse::MOUSEEVENTF_LEFTUP;\r\nuse windows::Win32::UI::Input::KeyboardAndMouse::MOUSEEVENTF_RIGHTDOWN;\r\nuse windows::Win32::UI::Input::KeyboardAndMouse::MOUSEEVENTF_RIGHTUP;\r\nuse windows::Win32::UI::Input::KeyboardAndMouse::MOUSEEVENTF_WHEEL;\r\nuse windows::Win32::UI::Input::KeyboardAndMouse::MOUSEINPUT;\r\nuse windows::Win32::UI::Input::KeyboardAndMouse::VIRTUAL_KEY;\r\nuse windows::Win32::UI::WindowsAndMessaging::GetCursorPos;\r\nuse windows::Win32::UI::WindowsAndMessaging::SetCursorPos;\r\nuse windows::Win32::UI::WindowsAndMessaging::WHEEL_DELTA;\r\n\r\npub fn get_cursor_position() -> Result<IVec2, windows::core::Error> {\r\n    unsafe {\r\n        let mut point = POINT::default();\r\n        GetCursorPos(&mut point)?;\r\n        Ok(IVec2::new(point.x, point.y))\r\n    }\r\n}\r\n\r\npub fn set_cursor_position(position: IVec2) -> Result<(), windows::core::Error> {\r\n    unsafe {\r\n        SetCursorPos(position.x, position.y)?;\r\n        Ok(())\r\n    }\r\n}\r\n\r\npub fn left_mouse_down() -> Result<(), windows::core::Error> {\r\n    // Prepare a mouse input for left button down\r\n    let mouse_input = MOUSEINPUT {\r\n        dx: 0,\r\n        dy: 0,\r\n        mouseData: 0,\r\n        dwFlags: MOUSEEVENTF_LEFTDOWN,\r\n        time: 0,\r\n        dwExtraInfo: 0,\r\n    };\r\n\r\n    // Prepare an INPUT structure for the down event\r\n    let input = INPUT {\r\n        r#type: INPUT_MOUSE,\r\n        Anonymous: INPUT_0 { mi: mouse_input },\r\n    };\r\n\r\n    // Send the input for button down\r\n    unsafe { SendInput(&[input], std::mem::size_of::<INPUT>() as i32) };\r\n\r\n    Ok(())\r\n}\r\n\r\npub fn left_mouse_up() -> Result<(), windows::core::Error> {\r\n    // Prepare a mouse input for left button up\r\n    let mouse_input = MOUSEINPUT {\r\n        dx: 0,\r\n        dy: 0,\r\n        mouseData: 0,\r\n        dwFlags: MOUSEEVENTF_LEFTUP,\r\n        time: 0,\r\n        dwExtraInfo: 0,\r\n    };\r\n\r\n    // Prepare an INPUT structure for the up event\r\n    let input = INPUT {\r\n        r#type: INPUT_MOUSE,\r\n        Anonymous: INPUT_0 { mi: mouse_input },\r\n    };\r\n\r\n    // Send the input for button up\r\n    unsafe { SendInput(&[input], std::mem::size_of::<INPUT>() as i32) };\r\n\r\n    Ok(())\r\n}\r\n\r\n#[allow(dead_code)]\r\npub fn left_click() -> Result<(), windows::core::Error> {\r\n    left_mouse_down()?;\r\n    left_mouse_up()?;\r\n    Ok(())\r\n}\r\n\r\npub fn right_mouse_down() -> Result<(), windows::core::Error> {\r\n    // Prepare a mouse input for right button down\r\n    let mouse_input = MOUSEINPUT {\r\n        dx: 0,\r\n        dy: 0,\r\n        mouseData: 0,\r\n        dwFlags: MOUSEEVENTF_RIGHTDOWN,\r\n        time: 0,\r\n        dwExtraInfo: 0,\r\n    };\r\n\r\n    // Prepare an INPUT structure for the down event\r\n    let input = INPUT {\r\n        r#type: INPUT_MOUSE,\r\n        Anonymous: INPUT_0 { mi: mouse_input },\r\n    };\r\n\r\n    // Send the input for button down\r\n    unsafe { SendInput(&[input], std::mem::size_of::<INPUT>() as i32) };\r\n\r\n    Ok(())\r\n}\r\n\r\npub fn right_mouse_up() -> Result<(), windows::core::Error> {\r\n    // Prepare a mouse input for right button up\r\n    let mouse_input = MOUSEINPUT {\r\n        dx: 0,\r\n        dy: 0,\r\n        mouseData: 0,\r\n        dwFlags: MOUSEEVENTF_RIGHTUP,\r\n        time: 0,\r\n        dwExtraInfo: 0,\r\n    };\r\n\r\n    // Prepare an INPUT structure for the up event\r\n    let input = INPUT {\r\n        r#type: INPUT_MOUSE,\r\n        Anonymous: INPUT_0 { mi: mouse_input },\r\n    };\r\n\r\n    // Send the input for button up\r\n    unsafe { SendInput(&[input], std::mem::size_of::<INPUT>() as i32) };\r\n\r\n    Ok(())\r\n}\r\n\r\n// Constants\r\nconst INPUT_KEYBOARD: u32 = 1;\r\nconst VK_F23: u16 = 0x86;\r\nconst KEYEVENTF_KEYUP: u32 = 0x0002;\r\n\r\npub fn press_f23_key() -> Result<(), windows::core::Error> {\r\n    let keyboard_input = KEYBDINPUT {\r\n        wVk: VIRTUAL_KEY(VK_F23),\r\n        wScan: 0,\r\n        dwFlags: KEYBD_EVENT_FLAGS(0),\r\n        time: 0,\r\n        dwExtraInfo: 0,\r\n    };\r\n\r\n    let input = INPUT {\r\n        r#type: INPUT_TYPE(INPUT_KEYBOARD),\r\n        Anonymous: INPUT_0 { ki: keyboard_input },\r\n    };\r\n\r\n    unsafe { SendInput(&[input], std::mem::size_of::<INPUT>() as i32) };\r\n\r\n    Ok(())\r\n}\r\n\r\npub fn release_f23_key() -> Result<(), windows::core::Error> {\r\n    let keyboard_input = KEYBDINPUT {\r\n        wVk: VIRTUAL_KEY(VK_F23),\r\n        wScan: 0,\r\n        dwFlags: KEYBD_EVENT_FLAGS(KEYEVENTF_KEYUP),\r\n        time: 0,\r\n        dwExtraInfo: 0,\r\n    };\r\n\r\n    let input = INPUT {\r\n        r#type: INPUT_TYPE(INPUT_KEYBOARD),\r\n        Anonymous: INPUT_0 { ki: keyboard_input },\r\n    };\r\n\r\n    unsafe { SendInput(&[input], std::mem::size_of::<INPUT>() as i32) };\r\n\r\n    Ok(())\r\n}\r\n\r\npub fn scroll_wheel(scale: f32) -> Result<(), windows::core::Error> {\r\n    let mouse_input = MOUSEINPUT {\r\n        dx: 0,\r\n        dy: 0,\r\n        mouseData: (WHEEL_DELTA as f32 * scale) as i32 as u32, // https://github.com/microsoft/windows-rs/issues/2708\r\n        dwFlags: MOUSEEVENTF_WHEEL,\r\n        time: 0,\r\n        dwExtraInfo: 0,\r\n    };\r\n\r\n    let input = INPUT {\r\n        r#type: INPUT_MOUSE,\r\n        Anonymous: INPUT_0 { mi: mouse_input },\r\n    };\r\n\r\n    unsafe { SendInput(&[input], std::mem::size_of::<INPUT>() as i32) };\r\n\r\n    Ok(())\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\window_swap_tool\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_window_swap_tool\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\ncursor_hero_window_swap_tool_types = { workspace = true }\r\ncursor_hero_toolbelt_types = { workspace = true }\r\ncursor_hero_tools = { workspace = true }\r\nleafwing-input-manager = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\xelu_prompts\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_xelu_prompts\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\nleafwing-input-manager = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\version\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_version\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\winutils\\src\\win_process.rs\r\n\r\n````rust\r\nuse crate::win_errors::*;\r\nuse windows::core::PWSTR;\r\nuse windows::Win32::Foundation::CloseHandle;\r\nuse windows::Win32::Foundation::HANDLE;\r\nuse windows::Win32::System::Diagnostics::ToolHelp::CreateToolhelp32Snapshot;\r\nuse windows::Win32::System::Diagnostics::ToolHelp::Process32FirstW;\r\nuse windows::Win32::System::Diagnostics::ToolHelp::Process32NextW;\r\nuse windows::Win32::System::Diagnostics::ToolHelp::PROCESSENTRY32W;\r\nuse windows::Win32::System::Diagnostics::ToolHelp::TH32CS_SNAPPROCESS;\r\nuse windows::Win32::System::Threading::OpenProcess;\r\nuse windows::Win32::System::Threading::QueryFullProcessImageNameW;\r\nuse windows::Win32::System::Threading::PROCESS_NAME_FORMAT;\r\nuse windows::Win32::System::Threading::PROCESS_QUERY_INFORMATION;\r\n\r\npub struct ProcessIterator {\r\n    snapshot: HANDLE,\r\n    process: PROCESSENTRY32W,\r\n    first_done: bool,\r\n}\r\n\r\nimpl ProcessIterator {\r\n    pub fn new() -> Result<Self> {\r\n        unsafe {\r\n            let snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0)?;\r\n            Ok(ProcessIterator {\r\n                snapshot,\r\n                process: PROCESSENTRY32W::default(),\r\n                first_done: false,\r\n            })\r\n        }\r\n    }\r\n}\r\n\r\nimpl Iterator for ProcessIterator {\r\n    type Item = PROCESSENTRY32W;\r\n\r\n    fn next(&mut self) -> Option<Self::Item> {\r\n        unsafe {\r\n            self.process.dwSize = std::mem::size_of::<PROCESSENTRY32W>() as u32;\r\n            if !self.first_done {\r\n                self.first_done = true;\r\n                match Process32FirstW(self.snapshot, &mut self.process) {\r\n                    Ok(()) => Some(self.process),\r\n                    Err(e) => {\r\n                        eprintln!(\"Failed to get first process: {:?}\", e);\r\n                        None\r\n                    }\r\n                }\r\n            } else {\r\n                match Process32NextW(self.snapshot, &mut self.process) {\r\n                    Ok(()) => Some(self.process),\r\n                    Err(e) => {\r\n                        if e.message() == \"There are no more files.\" {\r\n                            return None;\r\n                        }\r\n                        eprintln!(\"Failed to get next process: {:?}\", e);\r\n                        None\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nimpl Drop for ProcessIterator {\r\n    fn drop(&mut self) {\r\n        unsafe {\r\n            if let Err(e) = CloseHandle(self.snapshot) {\r\n                eprintln!(\"Failed to close snapshot: {:?}\", e);\r\n            }\r\n        };\r\n    }\r\n}\r\n\r\npub fn get_process_full_name(process_id: u32) -> Result<String> {\r\n    unsafe {\r\n        let process_handle: HANDLE = OpenProcess(PROCESS_QUERY_INFORMATION, false, process_id)?;\r\n        let result = (|| {\r\n            if process_handle.is_invalid() {\r\n                eprintln!(\"Failed to open process handle\");\r\n                return Err(windows::core::Error::from_win32());\r\n            }\r\n\r\n            let mut buffer: Vec<u16> = Vec::with_capacity(512);\r\n            let mut buffer_size = buffer.capacity() as u32;\r\n            let full_name_pwstr = PWSTR(buffer.as_mut_ptr());\r\n\r\n            QueryFullProcessImageNameW(\r\n                process_handle,\r\n                PROCESS_NAME_FORMAT(0),\r\n                full_name_pwstr,\r\n                &mut buffer_size,\r\n            )?;\r\n            buffer.set_len(buffer_size as usize);\r\n\r\n            Ok(String::from_utf16_lossy(&buffer))\r\n        })();\r\n        if let Err(e) = CloseHandle(process_handle) {\r\n            eprintln!(\"Failed to close process handle: {:?}\", e);\r\n        }\r\n        Ok(result?)\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\templates\\patterns\\new_plugin_with_types\\Cargo.toml\r\n\r\n````toml\r\n{{before_first_workspace_dependency}}\r\ncursor_hero_{{crate_name}}_types = { path = \"./crates/{{crate_name}}_types\" }\r\ncursor_hero_{{crate_name}} = { path = \"./crates/{{crate_name}}\" }\r\n{{first_workspace_dependency_onwards}}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui_inspector_types\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_ui_inspector_types\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\ncursor_hero_ui_automation_types = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\use cases\\asset picking.md\r\n\r\n````markdown\r\nI have some folders in my documents containing game sound effects.\r\nIt's a pain to preview them in windows.\r\n\r\nI should make an environment that lets me browse the files and preview them by walking over them.\r\nHit a to play the sound again.\r\n\r\nSend the sound to the game assets folder.\r\nOpen the sound in audacity.\r\nInternal sound editor?\r\nSFXR integration?\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\templates\\patterns\\new_tool\\crates\\{{crate_name}}_tool\\src\\{{crate_name}}_tool_populate_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse cursor_hero_{{crate_name}}_tool_types::prelude::*;\r\nuse cursor_hero_toolbelt_types::prelude::*;\r\nuse cursor_hero_tools::tool_spawning::ToolSpawnConfig;\r\n\r\npub struct {{crate_name_pascal}}ToolPopulatePlugin;\r\n\r\nimpl Plugin for {{crate_name_pascal}}ToolPopulatePlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Update, handle_toolbelt_events);\r\n    }\r\n}\r\n\r\nfn handle_toolbelt_events(\r\n    mut commands: Commands,\r\n    asset_server: Res<AssetServer>,\r\n    mut reader: EventReader<PopulateToolbeltEvent>,\r\n) {\r\n    for event in reader.read() {\r\n        let PopulateToolbeltEvent {\r\n            loadout: ToolbeltLoadout::WindowPosition,\r\n            ..\r\n        } = event\r\n        else {\r\n            continue;\r\n        };\r\n        ToolSpawnConfig::<_, {{crate_name_pascal}}ToolAction>::new(\r\n            {{crate_name_pascal}}Tool::default(),\r\n            event.id,\r\n            event,\r\n        )\r\n        .with_src_path(file!().into())\r\n        .guess_name(file!())\r\n        .guess_image(file!(), &asset_server, \"webp\")\r\n        .with_description(\"REPLACE THIS DESCRIPTION!!!\")\r\n        .spawn(&mut commands);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\window_swap_tool_types\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_window_swap_tool_types\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\nleafwing-input-manager = { workspace = true }\r\nbevy-inspector-egui = { workspace = true }\r\ncursor_hero_toolbelt_types = { workspace = true }\r\ncursor_hero_input = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\worker\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_worker\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\ncursor_hero_worker_types = { workspace = true }\r\ncrossbeam-channel = { workspace = true }\r\ntokio = {workspace = true}\r\nwindows = { workspace = true, features = [\r\n    \"Win32_Foundation\",\r\n    \"Win32_System_Com\",\r\n] }\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\window_position\\src\\lib.rs\r\n\r\n````rust\r\npub mod window_position_command_plugin;\r\npub mod window_position_loadout_switcher_tool_plugin;\r\npub mod window_position_plugin;\r\npub mod window_position_tool_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::window_position_plugin::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\use cases\\intellisense.md\r\n\r\n````markdown\r\nwhen prompting for suggestions in a rust file, the imports may be using\r\n\r\nuse whatever_types::prelude::*;\r\n\r\nit should be a farily simple operation to materialize a list of all the types that are now present.\r\nLanguage server integration with the prompting mechanism.\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\voice_to_text\\src\\voice_to_text_button_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse bevy_xpbd_2d::prelude::*;\r\nuse cursor_hero_environment_types::prelude::*;\r\nuse cursor_hero_math::prelude::Lerp;\r\nuse cursor_hero_cursor_types::prelude::*;\r\nuse cursor_hero_voice_to_text_types::prelude::*;\r\n\r\npub struct VoiceToTextButtonPlugin;\r\n\r\nimpl Plugin for VoiceToTextButtonPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Update, populate_new_host_environments);\r\n        app.add_systems(Update, update_visuals);\r\n        app.add_systems(Update, status_button_click);\r\n        app.add_systems(Update, vscode_button_click);\r\n        app.add_systems(Update, handle_vscode_events);\r\n    }\r\n}\r\n\r\nfn populate_new_host_environments(\r\n    mut commands: Commands,\r\n    mut environment_events: EventReader<PopulateEnvironmentEvent>,\r\n    environment_query: Query<(), With<HostEnvironment>>,\r\n    asset_server: Res<AssetServer>,\r\n) {\r\n    for event in environment_events.read() {\r\n        if !environment_query.contains(event.environment_id) {\r\n            continue;\r\n        }\r\n        let environment_id = event.environment_id;\r\n        info!(\"Adding button to new host environment {:?}\", environment_id);\r\n        commands.entity(environment_id).with_children(|parent| {\r\n            parent\r\n                .spawn((\r\n                    VoiceToTextStatusButton::default(),\r\n                    Name::new(\"Voice2Text Button\"),\r\n                    SpriteBundle {\r\n                        sprite: Sprite {\r\n                            custom_size: Some(Vec2::new(200.0, 100.0)),\r\n                            color: Color::PURPLE,\r\n                            ..default()\r\n                        },\r\n                        transform: Transform::from_translation(Vec3::new(\r\n                            1920.0 / 2.0 + 600.0,\r\n                            -1080.0 - 200.0,\r\n                            0.0,\r\n                        )),\r\n                        ..default()\r\n                    },\r\n                    Clickable,\r\n                    Hoverable,\r\n                    RigidBody::Static,\r\n                    Sensor,\r\n                    Collider::cuboid(200.0, 100.0),\r\n                ))\r\n                .with_children(|parent| {\r\n                    parent.spawn((Text2dBundle {\r\n                        text: Text::from_section(\r\n                            \"Voice2Text Server Control\".to_string(),\r\n                            TextStyle {\r\n                                font: asset_server.load(\"fonts/FiraSans-Bold.ttf\"),\r\n                                font_size: 32.0,\r\n                                color: Color::WHITE,\r\n                            },\r\n                        )\r\n                        .with_alignment(TextAlignment::Center),\r\n                        transform: Transform::from_xyz(0.0, 70.0, 1.0),\r\n                        ..default()\r\n                    },));\r\n                });\r\n            parent\r\n                .spawn((\r\n                    VoiceToTextVscodeButton::default(),\r\n                    Name::new(\"Voice2Text VSCode Button\"),\r\n                    SpriteBundle {\r\n                        sprite: Sprite {\r\n                            custom_size: Some(Vec2::new(200.0, 100.0)),\r\n                            color: Color::rgb(0.0, 0.6, 0.8),\r\n                            ..default()\r\n                        },\r\n                        transform: Transform::from_translation(Vec3::new(\r\n                            1920.0 / 2.0 + 600.0,\r\n                            -1080.0 - 350.0,\r\n                            0.0,\r\n                        )),\r\n                        ..default()\r\n                    },\r\n                    Clickable,\r\n                    Hoverable,\r\n                    RigidBody::Static,\r\n                    Sensor,\r\n                    Collider::cuboid(200.0, 100.0),\r\n                ))\r\n                .with_children(|parent| {\r\n                    parent.spawn((Text2dBundle {\r\n                        text: Text::from_section(\r\n                            \"open in vscode\".to_string(),\r\n                            TextStyle {\r\n                                font: asset_server.load(\"fonts/FiraSans-Bold.ttf\"),\r\n                                font_size: 32.0,\r\n                                color: Color::WHITE,\r\n                            },\r\n                        )\r\n                        .with_alignment(TextAlignment::Center),\r\n                        transform: Transform::from_xyz(0.0, 0.0, 1.0),\r\n                        ..default()\r\n                    },));\r\n                });\r\n        });\r\n    }\r\n}\r\n\r\nfn update_visuals(\r\n    mut events: EventReader<VoiceToTextStatusEvent>,\r\n    mut button_query: Query<(&mut Sprite, &Children, &mut VoiceToTextStatusButton)>,\r\n    mut button_text_query: Query<&mut Text>,\r\n) {\r\n    for event in events.read() {\r\n        let VoiceToTextStatusEvent::Changed {\r\n            new_status: status, ..\r\n        } = event;\r\n        debug!(\r\n            \"Updating VoiceToText Server Control visuals to {:?}\",\r\n            status\r\n        );\r\n        for button in button_query.iter_mut() {\r\n            let (mut button_sprite, button_children, mut button) = button;\r\n            button.visual_state = match button.visual_state {\r\n                VoiceToTextStatusButtonVisualState::Default { .. } => {\r\n                    VoiceToTextStatusButtonVisualState::Default {\r\n                        status: status.clone(),\r\n                    }\r\n                }\r\n                VoiceToTextStatusButtonVisualState::Hovered { .. } => {\r\n                    VoiceToTextStatusButtonVisualState::Hovered {\r\n                        status: status.clone(),\r\n                    }\r\n                }\r\n                VoiceToTextStatusButtonVisualState::Pressed { .. } => {\r\n                    VoiceToTextStatusButtonVisualState::Pressed {\r\n                        status: status.clone(),\r\n                    }\r\n                }\r\n            };\r\n            match status {\r\n                VoiceToTextStatus::Alive { .. } => {\r\n                    button_sprite.color = Color::GREEN;\r\n                }\r\n                VoiceToTextStatus::AliveButWeDontKnowTheApiKey => {\r\n                    button_sprite.color = Color::ORANGE_RED;\r\n                }\r\n                VoiceToTextStatus::Dead => {\r\n                    button_sprite.color = Color::RED;\r\n                }\r\n                VoiceToTextStatus::Unknown | VoiceToTextStatus::UnknownWithCachedApiKey { .. } => {\r\n                    button_sprite.color = Color::PURPLE;\r\n                }\r\n                VoiceToTextStatus::Starting {\r\n                    instant, timeout, ..\r\n                } => {\r\n                    button_sprite.color = Color::YELLOW\r\n                        * (1.0, 0.1).lerp(instant.elapsed().as_secs_f32() / timeout.as_secs_f32());\r\n                }\r\n            }\r\n            for child in button_children.iter() {\r\n                if let Ok(mut text) = button_text_query.get_mut(*child) {\r\n                    match status {\r\n                        VoiceToTextStatus::Alive { .. } => {\r\n                            text.sections[0].value =\r\n                                \"VoiceToText Server Control (Alive)\".to_string();\r\n                        }\r\n                        VoiceToTextStatus::AliveButWeDontKnowTheApiKey => {\r\n                            text.sections[0].value =\r\n                                \"VoiceToText Server Control (Alive, but we don't know the API key)\"\r\n                                    .to_string();\r\n                        }\r\n                        VoiceToTextStatus::Dead => {\r\n                            text.sections[0].value =\r\n                                \"VoiceToText Server Control (Dead)\".to_string();\r\n                        }\r\n                        VoiceToTextStatus::Unknown => {\r\n                            text.sections[0].value =\r\n                                \"VoiceToText Server Control (Unknown)\".to_string();\r\n                        }\r\n                        VoiceToTextStatus::UnknownWithCachedApiKey { .. } => {\r\n                            text.sections[0].value =\r\n                                \"VoiceToText Server Control (Unknown, api key present)\".to_string();\r\n                        }\r\n                        VoiceToTextStatus::Starting { instant, .. } => {\r\n                            text.sections[0].value = format!(\r\n                                \"VoiceToText Server Control (Starting {}s ago)\",\r\n                                instant.elapsed().as_secs()\r\n                            );\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    for button in button_query.iter_mut() {\r\n        let (mut sprite, children, button) = button;\r\n        // if the visual state status is starting, update the text to show the time elapsed\r\n        let (VoiceToTextStatusButtonVisualState::Default {\r\n            status: VoiceToTextStatus::Starting {\r\n                instant, timeout, ..\r\n            },\r\n        }\r\n        | VoiceToTextStatusButtonVisualState::Hovered {\r\n            status: VoiceToTextStatus::Starting {\r\n                instant, timeout, ..\r\n            },\r\n        }\r\n        | VoiceToTextStatusButtonVisualState::Pressed {\r\n            status: VoiceToTextStatus::Starting {\r\n                instant, timeout, ..\r\n            },\r\n        }) = button.visual_state\r\n        else {\r\n            continue;\r\n        };\r\n        sprite.color = Color::YELLOW\r\n            * (1.0, 0.1).lerp(instant.elapsed().as_secs_f32() / timeout.as_secs_f32());\r\n        for child in children.iter() {\r\n            if let Ok(mut text) = button_text_query.get_mut(*child) {\r\n                text.sections[0].value = format!(\r\n                    \"VoiceToText Server Control (Starting {}s ago)\",\r\n                    instant.elapsed().as_secs()\r\n                );\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfn status_button_click(\r\n    mut click_events: EventReader<ClickEvent>,\r\n    button_query: Query<&VoiceToTextStatusButton>,\r\n    mut command_events: EventWriter<VoiceToTextCommandEvent>,\r\n) {\r\n    for event in click_events.read() {\r\n        let ClickEvent::Clicked {\r\n            target_id,\r\n            cursor_id: _,\r\n            way,\r\n        } = event\r\n        else {\r\n            continue;\r\n        };\r\n        if way != &Way::Left {\r\n            continue;\r\n        }\r\n        if let Ok(button) = button_query.get(*target_id) {\r\n            info!(\"VoiceToText Server Control clicked\");\r\n            // if the button visual status is alive, do nothing\r\n            match button.visual_state {\r\n                VoiceToTextStatusButtonVisualState::Default {\r\n                    status: VoiceToTextStatus::Alive { .. },\r\n                }\r\n                | VoiceToTextStatusButtonVisualState::Hovered {\r\n                    status: VoiceToTextStatus::Alive { .. },\r\n                }\r\n                | VoiceToTextStatusButtonVisualState::Pressed {\r\n                    status: VoiceToTextStatus::Alive { .. },\r\n                } => {\r\n                    warn!(\"VoiceToText Server Control is already alive\");\r\n                    continue;\r\n                }\r\n                _ => {}\r\n            }\r\n            let event = VoiceToTextCommandEvent::Startup;\r\n            debug!(\"Sending event {:?}\", event);\r\n            command_events.send(event);\r\n        }\r\n    }\r\n}\r\n\r\nfn vscode_button_click(\r\n    mut click_events: EventReader<ClickEvent>,\r\n    button_query: Query<&VoiceToTextVscodeButton>,\r\n    mut vscode_events: EventWriter<VoiceToTextVscodeEvent>,\r\n) {\r\n    for event in click_events.read() {\r\n        let ClickEvent::Clicked {\r\n            target_id,\r\n            cursor_id: _,\r\n            way,\r\n        } = event\r\n        else {\r\n            continue;\r\n        };\r\n        if way != &Way::Left {\r\n            continue;\r\n        }\r\n        if button_query.get(*target_id).is_ok() {\r\n            info!(\"VoiceToText vscode clicked\");\r\n            let event = VoiceToTextVscodeEvent::Startup;\r\n            debug!(\"Sending event {:?}\", event);\r\n            vscode_events.send(event);\r\n        }\r\n    }\r\n}\r\n\r\nfn handle_vscode_events(mut vscode_events: EventReader<VoiceToTextVscodeEvent>) {\r\n    let should_start = vscode_events\r\n        .read()\r\n        .any(|event| matches!(event, VoiceToTextVscodeEvent::Startup));\r\n    if should_start {\r\n        info!(\"Opening vscode\");\r\n        if let Err(e) = crate::voice_to_text::start_vscode() {\r\n            error!(\"Failed to start vscode: {:?}\", e);\r\n        }\r\n    }\r\n    vscode_events.clear();\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\window_swap_tool\\src\\window_swap_tool_tick_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse cursor_hero_WindowSwap_tool_types::prelude::*;\r\nuse cursor_hero_toolbelt_types::prelude::*;\r\nuse leafwing_input_manager::prelude::*;\r\n\r\npub struct WindowSwapToolTickPlugin;\r\n\r\nimpl Plugin for WindowSwapToolTickPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_plugins(InputManagerPlugin::<WindowSwapToolAction>::default());\r\n        app.add_systems(Update, tick);\r\n    }\r\n}\r\n\r\nfn tick(\r\n    tool_query: Query<(&ActionState<WindowSwapToolAction>, &WindowSwapTool), With<ActiveTool>>,\r\n) {\r\n    for tool in tool_query.iter() {\r\n        let (tool_actions, tool) = tool;\r\n        if !tool_actions.pressed(WindowSwapToolAction::Use) {\r\n            continue;\r\n        }\r\n        info!(\"WindowSwapTool used!\");\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\voice_to_text\\src\\voice_to_text_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse cursor_hero_voice_to_text_types::voice_to_text_types::VoiceToTextStatus;\r\n\r\nuse crate::voice_to_text_button_plugin::VoiceToTextButtonPlugin;\r\nuse crate::voice_to_text_ping_plugin::VoiceToTextPingPlugin;\r\nuse crate::voice_to_text_worker_plugin::VoiceToTextWorkerPlugin;\r\n\r\npub struct VoiceToTextPlugin;\r\n\r\nimpl Plugin for VoiceToTextPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.init_resource::<VoiceToTextStatus>();\r\n        app.add_plugins(VoiceToTextButtonPlugin);\r\n        app.add_plugins(VoiceToTextPingPlugin);\r\n        app.add_plugins(VoiceToTextWorkerPlugin);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\templates\\patterns\\new_tool\\__pattern__.py\r\n\r\n````py\r\ndef gather_global_variables() -> dict[str,str]:\r\n    crate_name = input(\"crate_name\")\r\n    assert crate_name, \"crate_name is required\"\r\n    crate_name_pascal = pascal(crate_name)\r\n    assert not crate_name.endswith(\"tool\")\r\n    return {\r\n        \"crate_name\": crate_name,\r\n        \"crate_name_pascal\": crate_name_pascal,\r\n    }\r\n\r\ndef pascal(snake_string: str) -> str:\r\n    return ''.join(word.capitalize() for word in snake_string.split('_'))\r\n\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\window_position_types\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_window_position_types\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\ncursor_hero_math = {workspace = true}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui_watcher\\src\\ui_watcher_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse cursor_hero_character_types::prelude::MainCharacter;\r\nuse cursor_hero_environment_types::environment_types::EnvironmentTracker;\r\nuse cursor_hero_memory_types::prelude::get_persist_file;\r\nuse cursor_hero_memory_types::prelude::MemoryConfig;\r\nuse cursor_hero_memory_types::prelude::Usage;\r\nuse cursor_hero_observation_types::observation_types::SomethingObservableHappenedEvent;\r\nuse cursor_hero_ui_automation::prelude::take_snapshot;\r\nuse cursor_hero_ui_watcher_types::ui_watcher_types::GameboundUIWatcherMessage;\r\nuse cursor_hero_ui_watcher_types::ui_watcher_types::ThreadboundUIWatcherMessage;\r\nuse cursor_hero_worker::prelude::anyhow::Result;\r\nuse cursor_hero_worker::prelude::Sender;\r\nuse cursor_hero_worker::prelude::WorkerConfig;\r\nuse cursor_hero_worker::prelude::WorkerPlugin;\r\nuse std::io::Write;\r\n\r\npub struct UiWatcherPlugin;\r\n\r\nimpl Plugin for UiWatcherPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_plugins(WorkerPlugin {\r\n            config: WorkerConfig::<ThreadboundUIWatcherMessage, GameboundUIWatcherMessage, ()> {\r\n                name: \"ui watcher\".to_string(),\r\n                handle_threadbound_message,\r\n                ..default()\r\n            },\r\n        });\r\n        app.add_systems(Update, handle_gamebound_messages);\r\n        app.add_systems(Update, trigger_gather_info);\r\n    }\r\n}\r\n\r\nfn handle_threadbound_message(\r\n    msg: &ThreadboundUIWatcherMessage,\r\n    reply_tx: &Sender<GameboundUIWatcherMessage>,\r\n    _state: &mut (),\r\n) -> Result<()> {\r\n    match msg {\r\n        ThreadboundUIWatcherMessage::TakeSnapshot => {\r\n            let snapshot = take_snapshot()?;\r\n            let msg = GameboundUIWatcherMessage::Snapshot(snapshot);\r\n            // println!(\"Sending {:?}\", msg);\r\n            reply_tx.send(msg)?;\r\n        }\r\n    }\r\n\r\n    Ok(())\r\n}\r\n\r\nfn handle_gamebound_messages(\r\n    memory_config: Res<MemoryConfig>,\r\n    mut gamebound_events: EventReader<GameboundUIWatcherMessage>,\r\n    mut observation_events: EventWriter<SomethingObservableHappenedEvent>,\r\n    character_query: Query<&EnvironmentTracker, With<MainCharacter>>,\r\n) {\r\n    if gamebound_events.is_empty() {\r\n        return;\r\n    }\r\n    let environment_id = character_query.get_single().ok().map(|c| c.environment_id);\r\n    for msg in gamebound_events.read() {\r\n        let (msg_kind, GameboundUIWatcherMessage::Snapshot(snapshot)) = (\"Snapshot\", msg);\r\n        debug!(\"Received message {}\", msg_kind);\r\n\r\n        observation_events.send(SomethingObservableHappenedEvent::UISnapshot {\r\n            snapshot: snapshot.clone(),\r\n            environment_id,\r\n        });\r\n\r\n        match get_persist_file(\r\n            memory_config.as_ref(),\r\n            \"results.txt\",\r\n            Usage::Persist,\r\n        ) {\r\n            Ok(mut file) => {\r\n                if let Err(e) = file.write_all(format!(\"{:#?}\", snapshot).as_bytes()) {\r\n                    error!(\"Failed to write to file: {:?}\", e);\r\n                } else {\r\n                    info!(\"Wrote snapshot to file {:?}\", file);\r\n                }\r\n            }\r\n            Err(e) => {\r\n                error!(\"Failed to open file: {:?}\", e);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfn trigger_gather_info(\r\n    mut events: EventWriter<ThreadboundUIWatcherMessage>,\r\n    mut cooldown: Local<Option<Timer>>,\r\n    time: Res<Time>,\r\n) {\r\n    // handle cooldown\r\n    let Some(cooldown) = cooldown.as_mut() else {\r\n        cooldown.replace(Timer::from_seconds(1.0, TimerMode::Repeating));\r\n        return;\r\n    };\r\n    if !cooldown.tick(time.delta()).just_finished() {\r\n        return;\r\n    }\r\n\r\n    // send event to worker\r\n    debug!(\"Triggering gather info\");\r\n    events.send(ThreadboundUIWatcherMessage::TakeSnapshot);\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\winutils\\src\\win_errors.rs\r\n\r\n````rust\r\nuse std::rc::Rc;\r\nuse std::string::FromUtf16Error;\r\nuse widestring::error::ContainsNul;\r\nuse windows::Win32::Foundation::BOOL;\r\n\r\n#[derive(Debug, Clone)]\r\npub enum Error {\r\n    Windows(windows::core::Error),\r\n    WideString(ContainsNul<u16>),\r\n    FromUtf16Error,\r\n    Described(Rc<Error>, String),\r\n    ImageContainerNotBigEnough,\r\n    Other(Rc<dyn std::error::Error>),\r\n}\r\nimpl std::fmt::Display for Error {\r\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\r\n        match self {\r\n            Error::Windows(e) => write!(f, \"Windows error: {}\", e.message()),\r\n            Error::WideString(e) => write!(f, \"Wide string error: {}\", e),\r\n            Error::FromUtf16Error => write!(f, \"FromUtf16Error\"),\r\n            Error::Described(e, description) => write!(f, \"{}: {}\", e, description),\r\n            Error::ImageContainerNotBigEnough => write!(f, \"Image container not big enough\"),\r\n            Error::Other(e) => write!(f, \"(other) {}\", e),\r\n        }\r\n    }\r\n}\r\nimpl std::error::Error for Error {}\r\nimpl Error {\r\n    pub fn from_win32() -> Self {\r\n        Error::Windows(windows::core::Error::from_win32())\r\n    }\r\n    pub fn with_description(self, description: String) -> Self {\r\n        Error::Described(Rc::new(self), description)\r\n    }\r\n}\r\nimpl From<windows::core::Error> for Error {\r\n    fn from(e: windows::core::Error) -> Self {\r\n        Error::Windows(e)\r\n    }\r\n}\r\nimpl From<ContainsNul<u16>> for Error {\r\n    fn from(e: ContainsNul<u16>) -> Self {\r\n        Error::WideString(e)\r\n    }\r\n}\r\nimpl From<FromUtf16Error> for Error {\r\n    fn from(_e: FromUtf16Error) -> Self {\r\n        Error::FromUtf16Error\r\n    }\r\n}\r\n\r\npub type Result<T> = std::result::Result<T, Error>;\r\n\r\npub trait WithDescription<T> {\r\n    fn with_description(self, description: String) -> Result<T>;\r\n}\r\nimpl<T> WithDescription<T> for windows::core::Result<T> {\r\n    fn with_description(self, description: String) -> Result<T> {\r\n        self.map_err(|e| Error::Windows(e).with_description(description))\r\n    }\r\n}\r\n\r\npub trait OkWithDescription<T> {\r\n    fn ok_with_description(self, description: String) -> Result<T>;\r\n}\r\nimpl OkWithDescription<()> for BOOL {\r\n    fn ok_with_description(self, description: String) -> Result<()> {\r\n        self.ok()\r\n            .map_err(|e| Error::Windows(e).with_description(description))\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\winutils\\examples\\app_icons_example.rs\r\n\r\n````rust\r\nuse std::rc::Rc;\r\n\r\nuse bevy::utils::HashSet;\r\nuse cursor_hero_winutils::win_errors::*;\r\nuse cursor_hero_winutils::win_icons::get_images_from_exe;\r\nuse cursor_hero_winutils::win_process::*;\r\nuse windows::core::PWSTR;\r\nuse windows::Win32::Foundation::E_ACCESSDENIED;\r\n\r\nfn main() -> Result<()> {\r\n    unsafe {\r\n        let process_iter = ProcessIterator::new()?;\r\n        let mut done = HashSet::new();\r\n        for mut process in process_iter {\r\n            let exe_name_pwstr = PWSTR(process.szExeFile.as_mut_ptr());\r\n            let exe_name = exe_name_pwstr.to_string()?;\r\n            let exe_path = match get_process_full_name(process.th32ProcessID) {\r\n                Ok(s) => s,\r\n                Err(e) => {\r\n                    if matches!(\r\n                        e,\r\n                        Error::Windows(ref e) if e.code() == E_ACCESSDENIED\r\n                    ) {\r\n                        continue;\r\n                    }\r\n                    eprintln!(\r\n                        \"Failed to get full process name for PID {:05} ({}): {:?}\",\r\n                        process.th32ProcessID, exe_name, e\r\n                    );\r\n                    continue;\r\n                }\r\n            };\r\n            if done.contains(&exe_path) {\r\n                continue;\r\n            }\r\n            done.insert(exe_path.clone());\r\n            let icons = get_images_from_exe(exe_path.as_str())?;\r\n            println!(\r\n                \"Process ID: {:05}, name: {}, icon count: {}\",\r\n                process.th32ProcessID,\r\n                exe_name,\r\n                icons.len()\r\n            );\r\n\r\n            if icons.is_empty() {\r\n                continue;\r\n            }\r\n\r\n            // write the image to target/app_icons/{exe_name}/{icon_index}.png\r\n            let mut path = std::path::PathBuf::from(\"target/app_icons\");\r\n            path.push(exe_name);\r\n            std::fs::create_dir_all(&path).map_err(|e| Error::Other(Rc::new(e)))?;\r\n            for (i, icon) in icons.iter().enumerate() {\r\n                let mut icon_path = path.clone();\r\n                icon_path.push(format!(\"{}.png\", i));\r\n                icon.save(icon_path).map_err(|e| Error::Other(Rc::new(e)))?;\r\n            }\r\n        }\r\n    }\r\n    Ok(())\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\window_position_types\\win_icons.rs\r\n\r\n````rust\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\templates\\patterns\\new_tool\\Cargo.toml\r\n\r\n````toml\r\n{{before_first_workspace_dependency}}\r\ncursor_hero_{{crate_name}}_tool = { path = \"./crates/{{crate_name}}_tool\" }\r\ncursor_hero_{{crate_name}}_tool_types = { path = \"./crates/{{crate_name}}_tool_types\" }\r\n{{first_workspace_dependency_onwards}}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\voice_to_text\\src\\voice_to_text_ping_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse bevy::utils::Instant;\r\nuse cursor_hero_voice_to_text_types::prelude::*;\r\n\r\npub struct VoiceToTextPingPlugin;\r\n\r\nimpl Plugin for VoiceToTextPingPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Update, periodic_ping);\r\n        app.add_systems(Update, handle_pong);\r\n        app.add_systems(Update, init_receiver_once_alive);\r\n    }\r\n}\r\n\r\nfn periodic_ping(\r\n    mut ping_events: EventWriter<VoiceToTextPingEvent>,\r\n    mut last_ping: Local<Option<Instant>>,\r\n) {\r\n    if let Some(instant) = *last_ping {\r\n        if instant.elapsed().as_secs() > 5 {\r\n            ping_events.send(VoiceToTextPingEvent::Ping);\r\n            *last_ping = Some(Instant::now());\r\n        }\r\n    } else {\r\n        ping_events.send(VoiceToTextPingEvent::Ping);\r\n        *last_ping = Some(Instant::now());\r\n    }\r\n}\r\n\r\nfn handle_pong(\r\n    mut ping_events: EventReader<VoiceToTextPingEvent>,\r\n    mut status_events: EventWriter<VoiceToTextStatusEvent>,\r\n    mut current_status: ResMut<VoiceToTextStatus>,\r\n) {\r\n    for event in ping_events.read() {\r\n        let VoiceToTextPingEvent::Pong { status: new_status } = event else {\r\n            continue;\r\n        };\r\n        // identify the new state based on the pong\r\n        // if the pong says dead and the current state is starting, only change to dead if the timeout has been exceeded\r\n        let new_status = match (&*current_status, new_status) {\r\n            (\r\n                VoiceToTextStatus::Starting {\r\n                    instant,\r\n                    timeout,\r\n                    api_key,\r\n                },\r\n                status,\r\n            ) => {\r\n                if let VoiceToTextStatus::Alive {\r\n                    api_key: other_api_key,\r\n                    listening,\r\n                } = status\r\n                {\r\n                    // Unlikely branch, but lets be safe\r\n                    if other_api_key != api_key {\r\n                        warn!(\"Received pong with Alive status with an api key different from the one we tracked when starting the program, overwriting api key\")\r\n                    }\r\n                    VoiceToTextStatus::Alive {\r\n                        api_key: other_api_key.clone(),\r\n                        listening: *listening,\r\n                    }\r\n                } else if *status == VoiceToTextStatus::AliveButWeDontKnowTheApiKey {\r\n                    // A server has responded to our ping, assume the API key is the one we tracked when we started the program\r\n                    VoiceToTextStatus::Alive {\r\n                        api_key: api_key.clone(),\r\n                        listening: false,\r\n                    }\r\n                } else if instant.elapsed() > *timeout {\r\n                    // Only accept the dead status if the timeout has been exceeded\r\n                    VoiceToTextStatus::Dead\r\n                } else {\r\n                    // Timeout not exceeded, keep the current status (starting)\r\n                    current_status.clone()\r\n                }\r\n            }\r\n            (VoiceToTextStatus::Alive { .. }, VoiceToTextStatus::AliveButWeDontKnowTheApiKey) => {\r\n                // Ping is alive, retain the api key\r\n                current_status.clone()\r\n            }\r\n            (\r\n                VoiceToTextStatus::UnknownWithCachedApiKey { api_key },\r\n                VoiceToTextStatus::AliveButWeDontKnowTheApiKey,\r\n            ) => {\r\n                // Ping is alive, use the cached api key\r\n                VoiceToTextStatus::Alive {\r\n                    api_key: api_key.clone(),\r\n                    listening: false,\r\n                }\r\n            }\r\n            (a, b) => {\r\n                debug!(\r\n                    \"Received pong with status {:?} but the current status is {:?}\",\r\n                    b, a\r\n                );\r\n                new_status.clone()\r\n            }\r\n        };\r\n\r\n        if *current_status != new_status {\r\n            let event = VoiceToTextStatusEvent::Changed {\r\n                old_status: current_status.clone(),\r\n                new_status: new_status.clone(),\r\n            };\r\n            debug!(\"Sending event {:?}\", event);\r\n            status_events.send(event);\r\n\r\n            *current_status = new_status;\r\n        }\r\n    }\r\n}\r\n\r\nfn init_receiver_once_alive(\r\n    mut command_events: EventWriter<VoiceToTextCommandEvent>,\r\n    mut status_events: EventReader<VoiceToTextStatusEvent>,\r\n) {\r\n    for event in status_events.read() {\r\n        let VoiceToTextStatusEvent::Changed {\r\n            new_status,\r\n            old_status,\r\n        } = event;\r\n        if !matches!(\r\n            old_status,\r\n            VoiceToTextStatus::Starting { .. } | VoiceToTextStatus::UnknownWithCachedApiKey { .. }\r\n        ) {\r\n            continue;\r\n        }\r\n        let VoiceToTextStatus::Alive { api_key, .. } = new_status else {\r\n            continue;\r\n        };\r\n        let event = VoiceToTextCommandEvent::ConnectReceiver {\r\n            api_key: api_key.clone(),\r\n        };\r\n        debug!(\"Now alive, sending event: {:?}\", event);\r\n        command_events.send(event);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\window_position\\src\\window_position_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n\r\nuse crate::window_position_command_plugin::WindowPositionCommandPlugin;\r\nuse crate::window_position_loadout_switcher_tool_plugin::WindowPositionLoadoutSwitcherToolPlugin;\r\nuse crate::window_position_tool_plugin::WindowPositionToolPlugin;\r\n\r\npub struct WindowPositionPlugin;\r\n\r\nimpl Plugin for WindowPositionPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_plugins(WindowPositionLoadoutSwitcherToolPlugin);\r\n        app.add_plugins(WindowPositionToolPlugin);\r\n        app.add_plugins(WindowPositionCommandPlugin);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\templates\\patterns\\new_tool\\crates\\plugins\\Cargo.toml\r\n\r\n````toml\r\n{{before_first_plugins_dependency}}\r\ncursor_hero_{{crate_name}}_tool = { workspace = true }\r\ncursor_hero_{{crate_name}}_tool_types = { workspace = true }\r\n{{first_plugins_dependency_onwards}}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\voice_to_text\\src\\voice_to_text.rs\r\n\r\n````rust\r\nuse bevy::log::debug;\r\nuse bevy::log::error;\r\nuse bevy::log::info;\r\nuse crossbeam_channel::Sender;\r\nuse cursor_hero_secret_types::secrets_types::SecretString;\r\nuse cursor_hero_voice_to_text_types::prelude::*;\r\nuse futures_util::stream::StreamExt;\r\nuse futures_util::SinkExt;\r\nuse rand::distributions::Alphanumeric;\r\nuse rand::Rng;\r\nuse reqwest::Client;\r\nuse std::error::Error;\r\nuse std::process::Command;\r\nuse tokio_tungstenite::connect_async;\r\nuse tokio_tungstenite::tungstenite::client::IntoClientRequest;\r\nuse tokio_tungstenite::tungstenite::http::header::AUTHORIZATION;\r\nuse tokio_tungstenite::tungstenite::http::HeaderValue;\r\nuse tokio_tungstenite::tungstenite::protocol::Message;\r\n\r\nuse crate::voice_to_text_worker_plugin::GameboundMessage;\r\n\r\npub(crate) const URL: &str = \"https://localhost:9127\";\r\n\r\npub(crate) async fn get_status() -> Result<VoiceToTextStatus, Box<dyn Error>> {\r\n    let client = Client::new();\r\n    match client.get(format!(\"{}/\", URL)).send().await {\r\n        Ok(res) => match res.status().is_success() {\r\n            true => Ok(VoiceToTextStatus::AliveButWeDontKnowTheApiKey),\r\n            false => Ok(VoiceToTextStatus::Dead),\r\n        },\r\n        Err(_) => Ok(VoiceToTextStatus::Dead),\r\n    }\r\n}\r\n\r\nfn generate_api_key(len: usize) -> SecretString {\r\n    let rng = rand::thread_rng();\r\n    let inner = rng\r\n        .sample_iter(&Alphanumeric)\r\n        .take(len)\r\n        .map(char::from)\r\n        .collect();\r\n    SecretString::new(inner)\r\n}\r\n\r\npub(crate) fn start() -> Result<SecretString, Box<dyn Error>> {\r\n    let port = 9127;\r\n    let api_key = generate_api_key(32);\r\n    match std::process::Command::new(\"wt\")\r\n        .args([\r\n            \"--window\",\r\n            \"0\",\r\n            \"--profile\",\r\n            \"PowerShell\",\r\n            \"--title\",\r\n            \"Voice2Text\",\r\n            \"--\",\r\n            \"pwsh\",\r\n            \"-Command\",\r\n            r\"cd D:\\Repos\\ml\\voice2text && conda activate whisperx && python .\\transcribe_hotkey_typer.py $env:port $env:api_key\",\r\n        ])\r\n        .env(\"port\", port.to_string())\r\n        .env(\"api_key\", api_key.expose_secret())\r\n        .spawn()\r\n    {\r\n        Ok(_) => Ok(api_key),\r\n        Err(e) => Err(Box::new(e)),\r\n    }\r\n}\r\n\r\npub(crate) fn start_vscode() -> Result<(), Box<dyn Error>> {\r\n    match Command::new(r\"C:\\Program Files\\Microsoft VS Code\\Code.exe\")\r\n        .args([r\"D:\\Repos\\ml\\voice2text\"])\r\n        .spawn()\r\n    {\r\n        Ok(_) => Ok(()),\r\n        Err(e) => Err(Box::new(e)),\r\n    }\r\n}\r\n\r\npub(crate) async fn set_listening(\r\n    listening: bool,\r\n    api_key: SecretString,\r\n) -> Result<(), Box<dyn Error>> {\r\n    let client = Client::new();\r\n    let endpoint = match listening {\r\n        true => format!(\"{}/start_listening\", URL),\r\n        false => format!(\"{}/stop_listening\", URL),\r\n    };\r\n    match client\r\n        .post(endpoint)\r\n        .header(reqwest::header::AUTHORIZATION, api_key.expose_secret())\r\n        .send()\r\n        .await\r\n    {\r\n        Ok(res) => match res.status().is_success() {\r\n            true => Ok(()),\r\n            false => Err(Box::new(std::io::Error::new(\r\n                std::io::ErrorKind::Other,\r\n                format!(\r\n                    \"Failed to set listening: {:?}\",\r\n                    match res.text().await {\r\n                        Ok(text) => text,\r\n                        Err(e) =>\r\n                            format!(\"Failed to get response text during failure handler: {}\", e),\r\n                    }\r\n                ),\r\n            )))?,\r\n        },\r\n        Err(e) => Err(Box::new(e)),\r\n    }\r\n}\r\n\r\nuse serde::Deserialize;\r\n#[derive(Debug, Deserialize)]\r\nstruct TranscriptionResponse {\r\n    segments: Vec<Segment>,\r\n    // language: String,\r\n}\r\n\r\n#[derive(Debug, Deserialize)]\r\nstruct Segment {\r\n    text: String,\r\n    // start: f64,\r\n    // end: f64,\r\n}\r\n\r\npub(crate) async fn connect_receiver(\r\n    game_tx: Sender<GameboundMessage>,\r\n    api_key: SecretString,\r\n) -> Result<(), Box<dyn Error>> {\r\n    // Assuming the WebSocket endpoint is similar to HTTP but with ws(s) protocol\r\n    let url = format!(\"{URL}/results\").replace(\"http\", \"ws\");\r\n\r\n    // Add our auth header\r\n    let mut req = url.into_client_request()?;\r\n    let val = HeaderValue::from_str(api_key.expose_secret().as_str())?;\r\n    req.headers_mut().insert(AUTHORIZATION, val);\r\n\r\n    // Start worker to listen to responses without blocking the main thread\r\n    tokio::spawn(async move {\r\n        let (ws_stream, _) = match connect_async(req).await {\r\n            Ok(conn) => {\r\n                info!(\"Connected to WebSocket\");\r\n                conn\r\n            }\r\n            Err(e) => {\r\n                error!(\"Failed to connect to WebSocket: {:?}\", e);\r\n                return;\r\n            }\r\n        };\r\n\r\n        let (mut write, mut read) = ws_stream.split();\r\n        debug!(\"Starting keepalive thread\");\r\n        tokio::spawn(async move {\r\n            debug!(\"Keepalive thread started, entering main loop\");\r\n            loop {\r\n                tokio::time::sleep(tokio::time::Duration::from_secs(5)).await;\r\n                if let Err(e) = write.send(Message::text(\"keepalive\")).await {\r\n                    error!(\"Failed to send keepalive: {:?}\", e);\r\n                    break;\r\n                }\r\n            }\r\n        });\r\n\r\n        // Listening for messages\r\n        while let Some(message) = read.next().await {\r\n            match message {\r\n                Ok(msg) => {\r\n                    if let Message::Text(text) = msg {\r\n                        // Deserialize the JSON text into TranscriptionResponse\r\n                        debug!(\"Received message: {}\", text);\r\n                        match serde_json::from_str::<TranscriptionResponse>(&text) {\r\n                            Ok(transcription) => {\r\n                                // Concatenate the text of all segments\r\n                                let concatenated_text = transcription\r\n                                    .segments\r\n                                    .iter()\r\n                                    .map(|s| s.text.as_str())\r\n                                    .collect::<Vec<&str>>()\r\n                                    .join(\" \");\r\n                                let msg = GameboundMessage::TranscriptionReceived {\r\n                                    transcription: concatenated_text,\r\n                                };\r\n                                debug!(\"Sending transcription to game: {:?}\", msg);\r\n                                if let Err(e) = game_tx.send(msg) {\r\n                                    error!(\"Failed to send transcription to game: {:?}\", e);\r\n                                }\r\n                            }\r\n                            Err(e) => error!(\"Failed to deserialize message: {:?}\", e),\r\n                        }\r\n                    }\r\n                }\r\n                Err(e) => {\r\n                    error!(\"WebSocket error: {:?}\", e);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    });\r\n\r\n    Ok(())\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\window_position\\src\\window_position_command_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse cursor_hero_window_position_types::window_position_types::WindowPositionCommand;\r\n\r\npub struct WindowPositionCommandPlugin;\r\n\r\nimpl Plugin for WindowPositionCommandPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Update, handle_commands);\r\n    }\r\n}\r\n\r\nfn handle_commands(\r\n    mut command_queue: EventReader<WindowPositionCommand>,\r\n    mut window_query: Query<&mut Window>,\r\n) {\r\n    for command in command_queue.read() {\r\n        let Ok(window) = window_query.get_mut(command.window) else {\r\n            warn!(\"Window {:?} not found\", command.window);\r\n            continue;\r\n        };\r\n        debug!(\"Handling command {:?}\", command);\r\n        let mut window = window;\r\n        if let Some(position) = command.position {\r\n            window.position = position;\r\n        }\r\n        if let Some(resolution) = &command.resolution {\r\n            window.resolution = resolution.clone();\r\n        }\r\n        if let Some(mode) = command.mode {\r\n            window.mode = mode;\r\n        }\r\n        // only handle one command a tick\r\n        break;\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui_watcher\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_ui_watcher\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\ncursor_hero_ui_watcher_types = { workspace = true }\r\ncrossbeam-channel = { workspace = true }\r\ncursor_hero_ui_automation = { workspace = true }\r\ncursor_hero_environment_types = { workspace = true }\r\ncursor_hero_observation_types = { workspace = true }\r\ncursor_hero_memory_types = { workspace = true }\r\ncursor_hero_character_types = { workspace = true }\r\ncursor_hero_worker = { workspace = true }\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\templates\\patterns\\new_plugin_with_types\\crates\\{{crate_name}}_types\\src\\{{crate_name}}_types.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n\r\n#[derive(Component, Debug, Reflect)]\r\npub struct MyComponent;\r\n\r\n#[derive(Event, Debug, Reflect)]\r\npub enum MyEvent {\r\n    Guh,\r\n    Uh\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\voice_to_text_types\\src\\lib.rs\r\n\r\n````rust\r\n#![feature(trivial_bounds)]\r\npub mod voice_to_text_types;\r\npub mod voice_to_text_types_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::voice_to_text_types::*;\r\n    pub use crate::voice_to_text_types_plugin::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\templates\\patterns\\new_tool\\crates\\{{crate_name}}_tool_types\\src\\lib.rs\r\n\r\n````rust\r\npub mod {{crate_name}}_tool_types;\r\npub mod {{crate_name}}_tool_types_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::{{crate_name}}_tool_types::*;\r\n    pub use crate::{{crate_name}}_tool_types_plugin::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\todo.md\r\n\r\n````markdown\r\n# Current Priorities\r\n\r\n## Active\r\n\r\n- Fix properties not working\r\n- Finish calculator stub\r\n\r\n## Up Next\r\n\r\n\r\n\r\n## Grab Bag\r\n\r\n- UI Resolver for VSCode window\r\n- UI Resolver for a kanban board, move todo list to it. Mapping to GitHub project board?\r\n- UI Resolver for todo list, make it structured\r\n- UI Resolver for Task Manager\r\n- UI Resolver for qBitTorrent\r\n- UI Resolver for VPN\r\n- UI Resolver for Edge\r\n- UI Resolver for Windows Explorer; notes and files searchable? brick-per-file representation in game world\r\n- UI Resolver for mpv\r\n- UI Resolver for SyncPlay\r\n- UI Resolver for Discord\r\n- UI Resolver for Windows Terminal\r\n- move click tool to its own crate pair\r\n- click toggle inspector for game objects\r\n- rename plugin refactoring action - rename file snake case, rename plugin pascal case\r\n- fix r3 position cursor at title bar\r\n- emoji text in world and in egui test\r\n- add world representation of all our cursor_hero crates where clicking them will toggle their log level to warn\r\n  - button to set all scope to warn and all open tabs to trace\r\n- rustdoc_json to create buttons to toggle log level for individual crates from within the game, persisting changes by modifying the log plugin init code \r\n- window swap: swap the position of the game window with the window under the cursor\r\n- switch LLM to one that is better for programming and knows about VS Code.\r\n- Keyboard Tool D-Pad Chords for Arbitrary Letters\r\n- Understand why I can't use the app to hit its own close button\r\n\r\n- home and end buttons in keyboard tool\r\n\r\n- data brick - screenshot tool creates physics object cube that contains the data\r\n  - only show hover preview and only process clicks for ui elements that match a known data provider pattern\r\n  - agent can manipulate and observe the cube\r\n  - cube observations do not map to the inner info, apps may be summarized in a few lines with hints about what subdata can be extracted\r\n  - UI databrick - contains information extracted from UI Automation\r\n  - File databrick - contains file contents and file handle info (path, size, etc)\r\n  - Chat databrick - contains chat history\r\n  - brick observations shouldn't be retained from previous messages, only keep chat history / purge brick history? if the agent can only observe the bricks around it, and we create a brick to represent chat history, then we can have the agent manage its own context window by summarizing and discarding bricks. problem: how large is the context window? we need indicators. Not contained within, but referenced to be gathered later. \r\n\r\n\r\n- context teleport tool\r\n  - tab to place marker\r\n  - mouse1 to teleport cube to marker\r\n\r\n- camera tool\r\n  - f1 - env 1\r\n  - f2 - env 2\r\n  - 1 - teleport object to 1\r\n  - 2 - teleport object to 2\r\n\r\n\r\n- start menu button\r\n- button creates a window with icon, title, decorations\r\n- taskbar lists windows\r\n- \r\n- update tool plugin template\r\n\r\n- tree structure component that can render a tree structure following the flat-but-annotated style of the inspect.exe tree of the vscode file explorer\r\n- agent memory reset (gun?)\r\n  - points towards cursor\r\n  - projectile shoot\r\n  - sfx\r\n  - projectile hit\r\n  - sfx\r\n  - hitreg wipe memory\r\n- name labels above characters\r\n- character positions in observation\r\n  - snapshot at time for observation, or record ongoing activity?\r\n  - \"X walked by, 25s ago\"\r\n  - \"Y stopped moving at [12.0, 255.0], 5s ago\"\r\n\r\n- sfx when service comes online\r\n- better prompt history\r\n- vscode buffer observations\r\n- Onboarder startup button\r\n- Screen pause toggle button\r\n- add \"thinking\" bubble above agent head when request in flight\r\n\r\n- customizable launch params for the wt invocation to launch ollama and stuff in case people have different WSL distros than ubuntu\r\n  - restart memory, edit in game\r\n- ollama server documentation button to open the github\r\n- character selection room, displaying all the variants of the character using a closet that you scroll through the hangers that describe the situation in which each sprite is used, exploded view to show all variants / the sprite sheet\r\n- run animation\r\n\r\n- performance profiling (so I can close the browser tab I have open for the rust metrics lib)\r\n- reduce background CPU usage from 22% \ud83d\ude31 https://learn.microsoft.com/en-us/windows-hardware/test/wpt/introduction-to-wpr\r\n\r\n- switcher wheel to collect all switcher tools for predictable navigation\r\n  - gamepad rumble on hover\r\n  - sound effect on hover tool\r\n- fullscreen tool binding f11 to fullscreen toggle\r\n- set clippy rule to flag `unwrap` and `expect` usage\r\n- post to openai discord use-cases channel https://discord.com/channels/974519864045756446/1155775326253756456\r\n  - tag @abdubs (Alex)\r\n- window switcher tool; window wheel -> focus, teleport\r\n- Github releases in world\r\n- File browser in world\r\n- Voice input tool\r\n  - Push to talk\r\n  - Push to toggle talk\r\n  - Insert period\r\n  - Insert space\r\n  - Hit enter\r\n\r\n- interpreter agent that acts as \"middleware\" that will process user speech transcription to clean it up typos and other errors that can decrease model performance before it gets included in main agent observations\r\n- track recently played sounds and empower the user to adjust the volume of individual sounds and future sounds of the same class\r\n- sprint tool scales scroll speed\r\n\r\n- couple click tool with window/screen mouse position tool\r\n- make overlay logic stop when inspection tool disabled\r\n\r\n- add version number to binary as part of build\r\n\r\n- show tools which have conflicting keys in red\r\n- tool to focus the game window and maximize it on the monitors with dpad\r\n\r\n- jump tool - aimlock with right stick to jump to targets at varying distances\r\n\r\n- new tool tool\r\n  - bind: type \"plug\"\r\n  - bind: press tab\r\n  - bind: rename symbol refactor hotkey (Shift+F6)\r\n  - bind: voice2text\r\n  - bind: enter\r\n- new file tool\r\n  - bind: left click (on folder -> new file)\r\n  - bind: voice prompt with instructions on file name preference, include txt of tree output next to the cursor in the vscode file explorer\r\n  - bind: hit enter\r\n\r\n\r\nheuristics!\r\n\r\nadd a binding to the voice tool for hitting the enter button.Add a binding.for the Ctrl-S hotkey.add a hotkey to thefor inserting a new line.Add a camera tool to own the hotkey for fire.following the character.- tool selection wheel show on rstick click, left stick to pick item in the wheel - is the toolbelt a tool?\r\n- teleport tool - rstick in maps left stick to full screen coords. Full left stick places cursor as far left, across all screens, as possible\r\n- find way to overlay on top of other windows without drawing the screens\r\n- text buffer - a change-listenable history-queryable place to store text\r\n- d-pad keyboard navigation tool , arrow keys, wasd, hjkl\r\n- clipboard tool - keybind to push text buffer to system clipboard, keybind to pull from system clipboard to text buffer, keybind to send ctrl+v input\r\n- voice2text tool - hold to talk to transcribe your voice into the text buffer\r\n- annotation tool - keybind to append to a file (timestamp, cursor pos, element under cursor persistent id, text buffer)\r\n- cursor tool - mapping to shift to enable shift-clicking, mapping control to enable control clicking.Combinable with shift.\r\n- summarize tool - summarize the clicked element. north/south: summary length adjust. east/west: level of detail adjust\r\n- dump tool - poop emoji icon, dumps context of the current timestep to the text buffer. keybind to adjust detail\r\n- zoom tool - right trigger to control zoom\r\n- type tool - send keyboard inputs according to the text buffer\r\n- d-pad quick toggle tool system\r\n- timestamp marking tool - save to file with note\r\n- describe hovered element tool\r\n- llm inference for arbitrary string payloads\r\n- rebind hotkey tool that analyzes project for keybinding defaults in code and edits the code in place to change the default\r\n- todo tool that reads top 3 todo.md entries and top 3 git log into LLM to suggest the next thing to work on\r\n- TTS (glados)\r\n- more real time voice 2 text\r\n- indicator out of bounds when OBS is not recording / status lights for OBS\r\n- detect periods of waiting and replace progress spinners / cargo build logs / chatgpt still typing a response with a video from my watch later, my move in a chess game, a chess puzzle, an email -- predict the length of the time spinning to pick a thing to that will take that amount of time, \r\n- point at program and open the source code - mapping from program to disk location\r\n- automate bevy cloning and dependency update to point at local clones of the repos\r\n\r\n# use case\r\n\r\nselect multiple files from vscode, tool read the contents of those files and format in markdown code blocks including file path \r\n\r\n```main.rs\r\npub mod other;\r\n\r\nfn main() {\r\n    println!(\"hello world\");\r\n}\r\n```\r\n\r\n```other.rs\r\npub fn other() {\r\n    println!(\"other\");\r\n}\r\n```\r\n\r\nto be combined in non-conflicting keys\r\n\r\n- left click\r\n- enter\r\n- voice2text\r\n- copy to clipboard\r\n- append to selection\r\n- remove from selection\r\n\r\n# use case - slider hub\r\n\r\nvolume slider hub\r\n\r\nMaster slider\r\nAudio mixer slider per app\r\nApp slider - game master volume slider, music/sfx slider; youtube video slider, mpv volume slider\r\ncontrol all from single location - can use browser extension to control youtube without bringing the video to the front\r\n\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\window_position_types\\src\\lib.rs\r\n\r\n````rust\r\npub mod window_position_types;\r\npub mod window_position_types_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::window_position_types::*;\r\n    pub use crate::window_position_types_plugin::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\templates\\patterns\\new_plugin_with_types\\crates\\{{crate_name}}_types\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_{{crate_name}}_types\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\window_swap_tool\\src\\window_swap_tool_populate_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse cursor_hero_toolbelt_types::prelude::*;\r\nuse cursor_hero_tools::tool_spawning::ToolSpawnConfig;\r\nuse cursor_hero_window_swap_tool_types::prelude::*;\r\n\r\npub struct WindowSwapToolPopulatePlugin;\r\n\r\nimpl Plugin for WindowSwapToolPopulatePlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Update, handle_toolbelt_events);\r\n    }\r\n}\r\n\r\nfn handle_toolbelt_events(\r\n    mut commands: Commands,\r\n    asset_server: Res<AssetServer>,\r\n    mut reader: EventReader<ToolbeltPopulateEvent>,\r\n) {\r\n    for event in reader.read() {\r\n        let ToolbeltPopulateEvent {\r\n            loadout: ToolbeltLoadout::WindowPosition,\r\n            ..\r\n        } = event\r\n        else {\r\n            continue;\r\n        };\r\n        ToolSpawnConfig::<_, WindowSwapToolAction>::new(WindowSwapTool, event.id, event)\r\n            .with_src_path(file!().into())\r\n            .guess_name(file!())\r\n            .guess_image(file!(), &asset_server, \"webp\")\r\n            .with_description(\"Swap the positions of windows.\")\r\n            .spawn(&mut commands);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\templates\\patterns\\new_plugin_with_types\\crates\\{{crate_name}}\\src\\{{crate_name}}_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n\r\npub struct {{crate_name_pascal}}Plugin;\r\n\r\nimpl Plugin for {{crate_name_pascal}}Plugin {\r\n    fn build(&self, app: &mut App) {\r\n    }\r\n}\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\templates\\patterns\\new_tool\\crates\\{{crate_name}}_tool\\src\\{{crate_name}}_tool_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse crate::{{crate_name}}_tool_populate_plugin::{{crate_name_pascal}}ToolPopulatePlugin;\r\n\r\npub struct {{crate_name_pascal}}ToolPlugin;\r\n\r\nimpl Plugin for {{crate_name_pascal}}ToolPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_plugins({{crate_name_pascal}}ToolPopulatePlugin);\r\n    }\r\n}\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\winutils\\src\\win_colors.rs\r\n\r\n````rust\r\nuse bevy::render::color::Color;\r\nuse std::error::Error;\r\nuse winreg::enums::*;\r\nuse winreg::RegKey;\r\n\r\npub fn get_accent_color() -> Result<Color, Box<dyn Error>> {\r\n    let hklm = RegKey::predef(HKEY_CURRENT_USER);\r\n    let personalization =\r\n        hklm.open_subkey(\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Explorer\\\\Accent\")?;\r\n    let accent_color: u32 = personalization.get_value(\"AccentColorMenu\")?;\r\n    Ok(abgr_to_rgba(accent_color))\r\n}\r\n\r\npub fn get_start_color() -> Result<Color, Box<dyn Error>> {\r\n    let hklm = RegKey::predef(HKEY_CURRENT_USER);\r\n    let personalization =\r\n        hklm.open_subkey(\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Explorer\\\\Accent\")?;\r\n    let accent_color: u32 = personalization.get_value(\"StartColorMenu\")?;\r\n    Ok(abgr_to_rgba(accent_color))\r\n}\r\n\r\nfn abgr_to_rgba(abgr: u32) -> Color {\r\n    let a = ((abgr >> 24) & 0xff) as u8;\r\n    let b = ((abgr >> 16) & 0xff) as u8;\r\n    let g = ((abgr >> 8) & 0xff) as u8;\r\n    let r = (abgr & 0xff) as u8;\r\n\r\n    Color::rgba_u8(r, g, b, a)\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    #[test]\r\n    fn test_get_accent_color() {\r\n        match super::get_accent_color() {\r\n            Ok(color) => println!(\"Accent color: {:?}\", color),\r\n            Err(e) => panic!(\"Error reading accent color: {}\", e),\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\window_position\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_window_position\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\ncursor_hero_bevy = { workspace = true }\r\ncursor_hero_window_position_types = { workspace = true }\r\ncursor_hero_toolbelt_types = { workspace = true }\r\ncursor_hero_tools = { workspace = true }\r\ncursor_hero_winutils = { workspace = true }\r\ncursor_hero_math = { workspace = true }\r\nimage = { workspace = true}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\templates\\patterns\\new_tool\\crates\\{{crate_name}}_tool_types\\src\\{{crate_name}}_tool_types_plugin.rs\r\n\r\n````rust\r\nuse crate::prelude::*;\r\nuse bevy::prelude::*;\r\n\r\npub struct {{crate_name_pascal}}ToolTypesPlugin;\r\n\r\nimpl Plugin for {{crate_name_pascal}}ToolTypesPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<{{crate_name_pascal}}Tool>();\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\window_position_types\\src\\window_position_types_plugin.rs\r\n\r\n````rust\r\nuse crate::prelude::*;\r\nuse bevy::prelude::*;\r\n\r\npub struct WindowPositionTypesPlugin;\r\n\r\nimpl Plugin for WindowPositionTypesPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<crate::window_position_types::HostWindowPosition>();\r\n        app.register_type::<WindowPositionLoadoutSwitcherTool>();\r\n        app.register_type::<WindowPositionTool>();\r\n        app.register_type::<WindowPositionCommand>();\r\n        app.add_event::<WindowPositionCommand>();\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\templates\\patterns\\new_tool\\crates\\{{crate_name}}_tool\\src\\lib.rs\r\n\r\n````rust\r\npub mod {{crate_name}}_tool_plugin;\r\npub mod {{crate_name}}_tool_populate_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::{{crate_name}}_tool_plugin::*;\r\n}\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\winutils\\src\\lib.rs\r\n\r\n````rust\r\n#![feature(let_chains)]\r\n\r\nuse bevy::math::IRect;\r\n\r\npub mod win_colors;\r\npub mod win_cursor;\r\npub mod win_errors;\r\npub mod win_events;\r\npub mod win_icons;\r\npub mod win_keyboard;\r\npub mod win_mouse;\r\npub mod win_process;\r\npub mod win_screen_capture;\r\npub mod win_wallpaper;\r\npub mod win_window;\r\n\r\npub trait ToBevyIRect {\r\n    fn to_bevy_irect(&self) -> IRect;\r\n}\r\n\r\npub use widestring;\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\templates\\matchers\\new_plugin_with_types\\Cargo.toml.py\r\n\r\n````py\r\n# {{before_first_workspace_dependency}}\r\n# cursor_hero_{{crate_name}}_types = { path = \"./crates/{{crate_name}}_types\" }\r\n# cursor_hero_{{crate_name}} = { path = \"./crates/{{crate_name}}\" }\r\n# {{first_workspace_dependency_onwards}}\r\n\r\ndef gather_variables(text: str) -> dict[str,str]:\r\n    # before_first_workspace_dependency\r\n    find = \"[workspace.dependencies]\"\r\n    include = True\r\n    index = text.find(find)\r\n    assert index != -1, f\"Coult not find `{find}`\"\r\n    index = index + len(find) if include else index\r\n    before_first_workspace_dependency, remaining = text[:index],text[index:]\r\n\r\n    # first_workspace_dependency_onwards\r\n    first_workspace_dependency_onwards = remaining\r\n\r\n    return {\r\n        \"before_first_workspace_dependency\": before_first_workspace_dependency,\r\n        \"first_workspace_dependency_onwards\": first_workspace_dependency_onwards,\r\n    }\r\n\r\n##### OLD CONTENT OF THIS FILE\r\n\r\n# # {{before_first_workspace_dependency}}\r\n# # cursor_hero_{{crate_name}}_tool = { path = \"./crates/{{crate_name}}_tool\" }\r\n# # {{first_workspace_dependency_onwards}\r\n# \r\n# \r\n# \r\n# def gather_variables(text: str) -> dict[str,str]:\r\n#     find = \"some part of the file\"\r\n#     include = True\r\n#     index = text.find(find)\r\n#     assert index != -1, f\"Coult not find `{find}`\"\r\n#     index = index + len(find) if include else index\r\n#     before_first_workspace_dependency, remaining = text[:index],text[index:]\r\n# \r\n#     first_workspace_dependency_onwards = remaining\r\n# \r\n#     return {\r\n#         \"before_first_workspace_dependency\": before_first_workspace_dependency,\r\n#         \"first_workspace_dependency_onwards\": first_workspace_dependency_onwards,\r\n#     }\r\n# \r\n# ##### OLD CONTENT OF THIS FILE\r\n# \r\n# # # {{before_first_workspace_dependency}}\r\n# # # cursor_hero_{{crate_name}}_tool = { path = \"./crates/{{crate_name}}_tool\" }\r\n# # # {{first_workspace_dependency_onwards}\r\n# # \r\n# # \r\n# # \r\n# # def gather_variables(text: str) -> dict[str,str]:\r\n# #     find = \"some part of the file\"\r\n# #     include = True\r\n# #     index = text.find(find)\r\n# #     assert index != -1, f\"Coult not find `{find}`\"\r\n# #     index = index + len(find) if include else index\r\n# #     before_first_workspace_dependency, remaining = text[:index],text[index:]\r\n# # \r\n# #     first_workspace_dependency_onwards = remaining\r\n# #     return {\r\n# #         \"before_first_workspace_dependency\": before_first_workspace_dependency,\r\n# #         \"first_workspace_dependency_onwards\": first_workspace_dependency_onwards,\r\n# #     }\r\n# # \r\n# # ##### OLD CONTENT OF THIS FILE\r\n# # \r\n# # # # {{before_first_workspace_dependency}}\r\n# # # # cursor_hero_{{crate_name}}_tool = { path = \"./crates/{{crate_name}}_tool\" }\r\n# # # # {{first_workspace_dependency_onwards}\r\n# # # \r\n# # # \r\n# # # \r\n# # # def gather_variables(text: str) -> dict[str,str]:\r\n# # #     find = \"some part of the file\"\r\n# # #     include = True\r\n# # #     index = text.find(find)\r\n# # #     assert index != -1, f\"Coult not find `{find}`\"\r\n# # #     index = index + len(find) if include else index\r\n# # #     before_first_workspace_dependency, remaining = text[:index],text[index:]\r\n# # # \r\n# # #     find = \"some part of the file\"\r\n# # #     include = True\r\n# # #     index = remaining.find(find)\r\n# # #     assert index != -1, f\"Coult not find `{find}`\"\r\n# # #     index = index + len(find) if include else index\r\n# # #     first_workspace_dependency_onwards, remaining = remaining[:index],remaining[index:]\r\n# # # \r\n# # #     return {\r\n# # #         \"before_first_workspace_dependency\": before_first_workspace_dependency,\r\n# # #         \"first_workspace_dependency_onwards\": first_workspace_dependency_onwards,\r\n# # #     }\r\n# # # \r\n# # # ##### OLD CONTENT OF THIS FILE\r\n# # # \r\n# # # # # {{before_first_workspace_dependency}}\r\n# # # # # cursor_hero_{{crate_name}}_tool = { path = \"./crates/{{crate_name}}_tool\" }\r\n# # # # # {{first_workspace_dependency_onwards}\r\n# # # # \r\n# # # # \r\n# # # # \r\n# # # # def gather_variables(text: str) -> dict[str,str]:\r\n# # # #     find = \"some part of the file\"\r\n# # # #     include = True\r\n# # # #     index = text.find(find)\r\n# # # #     assert index != -1, f\"Coult not find `{find}`\"\r\n# # # #     index = index + len(find) if include else index\r\n# # # #     before_first_workspace_dependency, remaining = text[:index],text[index:]\r\n# # # # \r\n# # # #     find = \"some part of the file\"\r\n# # # #     include = True\r\n# # # #     index = remaining.find(find)\r\n# # # #     assert index != -1, f\"Coult not find `{find}`\"\r\n# # # #     index = index + len(find) if include else index\r\n# # # #     first_workspace_dependency_onwards, remaining = remaining[:index],remaining[index:]\r\n# # # # \r\n# # # #     return {\r\n# # # #         \"before_first_workspace_dependency\": before_first_workspace_dependency,\r\n# # # #         \"first_workspace_dependency_onwards\": first_workspace_dependency_onwards,\r\n# # # #     }\r\n# # # # \r\n# # # # ##### OLD CONTENT OF THIS FILE\r\n# # # # \r\n# # # # # # {{before_first_workspace_dependency}}\r\n# # # # # # cursor_hero_{{crate_name}}_tool = { path = \"./crates/{{crate_name}}_tool\" }\r\n# # # # # # {{first_workspace_dependency_onwards}\r\n# # # # # \r\n# # # # # \r\n# # # # # \r\n# # # # # def gather_variables(text: str) -> dict[str,str]:\r\n# # # # #     find = \"some part of the file\"\r\n# # # # #     include = True\r\n# # # # #     index = text.find(find)\r\n# # # # #     assert index != -1, f\"Coult not find `{find}`\"\r\n# # # # #     before_first_workspace_dependency, remaining = text[:index],text[index:]\r\n# # # # # \r\n# # # # #     find = \"some part of the file\"\r\n# # # # #     include = True\r\n# # # # #     index = remaining.find(find)\r\n# # # # #     assert index != -1, f\"Coult not find `{find}`\"\r\n# # # # #     first_workspace_dependency_onwards, remaining = remaining[:index],remaining[index:]\r\n# # # # # \r\n# # # # #     return {\r\n# # # # #         \"before_first_workspace_dependency\": before_first_workspace_dependency,\r\n# # # # #         \"first_workspace_dependency_onwards\": first_workspace_dependency_onwards,\r\n# # # # #     }\r\n# # # # # \r\n# # # # # ##### OLD CONTENT OF THIS FILE\r\n# # # # # \r\n# # # # # # # {{before_first_workspace_dependency}}\r\n# # # # # # # cursor_hero_{{crate_name}}_tool = { path = \"./crates/{{crate_name}}_tool\" }\r\n# # # # # # # {{first_workspace_depndency_onwards}}\r\n# # # # # # \r\n# # # # # # \r\n# # # # # # \r\n# # # # # # def gather_variables(text: str) -> dict[str,str]:\r\n# # # # # #     find = \"some part of the file\"\r\n# # # # # #     include = true\r\n# # # # # #     index = text.find(find)\r\n# # # # # #     assert index != -1, f\"Coult not find `{find}`\"\r\n# # # # # #     before_first_workspace_dependency, remaining = text[:index],text[index:]\r\n# # # # # # \r\n# # # # # #     find = \"some part of the file\"\r\n# # # # # #     include = true\r\n# # # # # #     index = remaining.find(find)\r\n# # # # # #     assert index != -1, f\"Coult not find `{find}`\"\r\n# # # # # #     first_workspace_dependency_onwards, remaining = remaining[:index],remaining[index:]\r\n# # # # # # \r\n# # # # # #     return {\r\n# # # # # #         \"before_first_workspace_dependency\": before_first_workspace_dependency,\r\n# # # # # #         \"first_workspace_dependency_onwards\": first_workspace_dependency_onwards,\r\n# # # # # #     }\r\n# # # # # # \r\n# # # # # # ##### OLD CONTENT OF THIS FILE\r\n# # # # # # \r\n# # # # # # # # {{before_first_workspace_dependency}}\r\n# # # # # # # # cursor_hero_{{crate_name}}_tool = { path = \"./crates/{{crate_name}}_tool\" }\r\n# # # # # # # # {{first_workspace_dependency_onwards}\r\n# # # # # # # \r\n# # # # # # # \r\n# # # # # # # \r\n# # # # # # # def gather_variables(text: str) -> dict[str,str]:\r\n# # # # # # #     find = \"some part of the file\"\r\n# # # # # # #     include = true    index = text.find(find)\r\n# # # # # # #     assert index != -1, f\"Coult not find `{find}`\"\r\n# # # # # # #     before_first_workspace_dependency, remaining = text[:index],text[index:]\r\n# # # # # # # \r\n# # # # # # #     find = \"some part of the file\"\r\n# # # # # # #     include = true    index = remaining.find(find)\r\n# # # # # # #     assert index != -1, f\"Coult not find `{find}`\"\r\n# # # # # # #     first_workspace_dependency_onwards, remaining = remaining[:index],remaining[index:]\r\n# # # # # # # \r\n# # # # # # #     return {\r\n# # # # # # #         \"before_first_workspace_dependency\": before_first_workspace_dependency,\r\n# # # # # # #         \"first_workspace_dependency_onwards\": first_workspace_dependency_onwards,\r\n# # # # # # #     }\r\n# # # # # # # \r\n# # # # # # # ##### OLD CONTENT OF THIS FILE\r\n# # # # # # # \r\n# # # # # # # # # {{before_first_workspace_dependency}}\r\n# # # # # # # # # cursor_hero_{{crate_name}}_tool = { path = \"./crates/{{crate_name}}_tool\" }\r\n# # # # # # # # # {{first_workspace_dependency_onw\r\n# # # # # # # # \r\n# # # # # # # # \r\n# # # # # # # # \r\n# # # # # # # # def gather_variables(text: str) -> dict[str,str]:\r\n# # # # # # # #     find = \"some part of the file\"\r\n# # # # # # # #     include = true    index = text.find(find)\r\n# # # # # # # #     assert index != -1, f\"Coult not find `{find}`\"\r\n# # # # # # # #     before_first_workspace_dependency, remaining = text[:index],text[index:]\r\n# # # # # # # # \r\n# # # # # # # #     find = \"some part of the file\"\r\n# # # # # # # #     include = true    index = remaining.find(find)\r\n# # # # # # # #     assert index != -1, f\"Coult not find `{find}`\"\r\n# # # # # # # #     first_workspace_dependency_onwards, remaining = remaining[:index],remaining[index:]\r\n# # # # # # # # \r\n# # # # # # # #     return {\r\n# # # # # # # #         \"before_first_workspace_dependency\": before_first_workspace_dependency,\r\n# # # # # # # #         \"first_workspace_dependency_onwards\": first_workspace_dependency_onwards,\r\n# # # # # # # #     }\r\n# # # # # # # # \r\n# # # # # # # # ##### OLD CONTENT OF THIS FILE# # {{before_first_workspace_dependency}}\r\n# # # # # # # # # # cursor_hero_{{crate_name}}_tool = { path = \"./crates/{{crate_name}}_tool\" }\r\n# # # # # # # # # \r\n# # # # # # # # # \r\n# # # # # # # # # \r\n# # # # # # # # # \r\n# # # # # # # # # def gather_variables(text: str) -> dict[str,str]:\r\n# # # # # # # # #     find = \"some part of the file\"\r\n# # # # # # # # #     include = true    index = text.find(find)\r\n# # # # # # # # #     assert index != -1, f\"Coult not find `{find}`\"\r\n# # # # # # # # #     before_first_workspace_dependency, remaining = text[:index],text[index:]\r\n# # # # # # # # # \r\n# # # # # # # # #     find = \"some part of the file\"\r\n# # # # # # # # #     include = true    index = remaining.find(find)\r\n# # # # # # # # #     assert index != -1, f\"Coult not find `{find}`\"\r\n# # # # # # # # #     first_workspace_dependency_onwards, remaining = remaining[:index],remaining[index:]\r\n# # # # # # # # # \r\n# # # # # # # # #     return {\r\n# # # # # # # # #         \"before_first_workspace_dependency\": before_first_workspace_dependency,\r\n# # # # # # # # #         \"first_workspace_dependency_onwards\": first_workspace_dependency_onwards,\r\n# # # # # # # # #     }\r\n# # # # # # # # \r\n# # # # # # # # \r\n# # # # # # # \r\n# # # # # # # \r\n# # # # # # \r\n# # # # # # \r\n# # # # # \r\n# # # # # \r\n# # # # \r\n# # # # \r\n# # # \r\n# # # \r\n# # \r\n# # \r\n# \r\n# \r\n\r\n\r\n##### WORKSPACE CONTENT\r\n#[package]\r\n#name = \"cursor_hero\"\r\n#version = \"0.3.0\"\r\n#edition = \"2021\"\r\n#\r\n#[workspace]\r\n#members = [\"crates/*\", \"other/gamepad_hell\", \"other/uparrow-enter\"]\r\n#\r\n## See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n#\r\n#[workspace.dependencies]\r\n#cursor_hero_environment_types = { path = \"./crates/environment_types\" }\r\n#cursor_hero_chat_types = { path = \"./crates/chat_types\" }\r\n#cursor_hero_chat = { path = \"./crates/chat\" }\r\n#cursor_hero_tts = { path = \"./crates/tts\" }\r\n#cursor_hero_tts_types = { path = \"./crates/tts_types\" }\r\n#cursor_hero_observation_types = { path = \"./crates/observation_types\" }\r\n#cursor_hero_observation = { path = \"./crates/observation\" }\r\n#cursor_hero_inference_types = { path = \"./crates/inference_types\" }\r\n#cursor_hero_inference = { path = \"./crates/inference\" }\r\n#cursor_hero_movement_tool_types = { path = \"./crates/movement_tool_types\" }\r\n#cursor_hero_movement_tool = { path = \"./crates/movement_tool\" }\r\n#cursor_hero_character_types = { path = \"./crates/character_types\" }\r\n#cursor_hero_agent_types = { path = \"./crates/agent_types\" }\r\n#cursor_hero_physics_debug = { path = \"./crates/physics_debug\" }\r\n#cursor_hero_math = { path = \"./crates/math\" }\r\n#cursor_hero_cursor_types = { path = \"./crates/pointer_types\" }\r\n#cursor_hero_toolbelt_types = { path = \"./crates/toolbelt_types\" }\r\n#cursor_hero_sprint_tool_types = { path = \"./crates/sprint_tool_types\" }\r\n#cursor_hero_sprint_tool = { path = \"./crates/sprint_tool\" }\r\n#cursor_hero_agent = { path = \"./crates/agent\" }\r\n#cursor_hero_taskbar = { path = \"./crates/taskbar\" }\r\n#cursor_hero_environment_nametag = { path = \"./crates/environment_nametag\" }\r\n#cursor_hero_environment = { path = \"./crates/environment\" }\r\n#cursor_hero_xelu_prompts = { path = \"./crates/xelu_prompts\" }\r\n#cursor_hero_pause_tool = { path = \"./crates/pause_tool\" }\r\n#cursor_hero_wallpaper = { path = \"./crates/wallpaper\" }\r\n#cursor_hero_cursor_mirror = { path = \"./crates/cursor_mirror\" }\r\n#cursor_hero_hover = { path = \"./crates/hover\" }\r\n#cursor_hero_pressure_plate = { path = \"./crates/pressure_plate\" }\r\n#cursor_hero_level_bounds = { path = \"./crates/level_bounds\" }\r\n#cursor_hero_bevy = { path = \"./crates/bevy\" }\r\n#cursor_hero_input = { path = \"./crates/input\" }\r\n#cursor_hero_camera = { path = \"./crates/camera\" }\r\n#cursor_hero_character = { path = \"./crates/character\" }\r\n#cursor_hero_data = { path = \"./crates/data\" }\r\n#cursor_hero_metrics = { path = \"./crates/metrics\" }\r\n#cursor_hero_click_drag_character_movement = { path = \"./crates/click_drag_character_movement\" }\r\n#cursor_hero_physics = { path = \"./crates/physics\" }\r\n#cursor_hero_cursor = { path = \"./crates/pointer\" }\r\n#cursor_hero_screen = { path = \"./crates/screen\" }\r\n#cursor_hero_toolbelt = { path = \"./crates/toolbelt\" }\r\n#cursor_hero_tools = { path = \"./crates/tools\" }\r\n#cursor_hero_ui = { path = \"./crates/ui\" }\r\n#cursor_hero_winutils = { path = \"./crates/winutils\" }\r\n#cursor_hero_restart_memory = { path = \"./crates/restart_memory\" }\r\n#cursor_hero_version = { path = \"./crates/version\" }\r\n#cursor_hero_plugins = { path = \"./crates/plugins\" }\r\n#cursor_hero_icon = { path = \"./crates/icon\" }\r\n##inline_tweak = {git = \"https://github.com/Uriopass/inline_tweak\", version = \"1.1.0\", tag = \"v1.1.0\"} # features=[\"derive\"]\r\n#anyhow = \"1.0.75\"\r\n#glam = \"0.25.0\"\r\n## bevy = { path = \"../bevy\", features = [\"dynamic_linking\"] }\r\n#bevy = { version = \"0.12.1\", git = \"https://github.com/TeamDman/bevy.git\", branch = \"cursor_hero\" }\r\n#bevy-inspector-egui = { version = \"0.22.1\", git = \"https://github.com/TeamDman/bevy-inspector-egui.git\", branch = \"cursor_hero\" }\r\n#bevy_xpbd_2d = { git = \"https://github.com/TeamDman/bevy_xpbd.git\", branch = \"cursor_hero\", features = [\r\n#  \"simd\",\r\n#  \"parallel\",\r\n#] }\r\n#bevy_egui = { git = \"https://github.com/TeamDman/bevy_egui.git\", branch = \"cursor_hero\", version = \"0.24\" }\r\n## enigo = {git = \"https://github.com/TeamDman/enigo\", branch = \"cursor_hero\", version = \"0.1.3\"}\r\n## enigo = {path = \"../../rust/enigo\", version = \"0.1.3\"}\r\n#enigo = \"0.2.0-rc2\"\r\n#egui = \"0.24\"\r\n#crossbeam-channel = \"0.5.8\"\r\n#itertools = \"0.12.0\"\r\n#raw-window-handle = \"0.5.2\"\r\n#leafwing-input-manager = { git = \"https://github.com/TeamDman/leafwing-input-manager.git\", branch = \"cursor_hero\" }\r\n#windows = \"0.51.1\"\r\n#indexmap = \"2.1.0\"\r\n#image = \"0.24.7\"\r\n#screenshots = \"0.8.4\"\r\n#uiautomation = \"0.7.3\"\r\n#serde = { version = \"1.0\", features = [\"derive\"] }\r\n#serde_json = \"1.0\"\r\n#tokio = { version = \"1.32.0\", features = [\"net\", \"full\"] }\r\n#tokio-named-pipes = \"0.1.0\"\r\n#syn = { version = \"2.0.48\", features = [\"full\", \"visit-mut\", \"visit\"] }\r\n#quote = \"1.0.35\"\r\n#proc-macro2 = \"1.0.76\"\r\n#bevy_embedded_assets = { version = \"0.9.1\", git = \"https://github.com/TeamDman/bevy_embedded_assets.git\", branch = \"cursor_hero\" }\r\n#winit = \"0.28.7\"\r\n#fxhash = \"0.2.1\"\r\n#widestring = \"1.0.2\"\r\n#winreg = \"0.52.0\"\r\n#rand = \"0.8.5\"\r\n#ollama-rs = \"0.1.6\"\r\n#reqwest = \"0.11.24\"\r\n#urlencoding = \"2.1.3\"\r\n#chrono = \"0.4.33\"\r\n#\r\n#[dependencies]\r\n#cursor_hero_plugins = { workspace = true }\r\n#cursor_hero_version = { workspace = true }\r\n#bevy = { workspace = true }\r\n#\r\n#\r\n#[dev-dependencies]\r\n#bevy = { workspace = true, features = [\"dynamic_linking\"] }\r\n#\r\n#\r\n#[build-dependencies]\r\n#embed-resource = \"1.6.3\"\r\n#\r\n#[profile.dev]\r\n#opt-level = 1\r\n#\r\n#[profile.dev.package.\"*\"]\r\n#opt-level = 3\r\n#\r\n## [patch.crates-io]\r\n## winit = { path = \"D:/Repos/rust/winit\" }\r\n#\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\wallpaper\\src\\lib.rs\r\n\r\n````rust\r\npub mod wallpaper_plugin;\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\voice_to_text_types\\src\\voice_to_text_types_plugin.rs\r\n\r\n````rust\r\nuse crate::prelude::*;\r\nuse bevy::prelude::*;\r\n\r\npub struct VoiceToTextTypesPlugin;\r\n\r\nimpl Plugin for VoiceToTextTypesPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<VoiceToTextStatus>();\r\n        app.register_type::<VoiceToTextStatusButton>();\r\n        app.register_type::<VoiceToTextStatusButtonVisualState>();\r\n        app.register_type::<VoiceToTextStatusEvent>();\r\n        app.add_event::<VoiceToTextStatusEvent>();\r\n\r\n        app.register_type::<VoiceToTextPingEvent>();\r\n        app.add_event::<VoiceToTextPingEvent>();\r\n\r\n        app.register_type::<VoiceToTextTranscriptionEvent>();\r\n        app.add_event::<VoiceToTextTranscriptionEvent>();\r\n\r\n        app.register_type::<VoiceToTextCommandEvent>();\r\n        app.add_event::<VoiceToTextCommandEvent>();\r\n\r\n        app.register_type::<VoiceToTextVscodeButton>();\r\n        app.register_type::<VoiceToTextVscodeButtonVisualState>();\r\n        app.register_type::<VoiceToTextVscodeEvent>();\r\n        app.add_event::<VoiceToTextVscodeEvent>();\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\templates\\matchers\\new_plugin_with_types\\crates\\plugins\\Cargo.toml.py\r\n\r\n````py\r\n# {{before_first_plugins_dependency}}\r\n# cursor_hero_{{crate_name}} = { workspace = true }\r\n# {{first_plugins_dependency_onwards}}\r\n\r\ndef gather_variables(text: str) -> dict[str,str]:\r\n    # before_first_plugins_dependency\r\n    find = \"[dependencies]\"\r\n    include = True\r\n    index = text.find(find)\r\n    assert index != -1, f\"Coult not find `{find}`\"\r\n    index = index + len(find) if include else index\r\n    before_first_plugins_dependency, remaining = text[:index],text[index:]\r\n\r\n    # first_plugins_dependency_onwards\r\n    first_plugins_dependency_onwards = remaining\r\n\r\n    return {\r\n        \"before_first_plugins_dependency\": before_first_plugins_dependency,\r\n        \"first_plugins_dependency_onwards\": first_plugins_dependency_onwards,\r\n    }\r\n\r\n#region OLD CONTENT OF THIS FILE\r\n\r\n# # {{before_first_plugins_dependency}}\r\n# # cursor_hero_{{crate_name}} = { workspace = true }\r\n# # {{first_plugins_dependency_onwards}\r\n# \r\n# from typing import Tuple\r\n# \r\n# def chunk(text: str) -> Tuple[str, str]:\r\n#     index = text.find(\"[dependencies]\")\r\n#     if index == -1:\r\n#         return text, \"# !!!SPLIT FAILED!!!\"\r\n#     return text[:index], text[index:]\r\n# \r\n#endregion\r\n\r\n#region WORKSPACE CONTENT\r\n#[package]\r\n#name = \"cursor_hero_plugins\"\r\n#version = \"0.1.0\"\r\n#edition = \"2021\"\r\n#\r\n## See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n#\r\n#\r\n#[dependencies]\r\n#cursor_hero_environment_types = { workspace = true }\r\n#cursor_hero_chat_types = { workspace = true }\r\n#cursor_hero_chat = { workspace = true }\r\n#cursor_hero_tts = { workspace = true }\r\n#cursor_hero_tts_types = { workspace = true }\r\n#cursor_hero_observation_types = { workspace = true }\r\n#cursor_hero_observation = { workspace = true }\r\n#cursor_hero_inference_types = { workspace = true }\r\n#cursor_hero_inference = { workspace = true }\r\n#cursor_hero_movement_tool_types = { workspace = true }\r\n#cursor_hero_movement_tool = { workspace = true }\r\n#cursor_hero_character_types = { workspace = true }\r\n#cursor_hero_agent_types = { workspace = true }\r\n#cursor_hero_physics_debug = { workspace = true }\r\n#cursor_hero_math = { workspace = true }\r\n#cursor_hero_version = { workspace = true }\r\n#cursor_hero_cursor_types = { workspace = true }\r\n#cursor_hero_toolbelt_types = { workspace = true }\r\n#cursor_hero_sprint_tool_types = { workspace = true }\r\n#cursor_hero_sprint_tool = { workspace = true }\r\n#cursor_hero_agent = { workspace = true }\r\n#cursor_hero_taskbar = { workspace = true }\r\n#cursor_hero_environment_nametag = { workspace = true }\r\n#cursor_hero_environment = { workspace = true }\r\n#cursor_hero_xelu_prompts = { workspace = true }\r\n#cursor_hero_pause_tool = { workspace = true }\r\n#cursor_hero_wallpaper = { workspace = true }\r\n#cursor_hero_cursor_mirror = {workspace = true}\r\n#cursor_hero_hover = {workspace = true}\r\n#cursor_hero_pressure_plate = {workspace = true}\r\n#cursor_hero_level_bounds = {workspace = true}\r\n#cursor_hero_input = {workspace = true}\r\n#cursor_hero_camera = {workspace = true}\r\n#cursor_hero_character = {workspace = true}\r\n#cursor_hero_data = {workspace = true}\r\n#cursor_hero_metrics = {workspace = true}\r\n#cursor_hero_click_drag_character_movement = {workspace = true}\r\n#cursor_hero_physics = {workspace = true}\r\n#cursor_hero_cursor = {workspace = true}\r\n#cursor_hero_screen = {workspace = true}\r\n#cursor_hero_toolbelt = {workspace = true}\r\n#cursor_hero_tools = {workspace = true}\r\n#cursor_hero_ui = {workspace = true}\r\n#cursor_hero_icon = {workspace = true}\r\n#cursor_hero_winutils = {workspace = true}\r\n#cursor_hero_restart_memory = {workspace = true}\r\n#bevy = {workspace = true}\r\n#bevy_embedded_assets = { workspace = true }\r\n#bevy-inspector-egui = { workspace = true }\r\n#\r\n#[dev-dependencies]\r\n#cursor_hero_restart_memory = {workspace = true}\r\n#\r\n#endregion\r\n\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\voice_to_text_types\\src\\voice_to_text_types.rs\r\n\r\n````rust\r\nuse std::fmt::Debug;\r\nuse std::time::Duration;\r\n\r\nuse bevy::prelude::*;\r\nuse bevy::utils::Instant;\r\nuse cursor_hero_secret_types::prelude::*;\r\n\r\n#[derive(Reflect, Resource, Default, Debug, Clone, Eq, PartialEq)]\r\n#[reflect(Resource)]\r\npub enum VoiceToTextStatus {\r\n    #[default]\r\n    Unknown,\r\n    UnknownWithCachedApiKey {\r\n        api_key: SecretString,\r\n    },\r\n    Alive {\r\n        api_key: SecretString,\r\n        listening: bool,\r\n    },\r\n    AliveButWeDontKnowTheApiKey,\r\n    Dead,\r\n    Starting {\r\n        instant: Instant,\r\n        timeout: Duration,\r\n        api_key: SecretString,\r\n    },\r\n}\r\n\r\n#[derive(Event, Debug, Reflect)]\r\npub enum VoiceToTextPingEvent {\r\n    Ping,\r\n    Pong { status: VoiceToTextStatus },\r\n}\r\n\r\n#[derive(Event, Debug, Reflect)]\r\npub enum VoiceToTextStatusEvent {\r\n    Changed {\r\n        old_status: VoiceToTextStatus,\r\n        new_status: VoiceToTextStatus,\r\n    },\r\n}\r\n\r\n#[derive(Event, Debug, Reflect)]\r\npub enum VoiceToTextTranscriptionEvent {\r\n    Received { transcription: String },\r\n}\r\n\r\n#[derive(Event, Debug, Reflect)]\r\npub enum VoiceToTextCommandEvent {\r\n    Startup,\r\n    SetListening {\r\n        listening: bool,\r\n        api_key: SecretString,\r\n    },\r\n    ConnectReceiver {\r\n        api_key: SecretString,\r\n    },\r\n}\r\n\r\n#[derive(Component, Debug, Reflect, Default)]\r\npub struct VoiceToTextStatusButton {\r\n    pub visual_state: VoiceToTextStatusButtonVisualState,\r\n}\r\n\r\n#[derive(Debug, Reflect, Eq, PartialEq)]\r\npub enum VoiceToTextStatusButtonVisualState {\r\n    Default { status: VoiceToTextStatus },\r\n    Hovered { status: VoiceToTextStatus },\r\n    Pressed { status: VoiceToTextStatus },\r\n}\r\nimpl Default for VoiceToTextStatusButtonVisualState {\r\n    fn default() -> Self {\r\n        VoiceToTextStatusButtonVisualState::Default {\r\n            status: VoiceToTextStatus::Unknown,\r\n        }\r\n    }\r\n}\r\n\r\n#[derive(Component, Debug, Reflect, Default)]\r\npub struct VoiceToTextVscodeButton {\r\n    pub visual_state: VoiceToTextVscodeButtonVisualState,\r\n}\r\n#[derive(Debug, Reflect, Eq, PartialEq, Default)]\r\npub enum VoiceToTextVscodeButtonVisualState {\r\n    #[default]\r\n    Default,\r\n}\r\n#[derive(Event, Debug, Reflect)]\r\npub enum VoiceToTextVscodeEvent {\r\n    Startup,\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\window_position\\src\\window_position_tool_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse bevy::window::PrimaryWindow;\r\nuse bevy::window::WindowMode;\r\nuse bevy::window::WindowResolution;\r\nuse cursor_hero_bevy::prelude::BottomRightI;\r\nuse cursor_hero_bevy::prelude::CornerOfIRect;\r\nuse cursor_hero_bevy::prelude::IRectScale;\r\nuse cursor_hero_bevy::prelude::TopLeftI;\r\nuse cursor_hero_bevy::prelude::TranslateIVec2;\r\nuse cursor_hero_math::prelude::Corner;\r\nuse cursor_hero_toolbelt_types::prelude::ToolbeltPopulateEvent;\r\nuse cursor_hero_toolbelt_types::toolbelt_types::ActiveTool;\r\nuse cursor_hero_toolbelt_types::toolbelt_types::ToolbeltLoadout;\r\nuse cursor_hero_tools::prelude::NoInputs;\r\nuse cursor_hero_tools::prelude::ToolSpawnConfig;\r\nuse cursor_hero_tools::tool_spawning::StartingState;\r\nuse cursor_hero_window_position_types::prelude::HostWindowPosition;\r\nuse cursor_hero_window_position_types::prelude::WindowPositionTool;\r\nuse cursor_hero_window_position_types::window_position_types::WindowPositionCommand;\r\nuse cursor_hero_winutils::win_mouse::set_cursor_position;\r\nuse cursor_hero_winutils::win_screen_capture::get_all_monitors;\r\nuse cursor_hero_winutils::win_screen_capture::get_monitor_infos;\r\nuse cursor_hero_winutils::win_screen_capture::Monitor;\r\nuse image::ImageBuffer;\r\nuse image::Rgba;\r\npub struct WindowPositionToolPlugin;\r\n\r\nimpl Plugin for WindowPositionToolPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Update, populate_toolbelts);\r\n        app.add_systems(Update, do_position);\r\n    }\r\n}\r\n\r\nfn populate_toolbelts(\r\n    mut commands: Commands,\r\n    mut reader: EventReader<ToolbeltPopulateEvent>,\r\n    mut textures: ResMut<Assets<Image>>,\r\n) {\r\n    for event in reader.read() {\r\n        if event.loadout != ToolbeltLoadout::WindowPosition {\r\n            continue;\r\n        }\r\n        let Ok(monitors) = get_all_monitors() else {\r\n            warn!(\"No monitors found\");\r\n            continue;\r\n        };\r\n        let icon_size = UVec2::new(500, 500);\r\n\r\n        let mut world = IRect::from_corners(\r\n            monitors\r\n                .iter()\r\n                .map(|monitor| monitor.info.rect.top_left())\r\n                .reduce(|a, b| a.min(b))\r\n                .unwrap_or_default(),\r\n            monitors\r\n                .iter()\r\n                .map(|monitor| monitor.info.rect.bottom_right())\r\n                .reduce(|a, b| a.max(b))\r\n                .unwrap_or_default(),\r\n        );\r\n\r\n        // expand it to be square aspect ratio\r\n        if world.size().x > world.size().y {\r\n            world = world.scale(Vec2::new(\r\n                1.0,\r\n                world.size().x as f32 / world.size().y as f32,\r\n            ));\r\n        } else {\r\n            world = world.scale(Vec2::new(\r\n                world.size().y as f32 / world.size().x as f32,\r\n                1.0,\r\n            ));\r\n        }\r\n\r\n        for monitor in monitors.iter() {\r\n            for corner in Corner::variants() {\r\n                let name = format!(\"{:?} Monitor {}\", corner, monitor.info.name);\r\n\r\n                let image = image_for_monitor_corner(icon_size, world, monitor, &corner);\r\n                let texture = textures.add(image);\r\n\r\n                ToolSpawnConfig::<WindowPositionTool, NoInputs>::new(\r\n                    WindowPositionTool {\r\n                        window_position: HostWindowPosition::Corner {\r\n                            corner,\r\n                            monitor: monitor.info.id,\r\n                        },\r\n                    },\r\n                    event.id,\r\n                    event,\r\n                )\r\n                .with_src_path(file!().into())\r\n                .with_name(name.clone())\r\n                .with_image(texture)\r\n                .with_description(\"Moves the game window\")\r\n                .with_size(Vec2::new(100.0, 100.0))\r\n                .with_starting_state(StartingState::Inactive)\r\n                .spawn(&mut commands);\r\n            }\r\n            let name = format!(\"fullscreen_monitor_{}\", monitor.info.id);\r\n            ToolSpawnConfig::<WindowPositionTool, NoInputs>::new(\r\n                WindowPositionTool {\r\n                    window_position: HostWindowPosition::Fullscreen {\r\n                        monitor: monitor.info.id,\r\n                    },\r\n                },\r\n                event.id,\r\n                event,\r\n            )\r\n            .with_src_path(file!().into())\r\n            .with_name(name.clone())\r\n            .with_image(textures.add(image_for_monitor(icon_size, world, monitor)))\r\n            .with_description(\"Moves the game window\")\r\n            .with_size(Vec2::new(100.0, 100.0))\r\n            .with_starting_state(StartingState::Inactive)\r\n            .spawn(&mut commands);\r\n        }\r\n    }\r\n}\r\n\r\nfn image_for_monitor_corner(\r\n    icon_size: UVec2,\r\n    world: IRect,\r\n    monitor: &Monitor,\r\n    corner: &Corner,\r\n) -> Image {\r\n    let mut imgbuf =\r\n        ImageBuffer::from_pixel(icon_size.x, icon_size.y, Rgba([173u8, 216u8, 230u8, 255u8])); // Light blue background\r\n\r\n    let scale = icon_size.as_vec2() / world.size().as_vec2();\r\n    let monitor_icon_region = monitor.info.rect.translate(&-world.min).scale(scale);\r\n    debug!(\r\n        \"Monitor icon region: {:?}, scale: {:?}\",\r\n        monitor_icon_region, scale\r\n    );\r\n\r\n    let dest_icon_region = IRect::from_corners(\r\n        monitor_icon_region.center(),\r\n        corner.of(&monitor_icon_region),\r\n    );\r\n    for (x, y, pixel) in imgbuf.enumerate_pixels_mut() {\r\n        if monitor_icon_region.contains(IVec2::new(x as i32, y as i32)) {\r\n            *pixel = Rgba([255u8, 0u8, 0u8, 255u8]);\r\n        }\r\n        if dest_icon_region.contains(IVec2::new(x as i32, y as i32)) {\r\n            *pixel = Rgba([0u8, 255u8, 0u8, 255u8]);\r\n        }\r\n    }\r\n    Image::from_dynamic(imgbuf.into(), true)\r\n}\r\n\r\nfn image_for_monitor(icon_size: UVec2, world: IRect, monitor: &Monitor) -> Image {\r\n    let mut imgbuf =\r\n        ImageBuffer::from_pixel(icon_size.x, icon_size.y, Rgba([173u8, 216u8, 230u8, 255u8])); // Light blue background\r\n\r\n    let scale = icon_size.as_vec2() / world.size().as_vec2();\r\n    let monitor_icon_region = monitor.info.rect.translate(&-world.min).scale(scale);\r\n    debug!(\r\n        \"Monitor icon region: {:?}, scale: {:?}\",\r\n        monitor_icon_region, scale\r\n    );\r\n    for (x, y, pixel) in imgbuf.enumerate_pixels_mut() {\r\n        if monitor_icon_region.contains(IVec2::new(x as i32, y as i32)) {\r\n            *pixel = Rgba([0u8, 0u8, 255u8, 255u8]);\r\n        }\r\n    }\r\n    Image::from_dynamic(imgbuf.into(), true)\r\n}\r\n\r\nfn do_position(\r\n    mut commands: Commands,\r\n    tool_query: Query<(Entity, &WindowPositionTool), With<ActiveTool>>,\r\n    mut window_query: Query<Entity, With<PrimaryWindow>>,\r\n    mut window_commands: EventWriter<WindowPositionCommand>,\r\n) {\r\n    let Ok(monitor_infos) = get_monitor_infos() else {\r\n        return;\r\n    };\r\n\r\n    for tool in tool_query.iter() {\r\n        let (tool_id, tool) = tool;\r\n        let Ok(window) = window_query.get_single_mut() else {\r\n            error!(\"No primary window found\");\r\n            return;\r\n        };\r\n        let window_id = window;\r\n        match tool.window_position {\r\n            HostWindowPosition::Corner {\r\n                ref corner,\r\n                monitor,\r\n            } => {\r\n                let Some(monitor) = monitor_infos.iter().find(|info| info.id == monitor) else {\r\n                    warn!(\"No monitor found with id: {}\", monitor);\r\n                    continue;\r\n                };\r\n                debug!(\r\n                    \"Activating corner: {:?} on monitor: {}\",\r\n                    corner, monitor.name\r\n                );\r\n                let dest_bounds = IRect::from_corners(\r\n                    monitor.work_area.center(),\r\n                    corner.of(&monitor.work_area)\r\n                        - ((corner.of(&monitor.work_area) - monitor.work_area.center())\r\n                            .as_vec2()\r\n                            .normalize()\r\n                            * 100.0)\r\n                            .as_ivec2(),\r\n                );\r\n                window_commands.send(WindowPositionCommand {\r\n                    window: window_id,\r\n                    position: Some(WindowPosition::At(dest_bounds.top_left())),\r\n                    resolution: Some(WindowResolution::new(\r\n                        dest_bounds.width() as f32,\r\n                        dest_bounds.height() as f32,\r\n                    )),\r\n                    mode: Some(WindowMode::Windowed),\r\n                });\r\n                if let Err(e) = set_cursor_position(dest_bounds.center()) {\r\n                    warn!(\"Failed to set cursor position: {}\", e);\r\n                }\r\n                commands.entity(tool_id).remove::<ActiveTool>();\r\n            }\r\n            HostWindowPosition::Fullscreen { monitor } => {\r\n                let Some(monitor) = monitor_infos.iter().find(|info| info.id == monitor) else {\r\n                    warn!(\"No monitor found with id: {}\", monitor);\r\n                    continue;\r\n                };\r\n                debug!(\"Activating fullscreen on monitor: {}\", monitor.name);\r\n                let margin = 50;\r\n                window_commands.send(WindowPositionCommand {\r\n                    window: window_id,\r\n                    position: Some(WindowPosition::At(\r\n                        monitor.work_area.top_left() + IVec2::splat(margin),\r\n                    )),\r\n                    resolution: Some(WindowResolution::new(\r\n                        (monitor.work_area.width() + margin * 2) as f32,\r\n                        (monitor.work_area.height() + margin * 2) as f32,\r\n                    )),\r\n                    mode: Some(WindowMode::Windowed),\r\n                });\r\n                // send second command to ensure fullscreen applies over the taskbar properly\r\n                let cmd = WindowPositionCommand {\r\n                    window: window_id,\r\n                    // position: Some(WindowPosition::At(monitor.work_area.top_left())),\r\n                    // resolution: Some(WindowResolution::new(\r\n                    //     monitor.work_area.width() as f32,\r\n                    //     monitor.work_area.height() as f32,\r\n                    // )),\r\n                    mode: Some(WindowMode::BorderlessFullscreen),\r\n                    position: None,\r\n                    resolution: None,\r\n                };\r\n                window_commands.send(cmd);\r\n\r\n                if let Err(e) = set_cursor_position(monitor.work_area.center()) {\r\n                    warn!(\"Failed to set cursor position: {}\", e);\r\n                }\r\n                commands.entity(tool_id).remove::<ActiveTool>();\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\window_swap_tool_types\\src\\window_swap_tool_types_plugin.rs\r\n\r\n````rust\r\nuse crate::prelude::*;\r\nuse bevy::prelude::*;\r\n\r\npub struct WindowSwapToolTypesPlugin;\r\n\r\nimpl Plugin for WindowSwapToolTypesPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<WindowSwapTool>();\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui_watcher_types\\src\\lib.rs\r\n\r\n````rust\r\npub mod ui_watcher_types;\r\npub mod ui_watcher_types_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::ui_watcher_types::*;\r\n    pub use crate::ui_watcher_types_plugin::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\version\\src\\version_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n\r\npub struct VersionPlugin(pub String);\r\n\r\nimpl Plugin for VersionPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.insert_resource(Version(self.0.clone()));\r\n    }\r\n}\r\n\r\n#[derive(Resource, Reflect, Default)]\r\n#[reflect(Resource)]\r\npub struct Version(pub String);\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\templates\\matchers\\new_tool\\crates\\plugins\\Cargo.toml.py\r\n\r\n````py\r\n# {{before_first_plugins_dependency}}\r\n# cursor_hero_{{crate_name}} = { workspace = true }\r\n# {{first_plugins_dependency_onwards}}\r\n\r\ndef gather_variables(text: str) -> dict[str,str]:\r\n    # before_first_plugins_dependency\r\n    find = \"[dependencies]\"\r\n    include = True\r\n    index = text.find(find)\r\n    assert index != -1, f\"Coult not find `{find}`\"\r\n    index = index + len(find) if include else index\r\n    before_first_plugins_dependency, remaining = text[:index],text[index:]\r\n\r\n    # first_plugins_dependency_onwards\r\n    first_plugins_dependency_onwards = remaining\r\n\r\n    return {\r\n        \"before_first_plugins_dependency\": before_first_plugins_dependency,\r\n        \"first_plugins_dependency_onwards\": first_plugins_dependency_onwards,\r\n    }\r\n\r\n#region OLD CONTENT OF THIS FILE\r\n\r\n# # {{before_first_plugins_dependency}}\r\n# # cursor_hero_{{crate_name}} = { workspace = true }\r\n# # {{first_plugins_dependency_onwards}\r\n# \r\n# from typing import Tuple\r\n# \r\n# def chunk(text: str) -> Tuple[str, str]:\r\n#     index = text.find(\"[dependencies]\")\r\n#     if index == -1:\r\n#         return text, \"# !!!SPLIT FAILED!!!\"\r\n#     return text[:index], text[index:]\r\n# \r\n#endregion\r\n\r\n#region WORKSPACE CONTENT\r\n#[package]\r\n#name = \"cursor_hero_plugins\"\r\n#version = \"0.1.0\"\r\n#edition = \"2021\"\r\n#\r\n## See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n#\r\n#\r\n#[dependencies]\r\n#cursor_hero_environment_types = { workspace = true }\r\n#cursor_hero_chat_types = { workspace = true }\r\n#cursor_hero_chat = { workspace = true }\r\n#cursor_hero_tts = { workspace = true }\r\n#cursor_hero_tts_types = { workspace = true }\r\n#cursor_hero_observation_types = { workspace = true }\r\n#cursor_hero_observation = { workspace = true }\r\n#cursor_hero_inference_types = { workspace = true }\r\n#cursor_hero_inference = { workspace = true }\r\n#cursor_hero_movement_tool_types = { workspace = true }\r\n#cursor_hero_movement_tool = { workspace = true }\r\n#cursor_hero_character_types = { workspace = true }\r\n#cursor_hero_agent_types = { workspace = true }\r\n#cursor_hero_physics_debug = { workspace = true }\r\n#cursor_hero_math = { workspace = true }\r\n#cursor_hero_version = { workspace = true }\r\n#cursor_hero_cursor_types = { workspace = true }\r\n#cursor_hero_toolbelt_types = { workspace = true }\r\n#cursor_hero_sprint_tool_types = { workspace = true }\r\n#cursor_hero_sprint_tool = { workspace = true }\r\n#cursor_hero_agent = { workspace = true }\r\n#cursor_hero_taskbar = { workspace = true }\r\n#cursor_hero_environment_nametag = { workspace = true }\r\n#cursor_hero_environment = { workspace = true }\r\n#cursor_hero_xelu_prompts = { workspace = true }\r\n#cursor_hero_pause_tool = { workspace = true }\r\n#cursor_hero_wallpaper = { workspace = true }\r\n#cursor_hero_cursor_mirror = {workspace = true}\r\n#cursor_hero_hover = {workspace = true}\r\n#cursor_hero_pressure_plate = {workspace = true}\r\n#cursor_hero_level_bounds = {workspace = true}\r\n#cursor_hero_input = {workspace = true}\r\n#cursor_hero_camera = {workspace = true}\r\n#cursor_hero_character = {workspace = true}\r\n#cursor_hero_data = {workspace = true}\r\n#cursor_hero_metrics = {workspace = true}\r\n#cursor_hero_click_drag_character_movement = {workspace = true}\r\n#cursor_hero_physics = {workspace = true}\r\n#cursor_hero_cursor = {workspace = true}\r\n#cursor_hero_screen = {workspace = true}\r\n#cursor_hero_toolbelt = {workspace = true}\r\n#cursor_hero_tools = {workspace = true}\r\n#cursor_hero_ui = {workspace = true}\r\n#cursor_hero_icon = {workspace = true}\r\n#cursor_hero_winutils = {workspace = true}\r\n#cursor_hero_restart_memory = {workspace = true}\r\n#bevy = {workspace = true}\r\n#bevy_embedded_assets = { workspace = true }\r\n#bevy-inspector-egui = { workspace = true }\r\n#\r\n#[dev-dependencies]\r\n#cursor_hero_restart_memory = {workspace = true}\r\n#\r\n#endregion\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui_watcher\\src\\lib.rs\r\n\r\n````rust\r\npub mod ui_watcher_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::ui_watcher_plugin::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\use cases\\monologuing.md\r\n\r\n````markdown\r\nI am recording in OBS. I am using VSCode.\r\nI have ChatGPT open. \r\nSo I'm talking and describing the problem that I want solved.And I'm gesturing in the editor, but ChatGPT cannot see the gestures at this time.Currently the best I can do is hold a push-to-talk button that will transcribe things as I say them, but that is not capturing information such as the selection under my mouse changing or tabs being changed in VS Code.One thing that I think would be good is a visual feedback for when the push-to-talk is actively listening.and that won't give misinformation. So if it says it's listening, it must be accurate.Because you can't be second-guessing the indicatorThe current best indicator is focusing the Windows Terminal, which has multiple tabs open, but one of those tabs is the Python program, which does have logging for when it is listening and other activities.So this could be leveraged.One possible way to do it would be to havethe tool programmatically focus the Windows Terminal window and then grab the content inside of it.a different way to do it would be to have the startup script for the thing that is running theWindows, or the voice-to-text thing.The thing that launches that would do so in a way that it captures the system and feeds it back to our program.One way to grab the logs would be to focus the Windows terminal, programmatically click and drag from the top left to the bottom right to select all the content, and then right-click to copy it.This causes problems though because the scenario where we are using the push-to-talk might be where we have something focused and we expect to type the response into it, but the act of focusing the Windows terminal to capture the content of it using click-and-drag would unfocus the text box we were previously at.That could be remediated by placing a marker fora reference on how to return to the current state.so that when we deviate from the state to analyze something, we know how to return to it. So the act of focusing the Windows terminal and unfocusing the text input, we would need to be able to...have a course of action for refocusing the text input. I need a way to be able to toggle the listening instead of holding it, because if I'm talking for a long time, I might just want it to listen continuously without having to hold down a button. and want to make a tool for the clipboard. It will be called the clipboard tool. The clipboard tool, when equipped, will...disable all the other tools so that it is the last one. So instead of adding to my to-do list an item that I could finish now but want to put on hold to pursue a different idea, it is just better for me to finish it.\r\n\r\n```ipynb\r\nimport os\r\nimport re\r\n\r\n# Get the list of all Cargo.toml files\r\ncargo_files = []\r\nfor root, dirs, files in os.walk('./crates'):\r\n    for file in files:\r\n        if file == 'Cargo.toml':\r\n            cargo_files.append(os.path.join(root, file))\r\n\r\n# Iterate over each Cargo.toml file\r\nfor cargo_file in cargo_files:\r\n    with open(cargo_file, 'r') as file:\r\n        lines = file.readlines()\r\n\r\n    # Find entries in [dependencies] that don't begin with \"cursor_\"\r\n    dependencies = []\r\n    for i, line in enumerate(lines):\r\n        if line.strip() == '[dependencies]':\r\n            j = i + 1\r\n            while j < len(lines) and not lines[j].startswith('['):\r\n                dependency = lines[j].strip()\r\n                if not dependency.startswith('cursor_'):\r\n                    dependencies.append(dependency)\r\n                j += 1\r\n\r\n    # Update the dependencies to { workspace = true }\r\n    for i, dependency in enumerate(dependencies):\r\n        lines[lines.index(dependency)] = dependency.replace(dependency, f'{dependency} = {{ workspace = true }}')\r\n\r\n    # Append features block to the windows crate\r\n    if 'windows' in cargo_file:\r\n        for i, line in enumerate(lines):\r\n            if line.strip() == '[dependencies.windows]':\r\n                j = i + 1\r\n                while j < len(lines) and not lines[j].startswith('['):\r\n                    if lines[j].startswith('features'):\r\n                        lines[j] = lines[j].strip()[:-1] + ', \"abc\"]\\n'\r\n                    j += 1\r\n\r\n    # Log the replaced entries\r\n    replaced_entries = [dependency.split('=')[0].strip() for dependency in dependencies]\r\n    print(f'Replaced entries in {cargo_file}: {replaced_entries}')\r\n\r\n    # Write the updated lines back to the Cargo.toml file\r\n    # with open(cargo_file, 'w') as file:\r\n    #     file.writelines(lines)\r\n```\r\nThat is an attempt at a notebook to...adjust dependencies to rely on the parent create.\r\nIt doesn't print anything when ran.\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\window_swap_tool_types\\src\\window_swap_tool_types.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse leafwing_input_manager::prelude::*;\r\n\r\nuse bevy_inspector_egui::prelude::ReflectInspectorOptions;\r\nuse bevy_inspector_egui::InspectorOptions;\r\nuse cursor_hero_input::active_input_state_plugin::InputMethod;\r\nuse cursor_hero_toolbelt_types::prelude::*;\r\n\r\n#[derive(Component, Reflect, Debug, InspectorOptions)]\r\n#[reflect(Component, InspectorOptions)]\r\npub struct WindowSwapTool;\r\n\r\nimpl Default for WindowSwapTool {\r\n    fn default() -> Self {\r\n        match InputMethod::default() {\r\n            InputMethod::MouseAndKeyboard | InputMethod::Keyboard => Self::default_mnk(),\r\n            InputMethod::Gamepad => Self::default_gamepad(),\r\n        }\r\n    }\r\n}\r\nimpl WindowSwapTool {\r\n    pub fn default_mnk() -> WindowSwapTool {\r\n        WindowSwapTool\r\n    }\r\n    pub fn default_gamepad() -> WindowSwapTool {\r\n        WindowSwapTool\r\n    }\r\n}\r\n\r\n#[derive(Actionlike, PartialEq, Eq, Clone, Copy, Hash, Debug, Reflect)]\r\npub enum WindowSwapToolAction {\r\n    Use,\r\n}\r\n\r\nimpl WindowSwapToolAction {\r\n    fn default_gamepad_binding(&self) -> UserInput {\r\n        match self {\r\n            Self::Use => GamepadButtonType::North.into(),\r\n        }\r\n    }\r\n\r\n    fn default_mkb_binding(&self) -> UserInput {\r\n        match self {\r\n            Self::Use => KeyCode::Q.into(),\r\n        }\r\n    }\r\n}\r\nimpl ToolAction for WindowSwapToolAction {\r\n    fn default_input_map(_event: &ToolbeltPopulateEvent) -> Option<InputMap<WindowSwapToolAction>> {\r\n        let mut input_map = InputMap::default();\r\n\r\n        for variant in WindowSwapToolAction::variants() {\r\n            input_map.insert(variant.default_mkb_binding(), variant);\r\n            input_map.insert(variant.default_gamepad_binding(), variant);\r\n        }\r\n        Some(input_map)\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\voice_to_text\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_voice_to_text\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\ncursor_hero_inference_types = { workspace = true }\r\ncursor_hero_voice_to_text_types = { workspace = true }\r\ntokio = { workspace = true }\r\ntokio-tungstenite = { workspace = true, features = [\"native-tls\"]}\r\nfutures-util = { workspace = true }\r\nreqwest = { workspace = true }\r\nurlencoding = { workspace = true }\r\ncrossbeam-channel = { workspace = true }\r\ncursor_hero_environment_types = { workspace = true }\r\ncursor_hero_cursor_types = { workspace = true }\r\ncursor_hero_math = { workspace = true }\r\nbevy_xpbd_2d = { workspace = true }\r\nrand = { workspace = true }\r\nrodio = { workspace = true, features = [\"wav\"] }\r\ncursor_hero_secret_types = { workspace = true }\r\nserde = { workspace = true }\r\nserde_json = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\templates\\matchers\\new_plugin_with_types\\crates\\plugins\\src\\default_launch_mode_plugin.rs.py\r\n\r\n````py\r\n# {{use_statements}}\r\n# use cursor_hero_{{crate_name}}::prelude::*;\r\n# use cursor_hero_{{crate_name}}_types::prelude::*;\r\n# {{plugin_start}}\r\n#         app.add_plugins({{crate_name_pascal}}TypesPlugin);\r\n#         app.add_plugins({{crate_name_pascal}}Plugin);\r\n# {{plugin_remaining}}\r\n\r\ndef gather_variables(text: str) -> dict[str,str]:\r\n    # use_statements\r\n    find = \"pub struct DefaultLaunchModePlugin;\"\r\n    include = False\r\n    index = text.find(find)\r\n    assert index != -1, f\"Coult not find `{find}`\"\r\n    index = index + len(find) if include else index\r\n    use_statements, remaining = text[:index],text[index:]\r\n\r\n    # plugin_start\r\n    find = \"fn build(&self, app: &mut App) {\"\r\n    include = True\r\n    index = remaining.find(find)\r\n    assert index != -1, f\"Coult not find `{find}`\"\r\n    index = index + len(find) if include else index\r\n    plugin_start, remaining = remaining[:index],remaining[index:]\r\n\r\n    # plugin_remaining\r\n    plugin_remaining = remaining\r\n\r\n    return {\r\n        \"use_statements\": use_statements,\r\n        \"plugin_start\": plugin_start,\r\n        \"plugin_remaining\": plugin_remaining,\r\n    }\r\n\r\n#region WORKSPACE CONTENT\r\n#use bevy::input::common_conditions::input_toggle_active;\r\n#use bevy::prelude::*;\r\n#\r\n#use bevy::audio::AudioPlugin;\r\n#use bevy::audio::SpatialScale;\r\n#use bevy::diagnostic::FrameTimeDiagnosticsPlugin;\r\n#use bevy::log::LogPlugin;\r\n#use bevy_embedded_assets::EmbeddedAssetPlugin;\r\n#use bevy_inspector_egui::quick::WorldInspectorPlugin;\r\n#use cursor_hero_agent::agent_plugin::AgentPlugin;\r\n#use cursor_hero_camera::camera_plugin::CameraPlugin;\r\n#use cursor_hero_character::character_plugin::CharacterPlugin;\r\n#use cursor_hero_cursor_mirror::cursor_mirroring_plugin::CursorMirroringPlugin;\r\n#use cursor_hero_environment::environment_plugin::EnvironmentPlugin;\r\n#use cursor_hero_environment_nametag::environment_nametag_plugin::EnvironmentNametagPlugin;\r\n#use cursor_hero_hover::afterimage_plugin::AfterimagePlugin;\r\n#use cursor_hero_hover::hover_tool::HoverToolPlugin;\r\n#use cursor_hero_hover::hover_ui_automation_plugin::HoverUiAutomationPlugin;\r\n#use cursor_hero_hover::inspect_tool::InspectToolPlugin;\r\n#use cursor_hero_hover::inspect_wheel_tool::InspectWheelToolPlugin;\r\n#use cursor_hero_icon::IconPlugin;\r\n#use cursor_hero_input::InputPlugin;\r\n#use cursor_hero_level_bounds::level_bounds_plugin::LevelBoundsPlugin;\r\n#use cursor_hero_math::math_plugin::MathPlugin;\r\n#use cursor_hero_pause_tool::pause_tool_plugin::PauseToolPlugin;\r\n#use cursor_hero_physics::damping_plugin::DampingPlugin;\r\n#use cursor_hero_physics::physics_plugin::PhysicsPlugin;\r\n#use cursor_hero_physics_debug::physics_debug_plugin::PhysicsDebugPlugin;\r\n#use cursor_hero_cursor::pointer_plugin::PointerPlugin;\r\n#use cursor_hero_cursor_types::pointer_types_plugin::PointerTypesPlugin;\r\n#use cursor_hero_pressure_plate::pressure_plate_plugin::PressurePlatePlugin;\r\n#use cursor_hero_restart_memory::MemoryPlugin;\r\n##[cfg(debug_assertions)]\r\n#use cursor_hero_screen::screen_plugin::ScreenPlugin;\r\n#use cursor_hero_screen::screen_update_plugin::ScreenUpdatePlugin;\r\n#use cursor_hero_sprint_tool::sprint_tool_plugin::SprintToolPlugin;\r\n#use cursor_hero_sprint_tool_types::sprint_tool_types_plugin::SprintToolTypesPlugin;\r\n#use cursor_hero_taskbar::taskbar_plugin::TaskbarPlugin;\r\n#use cursor_hero_toolbelt::toolbelt_plugin::ToolbeltPlugin;\r\n#use cursor_hero_toolbelt_types::toolbelt_types_plugin::ToolbeltTypesPlugin;\r\n#use cursor_hero_tools::ToolPlugin;\r\n#use cursor_hero_ui::about_text_plugin::AboutTextPlugin;\r\n#use cursor_hero_ui::fps_text_plugin::FpsTextPlugin;\r\n#use cursor_hero_version::version_plugin::Version;\r\n#use cursor_hero_wallpaper::wallpaper_plugin::WallpaperPlugin;\r\n#\r\n#use cursor_hero_agent_types::agent_types_plugin::AgentTypesPlugin;\r\n#use cursor_hero_character_types::character_types_plugin::CharacterTypesPlugin;\r\n#use cursor_hero_chat::chat_plugin::ChatPlugin;\r\n#use cursor_hero_chat_types::chat_types_plugin::ChatTypesPlugin;\r\n#use cursor_hero_inference::inference_plugin::InferencePlugin;\r\n#use cursor_hero_inference_types::inference_types_plugin::InferenceTypesPlugin;\r\n#use cursor_hero_movement_tool::movement_tool_plugin::MovementToolPlugin;\r\n#use cursor_hero_movement_tool_types::movement_tool_types_plugin::MovementToolTypesPlugin;\r\n#use cursor_hero_observation::observation_plugin::ObservationPlugin;\r\n#use cursor_hero_observation_types::observation_types_plugin::ObservationTypesPlugin;\r\n#use cursor_hero_tts::tts_plugin::TtsPlugin;\r\n#use cursor_hero_tts_types::tts_types_plugin::TtsTypesPlugin;\r\n#use cursor_hero_environment_types::environment_types_plugin::EnvironmentTypesPlugin;\r\n#pub struct MyPlugin;\r\n#\r\n#impl Plugin for MyPlugin {\r\n#    fn build(&self, app: &mut App) {\r\n#        app.add_plugins(EnvironmentTypesPlugin);\r\n#        app.add_plugins(ChatTypesPlugin);\r\n#        app.add_plugins(ChatPlugin);\r\n#        app.add_plugins(TtsPlugin);\r\n#        app.add_plugins(TtsTypesPlugin);\r\n#        app.add_plugins(ObservationTypesPlugin);\r\n#        app.add_plugins(ObservationPlugin);\r\n#        app.add_plugins(InferenceTypesPlugin);\r\n#        app.add_plugins(InferencePlugin);\r\n#        app.add_plugins(MovementToolTypesPlugin);\r\n#        app.add_plugins(MovementToolPlugin);\r\n#        app.add_plugins(CharacterTypesPlugin);\r\n#        app.add_plugins(AgentTypesPlugin);\r\n#        app.add_plugins(AgentPlugin);\r\n#        //app.add_plugins(ClickDragMovementPlugin);\r\n#        //app.add_plugins(HoverShowerRelayPlugin);\r\n#        //app.add_plugins(HoverShowerServicePlugin);\r\n#        app.add_plugins(AboutTextPlugin);\r\n#        app.add_plugins(AfterimagePlugin);\r\n#        app.add_plugins(CameraPlugin);\r\n#        app.add_plugins(CharacterPlugin);\r\n#        app.add_plugins(CursorMirroringPlugin);\r\n#        app.add_plugins(DampingPlugin);\r\n#        app.add_plugins(EnvironmentNametagPlugin);\r\n#        app.add_plugins(EnvironmentPlugin);\r\n#        app.add_plugins(FpsTextPlugin);\r\n#        app.add_plugins(HoverToolPlugin);\r\n#        app.add_plugins(HoverUiAutomationPlugin);\r\n#        app.add_plugins(IconPlugin);\r\n#        app.add_plugins(InputPlugin);\r\n#        app.add_plugins(InspectToolPlugin);\r\n#        app.add_plugins(InspectWheelToolPlugin);\r\n#        app.add_plugins(LevelBoundsPlugin);\r\n#        app.add_plugins(MathPlugin);\r\n#        app.add_plugins(MemoryPlugin);\r\n#        app.add_plugins(PauseToolPlugin);\r\n#        app.add_plugins(PhysicsDebugPlugin);\r\n#        app.add_plugins(PhysicsPlugin);\r\n#        app.add_plugins(PointerPlugin);\r\n#        app.add_plugins(PointerTypesPlugin);\r\n#        // app.add_plugins(PositionTextPlugin);\r\n#        app.add_plugins(PressurePlatePlugin);\r\n#        app.add_plugins(ScreenPlugin);\r\n#        app.add_plugins(ScreenUpdatePlugin);\r\n#        app.add_plugins(SprintToolPlugin);\r\n#        app.add_plugins(SprintToolTypesPlugin);\r\n#        app.add_plugins(TaskbarPlugin);\r\n#        app.add_plugins(ToolbeltPlugin);\r\n#        app.add_plugins(ToolbeltTypesPlugin);\r\n#        app.add_plugins(ToolPlugin);\r\n#        app.add_plugins(WallpaperPlugin);\r\n#\r\n#        // must be before the default plugins\r\n#        app.add_plugins(EmbeddedAssetPlugin {\r\n#            mode: bevy_embedded_assets::PluginMode::ReplaceDefault,\r\n#        });\r\n#\r\n#        #[cfg(debug_assertions)]\r\n#        let log_plugin = LogPlugin {\r\n#            level: bevy::log::Level::DEBUG,\r\n#            filter: \"info,wgpu_core=warn,wgpu_hal=warn,bevy_ecs=info,cursor_hero=debug\".into(),\r\n#            // filter: \"debug,wgpu_core=warn,wgpu_hal=warn,bevy_ecs=info,cursor_hero=debug\".into(),\r\n#        };\r\n#        #[cfg(not(debug_assertions))]\r\n#        let log_plugin = LogPlugin {\r\n#            level: bevy::log::Level::INFO,\r\n#            filter: \"info,wgpu_core=warn,wgpu_hal=warn\".into(),\r\n#        };\r\n#        const AUDIO_SCALE: f32 = 1. / 100.0;\r\n#        let version = match app.world.get_resource::<Version>() {\r\n#            Some(version) => version.0.clone(),\r\n#            None => {\r\n#                warn!(\"Version resource not found\");\r\n#                \"Unknown\".to_string()\r\n#            }\r\n#        };\r\n#        app.add_plugins(\r\n#            DefaultPlugins\r\n#                .set(ImagePlugin::default_nearest())\r\n#                .set(AudioPlugin {\r\n#                    spatial_scale: SpatialScale::new_2d(AUDIO_SCALE),\r\n#                    ..default()\r\n#                })\r\n#                .set(WindowPlugin {\r\n#                    primary_window: Some(Window {\r\n#                        transparent: true,\r\n#                        title: format!(\"Cursor Hero v{}\", version),\r\n#                        resizable: true,\r\n#                        ..default()\r\n#                    }),\r\n#                    ..default()\r\n#                })\r\n#                .set(log_plugin)\r\n#                .build(),\r\n#        );\r\n#\r\n#        // must be after the default plugins\r\n#        app.add_plugins(\r\n#            WorldInspectorPlugin::default().run_if(input_toggle_active(false, KeyCode::Grave)),\r\n#        );\r\n#        app.add_plugins(FrameTimeDiagnosticsPlugin);\r\n#    }\r\n#}\r\n#\r\n#endregion\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\voice_to_text\\src\\voice_to_text_worker_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse crossbeam_channel::bounded;\r\nuse crossbeam_channel::Receiver;\r\nuse crossbeam_channel::Sender;\r\nuse cursor_hero_secret_types::secrets_types::SecretString;\r\nuse cursor_hero_voice_to_text_types::prelude::*;\r\nuse std::thread;\r\nuse std::time::Duration;\r\nuse std::time::Instant;\r\n\r\npub struct VoiceToTextWorkerPlugin;\r\n\r\nimpl Plugin for VoiceToTextWorkerPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Startup, create_worker_thread);\r\n        app.add_systems(Update, events_to_bridge);\r\n        app.add_systems(Update, bridge_to_events);\r\n    }\r\n}\r\n\r\n#[derive(Debug)]\r\npub(crate) enum GameboundMessage {\r\n    Pong { status: VoiceToTextStatus },\r\n    Starting { api_key: SecretString },\r\n    TranscriptionReceived { transcription: String },\r\n}\r\n\r\n#[derive(Debug)]\r\nenum ThreadboundMessage {\r\n    Ping,\r\n    Startup,\r\n    SetListening {\r\n        listening: bool,\r\n        api_key: SecretString,\r\n    },\r\n    ConnectReceiver {\r\n        api_key: SecretString,\r\n    },\r\n}\r\n\r\n#[derive(Resource)]\r\nstruct Bridge {\r\n    pub sender: Sender<ThreadboundMessage>,\r\n    pub receiver: Receiver<GameboundMessage>,\r\n}\r\n\r\nfn create_worker_thread(mut commands: Commands) {\r\n    let (game_tx, game_rx) = bounded::<_>(10);\r\n    let (thread_tx, thread_rx) = bounded::<_>(10);\r\n    commands.insert_resource(Bridge {\r\n        sender: thread_tx,\r\n        receiver: game_rx,\r\n    });\r\n\r\n    let game_tx_clone = game_tx.clone();\r\n    thread::Builder::new()\r\n        .name(\"Voice2Text status thread\".to_string())\r\n        .spawn(move || {\r\n            let rt = tokio::runtime::Runtime::new().unwrap();\r\n            rt.block_on(async {\r\n                let game_tx = game_tx_clone;\r\n                loop {\r\n                    let msg = match thread_rx.recv() {\r\n                        Ok(msg) => msg,\r\n                        Err(_) => {\r\n                            error!(\"Threadbound channel failure, exiting\");\r\n                            break;\r\n                        }\r\n                    };\r\n                    match msg {\r\n                        ThreadboundMessage::Ping => {\r\n                            debug!(\"Worker received ping request, pinging VoiceToText API\");\r\n                            let status = match crate::voice_to_text::get_status().await {\r\n                                Ok(status) => status,\r\n                                Err(e) => {\r\n                                    error!(\"Failed to get status: {:?}\", e);\r\n                                    VoiceToTextStatus::Unknown\r\n                                }\r\n                            };\r\n                            if let Err(e) = game_tx.send(GameboundMessage::Pong { status }) {\r\n                                error!(\"Gamebound channel failure, exiting: {}\", e);\r\n                                break;\r\n                            }\r\n                        }\r\n                        ThreadboundMessage::Startup => {\r\n                            debug!(\"Worker received startup request, starting VoiceToText API\");\r\n                            match crate::voice_to_text::start() {\r\n                                Ok(api_key) => {\r\n                                    debug!(\"VoiceToText API started successfully\");\r\n                                    if let Err(e) =\r\n                                        game_tx.send(GameboundMessage::Starting { api_key })\r\n                                    {\r\n                                        error!(\"Gamebound channel failure, exiting: {}\", e);\r\n                                        break;\r\n                                    }\r\n                                }\r\n                                Err(e) => {\r\n                                    error!(\"Failed to start: {:?}\", e);\r\n                                }\r\n                            };\r\n                        }\r\n                        ThreadboundMessage::SetListening { listening, api_key } => {\r\n                            debug!(\"Worker received set listening request: {}\", listening);\r\n                            match crate::voice_to_text::set_listening(listening, api_key).await {\r\n                                Ok(()) => {\r\n                                    info!(\r\n                                        \"VoiceToText API set listening={} successfully\",\r\n                                        listening\r\n                                    );\r\n                                }\r\n                                Err(e) => {\r\n                                    error!(\"Failed to set listening: {:?}\", e);\r\n                                }\r\n                            }\r\n                        }\r\n                        ThreadboundMessage::ConnectReceiver { api_key } => {\r\n                            info!(\"Worker received connect receiver request\");\r\n                            match crate::voice_to_text::connect_receiver(game_tx.clone(), api_key)\r\n                                .await\r\n                            {\r\n                                Ok(()) => {\r\n                                    info!(\"VoiceToText API connected receiver successfully\");\r\n                                }\r\n                                Err(e) => {\r\n                                    error!(\"Failed to connect receiver: {:?}\", e);\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    std::thread::sleep(std::time::Duration::from_millis(50));\r\n                }\r\n            });\r\n        })\r\n        .expect(\"Failed to spawn thread\");\r\n}\r\n\r\nfn events_to_bridge(\r\n    bridge: ResMut<Bridge>,\r\n    mut ping_events: EventReader<VoiceToTextPingEvent>,\r\n    mut command_events: EventReader<VoiceToTextCommandEvent>,\r\n) {\r\n    // Detect ping requests\r\n    for event in ping_events.read() {\r\n        let VoiceToTextPingEvent::Ping = event else {\r\n            continue;\r\n        };\r\n        let msg = ThreadboundMessage::Ping;\r\n        debug!(\"Sending bridge message: {:?}\", msg);\r\n        if let Err(e) = bridge.sender.send(msg) {\r\n            error!(\"Threadbound channel failure: {}\", e);\r\n        }\r\n    }\r\n\r\n    for event in command_events.read() {\r\n        let msg = match event {\r\n            VoiceToTextCommandEvent::Startup => ThreadboundMessage::Startup,\r\n            VoiceToTextCommandEvent::SetListening { listening, api_key } => {\r\n                ThreadboundMessage::SetListening {\r\n                    listening: *listening,\r\n                    api_key: api_key.clone(),\r\n                }\r\n            }\r\n            VoiceToTextCommandEvent::ConnectReceiver { api_key } => {\r\n                ThreadboundMessage::ConnectReceiver {\r\n                    api_key: api_key.clone(),\r\n                }\r\n            }\r\n        };\r\n        debug!(\"Sending bridge message: {:?}\", msg);\r\n        if let Err(e) = bridge.sender.send(msg) {\r\n            error!(\"Threadbound channel failure: {}\", e);\r\n        }\r\n    }\r\n}\r\n\r\nfn bridge_to_events(\r\n    bridge: ResMut<Bridge>,\r\n    mut ping_events: EventWriter<VoiceToTextPingEvent>,\r\n    mut status_events: EventWriter<VoiceToTextStatusEvent>,\r\n    mut transcription_events: EventWriter<VoiceToTextTranscriptionEvent>,\r\n    mut current_status: ResMut<VoiceToTextStatus>,\r\n) {\r\n    for msg in bridge.receiver.try_iter() {\r\n        match msg {\r\n            GameboundMessage::Pong { status } => {\r\n                let event = VoiceToTextPingEvent::Pong { status };\r\n                debug!(\"Received bridge response, sending game event {:?}\", event);\r\n                ping_events.send(event);\r\n            }\r\n            GameboundMessage::Starting { api_key } => {\r\n                let new_status = VoiceToTextStatus::Starting {\r\n                    instant: Instant::now(),\r\n                    timeout: Duration::from_secs(60),\r\n                    api_key: api_key.clone(),\r\n                };\r\n                let event = VoiceToTextStatusEvent::Changed {\r\n                    old_status: current_status.clone(),\r\n                    new_status: new_status.clone(),\r\n                };\r\n                debug!(\"Received bridge response, sending game event {:?}\", event);\r\n                status_events.send(event);\r\n\r\n                *current_status = new_status;\r\n            }\r\n            GameboundMessage::TranscriptionReceived { transcription } => {\r\n                let event = VoiceToTextTranscriptionEvent::Received { transcription };\r\n                debug!(\"Received bridge response, sending game event {:?}\", event);\r\n                transcription_events.send(event);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\worker_types\\src\\lib.rs\r\n\r\n````rust\r\nmod worker_types;\r\nmod worker_types_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::worker_types::*;\r\n    pub use crate::worker_types_plugin::*;\r\n    pub use anyhow;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\winutils\\src\\win_screen_capture.rs\r\n\r\n````rust\r\n#![allow(unused_imports)]\r\n// most code from https://github.com/nashaofu/screenshots-rs/ commit 999faac06f85bd93638c2a9cda6cbb25ad9f5c73\r\n// my changes are MPLv2, original code is Apache 2.0\r\n// modifications aim to reduce redundant work for successive screen capture calls\r\n\r\n// might also be interesting:\r\n// https://github.com/rhinostream/win_desktop_duplication/tree/master\r\n// https://github.com/rustdesk/rustdesk\r\n// https://github.com/RustBuddies/desktop-sharing\r\n// https://github.com/mira-screen-share/sharer/blob/main/src/capture/wgc/display.rs\r\n\r\n#[cfg(target_arch = \"x86\")]\r\nuse std::arch::x86::_mm_shuffle_epi8;\r\nuse std::arch::x86_64::__m128i;\r\nuse std::arch::x86_64::_mm_loadu_si128;\r\nuse std::arch::x86_64::_mm_setr_epi8;\r\n#[cfg(target_arch = \"x86_64\")]\r\nuse std::arch::x86_64::_mm_shuffle_epi8;\r\nuse std::arch::x86_64::_mm_storeu_si128;\r\nuse std::sync::Arc;\r\n\r\nuse anyhow::anyhow;\r\nuse anyhow::Result;\r\nuse bevy::math::IRect;\r\nuse cursor_hero_bevy::prelude::LeftI;\r\nuse cursor_hero_bevy::prelude::TopI;\r\nuse cursor_hero_bevy::prelude::TopLeftI;\r\nuse cursor_hero_bevy::prelude::TranslateIVec2;\r\nuse cursor_hero_math::prelude::bgra_to_rgba;\r\n// use display_info::DisplayInfo;\r\n// use fxhash::hash32;\r\nuse image::RgbaImage;\r\nuse std::mem;\r\nuse std::ops::Deref;\r\nuse std::ptr;\r\nuse std::rc::Rc;\r\nuse widestring::U16CString;\r\nuse windows::core::PCWSTR;\r\nuse windows::Win32::Foundation::BOOL;\r\nuse windows::Win32::Foundation::LPARAM;\r\nuse windows::Win32::Foundation::RECT;\r\nuse windows::Win32::Graphics::Gdi::BitBlt;\r\nuse windows::Win32::Graphics::Gdi::CreateCompatibleBitmap;\r\nuse windows::Win32::Graphics::Gdi::CreateCompatibleDC;\r\nuse windows::Win32::Graphics::Gdi::CreateDCW;\r\nuse windows::Win32::Graphics::Gdi::DeleteDC;\r\nuse windows::Win32::Graphics::Gdi::DeleteObject;\r\nuse windows::Win32::Graphics::Gdi::EnumDisplayMonitors;\r\nuse windows::Win32::Graphics::Gdi::GetDIBits;\r\nuse windows::Win32::Graphics::Gdi::GetMonitorInfoW;\r\nuse windows::Win32::Graphics::Gdi::GetObjectW;\r\nuse windows::Win32::Graphics::Gdi::SelectObject;\r\nuse windows::Win32::Graphics::Gdi::SetStretchBltMode;\r\nuse windows::Win32::Graphics::Gdi::StretchBlt;\r\nuse windows::Win32::Graphics::Gdi::BITMAP;\r\nuse windows::Win32::Graphics::Gdi::BITMAPINFO;\r\nuse windows::Win32::Graphics::Gdi::BITMAPINFOHEADER;\r\nuse windows::Win32::Graphics::Gdi::DIB_RGB_COLORS;\r\nuse windows::Win32::Graphics::Gdi::HBITMAP;\r\nuse windows::Win32::Graphics::Gdi::HDC;\r\nuse windows::Win32::Graphics::Gdi::HMONITOR;\r\nuse windows::Win32::Graphics::Gdi::MONITORINFOEXW;\r\nuse windows::Win32::Graphics::Gdi::RGBQUAD;\r\nuse windows::Win32::Graphics::Gdi::SRCCOPY;\r\nuse windows::Win32::Graphics::Gdi::STRETCH_HALFTONE;\r\n\r\nuse cursor_hero_metrics::Metrics;\r\n\r\nuse crate::ToBevyIRect;\r\n\r\n//////////////////////\r\n/// GET MONITOR INFOS\r\n//////////////////////\r\npub type MonitorId = u32;\r\n\r\n#[derive(Debug)]\r\npub struct MonitorInfo {\r\n    pub id: MonitorId,\r\n    pub name: String,\r\n    pub rect: IRect,\r\n    pub work_area: IRect, // the area of the monitor not covered by the taskbar\r\n    pub is_primary: bool,\r\n}\r\n\r\npub fn get_monitor_infos() -> Result<Vec<MonitorInfo>> {\r\n    // box it up so we can pass it to the callback\r\n    let results: *mut Vec<MONITORINFOEXW> = Box::into_raw(Box::default());\r\n\r\n    // use proc method to iterate monitors and collect into results vec\r\n    unsafe {\r\n        EnumDisplayMonitors(\r\n            HDC::default(),\r\n            None,\r\n            Some(monitor_enum_proc),\r\n            LPARAM(results as isize),\r\n        )\r\n        .ok()?;\r\n    };\r\n\r\n    // convert results back into a vec\r\n    let results = unsafe { &Box::from_raw(results) };\r\n\r\n    // convert vec of MONITORINFOEXW into vec of MonitorInfo\r\n    let results = results\r\n        .iter()\r\n        .map(|info| {\r\n            let sz_device_ptr = info.szDevice.as_ptr();\r\n            let sz_device_string =\r\n                unsafe { U16CString::from_ptr_str(sz_device_ptr).to_string_lossy() };\r\n            MonitorInfo {\r\n                id: fxhash::hash32(sz_device_string.as_bytes()), // same algorithm as screen crate\r\n                name: sz_device_string,\r\n                rect: info.monitorInfo.rcMonitor.to_bevy_irect(),\r\n                work_area: info.monitorInfo.rcWork.to_bevy_irect(),\r\n                is_primary: info.monitorInfo.dwFlags == 1,\r\n            }\r\n        })\r\n        .collect::<Vec<MonitorInfo>>();\r\n    Ok(results)\r\n}\r\n\r\nextern \"system\" fn monitor_enum_proc(\r\n    h_monitor: HMONITOR,\r\n    _: HDC,\r\n    _: *mut RECT,\r\n    data: LPARAM,\r\n) -> BOOL {\r\n    let results = unsafe { Box::from_raw(data.0 as *mut Vec<MONITORINFOEXW>) };\r\n    let results = Box::leak(results);\r\n\r\n    match get_monitor_info_exw(h_monitor) {\r\n        Ok(monitor_info_exw) => {\r\n            results.push(monitor_info_exw);\r\n            BOOL::from(true)\r\n        }\r\n        Err(_) => BOOL::from(false),\r\n    }\r\n}\r\n\r\nfn get_monitor_info_exw(h_monitor: HMONITOR) -> Result<MONITORINFOEXW> {\r\n    let mut monitor_info_exw: MONITORINFOEXW = unsafe { mem::zeroed() };\r\n    monitor_info_exw.monitorInfo.cbSize = mem::size_of::<MONITORINFOEXW>() as u32;\r\n    let monitor_info_exw_ptr = <*mut _>::cast(&mut monitor_info_exw);\r\n\r\n    unsafe {\r\n        GetMonitorInfoW(h_monitor, monitor_info_exw_ptr).ok()?;\r\n    };\r\n    Ok(monitor_info_exw)\r\n}\r\n\r\n//////////////////\r\n/// GET MONITORS\r\n//////////////////\r\npub struct Monitor {\r\n    pub info: MonitorInfo,\r\n    device_context: HDC,\r\n}\r\n\r\npub fn get_all_monitors() -> Result<Vec<Monitor>> {\r\n    let monitor_infos = get_monitor_infos()?;\r\n    let mut monitors = Vec::new();\r\n\r\n    for monitor_info in monitor_infos {\r\n        // intermediate variables are required to ensure the pointer contents remain in scope\r\n        let a = U16CString::from_str(&monitor_info.name)?;\r\n        let b = a.as_ptr();\r\n        let name_pcwstr = PCWSTR(b);\r\n        let device_context =\r\n            unsafe { CreateDCW(name_pcwstr, name_pcwstr, PCWSTR(ptr::null()), None) };\r\n\r\n        monitors.push(Monitor {\r\n            info: monitor_info,\r\n            device_context,\r\n        });\r\n    }\r\n\r\n    Ok(monitors)\r\n}\r\n\r\n/////////////////////////////\r\n/// MONITOR REGION CAPTURER\r\n/////////////////////////////\r\n\r\npub struct MonitorRegionCapturer {\r\n    pub monitor: Arc<Monitor>,\r\n    pub capture_region: IRect,\r\n    device_context: HDC,\r\n    bitmap: HBITMAP,\r\n}\r\n\r\npub fn get_full_monitor_capturers() -> Result<Vec<MonitorRegionCapturer>> {\r\n    let monitors = get_all_monitors()?;\r\n    let mut capturers = Vec::new();\r\n\r\n    for monitor in monitors {\r\n        let region = monitor.info.rect;\r\n        let capturer = get_monitor_capturer(Arc::new(monitor), region);\r\n        capturers.push(capturer);\r\n    }\r\n\r\n    Ok(capturers)\r\n}\r\n\r\npub fn get_monitor_capturer(monitor: Arc<Monitor>, capture_region: IRect) -> MonitorRegionCapturer {\r\n    let capture_device_context = unsafe { CreateCompatibleDC(monitor.device_context) };\r\n    let bitmap = unsafe {\r\n        CreateCompatibleBitmap(\r\n            monitor.device_context,\r\n            capture_region.width(),\r\n            capture_region.height(),\r\n        )\r\n    };\r\n\r\n    unsafe {\r\n        SelectObject(capture_device_context, bitmap);\r\n        SetStretchBltMode(monitor.device_context, STRETCH_HALFTONE);\r\n    };\r\n\r\n    MonitorRegionCapturer {\r\n        monitor,\r\n        device_context: capture_device_context,\r\n        bitmap,\r\n        capture_region,\r\n    }\r\n}\r\n\r\nimpl Drop for MonitorRegionCapturer {\r\n    fn drop(&mut self) {\r\n        unsafe {\r\n            DeleteObject(self.bitmap);\r\n            DeleteDC(self.device_context);\r\n        }\r\n    }\r\n}\r\nimpl MonitorRegionCapturer {\r\n    // pub fn capture(&self) -> Result<RgbaImage> {\r\n    pub fn capture(&self, metrics: &mut Option<Metrics>) -> Result<RgbaImage> {\r\n        // todo: try https://learn.microsoft.com/en-us/windows/win32/api/dxgi1_2/nf-dxgi1_2-idxgioutputduplication-acquirenextframe\r\n        unsafe {\r\n            if let Some(metrics) = metrics {\r\n                metrics.begin(\"blit\");\r\n            }\r\n            StretchBlt(\r\n                self.device_context,\r\n                0,\r\n                0,\r\n                self.capture_region.width(),\r\n                self.capture_region.height(),\r\n                self.monitor.device_context,\r\n                self.monitor.info.rect.left() - self.capture_region.left(),\r\n                self.monitor.info.rect.top() - self.capture_region.top(),\r\n                self.capture_region.width(),\r\n                self.capture_region.height(),\r\n                SRCCOPY,\r\n            )\r\n            .ok()?;\r\n            if let Some(metrics) = metrics {\r\n                metrics.end(\"blit\");\r\n            }\r\n        };\r\n\r\n        let mut bitmap_info = BITMAPINFO {\r\n            bmiHeader: BITMAPINFOHEADER {\r\n                biSize: mem::size_of::<BITMAPINFOHEADER>() as u32,\r\n                biWidth: self.capture_region.width(),\r\n                biHeight: -self.capture_region.height(),\r\n                biPlanes: 1,\r\n                biBitCount: 32,\r\n                biCompression: 0,\r\n                biSizeImage: 0,\r\n                biXPelsPerMeter: 0,\r\n                biYPelsPerMeter: 0,\r\n                biClrUsed: 0,\r\n                biClrImportant: 0,\r\n            },\r\n            bmiColors: [RGBQUAD::default(); 1],\r\n        };\r\n\r\n        let mut data =\r\n            vec![0u8; (self.capture_region.width() * self.capture_region.height()) as usize * 4];\r\n        let buf_prt = data.as_ptr() as *mut _;\r\n\r\n        if let Some(metrics) = metrics {\r\n            metrics.begin(\"getdibits\");\r\n        }\r\n        let err = unsafe {\r\n            GetDIBits(\r\n                self.device_context,\r\n                self.bitmap,\r\n                0,\r\n                self.capture_region.height() as u32,\r\n                Some(buf_prt),\r\n                &mut bitmap_info,\r\n                DIB_RGB_COLORS,\r\n            ) == 0\r\n        };\r\n        if let Some(metrics) = metrics {\r\n            metrics.end(\"getdibits\");\r\n        }\r\n\r\n        if err {\r\n            return Err(anyhow!(\"Get RGBA data failed\"));\r\n        }\r\n\r\n        let mut bitmap = BITMAP::default();\r\n        let bitmap_ptr = <*mut _>::cast(&mut bitmap);\r\n\r\n        if let Some(metrics) = metrics {\r\n            metrics.begin(\"getobject\");\r\n        }\r\n        unsafe {\r\n            // Get the BITMAP from the HBITMAP.\r\n            GetObjectW(\r\n                self.bitmap,\r\n                mem::size_of::<BITMAP>() as i32,\r\n                Some(bitmap_ptr),\r\n            );\r\n        }\r\n        if let Some(metrics) = metrics {\r\n            metrics.end(\"getobject\");\r\n        }\r\n\r\n        if let Some(metrics) = metrics {\r\n            metrics.begin(\"shuffle\");\r\n        }\r\n        bgra_to_rgba(data.as_mut_slice());\r\n        if let Some(metrics) = metrics {\r\n            metrics.end(\"shuffle\");\r\n        }\r\n\r\n        let data = RgbaImage::from_vec(\r\n            self.capture_region.width() as u32,\r\n            self.capture_region.height() as u32,\r\n            data,\r\n        );\r\n        data.ok_or_else(|| anyhow!(\"Invalid image data\"))\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\n#[allow(unused_imports)]\r\nmod tests {\r\n    use bevy::math::IVec2;\r\n\r\n    use super::*;\r\n\r\n    #[test]\r\n    fn names() {\r\n        get_monitor_infos().unwrap().iter().for_each(|info| {\r\n            println!(\"{:?}\", info);\r\n        });\r\n    }\r\n\r\n    #[test]\r\n    fn full_screenshots() {\r\n        let capturers = get_full_monitor_capturers().unwrap();\r\n        std::fs::create_dir_all(\"target/capture\").unwrap();\r\n\r\n        capturers.iter().for_each(|capturer| {\r\n            let capture = capturer.capture(&mut None).unwrap();\r\n            let mon_name_good = capturer.monitor.info.name.replace(r\"\\\\.\\\", \"\");\r\n            let path = format!(\"target/capture/full-{}.png\", mon_name_good);\r\n            capture.save(path).unwrap();\r\n        });\r\n    }\r\n\r\n    #[test]\r\n    fn region_screenshots() {\r\n        let monitors = get_all_monitors().unwrap();\r\n        let mut capturers = Vec::new();\r\n\r\n        for monitor in monitors {\r\n            let p0 = monitor.info.rect.top_left();\r\n            let p1 = p0 + IVec2::new(100, 100);\r\n            let region = IRect::from_corners(p0, p1);\r\n            let capturer = get_monitor_capturer(Arc::new(monitor), region);\r\n            capturers.push(capturer);\r\n        }\r\n        std::fs::create_dir_all(\"target/capture\").unwrap();\r\n\r\n        capturers.iter().for_each(|capturer| {\r\n            let capture = capturer.capture(&mut None).unwrap();\r\n            let mon_name_good = capturer.monitor.info.name.replace(r\"\\\\.\\\", \"\");\r\n            let path = format!(\"target/capture/region-{}.png\", mon_name_good);\r\n            capture.save(path).unwrap();\r\n        });\r\n    }\r\n\r\n    #[test]\r\n    fn capture_avg() {\r\n        let capturers = get_full_monitor_capturers().unwrap();\r\n        std::fs::create_dir_all(\"target/capture\").unwrap();\r\n\r\n        for _ in 0..100 {\r\n            capturers.iter().for_each(|capturer| {\r\n                let capture = capturer.capture(&mut None).unwrap();\r\n                let (mut tot_r, mut tot_g, mut tot_b) = (0, 0, 0);\r\n\r\n                for pixel in capture.enumerate_pixels() {\r\n                    let image::Rgba([r, g, b, _]) = pixel.2; // Destructure the Rgba struct\r\n                    tot_r += *r as u64;\r\n                    tot_g += *g as u64;\r\n                    tot_b += *b as u64;\r\n                }\r\n                let size = capture.iter().count() as u64;\r\n                print!(\r\n                    \"{} -- avg: {:?}\\t\",\r\n                    capturer.monitor.info.name,\r\n                    (tot_r / size, tot_g / size, tot_b / size)\r\n                );\r\n            });\r\n            print!(\"\\n\");\r\n            std::thread::sleep(std::time::Duration::from_millis(100));\r\n        }\r\n    }\r\n\r\n    #[test]\r\n    fn screenshot_speed() {\r\n        let capturers = get_full_monitor_capturers().unwrap();\r\n        let mut durations = Vec::new();\r\n        for _ in 0..100 {\r\n            capturers.iter().for_each(|capturer| {\r\n                let start = std::time::Instant::now();\r\n                let _ = capturer.capture(&mut None).unwrap();\r\n                let duration = start.elapsed();\r\n                durations.push(duration.as_millis());\r\n            });\r\n            std::thread::sleep(std::time::Duration::from_millis(1));\r\n        }\r\n        let avg = durations.iter().sum::<u128>() / durations.len() as u128;\r\n        println!(\"avg: {:?}ms\", avg);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\use cases\\run test.md\r\n\r\n````markdown\r\ngiven a rust file open, add a keyboard shortcut to run the test closest to the cursor\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\wallpaper\\src\\wallpaper_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse cursor_hero_environment_types::prelude::*;\r\n\r\npub struct WallpaperPlugin;\r\n\r\nimpl Plugin for WallpaperPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<Wallpaper>();\r\n        app.add_systems(Update, spawn_wallpaper);\r\n    }\r\n}\r\n\r\n#[derive(Component, Debug, Reflect)]\r\npub struct Wallpaper;\r\n\r\nfn spawn_wallpaper(\r\n    mut commands: Commands,\r\n    mut environment_events: EventReader<PopulateEnvironmentEvent>,\r\n    environment_query: Query<&AgentEnvironment>,\r\n    asset_server: Res<AssetServer>,\r\n) {\r\n    for event in environment_events.read() {\r\n        if !environment_query.contains(event.environment_id) {\r\n            continue;\r\n        }\r\n        info!(\r\n            \"Spawning wallpaper for game environment {:?}\",\r\n            event.environment_id\r\n        );\r\n        commands\r\n            .entity(event.environment_id)\r\n            .with_children(|parent| {\r\n                parent.spawn((\r\n                    SpriteBundle {\r\n                        sprite: Sprite {\r\n                            custom_size: Some(Vec2::new(1920.0, 1080.0)),\r\n                            anchor: bevy::sprite::Anchor::TopLeft,\r\n                            ..default()\r\n                        },\r\n                        texture: asset_server.load(\"textures/environment/game/wallpaper.png\"),\r\n                        transform: Transform::from_translation(Vec3::new(0.0, 0.0, 1.0)),\r\n                        ..default()\r\n                    },\r\n                    Name::new(\"Wallpaper\"),\r\n                ));\r\n            });\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\use cases\\structural tools.md\r\n\r\n````markdown\r\nspecify method signature of a system before having copilot build the body\r\n- verbal description of the intent of the system and any method signature suggestions\r\n- recommender system provide a list of parameters that sound relevant\r\n  - mut Commands\r\n  - event readers\r\n  - event writers\r\n  - tool query\r\n  - toolbelt query\r\n  - character query\r\n  - pointer query\r\n  - camera query\r\n  - local parameters\r\n  - resources\r\n  - properties\r\n    - Components\r\n      - Tool\r\n      - Transform\r\n    - Filters\r\n      - With, Without\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\voice_to_text\\src\\lib.rs\r\n\r\n````rust\r\n#![feature(let_chains)]\r\npub mod voice_to_text;\r\npub mod voice_to_text_button_plugin;\r\npub mod voice_to_text_ping_plugin;\r\npub mod voice_to_text_plugin;\r\npub mod voice_to_text_worker_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::voice_to_text_plugin::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\window_position_types\\src\\window_position_types.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse bevy::window::WindowMode;\r\nuse bevy::window::WindowResolution;\r\n\r\n#[derive(Debug, Reflect)]\r\npub enum HostWindowPosition {\r\n    Fullscreen {\r\n        monitor: u32,\r\n    },\r\n    Corner {\r\n        corner: cursor_hero_math::prelude::Corner,\r\n        monitor: u32,\r\n    },\r\n}\r\n\r\n#[derive(Component, Reflect, Default)]\r\npub struct WindowPositionLoadoutSwitcherTool;\r\n\r\n#[derive(Component, Reflect)]\r\npub struct WindowPositionTool {\r\n    pub window_position: HostWindowPosition,\r\n}\r\n\r\n#[derive(Event, Reflect, Debug, Clone)]\r\npub struct WindowPositionCommand {\r\n    pub window: Entity,\r\n    pub mode: Option<WindowMode>,\r\n    pub resolution: Option<WindowResolution>,\r\n    pub position: Option<WindowPosition>,\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\winutils\\src\\win_wallpaper.rs\r\n\r\n````rust\r\nuse std::env;\r\nuse std::ffi::OsString;\r\nuse std::os::raw::c_void;\r\nuse std::os::windows::ffi::OsStringExt;\r\nuse std::path::PathBuf;\r\nuse windows::Win32::UI::WindowsAndMessaging::SystemParametersInfoW;\r\nuse windows::Win32::UI::WindowsAndMessaging::SPIF_UPDATEINIFILE;\r\nuse windows::Win32::UI::WindowsAndMessaging::SPI_GETDESKWALLPAPER;\r\n/// This gets the path to the file at the time the user set the wallpaper.\r\n/// The file may have moved since then.\r\npub fn get_wallpaper_path() -> Result<OsString, windows::core::Error> {\r\n    let mut buffer = vec![0u16; 32768]; // theoretical max path after increase\r\n    unsafe {\r\n        SystemParametersInfoW(\r\n            SPI_GETDESKWALLPAPER,\r\n            buffer.len() as u32,\r\n            Some(buffer.as_mut_ptr() as *mut c_void),\r\n            SPIF_UPDATEINIFILE,\r\n        )\r\n    }?;\r\n\r\n    // Find the position of the first null character\r\n    let len = buffer.iter().position(|&c| c == 0).unwrap_or(buffer.len());\r\n\r\n    // Create a slice of the buffer up to the found position\r\n    let trimmed_buffer = &buffer[..len];\r\n\r\n    Ok(OsString::from_wide(trimmed_buffer))\r\n}\r\n\r\npub fn get_transcoded_wallpaper_path() -> Result<PathBuf, env::VarError> {\r\n    let app_data = env::var(\"APPDATA\")?; // Get the value of the APPDATA environment variable\r\n    let themes_path =\r\n        PathBuf::from(app_data).join(\"Microsoft\\\\Windows\\\\Themes\\\\TranscodedWallpaper\");\r\n    Ok(themes_path)\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    #[test]\r\n    fn test_get_wallpaper_path() {\r\n        let path = super::get_wallpaper_path();\r\n        println!(\"Wallpaper path: {:?}\", path);\r\n        assert!(path.is_ok());\r\n    }\r\n\r\n    #[test]\r\n    fn test_get_transcoded_wallpaper_path() {\r\n        let path = super::get_transcoded_wallpaper_path();\r\n        println!(\"Transcoded wallpaper path: {:?}\", path);\r\n        assert!(path.is_ok());\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\winutils\\src\\win_events.rs\r\n\r\n````rust\r\nuse bevy::math::IRect;\r\nuse bevy::math::IVec2;\r\nuse bevy::prelude::default;\r\nuse crossbeam_channel::Receiver;\r\nuse crossbeam_channel::Sender;\r\nuse once_cell::sync::Lazy;\r\nuse std::collections::HashMap;\r\nuse std::sync::Mutex;\r\nuse windows::core::PCWSTR;\r\nuse windows::Win32::Devices::HumanInterfaceDevice::HID_USAGE_GENERIC_KEYBOARD;\r\nuse windows::Win32::Devices::HumanInterfaceDevice::HID_USAGE_GENERIC_MOUSE;\r\nuse windows::Win32::Devices::HumanInterfaceDevice::HID_USAGE_PAGE_GENERIC;\r\nuse windows::Win32::Foundation::HWND;\r\nuse windows::Win32::Foundation::*;\r\nuse windows::Win32::System::Variant::VARIANT;\r\nuse windows::Win32::System::Variant::VT_I4;\r\nuse windows::Win32::UI::Accessibility::*;\r\nuse windows::Win32::UI::Input::GetRawInputData;\r\nuse windows::Win32::UI::Input::RegisterRawInputDevices;\r\nuse windows::Win32::UI::Input::HRAWINPUT;\r\nuse windows::Win32::UI::Input::RAWINPUT;\r\nuse windows::Win32::UI::Input::RAWINPUTDEVICE;\r\nuse windows::Win32::UI::Input::RAWINPUTHEADER;\r\nuse windows::Win32::UI::Input::RIDEV_INPUTSINK;\r\nuse windows::Win32::UI::Input::RID_INPUT;\r\nuse windows::Win32::UI::Input::RIM_TYPEKEYBOARD;\r\nuse windows::Win32::UI::Input::RIM_TYPEMOUSE;\r\nuse windows::Win32::UI::WindowsAndMessaging::EVENT_OBJECT_CREATE;\r\nuse windows::Win32::UI::WindowsAndMessaging::EVENT_OBJECT_DESTROY;\r\nuse windows::Win32::UI::WindowsAndMessaging::EVENT_OBJECT_HIDE;\r\nuse windows::Win32::UI::WindowsAndMessaging::EVENT_OBJECT_LIVEREGIONCHANGED;\r\nuse windows::Win32::UI::WindowsAndMessaging::EVENT_OBJECT_STATECHANGE;\r\nuse windows::Win32::UI::WindowsAndMessaging::EVENT_OBJECT_VALUECHANGE;\r\nuse windows::Win32::UI::WindowsAndMessaging::*;\r\n\r\n#[derive(Debug)]\r\npub enum ProcMessage {\r\n    MouseMoved(IVec2),\r\n    KeyDown(char),\r\n    Event {\r\n        event_name: String,\r\n        name: Option<String>,\r\n        role: Option<String>,\r\n        state: Option<String>,\r\n        bounds: Option<IRect>,\r\n    },\r\n}\r\n\r\nstatic SENDERS: Lazy<Mutex<HashMap<isize, Sender<ProcMessage>>>> =\r\n    Lazy::new(|| Mutex::new(HashMap::new()));\r\nstatic HWND_TO_HOOK: Lazy<Mutex<HashMap<isize, isize>>> = Lazy::new(|| Mutex::new(HashMap::new()));\r\nfn store_sender_for_identifier(\r\n    identifier: isize,\r\n    sender: Sender<ProcMessage>,\r\n) -> Result<(), &'static str> {\r\n    let mut senders = SENDERS.lock().map_err(|_| \"Failed to lock SENDERS map\")?;\r\n    senders.insert(identifier, sender);\r\n    Ok(())\r\n}\r\nfn get_sender_for_window(hwnd: HWND) -> Option<Sender<ProcMessage>> {\r\n    let senders = SENDERS.lock().ok()?;\r\n    senders.get(&hwnd.0).cloned()\r\n}\r\nfn get_sender_for_hook(hook: HWINEVENTHOOK) -> Option<Sender<ProcMessage>> {\r\n    let senders = SENDERS.lock().ok()?;\r\n    senders.get(&hook.0).cloned()\r\n}\r\nfn store_sender(\r\n    hwnd: HWND,\r\n    hook: HWINEVENTHOOK,\r\n    sender: Sender<ProcMessage>,\r\n) -> Result<(), &'static str> {\r\n    store_sender_for_identifier(hwnd.0, sender.clone())?;\r\n    store_sender_for_identifier(hook.0, sender)?;\r\n    Ok(())\r\n}\r\nfn drop_senders_for_window(hwnd: HWND) -> Result<(), &'static str> {\r\n    let mut senders = SENDERS.lock().map_err(|_| \"Failed to lock SENDERS map\")?;\r\n\r\n    // Remove the sender for the window\r\n    senders.remove(&hwnd.0);\r\n\r\n    // Get the hook for the window\r\n    let mut hook_map = HWND_TO_HOOK\r\n        .lock()\r\n        .map_err(|_| \"Failed to lock HWND_TO_HOOK map\")?;\r\n    if let Some(hook) = hook_map.remove(&hwnd.0) {\r\n        // Drop the sender for the hook\r\n        senders.remove(&hook);\r\n    }\r\n\r\n    Ok(())\r\n}\r\n\r\npub fn create_os_event_listener() -> Result<Receiver<ProcMessage>, windows::core::Error> {\r\n    let (tx, rx) = crossbeam_channel::unbounded();\r\n    std::thread::spawn(move || match create_window_and_do_message_loop(tx) {\r\n        Ok(()) => {\r\n            unreachable!(\"create_window_and_do_message_loop should never return Ok\");\r\n        }\r\n        Err(e) => {\r\n            eprintln!(\"Error in os_event_listener_thread: {:?}\", e);\r\n        }\r\n    });\r\n    Ok(rx)\r\n}\r\n\r\nfn create_window_and_do_message_loop(tx: Sender<ProcMessage>) -> Result<(), windows::core::Error> {\r\n    let hwnd = init_window()?;\r\n    // attach_tx_pointer(hwnd, tx.clone());\r\n    let hook = register_os_event_listener()?;\r\n    store_sender(hwnd, hook, tx).map_err(|e| windows::core::Error::new(E_FAIL, e.into()))?;\r\n\r\n    register_interest_in_mouse_with_os(hwnd.0)?;\r\n    register_interest_in_keyboard_with_os(hwnd.0)?;\r\n    unsafe {\r\n        let mut message = MSG::default();\r\n        println!(\"Starting message loop\");\r\n        while GetMessageA(&mut message, hwnd, 0, 0).as_bool() {\r\n            TranslateMessage(&message);\r\n            DispatchMessageA(&message);\r\n            // println!(\"ballin, got {:?}\", message);\r\n        }\r\n        DestroyWindow(hwnd)?;\r\n    }\r\n    Ok(())\r\n}\r\n\r\nfn register_os_event_listener() -> Result<HWINEVENTHOOK, windows::core::Error> {\r\n    unsafe {\r\n        match SetWinEventHook(\r\n            EVENT_MIN, // or specific event codes\r\n            EVENT_MAX, // or specific event codes\r\n            None,      // hmodWinEventProc\r\n            Some(os_event_procedure),\r\n            0, // idProcess\r\n            0, // idThread\r\n            WINEVENT_OUTOFCONTEXT,\r\n        ) {\r\n            HWINEVENTHOOK(0) => Err(windows::core::Error::new(\r\n                E_FAIL,\r\n                \"Failed to register interest in all events\".into(),\r\n            )),\r\n            x => Ok(x),\r\n        }\r\n    }\r\n}\r\n\r\nfn register_interest_in_mouse_with_os(hwnd: isize) -> Result<(), windows::core::Error> {\r\n    unsafe {\r\n        let device = RAWINPUTDEVICE {\r\n            usUsagePage: HID_USAGE_PAGE_GENERIC,\r\n            usUsage: HID_USAGE_GENERIC_MOUSE,\r\n            dwFlags: RIDEV_INPUTSINK,\r\n            hwndTarget: HWND(hwnd),\r\n        };\r\n        RegisterRawInputDevices(&[device], std::mem::size_of::<RAWINPUTDEVICE>() as u32)\r\n    }\r\n}\r\n\r\nfn register_interest_in_keyboard_with_os(hwnd: isize) -> Result<(), windows::core::Error> {\r\n    unsafe {\r\n        let device = RAWINPUTDEVICE {\r\n            usUsagePage: HID_USAGE_PAGE_GENERIC,\r\n            usUsage: HID_USAGE_GENERIC_KEYBOARD,\r\n            dwFlags: RIDEV_INPUTSINK,\r\n            hwndTarget: HWND(hwnd),\r\n        };\r\n        RegisterRawInputDevices(&[device], std::mem::size_of::<RAWINPUTDEVICE>() as u32)\r\n    }\r\n}\r\n\r\nfn init_window() -> Result<HWND, windows::core::Error> {\r\n    let class_name =\r\n        widestring::U16CString::from_str(\"bruh\").map_err(|_| windows::core::Error::OK)?;\r\n    let class_name_ptr = class_name.as_ptr();\r\n    let class_name_pcwstr = PCWSTR(class_name_ptr);\r\n\r\n    let hinstance = unsafe { windows::Win32::System::LibraryLoader::GetModuleHandleW(None)? };\r\n\r\n    let wnd = WNDCLASSEXW {\r\n        cbSize: std::mem::size_of::<WNDCLASSEXW>() as u32,\r\n        lpfnWndProc: Some(window_message_procedure),\r\n        hInstance: hinstance.into(),\r\n        lpszClassName: class_name_pcwstr,\r\n        ..default()\r\n    };\r\n\r\n    let _reg = unsafe { RegisterClassExW(&wnd) };\r\n\r\n    let window = unsafe {\r\n        CreateWindowExW(\r\n            WINDOW_EX_STYLE::default(),\r\n            class_name_pcwstr,\r\n            None,\r\n            WINDOW_STYLE(0),\r\n            CW_USEDEFAULT,\r\n            CW_USEDEFAULT,\r\n            CW_USEDEFAULT,\r\n            CW_USEDEFAULT,\r\n            None,\r\n            None,\r\n            hinstance,\r\n            None,\r\n        )\r\n    };\r\n\r\n    unsafe { GetLastError()? };\r\n    if window.0 == 0 {\r\n        return Err(windows::core::Error::from_win32());\r\n    }\r\n\r\n    Ok(window)\r\n}\r\n\r\nunsafe extern \"system\" fn window_message_procedure(\r\n    hwnd: HWND,\r\n    msg: u32,\r\n    w_param: WPARAM,\r\n    l_param: LPARAM,\r\n) -> LRESULT {\r\n    let next = || DefWindowProcW(hwnd, msg, w_param, l_param);\r\n\r\n    // let tx = match get_tx_pointer(hwnd) {\r\n    //     Some(tx) => tx,\r\n    //     None => return next(),\r\n    // };\r\n\r\n    let tx = match get_sender_for_window(hwnd) {\r\n        Some(tx) => tx,\r\n        None => return next(),\r\n    };\r\n\r\n    match msg {\r\n        WM_INPUT => {\r\n            let mut size = 0;\r\n            let result = GetRawInputData(\r\n                HRAWINPUT(l_param.0),\r\n                RID_INPUT,\r\n                None, // Pointer to data is null, requesting size only\r\n                &mut size,\r\n                std::mem::size_of::<RAWINPUTHEADER>() as u32,\r\n            );\r\n            assert_eq!(result as i32, 0);\r\n\r\n            let mut data = vec![0u8; size as usize];\r\n            let recv_size = GetRawInputData(\r\n                HRAWINPUT(l_param.0),\r\n                RID_INPUT,\r\n                Some(data.as_mut_ptr() as *mut std::ffi::c_void),\r\n                &mut size,\r\n                std::mem::size_of::<RAWINPUTHEADER>() as u32,\r\n            );\r\n            assert_eq!(recv_size as i32, size as i32);\r\n            let input = &*(data.as_ptr() as *const RAWINPUT);\r\n\r\n            if input.header.dwType == RIM_TYPEKEYBOARD.0\r\n                && input.data.keyboard.Message == WM_KEYDOWN\r\n            {\r\n                let key = input.data.keyboard.VKey as u8 as char;\r\n                if let Err(e) = tx.send(ProcMessage::KeyDown(key)) {\r\n                    eprintln!(\"Error sending keyboard message: {:?}\", e);\r\n                    return LRESULT(0);\r\n                }\r\n            }\r\n\r\n            if input.header.dwType == RIM_TYPEMOUSE.0 {\r\n                let mouse_data = input.data.mouse;\r\n                let x = mouse_data.lLastX;\r\n                let y = mouse_data.lLastY;\r\n                if let Err(e) = tx.send(ProcMessage::MouseMoved(IVec2::new(x, y))) {\r\n                    eprintln!(\"Error sending mouse message: {:?}\", e);\r\n                    return LRESULT(0);\r\n                }\r\n            }\r\n\r\n            LRESULT(0)\r\n        }\r\n        WM_DESTROY => {\r\n            // detach_tx_pointer_and_drop(hwnd);\r\n            drop_senders_for_window(hwnd).unwrap();\r\n            PostQuitMessage(0);\r\n            LRESULT(0)\r\n        }\r\n        _ => next(),\r\n    }\r\n}\r\n\r\nunsafe extern \"system\" fn os_event_procedure(\r\n    hook: HWINEVENTHOOK,\r\n    event: u32,\r\n    hwnd: HWND,\r\n    object_id: i32,\r\n    child_id: i32,\r\n    _id_event_thread: u32,\r\n    _dwms_event_time: u32,\r\n) {\r\n    if event < 1000\r\n        || event == EVENT_OBJECT_SHOW\r\n        || event == EVENT_OBJECT_LOCATIONCHANGE\r\n        || event == EVENT_OBJECT_NAMECHANGE\r\n        || event == EVENT_OBJECT_REORDER\r\n        || event == EVENT_OBJECT_VALUECHANGE\r\n        || event == EVENT_OBJECT_CREATE\r\n        || event == EVENT_OBJECT_DESTROY\r\n        || event == EVENT_OBJECT_HIDE\r\n        || event == EVENT_OBJECT_LIVEREGIONCHANGED\r\n    {\r\n        return;\r\n    }\r\n    // if event < 1000 {\r\n    //     return;\r\n    // }\r\n\r\n    let event_name = event_to_name(event).to_string();\r\n    // println!(\r\n    //     \"Hook: {:?}, Event: {:?} ({}), HWND: {:?}, idObject: {:?}, idChild: {:?}\",\r\n    //     hook,\r\n    //     event,\r\n    //     event_name,\r\n    //     hwnd,\r\n    //     object_id,\r\n    //     child_id\r\n    // );\r\n\r\n    // println!(\"Attempting getting tx from window hwnd: {:?}\", hwnd);\r\n    let tx = match get_sender_for_hook(hook) {\r\n        Some(tx) => {\r\n            // println!(\"Got tx from hook {:?}\", hook);\r\n            tx\r\n        }\r\n        None => {\r\n            eprintln!(\"No tx found for hook {:?}\", hook);\r\n            return;\r\n        }\r\n    };\r\n\r\n    if object_id != OBJID_CLIENT.0 {\r\n        return;\r\n    }\r\n    // println!(\"happy path\");\r\n    // if (event == EVENT_OBJECT_SELECTIONADD || event == EVENT_OBJECT_STATECHANGE)\r\n    //     && object_id == OBJID_CLIENT.0 {}\r\n    // Here you get the name and state of the element that triggered the event.\r\n    // Implement the logic to retrieve the name and state using the AccessibleObjectFromEvent function.\r\n    let mut acc_ptr: Option<IAccessible> = None;\r\n    let mut elem = VARIANT::default();\r\n\r\n    // println!(\"Getting accessible object\");\r\n    let lookup = AccessibleObjectFromEvent(\r\n        hwnd,\r\n        object_id as u32,\r\n        child_id as u32,\r\n        &mut acc_ptr,\r\n        &mut elem,\r\n    );\r\n    if lookup.is_err() {\r\n        // eprintln!(\"Error getting accessible object: {:?}\", lookup);\r\n        return;\r\n    }\r\n    let acc = match acc_ptr {\r\n        Some(acc) => acc,\r\n        None => {\r\n            // eprintln!(\"Error getting accessible object\");\r\n            return;\r\n        }\r\n    };\r\n\r\n    // println!(\"Getting name\");\r\n    let name = acc.get_accName(elem.clone()).map(|x| x.to_string()).ok();\r\n\r\n    // println!(\"Getting role\");\r\n    let role = acc\r\n        .get_accRole(elem.clone())\r\n        .and_then(|variant| variant_to_int(&variant))\r\n        .map(|i| role_to_name(i as u32).to_string())\r\n        .ok();\r\n\r\n    // println!(\"Getting state\");\r\n    let state = acc\r\n        .get_accState(elem.clone())\r\n        .and_then(|variant| variant_to_int(&variant))\r\n        .map(|i| state_to_string(i as u32))\r\n        .ok();\r\n\r\n    let mut pxleft = 0;\r\n    let mut pytop = 0;\r\n    let mut pcxwidth = 0;\r\n    let mut pcyheight = 0;\r\n\r\n    // println!(\"Getting location\");\r\n    let bounds = match acc.accLocation(&mut pxleft, &mut pytop, &mut pcxwidth, &mut pcyheight, elem)\r\n    {\r\n        Ok(()) => Some(IRect::from_corners(\r\n            IVec2::new(pxleft, pytop),\r\n            IVec2::new(pxleft + pcxwidth, pytop + pcyheight),\r\n        )),\r\n        Err(_) => None,\r\n    };\r\n\r\n    // println!(\"Building msg\");\r\n    let msg = ProcMessage::Event {\r\n        event_name,\r\n        name,\r\n        role,\r\n        state,\r\n        bounds,\r\n    };\r\n\r\n    // println!(\"Sending event message {:?}\", msg);\r\n    if let Err(e) = tx.send(msg) {\r\n        eprintln!(\"Error sending event message: {:?}\", e);\r\n    } else {\r\n        // println!(\"Sent event message :D\");\r\n    }\r\n}\r\n\r\nfn variant_to_int(variant: &VARIANT) -> Result<i32, windows::core::Error> {\r\n    let var_type = unsafe { variant.Anonymous.Anonymous.vt };\r\n\r\n    match var_type {\r\n        VT_I4 => {\r\n            // Extract 32-bit integer\r\n            Ok(unsafe { variant.Anonymous.Anonymous.Anonymous.lVal })\r\n        }\r\n        _ => Err(windows::core::Error::new(\r\n            windows::Win32::Foundation::E_FAIL,\r\n            \"Unsupported VARIANT type\".into(),\r\n        )),\r\n    }\r\n}\r\n\r\n// fn decimal_to_string(decimal: DECIMAL) -> Result<String, windows::core::Error> {\r\n//     unsafe { VarBstrFromDec(&decimal, 0, 0).map(|bstr| bstr.to_string()) }\r\n// }\r\n\r\n// fn variant_to_string(variant: &VARIANT) -> Result<String, windows::core::Error> {\r\n//     let var_type = unsafe { variant.Anonymous.Anonymous.vt };\r\n\r\n//     match var_type {\r\n//         VT_BSTR => {\r\n//             // Extract BSTR and convert to String\r\n//             let bstr = unsafe { &variant.Anonymous.Anonymous.Anonymous.bstrVal };\r\n//             Ok(bstr.to_string())\r\n//         }\r\n//         VT_I4 => {\r\n//             // Extract 32-bit integer and convert to String\r\n//             let int_val = unsafe { variant.Anonymous.Anonymous.Anonymous.lVal };\r\n//             Ok(int_val.to_string())\r\n//         }\r\n//         // Add more cases as needed for other VARTYPEs you expect to handle\r\n//         _ => Err(windows::core::Error::new(\r\n//             windows::Win32::Foundation::E_FAIL,\r\n//             \"Unsupported VARIANT type\".into(),\r\n//         )),\r\n//     }\r\n// }\r\n\r\nfn state_to_string(state: u32) -> String {\r\n    let mut states = Vec::new();\r\n    if state & STATE_SYSTEM_ALERT_HIGH != 0 {\r\n        states.push(\"STATE_SYSTEM_ALERT_HIGH\")\r\n    }\r\n    if state & STATE_SYSTEM_ALERT_LOW != 0 {\r\n        states.push(\"STATE_SYSTEM_ALERT_LOW\")\r\n    }\r\n    if state & STATE_SYSTEM_ALERT_MEDIUM != 0 {\r\n        states.push(\"STATE_SYSTEM_ALERT_MEDIUM\")\r\n    }\r\n    if state & STATE_SYSTEM_ANIMATED != 0 {\r\n        states.push(\"STATE_SYSTEM_ANIMATED\")\r\n    }\r\n    if state & STATE_SYSTEM_BUSY != 0 {\r\n        states.push(\"STATE_SYSTEM_BUSY\")\r\n    }\r\n    if state & STATE_SYSTEM_CHECKED != 0 {\r\n        states.push(\"STATE_SYSTEM_CHECKED\")\r\n    }\r\n    if state & STATE_SYSTEM_COLLAPSED != 0 {\r\n        states.push(\"STATE_SYSTEM_COLLAPSED\")\r\n    }\r\n    if state & STATE_SYSTEM_DEFAULT != 0 {\r\n        states.push(\"STATE_SYSTEM_DEFAULT\")\r\n    }\r\n    if state & STATE_SYSTEM_EXPANDED != 0 {\r\n        states.push(\"STATE_SYSTEM_EXPANDED\")\r\n    }\r\n    if state & STATE_SYSTEM_EXTSELECTABLE != 0 {\r\n        states.push(\"STATE_SYSTEM_EXTSELECTABLE\")\r\n    }\r\n    if state & STATE_SYSTEM_FLOATING != 0 {\r\n        states.push(\"STATE_SYSTEM_FLOATING\")\r\n    }\r\n    if state & STATE_SYSTEM_FOCUSED != 0 {\r\n        states.push(\"STATE_SYSTEM_FOCUSED\")\r\n    }\r\n    if state & STATE_SYSTEM_HOTTRACKED != 0 {\r\n        states.push(\"STATE_SYSTEM_HOTTRACKED\")\r\n    }\r\n    if state & STATE_SYSTEM_INDETERMINATE != 0 {\r\n        states.push(\"STATE_SYSTEM_INDETERMINATE\")\r\n    }\r\n    if state & STATE_SYSTEM_LINKED != 0 {\r\n        states.push(\"STATE_SYSTEM_LINKED\")\r\n    }\r\n    if state & STATE_SYSTEM_MARQUEED != 0 {\r\n        states.push(\"STATE_SYSTEM_MARQUEED\")\r\n    }\r\n    if state & STATE_SYSTEM_MIXED != 0 {\r\n        states.push(\"STATE_SYSTEM_MIXED\")\r\n    }\r\n    if state & STATE_SYSTEM_MOVEABLE != 0 {\r\n        states.push(\"STATE_SYSTEM_MOVEABLE\")\r\n    }\r\n    if state & STATE_SYSTEM_MULTISELECTABLE != 0 {\r\n        states.push(\"STATE_SYSTEM_MULTISELECTABLE\")\r\n    }\r\n    if state & STATE_SYSTEM_PROTECTED != 0 {\r\n        states.push(\"STATE_SYSTEM_PROTECTED\")\r\n    }\r\n    if state & STATE_SYSTEM_READONLY != 0 {\r\n        states.push(\"STATE_SYSTEM_READONLY\")\r\n    }\r\n    if state & STATE_SYSTEM_SELECTABLE != 0 {\r\n        states.push(\"STATE_SYSTEM_SELECTABLE\")\r\n    }\r\n    if state & STATE_SYSTEM_SELECTED != 0 {\r\n        states.push(\"STATE_SYSTEM_SELECTED\")\r\n    }\r\n    if state & STATE_SYSTEM_SELFVOICING != 0 {\r\n        states.push(\"STATE_SYSTEM_SELFVOICING\")\r\n    }\r\n    if state & STATE_SYSTEM_SIZEABLE != 0 {\r\n        states.push(\"STATE_SYSTEM_SIZEABLE\")\r\n    }\r\n    if state & STATE_SYSTEM_TRAVERSED != 0 {\r\n        states.push(\"STATE_SYSTEM_TRAVERSED\")\r\n    }\r\n    if state & STATE_SYSTEM_VALID != 0 {\r\n        states.push(\"STATE_SYSTEM_VALID\")\r\n    }\r\n    states.join(\",\")\r\n}\r\n\r\npub fn role_to_name(role: u32) -> &'static str {\r\n    match role {\r\n        ROLE_SYSTEM_ALERT => \"ROLE_SYSTEM_ALERT\",\r\n        ROLE_SYSTEM_ANIMATION => \"ROLE_SYSTEM_ANIMATION\",\r\n        ROLE_SYSTEM_APPLICATION => \"ROLE_SYSTEM_APPLICATION\",\r\n        ROLE_SYSTEM_BORDER => \"ROLE_SYSTEM_BORDER\",\r\n        ROLE_SYSTEM_BUTTONDROPDOWN => \"ROLE_SYSTEM_BUTTONDROPDOWN\",\r\n        ROLE_SYSTEM_BUTTONDROPDOWNGRID => \"ROLE_SYSTEM_BUTTONDROPDOWNGRID\",\r\n        ROLE_SYSTEM_BUTTONMENU => \"ROLE_SYSTEM_BUTTONMENU\",\r\n        ROLE_SYSTEM_CARET => \"ROLE_SYSTEM_CARET\",\r\n        ROLE_SYSTEM_CELL => \"ROLE_SYSTEM_CELL\",\r\n        ROLE_SYSTEM_CHARACTER => \"ROLE_SYSTEM_CHARACTER\",\r\n        ROLE_SYSTEM_CHART => \"ROLE_SYSTEM_CHART\",\r\n        ROLE_SYSTEM_CHECKBUTTON => \"ROLE_SYSTEM_CHECKBUTTON\",\r\n        ROLE_SYSTEM_CLIENT => \"ROLE_SYSTEM_CLIENT\",\r\n        ROLE_SYSTEM_CLOCK => \"ROLE_SYSTEM_CLOCK\",\r\n        ROLE_SYSTEM_COLUMN => \"ROLE_SYSTEM_COLUMN\",\r\n        ROLE_SYSTEM_COLUMNHEADER => \"ROLE_SYSTEM_COLUMNHEADER\",\r\n        ROLE_SYSTEM_COMBOBOX => \"ROLE_SYSTEM_COMBOBOX\",\r\n        ROLE_SYSTEM_CURSOR => \"ROLE_SYSTEM_CURSOR\",\r\n        ROLE_SYSTEM_DIAGRAM => \"ROLE_SYSTEM_DIAGRAM\",\r\n        ROLE_SYSTEM_DIAL => \"ROLE_SYSTEM_DIAL\",\r\n        ROLE_SYSTEM_DIALOG => \"ROLE_SYSTEM_DIALOG\",\r\n        ROLE_SYSTEM_DOCUMENT => \"ROLE_SYSTEM_DOCUMENT\",\r\n        ROLE_SYSTEM_DROPLIST => \"ROLE_SYSTEM_DROPLIST\",\r\n        ROLE_SYSTEM_EQUATION => \"ROLE_SYSTEM_EQUATION\",\r\n        ROLE_SYSTEM_GRAPHIC => \"ROLE_SYSTEM_GRAPHIC\",\r\n        ROLE_SYSTEM_GRIP => \"ROLE_SYSTEM_GRIP\",\r\n        ROLE_SYSTEM_GROUPING => \"ROLE_SYSTEM_GROUPING\",\r\n        ROLE_SYSTEM_HELPBALLOON => \"ROLE_SYSTEM_HELPBALLOON\",\r\n        ROLE_SYSTEM_HOTKEYFIELD => \"ROLE_SYSTEM_HOTKEYFIELD\",\r\n        ROLE_SYSTEM_INDICATOR => \"ROLE_SYSTEM_INDICATOR\",\r\n        ROLE_SYSTEM_IPADDRESS => \"ROLE_SYSTEM_IPADDRESS\",\r\n        ROLE_SYSTEM_LINK => \"ROLE_SYSTEM_LINK\",\r\n        ROLE_SYSTEM_LIST => \"ROLE_SYSTEM_LIST\",\r\n        ROLE_SYSTEM_LISTITEM => \"ROLE_SYSTEM_LISTITEM\",\r\n        ROLE_SYSTEM_MENUBAR => \"ROLE_SYSTEM_MENUBAR\",\r\n        ROLE_SYSTEM_MENUITEM => \"ROLE_SYSTEM_MENUITEM\",\r\n        ROLE_SYSTEM_MENUPOPUP => \"ROLE_SYSTEM_MENUPOPUP\",\r\n        ROLE_SYSTEM_OUTLINE => \"ROLE_SYSTEM_OUTLINE\",\r\n        ROLE_SYSTEM_OUTLINEBUTTON => \"ROLE_SYSTEM_OUTLINEBUTTON\",\r\n        ROLE_SYSTEM_OUTLINEITEM => \"ROLE_SYSTEM_OUTLINEITEM\",\r\n        ROLE_SYSTEM_PAGETAB => \"ROLE_SYSTEM_PAGETAB\",\r\n        ROLE_SYSTEM_PAGETABLIST => \"ROLE_SYSTEM_PAGETABLIST\",\r\n        ROLE_SYSTEM_PANE => \"ROLE_SYSTEM_PANE\",\r\n        ROLE_SYSTEM_PROGRESSBAR => \"ROLE_SYSTEM_PROGRESSBAR\",\r\n        ROLE_SYSTEM_PROPERTYPAGE => \"ROLE_SYSTEM_PROPERTYPAGE\",\r\n        ROLE_SYSTEM_PUSHBUTTON => \"ROLE_SYSTEM_PUSHBUTTON\",\r\n        ROLE_SYSTEM_RADIOBUTTON => \"ROLE_SYSTEM_RADIOBUTTON\",\r\n        ROLE_SYSTEM_ROW => \"ROLE_SYSTEM_ROW\",\r\n        ROLE_SYSTEM_ROWHEADER => \"ROLE_SYSTEM_ROWHEADER\",\r\n        ROLE_SYSTEM_SCROLLBAR => \"ROLE_SYSTEM_SCROLLBAR\",\r\n        ROLE_SYSTEM_SEPARATOR => \"ROLE_SYSTEM_SEPARATOR\",\r\n        ROLE_SYSTEM_SLIDER => \"ROLE_SYSTEM_SLIDER\",\r\n        ROLE_SYSTEM_SOUND => \"ROLE_SYSTEM_SOUND\",\r\n        ROLE_SYSTEM_SPINBUTTON => \"ROLE_SYSTEM_SPINBUTTON\",\r\n        ROLE_SYSTEM_SPLITBUTTON => \"ROLE_SYSTEM_SPLITBUTTON\",\r\n        ROLE_SYSTEM_STATICTEXT => \"ROLE_SYSTEM_STATICTEXT\",\r\n        ROLE_SYSTEM_STATUSBAR => \"ROLE_SYSTEM_STATUSBAR\",\r\n        ROLE_SYSTEM_TABLE => \"ROLE_SYSTEM_TABLE\",\r\n        ROLE_SYSTEM_TEXT => \"ROLE_SYSTEM_TEXT\",\r\n        ROLE_SYSTEM_TITLEBAR => \"ROLE_SYSTEM_TITLEBAR\",\r\n        ROLE_SYSTEM_TOOLBAR => \"ROLE_SYSTEM_TOOLBAR\",\r\n        ROLE_SYSTEM_TOOLTIP => \"ROLE_SYSTEM_TOOLTIP\",\r\n        ROLE_SYSTEM_WHITESPACE => \"ROLE_SYSTEM_WHITESPACE\",\r\n        ROLE_SYSTEM_WINDOW => \"ROLE_SYSTEM_WINDOW\",\r\n        _ => \"<Unknown>\",\r\n    }\r\n}\r\n\r\npub fn event_to_name(event: u32) -> &'static str {\r\n    match event {\r\n        EVENT_AIA_END => \"EVENT_AIA_END\",\r\n        EVENT_AIA_START => \"EVENT_AIA_START\",\r\n        EVENT_CONSOLE_CARET => \"EVENT_CONSOLE_CARET\",\r\n        EVENT_CONSOLE_END => \"EVENT_CONSOLE_END\",\r\n        EVENT_CONSOLE_END_APPLICATION => \"EVENT_CONSOLE_END_APPLICATION\",\r\n        EVENT_CONSOLE_LAYOUT => \"EVENT_CONSOLE_LAYOUT\",\r\n        EVENT_CONSOLE_START_APPLICATION => \"EVENT_CONSOLE_START_APPLICATION\",\r\n        EVENT_CONSOLE_UPDATE_REGION => \"EVENT_CONSOLE_UPDATE_REGION\",\r\n        EVENT_CONSOLE_UPDATE_SCROLL => \"EVENT_CONSOLE_UPDATE_SCROLL\",\r\n        EVENT_CONSOLE_UPDATE_SIMPLE => \"EVENT_CONSOLE_UPDATE_SIMPLE\",\r\n        EVENT_OBJECT_ACCELERATORCHANGE => \"EVENT_OBJECT_ACCELERATORCHANGE\",\r\n        EVENT_OBJECT_CLOAKED => \"EVENT_OBJECT_CLOAKED\",\r\n        EVENT_OBJECT_CONTENTSCROLLED => \"EVENT_OBJECT_CONTENTSCROLLED\",\r\n        EVENT_OBJECT_CREATE => \"EVENT_OBJECT_CREATE\",\r\n        EVENT_OBJECT_DEFACTIONCHANGE => \"EVENT_OBJECT_DEFACTIONCHANGE\",\r\n        EVENT_OBJECT_DESCRIPTIONCHANGE => \"EVENT_OBJECT_DESCRIPTIONCHANGE\",\r\n        EVENT_OBJECT_DESTROY => \"EVENT_OBJECT_DESTROY\",\r\n        EVENT_OBJECT_DRAGCANCEL => \"EVENT_OBJECT_DRAGCANCEL\",\r\n        EVENT_OBJECT_DRAGCOMPLETE => \"EVENT_OBJECT_DRAGCOMPLETE\",\r\n        EVENT_OBJECT_DRAGDROPPED => \"EVENT_OBJECT_DRAGDROPPED\",\r\n        EVENT_OBJECT_DRAGENTER => \"EVENT_OBJECT_DRAGENTER\",\r\n        EVENT_OBJECT_DRAGLEAVE => \"EVENT_OBJECT_DRAGLEAVE\",\r\n        EVENT_OBJECT_DRAGSTART => \"EVENT_OBJECT_DRAGSTART\",\r\n        EVENT_OBJECT_END => \"EVENT_OBJECT_END\",\r\n        EVENT_OBJECT_FOCUS => \"EVENT_OBJECT_FOCUS\",\r\n        EVENT_OBJECT_HELPCHANGE => \"EVENT_OBJECT_HELPCHANGE\",\r\n        EVENT_OBJECT_HIDE => \"EVENT_OBJECT_HIDE\",\r\n        EVENT_OBJECT_HOSTEDOBJECTSINVALIDATED => \"EVENT_OBJECT_HOSTEDOBJECTSINVALIDATED\",\r\n        EVENT_OBJECT_IME_CHANGE => \"EVENT_OBJECT_IME_CHANGE\",\r\n        EVENT_OBJECT_IME_HIDE => \"EVENT_OBJECT_IME_HIDE\",\r\n        EVENT_OBJECT_IME_SHOW => \"EVENT_OBJECT_IME_SHOW\",\r\n        EVENT_OBJECT_INVOKED => \"EVENT_OBJECT_INVOKED\",\r\n        EVENT_OBJECT_LIVEREGIONCHANGED => \"EVENT_OBJECT_LIVEREGIONCHANGED\",\r\n        EVENT_OBJECT_LOCATIONCHANGE => \"EVENT_OBJECT_LOCATIONCHANGE\",\r\n        EVENT_OBJECT_NAMECHANGE => \"EVENT_OBJECT_NAMECHANGE\",\r\n        EVENT_OBJECT_PARENTCHANGE => \"EVENT_OBJECT_PARENTCHANGE\",\r\n        EVENT_OBJECT_REORDER => \"EVENT_OBJECT_REORDER\",\r\n        EVENT_OBJECT_SELECTION => \"EVENT_OBJECT_SELECTION\",\r\n        EVENT_OBJECT_SELECTIONADD => \"EVENT_OBJECT_SELECTIONADD\",\r\n        EVENT_OBJECT_SELECTIONREMOVE => \"EVENT_OBJECT_SELECTIONREMOVE\",\r\n        EVENT_OBJECT_SELECTIONWITHIN => \"EVENT_OBJECT_SELECTIONWITHIN\",\r\n        EVENT_OBJECT_SHOW => \"EVENT_OBJECT_SHOW\",\r\n        EVENT_OBJECT_STATECHANGE => \"EVENT_OBJECT_STATECHANGE\",\r\n        EVENT_OBJECT_TEXTEDIT_CONVERSIONTARGETCHANGED => {\r\n            \"EVENT_OBJECT_TEXTEDIT_CONVERSIONTARGETCHANGED\"\r\n        }\r\n        EVENT_OBJECT_TEXTSELECTIONCHANGED => \"EVENT_OBJECT_TEXTSELECTIONCHANGED\",\r\n        EVENT_OBJECT_UNCLOAKED => \"EVENT_OBJECT_UNCLOAKED\",\r\n        EVENT_OBJECT_VALUECHANGE => \"EVENT_OBJECT_VALUECHANGE\",\r\n        EVENT_OEM_DEFINED_END => \"EVENT_OEM_DEFINED_END\",\r\n        EVENT_OEM_DEFINED_START => \"EVENT_OEM_DEFINED_START\",\r\n        EVENT_SYSTEM_ALERT => \"EVENT_SYSTEM_ALERT\",\r\n        EVENT_SYSTEM_ARRANGMENTPREVIEW => \"EVENT_SYSTEM_ARRANGMENTPREVIEW\",\r\n        EVENT_SYSTEM_CAPTUREEND => \"EVENT_SYSTEM_CAPTUREEND\",\r\n        EVENT_SYSTEM_CAPTURESTART => \"EVENT_SYSTEM_CAPTURESTART\",\r\n        EVENT_SYSTEM_CONTEXTHELPEND => \"EVENT_SYSTEM_CONTEXTHELPEND\",\r\n        EVENT_SYSTEM_CONTEXTHELPSTART => \"EVENT_SYSTEM_CONTEXTHELPSTART\",\r\n        EVENT_SYSTEM_DESKTOPSWITCH => \"EVENT_SYSTEM_DESKTOPSWITCH\",\r\n        EVENT_SYSTEM_DIALOGEND => \"EVENT_SYSTEM_DIALOGEND\",\r\n        EVENT_SYSTEM_DIALOGSTART => \"EVENT_SYSTEM_DIALOGSTART\",\r\n        EVENT_SYSTEM_DRAGDROPEND => \"EVENT_SYSTEM_DRAGDROPEND\",\r\n        EVENT_SYSTEM_DRAGDROPSTART => \"EVENT_SYSTEM_DRAGDROPSTART\",\r\n        EVENT_SYSTEM_END => \"EVENT_SYSTEM_END\",\r\n        EVENT_SYSTEM_FOREGROUND => \"EVENT_SYSTEM_FOREGROUND\",\r\n        EVENT_SYSTEM_IME_KEY_NOTIFICATION => \"EVENT_SYSTEM_IME_KEY_NOTIFICATION\",\r\n        EVENT_SYSTEM_MENUEND => \"EVENT_SYSTEM_MENUEND\",\r\n        EVENT_SYSTEM_MENUPOPUPEND => \"EVENT_SYSTEM_MENUPOPUPEND\",\r\n        EVENT_SYSTEM_MENUPOPUPSTART => \"EVENT_SYSTEM_MENUPOPUPSTART\",\r\n        EVENT_SYSTEM_MENUSTART => \"EVENT_SYSTEM_MENUSTART\",\r\n        EVENT_SYSTEM_MINIMIZEEND => \"EVENT_SYSTEM_MINIMIZEEND\",\r\n        EVENT_SYSTEM_MINIMIZESTART => \"EVENT_SYSTEM_MINIMIZESTART\",\r\n        EVENT_SYSTEM_MOVESIZEEND => \"EVENT_SYSTEM_MOVESIZEEND\",\r\n        EVENT_SYSTEM_MOVESIZESTART => \"EVENT_SYSTEM_MOVESIZESTART\",\r\n        EVENT_SYSTEM_SCROLLINGEND => \"EVENT_SYSTEM_SCROLLINGEND\",\r\n        EVENT_SYSTEM_SCROLLINGSTART => \"EVENT_SYSTEM_SCROLLINGSTART\",\r\n        EVENT_SYSTEM_SOUND => \"EVENT_SYSTEM_SOUND\",\r\n        EVENT_SYSTEM_SWITCHEND => \"EVENT_SYSTEM_SWITCHEND\",\r\n        EVENT_SYSTEM_SWITCHER_APPDROPPED => \"EVENT_SYSTEM_SWITCHER_APPDROPPED\",\r\n        EVENT_SYSTEM_SWITCHER_APPGRABBED => \"EVENT_SYSTEM_SWITCHER_APPGRABBED\",\r\n        EVENT_SYSTEM_SWITCHER_APPOVERTARGET => \"EVENT_SYSTEM_SWITCHER_APPOVERTARGET\",\r\n        EVENT_SYSTEM_SWITCHER_CANCELLED => \"EVENT_SYSTEM_SWITCHER_CANCELLED\",\r\n        EVENT_SYSTEM_SWITCHSTART => \"EVENT_SYSTEM_SWITCHSTART\",\r\n        EVENT_UIA_EVENTID_END => \"EVENT_UIA_EVENTID_END\",\r\n        EVENT_UIA_EVENTID_START => \"EVENT_UIA_EVENTID_START\",\r\n        EVENT_UIA_PROPID_END => \"EVENT_UIA_PROPID_END\",\r\n        EVENT_UIA_PROPID_START => \"EVENT_UIA_PROPID_START\",\r\n        _ => \"<Unknown>\",\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n\r\n    #[test]\r\n    fn listen_all() -> Result<(), windows::core::Error> {\r\n        let rx = create_os_event_listener()?;\r\n        while let Ok(msg) = rx.recv() {\r\n            println!(\"Received message: {:?}\", msg);\r\n        }\r\n        Ok(())\r\n    }\r\n\r\n    #[test]\r\n    fn listen_events() -> Result<(), windows::core::Error> {\r\n        let rx = create_os_event_listener()?;\r\n        while let Ok(msg) = rx.recv() {\r\n            if !matches!(msg, ProcMessage::Event { .. }) {\r\n                continue;\r\n            }\r\n            println!(\"Received message: {:?}\", msg);\r\n        }\r\n        Ok(())\r\n    }\r\n\r\n    #[test]\r\n    fn listen_mouse() -> Result<(), windows::core::Error> {\r\n        let rx = create_os_event_listener()?;\r\n        while let Ok(msg) = rx.recv() {\r\n            if !matches!(msg, ProcMessage::MouseMoved { .. }) {\r\n                continue;\r\n            }\r\n            println!(\"Received message: {:?}\", msg);\r\n        }\r\n        Ok(())\r\n    }\r\n\r\n    #[test]\r\n    fn listen_keyboard() -> Result<(), windows::core::Error> {\r\n        let rx = create_os_event_listener()?;\r\n        while let Ok(msg) = rx.recv() {\r\n            if !matches!(msg, ProcMessage::KeyDown { .. }) {\r\n                continue;\r\n            }\r\n            println!(\"Received message: {:?}\", msg);\r\n        }\r\n        Ok(())\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\use cases\\updating readme useful stuff links.md\r\n\r\n````markdown\r\nI have in the README.md a list of\r\n\r\n- github projects\r\n- reddit links\r\n- homepages\r\n- research papers\r\n\r\nregarding the recent progress into the genre of tech related to the future of Cursor Hero.\r\n\r\nThe goal is to automate the process of creating a survey paper.\r\n\r\nAnalyze the technology:\r\n\r\n- project name\r\n- what problem does it solve\r\n- core discovery / unique methodology\r\n- tagline according to github / homepage\r\n- integration opportunities (api, python lib, rust lib, container, service (local is better))\r\n\r\nMost importantly, index the info such that it will show up in results when I describe a task I want to accomplish.\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\templates\\patterns\\new_plugin_with_types\\crates\\{{crate_name}}_types\\src\\lib.rs\r\n\r\n````rust\r\nmod {{crate_name}}_types_plugin;\r\nmod {{crate_name}}_types;\r\n\r\npub mod prelude {\r\n    pub use crate::{{crate_name}}_types::*;\r\n    pub use crate::{{crate_name}}_types_plugin::*;\r\n}\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\voice_to_text_types\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_voice_to_text_types\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\ncursor_hero_secret_types = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\winutils\\src\\win_window.rs\r\n\r\n````rust\r\nuse bevy::math::IRect;\r\nuse bevy::math::IVec2;\r\nuse windows::core::PCSTR;\r\nuse windows::Win32::Foundation::HWND;\r\nuse windows::Win32::Foundation::LPARAM;\r\nuse windows::Win32::Foundation::RECT;\r\nuse windows::Win32::Foundation::WPARAM;\r\nuse windows::Win32::UI::Input::KeyboardAndMouse::ReleaseCapture;\r\nuse windows::Win32::UI::WindowsAndMessaging::FindWindowA;\r\nuse windows::Win32::UI::WindowsAndMessaging::GetClientRect;\r\nuse windows::Win32::UI::WindowsAndMessaging::GetForegroundWindow;\r\nuse windows::Win32::UI::WindowsAndMessaging::GetSystemMetrics;\r\nuse windows::Win32::UI::WindowsAndMessaging::GetWindowRect;\r\nuse windows::Win32::UI::WindowsAndMessaging::IsWindowVisible;\r\nuse windows::Win32::UI::WindowsAndMessaging::SendMessageW;\r\nuse windows::Win32::UI::WindowsAndMessaging::SetForegroundWindow;\r\nuse windows::Win32::UI::WindowsAndMessaging::ShowWindow;\r\nuse windows::Win32::UI::WindowsAndMessaging::HTCAPTION;\r\nuse windows::Win32::UI::WindowsAndMessaging::SM_CYCAPTION;\r\nuse windows::Win32::UI::WindowsAndMessaging::SM_CYFRAME;\r\nuse windows::Win32::UI::WindowsAndMessaging::SW_RESTORE;\r\nuse windows::Win32::UI::WindowsAndMessaging::WM_NCLBUTTONDOWN;\r\n\r\nuse crate::ToBevyIRect;\r\n\r\nimpl ToBevyIRect for RECT {\r\n    fn to_bevy_irect(&self) -> IRect {\r\n        IRect {\r\n            min: IVec2::new(self.left, self.top),\r\n            max: IVec2::new(self.right, self.bottom),\r\n        }\r\n    }\r\n}\r\n\r\n#[derive(Debug)]\r\npub enum WindowBoundsError {\r\n    WindowNotFound,\r\n    WindowsError(windows::core::Error),\r\n}\r\n\r\n#[allow(dead_code)]\r\npub fn get_window_bounds_from_title(title: &str) -> Result<IRect, WindowBoundsError> {\r\n    unsafe {\r\n        let hwnd = FindWindowA(PCSTR::null(), PCSTR(title.as_ptr() as _));\r\n        if hwnd.0 == 0 {\r\n            return Err(WindowBoundsError::WindowNotFound);\r\n        }\r\n        let mut rect = RECT::default();\r\n        GetWindowRect(hwnd, &mut rect).map_err(WindowBoundsError::WindowsError)?;\r\n        Ok(rect.to_bevy_irect())\r\n    }\r\n}\r\n\r\npub fn get_window_bounds(hwnd: isize) -> Result<IRect, WindowBoundsError> {\r\n    unsafe {\r\n        let mut rect = RECT::default();\r\n        GetWindowRect(HWND(hwnd), &mut rect).map_err(WindowBoundsError::WindowsError)?;\r\n        Ok(rect.to_bevy_irect())\r\n    }\r\n}\r\n\r\npub fn get_window_inner_bounds(hwnd: isize) -> Result<IRect, WindowBoundsError> {\r\n    unsafe {\r\n        let hwnd = HWND(hwnd);\r\n        let mut rect = RECT::default();\r\n        if GetClientRect(hwnd, &mut rect).is_ok() {\r\n            Ok(rect.to_bevy_irect())\r\n        } else {\r\n            Err(WindowBoundsError::WindowsError(\r\n                windows::core::Error::from_win32(),\r\n            ))\r\n        }\r\n    }\r\n}\r\n\r\npub fn begin_dragging(hwnd: isize) -> Result<(), windows::core::Error> {\r\n    unsafe {\r\n        let _join_handle = std::thread::Builder::new()\r\n            .name(\"Begin move\".to_string())\r\n            .spawn(move || {\r\n                if let Err(e) = ReleaseCapture() {\r\n                    eprintln!(\"Failed to release capture: {:?}\", e);\r\n                }\r\n                let hwnd = HWND(hwnd);\r\n                SendMessageW(\r\n                    hwnd,\r\n                    WM_NCLBUTTONDOWN,\r\n                    WPARAM(HTCAPTION as usize),\r\n                    LPARAM(0),\r\n                );\r\n                println!(\"Sent message\");\r\n            });\r\n        Ok(())\r\n    }\r\n}\r\n\r\npub fn get_window_title_bar_center_position(hwnd: isize) -> Result<IVec2, WindowBoundsError> {\r\n    unsafe {\r\n        let bounds = get_window_bounds(hwnd)?;\r\n\r\n        // SM_CYCAPTION includes the height of the title bar\r\n        let caption_height = GetSystemMetrics(SM_CYCAPTION);\r\n\r\n        // SM_CYFRAME includes the height of the window frame (border)\r\n        let frame_height = GetSystemMetrics(SM_CYFRAME);\r\n\r\n        let pos =\r\n            bounds.min + IVec2::new((bounds.width()) / 2, (caption_height / 2) + frame_height);\r\n        Ok(pos)\r\n    }\r\n}\r\n\r\npub fn get_window_inner_offset() -> IVec2 {\r\n    unsafe {\r\n        // SM_CYCAPTION includes the height of the title bar\r\n        let caption_height = GetSystemMetrics(SM_CYCAPTION);\r\n\r\n        // SM_CYFRAME includes the height of the window frame (border)\r\n        let frame_height = GetSystemMetrics(SM_CYFRAME);\r\n\r\n        IVec2::new(frame_height, caption_height + frame_height * 2)\r\n    }\r\n}\r\n\r\npub fn focus_window(hwnd: isize) {\r\n    unsafe {\r\n        // Convert the isize to HWND\r\n        let hwnd = HWND(hwnd);\r\n\r\n        // If the window is minimized, restore it before setting it to the foreground.\r\n        if !IsWindowVisible(hwnd).as_bool() {\r\n            ShowWindow(hwnd, SW_RESTORE);\r\n        }\r\n\r\n        // Bring the window to the foreground\r\n        SetForegroundWindow(hwnd);\r\n    }\r\n}\r\n\r\npub fn note_window_info(hwnd: isize) -> Result<IRect, WindowBoundsError> {\r\n    unsafe {\r\n        let hwnd = HWND(hwnd);\r\n\r\n        // Get the window's size and location\r\n        let mut rect = RECT::default();\r\n        GetWindowRect(hwnd, &mut rect).map_err(WindowBoundsError::WindowsError)?;\r\n        Ok(rect.to_bevy_irect())\r\n    }\r\n}\r\n\r\npub fn is_window_focused(hwnd: HWND) -> bool {\r\n    unsafe {\r\n        // Get the handle to the currently focused (foreground) window.\r\n        let foreground_hwnd = GetForegroundWindow();\r\n\r\n        // Compare it with the provided hwnd.\r\n        foreground_hwnd == hwnd\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\templates\\patterns\\new_plugin_with_types\\__pattern__.py\r\n\r\n````py\r\ndef gather_global_variables() -> dict[str,str]:\r\n    crate_name = input(\"crate_name\")\r\n    assert crate_name, \"crate_name is required\"\r\n    crate_name_pascal = pascal(crate_name)\r\n    return {\r\n        \"crate_name\": crate_name,\r\n        \"crate_name_pascal\": crate_name_pascal,\r\n    }\r\n\r\ndef pascal(snake_string: str) -> str:\r\n    return ''.join(word.capitalize() for word in snake_string.split('_'))\r\n\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\window_swap_tool_types\\src\\lib.rs\r\n\r\n````rust\r\npub mod window_swap_tool_types;\r\npub mod window_swap_tool_types_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::window_swap_tool_types::*;\r\n    pub use crate::window_swap_tool_types_plugin::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\worker\\src\\lib.rs\r\n\r\n````rust\r\nmod worker_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::worker_plugin::*;\r\n    pub use cursor_hero_worker_types::prelude::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\worker_types\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_worker_types\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\ncrossbeam-channel = { workspace = true }\r\nanyhow = { workspace = true }\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\wallpaper\\src\\main.rs\r\n\r\n````rust\r\nuse cursor_hero_winutils::win_wallpaper::get_transcoded_wallpaper_path;\r\nuse cursor_hero_winutils::win_wallpaper::get_wallpaper_path;\r\nuse std::path::PathBuf;\r\n\r\n/// Will update the wallpaper used in the game environment\r\nfn main() {\r\n    let wallpaper_path = get_wallpaper_path();\r\n    if let Err(e) = wallpaper_path {\r\n        panic!(\"Error: {:?}\", e);\r\n    }\r\n    let mut wallpaper_path = PathBuf::from(wallpaper_path.unwrap());\r\n    println!(\"Wallpaper path: {:?}\", wallpaper_path);\r\n    // check it exists\r\n    if !wallpaper_path.exists() {\r\n        println!(\"Wallpaper path does not exist, attempting transcoded path\");\r\n        wallpaper_path = match get_transcoded_wallpaper_path() {\r\n            Ok(path) => {\r\n                println!(\"Wallpaper path: {:?}\", path);\r\n                // check it exists\r\n                if !path.exists() {\r\n                    panic!(\"Wallpaper path does not exist\");\r\n                }\r\n                path\r\n            }\r\n            Err(e) => panic!(\"Error: {:?}\", e),\r\n        };\r\n    }\r\n    // copy to assets/textures/environment/game/wallpaper.png\r\n    let dest = std::path::Path::new(\"assets/textures/environment/game/wallpaper.png\");\r\n    std::fs::copy(wallpaper_path, dest).unwrap();\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\window_position\\src\\window_position_loadout_switcher_tool_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse cursor_hero_toolbelt_types::prelude::ToolbeltPopulateEvent;\r\nuse cursor_hero_toolbelt_types::toolbelt_types::ActiveTool;\r\nuse cursor_hero_toolbelt_types::toolbelt_types::ToolbeltLoadout;\r\nuse cursor_hero_tools::prelude::NoInputs;\r\nuse cursor_hero_tools::prelude::ToolSpawnConfig;\r\nuse cursor_hero_tools::tool_spawning::StartingState;\r\nuse cursor_hero_window_position_types::window_position_types::WindowPositionLoadoutSwitcherTool;\r\n\r\npub struct WindowPositionLoadoutSwitcherToolPlugin;\r\n\r\nimpl Plugin for WindowPositionLoadoutSwitcherToolPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Update, populate_toolbelts);\r\n        app.add_systems(Update, do_switch);\r\n    }\r\n}\r\n\r\nfn populate_toolbelts(\r\n    mut commands: Commands,\r\n    asset_server: Res<AssetServer>,\r\n    mut reader: EventReader<ToolbeltPopulateEvent>,\r\n) {\r\n    for event in reader.read() {\r\n        if event.loadout != ToolbeltLoadout::Default {\r\n            continue;\r\n        }\r\n        ToolSpawnConfig::<WindowPositionLoadoutSwitcherTool, NoInputs>::new(\r\n            WindowPositionLoadoutSwitcherTool,\r\n            event.id,\r\n            event,\r\n        )\r\n        .with_src_path(file!().into())\r\n        .guess_name(file!())\r\n        .with_image(asset_server.load(\"textures/tools/window_position.webp\"))\r\n        .with_description(\"Swaps to taskbar tools\")\r\n        .with_starting_state(StartingState::Inactive)\r\n        .spawn(&mut commands);\r\n    }\r\n}\r\n\r\nfn do_switch(\r\n    mut commands: Commands,\r\n    tool_query: Query<&Parent, (Added<ActiveTool>, With<WindowPositionLoadoutSwitcherTool>)>,\r\n    mut toolbelt_events: EventWriter<ToolbeltPopulateEvent>,\r\n) {\r\n    for toolbelt_id in tool_query.iter() {\r\n        let toolbelt_id = toolbelt_id.get();\r\n        commands.entity(toolbelt_id).despawn_descendants();\r\n        toolbelt_events.send(ToolbeltPopulateEvent {\r\n            id: toolbelt_id,\r\n            loadout: ToolbeltLoadout::WindowPosition,\r\n        });\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\window_swap_tool\\src\\lib.rs\r\n\r\n````rust\r\npub mod window_swap_tool_plugin;\r\npub mod window_swap_tool_populate_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::window_swap_tool_plugin::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\templates\\matchers\\new_tool\\crates\\plugins\\src\\default_launch_mode_plugin.rs.py\r\n\r\n````py\r\n# {{use_statements}}\r\n# use cursor_hero_{{crate_name}}_tool::prelude::*;\r\n# {{plugin_start}}\r\n#         app.add_plugins({{crate_name_pascal}}ToolPlugin);\r\n# {{plugin_remaining}}\r\n\r\ndef gather_variables(text: str) -> dict[str,str]:\r\n    # use_statements\r\n    find = \"pub struct DefaultLaunchModePlugin;\"\r\n    include = False\r\n    index = text.find(find)\r\n    assert index != -1, f\"Coult not find `{find}`\"\r\n    index = index + len(find) if include else index\r\n    use_statements, remaining = text[:index],text[index:]\r\n\r\n    # plugin_start\r\n    find = \"fn build(&self, app: &mut App) {\"\r\n    include = True\r\n    index = remaining.find(find)\r\n    assert index != -1, f\"Coult not find `{find}`\"\r\n    index = index + len(find) if include else index\r\n    plugin_start, remaining = remaining[:index],remaining[index:]\r\n\r\n    # plugin_remaining\r\n    plugin_remaining = remaining\r\n\r\n    return {\r\n        \"use_statements\": use_statements,\r\n        \"plugin_start\": plugin_start,\r\n        \"plugin_remaining\": plugin_remaining,\r\n    }\r\n\r\n#region WORKSPACE CONTENT\r\n#use bevy::input::common_conditions::input_toggle_active;\r\n#use bevy::prelude::*;\r\n#\r\n#use bevy::audio::AudioPlugin;\r\n#use bevy::audio::SpatialScale;\r\n#use bevy::diagnostic::FrameTimeDiagnosticsPlugin;\r\n#use bevy::log::LogPlugin;\r\n#use bevy_embedded_assets::EmbeddedAssetPlugin;\r\n#use bevy_inspector_egui::quick::WorldInspectorPlugin;\r\n#use cursor_hero_agent::agent_plugin::AgentPlugin;\r\n#use cursor_hero_camera::camera_plugin::CameraPlugin;\r\n#use cursor_hero_character::character_plugin::CharacterPlugin;\r\n#use cursor_hero_cursor_mirror::cursor_mirroring_plugin::CursorMirroringPlugin;\r\n#use cursor_hero_environment::environment_plugin::EnvironmentPlugin;\r\n#use cursor_hero_environment_nametag::environment_nametag_plugin::EnvironmentNametagPlugin;\r\n#use cursor_hero_hover::afterimage_plugin::AfterimagePlugin;\r\n#use cursor_hero_hover::hover_tool::HoverToolPlugin;\r\n#use cursor_hero_hover::hover_ui_automation_plugin::HoverUiAutomationPlugin;\r\n#use cursor_hero_hover::inspect_tool::InspectToolPlugin;\r\n#use cursor_hero_hover::inspect_wheel_tool::InspectWheelToolPlugin;\r\n#use cursor_hero_icon::IconPlugin;\r\n#use cursor_hero_input::InputPlugin;\r\n#use cursor_hero_level_bounds::level_bounds_plugin::LevelBoundsPlugin;\r\n#use cursor_hero_math::math_plugin::MathPlugin;\r\n#use cursor_hero_pause_tool::pause_tool_plugin::PauseToolPlugin;\r\n#use cursor_hero_physics::damping_plugin::DampingPlugin;\r\n#use cursor_hero_physics::physics_plugin::PhysicsPlugin;\r\n#use cursor_hero_physics_debug::physics_debug_plugin::PhysicsDebugPlugin;\r\n#use cursor_hero_cursor::pointer_plugin::PointerPlugin;\r\n#use cursor_hero_cursor_types::pointer_types_plugin::PointerTypesPlugin;\r\n#use cursor_hero_pressure_plate::pressure_plate_plugin::PressurePlatePlugin;\r\n#use cursor_hero_restart_memory::MemoryPlugin;\r\n##[cfg(debug_assertions)]\r\n#use cursor_hero_screen::screen_plugin::ScreenPlugin;\r\n#use cursor_hero_screen::screen_update_plugin::ScreenUpdatePlugin;\r\n#use cursor_hero_sprint_tool::sprint_tool_plugin::SprintToolPlugin;\r\n#use cursor_hero_sprint_tool_types::sprint_tool_types_plugin::SprintToolTypesPlugin;\r\n#use cursor_hero_taskbar::taskbar_plugin::TaskbarPlugin;\r\n#use cursor_hero_toolbelt::toolbelt_plugin::ToolbeltPlugin;\r\n#use cursor_hero_toolbelt_types::toolbelt_types_plugin::ToolbeltTypesPlugin;\r\n#use cursor_hero_tools::ToolPlugin;\r\n#use cursor_hero_ui::about_text_plugin::AboutTextPlugin;\r\n#use cursor_hero_ui::fps_text_plugin::FpsTextPlugin;\r\n#use cursor_hero_version::version_plugin::Version;\r\n#use cursor_hero_wallpaper::wallpaper_plugin::WallpaperPlugin;\r\n#\r\n#use cursor_hero_agent_types::agent_types_plugin::AgentTypesPlugin;\r\n#use cursor_hero_character_types::character_types_plugin::CharacterTypesPlugin;\r\n#use cursor_hero_chat::chat_plugin::ChatPlugin;\r\n#use cursor_hero_chat_types::chat_types_plugin::ChatTypesPlugin;\r\n#use cursor_hero_inference::inference_plugin::InferencePlugin;\r\n#use cursor_hero_inference_types::inference_types_plugin::InferenceTypesPlugin;\r\n#use cursor_hero_movement_tool::movement_tool_plugin::MovementToolPlugin;\r\n#use cursor_hero_movement_tool_types::movement_tool_types_plugin::MovementToolTypesPlugin;\r\n#use cursor_hero_observation::observation_plugin::ObservationPlugin;\r\n#use cursor_hero_observation_types::observation_types_plugin::ObservationTypesPlugin;\r\n#use cursor_hero_tts::tts_plugin::TtsPlugin;\r\n#use cursor_hero_tts_types::tts_types_plugin::TtsTypesPlugin;\r\n#use cursor_hero_environment_types::environment_types_plugin::EnvironmentTypesPlugin;\r\n#pub struct MyPlugin;\r\n#\r\n#impl Plugin for MyPlugin {\r\n#    fn build(&self, app: &mut App) {\r\n#        app.add_plugins(EnvironmentTypesPlugin);\r\n#        app.add_plugins(ChatTypesPlugin);\r\n#        app.add_plugins(ChatPlugin);\r\n#        app.add_plugins(TtsPlugin);\r\n#        app.add_plugins(TtsTypesPlugin);\r\n#        app.add_plugins(ObservationTypesPlugin);\r\n#        app.add_plugins(ObservationPlugin);\r\n#        app.add_plugins(InferenceTypesPlugin);\r\n#        app.add_plugins(InferencePlugin);\r\n#        app.add_plugins(MovementToolTypesPlugin);\r\n#        app.add_plugins(MovementToolPlugin);\r\n#        app.add_plugins(CharacterTypesPlugin);\r\n#        app.add_plugins(AgentTypesPlugin);\r\n#        app.add_plugins(AgentPlugin);\r\n#        //app.add_plugins(ClickDragMovementPlugin);\r\n#        //app.add_plugins(HoverShowerRelayPlugin);\r\n#        //app.add_plugins(HoverShowerServicePlugin);\r\n#        app.add_plugins(AboutTextPlugin);\r\n#        app.add_plugins(AfterimagePlugin);\r\n#        app.add_plugins(CameraPlugin);\r\n#        app.add_plugins(CharacterPlugin);\r\n#        app.add_plugins(CursorMirroringPlugin);\r\n#        app.add_plugins(DampingPlugin);\r\n#        app.add_plugins(EnvironmentNametagPlugin);\r\n#        app.add_plugins(EnvironmentPlugin);\r\n#        app.add_plugins(FpsTextPlugin);\r\n#        app.add_plugins(HoverToolPlugin);\r\n#        app.add_plugins(HoverUiAutomationPlugin);\r\n#        app.add_plugins(IconPlugin);\r\n#        app.add_plugins(InputPlugin);\r\n#        app.add_plugins(InspectToolPlugin);\r\n#        app.add_plugins(InspectWheelToolPlugin);\r\n#        app.add_plugins(LevelBoundsPlugin);\r\n#        app.add_plugins(MathPlugin);\r\n#        app.add_plugins(MemoryPlugin);\r\n#        app.add_plugins(PauseToolPlugin);\r\n#        app.add_plugins(PhysicsDebugPlugin);\r\n#        app.add_plugins(PhysicsPlugin);\r\n#        app.add_plugins(PointerPlugin);\r\n#        app.add_plugins(PointerTypesPlugin);\r\n#        // app.add_plugins(PositionTextPlugin);\r\n#        app.add_plugins(PressurePlatePlugin);\r\n#        app.add_plugins(ScreenPlugin);\r\n#        app.add_plugins(ScreenUpdatePlugin);\r\n#        app.add_plugins(SprintToolPlugin);\r\n#        app.add_plugins(SprintToolTypesPlugin);\r\n#        app.add_plugins(TaskbarPlugin);\r\n#        app.add_plugins(ToolbeltPlugin);\r\n#        app.add_plugins(ToolbeltTypesPlugin);\r\n#        app.add_plugins(ToolPlugin);\r\n#        app.add_plugins(WallpaperPlugin);\r\n#\r\n#        // must be before the default plugins\r\n#        app.add_plugins(EmbeddedAssetPlugin {\r\n#            mode: bevy_embedded_assets::PluginMode::ReplaceDefault,\r\n#        });\r\n#\r\n#        #[cfg(debug_assertions)]\r\n#        let log_plugin = LogPlugin {\r\n#            level: bevy::log::Level::DEBUG,\r\n#            filter: \"info,wgpu_core=warn,wgpu_hal=warn,bevy_ecs=info,cursor_hero=debug\".into(),\r\n#            // filter: \"debug,wgpu_core=warn,wgpu_hal=warn,bevy_ecs=info,cursor_hero=debug\".into(),\r\n#        };\r\n#        #[cfg(not(debug_assertions))]\r\n#        let log_plugin = LogPlugin {\r\n#            level: bevy::log::Level::INFO,\r\n#            filter: \"info,wgpu_core=warn,wgpu_hal=warn\".into(),\r\n#        };\r\n#        const AUDIO_SCALE: f32 = 1. / 100.0;\r\n#        let version = match app.world.get_resource::<Version>() {\r\n#            Some(version) => version.0.clone(),\r\n#            None => {\r\n#                warn!(\"Version resource not found\");\r\n#                \"Unknown\".to_string()\r\n#            }\r\n#        };\r\n#        app.add_plugins(\r\n#            DefaultPlugins\r\n#                .set(ImagePlugin::default_nearest())\r\n#                .set(AudioPlugin {\r\n#                    spatial_scale: SpatialScale::new_2d(AUDIO_SCALE),\r\n#                    ..default()\r\n#                })\r\n#                .set(WindowPlugin {\r\n#                    primary_window: Some(Window {\r\n#                        transparent: true,\r\n#                        title: format!(\"Cursor Hero v{}\", version),\r\n#                        resizable: true,\r\n#                        ..default()\r\n#                    }),\r\n#                    ..default()\r\n#                })\r\n#                .set(log_plugin)\r\n#                .build(),\r\n#        );\r\n#\r\n#        // must be after the default plugins\r\n#        app.add_plugins(\r\n#            WorldInspectorPlugin::default().run_if(input_toggle_active(false, KeyCode::Grave)),\r\n#        );\r\n#        app.add_plugins(FrameTimeDiagnosticsPlugin);\r\n#    }\r\n#}\r\n#\r\n#endregion\r\n\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\templates\\patterns\\new_plugin_with_types\\crates\\{{crate_name}}\\src\\lib.rs\r\n\r\n````rust\r\npub mod {{crate_name}}_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::{{crate_name}}_plugin::*;\r\n}\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui_watcher_types\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_ui_watcher_types\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\nuiautomation = {workspace = true}\r\ncursor_hero_ui_automation = {workspace = true}\r\ncursor_hero_worker_types = {workspace = true}\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\winutils\\src\\win_keyboard.rs\r\n\r\n````rust\r\n\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui_watcher_types\\src\\ui_watcher_types.rs\r\n\r\n````rust\r\n\r\nuse cursor_hero_worker_types::prelude::WorkerMessage;\r\nuse bevy::prelude::*;\r\nuse std::fmt;\r\nuse std::fmt::Display;\r\nuse std::fmt::Formatter;\r\nuse cursor_hero_ui_automation::prelude::UiSnapshot;\r\nuse uiautomation::controls::ControlType;\r\nuse uiautomation::UIElement;\r\n\r\npub enum AppUIElement {\r\n    VSCode(UIElement),\r\n    Unknown(UIElement),\r\n}\r\n\r\nimpl From<UIElement> for AppUIElement {\r\n    fn from(elem: UIElement) -> Self {\r\n        let name = elem.get_name();\r\n        let control_type = elem.get_control_type();\r\n        let class_name = elem.get_classname();\r\n        match (name, control_type, class_name) {\r\n            (Ok(name), Ok(ControlType::Pane), Ok(class_name))\r\n                if name.ends_with(\"Visual Studio Code\") && class_name == \"Chrome_WidgetWin_1\" =>\r\n            {\r\n                AppUIElement::VSCode(elem)\r\n            }\r\n            _ => AppUIElement::Unknown(elem),\r\n        }\r\n    }\r\n}\r\n\r\nimpl Display for AppUIElement {\r\n    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {\r\n        match self {\r\n            AppUIElement::VSCode(elem) => {\r\n                write!(f, \"Visual Studio Code: {:?}\", elem.get_name())\r\n                // match get_tree_string(elem) {\r\n                //     Ok(text) => write!(f, \"Visual Studio Code: {}\", text),\r\n                //     Err(e) => write!(f, \"Visual Studio Code: {:?}\", e),\r\n                // }\r\n            }\r\n            AppUIElement::Unknown(elem) => write!(f, \"Unknown: {:?}\", elem),\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n#[derive(Event, Debug, Reflect, Clone)]\r\npub enum ThreadboundUIWatcherMessage {\r\n    TakeSnapshot,\r\n}\r\nimpl WorkerMessage for ThreadboundUIWatcherMessage {}\r\n\r\n#[derive(Event, Debug, Reflect, Clone)]\r\npub enum GameboundUIWatcherMessage {\r\n    Snapshot(UiSnapshot),\r\n}\r\nimpl WorkerMessage for GameboundUIWatcherMessage {}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\winutils\\examples\\app_icons_bevy_example.rs\r\n\r\n````rust\r\nuse bevy::input::common_conditions::input_toggle_active;\r\nuse bevy::log::LogPlugin;\r\nuse bevy::prelude::*;\r\nuse bevy::utils::HashMap;\r\nuse bevy_inspector_egui::quick::WorldInspectorPlugin;\r\nuse cursor_hero_winutils::win_errors::*;\r\nuse cursor_hero_winutils::win_icons::get_images_from_exe;\r\nuse cursor_hero_winutils::win_process::*;\r\nuse cursor_hero_worker::prelude::*;\r\nuse image::DynamicImage;\r\nuse image::RgbaImage;\r\nuse windows::core::PWSTR;\r\nuse windows::Win32::Foundation::E_ACCESSDENIED;\r\nfn main() {\r\n    let mut app = App::new();\r\n    app.add_plugins(\r\n        DefaultPlugins\r\n            .set(LogPlugin {\r\n                level: bevy::log::Level::DEBUG,\r\n                filter: \"\r\ninfo,\r\nwgpu_core=warn,\r\nwgpu_hal=warn,\r\ncursor_hero=debug,\r\napp_icons_bevy_example=trace,\r\n\"\r\n                .replace('\\n', \"\")\r\n                .trim()\r\n                .into(),\r\n            })\r\n            .build(),\r\n    );\r\n    app.add_plugins(WorkerPlugin {\r\n        config: WorkerConfig::<ThreadboundMessage, GameboundMessage, ()> {\r\n            name: \"ui_snapshot\".to_string(),\r\n            is_ui_automation_thread: true,\r\n            handle_threadbound_message,\r\n            ..default()\r\n        },\r\n    });\r\n    app.add_systems(Update, receive);\r\n    app.add_systems(Startup, trigger);\r\n    app.add_systems(Startup, camera_setup);\r\n    app.add_plugins(\r\n        WorldInspectorPlugin::default().run_if(input_toggle_active(false, KeyCode::Grave)),\r\n    );\r\n    app.run();\r\n}\r\n\r\n#[derive(Debug, Reflect, Clone, Event)]\r\nenum ThreadboundMessage {\r\n    GatherRunningProcessIcons,\r\n}\r\nimpl WorkerMessage for ThreadboundMessage {}\r\n\r\n#[derive(Debug, Clone, Event)]\r\nenum GameboundMessage {\r\n    RunningProcessIcons(HashMap<String, Vec<RgbaImage>>),\r\n}\r\nimpl WorkerMessage for GameboundMessage {}\r\n\r\nfn handle_threadbound_message(\r\n    msg: &ThreadboundMessage,\r\n    reply_tx: &Sender<GameboundMessage>,\r\n    _state: &mut (),\r\n) -> Result<()> {\r\n    let ThreadboundMessage::GatherRunningProcessIcons = msg;\r\n    let process_iter = ProcessIterator::new()?;\r\n    let mut result = HashMap::new();\r\n    unsafe {\r\n        for mut process in process_iter {\r\n            let exe_name_pwstr = PWSTR(process.szExeFile.as_mut_ptr());\r\n            let exe_name = exe_name_pwstr.to_string()?;\r\n            let exe_path = match get_process_full_name(process.th32ProcessID) {\r\n                Ok(s) => s,\r\n                Err(e) => {\r\n                    if matches!(\r\n                        e,\r\n                        Error::Windows(ref e) if e.code() == E_ACCESSDENIED\r\n                    ) {\r\n                        continue;\r\n                    }\r\n                    warn!(\r\n                        \"Failed to get full process name for PID {:05} ({}): {:?}\",\r\n                        process.th32ProcessID, exe_name, e\r\n                    );\r\n                    continue;\r\n                }\r\n            };\r\n            if result.contains_key(&exe_path) {\r\n                continue;\r\n            }\r\n            let icons = get_images_from_exe(exe_path.as_str())?;\r\n            result.insert(exe_path, icons);\r\n        }\r\n    }\r\n    if let Err(e) = reply_tx.send(GameboundMessage::RunningProcessIcons(result)) {\r\n        error!(\"Failed to send snapshot: {:?}\", e);\r\n    }\r\n\r\n    Ok(())\r\n}\r\n\r\nfn camera_setup(mut commands: Commands) {\r\n    commands.spawn(Camera2dBundle::default());\r\n    // commands.spawn((\r\n    //     SpriteBundle {\r\n    //         transform: Transform::from_translation(Vec3::new(0.0, 0.0, 0.0)),\r\n    //         sprite: Sprite {\r\n    //             color: Color::WHITE,\r\n    //             custom_size: Some(Vec2::new(100.0, 100.0)),\r\n    //             ..default()\r\n    //         },\r\n    //         ..default()\r\n    //     },\r\n    // ));\r\n}\r\n\r\nfn trigger(mut events: EventWriter<ThreadboundMessage>) {\r\n    events.send(ThreadboundMessage::GatherRunningProcessIcons);\r\n}\r\n\r\nfn receive(\r\n    mut commands: Commands,\r\n    mut bridge: EventReader<GameboundMessage>,\r\n    mut icons_so_far: Local<usize>,\r\n    mut textures: ResMut<Assets<Image>>,\r\n) {\r\n    for msg in bridge.read() {\r\n        match msg {\r\n            GameboundMessage::RunningProcessIcons(icons) => {\r\n                info!(\"Received icons: {:?}\", icons.len());\r\n                for (exe_path, images) in icons {\r\n                    for image in images {\r\n                        debug!(\"{}x{}\", image.width(), image.height());\r\n                        let dynamic = DynamicImage::ImageRgba8(image.clone());\r\n                        let handle = textures.add(Image::from_dynamic(dynamic, true));\r\n                        let icons_per_row = 5;\r\n                        let icon_size = 100.0;\r\n                        let margin = 10.0;\r\n                        commands.spawn((\r\n                            SpriteBundle {\r\n                                texture: handle,\r\n                                transform: Transform::from_translation(Vec3::new(\r\n                                    (*icons_so_far % icons_per_row) as f32 * (icon_size + margin),\r\n                                    (*icons_so_far / icons_per_row) as f32 * (icon_size + margin),\r\n                                    0.0,\r\n                                )),\r\n                                sprite: Sprite {\r\n                                    color: Color::hsl(\r\n                                        *icons_so_far as f32 / icons.len() as f32 * 360.0,\r\n                                        1.0,\r\n                                        0.5,\r\n                                    ),\r\n                                    custom_size: Some(Vec2::splat(icon_size)),\r\n                                    ..default()\r\n                                },\r\n                                ..default()\r\n                            },\r\n                            Name::new(exe_path.clone()),\r\n                        ));\r\n                        *icons_so_far += 1;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\worker_types\\src\\worker_types.rs\r\n\r\n````rust\r\nuse anyhow::Error;\r\nuse anyhow::Result;\r\nuse bevy::prelude::*;\r\npub use crossbeam_channel::Receiver;\r\npub use crossbeam_channel::Sender;\r\nuse std::marker::PhantomData;\r\n\r\n#[derive(Resource)]\r\npub struct Bridge<T, G>\r\nwhere\r\n    T: WorkerMessage,\r\n    G: WorkerMessage,\r\n{\r\n    pub sender: Sender<T>,\r\n    pub receiver: Receiver<G>,\r\n}\r\n\r\npub trait WorkerMessage: std::fmt::Debug + Event + Send + Sync + Clone + 'static {}\r\n\r\npub trait WorkerState: 'static + Sized\r\n//  + Send + Sync + Clone\r\n{\r\n    fn try_default() -> Result<Self>;\r\n}\r\nimpl WorkerState for () {\r\n    fn try_default() -> Result<Self> {\r\n        Ok(())\r\n    }\r\n}\r\n\r\npub type ThreadboundMessageHandler<T, G, S> =\r\n    fn(msg: &T, reply_tx: &Sender<G>, state: &mut S) -> Result<()>;\r\n\r\npub type ThreadboundMessageErrorHandler<T, G, S> =\r\n    fn(msg: &T, reply_tx: &Sender<G>, state: &mut S, error: &Error) -> Result<()>;\r\n\r\npub type ThreadboundMessageReceiver<T, S> = fn(thread_rx: &Receiver<T>, state: &mut S) -> Result<T>;\r\n\r\n\r\npub struct TGSHolder<T,G,S> {\r\n    _phantom_t: PhantomData<T>,\r\n    _phantom_g: PhantomData<G>,\r\n    _phantom_s: PhantomData<S>,\r\n}\r\nunsafe impl <T, G, S> Send for TGSHolder<T, G, S> {}\r\nunsafe impl <T, G, S> Sync for TGSHolder<T, G, S> {}\r\nimpl <T, G, S> Clone for TGSHolder<T, G, S> {\r\n    fn clone(&self) -> Self {\r\n        TGSHolder {\r\n            _phantom_t: PhantomData,\r\n            _phantom_g: PhantomData,\r\n            _phantom_s: PhantomData,\r\n        }\r\n    }\r\n}\r\n\r\n#[derive(Resource, Reflect)]\r\npub struct WorkerConfig<T, G, S> {\r\n    pub name: String,\r\n    pub sleep_duration: std::time::Duration,\r\n    pub is_ui_automation_thread: bool,\r\n    pub threadbound_message_receiver: ThreadboundMessageReceiver<T, S>,\r\n    pub handle_threadbound_message: ThreadboundMessageHandler<T, G, S>,\r\n    pub handle_threadbound_message_error_handler: ThreadboundMessageErrorHandler<T, G, S>,\r\n    pub gamebound_channel_capacity: usize,\r\n    pub threadbound_channel_capacity: usize,\r\n    pub tgs_holder: TGSHolder<T, G, S>,\r\n}\r\nimpl<T: WorkerMessage, G: WorkerMessage, S: WorkerState> Default for WorkerConfig<T, G, S> {\r\n    fn default() -> Self {\r\n        WorkerConfig {\r\n            name: \"Unknown Worker\".to_string(),\r\n            is_ui_automation_thread: false,\r\n            sleep_duration: std::time::Duration::from_millis(100),\r\n            handle_threadbound_message: |_, _, _| Ok(()),\r\n            handle_threadbound_message_error_handler: |_, _, _, _| Ok(()),\r\n            threadbound_message_receiver: |thread_rx, _state| {\r\n                thread_rx\r\n                    .recv()\r\n                    .map_err(|e| Error::from(e).context(\"receiving threadbound message\"))\r\n            },\r\n            gamebound_channel_capacity: 10,\r\n            threadbound_channel_capacity: 10,\r\n            tgs_holder: TGSHolder {\r\n                _phantom_t: PhantomData,\r\n                _phantom_g: PhantomData,\r\n                _phantom_s: PhantomData,\r\n            },\r\n        }\r\n    }\r\n}\r\nimpl <T,G,S> Clone for WorkerConfig<T,G,S> {\r\n    fn clone(&self) -> Self {\r\n        WorkerConfig {\r\n            name: self.name.clone(),\r\n            sleep_duration: self.sleep_duration,\r\n            is_ui_automation_thread: self.is_ui_automation_thread,\r\n            threadbound_message_receiver: self.threadbound_message_receiver.clone(),\r\n            handle_threadbound_message: self.handle_threadbound_message.clone(),\r\n            handle_threadbound_message_error_handler: self.handle_threadbound_message_error_handler.clone(),\r\n            gamebound_channel_capacity: self.gamebound_channel_capacity,\r\n            threadbound_channel_capacity: self.threadbound_channel_capacity,\r\n            tgs_holder: self.tgs_holder.clone(),\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\templates\\matchers\\new_tool\\Cargo.toml.py\r\n\r\n````py\r\n# {{before_first_workspace_dependency}}\r\n# cursor_hero_{{crate_name}}_tool = { path = \"./crates/{{crate_name}}_tool\" }\r\n# {{first_workspace_dependency_onwards}}\r\n\r\n\r\n\r\ndef gather_variables(text: str) -> dict[str,str]:\r\n    # before_first_workspace_dependency\r\n    find = \"[workspace.dependencies]\"\r\n    include = True\r\n    index = text.find(find)\r\n    assert index != -1, f\"Coult not find `{find}`\"\r\n    index = index + len(find) if include else index\r\n    before_first_workspace_dependency, remaining = text[:index],text[index:]\r\n\r\n    # first_workspace_dependency_onwards\r\n    first_workspace_dependency_onwards = remaining\r\n\r\n    return {\r\n        \"before_first_workspace_dependency\": before_first_workspace_dependency,\r\n        \"first_workspace_dependency_onwards\": first_workspace_dependency_onwards,\r\n    }\r\n\r\n##### OLD CONTENT OF THIS FILE\r\n\r\n# # {{before_first_workspace_dependency}}\r\n# # cursor_hero_{{crate_name}}_tool = { path = \"./crates/{{crate_name}}_tool\" }\r\n# # {{first_workspace_dependency_onwards}\r\n# \r\n# \r\n# \r\n# def gather_variables(text: str) -> dict[str,str]:\r\n#     find = \"some part of the file\"\r\n#     include = True\r\n#     index = text.find(find)\r\n#     assert index != -1, f\"Coult not find `{find}`\"\r\n#     index = index + len(find) if include else index\r\n#     before_first_workspace_dependency, remaining = text[:index],text[index:]\r\n# \r\n#     first_workspace_dependency_onwards = remaining\r\n# \r\n#     return {\r\n#         \"before_first_workspace_dependency\": before_first_workspace_dependency,\r\n#         \"first_workspace_dependency_onwards\": first_workspace_dependency_onwards,\r\n#     }\r\n# \r\n# ##### OLD CONTENT OF THIS FILE\r\n# \r\n# # # {{before_first_workspace_dependency}}\r\n# # # cursor_hero_{{crate_name}}_tool = { path = \"./crates/{{crate_name}}_tool\" }\r\n# # # {{first_workspace_dependency_onwards}\r\n# # \r\n# # \r\n# # \r\n# # def gather_variables(text: str) -> dict[str,str]:\r\n# #     find = \"some part of the file\"\r\n# #     include = True\r\n# #     index = text.find(find)\r\n# #     assert index != -1, f\"Coult not find `{find}`\"\r\n# #     index = index + len(find) if include else index\r\n# #     before_first_workspace_dependency, remaining = text[:index],text[index:]\r\n# # \r\n# #     first_workspace_dependency_onwards = remaining\r\n# #     return {\r\n# #         \"before_first_workspace_dependency\": before_first_workspace_dependency,\r\n# #         \"first_workspace_dependency_onwards\": first_workspace_dependency_onwards,\r\n# #     }\r\n# # \r\n# # ##### OLD CONTENT OF THIS FILE\r\n# # \r\n# # # # {{before_first_workspace_dependency}}\r\n# # # # cursor_hero_{{crate_name}}_tool = { path = \"./crates/{{crate_name}}_tool\" }\r\n# # # # {{first_workspace_dependency_onwards}\r\n# # # \r\n# # # \r\n# # # \r\n# # # def gather_variables(text: str) -> dict[str,str]:\r\n# # #     find = \"some part of the file\"\r\n# # #     include = True\r\n# # #     index = text.find(find)\r\n# # #     assert index != -1, f\"Coult not find `{find}`\"\r\n# # #     index = index + len(find) if include else index\r\n# # #     before_first_workspace_dependency, remaining = text[:index],text[index:]\r\n# # # \r\n# # #     find = \"some part of the file\"\r\n# # #     include = True\r\n# # #     index = remaining.find(find)\r\n# # #     assert index != -1, f\"Coult not find `{find}`\"\r\n# # #     index = index + len(find) if include else index\r\n# # #     first_workspace_dependency_onwards, remaining = remaining[:index],remaining[index:]\r\n# # # \r\n# # #     return {\r\n# # #         \"before_first_workspace_dependency\": before_first_workspace_dependency,\r\n# # #         \"first_workspace_dependency_onwards\": first_workspace_dependency_onwards,\r\n# # #     }\r\n# # # \r\n# # # ##### OLD CONTENT OF THIS FILE\r\n# # # \r\n# # # # # {{before_first_workspace_dependency}}\r\n# # # # # cursor_hero_{{crate_name}}_tool = { path = \"./crates/{{crate_name}}_tool\" }\r\n# # # # # {{first_workspace_dependency_onwards}\r\n# # # # \r\n# # # # \r\n# # # # \r\n# # # # def gather_variables(text: str) -> dict[str,str]:\r\n# # # #     find = \"some part of the file\"\r\n# # # #     include = True\r\n# # # #     index = text.find(find)\r\n# # # #     assert index != -1, f\"Coult not find `{find}`\"\r\n# # # #     index = index + len(find) if include else index\r\n# # # #     before_first_workspace_dependency, remaining = text[:index],text[index:]\r\n# # # # \r\n# # # #     find = \"some part of the file\"\r\n# # # #     include = True\r\n# # # #     index = remaining.find(find)\r\n# # # #     assert index != -1, f\"Coult not find `{find}`\"\r\n# # # #     index = index + len(find) if include else index\r\n# # # #     first_workspace_dependency_onwards, remaining = remaining[:index],remaining[index:]\r\n# # # # \r\n# # # #     return {\r\n# # # #         \"before_first_workspace_dependency\": before_first_workspace_dependency,\r\n# # # #         \"first_workspace_dependency_onwards\": first_workspace_dependency_onwards,\r\n# # # #     }\r\n# # # # \r\n# # # # ##### OLD CONTENT OF THIS FILE\r\n# # # # \r\n# # # # # # {{before_first_workspace_dependency}}\r\n# # # # # # cursor_hero_{{crate_name}}_tool = { path = \"./crates/{{crate_name}}_tool\" }\r\n# # # # # # {{first_workspace_dependency_onwards}\r\n# # # # # \r\n# # # # # \r\n# # # # # \r\n# # # # # def gather_variables(text: str) -> dict[str,str]:\r\n# # # # #     find = \"some part of the file\"\r\n# # # # #     include = True\r\n# # # # #     index = text.find(find)\r\n# # # # #     assert index != -1, f\"Coult not find `{find}`\"\r\n# # # # #     before_first_workspace_dependency, remaining = text[:index],text[index:]\r\n# # # # # \r\n# # # # #     find = \"some part of the file\"\r\n# # # # #     include = True\r\n# # # # #     index = remaining.find(find)\r\n# # # # #     assert index != -1, f\"Coult not find `{find}`\"\r\n# # # # #     first_workspace_dependency_onwards, remaining = remaining[:index],remaining[index:]\r\n# # # # # \r\n# # # # #     return {\r\n# # # # #         \"before_first_workspace_dependency\": before_first_workspace_dependency,\r\n# # # # #         \"first_workspace_dependency_onwards\": first_workspace_dependency_onwards,\r\n# # # # #     }\r\n# # # # # \r\n# # # # # ##### OLD CONTENT OF THIS FILE\r\n# # # # # \r\n# # # # # # # {{before_first_workspace_dependency}}\r\n# # # # # # # cursor_hero_{{crate_name}}_tool = { path = \"./crates/{{crate_name}}_tool\" }\r\n# # # # # # # {{first_workspace_depndency_onwards}}\r\n# # # # # # \r\n# # # # # # \r\n# # # # # # \r\n# # # # # # def gather_variables(text: str) -> dict[str,str]:\r\n# # # # # #     find = \"some part of the file\"\r\n# # # # # #     include = true\r\n# # # # # #     index = text.find(find)\r\n# # # # # #     assert index != -1, f\"Coult not find `{find}`\"\r\n# # # # # #     before_first_workspace_dependency, remaining = text[:index],text[index:]\r\n# # # # # # \r\n# # # # # #     find = \"some part of the file\"\r\n# # # # # #     include = true\r\n# # # # # #     index = remaining.find(find)\r\n# # # # # #     assert index != -1, f\"Coult not find `{find}`\"\r\n# # # # # #     first_workspace_dependency_onwards, remaining = remaining[:index],remaining[index:]\r\n# # # # # # \r\n# # # # # #     return {\r\n# # # # # #         \"before_first_workspace_dependency\": before_first_workspace_dependency,\r\n# # # # # #         \"first_workspace_dependency_onwards\": first_workspace_dependency_onwards,\r\n# # # # # #     }\r\n# # # # # # \r\n# # # # # # ##### OLD CONTENT OF THIS FILE\r\n# # # # # # \r\n# # # # # # # # {{before_first_workspace_dependency}}\r\n# # # # # # # # cursor_hero_{{crate_name}}_tool = { path = \"./crates/{{crate_name}}_tool\" }\r\n# # # # # # # # {{first_workspace_dependency_onwards}\r\n# # # # # # # \r\n# # # # # # # \r\n# # # # # # # \r\n# # # # # # # def gather_variables(text: str) -> dict[str,str]:\r\n# # # # # # #     find = \"some part of the file\"\r\n# # # # # # #     include = true    index = text.find(find)\r\n# # # # # # #     assert index != -1, f\"Coult not find `{find}`\"\r\n# # # # # # #     before_first_workspace_dependency, remaining = text[:index],text[index:]\r\n# # # # # # # \r\n# # # # # # #     find = \"some part of the file\"\r\n# # # # # # #     include = true    index = remaining.find(find)\r\n# # # # # # #     assert index != -1, f\"Coult not find `{find}`\"\r\n# # # # # # #     first_workspace_dependency_onwards, remaining = remaining[:index],remaining[index:]\r\n# # # # # # # \r\n# # # # # # #     return {\r\n# # # # # # #         \"before_first_workspace_dependency\": before_first_workspace_dependency,\r\n# # # # # # #         \"first_workspace_dependency_onwards\": first_workspace_dependency_onwards,\r\n# # # # # # #     }\r\n# # # # # # # \r\n# # # # # # # ##### OLD CONTENT OF THIS FILE\r\n# # # # # # # \r\n# # # # # # # # # {{before_first_workspace_dependency}}\r\n# # # # # # # # # cursor_hero_{{crate_name}}_tool = { path = \"./crates/{{crate_name}}_tool\" }\r\n# # # # # # # # # {{first_workspace_dependency_onw\r\n# # # # # # # # \r\n# # # # # # # # \r\n# # # # # # # # \r\n# # # # # # # # def gather_variables(text: str) -> dict[str,str]:\r\n# # # # # # # #     find = \"some part of the file\"\r\n# # # # # # # #     include = true    index = text.find(find)\r\n# # # # # # # #     assert index != -1, f\"Coult not find `{find}`\"\r\n# # # # # # # #     before_first_workspace_dependency, remaining = text[:index],text[index:]\r\n# # # # # # # # \r\n# # # # # # # #     find = \"some part of the file\"\r\n# # # # # # # #     include = true    index = remaining.find(find)\r\n# # # # # # # #     assert index != -1, f\"Coult not find `{find}`\"\r\n# # # # # # # #     first_workspace_dependency_onwards, remaining = remaining[:index],remaining[index:]\r\n# # # # # # # # \r\n# # # # # # # #     return {\r\n# # # # # # # #         \"before_first_workspace_dependency\": before_first_workspace_dependency,\r\n# # # # # # # #         \"first_workspace_dependency_onwards\": first_workspace_dependency_onwards,\r\n# # # # # # # #     }\r\n# # # # # # # # \r\n# # # # # # # # ##### OLD CONTENT OF THIS FILE# # {{before_first_workspace_dependency}}\r\n# # # # # # # # # # cursor_hero_{{crate_name}}_tool = { path = \"./crates/{{crate_name}}_tool\" }\r\n# # # # # # # # # \r\n# # # # # # # # # \r\n# # # # # # # # # \r\n# # # # # # # # # \r\n# # # # # # # # # def gather_variables(text: str) -> dict[str,str]:\r\n# # # # # # # # #     find = \"some part of the file\"\r\n# # # # # # # # #     include = true    index = text.find(find)\r\n# # # # # # # # #     assert index != -1, f\"Coult not find `{find}`\"\r\n# # # # # # # # #     before_first_workspace_dependency, remaining = text[:index],text[index:]\r\n# # # # # # # # # \r\n# # # # # # # # #     find = \"some part of the file\"\r\n# # # # # # # # #     include = true    index = remaining.find(find)\r\n# # # # # # # # #     assert index != -1, f\"Coult not find `{find}`\"\r\n# # # # # # # # #     first_workspace_dependency_onwards, remaining = remaining[:index],remaining[index:]\r\n# # # # # # # # # \r\n# # # # # # # # #     return {\r\n# # # # # # # # #         \"before_first_workspace_dependency\": before_first_workspace_dependency,\r\n# # # # # # # # #         \"first_workspace_dependency_onwards\": first_workspace_dependency_onwards,\r\n# # # # # # # # #     }\r\n# # # # # # # # \r\n# # # # # # # # \r\n# # # # # # # \r\n# # # # # # # \r\n# # # # # # \r\n# # # # # # \r\n# # # # # \r\n# # # # # \r\n# # # # \r\n# # # # \r\n# # # \r\n# # # \r\n# # \r\n# # \r\n# \r\n# \r\n\r\n\r\n##### WORKSPACE CONTENT\r\n#[package]\r\n#name = \"cursor_hero\"\r\n#version = \"0.3.0\"\r\n#edition = \"2021\"\r\n#\r\n#[workspace]\r\n#members = [\"crates/*\", \"other/gamepad_hell\", \"other/uparrow-enter\"]\r\n#\r\n## See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n#\r\n#[workspace.dependencies]\r\n#cursor_hero_environment_types = { path = \"./crates/environment_types\" }\r\n#cursor_hero_chat_types = { path = \"./crates/chat_types\" }\r\n#cursor_hero_chat = { path = \"./crates/chat\" }\r\n#cursor_hero_tts = { path = \"./crates/tts\" }\r\n#cursor_hero_tts_types = { path = \"./crates/tts_types\" }\r\n#cursor_hero_observation_types = { path = \"./crates/observation_types\" }\r\n#cursor_hero_observation = { path = \"./crates/observation\" }\r\n#cursor_hero_inference_types = { path = \"./crates/inference_types\" }\r\n#cursor_hero_inference = { path = \"./crates/inference\" }\r\n#cursor_hero_movement_tool_types = { path = \"./crates/movement_tool_types\" }\r\n#cursor_hero_movement_tool = { path = \"./crates/movement_tool\" }\r\n#cursor_hero_character_types = { path = \"./crates/character_types\" }\r\n#cursor_hero_agent_types = { path = \"./crates/agent_types\" }\r\n#cursor_hero_physics_debug = { path = \"./crates/physics_debug\" }\r\n#cursor_hero_math = { path = \"./crates/math\" }\r\n#cursor_hero_cursor_types = { path = \"./crates/pointer_types\" }\r\n#cursor_hero_toolbelt_types = { path = \"./crates/toolbelt_types\" }\r\n#cursor_hero_sprint_tool_types = { path = \"./crates/sprint_tool_types\" }\r\n#cursor_hero_sprint_tool = { path = \"./crates/sprint_tool\" }\r\n#cursor_hero_agent = { path = \"./crates/agent\" }\r\n#cursor_hero_taskbar = { path = \"./crates/taskbar\" }\r\n#cursor_hero_environment_nametag = { path = \"./crates/environment_nametag\" }\r\n#cursor_hero_environment = { path = \"./crates/environment\" }\r\n#cursor_hero_xelu_prompts = { path = \"./crates/xelu_prompts\" }\r\n#cursor_hero_pause_tool = { path = \"./crates/pause_tool\" }\r\n#cursor_hero_wallpaper = { path = \"./crates/wallpaper\" }\r\n#cursor_hero_cursor_mirror = { path = \"./crates/cursor_mirror\" }\r\n#cursor_hero_hover = { path = \"./crates/hover\" }\r\n#cursor_hero_pressure_plate = { path = \"./crates/pressure_plate\" }\r\n#cursor_hero_level_bounds = { path = \"./crates/level_bounds\" }\r\n#cursor_hero_bevy = { path = \"./crates/bevy\" }\r\n#cursor_hero_input = { path = \"./crates/input\" }\r\n#cursor_hero_camera = { path = \"./crates/camera\" }\r\n#cursor_hero_character = { path = \"./crates/character\" }\r\n#cursor_hero_data = { path = \"./crates/data\" }\r\n#cursor_hero_metrics = { path = \"./crates/metrics\" }\r\n#cursor_hero_click_drag_character_movement = { path = \"./crates/click_drag_character_movement\" }\r\n#cursor_hero_physics = { path = \"./crates/physics\" }\r\n#cursor_hero_cursor = { path = \"./crates/pointer\" }\r\n#cursor_hero_screen = { path = \"./crates/screen\" }\r\n#cursor_hero_toolbelt = { path = \"./crates/toolbelt\" }\r\n#cursor_hero_tools = { path = \"./crates/tools\" }\r\n#cursor_hero_ui = { path = \"./crates/ui\" }\r\n#cursor_hero_winutils = { path = \"./crates/winutils\" }\r\n#cursor_hero_restart_memory = { path = \"./crates/restart_memory\" }\r\n#cursor_hero_version = { path = \"./crates/version\" }\r\n#cursor_hero_plugins = { path = \"./crates/plugins\" }\r\n#cursor_hero_icon = { path = \"./crates/icon\" }\r\n##inline_tweak = {git = \"https://github.com/Uriopass/inline_tweak\", version = \"1.1.0\", tag = \"v1.1.0\"} # features=[\"derive\"]\r\n#anyhow = \"1.0.75\"\r\n#glam = \"0.25.0\"\r\n## bevy = { path = \"../bevy\", features = [\"dynamic_linking\"] }\r\n#bevy = { version = \"0.12.1\", git = \"https://github.com/TeamDman/bevy.git\", branch = \"cursor_hero\" }\r\n#bevy-inspector-egui = { version = \"0.22.1\", git = \"https://github.com/TeamDman/bevy-inspector-egui.git\", branch = \"cursor_hero\" }\r\n#bevy_xpbd_2d = { git = \"https://github.com/TeamDman/bevy_xpbd.git\", branch = \"cursor_hero\", features = [\r\n#  \"simd\",\r\n#  \"parallel\",\r\n#] }\r\n#bevy_egui = { git = \"https://github.com/TeamDman/bevy_egui.git\", branch = \"cursor_hero\", version = \"0.24\" }\r\n## enigo = {git = \"https://github.com/TeamDman/enigo\", branch = \"cursor_hero\", version = \"0.1.3\"}\r\n## enigo = {path = \"../../rust/enigo\", version = \"0.1.3\"}\r\n#enigo = \"0.2.0-rc2\"\r\n#egui = \"0.24\"\r\n#crossbeam-channel = \"0.5.8\"\r\n#itertools = \"0.12.0\"\r\n#raw-window-handle = \"0.5.2\"\r\n#leafwing-input-manager = { git = \"https://github.com/TeamDman/leafwing-input-manager.git\", branch = \"cursor_hero\" }\r\n#windows = \"0.51.1\"\r\n#indexmap = \"2.1.0\"\r\n#image = \"0.24.7\"\r\n#screenshots = \"0.8.4\"\r\n#uiautomation = \"0.7.3\"\r\n#serde = { version = \"1.0\", features = [\"derive\"] }\r\n#serde_json = \"1.0\"\r\n#tokio = { version = \"1.32.0\", features = [\"net\", \"full\"] }\r\n#tokio-named-pipes = \"0.1.0\"\r\n#syn = { version = \"2.0.48\", features = [\"full\", \"visit-mut\", \"visit\"] }\r\n#quote = \"1.0.35\"\r\n#proc-macro2 = \"1.0.76\"\r\n#bevy_embedded_assets = { version = \"0.9.1\", git = \"https://github.com/TeamDman/bevy_embedded_assets.git\", branch = \"cursor_hero\" }\r\n#winit = \"0.28.7\"\r\n#fxhash = \"0.2.1\"\r\n#widestring = \"1.0.2\"\r\n#winreg = \"0.52.0\"\r\n#rand = \"0.8.5\"\r\n#ollama-rs = \"0.1.6\"\r\n#reqwest = \"0.11.24\"\r\n#urlencoding = \"2.1.3\"\r\n#chrono = \"0.4.33\"\r\n#\r\n#[dependencies]\r\n#cursor_hero_plugins = { workspace = true }\r\n#cursor_hero_version = { workspace = true }\r\n#bevy = { workspace = true }\r\n#\r\n#\r\n#[dev-dependencies]\r\n#bevy = { workspace = true, features = [\"dynamic_linking\"] }\r\n#\r\n#\r\n#[build-dependencies]\r\n#embed-resource = \"1.6.3\"\r\n#\r\n#[profile.dev]\r\n#opt-level = 1\r\n#\r\n#[profile.dev.package.\"*\"]\r\n#opt-level = 3\r\n#\r\n## [patch.crates-io]\r\n## winit = { path = \"D:/Repos/rust/winit\" }\r\n#\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\templates\\patterns\\new_plugin_with_types\\crates\\plugins\\src\\default_launch_mode_plugin.rs\r\n\r\n````rust\r\n{{use_statements}}\r\nuse cursor_hero_{{crate_name}}::prelude::*;\r\nuse cursor_hero_{{crate_name}}_types::prelude::*;\r\n{{plugin_start}}\r\n        app.add_plugins({{crate_name_pascal}}TypesPlugin);\r\n        app.add_plugins({{crate_name_pascal}}Plugin);\r\n        {{plugin_remaining}}\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\README.md\r\n\r\n````markdown\r\n# Cursor Hero\r\n\r\n[![Visitors](https://api.visitorbadge.io/api/visitors?path=github.com%2FTeamDman%2FCursor-Hero&countColor=%23263759)](https://visitorbadge.io/status?path=github.com%2FTeamDman%2FCursor-Hero)\r\n\r\n## Video demo\r\n\r\n[![yt thumbnail](https://img.youtube.com/vi/t1PYks0UTL8/0.jpg)](https://youtu.be/t1PYks0UTL8)\r\n\r\n## Regarding DualShock controllers\r\n\r\nTry [DS4Windows](https://ds4windows.dev/).\r\n\r\n## Integrations\r\n\r\n- [TeamDman/voice2text: Local speech recognition](https://github.com/teamdman/voice2text)\r\n- [ollama/ollama: Local LLM inference](https://github.com/ollama/ollama)\r\n- [R2D2FISH/glados-tts: GLaDOS speech synthesis](https://github.com/TeamDman/glados-tts.git)\r\n\r\n## Diagnosing problems\r\n\r\n```pwsh\r\n$env:RUST_BACKTRACE=\"1\"\r\n```\r\n\r\n## Project description\r\n\r\nCursor Hero is a thing built using Rust and the Bevy game engine.\r\n\r\nCursor Hero, when launched, presents you with a character that has a cursor. You can move the character and cursor independently using the mouse and keyboard, or using both sticks on a gamepad.\r\n\r\nIn the game world, you can see a scale representation of your monitors. I have three monitors, so when I launch the game I see the left, center, and right monitor, usually containing VSCode, Discord, and the Cursor Hero window itself.\r\n\r\nCursor Hero uses the `windows` crate to integrate tightly with the Windows operating system. It reads and writes the host cursor position, with integrations with the game to do things like position the host mouse \"cursor\" over the in-game \"cursor\", or updating the cursor so that it matches the game world position of the cursor, letting the player interact with the OS using the game representation of the screens.\r\n\r\nThis includes integrating with Windows UI automation to grab the locations of UI elements, copying the texture of the screen onto bricks in the game world that are physics objects.\r\n\r\nUI information is attached to the bricks, using `bevy-egui` to render UI elements with screen coordinates updated to correspond with world-coordinates of the bricks.\r\n\r\nUsing `egui`, the tree hierarchy of the UI is shown for the bricks created by clicking on UI elements in the screen texture. The tree could potentially grow to something like inspect.exe, where the properties of the UI element can be explored. Currently, the tree folding and selectable labels is working, but the properties panel on the right is not yet implemented.\r\n\r\nIn addition to showing the host environment, an agent environment is also constructed. The agent environment contains a virtual agent and a mimicry of the host OS. The mimicry extends to include a copy of the desktop background, a taskbar that pulls the colour from the OS preferences, and a start menu button that toggles visibility of an empty panel.\r\n\r\nThe virtual agent walks in circles. It has an observation buffer which other systems can publish events for something happening, and the buffer will conditionally append such events which are used in the construction of prompts for a local LLM ran using `ollama`.\r\n\r\nIn response to player chat messages, or in response to a period of inactivity, the agent will prompt the LLM in a chat format. With the response, it publishes its own chat message, and it invokes the `glados-tts` to speak the response to the player.\r\n\r\nThis agent behaviour, combined with integration to `voice2text`, allows the human to converse to the agent entirely locally using `whisper-x` to speak with the addition of a push-to-talk button and a toggle-active-listening button.\r\n\r\nGiven that the host cursor is being updated by the game cursor when in gamepad input mode, the game takes care to listen for raw mouse input events to determine when the player is trying to use mouse and keyboard input mode, avoiding holding the cursor captive since traditional input detection is not suitable. After all, if the cursor is programmatically controlled by the game, \"mouse moved events\" become less reliable when aiming for physical movement detection.\r\n\r\nAgain using the `windows` crate, the game is able to identify running processes and programmatically detect the exe path and extract the icons of the process from it.\r\nOpportunity exists to detect dynamic icons from process windows as well.\r\n\r\nThe game has a radial menu for enabling/disabling \"tools\", some of which start disabled and upon enabling will clear and repopulate the tools in the toolbelt with a different loadout.\r\n\r\nThe tool system has been used to show a radial menu of programs in the taskbar, using UI automation to grab the texture at the rect of each item to be displayed radially.\r\n\r\nThere is a tool loadout that lets you snap the game window to any corner or fullscreen of any monitors detected.\r\n\r\nThe default tool loadout starts you in click mode, letting you move your character and its cursor, with the ability to send click events to the OS, and to send click events to game objects using the ECS fundamentals. \r\n\r\nThe game has its own model system for the UI hierarchy, with support for detecting the details of running VSCode windows, including tabs on the left, open tab, contents of the explorer tab if open, editor groups open and involved tabs and file contents, current cursor line and position displayed in the bottom corner.\r\n\r\n## Where do we go from here\r\n\r\nI am continuously exploring many different trajectories for this project.\r\n\r\nSee [`./todo.md`](./todo.md) for brainstorming on potential features to add.\r\n\r\nSee [`./research_notes.md`](./research_notes.md) for links to internet resources that could be helpful.\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui_inspector_types\\src\\ui_inspector_types_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse crate::prelude::*;\r\n\r\npub struct UIInspectorTypesPlugin;\r\n\r\nimpl Plugin for UIInspectorTypesPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.init_resource::<UIData>();\r\n        app.register_type::<UIData>();\r\n        app.register_type::<FetchingState>();\r\n    }\r\n}\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\use cases\\from keep.md\r\n\r\n````markdown\r\nSuggest rename\r\n- get llm to suggest multiple new names for a code symbol\r\n- give context to llm: recent voice and rename activity\r\n- display suggestions as radial menu\r\n- picking a suggestion runs the rename hotkey, types it, hits enter\r\n\r\n\r\n\r\nMake a music mix by picking tracks out of hour long mixes downloaded from YouTube. Use chapter splits and timestamp notices from notes to identify song boundaries\r\n\r\n\r\nView two peoples monitor sets on the same world. Click and drag a file between computers - doorway maybe to make it clear when the transfer will start;passing between the boundary\r\n\r\nPermission zones, read (screen, files, nothing), write (send files to downloads or other configured locations, add torrents to their client and only see the torrents you added) \r\nPermission of read/write for media player playback of a file to perform Syncplay duties\r\n\r\nMonitor set parent to be used as offset for positioning cursor; let them be repositioned as a group and individually\r\n\r\n\r\n\r\nWrapped - create a carousel of the year, a screenshot/file from each day\r\n\r\n\r\n\r\nWhen the computer is locked - map the controller to 0-9\r\nDpad 1,2,3,4\r\nButtins 5,6,7,8\r\nL1 9\r\nR1 0\r\nUnlock using the pin pad\r\n\r\n\r\nPrivacy guards - disable microphone when inputting a password as it can be used to identify keyboard inputs - I wonder how distinct the controller button press sounds are? Todo: train a model to predict controller inputs from their sound\r\nShould be easy to get a ground truth dataset\r\n\r\nMinecraft gear change sound when switching tool(belt)s\r\n\r\n\r\nToolbelts\r\n- numeric input - 0-9 buttons\r\n- intellisense - ctrl, space, tab, arrow keys\r\n- movement - sticks for character and pointer, l3 sprint\r\n- clicking - l1=m2 r1=m1\r\n- voice - r3=voice to text\r\n- pause - unbind all, chord l3+r3+start to equip switcher toolbelt again\r\n- switcher - start and select show different controller previews with keys shown\r\n\r\nSwitcher\r\nHold select to show the wheel\r\nHold start to show another wheel\r\nEach wheel entry is a box with the icons for the tools it contains\r\nSwitching to a Toolbelt will unequip Toolbelt that have conflicting bindings\r\n\r\n\r\nHolding start shows a diagram of the controller. Will need to build a representation of the controller in the game. The Dpad, the sticks, and the buttons can all be used as 8-directional picker wheels. L1, R1 can be used as additional shift keys to open more wheels. \r\n\r\n\r\nRebind tool - show 6 controller previews (select, select+L1, select+r2, start, start+R1, start+r2) with the picker wheels. Let user click and drag toolbelts between picker wheel slots. \r\n\r\nChord rebinding - record a key sequence to identify the source, record a second key sequence as the destination, perform move. \r\n\r\nRebinding is done by changing the runtime input maps in addition to editing the source code defaults so that the changes persist between runs. If the file is open with modifications in vscode, save the file before editing on disk. \r\n\r\n\r\nWindow management tool\r\nL3 - swap - switch the position of the cursor hero window with the window under the pointer. If cursor hero is on left monitor and vscode on main, easily swap the two sizes and positions.\r\nDpad - arrow keys\r\nWest - windows button\r\nSouth - alt\r\nL1 - tab\r\nR1 - mouse1\r\nNorth - maximize\r\nEast - minimize\r\nLets the user do win+tab or alt+tab chords.\r\nL2 - open task bar wheel. Take the task bar and stretch it to fit a circle. Map the pointer position from the wheel to the actual task bar position so when the user clicks with R1 it clicks the task bar. Make the icon at the edge of the circle and have the label on the outside (if at the left of the circle, the icon and label will be reversed from the usual taskbar layout where the icon is to the left of the window title) \r\nIf there are many windows open, the circle will wrap around. Each icon has a larger radius than the previous one, such that it is on a new orbit by the time it wraps around to the start. Only show the window titles for the orbit radius closest to the pointer. \r\n\r\n\r\nRight monitor is easy input switch. Left 2 monitors for work (mouse n keyboard), right monitor to control personal system with the controller. \r\n\r\n\r\nMedia controls\r\n- pause play\r\n- volume\r\n- skip, previous\r\n- show currently playing\r\n\r\n\r\n\r\nBoundary/zone tool\r\nDraw new boundaries\r\nDelete boundaries\r\nLock boundaries\r\nUnlock boundaries\r\n\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\winutils\\src\\win_icons.rs\r\n\r\n````rust\r\nuse crate::win_errors::*;\r\nuse bevy::prelude::default;\r\nuse cursor_hero_math::prelude::bgra_to_rgba;\r\nuse image::ImageBuffer;\r\nuse image::RgbaImage;\r\nuse itertools::Itertools;\r\nuse widestring::U16CString;\r\nuse windows::core::PCWSTR;\r\nuse windows::Win32::Graphics::Gdi::CreateCompatibleDC;\r\nuse windows::Win32::Graphics::Gdi::DeleteDC;\r\nuse windows::Win32::Graphics::Gdi::DeleteObject;\r\nuse windows::Win32::Graphics::Gdi::GetDIBits;\r\nuse windows::Win32::Graphics::Gdi::SelectObject;\r\nuse windows::Win32::Graphics::Gdi::BITMAPINFO;\r\nuse windows::Win32::Graphics::Gdi::BITMAPINFOHEADER;\r\nuse windows::Win32::Graphics::Gdi::DIB_RGB_COLORS;\r\nuse windows::Win32::UI::Shell::ExtractIconExW;\r\nuse windows::Win32::UI::WindowsAndMessaging::CopyIcon;\r\nuse windows::Win32::UI::WindowsAndMessaging::DestroyIcon;\r\nuse windows::Win32::UI::WindowsAndMessaging::GetIconInfoExW;\r\nuse windows::Win32::UI::WindowsAndMessaging::HCURSOR;\r\nuse windows::Win32::UI::WindowsAndMessaging::HICON;\r\nuse windows::Win32::UI::WindowsAndMessaging::ICONINFOEXW;\r\n\r\npub fn get_images_from_exe(executable_path: &str) -> Result<Vec<RgbaImage>> {\r\n    unsafe {\r\n        let path_cstr = U16CString::from_str(executable_path)?;\r\n        let path_pcwstr = PCWSTR(path_cstr.as_ptr());\r\n        let num_icons_total = ExtractIconExW(path_pcwstr, -1, None, None, 0);\r\n        if num_icons_total == 0 {\r\n            return Ok(Vec::new()); // No icons extracted\r\n        }\r\n\r\n        let mut large_icons = vec![HICON::default(); num_icons_total as usize];\r\n        let mut small_icons = vec![HICON::default(); num_icons_total as usize];\r\n        let num_icons_fetched = ExtractIconExW(\r\n            path_pcwstr,\r\n            0,\r\n            Some(large_icons.as_mut_ptr()),\r\n            Some(small_icons.as_mut_ptr()),\r\n            num_icons_total,\r\n        );\r\n\r\n        if num_icons_fetched == 0 {\r\n            return Ok(Vec::new()); // No icons extracted\r\n        }\r\n\r\n        let images = large_icons\r\n            .iter()\r\n            .chain(small_icons.iter())\r\n            .map(convert_hicon_to_rgba_image)\r\n            .filter_map(|r| match r {\r\n                Ok(img) => Some(img),\r\n                Err(e) => {\r\n                    eprintln!(\"Failed to convert HICON to RgbaImage: {:?}\", e);\r\n                    None\r\n                }\r\n            })\r\n            .collect_vec();\r\n\r\n        large_icons\r\n            .iter()\r\n            .chain(small_icons.iter())\r\n            .filter(|icon| !icon.is_invalid())\r\n            .map(|icon| DestroyIcon(*icon))\r\n            .filter_map(|r| r.err())\r\n            .for_each(|e| eprintln!(\"Failed to destroy icon: {:?}\", e));\r\n\r\n        Ok(images)\r\n    }\r\n}\r\n\r\npub fn convert_hicon_to_rgba_image(hicon: &HICON) -> Result<RgbaImage> {\r\n    unsafe {\r\n        let mut icon_info = ICONINFOEXW {\r\n            cbSize: std::mem::size_of::<ICONINFOEXW>() as u32,\r\n            ..default()\r\n        };\r\n\r\n        if !GetIconInfoExW(*hicon, &mut icon_info).as_bool() {\r\n            return Err(Error::from_win32().with_description(format!(\r\n                \"icon \u2022 GetIconInfoExW: {} {}:{}\",\r\n                file!(),\r\n                line!(),\r\n                column!()\r\n            )));\r\n        }\r\n        let hdc_screen = CreateCompatibleDC(None);\r\n        let hdc_mem = CreateCompatibleDC(hdc_screen);\r\n        let hbm_old = SelectObject(hdc_mem, icon_info.hbmColor);\r\n\r\n        let mut bmp_info = BITMAPINFO {\r\n            bmiHeader: BITMAPINFOHEADER {\r\n                biSize: std::mem::size_of::<BITMAPINFOHEADER>() as u32,\r\n                biWidth: icon_info.xHotspot as i32 * 2,\r\n                biHeight: -(icon_info.yHotspot as i32 * 2),\r\n                biPlanes: 1,\r\n                biBitCount: 32,\r\n                biCompression: DIB_RGB_COLORS.0,\r\n                ..Default::default()\r\n            },\r\n            ..Default::default()\r\n        };\r\n\r\n        let mut buffer: Vec<u8> =\r\n            vec![0; (icon_info.xHotspot * 2 * icon_info.yHotspot * 2 * 4) as usize];\r\n\r\n        if GetDIBits(\r\n            hdc_mem,\r\n            icon_info.hbmColor,\r\n            0,\r\n            icon_info.yHotspot * 2,\r\n            Some(buffer.as_mut_ptr() as *mut _),\r\n            &mut bmp_info,\r\n            DIB_RGB_COLORS,\r\n        ) == 0\r\n        {\r\n            return Err(Error::from_win32().with_description(format!(\r\n                \"GetDIBits: {} {}:{}\",\r\n                file!(),\r\n                line!(),\r\n                column!()\r\n            )));\r\n        }\r\n        // Clean up\r\n        SelectObject(hdc_mem, hbm_old);\r\n        DeleteDC(hdc_mem);\r\n        DeleteDC(hdc_screen);\r\n        DeleteObject(icon_info.hbmColor);\r\n        DeleteObject(icon_info.hbmMask);\r\n\r\n        bgra_to_rgba(buffer.as_mut_slice());\r\n\r\n        let image = ImageBuffer::from_raw(icon_info.xHotspot * 2, icon_info.yHotspot * 2, buffer)\r\n            .ok_or_else(|| Error::ImageContainerNotBigEnough)?;\r\n        Ok(image)\r\n    }\r\n}\r\n\r\npub fn convert_hcursor_to_rgba_image(hcursor: &HCURSOR) -> Result<RgbaImage> {\r\n    unsafe {\r\n        // Convert HCURSOR to HICON\r\n        let hicon = CopyIcon(*hcursor)?;\r\n\r\n        // Use the existing convert_hicon_to_rgba_image function\r\n        let image = convert_hicon_to_rgba_image(&hicon)?;\r\n\r\n        // Destroy the HICON (since it was copied)\r\n        DestroyIcon(hicon)?;\r\n\r\n        Ok(image)\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use bevy::math::IVec4;\r\n    use std::path::PathBuf;\r\n\r\n    #[test]\r\n    fn test_convert_hicon_to_rgba_image() {\r\n        let exe_path = r\"C:\\Program Files (x86)\\Microsoft\\Edge\\Application\\msedge.exe\";\r\n        let icons = super::get_images_from_exe(exe_path).unwrap();\r\n\r\n        // Ensure the expected amount is present\r\n        assert_eq!(icons.len(), 30);\r\n\r\n        // Save icons\r\n        let mut path = PathBuf::from(\"target/app_icons\");\r\n        path.push(\"msedge.exe\");\r\n        std::fs::create_dir_all(&path).unwrap();\r\n        for (i, icon) in icons.iter().enumerate() {\r\n            let mut icon_path = path.clone();\r\n            icon_path.push(format!(\"{}.png\", i));\r\n            icon.save(icon_path).unwrap();\r\n        }\r\n\r\n        // Assert all icons are more than just transparent images\r\n        // Also count rgb totals\r\n        let mut passed = vec![false; icons.len()];\r\n        for (i, icon) in icons.iter().enumerate() {\r\n            let mut rgb_count = IVec4::ZERO;\r\n            for pixel in icon.pixels() {\r\n                let pixel = IVec4::new(\r\n                    pixel[0] as i32,\r\n                    pixel[1] as i32,\r\n                    pixel[2] as i32,\r\n                    pixel[3] as i32,\r\n                );\r\n                rgb_count += pixel;\r\n            }\r\n            if rgb_count != IVec4::ZERO {\r\n                passed[i] = true;\r\n            }\r\n        }\r\n        println!(\"{:?}\", passed);\r\n        assert!(passed.iter().all(|&x| x));\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\templates\\patterns\\new_tool\\crates\\{{crate_name}}_tool_types\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_{{crate_name}}_tool_types\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\nleafwing-input-manager = { workspace = true }\r\nbevy-inspector-egui = { workspace = true }\r\ncursor_hero_toolbelt_types = { workspace = true }\r\ncursor_hero_input = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui_inspector_types\\src\\lib.rs\r\n\r\n````rust\r\nmod ui_inspector_types_plugin;\r\nmod ui_inspector_types;\r\n\r\npub mod prelude {\r\n    pub use crate::ui_inspector_types::*;\r\n    pub use crate::ui_inspector_types_plugin::*;\r\n}\r\n````\r\n\r\n\r\n\r\n\r\n",
        "files": []
    },
    "response": {
        "candidates": [
            {
                "content": {
                    "parts": [
                        {
                            "text": "## Analyzing Cursor Hero UI Inspector Logs and Source Code\n\nBased on the provided logs and code snippets, here's my analysis of the potential causes for the UI inspector not showing element properties:\n\n**Observations from the logs:**\n\n*   The `cursor_hero_ui_inspector::ui_inspector_plugin` repeatedly finds `None` while searching for `DrillId::Child(2)`. This suggests an issue with locating the specific element you're trying to inspect.\n*   The logs reveal a list of children, but it's unclear which element corresponds to `DrillId::Child(2)`.\n\n**Potential Causes:**\n\n1.  **Incorrect DrillId:** The `DrillId` might not correctly identify the desired element. Ensure that `DrillId::Child(2)` accurately reflects the element's position in the UI hierarchy.\n2.  **Dynamic UI Changes:** If the UI structure changes after the `DrillId` is obtained, the element might no longer be at the expected location. Consider adding mechanisms to update the `DrillId` when the UI changes.\n3.  **Asynchronous Operations:** If fetching element information involves asynchronous operations, the properties might not be available immediately. Ensure proper synchronization and handling of asynchronous data fetching.\n4.  **Error Handling:** The code might not handle errors effectively during element lookup or property retrieval. Review error handling logic and ensure that errors are logged or otherwise communicated.\n\n**Recommendations:**\n\n*   **Verify DrillId:** Double-check the accuracy of `DrillId::Child(2)` and how it's generated. Consider using more descriptive identifiers if possible.\n*   **Inspect Element Hierarchy:** Use UI inspection tools like Accessibility Insights to understand the actual hierarchy and compare it with your assumptions.\n*   **Debug DrillId Lookup:** Add logging or breakpoints to trace the `drill_id` lookup process and identify where it fails.\n*   **Handle Dynamic UI:** Implement mechanisms to track UI changes and update the `DrillId` accordingly. \n*   **Synchronization:** If asynchronous operations are involved, employ synchronization primitives (e.g., mutexes, channels) or async/await patterns to ensure that properties are available when needed. \n*   **Error Handling:** Review error handling logic and provide informative messages or fallback mechanisms when errors occur.\n\n**Code Review (Limited Scope):**\n\nThe provided code snippets don't directly relate to the UI inspector functionality. However, they offer insights into the project's structure and coding practices. It's important to ensure that the code responsible for UI element lookup and property retrieval follows best practices for error handling, asynchronous operations, and dynamic UI updates. \n\n**Next Steps:**\n\n1.  **Focus on the UI Inspector Code:** Share the relevant code snippets related to UI element lookup and property retrieval for a more targeted analysis.\n2.  **Provide Additional Context:** Describe the expected behavior of the UI inspector and the steps leading to the observed issue. This will help pinpoint the root cause more effectively.\n\n**By following these recommendations and providing more information, we can work together to identify the exact cause of the problem and implement a solution to ensure the UI inspector functions as intended.**\n"
                        }
                    ],
                    "role": "model"
                },
                "finishReason": "STOP",
                "index": 0,
                "safetyRatings": [
                    {
                        "category": "HARM_CATEGORY_SEXUALLY_EXPLICIT",
                        "probability": "NEGLIGIBLE"
                    },
                    {
                        "category": "HARM_CATEGORY_HATE_SPEECH",
                        "probability": "NEGLIGIBLE"
                    },
                    {
                        "category": "HARM_CATEGORY_HARASSMENT",
                        "probability": "NEGLIGIBLE"
                    },
                    {
                        "category": "HARM_CATEGORY_DANGEROUS_CONTENT",
                        "probability": "NEGLIGIBLE"
                    }
                ]
            }
        ]
    }
}