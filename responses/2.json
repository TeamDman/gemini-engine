{
    "response": {
        "candidates": [
            {
                "content": {
                    "parts": [
                        {
                            "text": "## Proposed modifications to `calculator_example.rs`\n\nHere are the modifications you can make to `calculator_example.rs` to achieve the desired functionality:\n\n**1. Define constants for calculator dimensions and margin:**\n\n```rust\nconst CALCULATOR_WIDTH: f32 = 250.0;\nconst CALCULATOR_HEIGHT: f32 = 300.0;\nconst CALCULATOR_MARGIN: f32 = 20.0;\n```\n\n**2. Modify `step_2_of_making_the_calculators_in_the_game_match_the_calculator_apps_running_in_the_host`:**\n\nThis function will handle the received snapshot and spawn/update calculator entities.\n\n```rust\nfn step_2_of_making_the_calculators_in_the_game_match_the_calculator_apps_running_in_the_host(\n    mut snapshot: EventReader<GameboundUISnapshotMessage>,\n    mut calculator_query: Query<(Entity, &mut Calculator)>,\n    mut commands: Commands,\n    asset_server: Res<AssetServer>,\n) {\n    for msg in snapshot.read() {\n        let GameboundUISnapshotMessage::UISnapshot(snapshot) = msg;\n        debug!(\"Received snapshot: {:?}\", snapshot);\n\n        // Despawn existing calculators\n        for (entity, _) in calculator_query.iter_mut() {\n            commands.entity(entity).despawn_recursive();\n        }\n\n        // Spawn new calculators based on snapshot\n        let mut offset_x = 0.0;\n        for app in snapshot.app_windows.iter() {\n            let AppWindow::Calculator(calculator) = app else {\n                continue;\n            };\n\n            let calculator_entity = commands\n                .spawn((\n                    SpriteBundle {\n                        sprite: Sprite {\n                            custom_size: Some(Vec2::new(CALCULATOR_WIDTH, CALCULATOR_HEIGHT)),\n                            color: Color::WHITE,\n                            ..default()\n                        },\n                        transform: Transform::from_xyz(offset_x, 0.0, 0.0),\n                        texture: asset_server.load(\"textures/calculator_bg.png\"), // Replace with your background texture\n                        ..default()\n                    },\n                    calculator.clone(),\n                    Name::new(\"Calculator\"),\n                ))\n                .id();\n\n            // Spawn text display inside the calculator\n            commands.entity(calculator_entity).with_children(|parent| {\n                parent.spawn((\n                    Text2dBundle {\n                        text: Text::from_section(\n                            calculator.memory.buffer.to_string(),\n                            TextStyle {\n                                font: asset_server.load(\"fonts/FiraSans-Bold.ttf\"),\n                                font_size: 30.0,\n                                color: Color::BLACK,\n                            },\n                        ),\n                        transform: Transform::from_xyz(0.0, 50.0, 1.0),\n                        ..default()\n                    },\n                    NumberDisplayPanel,\n                    Name::new(\"Number Display\"),\n                ));\n            });\n\n            offset_x += CALCULATOR_WIDTH + CALCULATOR_MARGIN;\n        }\n    }\n}\n```\n\n**Explanation of changes:**\n\n1. **Constants:** Define constants for the calculator's dimensions and margin to easily control their size and spacing.\n2. **Despawning existing calculators:** The existing calculators are despawned before spawning new ones to ensure a clean slate.\n3. **Spawning new calculators:** \n    - Loop through each `AppWindow::Calculator` in the snapshot.\n    - Spawn a parent `SpriteBundle` with the background texture and desired size.\n    - Set the `Calculator` component with the data from the snapshot.\n    - Calculate the offset for positioning multiple calculators.\n    - Spawn a child entity with the `NumberDisplayPanel` component and display the calculator's buffer value using `Text2dBundle`.\n\n**Additional notes:**\n\n* Replace `\"textures/calculator_bg.png\"` with the actual path to your background texture.\n* You can further customize the appearance of the calculator by modifying the `Sprite` and `TextStyle` properties.\n* This code only handles the number display. You can add buttons and their functionalities in a similar way, using appropriate components and event handling.\n\nThese modifications should allow you to spawn and update calculator entities in your game based on the received snapshot, displaying the number from the host calculator app. \n"
                        }
                    ],
                    "role": "model"
                },
                "finishReason": "STOP",
                "index": 0,
                "safetyRatings": [
                    {
                        "category": "HARM_CATEGORY_SEXUALLY_EXPLICIT",
                        "probability": "NEGLIGIBLE"
                    },
                    {
                        "category": "HARM_CATEGORY_HATE_SPEECH",
                        "probability": "NEGLIGIBLE"
                    },
                    {
                        "category": "HARM_CATEGORY_HARASSMENT",
                        "probability": "NEGLIGIBLE"
                    },
                    {
                        "category": "HARM_CATEGORY_DANGEROUS_CONTENT",
                        "probability": "NEGLIGIBLE"
                    }
                ]
            }
        ]
    },
    "prompt": "\r\n\r\n#REGION crates/calculator_app_types/src/calculator_app_types_plugin.rs\r\nuse crate::prelude::*;\r\nuse bevy::prelude::*;\r\n\r\npub struct CalculatorAppTypesPlugin;\r\n\r\nimpl Plugin for CalculatorAppTypesPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<AppWindow>();\r\n    }\r\n}\r\n\r\n#ENDREGION\r\n\r\n\r\n#REGION crates/calculator_app_types/src/calculator_app_types.rs\r\nuse bevy::prelude::*;\r\n\r\n#[derive(Component, Debug, Reflect)]\r\npub struct AppWindow;\r\n\r\n#ENDREGION\r\n\r\n\r\n#REGION crates/calculator_app_types/src/lib.rs\r\npub mod calculator_app_types;\r\npub mod calculator_app_types_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::calculator_app_types::*;\r\n    pub use crate::calculator_app_types_plugin::*;\r\n}\r\n\r\n#ENDREGION\r\n\r\n\r\n#REGION crates/calculator_app/src/calculator_app_plugin.rs\r\nuse bevy::prelude::*;\r\n\r\npub struct CalculatorAppPlugin;\r\n\r\nimpl Plugin for CalculatorAppPlugin {\r\n    fn build(&self, _app: &mut App) {}\r\n}\r\n\r\n#ENDREGION\r\n\r\n\r\n#REGION crates/calculator_app/src/lib.rs\r\npub mod calculator_app_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::calculator_app_plugin::*;\r\n}\r\n\r\n#ENDREGION\r\n\r\n\r\n#REGION crates/fullscreen_tool/src/fullscreen_tool_populate_plugin.rs\r\nuse bevy::prelude::*;\r\nuse bevy::window::PrimaryWindow;\r\nuse cursor_hero_fullscreen_tool_types::prelude::*;\r\nuse cursor_hero_toolbelt_types::prelude::*;\r\nuse cursor_hero_tools::tool_spawning::NoInputs;\r\nuse cursor_hero_tools::tool_spawning::ToolSpawnConfig;\r\n\r\npub struct FullscreenToolPopulatePlugin;\r\n\r\nimpl Plugin for FullscreenToolPopulatePlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Update, handle_toolbelt_events);\r\n    }\r\n}\r\n\r\nfn handle_toolbelt_events(\r\n    mut commands: Commands,\r\n    asset_server: Res<AssetServer>,\r\n    mut reader: EventReader<ToolbeltPopulateEvent>,\r\n    window_query: Query<&Window, With<PrimaryWindow>>,\r\n) {\r\n    for event in reader.read() {\r\n        let ToolbeltLoadout::WindowPosition = event.loadout else {\r\n            continue;\r\n        };\r\n\r\n        let mode = window_query\r\n            .iter()\r\n            .map(|w| w.mode)\r\n            .next()\r\n            .unwrap_or_default();\r\n        let state = FullscreenTool::state_for_mode(mode);\r\n        debug!(\"Window: {:?}, tool: {:?}\", mode, state);\r\n        ToolSpawnConfig::<_, NoInputs>::new(FullscreenTool, event.id, event)\r\n            .with_src_path(file!().into())\r\n            .guess_name(file!())\r\n            .guess_image(file!(), &asset_server, \"webp\")\r\n            .with_description(\"Toggles fullscreen mode.\")\r\n            .with_starting_state(state)\r\n            .spawn(&mut commands);\r\n    }\r\n}\r\n\r\n#ENDREGION\r\n\r\n\r\n#REGION crates/hover/src/hover_ui_automation_plugin.rs\r\nuse std::thread;\r\n\r\nuse bevy::prelude::*;\r\nuse bevy::window::PrimaryWindow;\r\nuse crossbeam_channel::bounded;\r\nuse crossbeam_channel::Receiver;\r\nuse crossbeam_channel::Sender;\r\nuse cursor_hero_ui_automation::prelude::find_element_at;\r\nuse cursor_hero_ui_automation::prelude::gather_single_element_info;\r\nuse cursor_hero_ui_automation::prelude::ElementInfo;\r\nuse cursor_hero_winutils::win_mouse::get_cursor_position;\r\n\r\nuse cursor_hero_camera::camera_plugin::MainCamera;\r\n\r\npub struct HoverUiAutomationPlugin;\r\n\r\nimpl Plugin for HoverUiAutomationPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        info!(\"Adding HoverInfo resource\");\r\n        app.insert_resource(HoverInfo::default());\r\n        app.register_type::<HoveredElement>();\r\n        app.add_systems(Startup, setup);\r\n        app.add_systems(\r\n            Update,\r\n            (\r\n                update_game_mouse_position,\r\n                update_hover_info,\r\n                show_hovered_rect,\r\n            )\r\n                .chain(),\r\n        );\r\n    }\r\n}\r\n\r\n#[derive(Debug)]\r\nenum GameboundMessage {\r\n    ScreenHoverInfo(ElementInfo),\r\n    ScreenHoverInfoNone,\r\n    GameHoverInfo(ElementInfo),\r\n    GameHoverInfoNone,\r\n}\r\n\r\n#[derive(Debug)]\r\nenum ThreadboundMessage {\r\n    CursorPosition(IVec2),\r\n    CursorPositionNone,\r\n}\r\n\r\n#[derive(Resource)]\r\nstruct Bridge {\r\n    pub sender: Sender<ThreadboundMessage>,\r\n    pub receiver: Receiver<GameboundMessage>,\r\n}\r\n\r\n#[derive(Resource, Default)]\r\npub struct HoverInfo {\r\n    screen_element: Option<ElementInfo>,\r\n    game_element: Option<ElementInfo>,\r\n    enabled: bool,\r\n}\r\nimpl HoverInfo {\r\n    pub fn set_enabled(&mut self, enabled: bool) {\r\n        self.enabled = enabled;\r\n        if !enabled {\r\n            self.screen_element = None;\r\n            self.game_element = None;\r\n        }\r\n    }\r\n    pub fn is_enabled(&self) -> bool {\r\n        self.enabled\r\n    }\r\n}\r\n\r\n#[derive(Component, Reflect)]\r\npub struct HoveredElement {\r\n    pub info: ElementInfo,\r\n}\r\n\r\nfn setup(mut commands: Commands) {\r\n    let (game_tx, game_rx) = bounded::<_>(10);\r\n    let (thread_tx, thread_rx) = bounded::<_>(10);\r\n    commands.insert_resource(Bridge {\r\n        sender: thread_tx,\r\n        receiver: game_rx,\r\n    });\r\n\r\n    let game_tx_clone = game_tx.clone();\r\n    thread::Builder::new()\r\n        .name(\"Screen element hover info thread\".to_string())\r\n        .spawn(move || {\r\n            let game_tx = game_tx_clone;\r\n            loop {\r\n                if let Ok(cursor_pos) = get_cursor_position() {\r\n                    if let Ok(root) = find_element_at(cursor_pos) {\r\n                        let info = gather_single_element_info(&root);\r\n                        match info {\r\n                            Ok(info) => {\r\n                                game_tx\r\n                                    .send(GameboundMessage::ScreenHoverInfo(info))\r\n                                    .unwrap();\r\n                            }\r\n                            Err(_) => {\r\n                                game_tx.send(GameboundMessage::ScreenHoverInfoNone).unwrap();\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                std::thread::sleep(std::time::Duration::from_millis(50));\r\n            }\r\n        })\r\n        .expect(\"Failed to spawn screen element hover info thread\");\r\n\r\n    thread::Builder::new()\r\n        .name(\"Game element hover info thread\".to_string())\r\n        .spawn(move || {\r\n            loop {\r\n                // Block until at least one message is available\r\n                let mut msg = match thread_rx.recv() {\r\n                    Ok(msg) => msg,\r\n                    Err(e) => {\r\n                        error!(\"Failed to receive thread message, exiting: {:?}\", e);\r\n                        break;\r\n                    }\r\n                };\r\n\r\n                // Check for and use the latest message available\r\n                while let Ok(newer_msg) = thread_rx.try_recv() {\r\n                    msg = newer_msg;\r\n                }\r\n                match msg {\r\n                    ThreadboundMessage::CursorPositionNone => {\r\n                        game_tx.send(GameboundMessage::GameHoverInfoNone).unwrap();\r\n                        continue;\r\n                    }\r\n                    ThreadboundMessage::CursorPosition(cursor_pos) => {\r\n                        if let Ok(root) = find_element_at(cursor_pos) {\r\n                            let info = gather_single_element_info(&root);\r\n                            match info {\r\n                                Ok(info) => {\r\n                                    game_tx.send(GameboundMessage::GameHoverInfo(info)).unwrap();\r\n                                }\r\n                                Err(_) => {\r\n                                    game_tx.send(GameboundMessage::GameHoverInfoNone).unwrap();\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                std::thread::sleep(std::time::Duration::from_millis(50));\r\n            }\r\n        })\r\n        .expect(\"Failed to spawn game element hover info thread\");\r\n}\r\n\r\nfn update_game_mouse_position(\r\n    bridge: ResMut<Bridge>,\r\n    camera_query: Query<(&Camera, &GlobalTransform), With<MainCamera>>,\r\n    window_query: Query<&Window, With<PrimaryWindow>>,\r\n    mut debounce: Local<Option<IVec2>>,\r\n    hover_info: Res<HoverInfo>,\r\n) {\r\n    if !hover_info.enabled {\r\n        return;\r\n    }\r\n    let (camera, camera_transform) = camera_query.single();\r\n    let window = window_query.single();\r\n    let value = window\r\n        .cursor_position()\r\n        .and_then(|cursor| camera.viewport_to_world(camera_transform, cursor))\r\n        .map(|ray| ray.origin.truncate())\r\n        .map(|world_position| IVec2::new(world_position.x as i32, -world_position.y as i32));\r\n    if *debounce != value {\r\n        *debounce = value;\r\n        match value {\r\n            Some(value) => bridge\r\n                .sender\r\n                .send(ThreadboundMessage::CursorPosition(value))\r\n                .unwrap(),\r\n            None => bridge\r\n                .sender\r\n                .send(ThreadboundMessage::CursorPositionNone)\r\n                .unwrap(),\r\n        }\r\n    }\r\n}\r\n\r\nfn update_hover_info(mut hovered: ResMut<HoverInfo>, bridge: Res<Bridge>) {\r\n    if !hovered.enabled {\r\n        bridge.receiver.try_iter().for_each(drop);\r\n        return;\r\n    }\r\n    if let Ok(msg) = bridge.receiver.try_recv() {\r\n        match msg {\r\n            GameboundMessage::ScreenHoverInfo(info) => {\r\n                hovered.screen_element = Some(info);\r\n            }\r\n            GameboundMessage::ScreenHoverInfoNone => {\r\n                hovered.screen_element = None;\r\n            }\r\n            GameboundMessage::GameHoverInfo(info) => {\r\n                hovered.game_element = Some(info);\r\n            }\r\n            GameboundMessage::GameHoverInfoNone => {\r\n                hovered.game_element = None;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n#[derive(Component, Reflect, Debug)]\r\nstruct ScreenHoveredIndicatorTag;\r\n#[derive(Component, Reflect, Debug)]\r\nstruct GameHoveredIndicatorTag;\r\n\r\n#[allow(clippy::type_complexity)]\r\nfn show_hovered_rect(\r\n    mut screen_indicator: Query<\r\n        (Entity, &mut Sprite, &mut Transform, &mut HoveredElement),\r\n        (\r\n            With<ScreenHoveredIndicatorTag>,\r\n            Without<GameHoveredIndicatorTag>,\r\n        ),\r\n    >,\r\n    mut game_indicator: Query<\r\n        (Entity, &mut Sprite, &mut Transform, &mut HoveredElement),\r\n        (\r\n            With<GameHoveredIndicatorTag>,\r\n            Without<ScreenHoveredIndicatorTag>,\r\n        ),\r\n    >,\r\n    hovered: Res<HoverInfo>,\r\n    mut commands: Commands,\r\n) {\r\n    if let Ok((entity, mut sprite, mut transform, mut element)) = screen_indicator.get_single_mut()\r\n    {\r\n        if let Some(info) = &hovered.screen_element {\r\n            sprite.custom_size = Some(Vec2::new(\r\n                info.bounding_rect.width(),\r\n                info.bounding_rect.height(),\r\n            ));\r\n            transform.translation = Vec3::new(\r\n                info.bounding_rect.min.x + info.bounding_rect.width() / 2.,\r\n                -info.bounding_rect.min.y - info.bounding_rect.height() / 2.,\r\n                0.,\r\n            );\r\n            element.info = info.clone();\r\n        } else {\r\n            commands.entity(entity).despawn_recursive();\r\n        }\r\n    } else if let Some(info) = &hovered.screen_element {\r\n        commands.spawn((\r\n            SpriteBundle {\r\n                transform: Transform::from_xyz(\r\n                    info.bounding_rect.min.x + info.bounding_rect.width() / 2.,\r\n                    -info.bounding_rect.min.y - info.bounding_rect.height() / 2.,\r\n                    0.,\r\n                ),\r\n                sprite: Sprite {\r\n                    custom_size: Some(Vec2::new(\r\n                        info.bounding_rect.width(),\r\n                        info.bounding_rect.height(),\r\n                    )),\r\n                    color: Color::rgba(0.141, 0.675, 0.949, 0.05),\r\n                    ..default()\r\n                },\r\n                ..default()\r\n            },\r\n            Name::new(\"Screen Hovered Indicator\"),\r\n            ScreenHoveredIndicatorTag,\r\n            HoveredElement { info: info.clone() },\r\n        ));\r\n    }\r\n\r\n    if let Ok((entity, mut sprite, mut transform, mut element)) = game_indicator.get_single_mut() {\r\n        if let Some(info) = &hovered.game_element {\r\n            sprite.custom_size = Some(Vec2::new(\r\n                info.bounding_rect.width(),\r\n                info.bounding_rect.height(),\r\n            ));\r\n            transform.translation = Vec3::new(\r\n                info.bounding_rect.min.x + info.bounding_rect.width() / 2.,\r\n                -info.bounding_rect.min.y - info.bounding_rect.height() / 2.,\r\n                0.,\r\n            );\r\n            element.info = info.clone();\r\n        } else {\r\n            commands.entity(entity).despawn_recursive();\r\n        }\r\n    } else if let Some(info) = &hovered.game_element {\r\n        commands.spawn((\r\n            SpriteBundle {\r\n                transform: Transform::from_xyz(\r\n                    info.bounding_rect.min.x + info.bounding_rect.width() / 2.,\r\n                    -info.bounding_rect.min.y - info.bounding_rect.height() / 2.,\r\n                    0.,\r\n                ),\r\n                sprite: Sprite {\r\n                    custom_size: Some(Vec2::new(\r\n                        info.bounding_rect.width(),\r\n                        info.bounding_rect.height(),\r\n                    )),\r\n                    color: Color::rgba(0.641, 0.275, 0.649, 0.05),\r\n                    ..default()\r\n                },\r\n                ..default()\r\n            },\r\n            Name::new(\"Game Hovered Indicator\"),\r\n            GameHoveredIndicatorTag,\r\n            HoveredElement { info: info.clone() },\r\n        ));\r\n    }\r\n}\r\n\r\n#ENDREGION\r\n\r\n\r\n#REGION crates/hover/src/screenshot_tool.rs\r\nuse bevy::prelude::*;\r\nuse bevy::window::PrimaryWindow;\r\nuse bevy_egui::egui;\r\nuse bevy_egui::egui::Pos2;\r\nuse bevy_egui::EguiContext;\r\nuse bevy_egui::EguiContexts;\r\nuse bevy_inspector_egui::reflect_inspector::Context;\r\nuse bevy_inspector_egui::reflect_inspector::InspectorUi;\r\nuse bevy_xpbd_2d::components::Collider;\r\nuse bevy_xpbd_2d::components::RigidBody;\r\nuse crossbeam_channel::Sender;\r\nuse cursor_hero_bevy::prelude::NegativeYVec2;\r\nuse cursor_hero_bevy::prelude::NegativeYVec3;\r\nuse cursor_hero_camera::camera_plugin::MainCamera;\r\nuse cursor_hero_character_types::prelude::*;\r\nuse cursor_hero_environment_types::prelude::TrackEnvironmentTag;\r\nuse cursor_hero_physics::damping_plugin::MovementDamping;\r\nuse cursor_hero_pointer_types::prelude::*;\r\nuse cursor_hero_screen::get_image::get_image;\r\nuse cursor_hero_screen::get_image::ScreensToImageParam;\r\nuse cursor_hero_toolbelt_types::prelude::*;\r\nuse cursor_hero_tools::cube_tool::CubeToolInteractable;\r\nuse cursor_hero_tools::prelude::*;\r\nuse cursor_hero_ui_automation::prelude::find_element_at;\r\nuse cursor_hero_ui_automation::prelude::gather_elements_at;\r\nuse cursor_hero_ui_automation::prelude::gather_incomplete_ui_tree_starting_deep;\r\nuse cursor_hero_ui_automation::prelude::DrillId;\r\nuse cursor_hero_ui_automation::prelude::ElementInfo;\r\nuse cursor_hero_worker::prelude::Message;\r\nuse cursor_hero_worker::prelude::WorkerConfig;\r\nuse cursor_hero_worker::prelude::WorkerPlugin;\r\nuse itertools::Itertools;\r\nuse leafwing_input_manager::prelude::*;\r\nuse rand::thread_rng;\r\nuse rand::Rng;\r\n\r\npub struct ScreenshotToolPlugin;\r\n\r\nimpl Plugin for ScreenshotToolPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_plugins(WorkerPlugin {\r\n            config: WorkerConfig::<ThreadboundMessage, GameboundMessage> {\r\n                name: \"screenshot_tool\".to_string(),\r\n                is_ui_automation_thread: true,\r\n                handle_threadbound_message,\r\n                ..default()\r\n            },\r\n        });\r\n        app.register_type::<ScreenshotTool>();\r\n        app.register_type::<ScreenshotBrick>();\r\n        app.add_plugins(InputManagerPlugin::<ScreenshotToolAction>::default());\r\n        app.add_systems(Update, toolbelt_events);\r\n        app.add_systems(Update, handle_input);\r\n        app.add_systems(Update, handle_replies);\r\n        app.add_systems(Update, ui);\r\n    }\r\n}\r\n\r\n#[derive(Debug, Reflect, Clone, Event)]\r\nenum ThreadboundMessage {\r\n    Capture { world_position: Vec3 },\r\n    CaptureBrick { world_position: Vec3 },\r\n    Print { world_position: Vec3 },\r\n    Fracture { world_position: Vec3 },\r\n}\r\nimpl Message for ThreadboundMessage {}\r\n\r\n#[derive(Debug, Reflect, Clone, Event)]\r\nenum GameboundMessage {\r\n    Capture {\r\n        ui_tree: ElementInfo,\r\n        hovered_element: ElementInfo,\r\n        world_position: Vec3,\r\n    },\r\n    CaptureBrick {\r\n        ui_tree: ElementInfo,\r\n        hovered_element: ElementInfo,\r\n        world_position: Vec3,\r\n    },\r\n    Print(ElementInfo),\r\n    Fracture {\r\n        data: Vec<(ElementInfo, usize)>,\r\n        world_position: Vec3,\r\n    },\r\n}\r\nimpl Message for GameboundMessage {}\r\n\r\n#[derive(Component, Reflect, Default)]\r\nstruct ScreenshotTool;\r\n\r\n#[derive(Actionlike, PartialEq, Eq, Clone, Copy, Hash, Debug, Reflect)]\r\nenum ScreenshotToolAction {\r\n    Capture,\r\n    CaptureBrick,\r\n    Print,\r\n    Fracture,\r\n}\r\nimpl ScreenshotToolAction {\r\n    fn default_gamepad_binding(&self) -> UserInput {\r\n        match self {\r\n            Self::Capture => GamepadButtonType::RightTrigger.into(),\r\n            Self::CaptureBrick => GamepadButtonType::South.into(),\r\n            Self::Print => GamepadButtonType::North.into(),\r\n            Self::Fracture => GamepadButtonType::Select.into(),\r\n        }\r\n    }\r\n\r\n    fn default_mkb_binding(&self) -> UserInput {\r\n        match self {\r\n            Self::Capture => MouseButton::Left.into(),\r\n            Self::CaptureBrick => MouseButton::Middle.into(),\r\n            Self::Print => MouseButton::Right.into(),\r\n            Self::Fracture => KeyCode::G.into(),\r\n        }\r\n    }\r\n}\r\nimpl ToolAction for ScreenshotToolAction {\r\n    fn default_input_map(_event: &ToolbeltPopulateEvent) -> Option<InputMap<ScreenshotToolAction>> {\r\n        let mut input_map = InputMap::default();\r\n\r\n        for variant in ScreenshotToolAction::variants() {\r\n            input_map.insert(variant.default_mkb_binding(), variant);\r\n            input_map.insert(variant.default_gamepad_binding(), variant);\r\n        }\r\n        Some(input_map)\r\n    }\r\n}\r\n\r\n#[derive(Reflect, Default)]\r\nstruct ScreenshotBrickEguiState {\r\n    selected: Option<DrillId>,\r\n    expanded: Vec<DrillId>,\r\n}\r\n\r\n#[derive(Component, Reflect)]\r\nstruct ScreenshotBrick {\r\n    ui_tree: ElementInfo,\r\n    hero_element: ElementInfo,\r\n    egui_state: ScreenshotBrickEguiState,\r\n}\r\n\r\nfn toolbelt_events(\r\n    mut commands: Commands,\r\n    asset_server: Res<AssetServer>,\r\n    mut reader: EventReader<ToolbeltPopulateEvent>,\r\n) {\r\n    for event in reader.read() {\r\n        if event.loadout == ToolbeltLoadout::Inspector {\r\n            ToolSpawnConfig::<ScreenshotTool, ScreenshotToolAction>::new(\r\n                ScreenshotTool,\r\n                event.id,\r\n                event,\r\n            )\r\n            .with_src_path(file!().into())\r\n            .guess_name(file!())\r\n            .guess_image(file!(), &asset_server, \"webp\")\r\n            .with_description(\"Turn UI elements into information.\")\r\n            .spawn(&mut commands);\r\n        }\r\n    }\r\n}\r\n\r\nfn handle_input(\r\n    tools: Query<(&ActionState<ScreenshotToolAction>, &Parent), With<ActiveTool>>,\r\n    toolbelts: Query<&Parent, With<Toolbelt>>,\r\n    characters: Query<&Children, With<Character>>,\r\n    pointers: Query<&GlobalTransform, With<Pointer>>,\r\n    mut bridge: EventWriter<ThreadboundMessage>,\r\n    egui_context_query: Query<&EguiContext, With<PrimaryWindow>>,\r\n) {\r\n    for tool in tools.iter() {\r\n        let (tool_actions, tool_parent) = tool;\r\n\r\n        let Ok(toolbelt) = toolbelts.get(tool_parent.get()) else {\r\n            warn!(\"Tool not inside a toolbelt?\");\r\n            continue;\r\n        };\r\n        let toolbelt_parent = toolbelt;\r\n\r\n        let Ok(character) = characters.get(toolbelt_parent.get()) else {\r\n            warn!(\"Toolbelt parent not a character?\");\r\n            continue;\r\n        };\r\n        let character_children = character;\r\n\r\n        let Some(pointer) = character_children\r\n            .iter()\r\n            .filter_map(|x| pointers.get(*x).ok())\r\n            .next()\r\n        else {\r\n            //TODO: warn if more than one pointer found\r\n            warn!(\"Character {:?} missing a pointer?\", toolbelt_parent.get());\r\n            debug!(\"Character children: {:?}\", character_children);\r\n            continue;\r\n        };\r\n        let pointer_transform = pointer;\r\n        let pointer_translation = pointer_transform.translation();\r\n        let hovering_over_egui = egui_context_query\r\n            .get_single()\r\n            .ok()\r\n            .map(|egui_context| egui_context.clone().get_mut().is_pointer_over_area())\r\n            .unwrap_or(false);\r\n        if hovering_over_egui {\r\n            continue;\r\n        }\r\n        if tool_actions.just_pressed(ScreenshotToolAction::Capture) {\r\n            info!(\"Capture\");\r\n            let msg = ThreadboundMessage::Capture {\r\n                world_position: pointer_translation,\r\n            };\r\n            bridge.send(msg);\r\n        }\r\n        if tool_actions.just_pressed(ScreenshotToolAction::CaptureBrick) {\r\n            info!(\"CaptureBrick\");\r\n            let msg = ThreadboundMessage::CaptureBrick {\r\n                world_position: pointer_translation,\r\n            };\r\n            bridge.send(msg);\r\n        }\r\n        if tool_actions.just_pressed(ScreenshotToolAction::Print) {\r\n            info!(\"Print\");\r\n            let msg = ThreadboundMessage::Print {\r\n                world_position: pointer_translation,\r\n            };\r\n            bridge.send(msg);\r\n        }\r\n        if tool_actions.just_pressed(ScreenshotToolAction::Fracture) {\r\n            info!(\"Fracture\");\r\n            let msg = ThreadboundMessage::Fracture {\r\n                world_position: pointer_translation,\r\n            };\r\n            bridge.send(msg);\r\n        }\r\n    }\r\n}\r\n\r\nfn handle_threadbound_message(\r\n    msg: &ThreadboundMessage,\r\n    reply_tx: &Sender<GameboundMessage>,\r\n) -> Result<(), Box<dyn std::error::Error>> {\r\n    match msg {\r\n        ThreadboundMessage::Capture { world_position }\r\n        | ThreadboundMessage::CaptureBrick { world_position } => {\r\n            let mouse_position = world_position.xy().neg_y().as_ivec2();\r\n            debug!(\"Worker received click: {:?} {:?}\", msg, mouse_position);\r\n\r\n            let elem = find_element_at(mouse_position)?;\r\n            info!(\"{} - {}\", elem.get_classname()?, elem.get_name()?);\r\n\r\n            let id = elem.get_automation_id()?;\r\n            info!(\"Automation ID: {}\", id);\r\n            let gathered = gather_incomplete_ui_tree_starting_deep(elem)?;\r\n            // debug!(\"Element info: {:?}\", element_info);\r\n            let msg = match msg {\r\n                ThreadboundMessage::Capture { world_position } => GameboundMessage::Capture {\r\n                    ui_tree: gathered.ui_tree,\r\n                    hovered_element: gathered.start_info,\r\n                    world_position: *world_position,\r\n                },\r\n                ThreadboundMessage::CaptureBrick { world_position } => {\r\n                    GameboundMessage::CaptureBrick {\r\n                        ui_tree: gathered.ui_tree,\r\n                        hovered_element: gathered.start_info,\r\n                        world_position: *world_position,\r\n                    }\r\n                }\r\n                _ => unreachable!(),\r\n            };\r\n            reply_tx.send(msg)?;\r\n        }\r\n        ThreadboundMessage::Print { world_position } => {\r\n            let mouse_position = world_position.xy().neg_y().as_ivec2();\r\n            debug!(\"Worker received click: {:?} {:?}\", msg, mouse_position);\r\n\r\n            let elem = find_element_at(mouse_position)?;\r\n            info!(\"{:?}\", elem);\r\n\r\n            // Can we click on elements with this?\r\n            // elem.send_keys(keys, interval) exists!\r\n\r\n            // Send the info\r\n            let id = elem.get_automation_id()?;\r\n            info!(\"Automation ID: {}\", id);\r\n            let gathered = gather_incomplete_ui_tree_starting_deep(elem)?;\r\n            reply_tx.send(GameboundMessage::Print(gathered.ui_tree))?;\r\n        }\r\n        ThreadboundMessage::Fracture { world_position } => {\r\n            let mouse_position = world_position.xy().neg_y().as_ivec2();\r\n            debug!(\"Worker received click: {:?} {:?}\", msg, mouse_position);\r\n\r\n            let found = gather_elements_at(mouse_position)?;\r\n            let data = found\r\n                .into_iter()\r\n                .filter_map(|(elem, depth)| {\r\n                    gather_incomplete_ui_tree_starting_deep(elem)\r\n                        .ok()\r\n                        .map(|info| (info.start_info, depth))\r\n                })\r\n                .collect();\r\n            reply_tx.send(GameboundMessage::Fracture {\r\n                data,\r\n                world_position: *world_position,\r\n            })?;\r\n        }\r\n    }\r\n\r\n    Ok(())\r\n}\r\n\r\nfn handle_replies(\r\n    mut commands: Commands,\r\n    mut bridge: EventReader<GameboundMessage>,\r\n    screen_access: ScreensToImageParam,\r\n    asset_server: Res<AssetServer>,\r\n) {\r\n    for msg in bridge.read() {\r\n        match &msg {\r\n            GameboundMessage::Capture {\r\n                ui_tree,\r\n                hovered_element,\r\n                world_position,\r\n            }\r\n            | GameboundMessage::CaptureBrick {\r\n                ui_tree,\r\n                hovered_element,\r\n                world_position,\r\n            } => {\r\n                let (size, pos, texture_region) = match msg {\r\n                    GameboundMessage::Capture { .. } => (\r\n                        hovered_element.bounding_rect.size(),\r\n                        hovered_element.bounding_rect.center().extend(20.0).neg_y(),\r\n                        hovered_element.bounding_rect,\r\n                    ),\r\n                    GameboundMessage::CaptureBrick { .. } => (\r\n                        hovered_element.bounding_rect.size().normalize() * 60.0,\r\n                        *world_position,\r\n                        hovered_element.bounding_rect,\r\n                    ),\r\n                    _ => unreachable!(),\r\n                };\r\n                spawn_brick(\r\n                    &mut commands,\r\n                    ui_tree,\r\n                    hovered_element,\r\n                    size,\r\n                    pos,\r\n                    texture_region,\r\n                    &screen_access,\r\n                    &asset_server,\r\n                );\r\n            }\r\n            GameboundMessage::Print(info) => {\r\n                info!(\"Received info for element {:?}\", info);\r\n                commands.spawn((\r\n                    AudioBundle {\r\n                        source: asset_server.load(\"sounds/tape recorder eject 4.ogg\"),\r\n                        settings: PlaybackSettings::REMOVE,\r\n                    },\r\n                    Name::new(format!(\"SFX Element - {}\", info.name)),\r\n                ));\r\n            }\r\n            GameboundMessage::Fracture {\r\n                data,\r\n                world_position,\r\n            } => {\r\n                info!(\"Received info with {} elements\", data.len());\r\n                if !data.is_empty() {\r\n                    commands.spawn((\r\n                        SpatialBundle {\r\n                            transform: Transform::from_translation(*world_position),\r\n                            ..default()\r\n                        },\r\n                        AudioBundle {\r\n                            source: asset_server.load(\"sounds/spring strung light 4.ogg\"),\r\n                            settings: PlaybackSettings::DESPAWN.with_spatial(true),\r\n                        },\r\n                        Name::new(\"Fracture Sound\"),\r\n                    ));\r\n                }\r\n                for (info, depth) in data {\r\n                    // let Ok(image) = get_image(info.bounding_rect, &access) else {\r\n                    //     continue;\r\n                    // };\r\n                    // let texture_handle = asset_server.add(image);\r\n\r\n                    // spawn the element image\r\n                    let mut elem_center_pos = info.bounding_rect.center().extend(*depth as f32);\r\n                    elem_center_pos.y *= -1.0;\r\n                    commands.spawn((\r\n                        SpriteBundle {\r\n                            transform: Transform::from_translation(elem_center_pos),\r\n                            sprite: Sprite {\r\n                                custom_size: Some(info.bounding_rect.size()),\r\n                                color: Color::hsl(thread_rng().gen_range(0.0..360.0), 0.5, 0.5),\r\n                                ..default()\r\n                            },\r\n                            // texture: texture_handle,\r\n                            ..default()\r\n                        },\r\n                        CubeToolInteractable,\r\n                        RigidBody::Dynamic,\r\n                        Collider::cuboid(info.bounding_rect.width(), info.bounding_rect.height()),\r\n                        MovementDamping::default(),\r\n                        Name::new(format!(\"Element - {}\", info.name)),\r\n                    ));\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfn spawn_brick(\r\n    commands: &mut Commands,\r\n    ui_tree: &ElementInfo,\r\n    hero_element: &ElementInfo,\r\n    size: Vec2,\r\n    pos: Vec3,\r\n    texture_region: Rect,\r\n    screen_access: &ScreensToImageParam,\r\n    asset_server: &Res<AssetServer>,\r\n) {\r\n    let Ok(image) = get_image(texture_region, screen_access) else {\r\n        return;\r\n    };\r\n    let texture_handle = asset_server.add(image);\r\n    let expanded = ui_tree\r\n        .get_descendents()\r\n        .iter()\r\n        .chain([ui_tree].iter())\r\n        .filter(|x| x.children.is_some())\r\n        .map(|x| x.drill_id.clone())\r\n        .collect();\r\n    commands.spawn((\r\n        SpriteBundle {\r\n            transform: Transform::from_translation(pos),\r\n            sprite: Sprite {\r\n                custom_size: Some(size),\r\n                ..default()\r\n            },\r\n            texture: texture_handle,\r\n            ..default()\r\n        },\r\n        AudioBundle {\r\n            source: asset_server.load(\"sounds/spring strung light 4.ogg\"),\r\n            settings: PlaybackSettings::REMOVE.with_spatial(true),\r\n        },\r\n        // FloatyName {\r\n        //     text: element_info.name.clone(),\r\n        //     vertical_offset: 40.0,\r\n        //     appearance: NametagAppearance::Databrick,\r\n        // },\r\n        Hoverable,\r\n        Clickable,\r\n        CubeToolInteractable,\r\n        RigidBody::Dynamic,\r\n        TrackEnvironmentTag,\r\n        ScreenshotBrick {\r\n            ui_tree: ui_tree.clone(),\r\n            hero_element: hero_element.clone(),\r\n            egui_state: ScreenshotBrickEguiState {\r\n                selected: Some(hero_element.drill_id.clone()),\r\n                expanded,\r\n            },\r\n        },\r\n        Collider::cuboid(size.x, size.y),\r\n        MovementDamping::default(),\r\n        Name::new(format!(\"Element - {}\", hero_element.name)),\r\n    ));\r\n}\r\n\r\nfn ui(\r\n    mut commands: Commands,\r\n    screen_access: ScreensToImageParam,\r\n    asset_server: Res<AssetServer>,\r\n    mut contexts: EguiContexts,\r\n    mut brick_query: Query<(\r\n        Entity,\r\n        &mut ScreenshotBrick,\r\n        &Sprite,\r\n        &Name,\r\n        &GlobalTransform,\r\n    )>,\r\n    camera_query: Query<(&GlobalTransform, &Camera), With<MainCamera>>,\r\n    type_registry: Res<AppTypeRegistry>,\r\n) {\r\n    let Ok(camera) = camera_query.get_single() else {\r\n        warn!(\"No camera found\");\r\n        return;\r\n    };\r\n    let (camera_transform, camera) = camera;\r\n\r\n    let ctx = contexts.ctx_mut();\r\n    // let scale = (camera_transform.compute_transform().scale.x * 1.0).round();\r\n    // debug!(\"Scale: {}\", scale);\r\n    // ctx.set_zoom_factor(scale);\r\n\r\n    if brick_query.is_empty() {\r\n        return;\r\n    }\r\n\r\n    let mut cx = Context {\r\n        world: None,\r\n        queue: None,\r\n    };\r\n\r\n    let type_registry = type_registry.0.clone();\r\n    let type_registry = type_registry.read();\r\n\r\n    let mut inspector = InspectorUi::for_bevy(&type_registry, &mut cx);\r\n\r\n    for brick in brick_query.iter_mut() {\r\n        let (brick_id, mut brick, brick_sprite, brick_name, brick_global_transform) = brick;\r\n        let brick_global_translation = brick_global_transform.translation();\r\n        let popout_pos = brick_global_translation\r\n            + Vec3::new(\r\n                brick_sprite.custom_size.unwrap_or_default().x + 50.0,\r\n                0.0,\r\n                0.0,\r\n            );\r\n        let egui_pos = camera\r\n            .world_to_viewport(camera_transform, brick_global_translation)\r\n            .unwrap_or_default();\r\n\r\n        let id = egui::Id::new(brick_id);\r\n\r\n        egui::Window::new(brick_name.chars().take(64).collect::<String>())\r\n            .id(id)\r\n            .fixed_pos(Pos2::new(egui_pos.x, egui_pos.y))\r\n            .default_width(1200.0)\r\n            // .resizable(true)\r\n            .show(ctx, |ui| {\r\n                egui::SidePanel::left(id.with(\"tree\"))\r\n                    .resizable(true)\r\n                    .width_range(100.0..=4000.0)\r\n                    .default_width(600.0)\r\n                    .show_inside(ui, |ui| {\r\n                        ui.vertical_centered(|ui| {\r\n                            ui.heading(\"UI Tree\");\r\n                        });\r\n                        egui::ScrollArea::both().show(ui, |ui| {\r\n                            let id = id.with(brick.ui_tree.runtime_id.clone());\r\n\r\n                            let mut temp_egui_state = std::mem::take(&mut brick.egui_state);\r\n                            let mut temp_info = std::mem::take(&mut brick.ui_tree);\r\n                            ui_for_element_info(\r\n                                &mut temp_egui_state,\r\n                                id,\r\n                                &mut commands,\r\n                                &screen_access,\r\n                                &asset_server,\r\n                                ui,\r\n                                &mut temp_info,\r\n                                &mut inspector,\r\n                                &popout_pos,\r\n                            );\r\n                            brick.egui_state = temp_egui_state;\r\n                            brick.ui_tree = temp_info;\r\n\r\n                            ui.allocate_space(ui.available_size());\r\n                        });\r\n                    });\r\n\r\n                egui::TopBottomPanel::bottom(id.with(\"invisible bottom panel\"))\r\n                    .show_separator_line(false)\r\n                    .show_inside(ui, |_| ());\r\n\r\n                egui::CentralPanel::default().show_inside(ui, |ui| {\r\n                    ui.heading(\"AHOY!\");\r\n                    let id = brick.egui_state.selected.clone();\r\n                    if let Some(id) = id\r\n                        && let Some(x) = brick.ui_tree.lookup_drill_id_mut(id)\r\n                    {\r\n                        inspector.ui_for_reflect(x, ui);\r\n                    }\r\n                    // inspector.ui_for_reflect_readonly(&data, ui);\r\n                });\r\n            });\r\n    }\r\n}\r\n\r\n#[derive(Reflect, Debug)]\r\nstruct ElementUIData {\r\n    runtime_id: String,\r\n    frick: String,\r\n}\r\n\r\n#[allow(clippy::too_many_arguments)]\r\nfn ui_for_element_info(\r\n    state: &mut ScreenshotBrickEguiState,\r\n    id: egui::Id,\r\n    commands: &mut Commands,\r\n    screen_access: &ScreensToImageParam,\r\n    asset_server: &Res<AssetServer>,\r\n    ui: &mut egui::Ui,\r\n    element_info: &mut ElementInfo,\r\n    _inspector: &mut InspectorUi,\r\n    popout_pos: &Vec3,\r\n) {\r\n    egui::collapsing_header::CollapsingState::load_with_default_open(\r\n        ui.ctx(),\r\n        id,\r\n        state.expanded.contains(&element_info.drill_id),\r\n    )\r\n    .show_header(ui, |ui| {\r\n        let mut selected = state.selected == Some(element_info.drill_id.clone());\r\n        if ui\r\n            .toggle_value(\r\n                &mut selected,\r\n                format!(\r\n                    \"{:?} | {}\",\r\n                    element_info.name, element_info.localized_control_type\r\n                ),\r\n            )\r\n            .changed()\r\n        {\r\n            state.selected = if selected {\r\n                Some(element_info.drill_id.clone())\r\n            } else {\r\n                None\r\n            };\r\n        };\r\n    })\r\n    .body(|ui| {\r\n        // if ui.button(\"Popout\").clicked() {\r\n        //     spawn_brick(\r\n        //         commands,\r\n        //         element_info,\r\n        //         element_info.bounding_rect.size(),\r\n        //         *popout_pos,\r\n        //         screen_access,\r\n        //         asset_server,\r\n        //     )\r\n        // }\r\n\r\n        if let Some(children) = &mut element_info.children {\r\n            for child in children.iter_mut() {\r\n                ui_for_element_info(\r\n                    state,\r\n                    id.with(child.runtime_id.clone()),\r\n                    commands,\r\n                    screen_access,\r\n                    asset_server,\r\n                    ui,\r\n                    child,\r\n                    _inspector,\r\n                    popout_pos,\r\n                );\r\n            }\r\n        }\r\n    });\r\n}\r\n\r\n#ENDREGION\r\n\r\n\r\n#REGION crates/movement_tool/src/movement_tool_populate_plugin.rs\r\nuse bevy::prelude::*;\r\nuse cursor_hero_movement_tool_types::prelude::*;\r\nuse cursor_hero_toolbelt_types::prelude::*;\r\nuse cursor_hero_tools::tool_spawning::ToolSpawnConfig;\r\n\r\npub struct MovementToolPopulatePlugin;\r\n\r\nimpl Plugin for MovementToolPopulatePlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Update, handle_toolbelt_events);\r\n    }\r\n}\r\n\r\nfn handle_toolbelt_events(\r\n    mut commands: Commands,\r\n    asset_server: Res<AssetServer>,\r\n    mut reader: EventReader<ToolbeltPopulateEvent>,\r\n) {\r\n    for event in reader.read() {\r\n        match event.loadout {\r\n            ToolbeltLoadout::Default\r\n            | ToolbeltLoadout::Inspector\r\n            | ToolbeltLoadout::Taskbar\r\n            | ToolbeltLoadout::WindowPosition\r\n            | ToolbeltLoadout::Keyboard => {\r\n                ToolSpawnConfig::<_, MovementToolAction>::new(\r\n                    MovementTool::default(),\r\n                    event.id,\r\n                    event,\r\n                )\r\n                .with_src_path(file!().into())\r\n                .guess_name(file!())\r\n                .guess_image(file!(), &asset_server, \"png\")\r\n                .with_description(\"Go faster, reach further\")\r\n                .spawn(&mut commands);\r\n            }\r\n            ToolbeltLoadout::Agent => {\r\n                ToolSpawnConfig::<_, MovementToolAction>::new(\r\n                    MovementTool::default(),\r\n                    event.id,\r\n                    event,\r\n                )\r\n                .with_src_path(file!().into())\r\n                .with_input_map(None)\r\n                .guess_name(file!())\r\n                .guess_image(file!(), &asset_server, \"png\")\r\n                .with_description(\"Go faster, reach further\")\r\n                .spawn(&mut commands);\r\n            }\r\n            _ => {}\r\n        }\r\n    }\r\n}\r\n\r\n#ENDREGION\r\n\r\n\r\n#REGION crates/pressure_plate/src/pressure_plate_plugin.rs\r\nuse bevy::prelude::*;\r\nuse bevy_xpbd_2d::components::CollidingEntities;\r\n\r\npub struct PressurePlatePlugin;\r\nimpl Plugin for PressurePlatePlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Update, update_plate)\r\n            .add_event::<PressurePlateActivationEvent>()\r\n            .register_type::<PressurePlate>();\r\n    }\r\n}\r\n\r\n#[derive(Event)]\r\npub struct PressurePlateActivationEvent(pub Entity);\r\n\r\n#[derive(Component, Reflect)]\r\npub struct PressurePlate {\r\n    active_time: f32,\r\n    debounce: bool,\r\n    indicator: Entity,\r\n}\r\n\r\n#[derive(Component, Default, Reflect)]\r\npub struct PressurePlateProgressIndicator {\r\n    visual_progress: f32,\r\n}\r\n\r\nimpl PressurePlate {\r\n    pub fn new(indicator: Entity) -> Self {\r\n        Self {\r\n            active_time: 0.0,\r\n            debounce: false,\r\n            indicator,\r\n        }\r\n    }\r\n}\r\n\r\n#[allow(clippy::type_complexity)]\r\nfn update_plate(\r\n    asset_server: Res<AssetServer>,\r\n    mut commands: Commands,\r\n    time: Res<Time>,\r\n    mut query: Query<\r\n        (\r\n            Entity,\r\n            &mut PressurePlate,\r\n            &mut Sprite,\r\n            &CollidingEntities,\r\n            Option<&SpatialAudioSink>,\r\n        ),\r\n        Without<PressurePlateProgressIndicator>,\r\n    >,\r\n    mut indicator_query: Query<\r\n        (&mut PressurePlateProgressIndicator, &mut Sprite),\r\n        Without<PressurePlate>,\r\n    >,\r\n    mut activation_writer: EventWriter<PressurePlateActivationEvent>,\r\n) {\r\n    for (entity, mut plate, mut sprite, colliding_entities, sink) in &mut query {\r\n        if colliding_entities.0.is_empty() {\r\n            sprite.color = Color::rgb(0.2, 0.7, 0.9);\r\n            plate.active_time = 0.0;\r\n            sink.map(SpatialAudioSink::stop);\r\n            plate.debounce = false;\r\n        } else {\r\n            if plate.debounce {\r\n                continue;\r\n            }\r\n            sprite.color = Color::rgb(0.9, 0.7, 0.2);\r\n            if plate.active_time == 0.0 {\r\n                let bundle = AudioBundle {\r\n                    source: asset_server.load(\"sounds/pressure plate activation.ogg\"),\r\n                    settings: PlaybackSettings::REMOVE.with_spatial(true),\r\n                };\r\n                commands.entity(entity).insert(bundle);\r\n                plate.active_time += time.delta_seconds();\r\n            } else {\r\n                plate.active_time += time.delta_seconds();\r\n                if plate.active_time > cursor_hero_data::sounds::PRESSURE_PLATE_ACTIVATION_DURATION\r\n                {\r\n                    plate.active_time = 0.0;\r\n                    plate.debounce = true;\r\n                    activation_writer.send(PressurePlateActivationEvent(entity));\r\n                }\r\n            }\r\n        }\r\n        if let Ok((mut indicator, mut indicator_sprite)) = indicator_query.get_mut(plate.indicator)\r\n        {\r\n            indicator.visual_progress =\r\n                plate.active_time / cursor_hero_data::sounds::PRESSURE_PLATE_ACTIVATION_DURATION;\r\n            indicator_sprite.color = Color::rgb(0.2, 0.7, 0.9) * indicator.visual_progress;\r\n        }\r\n    }\r\n}\r\n\r\n#ENDREGION\r\n\r\n\r\n#REGION crates/toolbelt/src/tool_help_populate.rs\r\nuse cursor_hero_host_fs_types::host_fs_types::HostPath;\r\nuse cursor_hero_toolbelt_types::toolbelt_types::*;\r\n\r\nuse bevy::prelude::*;\r\nuse bevy_xpbd_2d::components::Collider;\r\nuse bevy_xpbd_2d::components::RigidBody;\r\nuse bevy_xpbd_2d::components::Sensor;\r\nuse cursor_hero_pointer_types::prelude::*;\r\n\r\nuse leafwing_input_manager::action_state::ActionState;\r\n\r\n#[allow(clippy::type_complexity)]\r\npub fn tool_help_lifecycle(\r\n    mut commands: Commands,\r\n    toolbelt_query: Query<\r\n        (&ActionState<ToolbeltAction>, &Children),\r\n        (Without<Tool>, With<Toolbelt>),\r\n    >,\r\n    tool_query: Query<(Entity, Option<&HostPath>, Option<&Children>, Option<&Name>), With<Tool>>,\r\n    tool_help_triggger_query: Query<Entity, With<ToolHelpTrigger>>,\r\n    asset_server: Res<AssetServer>,\r\n) {\r\n    for (toolbelt_actions, toolbelt_kids) in toolbelt_query.iter() {\r\n        if toolbelt_actions.just_pressed(ToolbeltAction::Show) {\r\n            for child_id in toolbelt_kids.iter() {\r\n                let Ok(tool) = tool_query.get(*child_id) else {\r\n                    continue;\r\n                };\r\n\r\n                let (tool_id, tool_src_path, _, tool_name) = tool;\r\n                commands.entity(tool_id).with_children(|parent| {\r\n                    let mut help = parent.spawn((\r\n                        Name::new(format!(\"Help Trigger for {:?} ({:?})\", tool_name, tool_id)),\r\n                        SpriteBundle {\r\n                            sprite: Sprite {\r\n                                custom_size: Some(Vec2::new(50.0, 50.0)),\r\n                                ..default()\r\n                            },\r\n                            transform: Transform::from_xyz(0.0, 0.0, 1.0),\r\n                            texture: asset_server.load(\"textures/toolbelt_wheel/help_trigger.png\"),\r\n                            ..default()\r\n                        },\r\n                        Hoverable,\r\n                        Clickable,\r\n                        ToolHelpTrigger,\r\n                        Sensor,\r\n                        RigidBody::Kinematic,\r\n                        Collider::cuboid(50.0, 50.0),\r\n                    ));\r\n                    if let Some(src_path) = tool_src_path {\r\n                        help.insert(src_path.clone());\r\n                    }\r\n                });\r\n            }\r\n        } else if toolbelt_actions.just_released(ToolbeltAction::Show) {\r\n            for child_id in toolbelt_kids.iter() {\r\n                let Ok(tool) = tool_query.get(*child_id) else {\r\n                    continue;\r\n                };\r\n                let (tool_id, _, Some(tool_children), _) = tool else {\r\n                    continue;\r\n                };\r\n                for child_id in tool_children.iter() {\r\n                    if let Ok(tool_help_trigger_id) = tool_help_triggger_query.get(*child_id) {\r\n                        commands\r\n                            .entity(tool_id)\r\n                            .remove_children(&[tool_help_trigger_id]);\r\n                        commands.entity(tool_help_trigger_id).despawn_recursive();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n#ENDREGION\r\n\r\n\r\n#REGION crates/ui_automation_types/src/calculator_ui_types.rs\r\nuse bevy::prelude::*;\r\nuse serde::{Deserialize, Serialize};\r\n\r\n#[derive(Component, Debug, Reflect, Default, Clone, Serialize, Deserialize, PartialEq)]\r\npub struct Calculator {\r\n    pub memory: CalculatorMemory,\r\n}\r\nimpl std::fmt::Display for Calculator {\r\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\r\n        write!(f, \"Calculator (value={})\", self.memory.buffer)\r\n    }\r\n}\r\n\r\n#[derive(Component, Debug, Reflect, Default)]\r\npub struct NumberDisplayPanel;\r\n\r\n#[derive(Component, Debug, Reflect, Default)]\r\npub struct DigitInputButton(u8);\r\n\r\n#[derive(Component, Debug, Reflect, Default)]\r\npub struct EqualsButton;\r\n\r\n#[derive(Component, Debug, Reflect, Default)]\r\npub struct PlusButton;\r\n\r\n#[derive(Component, Debug, Reflect, Default, Clone, Serialize, Deserialize, PartialEq)]\r\npub struct CalculatorMemory {\r\n    pub buffer: f64,\r\n}\r\n\r\n#[derive(Event, Debug, Reflect, Default)]\r\npub struct SpawnCalculatorRequest {\r\n    calculator: Calculator,\r\n}\r\n#[derive(Event, Debug, Reflect)]\r\npub struct CalculatorRequestDefaultPositioningRequest {\r\n    calculator: Entity,\r\n}\r\n\r\n#ENDREGION\r\n\r\n\r\n#REGION crates/ui_automation_types/src/edge_ui_types.rs\r\nuse bevy::prelude::*;\r\nuse itertools::Itertools;\r\nuse serde::Deserialize;\r\nuse serde::Serialize;\r\nuse std::collections::VecDeque;\r\nuse std::fmt;\r\nuse std::fmt::Display;\r\nuse std::fmt::Formatter;\r\nuse uiautomation::UIElement;\r\n\r\npub enum EdgeResolveError {\r\n    BadChildCount { tried_accessing: u32 },\r\n    UI(uiautomation::Error),\r\n    UnknownSideTabKind(String),\r\n    UnknownState,\r\n}\r\nimpl From<u32> for EdgeResolveError {\r\n    fn from(tried_accessing: u32) -> Self {\r\n        EdgeResolveError::BadChildCount { tried_accessing }\r\n    }\r\n}\r\n\r\nimpl From<uiautomation::Error> for EdgeResolveError {\r\n    fn from(e: uiautomation::Error) -> Self {\r\n        EdgeResolveError::UI(e)\r\n    }\r\n}\r\nimpl TryFrom<VecDeque<UIElement>> for EdgeCrawlState {\r\n    type Error = EdgeResolveError;\r\n    fn try_from(mut kids: VecDeque<UIElement>) -> Result<Self, Self::Error> {\r\n        let state = match kids.len() {\r\n            2 => EdgeCrawlState::LeftTabClosed {\r\n                tabs: kids.pop_front().ok_or(0u32)?,\r\n                editor: kids.pop_front().ok_or(1u32)?,\r\n            },\r\n            3 => EdgeCrawlState::LeftTabOpen {\r\n                side_nav_tabs: kids.pop_front().ok_or(0u32)?,\r\n                side_nav_view: kids.pop_front().ok_or(1u32)?,\r\n                editor: kids.pop_front().ok_or(2u32)?,\r\n            },\r\n            _ => EdgeCrawlState::Unknown,\r\n        };\r\n        Ok(state)\r\n    }\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]\r\npub enum View {\r\n    Explorer {\r\n        sticky: Vec<ExplorerItem>,\r\n        items: Vec<ExplorerItem>,\r\n    },\r\n    Unknown {},\r\n}\r\nimpl Display for View {\r\n    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {\r\n        match self {\r\n            View::Explorer { sticky, items } => {\r\n                writeln!(f, \"Explorer entries:\")?;\r\n                writeln!(f, \"=== BEGIN STICKY ===\")?;\r\n                for item in sticky.iter().sorted_by_key(|x| x.bounds.min.y) {\r\n                    writeln!(\r\n                        f,\r\n                        \"{}- {} ({})\",\r\n                        \" \".repeat(item.ui_level as usize),\r\n                        item.label.clone()\r\n                            + if matches!(item.kind, ExplorerItemKind::Directory { .. }) {\r\n                                \"/\"\r\n                            } else {\r\n                                \"\"\r\n                            },\r\n                        item.path\r\n                    )?;\r\n                }\r\n                writeln!(f, \"=== END STICKY ===\")?;\r\n                for item in items.iter().sorted_by_key(|x| x.bounds.min.y) {\r\n                    writeln!(\r\n                        f,\r\n                        \"{}- {} ({})\",\r\n                        \" \".repeat(item.ui_level as usize),\r\n                        item.label.clone()\r\n                            + if matches!(item.kind, ExplorerItemKind::Directory { .. }) {\r\n                                \"/\"\r\n                            } else {\r\n                                \"\"\r\n                            },\r\n                        item.path\r\n                    )?;\r\n                }\r\n                fmt::Result::Ok(())\r\n            }\r\n            View::Unknown {} => {\r\n                writeln!(f, \"Unknown view\")?;\r\n                fmt::Result::Ok(())\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\npub enum EdgeCrawlState {\r\n    LeftTabClosed {\r\n        tabs: UIElement,\r\n        editor: UIElement,\r\n    },\r\n    LeftTabOpen {\r\n        side_nav_tabs: UIElement,\r\n        side_nav_view: UIElement,\r\n        editor: UIElement,\r\n    },\r\n    Unknown,\r\n}\r\nimpl EdgeCrawlState {\r\n    pub fn get_side_nav_tabs_root_elem(&self) -> Result<&UIElement, EdgeResolveError> {\r\n        match self {\r\n            EdgeCrawlState::LeftTabClosed { tabs, .. } => Ok(tabs),\r\n            EdgeCrawlState::LeftTabOpen {\r\n                side_nav_tabs: tabs,\r\n                ..\r\n            } => Ok(tabs),\r\n            EdgeCrawlState::Unknown => Err(EdgeResolveError::UnknownState),\r\n        }\r\n    }\r\n    pub fn get_side_nav_view_root_elem(&self) -> Result<&UIElement, EdgeResolveError> {\r\n        match self {\r\n            EdgeCrawlState::LeftTabClosed { tabs, .. } => Ok(tabs),\r\n            EdgeCrawlState::LeftTabOpen {\r\n                side_nav_view: view,\r\n                ..\r\n            } => Ok(view),\r\n            EdgeCrawlState::Unknown => Err(EdgeResolveError::UnknownState),\r\n        }\r\n    }\r\n    pub fn get_editor_root_elem(&self) -> Result<&UIElement, EdgeResolveError> {\r\n        match self {\r\n            EdgeCrawlState::LeftTabClosed { editor, .. } => Ok(editor),\r\n            EdgeCrawlState::LeftTabOpen { editor, .. } => Ok(editor),\r\n            EdgeCrawlState::Unknown => Err(EdgeResolveError::UnknownState),\r\n        }\r\n    }\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]\r\npub struct EdgeWindowHeader {}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]\r\npub struct EdgeWindowBody {\r\n    pub editor_area: EditorArea,\r\n    pub side_nav: Vec<SideTab>,\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]\r\npub struct EdgeWindowFooter {\r\n    pub cursor_position: IVec2,\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]\r\npub struct EdgeWindow {\r\n    pub focused: bool,\r\n    pub header: EdgeWindowHeader,\r\n    pub body: EdgeWindowBody,\r\n    pub footer: EdgeWindowFooter,\r\n}\r\n\r\nimpl Display for EdgeWindow {\r\n    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {\r\n        writeln!(\r\n            f,\r\n            \":D :D :D Visual Studio Code {} owo owo owo\",\r\n            if self.focused { \"(focused)\" } else { \"\" }\r\n        )?;\r\n\r\n        writeln!(f, \"Side tabs:\")?;\r\n        for tab in self.body.side_nav.iter() {\r\n            match tab {\r\n                SideTab::Open { kind, view } => {\r\n                    writeln!(f, \"- (open) {:?} {{{{\\n{}}}}}\", kind, view)?;\r\n                }\r\n                SideTab::Closed { kind } => {\r\n                    writeln!(f, \"- {:?}\", kind)?;\r\n                }\r\n            }\r\n        }\r\n\r\n        writeln!(f, \"Editor groups:\")?;\r\n        for (i, group) in self.body.editor_area.groups.iter().enumerate() {\r\n            writeln!(f, \"Group {} tabs:\", i + 1)?;\r\n            for tab in group.tabs.iter() {\r\n                if tab.active {\r\n                    writeln!(f, \"- (active) {}\", tab.title)?;\r\n                } else {\r\n                    writeln!(f, \"- {}\", tab.title)?;\r\n                }\r\n            }\r\n            if let Some(ref content) = group.content {\r\n                writeln!(\r\n                    f,\r\n                    \"Group {} buffer:\\n=======\\n{}\\n=======\",\r\n                    i + 1,\r\n                    content.content\r\n                )?;\r\n            }\r\n        }\r\n\r\n        writeln!(f, \"Cursor position: {:?}\", self.footer.cursor_position)?;\r\n\r\n        fmt::Result::Ok(())\r\n    }\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]\r\npub enum SideTab {\r\n    Closed { kind: SideTabKind },\r\n    Open { kind: SideTabKind, view: View },\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]\r\npub enum ExplorerItemKind {\r\n    File,\r\n    Directory { expanded: bool },\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]\r\npub struct ExplorerItem {\r\n    pub label: String,\r\n    pub path: String,\r\n    pub ui_position_in_set: u32,\r\n    pub ui_size_of_set: u32,\r\n    pub ui_level: u32,\r\n    pub bounds: IRect,\r\n    pub kind: ExplorerItemKind,\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]\r\npub struct EditorArea {\r\n    pub groups: Vec<EditorGroup>,\r\n}\r\nimpl EditorArea {\r\n    pub fn get_expected_automation_id() -> &'static str {\r\n        \"workbench.parts.editor\"\r\n    }\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]\r\npub struct EditorGroup {\r\n    pub tabs: Vec<EditorTab>,\r\n    pub content: Option<EditorContent>,\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]\r\npub struct EditorTab {\r\n    pub title: String,\r\n    pub active: bool,\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]\r\npub struct EditorContent {\r\n    pub content: String,\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]\r\npub enum SideTabKind {\r\n    Explorer,\r\n    Search,\r\n    SourceControl,\r\n    RunAndDebug,\r\n    Extensions,\r\n    GitLens,\r\n    Azure,\r\n    Jupyter,\r\n    Chat,\r\n    GitHubActions,\r\n    Todo,\r\n}\r\nimpl SideTabKind {\r\n    pub fn variants() -> Vec<SideTabKind> {\r\n        vec![\r\n            SideTabKind::Explorer,\r\n            SideTabKind::Search,\r\n            SideTabKind::SourceControl,\r\n            SideTabKind::RunAndDebug,\r\n            SideTabKind::Extensions,\r\n            SideTabKind::GitLens,\r\n            SideTabKind::Azure,\r\n            SideTabKind::Jupyter,\r\n            SideTabKind::Chat,\r\n            SideTabKind::GitHubActions,\r\n            SideTabKind::Todo,\r\n        ]\r\n    }\r\n    pub fn get_view_automation_id(&self) -> Option<&str> {\r\n        match self {\r\n            SideTabKind::Explorer => Some(\"workbench.view.explorer\"),\r\n            _ => None,\r\n        }\r\n    }\r\n}\r\nimpl TryFrom<String> for SideTabKind {\r\n    type Error = EdgeResolveError;\r\n    fn try_from(s: String) -> Result<Self, Self::Error> {\r\n        let before_first_lparen = s.split_once(\" (\").map(|x| x.0).unwrap_or(s.as_str());\r\n        match before_first_lparen {\r\n            \"Explorer\" => Ok(SideTabKind::Explorer),\r\n            \"Search\" => Ok(SideTabKind::Search),\r\n            \"Source Control\" => Ok(SideTabKind::SourceControl),\r\n            \"Run and Debug\" => Ok(SideTabKind::RunAndDebug),\r\n            \"Extensions\" => Ok(SideTabKind::Extensions),\r\n            \"GitLens\" => Ok(SideTabKind::GitLens),\r\n            \"Azure\" => Ok(SideTabKind::Azure),\r\n            \"Jupyter\" => Ok(SideTabKind::Jupyter),\r\n            \"Chat\" => Ok(SideTabKind::Chat),\r\n            \"GitHub Actions\" => Ok(SideTabKind::GitHubActions),\r\n            \"TODOs\" => Ok(SideTabKind::Todo),\r\n            _ => Err(EdgeResolveError::UnknownSideTabKind(s)),\r\n        }\r\n    }\r\n}\r\n\r\n#ENDREGION\r\n\r\n\r\n#REGION crates/ui_automation_types/src/lib.rs\r\n#![feature(trivial_bounds)]\r\n\r\nmod taskbar_ui_types;\r\nmod ui_automation_drill;\r\nmod ui_automation_error_types;\r\nmod ui_automation_types;\r\nmod ui_automation_types_plugin;\r\nmod vscode_ui_types;\r\nmod calculator_ui_types;\r\n\r\npub mod prelude {\r\n    pub use crate::taskbar_ui_types::*;\r\n    pub use crate::ui_automation_drill::*;\r\n    pub use crate::ui_automation_error_types::*;\r\n    pub use crate::ui_automation_types::*;\r\n    pub use crate::ui_automation_types_plugin::*;\r\n    pub use crate::vscode_ui_types::*;\r\n    pub use crate::calculator_ui_types::*;\r\n    // pub use uiautomation;\r\n}\r\n\r\n#ENDREGION\r\n\r\n\r\n#REGION crates/ui_automation_types/src/taskbar_ui_types.rs\r\nuse bevy::prelude::*;\r\n\r\n#[derive(Debug, Reflect, Clone)]\r\npub struct Taskbar {\r\n    pub entries: Vec<TaskbarEntry>,\r\n}\r\n#[derive(Debug, Reflect, Clone)]\r\npub struct TaskbarEntry {\r\n    pub name: String,\r\n    pub bounds: IRect,\r\n}\r\n\r\n#ENDREGION\r\n\r\n\r\n#REGION crates/ui_automation_types/src/ui_automation_drill.rs\r\nuse std::collections::VecDeque;\r\nuse uiautomation::UIElement;\r\nuse uiautomation::UITreeWalker;\r\n\r\nuse crate::prelude::DrillId;\r\n\r\n#[derive(Debug)]\r\npub enum DrillError {\r\n    UI(uiautomation::Error),\r\n    EmptyPath,\r\n    BadPath,\r\n    OutOfBounds {\r\n        given: u32,\r\n        max: u32,\r\n        error: uiautomation::Error,\r\n    },\r\n}\r\nimpl std::error::Error for DrillError {}\r\nimpl std::fmt::Display for DrillError {\r\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\r\n        match self {\r\n            DrillError::UI(e) => write!(f, \"UIAutomation error: {}\", e),\r\n            DrillError::EmptyPath => write!(f, \"Empty path\"),\r\n            DrillError::BadPath => write!(f, \"Bad path\"),\r\n            DrillError::OutOfBounds { given, max, error } => write!(\r\n                f,\r\n                \"Out of bounds: given {}, max {}, error: {}\",\r\n                given, max, error\r\n            ),\r\n        }\r\n    }\r\n}\r\nimpl From<uiautomation::Error> for DrillError {\r\n    fn from(e: uiautomation::Error) -> Self {\r\n        DrillError::UI(e)\r\n    }\r\n}\r\npub trait Drillable {\r\n    fn drill<T: Into<DrillId>>(\r\n        &self,\r\n        walker: &UITreeWalker,\r\n        path: T,\r\n    ) -> Result<UIElement, DrillError>;\r\n}\r\nimpl Drillable for UIElement {\r\n    fn drill<T: Into<DrillId>>(\r\n        &self,\r\n        walker: &UITreeWalker,\r\n        path: T,\r\n    ) -> Result<UIElement, DrillError> {\r\n        let drill_id: DrillId = path.into();\r\n        match drill_id {\r\n            DrillId::Child(path) => {\r\n                let mut path = path\r\n                    .into_iter()\r\n                    .map(|x| x as u32)\r\n                    .collect::<VecDeque<u32>>();\r\n                if path.iter().any(|x| (*x as i32) < 0) {\r\n                    return Err(DrillError::BadPath);\r\n                }\r\n                drill_inner(self, walker, &mut path)\r\n            }\r\n            DrillId::Root | DrillId::Unknown => {\r\n                return Err(DrillError::BadPath);\r\n            }\r\n        }\r\n    }\r\n}\r\nfn drill_inner(\r\n    start: &UIElement,\r\n    walker: &UITreeWalker,\r\n    path: &mut VecDeque<u32>,\r\n) -> Result<UIElement, DrillError> {\r\n    let target_index = match path.pop_front() {\r\n        Some(x) => x,\r\n        None => return Err(DrillError::EmptyPath),\r\n    };\r\n    let mut child = walker.get_first_child(start)?;\r\n    let mut i = 0;\r\n    while i < target_index {\r\n        i += 1;\r\n        child = match walker.get_next_sibling(&child) {\r\n            Ok(x) => x,\r\n            Err(e) => {\r\n                return Err(DrillError::OutOfBounds {\r\n                    given: i,\r\n                    max: target_index,\r\n                    error: e,\r\n                })\r\n            }\r\n        };\r\n    }\r\n    if path.is_empty() {\r\n        Ok(child)\r\n    } else {\r\n        drill_inner(&child, walker, path)\r\n    }\r\n}\r\n\r\n#ENDREGION\r\n\r\n\r\n#REGION crates/ui_automation_types/src/ui_automation_error_types.rs\r\nuse crate::prelude::VSCodeResolveError;\r\nuse crate::ui_automation_drill::DrillError;\r\nuse std::fmt;\r\n\r\n#[derive(Debug)]\r\npub enum AppResolveError {\r\n    UI(uiautomation::Error),\r\n    BadStructure(String),\r\n    BadVSCodeStructure(String),\r\n    NoMatch,\r\n}\r\nimpl From<uiautomation::Error> for AppResolveError {\r\n    fn from(e: uiautomation::Error) -> Self {\r\n        AppResolveError::UI(e)\r\n    }\r\n}\r\nimpl From<DrillError> for AppResolveError {\r\n    fn from(e: DrillError) -> Self {\r\n        match e {\r\n            DrillError::UI(e) => AppResolveError::UI(e),\r\n            DrillError::EmptyPath => AppResolveError::BadStructure(\"Empty path\".to_string()),\r\n            DrillError::BadPath => AppResolveError::BadStructure(\"Bad path\".to_string()),\r\n            DrillError::OutOfBounds {\r\n                given,\r\n                max,\r\n                error: e,\r\n            } => AppResolveError::BadStructure(format!(\r\n                \"Out of bounds: given: {}, max: {}, error: {}\",\r\n                given, max, e\r\n            )),\r\n        }\r\n    }\r\n}\r\nimpl From<VSCodeResolveError> for AppResolveError {\r\n    fn from(e: VSCodeResolveError) -> Self {\r\n        match e {\r\n            VSCodeResolveError::UnknownSideTabKind(s) => {\r\n                AppResolveError::BadVSCodeStructure(format!(\"Unknown VSCode side tab kind: {}\", s))\r\n            }\r\n            VSCodeResolveError::UnknownState => {\r\n                AppResolveError::BadVSCodeStructure(\"Unknown VSCode state\".to_string())\r\n            }\r\n            VSCodeResolveError::UI(e) => AppResolveError::UI(e),\r\n            VSCodeResolveError::BadChildCount { tried_accessing } => AppResolveError::BadVSCodeStructure(\r\n                format!(\"Bad child count: tried accessing: {}\", tried_accessing),\r\n            ),\r\n        }\r\n    }\r\n}\r\n\r\nimpl fmt::Display for AppResolveError {\r\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\r\n        // Write a descriptive message for the error.\r\n        write!(f, \"{:?}\", self)\r\n    }\r\n}\r\nimpl std::error::Error for AppResolveError {}\r\n\r\n#[derive(Debug)]\r\npub enum GatherAppsError {\r\n    UI(uiautomation::Error),\r\n    NoneMatch,\r\n    ResolveFailed(Vec<AppResolveError>),\r\n}\r\nimpl From<uiautomation::Error> for GatherAppsError {\r\n    fn from(e: uiautomation::Error) -> Self {\r\n        GatherAppsError::UI(e)\r\n    }\r\n}\r\n\r\nimpl fmt::Display for GatherAppsError {\r\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\r\n        // Write a descriptive message for the error.\r\n        write!(f, \"{:?}\", self)\r\n    }\r\n}\r\nimpl std::error::Error for GatherAppsError {}\r\n\r\n#ENDREGION\r\n\r\n\r\n#REGION crates/ui_automation_types/src/ui_automation_types_plugin.rs\r\nuse crate::prelude::*;\r\nuse bevy::prelude::*;\r\n\r\npub struct UiAutomationTypesPlugin;\r\n\r\nimpl Plugin for UiAutomationTypesPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<ElementInfo>();\r\n        app.register_type::<DrillId>();\r\n        app.register_type::<ControlType>();\r\n    }\r\n}\r\n\r\n#ENDREGION\r\n\r\n\r\n#REGION crates/ui_automation_types/src/ui_automation_types.rs\r\nuse crate::prelude::Calculator;\r\nuse crate::vscode_ui_types::*;\r\nuse bevy::prelude::*;\r\nuse serde::Deserialize;\r\nuse serde::Serialize;\r\nuse std::collections::VecDeque;\r\nuse std::fmt;\r\nuse std::fmt::Display;\r\nuse std::fmt::Formatter;\r\nuse uiautomation::core::UICondition;\r\nuse uiautomation::UIAutomation;\r\n\r\n\r\npub trait HexList {\r\n    fn to_hex_list(&self) -> String;\r\n}\r\nimpl HexList for Vec<i32> {\r\n    fn to_hex_list(&self) -> String {\r\n        format!(\r\n            \"[{}]\",\r\n            self.iter()\r\n                .map(|x| format!(\"{:X}\", x).to_string())\r\n                .collect::<Vec<String>>()\r\n                .join(\",\")\r\n        )\r\n    }\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Reflect)]\r\npub struct UISnapshot {\r\n    pub app_windows: Vec<AppWindow>,\r\n}\r\n\r\nimpl Display for UISnapshot {\r\n    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {\r\n        writeln!(f, \"!!! UISnapshot !!!\")?;\r\n        for window in self.app_windows.iter() {\r\n            write!(f, \"{}\", window)?;\r\n        }\r\n        fmt::Result::Ok(())\r\n    }\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Reflect)]\r\npub enum AppWindow {\r\n    VSCode(VSCodeWindow),\r\n    Calculator(Calculator),\r\n}\r\n\r\nimpl Display for AppWindow {\r\n    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {\r\n        match self {\r\n            AppWindow::VSCode(window) => write!(f, \"{}\", window),\r\n            AppWindow::Calculator(window) => write!(f, \"{}\", window), \r\n        }\r\n    }\r\n}\r\n\r\npub fn all_of(\r\n    automation: &UIAutomation,\r\n    conditions: Vec<UICondition>,\r\n) -> Result<UICondition, uiautomation::Error> {\r\n    let iter = conditions.into_iter();\r\n    let mut current = automation.create_true_condition()?;\r\n\r\n    for condition in iter {\r\n        current = automation.create_and_condition(current, condition)?;\r\n    }\r\n\r\n    Ok(current)\r\n}\r\n\r\npub trait ToBevyIRect {\r\n    fn to_bevy_irect(&self) -> IRect;\r\n}\r\nimpl ToBevyIRect for uiautomation::types::Rect {\r\n    fn to_bevy_irect(&self) -> IRect {\r\n        IRect {\r\n            min: IVec2::new(self.get_left(), self.get_top()),\r\n            max: IVec2::new(self.get_right(), self.get_bottom()),\r\n        }\r\n    }\r\n}\r\n\r\n/// Defines enum for `windows::Win32::UI::Accessibility::UIA_CONTROLTYPE_ID`.\r\n///\r\n/// Contains the named constants used to identify Microsoft UI Automation control types.\r\n#[repr(u32)]\r\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Reflect)]\r\npub enum ControlType {\r\n    /// Identifies the\u00c2\u00a0Button\u00c2\u00a0control type.\r\n    Button = 50000u32,\r\n    /// Identifies the\u00c2\u00a0Calendar\u00c2\u00a0control type.\r\n    Calendar = 50001u32,\r\n    /// Identifies the\u00c2\u00a0CheckBox\u00c2\u00a0control type.\r\n    CheckBox = 50002u32,\r\n    /// Identifies the\u00c2\u00a0ComboBox\u00c2\u00a0control type.\r\n    ComboBox = 50003u32,\r\n    /// Identifies the\u00c2\u00a0Edit\u00c2\u00a0control type.\r\n    Edit = 50004u32,\r\n    /// Identifies the\u00c2\u00a0Hyperlink\u00c2\u00a0control type.\r\n    Hyperlink = 50005u32,\r\n    /// Identifies the\u00c2\u00a0Image\u00c2\u00a0control type.\r\n    Image = 50006u32,\r\n    /// Identifies the\u00c2\u00a0ListItem\u00c2\u00a0control type.\r\n    ListItem = 50007u32,\r\n    /// Identifies the\u00c2\u00a0List\u00c2\u00a0control type.\r\n    List = 50008u32,\r\n    /// Identifies the\u00c2\u00a0Menu\u00c2\u00a0control type.\r\n    Menu = 50009u32,\r\n    /// Identifies the\u00c2\u00a0MenuBar\u00c2\u00a0control type.\r\n    MenuBar = 50010u32,\r\n    /// Identifies the\u00c2\u00a0MenuItem\u00c2\u00a0control type.\r\n    MenuItem = 50011u32,\r\n    /// Identifies the\u00c2\u00a0ProgressBar\u00c2\u00a0control type.\r\n    ProgressBar = 50012u32,\r\n    /// Identifies the\u00c2\u00a0RadioButton\u00c2\u00a0control type.\r\n    RadioButton = 50013u32,\r\n    /// Identifies the\u00c2\u00a0ScrollBar\u00c2\u00a0control type.\r\n    ScrollBar = 50014u32,\r\n    /// Identifies the\u00c2\u00a0Slider\u00c2\u00a0control type.\r\n    Slider = 50015u32,\r\n    /// Identifies the\u00c2\u00a0Spinner\u00c2\u00a0control type.\r\n    Spinner = 50016u32,\r\n    /// Identifies the\u00c2\u00a0StatusBar\u00c2\u00a0control type.\r\n    StatusBar = 50017u32,\r\n    /// Identifies the\u00c2\u00a0Tab\u00c2\u00a0control type.\r\n    Tab = 50018u32,\r\n    /// Identifies the\u00c2\u00a0TabItem\u00c2\u00a0control type.\r\n    TabItem = 50019u32,\r\n    /// Identifies the\u00c2\u00a0Text\u00c2\u00a0control type.\r\n    Text = 50020u32,\r\n    /// Identifies the\u00c2\u00a0ToolBar\u00c2\u00a0control type.\r\n    ToolBar = 50021u32,\r\n    /// Identifies the\u00c2\u00a0ToolTip\u00c2\u00a0control type.\r\n    ToolTip = 50022u32,\r\n    /// Identifies the\u00c2\u00a0Tree\u00c2\u00a0control type.\r\n    Tree = 50023u32,\r\n    /// Identifies the\u00c2\u00a0TreeItem\u00c2\u00a0control type.\r\n    TreeItem = 50024u32,\r\n    /// Identifies the Custom control type. For more information, see\u00c2\u00a0Custom Properties, Events, and Control Patterns.\r\n    Custom = 50025u32,\r\n    /// Identifies the\u00c2\u00a0Group\u00c2\u00a0control type.\r\n    Group = 50026u32,\r\n    /// Identifies the\u00c2\u00a0Thumb\u00c2\u00a0control type.\r\n    Thumb = 50027u32,\r\n    /// Identifies the\u00c2\u00a0DataGrid\u00c2\u00a0control type.\r\n    DataGrid = 50028u32,\r\n    /// Identifies the\u00c2\u00a0DataItem\u00c2\u00a0control type.\r\n    DataItem = 50029u32,\r\n    /// Identifies the\u00c2\u00a0Document\u00c2\u00a0control type.\r\n    Document = 50030u32,\r\n    /// Identifies the\u00c2\u00a0SplitButton\u00c2\u00a0control type.\r\n    SplitButton = 50031u32,\r\n    /// Identifies the\u00c2\u00a0Window\u00c2\u00a0control type.\r\n    Window = 50032u32,\r\n    /// Identifies the\u00c2\u00a0Pane\u00c2\u00a0control type.\r\n    Pane = 50033u32,\r\n    /// Identifies the\u00c2\u00a0Header\u00c2\u00a0control type.\r\n    Header = 50034u32,\r\n    /// Identifies the\u00c2\u00a0HeaderItem\u00c2\u00a0control type.\r\n    HeaderItem = 50035u32,\r\n    /// Identifies the\u00c2\u00a0Table\u00c2\u00a0control type.\r\n    Table = 50036u32,\r\n    /// Identifies the\u00c2\u00a0TitleBar\u00c2\u00a0control type.\r\n    TitleBar = 50037u32,\r\n    /// Identifies the\u00c2\u00a0Separator\u00c2\u00a0control type.\r\n    Separator = 50038u32,\r\n    /// Identifies the\u00c2\u00a0SemanticZoom\u00c2\u00a0control type. Supported starting with Windows 8.\r\n    SemanticZoom = 50039u32,\r\n    /// Identifies the\u00c2\u00a0AppBar\u00c2\u00a0control type. Supported starting with Windows 8.1.\r\n    AppBar = 50040u32,\r\n}\r\nimpl From<uiautomation::controls::ControlType> for ControlType {\r\n    fn from(value: uiautomation::controls::ControlType) -> Self {\r\n        match value {\r\n            uiautomation::controls::ControlType::Button => ControlType::Button,\r\n            uiautomation::controls::ControlType::Calendar => ControlType::Calendar,\r\n            uiautomation::controls::ControlType::CheckBox => ControlType::CheckBox,\r\n            uiautomation::controls::ControlType::ComboBox => ControlType::ComboBox,\r\n            uiautomation::controls::ControlType::Edit => ControlType::Edit,\r\n            uiautomation::controls::ControlType::Hyperlink => ControlType::Hyperlink,\r\n            uiautomation::controls::ControlType::Image => ControlType::Image,\r\n            uiautomation::controls::ControlType::ListItem => ControlType::ListItem,\r\n            uiautomation::controls::ControlType::List => ControlType::List,\r\n            uiautomation::controls::ControlType::Menu => ControlType::Menu,\r\n            uiautomation::controls::ControlType::MenuBar => ControlType::MenuBar,\r\n            uiautomation::controls::ControlType::MenuItem => ControlType::MenuItem,\r\n            uiautomation::controls::ControlType::ProgressBar => ControlType::ProgressBar,\r\n            uiautomation::controls::ControlType::RadioButton => ControlType::RadioButton,\r\n            uiautomation::controls::ControlType::ScrollBar => ControlType::ScrollBar,\r\n            uiautomation::controls::ControlType::Slider => ControlType::Slider,\r\n            uiautomation::controls::ControlType::Spinner => ControlType::Spinner,\r\n            uiautomation::controls::ControlType::StatusBar => ControlType::StatusBar,\r\n            uiautomation::controls::ControlType::Tab => ControlType::Tab,\r\n            uiautomation::controls::ControlType::TabItem => ControlType::TabItem,\r\n            uiautomation::controls::ControlType::Text => ControlType::Text,\r\n            uiautomation::controls::ControlType::ToolBar => ControlType::ToolBar,\r\n            uiautomation::controls::ControlType::ToolTip => ControlType::ToolTip,\r\n            uiautomation::controls::ControlType::Tree => ControlType::Tree,\r\n            uiautomation::controls::ControlType::TreeItem => ControlType::TreeItem,\r\n            uiautomation::controls::ControlType::Custom => ControlType::Custom,\r\n            uiautomation::controls::ControlType::Group => ControlType::Group,\r\n            uiautomation::controls::ControlType::Thumb => ControlType::Thumb,\r\n            uiautomation::controls::ControlType::DataGrid => ControlType::DataGrid,\r\n            uiautomation::controls::ControlType::DataItem => ControlType::DataItem,\r\n            uiautomation::controls::ControlType::Document => ControlType::Document,\r\n            uiautomation::controls::ControlType::SplitButton => ControlType::SplitButton,\r\n            uiautomation::controls::ControlType::Window => ControlType::Window,\r\n            uiautomation::controls::ControlType::Pane => ControlType::Pane,\r\n            uiautomation::controls::ControlType::Header => ControlType::Header,\r\n            uiautomation::controls::ControlType::HeaderItem => ControlType::HeaderItem,\r\n            uiautomation::controls::ControlType::Table => ControlType::Table,\r\n            uiautomation::controls::ControlType::TitleBar => ControlType::TitleBar,\r\n            uiautomation::controls::ControlType::Separator => ControlType::Separator,\r\n            uiautomation::controls::ControlType::SemanticZoom => ControlType::SemanticZoom,\r\n            uiautomation::controls::ControlType::AppBar => ControlType::AppBar,\r\n        }\r\n    }\r\n}\r\n\r\npub type RuntimeId = Vec<i32>;\r\n\r\n#[derive(Debug, Eq, PartialEq, Clone, Reflect, Default, Hash)]\r\npub enum DrillId {\r\n    Root,\r\n    Child(VecDeque<usize>),\r\n    #[default]\r\n    Unknown,\r\n}\r\nimpl From<Vec<usize>> for DrillId {\r\n    fn from(value: Vec<usize>) -> Self {\r\n        DrillId::Child(value.into())\r\n    }\r\n}\r\nimpl From<VecDeque<usize>> for DrillId {\r\n    fn from(value: VecDeque<usize>) -> Self {\r\n        DrillId::Child(value)\r\n    }\r\n}\r\nimpl From<Vec<i32>> for DrillId {\r\n    fn from(value: Vec<i32>) -> Self {\r\n        DrillId::Child(value.into_iter().map(|x| x as usize).collect())\r\n    }\r\n}\r\nimpl From<VecDeque<i32>> for DrillId {\r\n    fn from(value: VecDeque<i32>) -> Self {\r\n        DrillId::Child(value.into_iter().map(|x| x as usize).collect())\r\n    }\r\n}\r\nimpl std::fmt::Display for DrillId {\r\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\r\n        match self {\r\n            DrillId::Root => write!(f, \"Root\"),\r\n            DrillId::Child(drill_id) => write!(\r\n                f,\r\n                \"{}\",\r\n                drill_id\r\n                    .iter()\r\n                    .map(|x| x.to_string())\r\n                    .collect::<Vec<String>>()\r\n                    .join(\",\")\r\n            ),\r\n            DrillId::Unknown => write!(f, \"Unknown\"),\r\n        }\r\n    }\r\n}\r\n\r\n#[derive(Debug, Clone, Reflect, PartialEq)]\r\n// #[reflect(no_field_bounds)] //https://github.com/bevyengine/bevy/issues/8965\r\npub struct ElementInfo {\r\n    pub name: String,\r\n    pub bounding_rect: Rect,\r\n    pub control_type: ControlType,\r\n    pub localized_control_type: String,\r\n    pub class_name: String,\r\n    pub automation_id: String,\r\n    #[reflect(ignore)]\r\n    pub runtime_id: Vec<i32>,\r\n    #[reflect(ignore)]\r\n    pub drill_id: DrillId,\r\n    #[reflect(ignore)]\r\n    pub children: Option<Vec<ElementInfo>>,\r\n}\r\nimpl Default for ElementInfo {\r\n    fn default() -> Self {\r\n        ElementInfo {\r\n            name: \"\".to_string(),\r\n            bounding_rect: Rect::new(0.0, 0.0, 0.0, 0.0),\r\n            control_type: ControlType::Pane,\r\n            localized_control_type: \"\".to_string(),\r\n            class_name: \"\".to_string(),\r\n            automation_id: \"\".to_string(),\r\n            runtime_id: vec![],\r\n            drill_id: DrillId::Unknown,\r\n            children: None,\r\n        }\r\n    }\r\n}\r\nimpl ElementInfo {\r\n    pub fn lookup_drill_id(&self, drill_id: DrillId) -> Option<&ElementInfo> {\r\n        self.lookup_drill_id_inner(drill_id, 0)\r\n    }\r\n    fn lookup_drill_id_inner(&self, drill_id: DrillId, skip: usize) -> Option<&ElementInfo> {\r\n        // println!(\"Looking in {} for {:?} ({:?})\", self.name, drill_id.map(|x| x.iter().skip(skip).collect::<Vec<&usize>>()), drill_id);\r\n        if self.drill_id == drill_id {\r\n            return Some(self);\r\n        }\r\n        let DrillId::Child(drill_id) = drill_id else {\r\n            return None;\r\n        };\r\n        if drill_id.is_empty() {\r\n            return None;\r\n        }\r\n        let Some(children) = &self.children else {\r\n            return None;\r\n        };\r\n        // println!(\"found children {:?}\", children.children.iter().map(|x| x.drill_id.clone()).collect_vec());\r\n        for child in children {\r\n            let DrillId::Child(child_drill_id) = &child.drill_id else {\r\n                continue;\r\n            };\r\n            if child_drill_id.back() == drill_id.iter().skip(skip).next() {\r\n                if skip == drill_id.len() - 1 {\r\n                    return Some(child);\r\n                } else {\r\n                    return child.lookup_drill_id_inner(DrillId::Child(drill_id.clone()), skip + 1);\r\n                }\r\n            }\r\n        }\r\n        None\r\n    }\r\n    pub fn lookup_drill_id_mut(&mut self, drill_id: DrillId) -> Option<&mut ElementInfo> {\r\n        self.lookup_drill_id_mut_inner(drill_id, 0)\r\n    }\r\n    \r\n    fn lookup_drill_id_mut_inner(&mut self, drill_id: DrillId, skip: usize) -> Option<&mut ElementInfo> {\r\n        // println!(\"Looking in {} for {:?} ({:?})\", self.name, drill_id.map(|x| x.iter().skip(skip).collect::<Vec<&usize>>()), drill_id);\r\n        if self.drill_id == drill_id {\r\n            return Some(self);\r\n        }\r\n        let DrillId::Child(drill_id) = drill_id else {\r\n            return None;\r\n        };\r\n        if drill_id.is_empty() {\r\n            return None;\r\n        }\r\n        let Some(ref mut children) = self.children else {\r\n            return None;\r\n        };\r\n        // println!(\"found children {:?}\", children.children.iter().map(|x| x.drill_id.clone()).collect_vec());\r\n        for child in children.iter_mut() {\r\n            let DrillId::Child(child_drill_id) = &child.drill_id else {\r\n                continue;\r\n            };\r\n            if child_drill_id.back() == drill_id.iter().skip(skip).next() {\r\n                if skip == drill_id.len() - 1 {\r\n                    return Some(child);\r\n                } else {\r\n                    return child.lookup_drill_id_mut_inner(DrillId::Child(drill_id.clone()), skip + 1);\r\n                }\r\n            }\r\n        }\r\n        None\r\n    }\r\n    pub fn get_descendents(&self) -> Vec<&ElementInfo> {\r\n        let mut descendents = vec![];\r\n        if let Some(children) = &self.children {\r\n            for child in children {\r\n                descendents.push(child);\r\n                descendents.extend(child.get_descendents());\r\n            }\r\n        }\r\n        descendents\r\n    }\r\n}\r\n// test lookup_drill_id\r\n#[cfg(test)]\r\nmod tests {\r\n    #[test]\r\n    fn test_lookup_drill_id() {\r\n        use super::*;\r\n        fn new_elem(name: &str, drill_id: Vec<usize>) -> ElementInfo {\r\n            ElementInfo {\r\n                name: name.to_string(),\r\n                bounding_rect: Rect::new(0.0, 0.0, 100.0, 100.0),\r\n                control_type: ControlType::Button,\r\n                localized_control_type: \"Button\".to_string(),\r\n                class_name: \"Button\".to_string(),\r\n                automation_id: \"Button\".to_string(),\r\n                runtime_id: vec![],\r\n                drill_id: match drill_id.is_empty() {\r\n                    true => DrillId::Root,\r\n                    false => DrillId::Child(drill_id.into()),\r\n                },\r\n                children: None,\r\n            }\r\n        }\r\n        let mut root = new_elem(\"root\", vec![]);\r\n\r\n        let mut a = new_elem(\"a\", vec![0]);\r\n        let a_a = new_elem(\"a_a\", vec![0, 0]);\r\n        let a_b = new_elem(\"a_b\", vec![0, 1]);\r\n        a.children = Some(vec![a_a.clone(), a_b.clone()]);\r\n\r\n        let mut b = new_elem(\"b\", vec![1]);\r\n        let mut b_a = new_elem(\"b_a\", vec![1, 0]);\r\n        let b_a_a = new_elem(\"b_a_a\", vec![1, 0, 0]);\r\n        let b_a_b = new_elem(\"b_a_b\", vec![1, 0, 1]);\r\n        b_a.children = Some(vec![b_a_a.clone(), b_a_b.clone()]);\r\n        let b_b = new_elem(\"b_b\", vec![1, 1]);\r\n        b.children = Some(vec![b_a.clone(), b_b.clone()]);\r\n\r\n        root.children = Some(vec![a.clone(), b.clone()]);\r\n\r\n        let items = vec![&root, &a, &a_a, &a_b, &b, &b_a, &b_a_a, &b_a_b, &b_b];\r\n        for item in items {\r\n            println!(\"Looking for {}\", item.name);\r\n            let found = root.lookup_drill_id(item.drill_id.clone());\r\n            assert_eq!(found, Some(item));\r\n            println!();\r\n        }\r\n    }\r\n}\r\n#ENDREGION\r\n\r\n\r\n#REGION crates/ui_automation_types/src/vscode_ui_types.rs\r\nuse bevy::prelude::*;\r\nuse itertools::Itertools;\r\nuse serde::Deserialize;\r\nuse serde::Serialize;\r\nuse std::collections::VecDeque;\r\nuse std::fmt;\r\nuse std::fmt::Display;\r\nuse std::fmt::Formatter;\r\nuse uiautomation::UIElement;\r\n\r\npub enum VSCodeResolveError {\r\n    BadChildCount { tried_accessing: u32 },\r\n    UI(uiautomation::Error),\r\n    UnknownSideTabKind(String),\r\n    UnknownState,\r\n}\r\nimpl From<u32> for VSCodeResolveError {\r\n    fn from(tried_accessing: u32) -> Self {\r\n        VSCodeResolveError::BadChildCount { tried_accessing }\r\n    }\r\n}\r\n\r\nimpl From<uiautomation::Error> for VSCodeResolveError {\r\n    fn from(e: uiautomation::Error) -> Self {\r\n        VSCodeResolveError::UI(e)\r\n    }\r\n}\r\nimpl TryFrom<VecDeque<UIElement>> for VSCodeCrawlState {\r\n    type Error = VSCodeResolveError;\r\n    fn try_from(mut kids: VecDeque<UIElement>) -> Result<Self, Self::Error> {\r\n        let state = match kids.len() {\r\n            2 => VSCodeCrawlState::LeftTabClosed {\r\n                tabs: kids.pop_front().ok_or(0u32)?,\r\n                editor: kids.pop_front().ok_or(1u32)?,\r\n            },\r\n            3 => VSCodeCrawlState::LeftTabOpen {\r\n                side_nav_tabs: kids.pop_front().ok_or(0u32)?,\r\n                side_nav_view: kids.pop_front().ok_or(1u32)?,\r\n                editor: kids.pop_front().ok_or(2u32)?,\r\n            },\r\n            _ => VSCodeCrawlState::Unknown,\r\n        };\r\n        Ok(state)\r\n    }\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]\r\npub enum View {\r\n    Explorer {\r\n        sticky: Vec<ExplorerItem>,\r\n        items: Vec<ExplorerItem>,\r\n    },\r\n    Unknown {},\r\n}\r\nimpl Display for View {\r\n    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {\r\n        match self {\r\n            View::Explorer { sticky, items } => {\r\n                writeln!(f, \"Explorer entries:\")?;\r\n                writeln!(f, \"=== BEGIN STICKY ===\")?;\r\n                for item in sticky.iter().sorted_by_key(|x| x.bounds.min.y) {\r\n                    writeln!(\r\n                        f,\r\n                        \"{}- {} ({})\",\r\n                        \" \".repeat(item.ui_level as usize),\r\n                        item.label.clone()\r\n                            + if matches!(item.kind, ExplorerItemKind::Directory { .. }) {\r\n                                \"/\"\r\n                            } else {\r\n                                \"\"\r\n                            },\r\n                        item.path\r\n                    )?;\r\n                }\r\n                writeln!(f, \"=== END STICKY ===\")?;\r\n                for item in items.iter().sorted_by_key(|x| x.bounds.min.y) {\r\n                    writeln!(\r\n                        f,\r\n                        \"{}- {} ({})\",\r\n                        \" \".repeat(item.ui_level as usize),\r\n                        item.label.clone()\r\n                            + if matches!(item.kind, ExplorerItemKind::Directory { .. }) {\r\n                                \"/\"\r\n                            } else {\r\n                                \"\"\r\n                            },\r\n                        item.path\r\n                    )?;\r\n                }\r\n                fmt::Result::Ok(())\r\n            }\r\n            View::Unknown {} => {\r\n                writeln!(f, \"Unknown view\")?;\r\n                fmt::Result::Ok(())\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\npub enum VSCodeCrawlState {\r\n    LeftTabClosed {\r\n        tabs: UIElement,\r\n        editor: UIElement,\r\n    },\r\n    LeftTabOpen {\r\n        side_nav_tabs: UIElement,\r\n        side_nav_view: UIElement,\r\n        editor: UIElement,\r\n    },\r\n    Unknown,\r\n}\r\nimpl VSCodeCrawlState {\r\n    pub fn get_side_nav_tabs_root_elem(&self) -> Result<&UIElement, VSCodeResolveError> {\r\n        match self {\r\n            VSCodeCrawlState::LeftTabClosed { tabs, .. } => Ok(tabs),\r\n            VSCodeCrawlState::LeftTabOpen {\r\n                side_nav_tabs: tabs,\r\n                ..\r\n            } => Ok(tabs),\r\n            VSCodeCrawlState::Unknown => Err(VSCodeResolveError::UnknownState),\r\n        }\r\n    }\r\n    pub fn get_side_nav_view_root_elem(&self) -> Result<&UIElement, VSCodeResolveError> {\r\n        match self {\r\n            VSCodeCrawlState::LeftTabClosed { tabs, .. } => Ok(tabs),\r\n            VSCodeCrawlState::LeftTabOpen {\r\n                side_nav_view: view,\r\n                ..\r\n            } => Ok(view),\r\n            VSCodeCrawlState::Unknown => Err(VSCodeResolveError::UnknownState),\r\n        }\r\n    }\r\n    pub fn get_editor_root_elem(&self) -> Result<&UIElement, VSCodeResolveError> {\r\n        match self {\r\n            VSCodeCrawlState::LeftTabClosed { editor, .. } => Ok(editor),\r\n            VSCodeCrawlState::LeftTabOpen { editor, .. } => Ok(editor),\r\n            VSCodeCrawlState::Unknown => Err(VSCodeResolveError::UnknownState),\r\n        }\r\n    }\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]\r\npub struct VSCodeWindowHeader {}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]\r\npub struct VSCodeWindowBody {\r\n    pub editor_area: EditorArea,\r\n    pub side_nav: Vec<SideTab>,\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]\r\npub struct VSCodeWindowFooter {\r\n    pub cursor_position: IVec2,\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]\r\npub struct VSCodeWindow {\r\n    pub focused: bool,\r\n    pub header: VSCodeWindowHeader,\r\n    pub body: VSCodeWindowBody,\r\n    pub footer: VSCodeWindowFooter,\r\n}\r\n\r\nimpl Display for VSCodeWindow {\r\n    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {\r\n        writeln!(\r\n            f,\r\n            \":D :D :D Visual Studio Code {} owo owo owo\",\r\n            if self.focused { \"(focused)\" } else { \"\" }\r\n        )?;\r\n\r\n        writeln!(f, \"Side tabs:\")?;\r\n        for tab in self.body.side_nav.iter() {\r\n            match tab {\r\n                SideTab::Open { kind, view } => {\r\n                    writeln!(f, \"- (open) {:?} {{{{\\n{}}}}}\", kind, view)?;\r\n                }\r\n                SideTab::Closed { kind } => {\r\n                    writeln!(f, \"- {:?}\", kind)?;\r\n                }\r\n            }\r\n        }\r\n\r\n        writeln!(f, \"Editor groups:\")?;\r\n        for (i, group) in self.body.editor_area.groups.iter().enumerate() {\r\n            writeln!(f, \"Group {} tabs:\", i + 1)?;\r\n            for tab in group.tabs.iter() {\r\n                if tab.active {\r\n                    writeln!(f, \"- (active) {}\", tab.title)?;\r\n                } else {\r\n                    writeln!(f, \"- {}\", tab.title)?;\r\n                }\r\n            }\r\n            if let Some(ref content) = group.content {\r\n                writeln!(\r\n                    f,\r\n                    \"Group {} buffer:\\n=======\\n{}\\n=======\",\r\n                    i + 1,\r\n                    content.content\r\n                )?;\r\n            }\r\n        }\r\n\r\n        writeln!(f, \"Cursor position: {:?}\", self.footer.cursor_position)?;\r\n\r\n        fmt::Result::Ok(())\r\n    }\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]\r\npub enum SideTab {\r\n    Closed { kind: SideTabKind },\r\n    Open { kind: SideTabKind, view: View },\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]\r\npub enum ExplorerItemKind {\r\n    File,\r\n    Directory { expanded: bool },\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]\r\npub struct ExplorerItem {\r\n    pub label: String,\r\n    pub path: String,\r\n    pub ui_position_in_set: u32,\r\n    pub ui_size_of_set: u32,\r\n    pub ui_level: u32,\r\n    pub bounds: IRect,\r\n    pub kind: ExplorerItemKind,\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]\r\npub struct EditorArea {\r\n    pub groups: Vec<EditorGroup>,\r\n}\r\nimpl EditorArea {\r\n    pub fn get_expected_automation_id() -> &'static str {\r\n        \"workbench.parts.editor\"\r\n    }\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]\r\npub struct EditorGroup {\r\n    pub tabs: Vec<EditorTab>,\r\n    pub content: Option<EditorContent>,\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]\r\npub struct EditorTab {\r\n    pub title: String,\r\n    pub active: bool,\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]\r\npub struct EditorContent {\r\n    pub content: String,\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]\r\npub enum SideTabKind {\r\n    Explorer,\r\n    Search,\r\n    SourceControl,\r\n    RunAndDebug,\r\n    Extensions,\r\n    GitLens,\r\n    Azure,\r\n    Jupyter,\r\n    Chat,\r\n    GitHubActions,\r\n    Todo,\r\n}\r\nimpl SideTabKind {\r\n    pub fn variants() -> Vec<SideTabKind> {\r\n        vec![\r\n            SideTabKind::Explorer,\r\n            SideTabKind::Search,\r\n            SideTabKind::SourceControl,\r\n            SideTabKind::RunAndDebug,\r\n            SideTabKind::Extensions,\r\n            SideTabKind::GitLens,\r\n            SideTabKind::Azure,\r\n            SideTabKind::Jupyter,\r\n            SideTabKind::Chat,\r\n            SideTabKind::GitHubActions,\r\n            SideTabKind::Todo,\r\n        ]\r\n    }\r\n    pub fn get_view_automation_id(&self) -> Option<&str> {\r\n        match self {\r\n            SideTabKind::Explorer => Some(\"workbench.view.explorer\"),\r\n            _ => None,\r\n        }\r\n    }\r\n}\r\nimpl TryFrom<String> for SideTabKind {\r\n    type Error = VSCodeResolveError;\r\n    fn try_from(s: String) -> Result<Self, Self::Error> {\r\n        let before_first_lparen = s.split_once(\" (\").map(|x| x.0).unwrap_or(s.as_str());\r\n        match before_first_lparen {\r\n            \"Explorer\" => Ok(SideTabKind::Explorer),\r\n            \"Search\" => Ok(SideTabKind::Search),\r\n            \"Source Control\" => Ok(SideTabKind::SourceControl),\r\n            \"Run and Debug\" => Ok(SideTabKind::RunAndDebug),\r\n            \"Extensions\" => Ok(SideTabKind::Extensions),\r\n            \"GitLens\" => Ok(SideTabKind::GitLens),\r\n            \"Azure\" => Ok(SideTabKind::Azure),\r\n            \"Jupyter\" => Ok(SideTabKind::Jupyter),\r\n            \"Chat\" => Ok(SideTabKind::Chat),\r\n            \"GitHub Actions\" => Ok(SideTabKind::GitHubActions),\r\n            \"TODOs\" => Ok(SideTabKind::Todo),\r\n            _ => Err(VSCodeResolveError::UnknownSideTabKind(s)),\r\n        }\r\n    }\r\n}\r\n\r\n#ENDREGION\r\n\r\n\r\n#REGION crates/ui_automation/examples/calculator_example.rs\r\n#![feature(let_chains)]\r\nuse bevy::input::common_conditions::input_toggle_active;\r\nuse bevy::log::LogPlugin;\r\nuse bevy::prelude::*;\r\nuse bevy::window::PrimaryWindow;\r\nuse bevy_egui::egui;\r\nuse bevy_egui::EguiContexts;\r\nuse bevy_egui::EguiSet;\r\nuse bevy_inspector_egui::quick::WorldInspectorPlugin;\r\nuse bevy_inspector_egui::reflect_inspector::Context;\r\nuse bevy_inspector_egui::reflect_inspector::InspectorUi;\r\nuse cursor_hero_memory::primary_window_memory_plugin::PrimaryWindowMemoryPlugin;\r\nuse cursor_hero_ui_automation::prelude::*;\r\nuse cursor_hero_winutils::win_mouse::get_cursor_position;\r\nuse cursor_hero_worker::prelude::Message;\r\nuse cursor_hero_worker::prelude::Sender;\r\nuse cursor_hero_worker::prelude::WorkerConfig;\r\nuse cursor_hero_worker::prelude::WorkerPlugin;\r\nfn main() {\r\n    let mut app = App::new();\r\n    app.add_plugins(\r\n        DefaultPlugins\r\n            .set(LogPlugin {\r\n                level: bevy::log::Level::DEBUG,\r\n                filter: \"\r\ninfo,\r\nwgpu_core=warn,\r\nwgpu_hal=warn,\r\ncalculator_example=trace,\r\ncursor_hero_worker=debug,\r\n\"\r\n                .replace('\\n', \"\")\r\n                .trim()\r\n                .into(),\r\n            })\r\n            .build(),\r\n    );\r\n    app.add_plugins(WorkerPlugin {\r\n        config: WorkerConfig::<ThreadboundUISnapshotMessage, GameboundUISnapshotMessage> {\r\n            name: \"calculator\".to_string(),\r\n            is_ui_automation_thread: true,\r\n            handle_threadbound_message: handle_threadbound_message,\r\n            ..default()\r\n        },\r\n    });\r\n    app.add_plugins(\r\n        WorldInspectorPlugin::default().run_if(input_toggle_active(false, KeyCode::Grave)),\r\n    );\r\n    app.add_plugins(PrimaryWindowMemoryPlugin);\r\n    app.insert_resource(ClearColor(Color::rgb(0.992, 0.714, 0.69)));\r\n    app.add_systems(Startup, spawn_camera);\r\n    app.add_systems(\r\n        Update,\r\n        step_1_of_making_the_calculators_in_the_game_match_the_calculator_apps_running_in_the_host,\r\n    );\r\n    app.add_systems(\r\n        Update,\r\n        step_2_of_making_the_calculators_in_the_game_match_the_calculator_apps_running_in_the_host,\r\n    );\r\n    app.run();\r\n}\r\n\r\nfn spawn_camera(mut commands: Commands) {\r\n    commands.spawn(Camera2dBundle::default());\r\n}\r\n\r\n#[derive(Debug, Reflect, Clone, Event)]\r\nenum ThreadboundUISnapshotMessage {\r\n    RequestUISnapshot,\r\n}\r\nimpl Message for ThreadboundUISnapshotMessage {}\r\n\r\n#[derive(Debug, Reflect, Clone, Event)]\r\nenum GameboundUISnapshotMessage {\r\n    UISnapshot(UISnapshot),\r\n}\r\nimpl Message for GameboundUISnapshotMessage {}\r\n\r\nfn handle_threadbound_message(\r\n    msg: &ThreadboundUISnapshotMessage,\r\n    reply_tx: &Sender<GameboundUISnapshotMessage>,\r\n) -> Result<(), Box<dyn std::error::Error>> {\r\n    let ThreadboundUISnapshotMessage::RequestUISnapshot = msg;\r\n    debug!(\"getting state of host calculators\");\r\n    let snapshot = take_snapshot()?;\r\n    if let Err(e) = reply_tx.send(GameboundUISnapshotMessage::UISnapshot(snapshot)) {\r\n        error!(\"Failed to send snapshot: {:?}\", e);\r\n    }\r\n    Ok(())\r\n}\r\n\r\nfn step_1_of_making_the_calculators_in_the_game_match_the_calculator_apps_running_in_the_host(\r\n    // mut data: ResMut<UIData>,\r\n    mut cooldown: Local<Option<Timer>>,\r\n    time: Res<Time>,\r\n    mut events: EventWriter<ThreadboundUISnapshotMessage>,\r\n    window: Query<&Window, With<PrimaryWindow>>,\r\n) {\r\n    let Ok(window) = window.get_single() else {\r\n        return;\r\n    };\r\n    if window.cursor_position().is_some() {\r\n        return;\r\n    }\r\n    let cooldown_over = if let Some(cooldown) = cooldown.as_mut() {\r\n        if cooldown.tick(time.delta()).just_finished() {\r\n            cooldown.reset();\r\n            true\r\n        } else {\r\n            false\r\n        }\r\n    } else {\r\n        cooldown.replace(Timer::from_seconds(0.5, TimerMode::Repeating));\r\n        true\r\n    };\r\n    if !cooldown_over {\r\n        return;\r\n    }\r\n\r\n    // if data.in_flight {\r\n    //     warn!(\"Too fast!\");\r\n    //     return;\r\n    // }\r\n\r\n    events.send(ThreadboundUISnapshotMessage::RequestUISnapshot);\r\n    // data.in_flight = true;\r\n}\r\n\r\nfn step_2_of_making_the_calculators_in_the_game_match_the_calculator_apps_running_in_the_host(\r\n    mut snapshot: EventReader<GameboundUISnapshotMessage>,\r\n    calculator_query: Query<&Calculator>,\r\n    mut commands: Commands,\r\n) {\r\n    for msg in snapshot.read() {\r\n        let GameboundUISnapshotMessage::UISnapshot(snapshot) = msg;\r\n        debug!(\"Received snapshot: {:?}\", snapshot);\r\n        for app in snapshot.app_windows.iter() {\r\n            let AppWindow::Calculator(calculator) = app else {\r\n                continue;\r\n            };\r\n            debug!(\"Received calculator: {:?}\", calculator);\r\n        }\r\n    }\r\n}\r\n\r\n#ENDREGION\r\n\r\n\r\n#REGION crates/ui_automation/examples/ui_hover_example.rs\r\n#![feature(let_chains, trivial_bounds)]\r\nuse std::collections::VecDeque;\r\n\r\nuse bevy::input::common_conditions::input_toggle_active;\r\nuse bevy::log::LogPlugin;\r\nuse bevy::prelude::*;\r\nuse bevy::utils::HashMap;\r\nuse bevy::window::PrimaryWindow;\r\nuse bevy_egui::egui;\r\nuse bevy_egui::egui::Align2;\r\nuse bevy_egui::EguiContexts;\r\nuse bevy_egui::EguiSet;\r\nuse bevy_inspector_egui::quick::WorldInspectorPlugin;\r\nuse bevy_inspector_egui::reflect_inspector::Context;\r\nuse bevy_inspector_egui::reflect_inspector::InspectorUi;\r\nuse cursor_hero_memory::primary_window_memory_plugin::PrimaryWindowMemoryPlugin;\r\nuse cursor_hero_ui_automation::prelude::*;\r\nuse cursor_hero_winutils::win_mouse::get_cursor_position;\r\nuse cursor_hero_worker::prelude::Message;\r\nuse cursor_hero_worker::prelude::Sender;\r\nuse cursor_hero_worker::prelude::WorkerConfig;\r\nuse cursor_hero_worker::prelude::WorkerPlugin;\r\nuse itertools::Itertools;\r\nuse uiautomation::UIAutomation;\r\nfn main() {\r\n    let mut app = App::new();\r\n    app.add_plugins(\r\n        DefaultPlugins\r\n            .set(LogPlugin {\r\n                level: bevy::log::Level::DEBUG,\r\n                filter: \"\r\ninfo,\r\nwgpu_core=warn,\r\nwgpu_hal=warn,\r\nui_hover_example=trace,\r\ncursor_hero_worker=debug,\r\n\"\r\n                .replace('\\n', \"\")\r\n                .trim()\r\n                .into(),\r\n            })\r\n            .build(),\r\n    );\r\n    app.add_plugins(WorkerPlugin {\r\n        config: WorkerConfig::<ThreadboundUISnapshotMessage, GameboundUISnapshotMessage> {\r\n            name: \"ui_hover\".to_string(),\r\n            is_ui_automation_thread: true,\r\n            handle_threadbound_message: handle_threadbound_message,\r\n            handle_threadbound_message_error_handler: handle_threadbound_message_error_handler,\r\n            ..default()\r\n        },\r\n    });\r\n    app.add_plugins(\r\n        WorldInspectorPlugin::default().run_if(input_toggle_active(false, KeyCode::Grave)),\r\n    );\r\n    app.add_plugins(PrimaryWindowMemoryPlugin);\r\n    app.insert_resource(ClearColor(Color::rgb(0.992, 0.714, 0.69)));\r\n    app.add_systems(Startup, spawn_camera);\r\n    app.add_systems(Update, periodic_snapshot);\r\n    app.add_systems(Update, fetch_requested);\r\n    app.add_systems(Update, receive);\r\n    app.add_systems(Update, gui.after(EguiSet::InitContexts));\r\n    app.init_resource::<UIData>();\r\n    app.register_type::<UIData>();\r\n    app.run();\r\n}\r\n\r\nfn spawn_camera(mut commands: Commands) {\r\n    commands.spawn(Camera2dBundle::default());\r\n}\r\n\r\n#[derive(Debug, Reflect, Clone, Event)]\r\nenum ThreadboundUISnapshotMessage {\r\n    CaptureHovered,\r\n    ChildrenFetchRequest {\r\n        drill_id: DrillId,\r\n        runtime_id: RuntimeId,\r\n    },\r\n}\r\nimpl Message for ThreadboundUISnapshotMessage {}\r\n\r\n#[derive(Debug, Reflect, Clone, Event)]\r\nenum GameboundUISnapshotMessage {\r\n    Hovered {\r\n        ui_tree: ElementInfo,\r\n        start: ElementInfo,\r\n        hovered: ElementInfo,\r\n    },\r\n    ChildrenFetchResponse {\r\n        drill_id: DrillId,\r\n        runtime_id: RuntimeId,\r\n        children: Vec<ElementInfo>,\r\n    },\r\n    Error,\r\n}\r\nimpl Message for GameboundUISnapshotMessage {}\r\n\r\n#[derive(Debug, Reflect)]\r\nenum FetchingState {\r\n    FetchRequest,\r\n    FetchDispatched,\r\n    Fetched(Vec<ElementInfo>),\r\n}\r\n\r\n#[derive(Resource, Debug, Reflect, Default)]\r\n#[reflect(Resource)]\r\nstruct UIData {\r\n    pub start: ElementInfo,\r\n    pub hovered: ElementInfo,\r\n    pub ui_tree: ElementInfo,\r\n    pub selected: Option<DrillId>,\r\n    pub expanded: Vec<DrillId>,\r\n    pub fresh: bool,\r\n    pub in_flight: bool,\r\n    pub paused: bool,\r\n    // Include runtime id in case tree changes and we quickly fetch something with the same drill_id before the first request comes back\r\n    pub fetching: HashMap<(DrillId, RuntimeId), FetchingState>,\r\n}\r\n\r\nfn handle_threadbound_message_error_handler(\r\n    _msg: &ThreadboundUISnapshotMessage,\r\n    reply_tx: &Sender<GameboundUISnapshotMessage>,\r\n    error: &Box<dyn std::error::Error>,\r\n) -> Result<(), Box<dyn std::error::Error>> {\r\n    reply_tx.send(GameboundUISnapshotMessage::Error)?;\r\n    Ok(())\r\n}\r\nfn handle_threadbound_message(\r\n    msg: &ThreadboundUISnapshotMessage,\r\n    reply_tx: &Sender<GameboundUISnapshotMessage>,\r\n) -> Result<(), Box<dyn std::error::Error>> {\r\n    match msg {\r\n        ThreadboundUISnapshotMessage::CaptureHovered => {\r\n            debug!(\"taking snapshot\");\r\n            let cursor_pos = get_cursor_position()?;\r\n            let hovered = find_element_at(cursor_pos)?;\r\n            let hovered_info = gather_single_element_info(&hovered)?;\r\n            let gathered = gather_incomplete_ui_tree_starting_deep(hovered)?;\r\n            if let Err(e) = reply_tx.send(GameboundUISnapshotMessage::Hovered {\r\n                ui_tree: gathered.ui_tree,\r\n                start: gathered.start_info,\r\n                hovered: hovered_info,\r\n            }) {\r\n                error!(\"Failed to send snapshot: {:?}\", e);\r\n            }\r\n        }\r\n        ThreadboundUISnapshotMessage::ChildrenFetchRequest {\r\n            drill_id,\r\n            runtime_id,\r\n        } => {\r\n            debug!(\"fetching children for {:?}\", drill_id);\r\n            let automation = UIAutomation::new()?;\r\n            let walker = automation.create_tree_walker()?;\r\n            let root = automation.get_root_element()?;\r\n            let found = root.drill(&walker, drill_id.clone())?;\r\n            let mut children = found\r\n                .gather_children(&walker, &StopBehaviour::EndOfSiblings)\r\n                .into_iter()\r\n                .enumerate()\r\n                .filter_map(|(i, child)| {\r\n                    gather_single_element_info(&child)\r\n                        .ok()\r\n                        .map(|mut child_info| {\r\n                            child_info.drill_id = DrillId::Child(vec![i].into_iter().collect());\r\n                            child_info\r\n                        })\r\n                })\r\n                .collect_vec();\r\n\r\n            update_drill_ids(Some(&mut children), &drill_id);\r\n            if let Err(e) = reply_tx.send(GameboundUISnapshotMessage::ChildrenFetchResponse {\r\n                drill_id: drill_id.clone(),\r\n                runtime_id: runtime_id.clone(),\r\n                children,\r\n            }) {\r\n                error!(\"Failed to send ChildrenFetchResponse: {:?}\", e);\r\n            }\r\n        }\r\n    }\r\n    Ok(())\r\n}\r\n\r\nfn fetch_requested(\r\n    mut data: ResMut<UIData>,\r\n    mut events: EventWriter<ThreadboundUISnapshotMessage>,\r\n) {\r\n    for (key, state) in data.fetching.iter_mut() {\r\n        if let FetchingState::FetchRequest = state {\r\n            *state = FetchingState::FetchDispatched;\r\n            events.send(ThreadboundUISnapshotMessage::ChildrenFetchRequest {\r\n                drill_id: key.0.clone(),\r\n                runtime_id: key.1.clone(),\r\n            });\r\n        }\r\n    }\r\n}\r\n\r\nfn periodic_snapshot(\r\n    mut data: ResMut<UIData>,\r\n    mut cooldown: Local<Option<Timer>>,\r\n    time: Res<Time>,\r\n    mut events: EventWriter<ThreadboundUISnapshotMessage>,\r\n    window: Query<&Window, With<PrimaryWindow>>,\r\n) {\r\n    let Ok(window) = window.get_single() else {\r\n        return;\r\n    };\r\n    if window.cursor_position().is_some() {\r\n        return;\r\n    }\r\n    let cooldown_over = if let Some(cooldown) = cooldown.as_mut() {\r\n        if cooldown.tick(time.delta()).just_finished() {\r\n            cooldown.reset();\r\n            true\r\n        } else {\r\n            false\r\n        }\r\n    } else {\r\n        cooldown.replace(Timer::from_seconds(0.5, TimerMode::Repeating));\r\n        true\r\n    };\r\n    if !cooldown_over {\r\n        return;\r\n    }\r\n\r\n    if data.paused {\r\n        return;\r\n    }\r\n\r\n    if data.in_flight {\r\n        warn!(\"Too fast!\");\r\n        return;\r\n    }\r\n\r\n    events.send(ThreadboundUISnapshotMessage::CaptureHovered);\r\n    data.in_flight = true;\r\n}\r\n\r\nfn receive(mut snapshot: EventReader<GameboundUISnapshotMessage>, mut ui_data: ResMut<UIData>) {\r\n    for msg in snapshot.read() {\r\n        match msg {\r\n            GameboundUISnapshotMessage::Error => {\r\n                ui_data.in_flight = false;\r\n            }\r\n            GameboundUISnapshotMessage::Hovered {\r\n                ui_tree,\r\n                start,\r\n                hovered,\r\n            } => {\r\n                ui_data.in_flight = false;\r\n                ui_data.ui_tree = ui_tree.clone();\r\n                ui_data.start = start.clone();\r\n                ui_data.hovered = hovered.clone();\r\n                ui_data.selected = Some(start.drill_id.clone());\r\n                ui_data.expanded = ui_tree\r\n                    .get_descendents()\r\n                    .iter()\r\n                    .chain([ui_tree].iter())\r\n                    .filter(|x| x.children.is_some())\r\n                    .map(|x| x.drill_id.clone())\r\n                    .collect();\r\n                ui_data.fresh = true;\r\n                debug!(\"Received snapshot\");\r\n            }\r\n            GameboundUISnapshotMessage::ChildrenFetchResponse {\r\n                drill_id,\r\n                runtime_id,\r\n                children,\r\n            } => {\r\n                let key = (drill_id.clone(), runtime_id.clone());\r\n                if let Some(FetchingState::FetchDispatched) = ui_data.fetching.get(&key) {\r\n                    ui_data\r\n                        .fetching\r\n                        .insert(key, FetchingState::Fetched(children.clone()));\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfn gui(\r\n    mut contexts: EguiContexts,\r\n    mut ui_data: ResMut<UIData>,\r\n    type_registry: Res<AppTypeRegistry>,\r\n) {\r\n    let ctx = contexts.ctx_mut();\r\n\r\n    let mut cx = Context {\r\n        world: None,\r\n        queue: None,\r\n    };\r\n\r\n    let type_registry = type_registry.0.clone();\r\n    let type_registry = type_registry.read();\r\n    let mut inspector = InspectorUi::for_bevy(&type_registry, &mut cx);\r\n\r\n    let id = egui::Id::new(\"Inspector\");\r\n    egui::Window::new(\"Inspector\")\r\n        .title_bar(false)\r\n        .id(id)\r\n        .default_pos((5.0, 5.0))\r\n        .default_width(1200.0)\r\n        .default_height(1000.0)\r\n        .show(ctx, |ui| {\r\n            egui::SidePanel::left(id.with(\"tree\"))\r\n                .resizable(true)\r\n                .width_range(100.0..=4000.0)\r\n                .default_width(600.0)\r\n                .show_inside(ui, |ui| {\r\n                    ui.vertical_centered(|ui| {\r\n                        ui.heading(\"UI Tree\");\r\n                    });\r\n                    egui::ScrollArea::both().show(ui, |ui| {\r\n                        let id = id.with(ui_data.ui_tree.runtime_id.clone());\r\n                        let mut elem = ui_data.ui_tree.clone();\r\n                        ui_for_element_info(id, ui, &mut ui_data, &mut elem, &mut inspector);\r\n                        ui_data.ui_tree = elem;\r\n                        ui.allocate_space(ui.available_size());\r\n                    });\r\n                });\r\n\r\n            egui::TopBottomPanel::bottom(id.with(\"invisible bottom panel\"))\r\n                .show_separator_line(false)\r\n                .show_inside(ui, |_| ());\r\n\r\n            egui::CentralPanel::default().show_inside(ui, |ui| {\r\n                ui.vertical_centered(|ui| {\r\n                    ui.heading(\"Properties\");\r\n                });\r\n                let id = ui_data.selected.clone();\r\n                if let Some(id) = id\r\n                    && let Some(x) = ui_data.ui_tree.lookup_drill_id_mut(id)\r\n                {\r\n                    inspector.ui_for_reflect_readonly(x, ui);\r\n                    ui.separator();\r\n                    ui.label(\"drill_id\");\r\n                    let drill_id = x.drill_id.to_string();\r\n                    inspector.ui_for_reflect_readonly(&drill_id, ui);\r\n                    if ui.button(\"copy\").clicked() {\r\n                        ui.output_mut(|out| {\r\n                            out.copied_text = drill_id.clone();\r\n                        });\r\n                        info!(\"Copied drill_id {} to clipboard\", drill_id);\r\n                    }\r\n                }\r\n                // inspector.ui_for_reflect_readonly(&data, ui);\r\n            });\r\n        });\r\n\r\n    let id = egui::Id::new(\"Paused\");\r\n    egui::Window::new(\"Paused\")\r\n        .id(id)\r\n        .title_bar(false)\r\n        .anchor(Align2::RIGHT_TOP, (5.0, 5.0))\r\n        .show(ctx, |ui| {\r\n            ui.checkbox(&mut ui_data.paused, \"Paused\");\r\n        });\r\n    ui_data.fresh = false;\r\n}\r\n\r\n#[allow(clippy::too_many_arguments)]\r\nfn ui_for_element_info(\r\n    id: egui::Id,\r\n    ui: &mut egui::Ui,\r\n    data: &mut UIData,\r\n    element_info: &mut ElementInfo,\r\n    _inspector: &mut InspectorUi,\r\n) {\r\n    let default_open = data.expanded.contains(&element_info.drill_id);\r\n    let mut expando = egui::collapsing_header::CollapsingState::load_with_default_open(\r\n        ui.ctx(),\r\n        id,\r\n        default_open,\r\n    );\r\n    if data.fresh {\r\n        expando.set_open(default_open);\r\n        data.fetching.clear();\r\n    }\r\n    if expando.is_open() && element_info.children.is_none() {\r\n        let key = (\r\n            element_info.drill_id.clone(),\r\n            element_info.runtime_id.clone(),\r\n        );\r\n        let found = data.fetching.get_mut(&key);\r\n        if !found.is_some() {\r\n            data.fetching.insert(key, FetchingState::FetchRequest);\r\n        } else if let Some(FetchingState::Fetched(ref mut children)) = found {\r\n            element_info.children = Some(std::mem::take(children));\r\n            data.fetching.remove(&key);\r\n        } else {\r\n            ui.label(\"fetching...\");\r\n        }\r\n    }\r\n    expando\r\n        .show_header(ui, |ui| {\r\n            let mut selected = data.selected == Some(element_info.drill_id.clone());\r\n            if selected && data.fresh {\r\n                ui.scroll_to_cursor(Some(egui::Align::Center));\r\n            }\r\n            if ui\r\n                .toggle_value(\r\n                    &mut selected,\r\n                    format!(\r\n                        \"{:?} | {}\",\r\n                        element_info.name, element_info.localized_control_type\r\n                    ),\r\n                )\r\n                .changed()\r\n            {\r\n                data.selected = if selected {\r\n                    Some(element_info.drill_id.clone())\r\n                } else {\r\n                    None\r\n                };\r\n            };\r\n        })\r\n        .body(|ui| {\r\n            if let Some(ref mut children) = element_info.children {\r\n                for child in children.iter_mut() {\r\n                    ui_for_element_info(\r\n                        id.with(child.runtime_id.clone()),\r\n                        ui,\r\n                        data,\r\n                        child,\r\n                        _inspector,\r\n                    );\r\n                }\r\n            }\r\n        });\r\n}\r\n\r\n#ENDREGION\r\n\r\n\r\n#REGION crates/ui_automation/examples/ui_snapshot_example.rs\r\nuse bevy::log::LogPlugin;\r\nuse bevy::prelude::*;\r\nuse bevy::window::ExitCondition;\r\nuse cursor_hero_memory_types::prelude::get_persist_file;\r\nuse cursor_hero_memory_types::prelude::Usage;\r\nuse cursor_hero_ui_automation::prelude::*;\r\nuse cursor_hero_worker::prelude::*;\r\nuse std::io::Write;\r\nfn main() {\r\n    let mut app = App::new();\r\n    app.add_plugins(\r\n        DefaultPlugins\r\n            .set(LogPlugin {\r\n                level: bevy::log::Level::DEBUG,\r\n                filter: \"\r\ninfo,\r\nwgpu_core=warn,\r\nwgpu_hal=warn,\r\nui_snapshot_example=trace,\r\ncursor_hero_worker=debug,\r\n\"\r\n                .replace('\\n', \"\")\r\n                .trim()\r\n                .into(),\r\n            })\r\n            .set(WindowPlugin {\r\n                primary_window: None,\r\n                exit_condition: ExitCondition::DontExit,\r\n                ..default()\r\n            })\r\n            .build(),\r\n    );\r\n    app.add_plugins(WorkerPlugin {\r\n        config: WorkerConfig::<ThreadboundUISnapshotMessage, GameboundUISnapshotMessage> {\r\n            name: \"ui_snapshot\".to_string(),\r\n            is_ui_automation_thread: true,\r\n            handle_threadbound_message: handle_threadbound_message,\r\n            ..default()\r\n        },\r\n    });\r\n    app.add_systems(Update, trigger);\r\n    app.add_systems(Update, receive);\r\n    app.run();\r\n}\r\n\r\n#[derive(Debug, Reflect, Clone, Event)]\r\nenum ThreadboundUISnapshotMessage {\r\n    TakeSnapshot,\r\n}\r\nimpl Message for ThreadboundUISnapshotMessage {}\r\n\r\n#[derive(Debug, Reflect, Clone, Event)]\r\nenum GameboundUISnapshotMessage {\r\n    Snapshot(UISnapshot),\r\n}\r\nimpl Message for GameboundUISnapshotMessage {}\r\n\r\nfn handle_threadbound_message(\r\n    msg: &ThreadboundUISnapshotMessage,\r\n    reply_tx: &Sender<GameboundUISnapshotMessage>,\r\n) -> Result<(), Box<dyn std::error::Error>> {\r\n    let ThreadboundUISnapshotMessage::TakeSnapshot = msg;\r\n    debug!(\"taking snapshot\");\r\n    let snapshot = take_snapshot()?;\r\n    if let Err(e) = reply_tx.send(GameboundUISnapshotMessage::Snapshot(snapshot)) {\r\n        error!(\"Failed to send snapshot: {:?}\", e);\r\n    }\r\n    Ok(())\r\n}\r\n\r\nfn trigger(\r\n    mut cooldown: Local<Option<Timer>>,\r\n    time: Res<Time>,\r\n    mut events: EventWriter<ThreadboundUISnapshotMessage>,\r\n) {\r\n    let should_tick = if let Some(cooldown) = cooldown.as_mut() {\r\n        if cooldown.tick(time.delta()).just_finished() {\r\n            cooldown.reset();\r\n            true\r\n        } else {\r\n            false\r\n        }\r\n    } else {\r\n        cooldown.replace(Timer::from_seconds(3.0, TimerMode::Repeating));\r\n        true\r\n    };\r\n    if !should_tick {\r\n        return;\r\n    }\r\n    events.send(ThreadboundUISnapshotMessage::TakeSnapshot);\r\n}\r\n\r\nfn receive(mut snapshot: EventReader<GameboundUISnapshotMessage>) {\r\n    for msg in snapshot.read() {\r\n        match msg {\r\n            GameboundUISnapshotMessage::Snapshot(snapshot) => {\r\n                debug!(\"received snapshot, writing to file\");\r\n                match get_persist_file(file!(), \"ui_snapshot.txt\", Usage::Persist) {\r\n                    Ok(mut file) => {\r\n                        if let Err(e) = file.write_all(snapshot.to_string().as_bytes()) {\r\n                            debug!(\"Failed to write to file: {:?}\", e);\r\n                        }\r\n                    }\r\n                    Err(e) => {\r\n                        error!(\"Failed to open file: {:?}\", e);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n#ENDREGION\r\n\r\n\r\n#REGION crates/ui_automation/src/elements_at_point.rs\r\nuse bevy::math::IVec2;\r\nuse std::collections::VecDeque;\r\nuse uiautomation::types::Point;\r\nuse uiautomation::UIAutomation;\r\nuse uiautomation::UIElement;\r\n\r\npub fn find_element_at(pos: IVec2) -> Result<UIElement, uiautomation::Error> {\r\n    let automation = UIAutomation::new()?;\r\n    automation.element_from_point(Point::new(pos.x, pos.y))\r\n}\r\n\r\npub fn gather_elements_at(pos: IVec2) -> Result<Vec<(UIElement, usize)>, uiautomation::Error> {\r\n    let automation = UIAutomation::new()?;\r\n    let walker = automation.create_tree_walker()?;\r\n    let start = automation.element_from_point(Point::new(pos.x, pos.y))?;\r\n    let mut rtn = vec![];\r\n    let mut next = VecDeque::new();\r\n    next.push_back((start, 0));\r\n    while let Some((elem, depth)) = next.pop_front() {\r\n        rtn.push((elem.clone(), depth));\r\n        if let Ok(child) = walker.get_first_child(&elem) {\r\n            next.push_back((child.clone(), depth + 1));\r\n            let mut next_sibling = child;\r\n            while let Ok(sibling) = walker.get_next_sibling(&next_sibling) {\r\n                next.push_back((sibling.clone(), depth + 1));\r\n                next_sibling = sibling;\r\n            }\r\n        }\r\n    }\r\n    Ok(rtn)\r\n}\r\n\r\n#ENDREGION\r\n\r\n\r\n#REGION crates/ui_automation/src/formatting.rs\r\nuse uiautomation::UIAutomation;\r\nuse uiautomation::UIElement;\r\n\r\npub fn get_tree_string(element: &UIElement) -> Result<String, uiautomation::Error> {\r\n    let automation = UIAutomation::new()?;\r\n    format_tree_recursive(element, &automation, 0)\r\n}\r\nfn format_tree_recursive(\r\n    element: &UIElement,\r\n    automation: &UIAutomation,\r\n    depth: usize,\r\n) -> Result<String, uiautomation::Error> {\r\n    // Format the current element's label.\r\n    let mut result = format!(\r\n        \"{}{}\\n\",\r\n        \" \".repeat(depth * 2), // Increase indentation with depth.\r\n        format_tree_label(element)\r\n    );\r\n\r\n    // Use the TreeWalker to navigate the children.\r\n    let walker = automation.create_tree_walker()?;\r\n    if let Ok(child) = walker.get_first_child(element) {\r\n        // Recursively format the child and any siblings.\r\n        result.push_str(&format_tree_recursive(&child, automation, depth + 1)?);\r\n        let mut next_sibling = child;\r\n        while let Ok(sibling) = walker.get_next_sibling(&next_sibling) {\r\n            result.push_str(&format_tree_recursive(&sibling, automation, depth + 1)?);\r\n            next_sibling = sibling;\r\n        }\r\n    }\r\n    Ok(result)\r\n}\r\nfn format_tree_label(element: &UIElement) -> String {\r\n    format!(\r\n        \"name={} control_type={} class_name={} runtime_id={} rect={}\",\r\n        element\r\n            .get_name()\r\n            .map(|name| format!(\"{:?}\", name))\r\n            .unwrap_or_else(|_| \"(null)\".to_string()),\r\n        element\r\n            .get_control_type()\r\n            .map(|ct| format!(\"{:?}\", ct))\r\n            .unwrap_or_else(|_| \"unknown control type\".to_string()),\r\n        element\r\n            .get_classname()\r\n            .map(|name| format!(\"{:?}\", name))\r\n            .unwrap_or_else(|_| \"(null)\".to_string()),\r\n        element\r\n            .get_runtime_id()\r\n            .map(|id| format!(\"{:?}\", id))\r\n            .unwrap_or_else(|_| \"(null)\".to_string()),\r\n        element\r\n            .get_bounding_rectangle()\r\n            .map(|rect| format!(\"{:?}\", rect))\r\n            .unwrap_or_else(|_| \"(null)\".to_string()),\r\n    )\r\n}\r\n\r\n#ENDREGION\r\n\r\n\r\n#REGION crates/ui_automation/src/gather_children.rs\r\nuse std::collections::VecDeque;\r\n\r\nuse cursor_hero_metrics::Metrics;\r\nuse uiautomation::UIElement;\r\nuse uiautomation::UITreeWalker;\r\n\r\n#[allow(dead_code)]\r\n#[derive(Debug)]\r\npub enum StopBehaviour {\r\n    EndOfSiblings,\r\n    LastChildEncountered,\r\n    TaskbarEndEncountered,\r\n    RootEndEncountered, // Calling get_next_sibling on the last child of root will hang, so use this to mitigate\r\n}\r\nimpl StopBehaviour {\r\n    fn include_last_child(&self) -> bool {\r\n        !matches!(self, StopBehaviour::TaskbarEndEncountered)\r\n    }\r\n}\r\ntrait GatherChildrenStopBehaviourFn {\r\n    fn should_stop(&self, next: &UIElement) -> bool;\r\n}\r\n\r\n#[derive(Debug)]\r\nstruct EndOfSiblings;\r\nimpl GatherChildrenStopBehaviourFn for EndOfSiblings {\r\n    fn should_stop(&self, _element: &UIElement) -> bool {\r\n        false\r\n    }\r\n}\r\n\r\n#[derive(Debug)]\r\nstruct LastChildEncountered {\r\n    runtime_id_of_last: Vec<i32>,\r\n}\r\nimpl GatherChildrenStopBehaviourFn for LastChildEncountered {\r\n    fn should_stop(&self, element: &UIElement) -> bool {\r\n        element.get_runtime_id() == Ok(self.runtime_id_of_last.clone())\r\n    }\r\n}\r\n\r\n#[derive(Debug)]\r\nstruct TaskbarEndEncountered;\r\nimpl GatherChildrenStopBehaviourFn for TaskbarEndEncountered {\r\n    fn should_stop(&self, element: &UIElement) -> bool {\r\n        element.get_automation_id() == Ok(\"TaskbarEndAccessibilityElement\".to_string())\r\n    }\r\n}\r\n\r\n#[derive(Debug)]\r\nstruct RootEndEncountered;\r\nimpl GatherChildrenStopBehaviourFn for RootEndEncountered {\r\n    fn should_stop(&self, element: &UIElement) -> bool {\r\n        element.get_name() == Ok(\"Program Manager\".to_string())\r\n            && element.get_classname() == Ok(\"Progman\".to_string())\r\n        // This could be more specific, but until a false positive is encountered, this is fine\r\n    }\r\n}\r\n\r\npub trait GatherChildrenable {\r\n    fn gather_children(\r\n        &self,\r\n        walker: &UITreeWalker,\r\n        stop_behaviour: &StopBehaviour,\r\n    ) -> VecDeque<UIElement>;\r\n}\r\nimpl GatherChildrenable for UIElement {\r\n    fn gather_children(\r\n        &self,\r\n        walker: &UITreeWalker,\r\n        stop_behaviour: &StopBehaviour,\r\n    ) -> VecDeque<UIElement> {\r\n        gather_children(walker, self, stop_behaviour)\r\n    }\r\n}\r\n\r\npub fn gather_children(\r\n    walker: &UITreeWalker,\r\n    parent: &UIElement,\r\n    stop_behaviour: &StopBehaviour,\r\n) -> VecDeque<UIElement> {\r\n    // println!(\"Gathering children of {:?}\", parent);\r\n    let mut children = VecDeque::new();\r\n    let mut metrics = Metrics::default();\r\n\r\n    // println!(\"Constructing stop behaviour fn for {:?}\", stop_behaviour);\r\n    metrics.begin(\"construct stop behaviour\");\r\n    let stop: Box<dyn GatherChildrenStopBehaviourFn> = match stop_behaviour {\r\n        StopBehaviour::EndOfSiblings => Box::new(EndOfSiblings),\r\n        StopBehaviour::LastChildEncountered => {\r\n            // println!(\"Getting last child of {:?}\", parent);\r\n            let last = walker.get_last_child(parent);\r\n            let last = match last {\r\n                Ok(last) => last,\r\n                Err(_) => {\r\n                    eprintln!(\"Failed to get last child of {:?}\", parent);\r\n                    return children\r\n                },\r\n            };\r\n            let runtime_id_of_last = last.get_runtime_id();\r\n            let runtime_id_of_last = match runtime_id_of_last {\r\n                Ok(runtime_id_of_last) => runtime_id_of_last,\r\n                Err(_) => {\r\n                    eprintln!(\"Failed to get runtime id of last child {:?} of {:?}\", last, parent);\r\n                    return children\r\n                },\r\n            };\r\n            Box::new(LastChildEncountered { runtime_id_of_last })\r\n        }\r\n        StopBehaviour::TaskbarEndEncountered => Box::new(TaskbarEndEncountered),\r\n        StopBehaviour::RootEndEncountered => Box::new(RootEndEncountered),\r\n    };\r\n    metrics.end(\"construct stop behaviour\");\r\n    // println!(\"Constructed stop behaviour {:?}\", stop_behaviour);\r\n\r\n    // println!(\"Finding first child\");\r\n    metrics.begin(\"find first child\");\r\n    let first = walker.get_first_child(parent);\r\n    metrics.end(\"find first child\");\r\n    // println!(\"Found first child\");\r\n\r\n    let Ok(first) = first else {\r\n        return children;\r\n    };\r\n    children.push_back(first.clone());\r\n    let mut next = first;\r\n    let mut i = 0;\r\n    loop {\r\n        // println!(\"About to grab next sibling of {:?}\", next);\r\n        metrics.begin(format!(\"get next sibling {}\", i).as_str());\r\n        let sibling = walker.get_next_sibling(&next);\r\n        metrics.end(format!(\"get next sibling {}\", i).as_str());\r\n        i += 1;\r\n\r\n        if let Ok(sibling) = sibling {\r\n            // println!(\"Got sibling {:?}\", sibling);\r\n            // println!(\"Checking if should stop\");\r\n            if stop.should_stop(&sibling) {\r\n                // println!(\"Should stop\");\r\n                if stop_behaviour.include_last_child() {\r\n                    // println!(\"Including last child\");\r\n                    children.push_back(sibling.clone());\r\n                }\r\n                break;\r\n            } else {\r\n                // println!(\"Should not stop\");\r\n                children.push_back(sibling.clone());\r\n                next = sibling;\r\n            }\r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n    // println!(\"Gathered {} children\", children.len());\r\n    // println!(\"| {}\", metrics.report().split(\" | \").join(\"\\n| \"));\r\n    children\r\n}\r\n\r\n#ENDREGION\r\n\r\n\r\n#REGION crates/ui_automation/src/gather_element_info.rs\r\nuse bevy::math::Rect;\r\nuse cursor_hero_ui_automation_types::prelude::DrillId;\r\nuse cursor_hero_ui_automation_types::prelude::ElementInfo;\r\nuse itertools::Itertools;\r\nuse std::collections::VecDeque;\r\nuse uiautomation::Error;\r\nuse uiautomation::UIAutomation;\r\nuse uiautomation::UIElement;\r\nuse uiautomation::UITreeWalker;\r\n\r\nuse crate::gather_children::GatherChildrenable;\r\nuse crate::gather_children::StopBehaviour;\r\n\r\npub struct GatherUITreeOkResult {\r\n    pub ui_tree: ElementInfo,\r\n    pub start_info: ElementInfo,\r\n}\r\npub fn gather_incomplete_ui_tree_starting_deep(\r\n    start_element: UIElement,\r\n) -> Result<GatherUITreeOkResult, Error> {\r\n    let automation = UIAutomation::new()?;\r\n    let walker = automation.create_tree_walker()?;\r\n    let ancestors = collect_ancestors(&start_element, &walker)?;\r\n    // println!(\"ancestors: {:?}\", ancestors);\r\n\r\n    let root_element = ancestors\r\n        .front()\r\n        .ok_or(Error::new(-1, \"No root element found\"))?\r\n        .clone();\r\n    let mut root_info = gather_tree(&root_element, &walker, &ancestors, 0)?;\r\n    root_info.drill_id = DrillId::Root;\r\n\r\n    update_drill_ids(root_info.children.as_mut(), &DrillId::Root);\r\n\r\n    let start_info = root_info\r\n        .get_descendents()\r\n        .into_iter()\r\n        .find(|info| Ok(&info.runtime_id) == start_element.get_runtime_id().as_ref())\r\n        .cloned();\r\n    let Some(start_info) = start_info else {\r\n        return Err(Error::new(\r\n            -1,\r\n            format!(\r\n                \"Start element {:?} (id: {:?}) not found in tree: {:?}\",\r\n                start_element,\r\n                start_element.get_runtime_id(),\r\n                root_info\r\n            )\r\n            .as_str(),\r\n        ));\r\n    };\r\n    // let start_info = start_info.unwrap_or_else(|| root_info.clone());\r\n\r\n    Ok(GatherUITreeOkResult {\r\n        ui_tree: root_info,\r\n        start_info,\r\n    })\r\n}\r\n\r\nfn collect_ancestors(\r\n    element: &UIElement,\r\n    walker: &UITreeWalker,\r\n) -> Result<VecDeque<UIElement>, Error> {\r\n    let mut ancestors = VecDeque::new();\r\n    let mut current_element = Some(element.clone());\r\n    while let Some(elem) = current_element {\r\n        ancestors.push_front(elem.clone());\r\n        current_element = walker.get_parent(&elem).ok();\r\n    }\r\n    Ok(ancestors)\r\n}\r\n\r\nfn gather_tree(\r\n    element: &UIElement,\r\n    walker: &UITreeWalker,\r\n    ancestors: &VecDeque<UIElement>,\r\n    depth: usize,\r\n) -> Result<ElementInfo, Error> {\r\n    let is_ancestor = |element: &UIElement| {\r\n        ancestors\r\n            .iter()\r\n            .any(|ancestor| ancestor.get_runtime_id() == element.get_runtime_id())\r\n    };\r\n    let on_ancestor = is_ancestor(element);\r\n    let mut element_info = gather_single_element_info(element)?;\r\n\r\n    if on_ancestor {\r\n        let children = element\r\n            .gather_children(\r\n                walker,\r\n                if depth == 0 {\r\n                    &StopBehaviour::RootEndEncountered\r\n                } else {\r\n                    &StopBehaviour::EndOfSiblings\r\n                },\r\n            )\r\n            .into_iter()\r\n            .enumerate()\r\n            .filter_map(|(i, child)| {\r\n                if is_ancestor(&child) {\r\n                    gather_tree(&child, walker, ancestors, depth + 1).ok()\r\n                } else {\r\n                    gather_single_element_info(&child).ok()\r\n                }\r\n                .map(|mut child_info| {\r\n                    child_info.drill_id = DrillId::Child(vec![i].into_iter().collect());\r\n                    child_info\r\n                })\r\n            })\r\n            .collect_vec();\r\n\r\n        element_info.children = Some(children);\r\n    }\r\n\r\n    Ok(element_info)\r\n}\r\n\r\npub fn update_drill_ids(children: Option<&mut Vec<ElementInfo>>, ancestor_path: &DrillId) {\r\n    if let Some(children) = children {\r\n        for child_info in children.iter_mut() {\r\n            // Check if the child has a base drill_id set\r\n            if let DrillId::Child(base_drill_id) = &child_info.drill_id {\r\n                let mut new_path = ancestor_path.clone();\r\n                if let Some(&child_position) = base_drill_id.back() {\r\n                    new_path = match new_path {\r\n                        DrillId::Root | DrillId::Unknown => {\r\n                            DrillId::Child(vec![child_position].into())\r\n                        }\r\n                        DrillId::Child(ref mut path) => {\r\n                            let mut new_path = path.clone();\r\n                            new_path.push_back(child_position);\r\n                            DrillId::Child(new_path)\r\n                        }\r\n                    };\r\n\r\n                    // Update the child's drill_id by concatenating the ancestor_path with its own position\r\n                    child_info.drill_id = new_path.clone();\r\n                }\r\n\r\n                // Recursively update this child's children\r\n                update_drill_ids(child_info.children.as_mut(), &new_path);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\npub fn gather_single_element_info(element: &UIElement) -> Result<ElementInfo, uiautomation::Error> {\r\n    let name = element.get_name()?;\r\n    let bb = element.get_bounding_rectangle()?;\r\n    let class_name = element.get_classname()?;\r\n    let control_type = element.get_control_type()?.into();\r\n    let localized_control_type = element.get_localized_control_type()?;\r\n    let automation_id = element.get_automation_id()?;\r\n    let runtime_id = element.get_runtime_id()?;\r\n\r\n    let info = ElementInfo {\r\n        name,\r\n        bounding_rect: Rect::new(\r\n            bb.get_left() as f32,\r\n            bb.get_top() as f32,\r\n            bb.get_right() as f32,\r\n            bb.get_bottom() as f32,\r\n        ),\r\n        control_type,\r\n        localized_control_type,\r\n        class_name,\r\n        automation_id,\r\n        runtime_id,\r\n        children: None,\r\n        drill_id: DrillId::Unknown,\r\n    };\r\n    Ok(info)\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n    use uiautomation::UIAutomation;\r\n\r\n    /// Discord doesn't play nice with new UIAutomaion\r\n    ///\r\n    /// Element children aren't shown like they are in the MSAA tree\r\n    #[test]\r\n    fn test_gather_discord_element_info() {\r\n        let automation = UIAutomation::new().unwrap();\r\n        let walker = automation.create_tree_walker().unwrap();\r\n        let start = automation\r\n            .element_from_point(uiautomation::types::Point::new(2359, 959))\r\n            .unwrap();\r\n        println!(\"start {:#?}\", start);\r\n        let info = gather_single_element_info(&start).unwrap();\r\n        println!(\"info {:#?}\", info);\r\n\r\n        // let parent = walker.get_parent(&start).unwrap();\r\n        // let parent_info = gather_single_element_info(&parent).unwrap();\r\n        // println!(\"parent_info {:#?}\", parent_info);\r\n\r\n        let ancestors = collect_ancestors(&start, &walker).unwrap();\r\n        println!(\"got {} ancestors\", ancestors.len());\r\n        // println!(\"ancestors {:#?}\", ancestors);\r\n        for ancestor in ancestors.iter().skip(1) {\r\n            print!(\r\n                \"ancestor {:?} (runtimeid={:?})\\t\",\r\n                ancestor,\r\n                ancestor.get_runtime_id()\r\n            );\r\n            for behaviour in vec![\r\n                StopBehaviour::EndOfSiblings,\r\n                // StopBehaviour::LastChildEncountered,\r\n                // StopBehaviour::TaskbarEndEncountered,\r\n                // StopBehaviour::RootEndEncountered,\r\n            ] {\r\n                let children = ancestor\r\n                    .gather_children(&walker, &behaviour)\r\n                    .into_iter()\r\n                    .map(|child| gather_single_element_info(&child).unwrap())\r\n                    .collect::<Vec<_>>();\r\n                if children.is_empty() {\r\n                    eprintln!(\"No children found using {:?}\", behaviour);\r\n                }\r\n                println!(\"children using {:?} {:#?}\", behaviour, children.len());\r\n            }\r\n        }\r\n\r\n        let gathered = gather_incomplete_ui_tree_starting_deep(start).unwrap();\r\n        // println!(\"tree {:#?}\", gathered.ui_tree);\r\n    }\r\n}\r\n\r\n#ENDREGION\r\n\r\n\r\n#REGION crates/ui_automation/src/gather_root_children.rs\r\nuse std::collections::VecDeque;\r\n\r\nuse uiautomation::UIAutomation;\r\nuse uiautomation::UIElement;\r\nuse uiautomation::UITreeWalker;\r\n\r\nuse crate::gather_children::gather_children;\r\nuse crate::gather_children::StopBehaviour;\r\n\r\npub fn gather_root_children(\r\n    automation: &UIAutomation,\r\n    walker: &UITreeWalker,\r\n) -> Result<VecDeque<UIElement>, uiautomation::Error> {\r\n    let root = automation.get_root_element()?;\r\n    // println!(\"Boutta gather top level children\");\r\n    let top_level_children = gather_children(walker, &root, &StopBehaviour::RootEndEncountered);\r\n    // let condition = &automation.create_true_condition()?;\r\n    // let found = root.find_all(TreeScope::Children, condition)?;\r\n    // println!(\"Found {} top level children\", top_level_children.len());\r\n    Ok(top_level_children)\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n    use uiautomation::UIAutomation;\r\n\r\n    #[test]\r\n    fn test_gather_root_children() {\r\n        let automation = UIAutomation::new().unwrap();\r\n        let walker = automation.create_tree_walker().unwrap();\r\n        for _ in 0..100 {\r\n            let start = std::time::Instant::now();\r\n            let children = gather_root_children(&automation, &walker).unwrap();\r\n            let end = std::time::Instant::now();\r\n            let elapsed = end - start;\r\n            println!(\"Gathered {} children in {:?}\", children.len(), elapsed);\r\n            assert!(!children.is_empty());\r\n            assert!(elapsed.as_millis() < 1000);\r\n        }\r\n    }\r\n}\r\n\r\n#ENDREGION\r\n\r\n\r\n#REGION crates/ui_automation/src/lib.rs\r\nmod elements_at_point;\r\nmod formatting;\r\nmod gather_children;\r\nmod gather_element_info;\r\nmod gather_root_children;\r\nmod resolve_app;\r\nmod resolve_vscode;\r\nmod take_snapshot;\r\nmod taskbar;\r\nmod ui_automation_plugin;\r\nmod resolve_calculator;\r\n\r\npub mod prelude {\r\n    pub use crate::elements_at_point::*;\r\n    pub use crate::formatting::*;\r\n    pub use crate::gather_element_info::*;\r\n    pub use crate::take_snapshot::*;\r\n    pub use crate::taskbar::*;\r\n    pub use crate::ui_automation_plugin::*;\r\n    pub use crate::gather_children::*;\r\n    pub use cursor_hero_ui_automation_types::prelude::*;\r\n}\r\n\r\n#ENDREGION\r\n\r\n\r\n#REGION crates/ui_automation/src/resolve_app.rs\r\nuse cursor_hero_ui_automation_types::prelude::*;\r\nuse uiautomation::controls::ControlType;\r\nuse uiautomation::UIAutomation;\r\nuse uiautomation::UIElement;\r\n\r\nuse crate::resolve_calculator::resolve_calculator;\r\nuse crate::resolve_vscode::resolve_vscode;\r\n\r\npub(crate) fn resolve_app(\r\n    elem: &UIElement,\r\n    automation: &UIAutomation,\r\n    focused: bool,\r\n) -> Result<AppWindow, AppResolveError> {\r\n    match (\r\n        elem.get_name(),\r\n        elem.get_control_type(),\r\n        elem.get_classname(),\r\n    ) {\r\n        (Ok(name), Ok(ControlType::Pane), Ok(class_name))\r\n            if name.ends_with(\"Visual Studio Code\") && class_name == \"Chrome_WidgetWin_1\" =>\r\n        {\r\n            resolve_vscode(elem, automation, focused)\r\n        }\r\n        (Ok(name), Ok(ControlType::Window), Ok(class_name))\r\n            if name == \"Calculator\" && class_name == \"ApplicationFrameWindow\" =>\r\n        {\r\n            resolve_calculator(elem, automation, focused)\r\n        }\r\n        _ => Err(AppResolveError::NoMatch),\r\n    }\r\n}\r\n\r\n#ENDREGION\r\n\r\n\r\n#REGION crates/ui_automation/src/resolve_calculator.rs\r\nuse bevy::math::IVec2;\r\nuse cursor_hero_ui_automation_types::prelude::*;\r\nuse itertools::Itertools;\r\nuse uiautomation::controls::ControlType;\r\nuse uiautomation::patterns::UIExpandCollapsePattern;\r\nuse uiautomation::types::ExpandCollapseState;\r\nuse uiautomation::types::TreeScope;\r\nuse uiautomation::types::UIProperty;\r\nuse uiautomation::variants::Variant;\r\nuse uiautomation::UIAutomation;\r\nuse uiautomation::UIElement;\r\nuse uiautomation::UITreeWalker;\r\n\r\nuse crate::gather_children::gather_children;\r\nuse crate::gather_children::GatherChildrenable;\r\nuse crate::gather_children::StopBehaviour;\r\n\r\npub(crate) fn resolve_calculator(\r\n    elem: &UIElement,\r\n    automation: &UIAutomation,\r\n    focused: bool,\r\n) -> Result<AppWindow, AppResolveError> {\r\n    // let walker = automation.create_tree_walker()?;\r\n    // let root = elem;\r\n\r\n    // let temp = root.drill(&walker, vec![0, 0, 0, 0, 0, 1])?;\r\n\r\n    // let body = temp.drill(&walker, vec![1, 0, 1])?;\r\n    // let body = resolve_body(&body, &walker)?;\r\n\r\n    Ok(AppWindow::Calculator(Calculator {\r\n        memory: CalculatorMemory { buffer: 0.0 },\r\n    }))\r\n}\r\n\r\nfn resolve_body(\r\n    body: &UIElement,\r\n    walker: &UITreeWalker,\r\n) -> Result<VSCodeWindowBody, AppResolveError> {\r\n    let state =\r\n        VSCodeCrawlState::try_from(gather_children(walker, body, &StopBehaviour::EndOfSiblings))?;\r\n\r\n    let side_nav = state\r\n        .get_side_nav_tabs_root_elem()?\r\n        .drill(walker, vec![0, 0])?\r\n        .gather_children(walker, &StopBehaviour::LastChildEncountered);\r\n    // println!(\"side_nav: {:?}\", side_nav);\r\n    let side_nav = side_nav\r\n        .into_iter()\r\n        .filter(|elem| elem.get_control_type() == Ok(ControlType::TabItem))\r\n        .map(|elem| {\r\n            let name = elem.get_name()?;\r\n            let kind = SideTabKind::try_from(name)?;\r\n            let active = elem\r\n                .get_property_value(UIProperty::ExpandCollapseExpandCollapseState)\r\n                .map(|v| v.try_into() == Ok(ExpandCollapseState::Expanded as i32))\r\n                .unwrap_or_default();\r\n            if active {\r\n                let view = state\r\n                    .get_side_nav_view_root_elem()?\r\n                    .drill(walker, vec![1])?;\r\n                let view = match view.get_automation_id() {\r\n                    Ok(id)\r\n                        if Some(id.as_str()) == SideTabKind::Explorer.get_view_automation_id() =>\r\n                    {\r\n                        fn as_explorer_item(\r\n                            walker: &UITreeWalker,\r\n                            tree_item: UIElement,\r\n                        ) -> Result<ExplorerItem, AppResolveError> {\r\n                            let label = tree_item.get_name()?;\r\n                            let ui_position_in_set = tree_item\r\n                                .get_property_value(UIProperty::PositionInSet)?\r\n                                .try_into()?;\r\n                            let ui_size_of_set = tree_item\r\n                                .get_property_value(UIProperty::SizeOfSet)?\r\n                                .try_into()?;\r\n                            let ui_level = tree_item\r\n                                .get_property_value(UIProperty::Level)?\r\n                                .try_into()?;\r\n                            let bounds = tree_item.get_bounding_rectangle()?.to_bevy_irect();\r\n                            let kind = tree_item\r\n                                .get_pattern::<UIExpandCollapsePattern>()\r\n                                .ok()\r\n                                .map(|p| ExplorerItemKind::Directory {\r\n                                    expanded: p.get_state() == Ok(ExpandCollapseState::Expanded),\r\n                                })\r\n                                .unwrap_or(ExplorerItemKind::File);\r\n                            let path = tree_item\r\n                                .drill(\r\n                                    walker,\r\n                                    match kind {\r\n                                        ExplorerItemKind::File => vec![0, 1, 0],\r\n                                        ExplorerItemKind::Directory { .. } => {\r\n                                            vec![0, 2, 0]\r\n                                        }\r\n                                    },\r\n                                )?\r\n                                .get_name()?;\r\n                            Ok(ExplorerItem {\r\n                                label,\r\n                                path,\r\n                                ui_position_in_set,\r\n                                ui_size_of_set,\r\n                                ui_level,\r\n                                bounds,\r\n                                kind,\r\n                            })\r\n                        }\r\n                        let sticky = view\r\n                            .drill(walker, vec![0, 1, 0, 0, 1, 0, 3])?\r\n                            .gather_children(walker, &StopBehaviour::EndOfSiblings)\r\n                            .into_iter()\r\n                            .filter_map(|tree_item| as_explorer_item(walker, tree_item).ok())\r\n                            .collect();\r\n                        let items = view\r\n                            .drill(walker, vec![0, 1, 0, 0, 1, 0, 0])?\r\n                            .gather_children(walker, &StopBehaviour::EndOfSiblings)\r\n                            .into_iter()\r\n                            .filter_map(|tree_item| as_explorer_item(walker, tree_item).ok())\r\n                            .collect();\r\n                        View::Explorer { sticky, items }\r\n                    }\r\n                    _ => {\r\n                        View::Unknown {}\r\n                        // elem: view.into()\r\n                    }\r\n                };\r\n\r\n                Ok(SideTab::Open {\r\n                    kind,\r\n                    // button: elem.into(),\r\n                    view,\r\n                })\r\n            } else {\r\n                Ok(SideTab::Closed {\r\n                    kind,\r\n                    // button: elem.into(),\r\n                })\r\n            }\r\n        })\r\n        .filter_map(|res: Result<SideTab, AppResolveError>| res.ok())\r\n        .collect();\r\n\r\n    let editor_area_elem = state\r\n        .get_editor_root_elem()?\r\n        .drill(walker, vec![0, 1, 0, 0])?;\r\n    if editor_area_elem.get_automation_id()? != EditorArea::get_expected_automation_id() {\r\n        return Err(AppResolveError::BadVSCodeStructure(format!(\r\n            \"Editor area has wrong automation id: {}\",\r\n            editor_area_elem.get_automation_id()?\r\n        )));\r\n    }\r\n    let editor_groups = editor_area_elem\r\n        .drill(walker, vec![0, 0, 0, 1])?\r\n        .gather_children(walker, &StopBehaviour::EndOfSiblings)\r\n        .into_iter()\r\n        .map(|group_elem| {\r\n            let group_tabs_holder = group_elem.drill(walker, vec![0, 0, 0])?;\r\n            let selected: Option<String> = group_tabs_holder\r\n                .get_property_value(UIProperty::SelectionSelection)?\r\n                .try_into()\r\n                .ok();\r\n            let group_tabs = group_tabs_holder\r\n                .gather_children(walker, &StopBehaviour::EndOfSiblings)\r\n                .into_iter()\r\n                .map(|group_tab_elem| {\r\n                    let title = group_tab_elem.get_name()?;\r\n                    let active = selected == Some(title.clone());\r\n                    Ok(EditorTab { title, active })\r\n                })\r\n                .filter_map(|r: Result<EditorTab, AppResolveError>| r.ok())\r\n                .collect();\r\n            let content_elem = group_elem.drill(walker, vec![1, 0, 0, 1])?;\r\n            let content = content_elem\r\n                .get_property_value(UIProperty::LegacyIAccessibleValue)\r\n                .map(|variant| variant.to_string())\r\n                .map(|text_content| EditorContent {\r\n                    content: text_content,\r\n                })\r\n                .ok();\r\n\r\n            Ok(EditorGroup {\r\n                tabs: group_tabs,\r\n                content,\r\n            })\r\n        })\r\n        .filter_map(|r: Result<EditorGroup, AppResolveError>| r.ok())\r\n        .collect();\r\n    let editor_area = EditorArea {\r\n        groups: editor_groups,\r\n    };\r\n\r\n    Ok(VSCodeWindowBody {\r\n        editor_area,\r\n        side_nav,\r\n    })\r\n}\r\n\r\nfn resolve_footer(\r\n    footer: &UIElement,\r\n    automation: &UIAutomation,\r\n) -> Result<VSCodeWindowFooter, AppResolveError> {\r\n    let condition = automation.create_property_condition(\r\n        UIProperty::AutomationId,\r\n        Variant::from(\"status.editor.selection\"),\r\n        None,\r\n    )?;\r\n    let cursor_position_elem = footer.find_first(TreeScope::Children, &condition)?;\r\n    let text = cursor_position_elem.get_name()?;\r\n    // \"Ln 218, Col 5\"\r\n    let cursor_position = text\r\n        .split(\", \")\r\n        .map(|part| part.split(' ').last().and_then(|s| s.parse::<usize>().ok()))\r\n        .collect_vec();\r\n    let cursor_position = match cursor_position.as_slice() {\r\n        [Some(line), Some(column)] => IVec2::new(*column as i32, *line as i32),\r\n        _ => {\r\n            return Err(AppResolveError::BadVSCodeStructure(format!(\r\n                \"Bad cursor position {:?}\",\r\n                cursor_position\r\n            )))\r\n        }\r\n    };\r\n    Ok(VSCodeWindowFooter { cursor_position })\r\n}\r\n\r\n#ENDREGION\r\n\r\n\r\n#REGION crates/ui_automation/src/resolve_vscode.rs\r\nuse bevy::math::IVec2;\r\nuse cursor_hero_ui_automation_types::prelude::*;\r\nuse itertools::Itertools;\r\nuse uiautomation::controls::ControlType;\r\nuse uiautomation::patterns::UIExpandCollapsePattern;\r\nuse uiautomation::types::ExpandCollapseState;\r\nuse uiautomation::types::TreeScope;\r\nuse uiautomation::types::UIProperty;\r\nuse uiautomation::variants::Variant;\r\nuse uiautomation::UIAutomation;\r\nuse uiautomation::UIElement;\r\nuse uiautomation::UITreeWalker;\r\n\r\nuse crate::gather_children::gather_children;\r\nuse crate::gather_children::GatherChildrenable;\r\nuse crate::gather_children::StopBehaviour;\r\n\r\npub(crate) fn resolve_vscode(\r\n    elem: &UIElement,\r\n    automation: &UIAutomation,\r\n    focused: bool,\r\n) -> Result<AppWindow, AppResolveError> {\r\n    let walker = automation.create_tree_walker()?;\r\n    let root = elem;\r\n\r\n    let temp = root.drill(&walker, vec![0, 0, 0, 0, 0, 1])?;\r\n\r\n    let body = temp.drill(&walker, vec![1, 0, 1])?;\r\n    let body = resolve_body(&body, &walker)?;\r\n\r\n    let footer = temp.drill(&walker, vec![2, 0])?;\r\n    let footer = resolve_footer(&footer, automation)?;\r\n    drop(temp);\r\n\r\n    Ok(AppWindow::VSCode(VSCodeWindow {\r\n        focused,\r\n        header: VSCodeWindowHeader {},\r\n        body,\r\n        footer,\r\n    }))\r\n}\r\n\r\nfn resolve_body(\r\n    body: &UIElement,\r\n    walker: &UITreeWalker,\r\n) -> Result<VSCodeWindowBody, AppResolveError> {\r\n    let state =\r\n        VSCodeCrawlState::try_from(gather_children(walker, body, &StopBehaviour::EndOfSiblings))?;\r\n\r\n    let side_nav = state\r\n        .get_side_nav_tabs_root_elem()?\r\n        .drill(walker, vec![0, 0])?\r\n        .gather_children(walker, &StopBehaviour::LastChildEncountered);\r\n    // println!(\"side_nav: {:?}\", side_nav);\r\n    let side_nav = side_nav\r\n        .into_iter()\r\n        .filter(|elem| elem.get_control_type() == Ok(ControlType::TabItem))\r\n        .map(|elem| {\r\n            let name = elem.get_name()?;\r\n            let kind = SideTabKind::try_from(name)?;\r\n            let active = elem\r\n                .get_property_value(UIProperty::ExpandCollapseExpandCollapseState)\r\n                .map(|v| v.try_into() == Ok(ExpandCollapseState::Expanded as i32))\r\n                .unwrap_or_default();\r\n            if active {\r\n                let view = state\r\n                    .get_side_nav_view_root_elem()?\r\n                    .drill(walker, vec![1])?;\r\n                let view = match view.get_automation_id() {\r\n                    Ok(id)\r\n                        if Some(id.as_str()) == SideTabKind::Explorer.get_view_automation_id() =>\r\n                    {\r\n                        fn as_explorer_item(\r\n                            walker: &UITreeWalker,\r\n                            tree_item: UIElement,\r\n                        ) -> Result<ExplorerItem, AppResolveError> {\r\n                            let label = tree_item.get_name()?;\r\n                            let ui_position_in_set = tree_item\r\n                                .get_property_value(UIProperty::PositionInSet)?\r\n                                .try_into()?;\r\n                            let ui_size_of_set = tree_item\r\n                                .get_property_value(UIProperty::SizeOfSet)?\r\n                                .try_into()?;\r\n                            let ui_level = tree_item\r\n                                .get_property_value(UIProperty::Level)?\r\n                                .try_into()?;\r\n                            let bounds = tree_item.get_bounding_rectangle()?.to_bevy_irect();\r\n                            let kind = tree_item\r\n                                .get_pattern::<UIExpandCollapsePattern>()\r\n                                .ok()\r\n                                .map(|p| ExplorerItemKind::Directory {\r\n                                    expanded: p.get_state() == Ok(ExpandCollapseState::Expanded),\r\n                                })\r\n                                .unwrap_or(ExplorerItemKind::File);\r\n                            let path = tree_item\r\n                                .drill(\r\n                                    walker,\r\n                                    match kind {\r\n                                        ExplorerItemKind::File => vec![0, 1, 0],\r\n                                        ExplorerItemKind::Directory { .. } => {\r\n                                            vec![0, 2, 0]\r\n                                        }\r\n                                    },\r\n                                )?\r\n                                .get_name()?;\r\n                            Ok(ExplorerItem {\r\n                                label,\r\n                                path,\r\n                                ui_position_in_set,\r\n                                ui_size_of_set,\r\n                                ui_level,\r\n                                bounds,\r\n                                kind,\r\n                            })\r\n                        }\r\n                        let sticky = view\r\n                            .drill(walker, vec![0, 1, 0, 0, 1, 0, 3])?\r\n                            .gather_children(walker, &StopBehaviour::EndOfSiblings)\r\n                            .into_iter()\r\n                            .filter_map(|tree_item| as_explorer_item(walker, tree_item).ok())\r\n                            .collect();\r\n                        let items = view\r\n                            .drill(walker, vec![0, 1, 0, 0, 1, 0, 0])?\r\n                            .gather_children(walker, &StopBehaviour::EndOfSiblings)\r\n                            .into_iter()\r\n                            .filter_map(|tree_item| as_explorer_item(walker, tree_item).ok())\r\n                            .collect();\r\n                        View::Explorer { sticky, items }\r\n                    }\r\n                    _ => {\r\n                        View::Unknown {}\r\n                        // elem: view.into()\r\n                    }\r\n                };\r\n\r\n                Ok(SideTab::Open {\r\n                    kind,\r\n                    // button: elem.into(),\r\n                    view,\r\n                })\r\n            } else {\r\n                Ok(SideTab::Closed {\r\n                    kind,\r\n                    // button: elem.into(),\r\n                })\r\n            }\r\n        })\r\n        .filter_map(|res: Result<SideTab, AppResolveError>| res.ok())\r\n        .collect();\r\n\r\n    let editor_area_elem = state\r\n        .get_editor_root_elem()?\r\n        .drill(walker, vec![0, 1, 0, 0])?;\r\n    if editor_area_elem.get_automation_id()? != EditorArea::get_expected_automation_id() {\r\n        return Err(AppResolveError::BadVSCodeStructure(format!(\r\n            \"Editor area has wrong automation id: {}\",\r\n            editor_area_elem.get_automation_id()?\r\n        )));\r\n    }\r\n    let editor_groups = editor_area_elem\r\n        .drill(walker, vec![0, 0, 0, 1])?\r\n        .gather_children(walker, &StopBehaviour::EndOfSiblings)\r\n        .into_iter()\r\n        .map(|group_elem| {\r\n            let group_tabs_holder = group_elem.drill(walker, vec![0, 0, 0])?;\r\n            let selected: Option<String> = group_tabs_holder\r\n                .get_property_value(UIProperty::SelectionSelection)?\r\n                .try_into()\r\n                .ok();\r\n            let group_tabs = group_tabs_holder\r\n                .gather_children(walker, &StopBehaviour::EndOfSiblings)\r\n                .into_iter()\r\n                .map(|group_tab_elem| {\r\n                    let title = group_tab_elem.get_name()?;\r\n                    let active = selected == Some(title.clone());\r\n                    Ok(EditorTab { title, active })\r\n                })\r\n                .filter_map(|r: Result<EditorTab, AppResolveError>| r.ok())\r\n                .collect();\r\n            let content_elem = group_elem.drill(walker, vec![1, 0, 0, 1])?;\r\n            let content = content_elem\r\n                .get_property_value(UIProperty::LegacyIAccessibleValue)\r\n                .map(|variant| variant.to_string())\r\n                .map(|text_content| EditorContent {\r\n                    content: text_content,\r\n                })\r\n                .ok();\r\n\r\n            Ok(EditorGroup {\r\n                tabs: group_tabs,\r\n                content,\r\n            })\r\n        })\r\n        .filter_map(|r: Result<EditorGroup, AppResolveError>| r.ok())\r\n        .collect();\r\n    let editor_area = EditorArea {\r\n        groups: editor_groups,\r\n    };\r\n\r\n    Ok(VSCodeWindowBody {\r\n        editor_area,\r\n        side_nav,\r\n    })\r\n}\r\n\r\nfn resolve_footer(\r\n    footer: &UIElement,\r\n    automation: &UIAutomation,\r\n) -> Result<VSCodeWindowFooter, AppResolveError> {\r\n    let condition = automation.create_property_condition(\r\n        UIProperty::AutomationId,\r\n        Variant::from(\"status.editor.selection\"),\r\n        None,\r\n    )?;\r\n    let cursor_position_elem = footer.find_first(TreeScope::Children, &condition)?;\r\n    let text = cursor_position_elem.get_name()?;\r\n    // \"Ln 218, Col 5\"\r\n    let cursor_position = text\r\n        .split(\", \")\r\n        .map(|part| part.split(' ').last().and_then(|s| s.parse::<usize>().ok()))\r\n        .collect_vec();\r\n    let cursor_position = match cursor_position.as_slice() {\r\n        [Some(line), Some(column)] => IVec2::new(*column as i32, *line as i32),\r\n        _ => {\r\n            return Err(AppResolveError::BadVSCodeStructure(format!(\r\n                \"Bad cursor position {:?}\",\r\n                cursor_position\r\n            )))\r\n        }\r\n    };\r\n    Ok(VSCodeWindowFooter { cursor_position })\r\n}\r\n\r\n#ENDREGION\r\n\r\n\r\n#REGION crates/ui_automation/src/take_snapshot.rs\r\nuse crate::gather_root_children::gather_root_children;\r\nuse crate::resolve_app::resolve_app;\r\nuse cursor_hero_ui_automation_types::prelude::*;\r\nuse itertools::Itertools;\r\nuse uiautomation::UIAutomation;\r\n\r\npub fn take_snapshot() -> Result<UISnapshot, GatherAppsError> {\r\n    let automation = UIAutomation::new()?;\r\n    let walker = automation.create_tree_walker()?;\r\n    // let walker = automation.get_raw_view_walker()?;\r\n    let top_level_children = gather_root_children(&automation, &walker)?;\r\n\r\n    let focused = automation.get_focused_element()?;\r\n    let focused_app = walker.normalize(&focused)?;\r\n\r\n    let mut apps = vec![];\r\n    let mut errors = vec![];\r\n    for elem in top_level_children {\r\n        let focused = elem.get_runtime_id() == focused_app.get_runtime_id();\r\n        match resolve_app(&elem, &automation, focused) {\r\n            Ok(app) => {\r\n                apps.push((elem, app));\r\n            }\r\n            Err(e) => errors.push(e),\r\n        }\r\n    }\r\n    let bad_errors = errors\r\n        .into_iter()\r\n        // NoMatch errors aren't enough to fail the whole snapshot\r\n        .filter(|e| !matches!(e, AppResolveError::NoMatch))\r\n        .filter(|e| !matches!(e, AppResolveError::BadVSCodeStructure(_)))\r\n        .collect_vec();\r\n    if !bad_errors.is_empty() {\r\n        return Err(GatherAppsError::ResolveFailed(bad_errors));\r\n    }\r\n\r\n    let snapshot = UISnapshot {\r\n        app_windows: apps.into_iter().map(|(_elem, app)| app).collect(),\r\n    };\r\n    Ok(snapshot)\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use windows::Win32::System::Com::CoInitializeEx;\r\n    use windows::Win32::System::Com::COINIT_MULTITHREADED;\r\n\r\n    use crate::prelude::take_snapshot;\r\n\r\n    #[test]\r\n    fn test_take_snapshot() {\r\n        //todo: put this in thread initialzed for COM like below\r\n        let snapshot = take_snapshot().unwrap();\r\n        assert!(snapshot.app_windows.len() > 0);\r\n    }\r\n\r\n    #[test]\r\n    fn test_take_snapshot_many() {\r\n        let handle = std::thread::spawn(move || -> windows::core::Result<()> {\r\n            unsafe {\r\n                // Initialize COM in MTA mode\r\n                // https://learn.microsoft.com/en-us/windows/win32/com/multithreaded-apartments\r\n                CoInitializeEx(None, COINIT_MULTITHREADED)?;\r\n\r\n                println!(\"COM initialized in MTA mode.\");\r\n\r\n                for i in 0..100 {\r\n                    let start = std::time::Instant::now();\r\n                    let snapshot = take_snapshot().unwrap();\r\n                    assert!(snapshot.app_windows.len() > 0);\r\n                    if i == 0 {\r\n                        println!(\"{}\", snapshot);\r\n                    }\r\n                    let end = std::time::Instant::now();\r\n                    println!(\"time: {:?}\", end - start);\r\n                    assert!(end - start < std::time::Duration::from_secs(1));\r\n                }\r\n\r\n                Ok(())\r\n            }\r\n        });\r\n\r\n        // Wait for the thread to complete its tasks and handle any errors\r\n        let _ = handle.join().unwrap();\r\n    }\r\n}\r\n\r\n#ENDREGION\r\n\r\n\r\n#REGION crates/ui_automation/src/taskbar.rs\r\nuse crate::gather_children::gather_children;\r\nuse crate::gather_children::StopBehaviour;\r\nuse crate::prelude::*;\r\nuse uiautomation::controls::ControlType;\r\nuse uiautomation::UIAutomation;\r\n\r\npub fn get_taskbar() -> Result<Taskbar, uiautomation::Error> {\r\n    let automation = UIAutomation::new()?;\r\n    let root = automation.get_root_element()?;\r\n    let taskbar_matcher = automation\r\n        .create_matcher()\r\n        .from(root)\r\n        .classname(\"MSTaskListWClass\")\r\n        .control_type(ControlType::ToolBar);\r\n    let taskbar = taskbar_matcher.find_first()?;\r\n    let taskbar_entry_walker = automation.create_tree_walker()?;\r\n    let taskbar_entries = gather_children(\r\n        &taskbar_entry_walker,\r\n        &taskbar,\r\n        &StopBehaviour::TaskbarEndEncountered,\r\n    );\r\n    let entries = taskbar_entries\r\n        .into_iter()\r\n        .map(|entry| TaskbarEntry {\r\n            name: entry.get_name().unwrap_or_default(),\r\n            bounds: entry\r\n                .get_bounding_rectangle()\r\n                .unwrap_or_default()\r\n                .to_bevy_irect(),\r\n        })\r\n        .collect();\r\n    Ok(Taskbar { entries })\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use crate::prelude::get_taskbar;\r\n\r\n    #[test]\r\n    fn test_get_taskbar() {\r\n        let taskbar = get_taskbar().unwrap();\r\n        assert!(taskbar.entries.len() > 0);\r\n        // print the entries\r\n        for entry in taskbar.entries {\r\n            println!(\"entry: {:?}\", entry);\r\n        }\r\n    }\r\n}\r\n\r\n#ENDREGION\r\n\r\n\r\n#REGION crates/ui_automation/src/ui_automation_plugin.rs\r\nuse bevy::prelude::*;\r\n\r\npub struct UiAutomationPlugin;\r\n\r\nimpl Plugin for UiAutomationPlugin {\r\n    fn build(&self, _app: &mut App) {}\r\n}\r\n\r\n#ENDREGION\r\n\r\n\r\n#REGION crates/window_swap_tool/src/window_swap_tool_populate_plugin.rs\r\nuse bevy::prelude::*;\r\nuse cursor_hero_toolbelt_types::prelude::*;\r\nuse cursor_hero_tools::tool_spawning::ToolSpawnConfig;\r\nuse cursor_hero_window_swap_tool_types::prelude::*;\r\n\r\npub struct WindowSwapToolPopulatePlugin;\r\n\r\nimpl Plugin for WindowSwapToolPopulatePlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Update, handle_toolbelt_events);\r\n    }\r\n}\r\n\r\nfn handle_toolbelt_events(\r\n    mut commands: Commands,\r\n    asset_server: Res<AssetServer>,\r\n    mut reader: EventReader<ToolbeltPopulateEvent>,\r\n) {\r\n    for event in reader.read() {\r\n        let ToolbeltPopulateEvent {\r\n            loadout: ToolbeltLoadout::WindowPosition,\r\n            ..\r\n        } = event\r\n        else {\r\n            continue;\r\n        };\r\n        ToolSpawnConfig::<_, WindowSwapToolAction>::new(WindowSwapTool, event.id, event)\r\n            .with_src_path(file!().into())\r\n            .guess_name(file!())\r\n            .guess_image(file!(), &asset_server, \"webp\")\r\n            .with_description(\"Swap the positions of windows.\")\r\n            .spawn(&mut commands);\r\n    }\r\n}\r\n\r\n#ENDREGION\r\n\r\n\r\n#REGION crates/winutils/examples/app_icons_example.rs\r\nuse std::rc::Rc;\r\n\r\nuse bevy::utils::HashSet;\r\nuse cursor_hero_winutils::win_errors::*;\r\nuse cursor_hero_winutils::win_icons::get_images_from_exe;\r\nuse cursor_hero_winutils::win_process::*;\r\nuse windows::core::PWSTR;\r\nuse windows::Win32::Foundation::E_ACCESSDENIED;\r\n\r\nfn main() -> Result<()> {\r\n    unsafe {\r\n        let process_iter = ProcessIterator::new()?;\r\n        let mut done = HashSet::new();\r\n        for mut process in process_iter {\r\n            let exe_name_pwstr = PWSTR(process.szExeFile.as_mut_ptr());\r\n            let exe_name = exe_name_pwstr.to_string()?;\r\n            let exe_path = match get_process_full_name(process.th32ProcessID) {\r\n                Ok(s) => s,\r\n                Err(e) => {\r\n                    if matches!(\r\n                        e,\r\n                        Error::Windows(ref e) if e.code() == E_ACCESSDENIED\r\n                    ) {\r\n                        continue;\r\n                    }\r\n                    eprintln!(\r\n                        \"Failed to get full process name for PID {:05} ({}): {:?}\",\r\n                        process.th32ProcessID, exe_name, e\r\n                    );\r\n                    continue;\r\n                }\r\n            };\r\n            if done.contains(&exe_path) {\r\n                continue;\r\n            }\r\n            done.insert(exe_path.clone());\r\n            let icons = get_images_from_exe(exe_path.as_str())?;\r\n            println!(\r\n                \"Process ID: {:05}, name: {}, icon count: {}\",\r\n                process.th32ProcessID,\r\n                exe_name,\r\n                icons.len()\r\n            );\r\n\r\n            if icons.is_empty() {\r\n                continue;\r\n            }\r\n\r\n            // write the image to target/app_icons/{exe_name}/{icon_index}.png\r\n            let mut path = std::path::PathBuf::from(\"target/app_icons\");\r\n            path.push(exe_name);\r\n            std::fs::create_dir_all(&path).map_err(|e| Error::Other(Rc::new(e)))?;\r\n            for (i, icon) in icons.iter().enumerate() {\r\n                let mut icon_path = path.clone();\r\n                icon_path.push(format!(\"{}.png\", i));\r\n                icon.save(icon_path).map_err(|e| Error::Other(Rc::new(e)))?;\r\n            }\r\n        }\r\n    }\r\n    Ok(())\r\n}\r\n\r\n#ENDREGION\r\n\r\n\r\n#REGION README.md\r\n# Cursor Hero\r\n\r\n[![Visitors](https://api.visitorbadge.io/api/visitors?path=github.com%2FTeamDman%2FCursor-Hero&countColor=%23263759)](https://visitorbadge.io/status?path=github.com%2FTeamDman%2FCursor-Hero)\r\n\r\n## Video demo\r\n\r\n[![yt thumbnail](https://img.youtube.com/vi/t1PYks0UTL8/0.jpg)](https://youtu.be/t1PYks0UTL8)\r\n\r\n## Regarding DualShock controllers\r\n\r\nTry [DS4Windows](https://ds4windows.dev/).\r\n\r\n## Integrations\r\n\r\n- [TeamDman/voice2text: Local speech recognition](https://github.com/teamdman/voice2text)\r\n- [ollama/ollama: Local LLM inference](https://github.com/ollama/ollama)\r\n- [R2D2FISH/glados-tts: GLaDOS speech synthesis](https://github.com/TeamDman/glados-tts.git)\r\n\r\n## Project description\r\n\r\nCursor Hero is a thing built using Rust and the Bevy game engine.\r\n\r\nCursor Hero, when launched, presents you with a character that has a pointer. You can move the character and pointer independently using the mouse and keyboard, or using both sticks on a gamepad.\r\n\r\nIn the game world, you can see a scale representation of your monitors. I have three monitors, so when I launch the game I see the left, center, and right monitor, usually containing VSCode, Discord, and the Cursor Hero window itself.\r\n\r\nCursor Hero uses the `windows` crate to integrate tightly with the Windows operating system. It reads and writes the host cursor position, with integrations with the game to do things like position the host mouse \"cursor\" over the in-game \"pointer\", or updating the cursor so that it matches the game world position of the pointer, letting the player interact with the OS using the game representation of the screens.\r\n\r\nThis includes integrating with Windows UI automation to grab the locations of UI elements, copying the texture of the screen onto bricks in the game world that are physics objects.\r\n\r\nUI information is attached to the bricks, using `bevy-egui` to render UI elements with screen coordinates updated to correspond with world-coordinates of the bricks.\r\n\r\nUsing `egui`, the tree hierarchy of the UI is shown for the bricks created by clicking on UI elements in the screen texture. The tree could potentially grow to something like inspect.exe, where the properties of the UI element can be explored. Currently, the tree folding and selectable labels is working, but the properties panel on the right is not yet implemented.\r\n\r\nIn addition to showing the host environment, a game environment is also constructed. The game environment contains a virtual agent and a mimicry of the host OS. The mimicry extends to include a copy of the desktop background, a taskbar that pulls the colour from the OS preferences, and a start menu button that toggles visibility of an empty panel.\r\n\r\nThe virtual agent walks in circles. It has an observation buffer which other systems can publish events for something happening, and the buffer will conditionally append such events which are used in the construction of prompts for a local LLM ran using `ollama`.\r\n\r\nIn response to player chat messages, or in response to a period of inactivity, the agent will prompt the LLM in a chat format. With the response, it publishes its own chat message, and it invokes the `glados-tts` to speak the response to the player.\r\n\r\nThis agent behaviour, combined with integration to `voice2text`, allows the human to converse to the agent entirely locally using `whisper-x` to speak with the addition of a push-to-talk button and a toggle-active-listening button.\r\n\r\nGiven that the host cursor is being updated by the game pointer when in gamepad input mode, the game takes care to listen for raw mouse input events to determine when the player is trying to use mouse and keyboard input mode, avoiding holding the pointer captive since traditional input detection is not suitable. After all, if the pointer is programmatically controlled by the game, \"mouse moved events\" become less reliable when aiming for physical movement detection.\r\n\r\nAgain using the `windows` crate, the game is able to identify running processes and programmatically detect the exe path and extract the icons of the process from it.\r\nOpportunity exists to detect dynamic icons from process windows as well.\r\n\r\nThe game has a radial menu for enabling/disabling \"tools\", some of which start disabled and upon enabling will clear and repopulate the tools in the toolbelt with a different loadout.\r\n\r\nThe tool system has been used to show a radial menu of programs in the taskbar, using UI automation to grab the texture at the rect of each item to be displayed radially.\r\n\r\nThere is a tool loadout that lets you snap the game window to any corner or fullscreen of any monitors detected.\r\n\r\nThe default tool loadout starts you in click mode, letting you move your character and its pointer, with the ability to send click events to the OS, and to send click events to game objects using the ECS fundamentals. \r\n\r\nThe game has its own model system for the UI hierarchy, with support for detecting the details of running VSCode windows, including tabs on the left, open tab, contents of the explorer tab if open, editor groups open and involved tabs and file contents, current cursor line and position displayed in the bottom corner.\r\n\r\n## Where do we go from here\r\n\r\nI am continuously exploring many different trajectories for this project.\r\n\r\nSee [`./todo.md`](./todo.md) for brainstorming on potential features to add.\r\n\r\nSee [`./research_notes.md`](./research_notes.md) for links to internet resources that could be helpful.\r\n\r\n#ENDREGION\r\n\r\n\r\n#REGION templates/patterns/new_tool/crates/{{crate_name}}_tool/src/{{crate_name}}_tool_populate_plugin.rs\r\nuse bevy::prelude::*;\r\nuse cursor_hero_{{crate_name}}_tool_types::prelude::*;\r\nuse cursor_hero_toolbelt_types::prelude::*;\r\nuse cursor_hero_tools::tool_spawning::ToolSpawnConfig;\r\n\r\npub struct {{crate_name_pascal}}ToolPopulatePlugin;\r\n\r\nimpl Plugin for {{crate_name_pascal}}ToolPopulatePlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Update, handle_toolbelt_events);\r\n    }\r\n}\r\n\r\nfn handle_toolbelt_events(\r\n    mut commands: Commands,\r\n    asset_server: Res<AssetServer>,\r\n    mut reader: EventReader<PopulateToolbeltEvent>,\r\n) {\r\n    for event in reader.read() {\r\n        let PopulateToolbeltEvent {\r\n            loadout: ToolbeltLoadout::WindowPosition,\r\n            ..\r\n        } = event\r\n        else {\r\n            continue;\r\n        };\r\n        ToolSpawnConfig::<_, {{crate_name_pascal}}ToolAction>::new(\r\n            {{crate_name_pascal}}Tool::default(),\r\n            event.id,\r\n            event,\r\n        )\r\n        .with_src_path(file!().into())\r\n        .guess_name(file!())\r\n        .guess_image(file!(), &asset_server, \"webp\")\r\n        .with_description(\"REPLACE THIS DESCRIPTION!!!\")\r\n        .spawn(&mut commands);\r\n    }\r\n}\r\n\r\n#ENDREGION\r\n\r\n\r\nAbove is the source code of some parts of the Cursor Hero project.\r\nI am working on the ui_hover_example thing right now\r\n\r\ncargo run -p cursor_hero_ui_automation --example ui_hover_example\r\n\r\nand now I want to create a calculator example that will use similar principals to enumerate the calculator windows\r\nand will update the calculator components in the ECS to match.\r\n\r\nLets treat the sync operation as a clear-then-create type thing\r\nWhen we receive the snapshot containing calculators, we will despawn_recursive all Query<(Entity, &Calculator)> then\r\nuse mut commands to spawn new ones with screens displaying the values according to the ones in the snapshot.\r\nFor now, focus just on the number display and don't add any buttons yet.\r\nWe will have a parent Calculator SpriteBundle that will act as the background,\r\nthen the text will be created within as the NumberDisplayPanel component entity.\r\n\r\nThe calculator spritebundle will have a set custom size, we will have fixed dimensions for the calculator\r\nthis will be used to offset by width + margin when spawning multiple\r\n\r\nPropose the modifications to be made to calculator_example.rs to proceed.\r\n",
    "file_url": null,
    "file_mimetype": null
}