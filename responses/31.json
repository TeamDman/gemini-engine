{
    "payload": {
        "prompt": "C:\\Users\\TeamD\\OneDrive\\Documents\\Ideas\\2024-04-01.md\r\nD:\\Repos\\Games\\Cursor-Hero\r\nD:\\Repos\\ml\\gemini-engine\r\n\r\n# Summary\r\n\r\n\r\n## C:\\Users\\TeamD\\OneDrive\\Documents\\Ideas\\2024-04-01.md\r\n\r\n````markdown\r\nFROM GOOGLE KEEP note titled \"Jonathan blow\"\r\n\r\n[https://youtu.be/uZgbKrDEzAs](https://youtu.be/uZgbKrDEzAs)  \r\n  \r\nTalking about having enthusiasm for Vulcan killed because of the prospect of learning an ecosystem.  \r\n  \r\nYou don't need to learn an ecosystem, you need to map your existing knowledge onto what's available.  \r\n  \r\nSyntax highlighting.  \r\nJump to symbol definition  \r\nList symbol usages  \r\nRename symbol  \r\nHow to have code depend on other code  \r\n  \r\nTools like treesitter, language servers, IDEs help accomplish these goals, but each thing is really a tiny problem that gets bundled to other tools as an implementation detail.  \r\n  \r\nAsking what line:column a symbols definition comes from is a question that depends on the file and the location of the symbol. It may be imported, Renamed, copied, moved.  \r\nThe dependency graph for a definition to its usages isn't a 1 hop process.  \r\n  \r\nIf i want to know the answer to a question, I must make sure the language server is running. Then the language server has to build an index. Why is this done every time I open vscode? Every time I add a dependency?  \r\n  \r\nThere is room for improvement. Graceful degredation.  \r\n  \r\n  \r\nQuality of life.  \r\nIf this is ranked #1 priority, then rust is a win even if it is leaving performance on the table.  \r\nIf my program compiles, then it is going to mostly work; whereas in other languages I don't have this guarantee.  \r\n  \r\nErrors as values is the core of this because it brings to the front all the situations in which a crash could occur and gives you the responsibility of handling them.  \r\n  \r\nWith Rust, some code panics.  \r\nYou may depend on a library which panics in some situation.  \r\n  \r\nBevy has a dot single method that panics, and a get_single method that returns an option.  \r\n  \r\nUsing unwrap in your code is folly. You should not share code that uses unwrap or panic, lest it be copied by some process that trims the context of why the panic is okay.  \r\n  \r\nLintet options for no unsafe and no unwrap and no panic?  \r\n  \r\n  \r\n1h3m in  \r\nLinguistic expression  \r\nHelldivers 2 stratagems have directional code  \r\nMagicka 2 has elemental combinations to create spells  \r\nI'm working on an engine for decision making with ECS footings and llm integration intended.  \r\nTo design new components and the details of how they combine in a system, you need an understanding of the system.  \r\nIf to order a 500gk eagle strike you had to hit a button to pull out a phone, and enter a phone number to dial them, that would be a test of you entering phone numbers accurately.  \r\nI want to quickly make decisions in a high dimensional environment with my understandings in alignment for what is possible within the system.  \r\n  \r\nIf I build a world simulator that considers a scene of components and can describe how they should transform over time, then that can be abstracted in code to make consistent the applications of those state transitions.  \r\n  \r\nA radial menu of autosuggested actions you could take. Aimbots for real life decision making.  \r\n  \r\nIts faster to pick an answer by pressing one button than it is to pick a course of action by pressing many buttons to type out a response instead of picking a suggested one.  \r\n  \r\nWhat are the reasons to pick actions outside of the suggested?  \r\n  \r\nHow easily can you pick the right answer from the list of possible answers.  \r\nHow well does the system assist you.  \r\n  \r\n===  \r\non desktop now.  \r\nhave discord and am just typing in the google note fullscreened with all windows minimized but this one.  \r\n  \r\nI used the windows file manager to search my videos folder for \"space\", which did not show the video I was thinking of in the first 15 results because I didn't bother to scroll.  \r\nI changed the search to \"time\", which quickly\r\n\r\n=== \r\n\r\nNow I am in Obsidian, which lets me more easily paste images into the content than keep and vscode do.\r\n\r\n![[SBl0qg717P.png]]![[msedge_c94Ol8PdId.png]]![[msedge_NTEBoXyVqX.png]]![[obs64_ST93rE6M7C.png]]![[obs64_c7lGsfP9dq.png]]![[obs64_snLDAGv6ZH.png]]![[obs64_8Z0tcqNYsB.png]]![[ShareX_ZRgR6XoO52.png]]![[obs64_Bu64q9nsxR.png]]![[obs64_94DqyMalHq.png]]![[obs64_2xQsK1fzFj.png]]\r\n\r\nThose are the screenshots I took, in the order that me dragging them into the window oldest to newest ordered them in this document.\r\n\r\nThis image sequences shows the starting state of me beginning to record those images.\r\nIt is a collection of images which can be ordered by the properties we know, including the order they were presumed to be taken.\r\n\r\nThis is not to be confused with the order in which they were copied without modification.\r\n\r\nI was working on Cursor Hero, my game, and I was watching a Jonathan Blow video whose link is included at the top.\r\n\r\nSentences like that give context to information which could be derived from given information with some assumptions like an internet connection.\r\nSometimes, though, information is lost or modified when you go to check the sources.\r\n\r\nMy own documents are an important representation, compared to downloading blog posts of others.\r\n\r\nThat data is significant in so far as it can be of utility to me, not because it has intrinsic value that could disagree with my own which affects what I want to achieve.\r\n\r\nIt's good to keep the information close together, but right now those pictures are being saved in my notes folder instead of being adjacent to the files which include them.\r\n\r\nBy operating from assumptions of a file system to create relationships, we force ourselves to a known good mapping of representation.\r\n\r\nIf a process becomes slow because it is creating 10,000 files, consider the intent of that process and see if it can be improved by compressing the information common to so many examples.\r\n\r\nJSON can summarize the contents of 100 text files by including a file path and a content line.\r\nThat gives you an easily deserializable representation that can then be further compressed in a general fashion by tools such as gzip.\r\n\r\nI would want my own system to be intelligent enough to maximize data redundancy by storing copies of an image in known locations until such a time arises where we require more storage, we can prioritize the freeing (compression) of our storage by the data that we have a risk tolerance for losing the data redundancy that having copies provided.\r\n\r\nIf I'm out of storage, I want to compress a steam game I haven't played in years to a tiny brick sooner than I compress my notes folder, which the loss of would be much greater.\r\n\r\nThe idea of Risk and the idea of data loss prevention (encompassing unauthorized disclosing of data) are related.\r\n\r\nEncrypting my files prevents situations where people have access to the contents of those files.\r\n\r\nThis can be desirable with content like passwords, which are used to ensure that a user issuing commands is a principal adhering to our known model of managing permissions and is granted access by a predicate we have decided gives us the most reward compared to other predicates we could chose to perform that decision making.\r\n\r\nThis can sound simple in a declarative situation, \"only my friends can see what games I'm playing\" but can turn into \"who are your friends\" \"what is a game\" and \"why\"\r\n\r\nI record this with the idea that I will remember having done so and will be able to find it later to make additional connections to serve some higher goal.\r\n\r\nIt is a tool in the mechanisms of how I operate and make decisions about what to work on.\r\n\r\nI have paused listening to the podcast to write this.\r\nThis discussion above is going in the direction of \"what steps do I need to do next to have a commit by the end of tonight that accomplishes a goal\"\r\n\r\nI will feed you the repository in question.\r\nI must decide on the order in which these pieces of information are arranged.\r\n\r\nAs I type I am in obsidian.\r\n\r\nBy the time this reaches the LLM it will have gone through a process that uploads the images by name which should correlate with what is in this document.\r\n\r\nI need to make the tool to convert this note into a comprehensive payload of text documents and images referenced by that text document.\r\n\r\nThis is a decision making problem that is performed manually very much at this stage.\r\n\r\nI could continue listening to the podcast\r\nI could continue typing\r\nI could do both.\r\n\r\nA next step would be to stop typing (which would prevent me from thing the rest of this)\r\nThis is a planning operation.\r\n\r\nNow, I must predict my course of action rather than document it as it happens.\r\nThis is a limitation of me having to type.\r\nExcept it's not because I could narrate what I'm doing.\r\nBut that introduces a step of performing transcription on my video.\r\nThat's something I've recently \"solved\" with the creation of a tool.\r\n\r\nA Swiss-army knife of tools for feeding content to you for a response.\r\n\r\nTo ask you to do the next part for me, I need to give a description of my understanding of the system.\r\n\r\nAlternatively, I rely on you to assume a default course of action given your existing assumptions about the data.\r\n\r\nI can expend effort to increase knowledge by providing a description.\r\n\r\nI must recognize when that step is no longer a manual one.\r\n\r\nTo be most efficient, I'd close my door and begin talking into the microphone.\r\n\r\nI'd have to record with OBS, and speak into the microphone, and play it back to validate that my microphone is working, and only then would I have satiated my desired level of risk for assuming that the recording is working.\r\n\r\nThese checks are very quick, but could be quicker.\r\n\r\nI control the directory that OBS writes to.\r\n\r\nI can describe a decision tree where to me \"start recording\" means \"perform these steps to launch software and perform obvious tests that don't take long to ensure the system is performing by expectations\"\r\n\r\nI have an agent waiting to make complex decisions.\r\n\r\nI am in the process of mapping a gameworld-calculator to an OS calculator.\r\n\r\nThe agent can interact with the game and have their actions relayed in the OS to the level of clicking on named UI elements.\r\n\r\nThe current effort on the project is being expended creating a relational mapping from UIAutomation trees to a known representation.\r\n\r\nInspect.exe does a great job and we are taking features from it to construct our own tool better suited to our needs.\r\n\r\nI have showed how the tool works in videos.\r\n\r\nI recently took a video on the state of the tool, Cursor Hero, which is open sourced, as most are all of my projects.\r\n\r\nI also recently took a video on the gemini-engine repo I am working on, which demonstrates the process I use to pass information to a LLM hosted by an external service because it has a longer context window than the LLMs I can run locally, of which I am using ollama to perform inference with the potential to easily switch models as improvements are shared.\r\n\r\nThis creates a dynamic of wanting to delegate sensitive and cost-effective information to the local model, and having to choose what information is shared with the external model.\r\n\r\nThis translates the problem from \"upload all my files and ask a question\" from \"upload some of my files and ask a question\". which introduces a lot of effort expenditure on the \"some\" decision making.\r\n\r\nThe gemini-engine repo aims to summarize a set of actions I want easily repeatable including the selection of what files to share, how to prepare them, and how to perform the sharing operation, and formatting the response of that operation to a good representation.\r\n\r\nWhen I make an API call, it creates a JSON including the prompt and the response and the files shared. Now I must check if that JSON file includes all that info.\r\n\r\nI looked at my open VSCode windows and found that none of them have the JSON visible, and I concluded that none of them had it open, but am I right in that conclusion?\r\n\r\nThen I struggled to tab back to this document because it focused the google keep file I still had open despite transitioning to here to type.\r\n\r\nI hesitate to narrate out loud given the presence of my Brother, even tho he sleepin.\r\n\r\nIt's not necessarily worse to type, but I feel less comfortable doing the mic right now and that feels like a loss of potential.\r\n\r\nThis (typing) only stops when I decide what question to ask, which means this text will end at whatever cutoff there is in the recording process to begin the inference but we can amend information by describing how the process will repeat for the information lost initially.\r\n\r\nYou couldn't: stop the recording so it is saved to disk, start recording the process of feeding it to the inference, and stop the recording to have the recording of the missing piece and feed it through again because you'd always have a piece left over.\r\n\r\nGiven the source code of X,Y,Z\r\nGive me an output that produces ${RESULT}\r\n\r\nA good system would be to have a single folder containing a copy of all the information needed for the inference, instead of having to look it up in other locations, because then you'd just say look at this folder\r\n\r\nInstead, I can build a suggestion of what files to include based on past selections.\r\n\r\nI need a recommender system, which means processing our logs to find out the historical information.\r\n\r\nIn Azure, there is an access log with actions and principals and role based access control with some roles granting the ability to grant other people roles and you want someone to only be able to accomplish discrete describable tasks but \r\n\r\n\r\n\r\nCurrently we\r\n\r\n- Suggest a directory to the clipboard\r\n- Create or edit a prompt\r\n- Update the prompt with the clipboard\r\n- Perform inference\r\n    - Select the images \r\n    - Select the prompt\r\n    - See also: interactive mode\r\n- The inference opens the response in VSCode\r\n    - This action can be repeated later\r\n- VSCode can interpret the response as Markdown and renders it\r\n\r\nI want to create the next PowerShell scripts that make this operation better.\r\n\r\nThis includes improving the way I take notes, which means my app should be writing to my notes because that action history is useful.\r\n\r\nI don't need to move this situation to Bevy, I could keep it all in PowerShell.\r\nHowever, there is merit to the innovation.\r\n\r\nI need to get the calculator working.\r\nStop typing. Do that.\r\n````\r\n\r\n\r\n\r\n# Summary\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\observation\\src\\observation_buffer_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse cursor_hero_environment_types::prelude::*;\r\nuse cursor_hero_observation_types::prelude::*;\r\n\r\n/// Responsible for storing observations inside ObservationBuckets of those who are able to observe them.\r\npub struct ObservationBufferPlugin;\r\n\r\nimpl Plugin for ObservationBufferPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Update, update_buffers);\r\n    }\r\n}\r\n\r\nfn update_buffers(\r\n    mut observation_events: EventReader<SomethingObservableHappenedEvent>,\r\n    mut buffer_query: Query<(Entity, &mut ObservationBuffer, Option<&EnvironmentTracker>)>,\r\n    mut buffer_events: EventWriter<ObservationBufferEvent>,\r\n) {\r\n    for event in observation_events.read() {\r\n        for buffer in buffer_query.iter_mut() {\r\n            let (buffer_id, mut buffer, buffer_environment_tag) = buffer;\r\n\r\n            // Determine if the buffer can see the event\r\n            let can_see = match (buffer_environment_tag, event) {\r\n                (\r\n                    Some(EnvironmentTracker {\r\n                        environment_id: buffer_environment_id,\r\n                    }),\r\n                    SomethingObservableHappenedEvent::Chat {\r\n                        environment_id: Some(event_environment_id),\r\n                        ..\r\n                    },\r\n                ) => *buffer_environment_id == *event_environment_id,\r\n                (\r\n                    _,\r\n                    SomethingObservableHappenedEvent::MemoryRestored {\r\n                        observation_buffer_id,\r\n                    },\r\n                ) => buffer_id == *observation_buffer_id,\r\n                (\r\n                    Some(EnvironmentTracker {\r\n                        environment_id: buffer_environment_id,\r\n                    }),\r\n                    SomethingObservableHappenedEvent::UISnapshot {\r\n                        environment_id: Some(event_environment_id),\r\n                        ..\r\n                    },\r\n                ) => *buffer_environment_id == *event_environment_id,\r\n                // A buffer outside all environments will observe all environments\r\n                (None, _) => true,\r\n                _ => false,\r\n            };\r\n            if !can_see {\r\n                if buffer.log_level == ObservationLogLevel::All {\r\n                    debug!(\"Buffer {:?} cannot see event {:?}\", buffer_id, event)\r\n                }\r\n                continue;\r\n            }\r\n\r\n            let entry = ObservationBufferEntry {\r\n                datetime: chrono::Local::now(),\r\n                origin: event.clone(),\r\n            };\r\n            if buffer.log_level == ObservationLogLevel::All {\r\n                debug!(\"Buffer {:?} observed event {:?}\", buffer_id, &entry)\r\n            }\r\n            buffer.observations.push(entry);\r\n\r\n            let event = ObservationBufferEvent::Updated { buffer_id };\r\n            buffer_events.send(event);\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\screen\\src\\screen_update_plugin.rs\r\n\r\n````rust\r\nuse std::sync::Arc;\r\nuse std::sync::Mutex;\r\nuse std::thread;\r\n\r\nuse crate::screen_plugin::Screen;\r\nuse bevy::prelude::*;\r\nuse bevy::utils::HashMap;\r\nuse bevy::window::PrimaryWindow;\r\nuse bevy::winit::WinitWindows;\r\nuse cursor_hero_metrics::Metrics;\r\nuse cursor_hero_winutils::win_screen_capture::get_full_monitor_capturers;\r\nuse cursor_hero_winutils::win_screen_capture::MonitorRegionCapturer;\r\n\r\npub struct CapturerHolderResource {\r\n    pub capturers: Vec<MonitorRegionCapturer>,\r\n}\r\n\r\n// Define a struct to hold captured frames\r\nstruct CapturedFrame {\r\n    data: Vec<u8>,\r\n}\r\n\r\n// Shared resource for captured frames\r\n#[derive(Resource)]\r\nstruct FrameHolderResource {\r\n    frames: Arc<Mutex<HashMap<u32, CapturedFrame>>>,\r\n    enabled: Arc<Mutex<bool>>,\r\n}\r\n\r\npub struct ScreenUpdatePlugin;\r\n\r\nimpl Plugin for ScreenUpdatePlugin {\r\n    fn build(&self, app: &mut App) {\r\n        // Create a shared resource for captured frames\r\n        let frames = Arc::new(Mutex::new(HashMap::new()));\r\n\r\n        // Clone the Arc to move into the capture thread\r\n        let frames_pointer = Arc::clone(&frames);\r\n\r\n        let capturer_holder = Arc::new(Mutex::new(CapturerHolderResource {\r\n            capturers: get_full_monitor_capturers().unwrap(),\r\n        }));\r\n\r\n        let enabled = Arc::new(Mutex::new(true));\r\n        let enabled_pointer = Arc::clone(&enabled);\r\n\r\n        let captured_frames = FrameHolderResource { frames, enabled };\r\n\r\n        // Spawn a separate thread for capturing frames\r\n        let ch = Arc::clone(&capturer_holder);\r\n        thread::spawn(move || loop {\r\n            if !*enabled_pointer.lock().unwrap() {\r\n                thread::sleep(std::time::Duration::from_millis(100));\r\n                continue;\r\n            }\r\n            let frames = capture_frames(ch.clone());\r\n            let mut shared_frames = frames_pointer.lock().unwrap();\r\n            *shared_frames = frames;\r\n        });\r\n\r\n        app.add_systems(Update, update_screens)\r\n            .insert_resource(captured_frames)\r\n            .insert_non_send_resource(CapturerHolderResource {\r\n                capturers: get_full_monitor_capturers().unwrap(),\r\n            });\r\n    }\r\n}\r\n\r\nfn capture_frames(capturers: Arc<Mutex<CapturerHolderResource>>) -> HashMap<u32, CapturedFrame> {\r\n    capturers\r\n        .lock()\r\n        .unwrap()\r\n        .capturers\r\n        .iter_mut()\r\n        .map(|capturer| {\r\n            // let mut metrics = Metrics::default();\r\n            // let frame = capturer.capture(&mut Some(metrics)).unwrap();\r\n            let frame = capturer.capture(&mut None).unwrap();\r\n            let frame = CapturedFrame {\r\n                data: frame.to_vec(),\r\n            };\r\n            (capturer.monitor.info.id, frame)\r\n        })\r\n        .collect::<HashMap<u32, CapturedFrame>>()\r\n}\r\n\r\nfn update_screens(\r\n    mut query: Query<(&mut Screen, &Handle<Image>)>,\r\n    mut textures: ResMut<Assets<Image>>,\r\n    time: Res<Time>,\r\n    frames: Res<FrameHolderResource>,\r\n    window_query: Query<Entity, With<PrimaryWindow>>,\r\n    winit_windows: NonSend<WinitWindows>,\r\n) {\r\n    let window_id = window_query.single();\r\n    let Some(winit_window) = winit_windows.get_window(window_id) else {\r\n        error!(\"Window not found\");\r\n        return;\r\n    };\r\n    if winit_window.is_minimized().unwrap_or(false) {\r\n        *frames.enabled.lock().unwrap() = false;\r\n        return;\r\n    } else {\r\n        *frames.enabled.lock().unwrap() = true;\r\n    }\r\n\r\n    let monitor_frames = frames.frames.lock().unwrap();\r\n    for (mut screen, texture) in &mut query {\r\n        if let Some(refresh_rate) = screen.refresh_rate.as_mut() {\r\n            // tick the refresh rate timer\r\n            refresh_rate.tick(time.delta());\r\n            // skip if not time to refresh\r\n            if !refresh_rate.finished() {\r\n                continue;\r\n            }\r\n        } else {\r\n            // skip if no refresh rate\r\n            continue;\r\n        }\r\n\r\n        // find the frame captured in the other thread\r\n        let mut metrics = Metrics::default();\r\n        metrics.begin(\"lookup\");\r\n        let frame = monitor_frames.get(&screen.id).unwrap();\r\n        metrics.end(\"lookup\");\r\n\r\n        // update the texture\r\n        metrics.begin(\"texture\");\r\n        textures.get_mut(texture).unwrap().data = frame.data.clone();\r\n        metrics.end(\"texture\");\r\n\r\n        // report metrics\r\n        // println!(\"{}\", metrics.report());\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\bevy\\src\\rect_scaled.rs\r\n\r\n````rust\r\nuse bevy::math::IRect;\r\nuse bevy::math::Rect;\r\nuse bevy::math::URect;\r\nuse bevy::math::Vec2;\r\n\r\npub trait RectScale {\r\n    fn scale(&self, scale: Vec2) -> Rect;\r\n}\r\nimpl RectScale for Rect {\r\n    fn scale(&self, scale: Vec2) -> Rect {\r\n        Rect {\r\n            min: self.min * scale,\r\n            max: self.max * scale,\r\n        }\r\n    }\r\n}\r\n\r\npub trait IRectScale {\r\n    fn scale(&self, scale: Vec2) -> IRect;\r\n}\r\nimpl IRectScale for IRect {\r\n    fn scale(&self, scale: Vec2) -> IRect {\r\n        IRect {\r\n            min: (self.min.as_vec2() * scale).as_ivec2(),\r\n            max: (self.max.as_vec2() * scale).as_ivec2(),\r\n        }\r\n    }\r\n}\r\n\r\npub trait URectScale {\r\n    fn scale(&self, scale: Vec2) -> URect;\r\n}\r\nimpl URectScale for URect {\r\n    fn scale(&self, scale: Vec2) -> URect {\r\n        URect {\r\n            min: (self.min.as_vec2() * scale).as_uvec2(),\r\n            max: (self.max.as_vec2() * scale).as_uvec2(),\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\math\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_math\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\agent\\src\\agent_movement_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse bevy_xpbd_2d::components::AngularVelocity;\r\nuse bevy_xpbd_2d::components::Rotation;\r\nuse cursor_hero_agent_types::prelude::*;\r\nuse cursor_hero_character_types::prelude::*;\r\nuse cursor_hero_movement_tool_types::prelude::*;\r\nuse cursor_hero_toolbelt_types::prelude::*;\r\nuse leafwing_input_manager::axislike::DualAxisData;\r\nuse leafwing_input_manager::prelude::*;\r\n\r\npub struct AgentMovementPlugin;\r\n\r\nimpl Plugin for AgentMovementPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Update, agent_tool_movement);\r\n        app.add_systems(Update, keep_upright);\r\n    }\r\n}\r\n\r\n#[allow(clippy::type_complexity)]\r\nfn agent_tool_movement(\r\n    character_query: Query<(&Children, &Transform), (With<Character>, With<Agent>)>,\r\n    toolbelt_query: Query<&Children, With<Toolbelt>>,\r\n    mut tool_query: Query<&mut ActionState<MovementToolAction>>,\r\n    time: Res<Time>,\r\n) {\r\n    for character in character_query.iter() {\r\n        let (character_children, character_transform) = character;\r\n        for character_child_id in character_children.iter() {\r\n            let Ok(toolbelt) = toolbelt_query.get(*character_child_id) else {\r\n                continue;\r\n            };\r\n            let toolbelt_children = toolbelt;\r\n            for tool in toolbelt_children.iter() {\r\n                let Ok(mut tool) = tool_query.get_mut(*tool) else {\r\n                    continue;\r\n                };\r\n                let data = tool.action_data_mut(MovementToolAction::Move);\r\n                let center = Vec2::new(1920.0, -1080.0) / 2.0;\r\n                // walk in a circle around the center\r\n                let desired_position = center + Vec2::from_angle(time.elapsed_seconds()) * 100.0;\r\n                let direction = desired_position - character_transform.translation.xy();\r\n                data.axis_pair = Some(DualAxisData::from_xy(direction.clamp_length_max(1.0)));\r\n                tool.press(MovementToolAction::Move);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n#[allow(clippy::type_complexity)]\r\nfn keep_upright(\r\n    mut character_query: Query<(&Rotation, &mut AngularVelocity), (With<Character>, With<Agent>)>,\r\n) {\r\n    for (rotation, mut angular_velocity) in character_query.iter_mut() {\r\n        *angular_velocity = AngularVelocity(rotation.sin() * -1.0);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\host_event_types\\src\\lib.rs\r\n\r\n````rust\r\nmod host_event_types;\r\nmod host_event_types_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::host_event_types::*;\r\n    pub use crate::host_event_types_plugin::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\winutils\\src\\win_mouse.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse windows::Win32::Foundation::POINT;\r\nuse windows::Win32::UI::Input::KeyboardAndMouse::SendInput;\r\nuse windows::Win32::UI::Input::KeyboardAndMouse::INPUT;\r\nuse windows::Win32::UI::Input::KeyboardAndMouse::INPUT_0;\r\nuse windows::Win32::UI::Input::KeyboardAndMouse::INPUT_MOUSE;\r\nuse windows::Win32::UI::Input::KeyboardAndMouse::INPUT_TYPE;\r\nuse windows::Win32::UI::Input::KeyboardAndMouse::KEYBDINPUT;\r\nuse windows::Win32::UI::Input::KeyboardAndMouse::KEYBD_EVENT_FLAGS;\r\nuse windows::Win32::UI::Input::KeyboardAndMouse::MOUSEEVENTF_LEFTDOWN;\r\nuse windows::Win32::UI::Input::KeyboardAndMouse::MOUSEEVENTF_LEFTUP;\r\nuse windows::Win32::UI::Input::KeyboardAndMouse::MOUSEEVENTF_RIGHTDOWN;\r\nuse windows::Win32::UI::Input::KeyboardAndMouse::MOUSEEVENTF_RIGHTUP;\r\nuse windows::Win32::UI::Input::KeyboardAndMouse::MOUSEEVENTF_WHEEL;\r\nuse windows::Win32::UI::Input::KeyboardAndMouse::MOUSEINPUT;\r\nuse windows::Win32::UI::Input::KeyboardAndMouse::VIRTUAL_KEY;\r\nuse windows::Win32::UI::WindowsAndMessaging::GetCursorPos;\r\nuse windows::Win32::UI::WindowsAndMessaging::SetCursorPos;\r\nuse windows::Win32::UI::WindowsAndMessaging::WHEEL_DELTA;\r\n\r\npub fn get_cursor_position() -> Result<IVec2, windows::core::Error> {\r\n    unsafe {\r\n        let mut point = POINT::default();\r\n        GetCursorPos(&mut point)?;\r\n        Ok(IVec2::new(point.x, point.y))\r\n    }\r\n}\r\n\r\npub fn set_cursor_position(position: IVec2) -> Result<(), windows::core::Error> {\r\n    unsafe {\r\n        SetCursorPos(position.x, position.y)?;\r\n        Ok(())\r\n    }\r\n}\r\n\r\npub fn left_mouse_down() -> Result<(), windows::core::Error> {\r\n    // Prepare a mouse input for left button down\r\n    let mouse_input = MOUSEINPUT {\r\n        dx: 0,\r\n        dy: 0,\r\n        mouseData: 0,\r\n        dwFlags: MOUSEEVENTF_LEFTDOWN,\r\n        time: 0,\r\n        dwExtraInfo: 0,\r\n    };\r\n\r\n    // Prepare an INPUT structure for the down event\r\n    let input = INPUT {\r\n        r#type: INPUT_MOUSE,\r\n        Anonymous: INPUT_0 { mi: mouse_input },\r\n    };\r\n\r\n    // Send the input for button down\r\n    unsafe { SendInput(&[input], std::mem::size_of::<INPUT>() as i32) };\r\n\r\n    Ok(())\r\n}\r\n\r\npub fn left_mouse_up() -> Result<(), windows::core::Error> {\r\n    // Prepare a mouse input for left button up\r\n    let mouse_input = MOUSEINPUT {\r\n        dx: 0,\r\n        dy: 0,\r\n        mouseData: 0,\r\n        dwFlags: MOUSEEVENTF_LEFTUP,\r\n        time: 0,\r\n        dwExtraInfo: 0,\r\n    };\r\n\r\n    // Prepare an INPUT structure for the up event\r\n    let input = INPUT {\r\n        r#type: INPUT_MOUSE,\r\n        Anonymous: INPUT_0 { mi: mouse_input },\r\n    };\r\n\r\n    // Send the input for button up\r\n    unsafe { SendInput(&[input], std::mem::size_of::<INPUT>() as i32) };\r\n\r\n    Ok(())\r\n}\r\n\r\n#[allow(dead_code)]\r\npub fn left_click() -> Result<(), windows::core::Error> {\r\n    left_mouse_down()?;\r\n    left_mouse_up()?;\r\n    Ok(())\r\n}\r\n\r\npub fn right_mouse_down() -> Result<(), windows::core::Error> {\r\n    // Prepare a mouse input for right button down\r\n    let mouse_input = MOUSEINPUT {\r\n        dx: 0,\r\n        dy: 0,\r\n        mouseData: 0,\r\n        dwFlags: MOUSEEVENTF_RIGHTDOWN,\r\n        time: 0,\r\n        dwExtraInfo: 0,\r\n    };\r\n\r\n    // Prepare an INPUT structure for the down event\r\n    let input = INPUT {\r\n        r#type: INPUT_MOUSE,\r\n        Anonymous: INPUT_0 { mi: mouse_input },\r\n    };\r\n\r\n    // Send the input for button down\r\n    unsafe { SendInput(&[input], std::mem::size_of::<INPUT>() as i32) };\r\n\r\n    Ok(())\r\n}\r\n\r\npub fn right_mouse_up() -> Result<(), windows::core::Error> {\r\n    // Prepare a mouse input for right button up\r\n    let mouse_input = MOUSEINPUT {\r\n        dx: 0,\r\n        dy: 0,\r\n        mouseData: 0,\r\n        dwFlags: MOUSEEVENTF_RIGHTUP,\r\n        time: 0,\r\n        dwExtraInfo: 0,\r\n    };\r\n\r\n    // Prepare an INPUT structure for the up event\r\n    let input = INPUT {\r\n        r#type: INPUT_MOUSE,\r\n        Anonymous: INPUT_0 { mi: mouse_input },\r\n    };\r\n\r\n    // Send the input for button up\r\n    unsafe { SendInput(&[input], std::mem::size_of::<INPUT>() as i32) };\r\n\r\n    Ok(())\r\n}\r\n\r\n// Constants\r\nconst INPUT_KEYBOARD: u32 = 1;\r\nconst VK_F23: u16 = 0x86;\r\nconst KEYEVENTF_KEYUP: u32 = 0x0002;\r\n\r\npub fn press_f23_key() -> Result<(), windows::core::Error> {\r\n    let keyboard_input = KEYBDINPUT {\r\n        wVk: VIRTUAL_KEY(VK_F23),\r\n        wScan: 0,\r\n        dwFlags: KEYBD_EVENT_FLAGS(0),\r\n        time: 0,\r\n        dwExtraInfo: 0,\r\n    };\r\n\r\n    let input = INPUT {\r\n        r#type: INPUT_TYPE(INPUT_KEYBOARD),\r\n        Anonymous: INPUT_0 { ki: keyboard_input },\r\n    };\r\n\r\n    unsafe { SendInput(&[input], std::mem::size_of::<INPUT>() as i32) };\r\n\r\n    Ok(())\r\n}\r\n\r\npub fn release_f23_key() -> Result<(), windows::core::Error> {\r\n    let keyboard_input = KEYBDINPUT {\r\n        wVk: VIRTUAL_KEY(VK_F23),\r\n        wScan: 0,\r\n        dwFlags: KEYBD_EVENT_FLAGS(KEYEVENTF_KEYUP),\r\n        time: 0,\r\n        dwExtraInfo: 0,\r\n    };\r\n\r\n    let input = INPUT {\r\n        r#type: INPUT_TYPE(INPUT_KEYBOARD),\r\n        Anonymous: INPUT_0 { ki: keyboard_input },\r\n    };\r\n\r\n    unsafe { SendInput(&[input], std::mem::size_of::<INPUT>() as i32) };\r\n\r\n    Ok(())\r\n}\r\n\r\npub fn scroll_wheel(scale: f32) -> Result<(), windows::core::Error> {\r\n    let mouse_input = MOUSEINPUT {\r\n        dx: 0,\r\n        dy: 0,\r\n        mouseData: (WHEEL_DELTA as f32 * scale) as i32 as u32, // https://github.com/microsoft/windows-rs/issues/2708\r\n        dwFlags: MOUSEEVENTF_WHEEL,\r\n        time: 0,\r\n        dwExtraInfo: 0,\r\n    };\r\n\r\n    let input = INPUT {\r\n        r#type: INPUT_MOUSE,\r\n        Anonymous: INPUT_0 { mi: mouse_input },\r\n    };\r\n\r\n    unsafe { SendInput(&[input], std::mem::size_of::<INPUT>() as i32) };\r\n\r\n    Ok(())\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\secret\\src\\secrets_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n\r\npub struct SecretsPlugin;\r\n\r\nimpl Plugin for SecretsPlugin {\r\n    fn build(&self, _app: &mut App) {}\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\tools\\src\\tool_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n\r\nuse crate::click_tool::ClickToolPlugin;\r\nuse crate::cube_tool::CubeToolPlugin;\r\nuse crate::default_wheel_tool::DefaultWheelToolPlugin;\r\nuse crate::focus_tool::FocusToolPlugin;\r\nuse crate::hello_tool::HelloToolPlugin;\r\nuse crate::keyboard_tool::KeyboardToolPlugin;\r\nuse crate::keyboard_wheel_tool::KeyboardWheelToolPlugin;\r\nuse crate::level_bounds_visibility_tool::LevelBoundsVisibilityToolPlugin;\r\n// use crate::placeholder_tool::PlaceholderToolPlugin;\r\n#[cfg(debug_assertions)]\r\nuse crate::restart_tool::RestartToolPlugin;\r\nuse crate::scroll_tool::ScrollToolPlugin;\r\nuse crate::talk_tool::TalkToolPlugin;\r\n// use crate::window_drag_tool::WindowDragToolPlugin;\r\nuse crate::zoom_tool::ZoomToolPlugin;\r\n\r\npub struct ToolPlugin;\r\nimpl Plugin for ToolPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_plugins(CubeToolPlugin);\r\n        // app.add_plugins(PlaceholderToolPlugin);\r\n        app.add_plugins(ClickToolPlugin);\r\n        app.add_plugins(ScrollToolPlugin);\r\n        app.add_plugins(TalkToolPlugin);\r\n        app.add_plugins(ZoomToolPlugin);\r\n        app.add_plugins(FocusToolPlugin);\r\n        app.add_plugins(DefaultWheelToolPlugin);\r\n        // app.add_plugins(WindowDragToolPlugin);\r\n        app.add_plugins(KeyboardToolPlugin);\r\n        app.add_plugins(KeyboardWheelToolPlugin);\r\n        app.add_plugins(HelloToolPlugin);\r\n        app.add_plugins(LevelBoundsVisibilityToolPlugin);\r\n        #[cfg(debug_assertions)]\r\n        app.add_plugins(RestartToolPlugin);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\pointer\\src\\pointer_click_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse bevy::utils::HashMap;\r\nuse bevy::utils::HashSet;\r\nuse bevy_xpbd_2d::components::CollidingEntities;\r\nuse cursor_hero_pointer_types::prelude::*;\r\n\r\npub struct PointerClickPlugin;\r\n\r\nimpl Plugin for PointerClickPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Update, press_detection);\r\n        app.add_systems(Update, release_detection);\r\n    }\r\n}\r\n\r\n#[allow(clippy::type_complexity)]\r\npub fn press_detection(\r\n    mut commands: Commands,\r\n    mut tool_click_events: EventReader<ToolClickEvent>,\r\n    mut click_events: EventWriter<ClickEvent>,\r\n    mut pointer_query: Query<(&CollidingEntities, Option<&mut Pressing>), With<Pointer>>,\r\n    mut target_query: Query<(Entity, &Visibility, Option<&mut Pressed>), With<Clickable>>,\r\n) {\r\n    let mut pointer_target_ways: Vec<(Entity, Entity, Way)> = vec![];\r\n    let mut target_pointer_ways: Vec<(Entity, Entity, Way)> = vec![];\r\n    for tool_click_event in tool_click_events.read() {\r\n        // only check pressed events\r\n        let ToolClickEvent::Pressed { pointer_id, way } = tool_click_event else {\r\n            continue;\r\n        };\r\n\r\n        // find the pointer for the event\r\n        let Ok((pointer_touching, pointer_pressing)) = pointer_query.get_mut(*pointer_id) else {\r\n            warn!(\"Pointer {:?} not found\", pointer_id);\r\n            continue;\r\n        };\r\n\r\n        let mut pressed = vec![];\r\n\r\n        // for each element the pointer is touching\r\n        for touching_id in pointer_touching.iter() {\r\n            // debug!(\"Pointer {:?} touching {:?}\", pointer_id, touching_id);\r\n            // ensure it is a clickable element\r\n            let Ok((target_id, target_visible, target_pressed)) =\r\n                target_query.get_mut(*touching_id)\r\n            else {\r\n                // debug!(\"Target {:?} not valid\", touching_id);\r\n                continue;\r\n            };\r\n            // ensure the element is visible\r\n            if target_visible == Visibility::Hidden {\r\n                continue;\r\n            }\r\n\r\n            // track in the element what is pressing it\r\n            if target_pressed.is_none() {\r\n                // nothing is pressing this element yet\r\n                target_pointer_ways.push((*touching_id, *pointer_id, *way));\r\n            } else if let Some(mut target_pressed) = target_pressed {\r\n                // something is already pressing this element\r\n                if target_pressed\r\n                    .presses\r\n                    .iter()\r\n                    .any(|press| press.pointer_id == *pointer_id && press.way == *way)\r\n                {\r\n                    warn!(\"Pointer {:?} already pressing {:?}\", pointer_id, target_id);\r\n                } else {\r\n                    target_pressed.presses.push(PointerPress {\r\n                        pointer_id: *pointer_id,\r\n                        way: *way,\r\n                    });\r\n                }\r\n            }\r\n\r\n            // send pressed event\r\n            click_events.send(ClickEvent::Pressed {\r\n                target_id,\r\n                pointer_id: *pointer_id,\r\n                way: *way,\r\n            });\r\n\r\n            pressed.push(target_id);\r\n        }\r\n\r\n        match pointer_pressing {\r\n            Some(mut pointer_pressing) => {\r\n                for target_id in pressed.into_iter() {\r\n                    if pointer_pressing\r\n                        .pressing\r\n                        .iter()\r\n                        .any(|p| p.target_id == target_id && p.way == *way)\r\n                    {\r\n                        warn!(\"Pointer {:?} already pressing {:?}\", pointer_id, target_id);\r\n                    } else {\r\n                        pointer_pressing.pressing.push(TargetPress {\r\n                            target_id,\r\n                            way: *way,\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n            None => {\r\n                for target_id in pressed.into_iter() {\r\n                    pointer_target_ways.push((*pointer_id, target_id, *way));\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // We have deferred the insertion of the Pressed and Pressing components\r\n    // This is because doing it in the event loop causes clobbering when simultaneous events occur\r\n    let pointer_target_ways = group_by_entity(pointer_target_ways);\r\n    for (pointer_id, target_presses) in pointer_target_ways {\r\n        commands.entity(pointer_id).insert(Pressing {\r\n            pressing: target_presses\r\n                .into_iter()\r\n                .map(|(target_id, way)| TargetPress { target_id, way })\r\n                .collect(),\r\n        });\r\n    }\r\n    let target_pointer_ways = group_by_entity(target_pointer_ways);\r\n    for (target_id, pointer_presses) in target_pointer_ways {\r\n        commands.entity(target_id).insert(Pressed {\r\n            presses: pointer_presses\r\n                .into_iter()\r\n                .map(|(pointer_id, way)| PointerPress { pointer_id, way })\r\n                .collect(),\r\n        });\r\n    }\r\n}\r\n\r\nfn group_by_entity(ways: Vec<(Entity, Entity, Way)>) -> HashMap<Entity, Vec<(Entity, Way)>> {\r\n    let mut groups: HashMap<Entity, Vec<(Entity, Way)>> = HashMap::new();\r\n\r\n    for (pointer, target, way) in ways {\r\n        groups\r\n            .entry(pointer)\r\n            .or_insert_with(Vec::new)\r\n            .push((target, way));\r\n    }\r\n\r\n    groups\r\n}\r\n\r\n#[allow(clippy::type_complexity)]\r\nfn release_detection(\r\n    mut commands: Commands,\r\n    mut tool_click_events: EventReader<ToolClickEvent>,\r\n    mut click_events: EventWriter<ClickEvent>,\r\n    mut pointer_query: Query<(&CollidingEntities, Option<&mut Pressing>), With<Pointer>>,\r\n    mut target_query: Query<(Entity, &Visibility, Option<&mut Pressed>), With<Clickable>>,\r\n) {\r\n    for tool_click_event in tool_click_events.read() {\r\n        // only check released events\r\n        let ToolClickEvent::Released { pointer_id, way } = tool_click_event else {\r\n            continue;\r\n        };\r\n\r\n        // find the pointer for the event\r\n        let Ok((pointer_touching, pointer_pressing)) = pointer_query.get_mut(*pointer_id) else {\r\n            warn!(\"Pointer {:?} not found\", pointer_id);\r\n            continue;\r\n        };\r\n\r\n        // each element the pointer has tracked as pressing now needs to be released\r\n        // if the pointer is still touching that element, also send a click event\r\n\r\n        // for each element the pointer is touching\r\n        let mut clicked: Vec<Entity> = vec![];\r\n        for touching_id in pointer_touching.iter() {\r\n            // ensure it is a clickable element\r\n            let Ok((target_id, target_visible, target_pressed)) =\r\n                target_query.get_mut(*touching_id)\r\n            else {\r\n                continue;\r\n            };\r\n            // ensure the element is visible\r\n            if target_visible == Visibility::Hidden {\r\n                continue;\r\n            }\r\n\r\n            // update the tracker in the target\r\n            if let Some(mut pressed) = target_pressed {\r\n                if let Some(press_index) = pressed\r\n                    .presses\r\n                    .iter()\r\n                    .position(|press| press.pointer_id == *pointer_id && press.way == *way)\r\n                {\r\n                    if pressed.presses.len() == 1 {\r\n                        // this is the last press, remove the tracker\r\n                        commands.entity(target_id).remove::<Pressed>();\r\n                    } else {\r\n                        // remove the press from the tracker\r\n                        pressed.presses.remove(press_index);\r\n                    }\r\n                } else {\r\n                    warn!(\"Pointer {:?} not pressing {:?}\", pointer_id, target_id);\r\n                }\r\n            } else {\r\n                warn!(\r\n                    \"Target {:?} didn't know it was pressed by pointer {:?}. Did you press elsewhere and release here?\",\r\n                    target_id, pointer_id\r\n                );\r\n            }\r\n\r\n            clicked.push(target_id);\r\n        }\r\n\r\n        match pointer_pressing {\r\n            Some(mut pressing) => {\r\n                // send release events\r\n                let mut remove = HashSet::new();\r\n                pressing\r\n                    .pressing\r\n                    .iter()\r\n                    .filter(|press| press.way == *way)\r\n                    .for_each(|press: &TargetPress| {\r\n                        click_events.send(ClickEvent::Released {\r\n                            target_id: press.target_id,\r\n                            pointer_id: *pointer_id,\r\n                            way: *way,\r\n                        });\r\n                        remove.insert(*press);\r\n                    });\r\n                pressing.pressing.retain(|press| !remove.contains(press));\r\n                if pressing.pressing.is_empty() {\r\n                    commands.entity(*pointer_id).remove::<Pressing>();\r\n                }\r\n                // ensure all clicked are present in remove\r\n                for target_id in clicked.iter() {\r\n                    if !remove.contains(&TargetPress {\r\n                        target_id: *target_id,\r\n                        way: *way,\r\n                    }) {\r\n                        warn!(\r\n                            \"Pointer {:?} didn't know it was clicking {:?}\",\r\n                            pointer_id, target_id\r\n                        );\r\n                    } else {\r\n                        click_events.send(ClickEvent::Clicked {\r\n                            target_id: *target_id,\r\n                            pointer_id: *pointer_id,\r\n                            way: *way,\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n            None => {\r\n                debug!(\"Pointer {:?} wasn't pressing anything\", pointer_id);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\xelu_prompts\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_xelu_prompts\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\nleafwing-input-manager = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\observation\\src\\observe_chat_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse cursor_hero_character_types::prelude::*;\r\nuse cursor_hero_chat_types::prelude::*;\r\nuse cursor_hero_environment_types::environment_types::EnvironmentTracker;\r\nuse cursor_hero_observation_types::prelude::*;\r\npub struct ObserveChatPlugin;\r\n\r\nimpl Plugin for ObserveChatPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Update, observe_chat);\r\n    }\r\n}\r\n\r\nfn observe_chat(\r\n    mut chat_events: EventReader<ChatEvent>,\r\n    mut observation_events: EventWriter<SomethingObservableHappenedEvent>,\r\n    character_query: Query<(Option<&Name>, Option<&EnvironmentTracker>), With<Character>>,\r\n) {\r\n    for event in chat_events.read() {\r\n        let ChatEvent::Chat {\r\n            character_id,\r\n            message,\r\n        } = event;\r\n        let Ok(character) = character_query.get(*character_id) else {\r\n            warn!(\r\n                \"Chat event for unknown character? character_id {:?}\",\r\n                character_id\r\n            );\r\n            continue;\r\n        };\r\n        let (character_name, character_environment_tag) = character;\r\n\r\n        let Some(character_name) = character_name else {\r\n            warn!(\r\n                \"Chat event for character with no name? character_id {:?}\",\r\n                character_id\r\n            );\r\n            continue;\r\n        };\r\n\r\n        let environment_id = character_environment_tag.map(|tag| tag.environment_id);\r\n\r\n        let event = SomethingObservableHappenedEvent::Chat {\r\n            environment_id,\r\n            character_id: *character_id,\r\n            character_name: character_name.to_string(),\r\n            message: message.clone(),\r\n        };\r\n        debug!(\"Sending event: {:?}\", event);\r\n        observation_events.send(event);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ollama_types\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_ollama_types\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\glados_tts_types\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_glados_tts_types\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\memory\\src\\voice_to_text_memory_plugin.rs\r\n\r\n````rust\r\nuse std::time::Duration;\r\n\r\nuse bevy::prelude::*;\r\nuse bevy::utils::Instant;\r\n\r\nuse cursor_hero_memory_types::prelude::*;\r\nuse cursor_hero_secret_types::secrets_types::SecretString;\r\nuse cursor_hero_voice_to_text_types::voice_to_text_types::VoiceToTextStatus;\r\nuse cursor_hero_voice_to_text_types::voice_to_text_types::VoiceToTextStatusEvent;\r\nuse serde::Deserialize;\r\nuse serde::Serialize;\r\n\r\npub struct VoiceToTextMemoryPlugin;\r\n\r\nimpl Plugin for VoiceToTextMemoryPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.insert_resource(VoiceToTextMemoryConfig::default());\r\n        app.add_systems(Update, persist.pipe(handle_persist_errors));\r\n        app.add_systems(Update, restore.pipe(handle_restore_errors));\r\n    }\r\n}\r\nconst PERSIST_FILE_NAME: &str = \"voice_to_text.json\";\r\n\r\n// not moved to lib to ensure log contains this module name\r\nfn handle_persist_errors(In(result): In<Result<PersistSuccess, PersistError>>) {\r\n    if let Err(e) = result {\r\n        error!(\"Persist error occurred: {:?}\", e);\r\n    } else if let Ok(PersistSuccess::WritePerformed) = result {\r\n        debug!(\"Persisted succeeded\");\r\n    }\r\n}\r\n\r\nfn handle_restore_errors(In(result): In<Result<RestoreSuccess, RestoreError>>) {\r\n    if let Err(e) = result {\r\n        error!(\"Restore error occurred: {:?}\", e);\r\n    } else if let Ok(RestoreSuccess::Performed) = result {\r\n        info!(\"Restore succeeded\");\r\n    }\r\n}\r\n\r\n#[derive(Debug, Resource, Reflect)]\r\n#[reflect(Resource)]\r\nstruct VoiceToTextMemoryConfig {\r\n    pub persist_cooldown: Timer,\r\n    pub restore_retry_cooldown: Duration,\r\n}\r\nimpl Default for VoiceToTextMemoryConfig {\r\n    fn default() -> Self {\r\n        Self {\r\n            persist_cooldown: Timer::from_seconds(10.0, TimerMode::Repeating),\r\n            restore_retry_cooldown: Duration::from_secs(60),\r\n        }\r\n    }\r\n}\r\n\r\n#[derive(Debug, Serialize, Deserialize, PartialEq, Clone)]\r\nstruct DiskData {\r\n    api_key: Option<SecretString>,\r\n}\r\n\r\nfn persist(\r\n    mut config: ResMut<VoiceToTextMemoryConfig>,\r\n    memory_config: Res<MemoryConfig>,\r\n    mut debounce: Local<Option<DiskData>>,\r\n    time: Res<Time>,\r\n    voice_status: Res<VoiceToTextStatus>,\r\n) -> Result<PersistSuccess, PersistError> {\r\n    if !config.persist_cooldown.tick(time.delta()).just_finished() {\r\n        return Ok(PersistSuccess::Cooldown);\r\n    }\r\n    let api_key = match &*voice_status {\r\n        VoiceToTextStatus::Alive { api_key, .. } | VoiceToTextStatus::Starting { api_key, .. } => {\r\n            Some(api_key.clone())\r\n        }\r\n        VoiceToTextStatus::Dead => None,\r\n        _ => {\r\n            return Ok(PersistSuccess::NoAction);\r\n        }\r\n    };\r\n    let data = DiskData { api_key };\r\n    if debounce.is_none() || debounce.as_ref().unwrap() != &data {\r\n        let file = get_persist_file(memory_config.as_ref(), PERSIST_FILE_NAME, Usage::Persist)\r\n            .map_err(PersistError::Io)?;\r\n        write_to_disk(file, data.clone())?;\r\n        *debounce = Some(data);\r\n        Ok(PersistSuccess::WritePerformed)\r\n    } else {\r\n        Ok(PersistSuccess::Debounce)\r\n    }\r\n}\r\n\r\nfn restore(\r\n    config: Res<VoiceToTextMemoryConfig>,\r\n    memory_config: Res<MemoryConfig>,\r\n    mut current_status: ResMut<VoiceToTextStatus>,\r\n    mut status_events: EventWriter<VoiceToTextStatusEvent>,\r\n    mut attempted_at: Local<Option<Instant>>,\r\n) -> Result<RestoreSuccess, RestoreError> {\r\n    if matches!(\r\n        *current_status,\r\n        VoiceToTextStatus::Alive { .. }\r\n            | VoiceToTextStatus::Starting { .. }\r\n            | VoiceToTextStatus::UnknownWithCachedApiKey { .. }\r\n            | VoiceToTextStatus::Dead\r\n    ) {\r\n        return Ok(RestoreSuccess::NoAction);\r\n    }\r\n    let file = match get_persist_file(memory_config.as_ref(), PERSIST_FILE_NAME, Usage::Restore) {\r\n        Ok(file) => Ok(file),\r\n        Err(e) => {\r\n            if let Some(attempt) = *attempted_at {\r\n                if attempt.elapsed() > config.restore_retry_cooldown {\r\n                    *attempted_at = Some(Instant::now());\r\n                    return Err(RestoreError::Io(e));\r\n                } else {\r\n                    // Silently ignore the error and retry later\r\n                    return Ok(RestoreSuccess::NoAction);\r\n                }\r\n            } else {\r\n                *attempted_at = Some(Instant::now());\r\n                return Err(RestoreError::Io(e));\r\n            }\r\n        }\r\n    }?;\r\n    let data: DiskData = read_from_disk(file)?;\r\n    let Some(api_key) = data.api_key else {\r\n        return Ok(RestoreSuccess::NoAction);\r\n    };\r\n\r\n    info!(\"Restoring api key\");\r\n\r\n    let new_status = match *current_status {\r\n        VoiceToTextStatus::Unknown\r\n        | VoiceToTextStatus::AliveButWeDontKnowTheApiKey\r\n        | VoiceToTextStatus::UnknownWithCachedApiKey { .. } => {\r\n            VoiceToTextStatus::UnknownWithCachedApiKey { api_key }\r\n        }\r\n        ref current => current.clone(),\r\n    };\r\n    if new_status != *current_status {\r\n        let event = VoiceToTextStatusEvent::Changed {\r\n            old_status: current_status.clone(),\r\n            new_status: new_status.clone(),\r\n        };\r\n        debug!(\"Sending event: {:?}\", event);\r\n        status_events.send(event);\r\n        *current_status = new_status;\r\n        Ok(RestoreSuccess::Performed)\r\n    } else {\r\n        Ok(RestoreSuccess::NoAction)\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\window_position_types\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_window_position_types\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\ncursor_hero_math = {workspace = true}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\templates\\matchers\\new_tool\\Cargo.toml.py\r\n\r\n````py\r\n# {{before_first_workspace_dependency}}\r\n# cursor_hero_{{crate_name}}_tool = { path = \"./crates/{{crate_name}}_tool\" }\r\n# {{first_workspace_dependency_onwards}}\r\n\r\n\r\n\r\ndef gather_variables(text: str) -> dict[str,str]:\r\n    # before_first_workspace_dependency\r\n    find = \"[workspace.dependencies]\"\r\n    include = True\r\n    index = text.find(find)\r\n    assert index != -1, f\"Coult not find `{find}`\"\r\n    index = index + len(find) if include else index\r\n    before_first_workspace_dependency, remaining = text[:index],text[index:]\r\n\r\n    # first_workspace_dependency_onwards\r\n    first_workspace_dependency_onwards = remaining\r\n\r\n    return {\r\n        \"before_first_workspace_dependency\": before_first_workspace_dependency,\r\n        \"first_workspace_dependency_onwards\": first_workspace_dependency_onwards,\r\n    }\r\n\r\n##### OLD CONTENT OF THIS FILE\r\n\r\n# # {{before_first_workspace_dependency}}\r\n# # cursor_hero_{{crate_name}}_tool = { path = \"./crates/{{crate_name}}_tool\" }\r\n# # {{first_workspace_dependency_onwards}\r\n# \r\n# \r\n# \r\n# def gather_variables(text: str) -> dict[str,str]:\r\n#     find = \"some part of the file\"\r\n#     include = True\r\n#     index = text.find(find)\r\n#     assert index != -1, f\"Coult not find `{find}`\"\r\n#     index = index + len(find) if include else index\r\n#     before_first_workspace_dependency, remaining = text[:index],text[index:]\r\n# \r\n#     first_workspace_dependency_onwards = remaining\r\n# \r\n#     return {\r\n#         \"before_first_workspace_dependency\": before_first_workspace_dependency,\r\n#         \"first_workspace_dependency_onwards\": first_workspace_dependency_onwards,\r\n#     }\r\n# \r\n# ##### OLD CONTENT OF THIS FILE\r\n# \r\n# # # {{before_first_workspace_dependency}}\r\n# # # cursor_hero_{{crate_name}}_tool = { path = \"./crates/{{crate_name}}_tool\" }\r\n# # # {{first_workspace_dependency_onwards}\r\n# # \r\n# # \r\n# # \r\n# # def gather_variables(text: str) -> dict[str,str]:\r\n# #     find = \"some part of the file\"\r\n# #     include = True\r\n# #     index = text.find(find)\r\n# #     assert index != -1, f\"Coult not find `{find}`\"\r\n# #     index = index + len(find) if include else index\r\n# #     before_first_workspace_dependency, remaining = text[:index],text[index:]\r\n# # \r\n# #     first_workspace_dependency_onwards = remaining\r\n# #     return {\r\n# #         \"before_first_workspace_dependency\": before_first_workspace_dependency,\r\n# #         \"first_workspace_dependency_onwards\": first_workspace_dependency_onwards,\r\n# #     }\r\n# # \r\n# # ##### OLD CONTENT OF THIS FILE\r\n# # \r\n# # # # {{before_first_workspace_dependency}}\r\n# # # # cursor_hero_{{crate_name}}_tool = { path = \"./crates/{{crate_name}}_tool\" }\r\n# # # # {{first_workspace_dependency_onwards}\r\n# # # \r\n# # # \r\n# # # \r\n# # # def gather_variables(text: str) -> dict[str,str]:\r\n# # #     find = \"some part of the file\"\r\n# # #     include = True\r\n# # #     index = text.find(find)\r\n# # #     assert index != -1, f\"Coult not find `{find}`\"\r\n# # #     index = index + len(find) if include else index\r\n# # #     before_first_workspace_dependency, remaining = text[:index],text[index:]\r\n# # # \r\n# # #     find = \"some part of the file\"\r\n# # #     include = True\r\n# # #     index = remaining.find(find)\r\n# # #     assert index != -1, f\"Coult not find `{find}`\"\r\n# # #     index = index + len(find) if include else index\r\n# # #     first_workspace_dependency_onwards, remaining = remaining[:index],remaining[index:]\r\n# # # \r\n# # #     return {\r\n# # #         \"before_first_workspace_dependency\": before_first_workspace_dependency,\r\n# # #         \"first_workspace_dependency_onwards\": first_workspace_dependency_onwards,\r\n# # #     }\r\n# # # \r\n# # # ##### OLD CONTENT OF THIS FILE\r\n# # # \r\n# # # # # {{before_first_workspace_dependency}}\r\n# # # # # cursor_hero_{{crate_name}}_tool = { path = \"./crates/{{crate_name}}_tool\" }\r\n# # # # # {{first_workspace_dependency_onwards}\r\n# # # # \r\n# # # # \r\n# # # # \r\n# # # # def gather_variables(text: str) -> dict[str,str]:\r\n# # # #     find = \"some part of the file\"\r\n# # # #     include = True\r\n# # # #     index = text.find(find)\r\n# # # #     assert index != -1, f\"Coult not find `{find}`\"\r\n# # # #     index = index + len(find) if include else index\r\n# # # #     before_first_workspace_dependency, remaining = text[:index],text[index:]\r\n# # # # \r\n# # # #     find = \"some part of the file\"\r\n# # # #     include = True\r\n# # # #     index = remaining.find(find)\r\n# # # #     assert index != -1, f\"Coult not find `{find}`\"\r\n# # # #     index = index + len(find) if include else index\r\n# # # #     first_workspace_dependency_onwards, remaining = remaining[:index],remaining[index:]\r\n# # # # \r\n# # # #     return {\r\n# # # #         \"before_first_workspace_dependency\": before_first_workspace_dependency,\r\n# # # #         \"first_workspace_dependency_onwards\": first_workspace_dependency_onwards,\r\n# # # #     }\r\n# # # # \r\n# # # # ##### OLD CONTENT OF THIS FILE\r\n# # # # \r\n# # # # # # {{before_first_workspace_dependency}}\r\n# # # # # # cursor_hero_{{crate_name}}_tool = { path = \"./crates/{{crate_name}}_tool\" }\r\n# # # # # # {{first_workspace_dependency_onwards}\r\n# # # # # \r\n# # # # # \r\n# # # # # \r\n# # # # # def gather_variables(text: str) -> dict[str,str]:\r\n# # # # #     find = \"some part of the file\"\r\n# # # # #     include = True\r\n# # # # #     index = text.find(find)\r\n# # # # #     assert index != -1, f\"Coult not find `{find}`\"\r\n# # # # #     before_first_workspace_dependency, remaining = text[:index],text[index:]\r\n# # # # # \r\n# # # # #     find = \"some part of the file\"\r\n# # # # #     include = True\r\n# # # # #     index = remaining.find(find)\r\n# # # # #     assert index != -1, f\"Coult not find `{find}`\"\r\n# # # # #     first_workspace_dependency_onwards, remaining = remaining[:index],remaining[index:]\r\n# # # # # \r\n# # # # #     return {\r\n# # # # #         \"before_first_workspace_dependency\": before_first_workspace_dependency,\r\n# # # # #         \"first_workspace_dependency_onwards\": first_workspace_dependency_onwards,\r\n# # # # #     }\r\n# # # # # \r\n# # # # # ##### OLD CONTENT OF THIS FILE\r\n# # # # # \r\n# # # # # # # {{before_first_workspace_dependency}}\r\n# # # # # # # cursor_hero_{{crate_name}}_tool = { path = \"./crates/{{crate_name}}_tool\" }\r\n# # # # # # # {{first_workspace_depndency_onwards}}\r\n# # # # # # \r\n# # # # # # \r\n# # # # # # \r\n# # # # # # def gather_variables(text: str) -> dict[str,str]:\r\n# # # # # #     find = \"some part of the file\"\r\n# # # # # #     include = true\r\n# # # # # #     index = text.find(find)\r\n# # # # # #     assert index != -1, f\"Coult not find `{find}`\"\r\n# # # # # #     before_first_workspace_dependency, remaining = text[:index],text[index:]\r\n# # # # # # \r\n# # # # # #     find = \"some part of the file\"\r\n# # # # # #     include = true\r\n# # # # # #     index = remaining.find(find)\r\n# # # # # #     assert index != -1, f\"Coult not find `{find}`\"\r\n# # # # # #     first_workspace_dependency_onwards, remaining = remaining[:index],remaining[index:]\r\n# # # # # # \r\n# # # # # #     return {\r\n# # # # # #         \"before_first_workspace_dependency\": before_first_workspace_dependency,\r\n# # # # # #         \"first_workspace_dependency_onwards\": first_workspace_dependency_onwards,\r\n# # # # # #     }\r\n# # # # # # \r\n# # # # # # ##### OLD CONTENT OF THIS FILE\r\n# # # # # # \r\n# # # # # # # # {{before_first_workspace_dependency}}\r\n# # # # # # # # cursor_hero_{{crate_name}}_tool = { path = \"./crates/{{crate_name}}_tool\" }\r\n# # # # # # # # {{first_workspace_dependency_onwards}\r\n# # # # # # # \r\n# # # # # # # \r\n# # # # # # # \r\n# # # # # # # def gather_variables(text: str) -> dict[str,str]:\r\n# # # # # # #     find = \"some part of the file\"\r\n# # # # # # #     include = true    index = text.find(find)\r\n# # # # # # #     assert index != -1, f\"Coult not find `{find}`\"\r\n# # # # # # #     before_first_workspace_dependency, remaining = text[:index],text[index:]\r\n# # # # # # # \r\n# # # # # # #     find = \"some part of the file\"\r\n# # # # # # #     include = true    index = remaining.find(find)\r\n# # # # # # #     assert index != -1, f\"Coult not find `{find}`\"\r\n# # # # # # #     first_workspace_dependency_onwards, remaining = remaining[:index],remaining[index:]\r\n# # # # # # # \r\n# # # # # # #     return {\r\n# # # # # # #         \"before_first_workspace_dependency\": before_first_workspace_dependency,\r\n# # # # # # #         \"first_workspace_dependency_onwards\": first_workspace_dependency_onwards,\r\n# # # # # # #     }\r\n# # # # # # # \r\n# # # # # # # ##### OLD CONTENT OF THIS FILE\r\n# # # # # # # \r\n# # # # # # # # # {{before_first_workspace_dependency}}\r\n# # # # # # # # # cursor_hero_{{crate_name}}_tool = { path = \"./crates/{{crate_name}}_tool\" }\r\n# # # # # # # # # {{first_workspace_dependency_onw\r\n# # # # # # # # \r\n# # # # # # # # \r\n# # # # # # # # \r\n# # # # # # # # def gather_variables(text: str) -> dict[str,str]:\r\n# # # # # # # #     find = \"some part of the file\"\r\n# # # # # # # #     include = true    index = text.find(find)\r\n# # # # # # # #     assert index != -1, f\"Coult not find `{find}`\"\r\n# # # # # # # #     before_first_workspace_dependency, remaining = text[:index],text[index:]\r\n# # # # # # # # \r\n# # # # # # # #     find = \"some part of the file\"\r\n# # # # # # # #     include = true    index = remaining.find(find)\r\n# # # # # # # #     assert index != -1, f\"Coult not find `{find}`\"\r\n# # # # # # # #     first_workspace_dependency_onwards, remaining = remaining[:index],remaining[index:]\r\n# # # # # # # # \r\n# # # # # # # #     return {\r\n# # # # # # # #         \"before_first_workspace_dependency\": before_first_workspace_dependency,\r\n# # # # # # # #         \"first_workspace_dependency_onwards\": first_workspace_dependency_onwards,\r\n# # # # # # # #     }\r\n# # # # # # # # \r\n# # # # # # # # ##### OLD CONTENT OF THIS FILE# # {{before_first_workspace_dependency}}\r\n# # # # # # # # # # cursor_hero_{{crate_name}}_tool = { path = \"./crates/{{crate_name}}_tool\" }\r\n# # # # # # # # # \r\n# # # # # # # # # \r\n# # # # # # # # # \r\n# # # # # # # # # \r\n# # # # # # # # # def gather_variables(text: str) -> dict[str,str]:\r\n# # # # # # # # #     find = \"some part of the file\"\r\n# # # # # # # # #     include = true    index = text.find(find)\r\n# # # # # # # # #     assert index != -1, f\"Coult not find `{find}`\"\r\n# # # # # # # # #     before_first_workspace_dependency, remaining = text[:index],text[index:]\r\n# # # # # # # # # \r\n# # # # # # # # #     find = \"some part of the file\"\r\n# # # # # # # # #     include = true    index = remaining.find(find)\r\n# # # # # # # # #     assert index != -1, f\"Coult not find `{find}`\"\r\n# # # # # # # # #     first_workspace_dependency_onwards, remaining = remaining[:index],remaining[index:]\r\n# # # # # # # # # \r\n# # # # # # # # #     return {\r\n# # # # # # # # #         \"before_first_workspace_dependency\": before_first_workspace_dependency,\r\n# # # # # # # # #         \"first_workspace_dependency_onwards\": first_workspace_dependency_onwards,\r\n# # # # # # # # #     }\r\n# # # # # # # # \r\n# # # # # # # # \r\n# # # # # # # \r\n# # # # # # # \r\n# # # # # # \r\n# # # # # # \r\n# # # # # \r\n# # # # # \r\n# # # # \r\n# # # # \r\n# # # \r\n# # # \r\n# # \r\n# # \r\n# \r\n# \r\n\r\n\r\n##### WORKSPACE CONTENT\r\n#[package]\r\n#name = \"cursor_hero\"\r\n#version = \"0.3.0\"\r\n#edition = \"2021\"\r\n#\r\n#[workspace]\r\n#members = [\"crates/*\", \"other/gamepad_hell\", \"other/uparrow-enter\"]\r\n#\r\n## See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n#\r\n#[workspace.dependencies]\r\n#cursor_hero_environment_types = { path = \"./crates/environment_types\" }\r\n#cursor_hero_chat_types = { path = \"./crates/chat_types\" }\r\n#cursor_hero_chat = { path = \"./crates/chat\" }\r\n#cursor_hero_tts = { path = \"./crates/tts\" }\r\n#cursor_hero_tts_types = { path = \"./crates/tts_types\" }\r\n#cursor_hero_observation_types = { path = \"./crates/observation_types\" }\r\n#cursor_hero_observation = { path = \"./crates/observation\" }\r\n#cursor_hero_inference_types = { path = \"./crates/inference_types\" }\r\n#cursor_hero_inference = { path = \"./crates/inference\" }\r\n#cursor_hero_movement_tool_types = { path = \"./crates/movement_tool_types\" }\r\n#cursor_hero_movement_tool = { path = \"./crates/movement_tool\" }\r\n#cursor_hero_character_types = { path = \"./crates/character_types\" }\r\n#cursor_hero_agent_types = { path = \"./crates/agent_types\" }\r\n#cursor_hero_physics_debug = { path = \"./crates/physics_debug\" }\r\n#cursor_hero_math = { path = \"./crates/math\" }\r\n#cursor_hero_pointer_types = { path = \"./crates/pointer_types\" }\r\n#cursor_hero_toolbelt_types = { path = \"./crates/toolbelt_types\" }\r\n#cursor_hero_sprint_tool_types = { path = \"./crates/sprint_tool_types\" }\r\n#cursor_hero_sprint_tool = { path = \"./crates/sprint_tool\" }\r\n#cursor_hero_agent = { path = \"./crates/agent\" }\r\n#cursor_hero_taskbar = { path = \"./crates/taskbar\" }\r\n#cursor_hero_environment_nametag = { path = \"./crates/environment_nametag\" }\r\n#cursor_hero_environment = { path = \"./crates/environment\" }\r\n#cursor_hero_xelu_prompts = { path = \"./crates/xelu_prompts\" }\r\n#cursor_hero_pause_tool = { path = \"./crates/pause_tool\" }\r\n#cursor_hero_wallpaper = { path = \"./crates/wallpaper\" }\r\n#cursor_hero_cursor_mirror = { path = \"./crates/cursor_mirror\" }\r\n#cursor_hero_hover = { path = \"./crates/hover\" }\r\n#cursor_hero_pressure_plate = { path = \"./crates/pressure_plate\" }\r\n#cursor_hero_level_bounds = { path = \"./crates/level_bounds\" }\r\n#cursor_hero_bevy = { path = \"./crates/bevy\" }\r\n#cursor_hero_input = { path = \"./crates/input\" }\r\n#cursor_hero_camera = { path = \"./crates/camera\" }\r\n#cursor_hero_character = { path = \"./crates/character\" }\r\n#cursor_hero_data = { path = \"./crates/data\" }\r\n#cursor_hero_metrics = { path = \"./crates/metrics\" }\r\n#cursor_hero_click_drag_character_movement = { path = \"./crates/click_drag_character_movement\" }\r\n#cursor_hero_physics = { path = \"./crates/physics\" }\r\n#cursor_hero_pointer = { path = \"./crates/pointer\" }\r\n#cursor_hero_screen = { path = \"./crates/screen\" }\r\n#cursor_hero_toolbelt = { path = \"./crates/toolbelt\" }\r\n#cursor_hero_tools = { path = \"./crates/tools\" }\r\n#cursor_hero_ui = { path = \"./crates/ui\" }\r\n#cursor_hero_winutils = { path = \"./crates/winutils\" }\r\n#cursor_hero_restart_memory = { path = \"./crates/restart_memory\" }\r\n#cursor_hero_version = { path = \"./crates/version\" }\r\n#cursor_hero_plugins = { path = \"./crates/plugins\" }\r\n#cursor_hero_icon = { path = \"./crates/icon\" }\r\n##inline_tweak = {git = \"https://github.com/Uriopass/inline_tweak\", version = \"1.1.0\", tag = \"v1.1.0\"} # features=[\"derive\"]\r\n#anyhow = \"1.0.75\"\r\n#glam = \"0.25.0\"\r\n## bevy = { path = \"../bevy\", features = [\"dynamic_linking\"] }\r\n#bevy = { version = \"0.12.1\", git = \"https://github.com/TeamDman/bevy.git\", branch = \"cursor_hero\" }\r\n#bevy-inspector-egui = { version = \"0.22.1\", git = \"https://github.com/TeamDman/bevy-inspector-egui.git\", branch = \"cursor_hero\" }\r\n#bevy_xpbd_2d = { git = \"https://github.com/TeamDman/bevy_xpbd.git\", branch = \"cursor_hero\", features = [\r\n#  \"simd\",\r\n#  \"parallel\",\r\n#] }\r\n#bevy_egui = { git = \"https://github.com/TeamDman/bevy_egui.git\", branch = \"cursor_hero\", version = \"0.24\" }\r\n## enigo = {git = \"https://github.com/TeamDman/enigo\", branch = \"cursor_hero\", version = \"0.1.3\"}\r\n## enigo = {path = \"../../rust/enigo\", version = \"0.1.3\"}\r\n#enigo = \"0.2.0-rc2\"\r\n#egui = \"0.24\"\r\n#crossbeam-channel = \"0.5.8\"\r\n#itertools = \"0.12.0\"\r\n#raw-window-handle = \"0.5.2\"\r\n#leafwing-input-manager = { git = \"https://github.com/TeamDman/leafwing-input-manager.git\", branch = \"cursor_hero\" }\r\n#windows = \"0.51.1\"\r\n#indexmap = \"2.1.0\"\r\n#image = \"0.24.7\"\r\n#screenshots = \"0.8.4\"\r\n#uiautomation = \"0.7.3\"\r\n#serde = { version = \"1.0\", features = [\"derive\"] }\r\n#serde_json = \"1.0\"\r\n#tokio = { version = \"1.32.0\", features = [\"net\", \"full\"] }\r\n#tokio-named-pipes = \"0.1.0\"\r\n#syn = { version = \"2.0.48\", features = [\"full\", \"visit-mut\", \"visit\"] }\r\n#quote = \"1.0.35\"\r\n#proc-macro2 = \"1.0.76\"\r\n#bevy_embedded_assets = { version = \"0.9.1\", git = \"https://github.com/TeamDman/bevy_embedded_assets.git\", branch = \"cursor_hero\" }\r\n#winit = \"0.28.7\"\r\n#fxhash = \"0.2.1\"\r\n#widestring = \"1.0.2\"\r\n#winreg = \"0.52.0\"\r\n#rand = \"0.8.5\"\r\n#ollama-rs = \"0.1.6\"\r\n#reqwest = \"0.11.24\"\r\n#urlencoding = \"2.1.3\"\r\n#chrono = \"0.4.33\"\r\n#\r\n#[dependencies]\r\n#cursor_hero_plugins = { workspace = true }\r\n#cursor_hero_version = { workspace = true }\r\n#bevy = { workspace = true }\r\n#\r\n#\r\n#[dev-dependencies]\r\n#bevy = { workspace = true, features = [\"dynamic_linking\"] }\r\n#\r\n#\r\n#[build-dependencies]\r\n#embed-resource = \"1.6.3\"\r\n#\r\n#[profile.dev]\r\n#opt-level = 1\r\n#\r\n#[profile.dev.package.\"*\"]\r\n#opt-level = 3\r\n#\r\n## [patch.crates-io]\r\n## winit = { path = \"D:/Repos/rust/winit\" }\r\n#\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\environment_nametag\\src\\environment_nametag_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse bevy::utils::HashSet;\r\nuse cursor_hero_bevy::prelude::Vec2ToRect;\r\nuse cursor_hero_environment_types::prelude::*;\r\nuse cursor_hero_screen::screen_plugin::Screen;\r\nuse cursor_hero_screen::screen_plugin::ScreenParent;\r\n\r\npub struct EnvironmentNametagPlugin;\r\n\r\nimpl Plugin for EnvironmentNametagPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_event::<NametagEvent>();\r\n        app.add_systems(Update, spawn_nametags_in_new_environments);\r\n        app.add_systems(Update, recalc_new_screen_nametags);\r\n        app.add_systems(Update, handle_nametag_update_event);\r\n        app.add_systems(Update, handle_nametag_recalculate_position_event);\r\n        app.register_type::<Nametag>();\r\n    }\r\n}\r\n\r\n#[allow(clippy::type_complexity)]\r\nfn spawn_nametags_in_new_environments(\r\n    mut environment_reader: EventReader<PopulateEnvironmentEvent>,\r\n    mut commands: Commands,\r\n    environment_query: Query<&Name, Or<(With<HostEnvironment>, With<GameEnvironment>)>>,\r\n    asset_server: Res<AssetServer>,\r\n) {\r\n    for event in environment_reader.read() {\r\n        let Ok(environment_name) = environment_query.get(event.environment_id) else {\r\n            continue;\r\n        };\r\n        let environment_id = event.environment_id;\r\n        info!(\r\n            \"Spawning nametags for environment {:?} ({})\",\r\n            environment_id, environment_name\r\n        );\r\n        commands.entity(environment_id).with_children(|parent| {\r\n            parent.spawn((\r\n                Text2dBundle {\r\n                    text: Text::from_section(\r\n                        environment_name.to_string(),\r\n                        TextStyle {\r\n                            font_size: 72.0,\r\n                            font: asset_server\r\n                                .load(\"fonts/kenney_kenney-fonts/Fonts/Kenney Future Narrow.ttf\"),\r\n                            color: Color::WHITE,\r\n                        },\r\n                    )\r\n                    .with_alignment(TextAlignment::Center),\r\n                    transform: Transform::from_xyz(0.0, 200.0, 1.0).with_scale(Vec3::splat(4.0)),\r\n                    ..default()\r\n                },\r\n                Nametag,\r\n                Name::new(\"Nametag\"),\r\n            ));\r\n        });\r\n    }\r\n}\r\n\r\nfn recalc_new_screen_nametags(\r\n    mut nametag_events: EventWriter<NametagEvent>,\r\n    screen_query: Query<&Parent, Added<Screen>>,\r\n    screen_parent_query: Query<&Parent, With<ScreenParent>>,\r\n) {\r\n    for new_screen_parent_id in screen_query.iter() {\r\n        if let Ok(environment_id) = screen_parent_query.get(new_screen_parent_id.get()) {\r\n            info!(\r\n                \"Detected new screen {:?} in environment {:?}, sending recalculate position event\",\r\n                new_screen_parent_id, environment_id\r\n            );\r\n            nametag_events.send(NametagEvent::RecalculatePosition {\r\n                environment_id: environment_id.get(),\r\n            });\r\n        }\r\n    }\r\n}\r\n\r\nfn handle_nametag_update_event(\r\n    mut nametag_events: EventReader<NametagEvent>,\r\n    environment_query: Query<&Children, With<EnvironmentKind>>,\r\n    mut nametag_query: Query<(&mut Text, &mut Transform), With<Nametag>>,\r\n) {\r\n    for nametag_event in nametag_events.read() {\r\n        if let NametagEvent::Update {\r\n            environment_id,\r\n            name,\r\n        } = nametag_event\r\n        {\r\n            info!(\r\n                \"Updating nametag for environment {:?} to {}\",\r\n                environment_id, name\r\n            );\r\n            if let Ok(environment_children) = environment_query.get(*environment_id) {\r\n                for child in environment_children.iter() {\r\n                    if let Ok((mut nametag_text, _)) = nametag_query.get_mut(*child) {\r\n                        nametag_text.sections[0].value = name.clone();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n#[allow(clippy::type_complexity)]\r\nfn handle_nametag_recalculate_position_event(\r\n    mut nametag_events: EventReader<NametagEvent>,\r\n    environment_query: Query<&Children, With<EnvironmentKind>>,\r\n    mut nametag_query: Query<(&mut Text, &mut Transform), (With<Nametag>, Without<Screen>)>,\r\n    screen_parent_query: Query<&Children, With<ScreenParent>>,\r\n    screen_query: Query<(&Sprite, &GlobalTransform), (With<Screen>, Without<Nametag>)>,\r\n) {\r\n    let mut debounce = HashSet::new();\r\n    for nametag_event in nametag_events.read() {\r\n        if let NametagEvent::RecalculatePosition { environment_id } = nametag_event {\r\n            if debounce.contains(environment_id) {\r\n                debug!(\r\n                    \"Debounced recalculate position event for environment {:?}, skipping\",\r\n                    environment_id\r\n                );\r\n                continue;\r\n            }\r\n            info!(\r\n                \"Recalculating nametag position for environment {:?}\",\r\n                environment_id\r\n            );\r\n            debounce.insert(environment_id);\r\n            if let Ok(environment_children) = environment_query.get(*environment_id) {\r\n                let mut max_extents = Rect::default();\r\n                for environment_child_id in environment_children.iter() {\r\n                    // debug!(\r\n                    //     \"Checking environment child {:?} for environment {:?}\",\r\n                    //     environment_child_id, environment_id\r\n                    // );\r\n                    if let Ok(screen_parent_children) =\r\n                        screen_parent_query.get(*environment_child_id)\r\n                    {\r\n                        debug!(\r\n                            \"Found screen parent children {:?} for environment {:?}\",\r\n                            screen_parent_children, environment_id\r\n                        );\r\n                        for screen_id in screen_parent_children.iter() {\r\n                            if let Ok((screen_sprite, screen_transform)) =\r\n                                screen_query.get(*screen_id)\r\n                            {\r\n                                if let Some(screen_size) = screen_sprite.custom_size {\r\n                                    max_extents =\r\n                                        max_extents.union(screen_size.as_size_of_rect_with_center(\r\n                                            &screen_transform.translation().xy(),\r\n                                        ));\r\n                                } else {\r\n                                    warn!(\r\n                                        \"Screen {:?} did not have custom size, skipping\",\r\n                                        screen_id\r\n                                    );\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                if max_extents.is_empty() {\r\n                    warn!(\r\n                        \"Max extents for environment {:?} was empty, skipping\",\r\n                        environment_id\r\n                    );\r\n                    continue;\r\n                }\r\n                info!(\r\n                    \"Max extents for environment {:?} is {:?}\",\r\n                    environment_id, max_extents\r\n                );\r\n                for child in environment_children.iter() {\r\n                    if let Ok((_, mut nametag_transform)) = nametag_query.get_mut(*child) {\r\n                        nametag_transform.translation.x = max_extents.center().x;\r\n                        nametag_transform.translation.y = max_extents.max.y + 200.0;\r\n                    }\r\n                }\r\n            } else {\r\n                warn!(\r\n                    \"Could not find environment children for environment {:?}\",\r\n                    environment_id\r\n                );\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\tools\\src\\talk_tool.rs\r\n\r\n````rust\r\nuse std::thread;\r\n\r\nuse bevy::prelude::*;\r\nuse cursor_hero_voice_to_text_types::voice_to_text_types::VoiceToTextCommandEvent;\r\nuse cursor_hero_voice_to_text_types::voice_to_text_types::VoiceToTextStatus;\r\nuse cursor_hero_voice_to_text_types::voice_to_text_types::VoiceToTextStatusEvent;\r\nuse leafwing_input_manager::prelude::*;\r\n\r\nuse crossbeam_channel::bounded;\r\nuse crossbeam_channel::Sender;\r\nuse cursor_hero_winutils::win_mouse::press_f23_key;\r\nuse cursor_hero_winutils::win_mouse::release_f23_key;\r\n\r\nuse cursor_hero_toolbelt_types::prelude::*;\r\n\r\nuse crate::prelude::*;\r\n\r\npub struct TalkToolPlugin;\r\n\r\nimpl Plugin for TalkToolPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<TalkTool>();\r\n        app.add_plugins(InputManagerPlugin::<TalkToolAction>::default());\r\n        app.add_systems(Startup, spawn_worker_thread);\r\n        app.add_systems(Update, toolbelt_events);\r\n        app.add_systems(Update, handle_input);\r\n    }\r\n}\r\n\r\n#[derive(Component, Reflect, Default)]\r\nstruct TalkTool;\r\n\r\nfn toolbelt_events(\r\n    mut commands: Commands,\r\n    asset_server: Res<AssetServer>,\r\n    mut reader: EventReader<ToolbeltPopulateEvent>,\r\n) {\r\n    for event in reader.read() {\r\n        let (ToolbeltLoadout::Keyboard | ToolbeltLoadout::Default) = event.loadout else {\r\n            continue;\r\n        };\r\n        {\r\n            ToolSpawnConfig::<TalkTool, TalkToolAction>::new(TalkTool, event.id, event)\r\n                .with_src_path(file!().into())\r\n                .guess_name(file!())\r\n                .guess_image(file!(), &asset_server, \"png\")\r\n                .with_description(\"Presses F23\")\r\n                .spawn(&mut commands);\r\n        }\r\n    }\r\n}\r\n\r\n#[derive(Actionlike, PartialEq, Eq, Clone, Copy, Hash, Debug, Reflect)]\r\nenum TalkToolAction {\r\n    PushToTalk,\r\n    ToggleAlwaysOn,\r\n}\r\n\r\n#[derive(Debug)]\r\nenum Motion {\r\n    Up,\r\n    Down,\r\n}\r\n\r\n#[derive(Debug)]\r\nenum ThreadMessage {\r\n    ListenButton(Motion),\r\n}\r\n\r\n#[derive(Resource)]\r\nstruct Bridge {\r\n    pub sender: Sender<ThreadMessage>,\r\n}\r\n\r\nimpl TalkToolAction {\r\n    fn default_wheel_gamepad_binding(&self) -> UserInput {\r\n        match self {\r\n            Self::PushToTalk => GamepadButtonType::Select.into(),\r\n            Self::ToggleAlwaysOn => GamepadButtonType::Start.into(),\r\n        }\r\n    }\r\n\r\n    fn default_wheel_mkb_binding(&self) -> UserInput {\r\n        match self {\r\n            Self::PushToTalk => KeyCode::ShiftRight.into(),\r\n            Self::ToggleAlwaysOn => KeyCode::Scroll.into(),\r\n        }\r\n    }\r\n    fn talk_wheel_gamepad_binding(&self) -> UserInput {\r\n        match self {\r\n            Self::PushToTalk => GamepadButtonType::Select.into(),\r\n            Self::ToggleAlwaysOn => GamepadButtonType::Start.into(),\r\n        }\r\n    }\r\n\r\n    fn talk_wheel_mkb_binding(&self) -> UserInput {\r\n        match self {\r\n            Self::PushToTalk => KeyCode::ShiftRight.into(),\r\n            Self::ToggleAlwaysOn => KeyCode::Scroll.into(),\r\n        }\r\n    }\r\n}\r\nimpl ToolAction for TalkToolAction {\r\n    fn default_input_map(event: &ToolbeltPopulateEvent) -> Option<InputMap<TalkToolAction>> {\r\n        match event.loadout {\r\n            ToolbeltLoadout::Default => Some(Self::with_defaults(\r\n                Self::default_wheel_gamepad_binding,\r\n                Self::default_wheel_mkb_binding,\r\n            )),\r\n            ToolbeltLoadout::Keyboard => Some(Self::with_defaults(\r\n                Self::talk_wheel_gamepad_binding,\r\n                Self::talk_wheel_mkb_binding,\r\n            )),\r\n            _ => None,\r\n        }\r\n    }\r\n}\r\n\r\nfn spawn_worker_thread(mut commands: Commands) {\r\n    let (tx, rx) = bounded::<_>(10);\r\n    commands.insert_resource(Bridge { sender: tx });\r\n    thread::spawn(move || loop {\r\n        let action = match rx.recv() {\r\n            Ok(action) => action,\r\n            Err(e) => {\r\n                error!(\"Failed to receive thread message, exiting: {:?}\", e);\r\n                break;\r\n            }\r\n        };\r\n        debug!(\"Worker received thread message: {:?}\", action);\r\n        match match action {\r\n            ThreadMessage::ListenButton(Motion::Down) => press_f23_key(),\r\n            ThreadMessage::ListenButton(Motion::Up) => release_f23_key(),\r\n        } {\r\n            Ok(_) => {}\r\n            Err(e) => {\r\n                error!(\"Failed to handle event {:?}: {:?}\", action, e);\r\n            }\r\n        }\r\n    });\r\n}\r\n\r\nfn handle_input(\r\n    tools: Query<&ActionState<TalkToolAction>, With<ActiveTool>>,\r\n    bridge: ResMut<Bridge>,\r\n    mut voice_command_events: EventWriter<VoiceToTextCommandEvent>,\r\n    mut voice_status_events: EventWriter<VoiceToTextStatusEvent>,\r\n    mut voice_status: ResMut<VoiceToTextStatus>,\r\n) {\r\n    for t_act in tools.iter() {\r\n        if t_act.just_pressed(TalkToolAction::PushToTalk) {\r\n            info!(\"Listen button pressed\");\r\n            match bridge\r\n                .sender\r\n                .send(ThreadMessage::ListenButton(Motion::Down))\r\n            {\r\n                Ok(_) => {}\r\n                Err(e) => {\r\n                    error!(\"Failed to send thread message: {:?}\", e);\r\n                }\r\n            }\r\n        }\r\n        if t_act.just_released(TalkToolAction::PushToTalk) {\r\n            info!(\"Listen button released\");\r\n            match bridge.sender.send(ThreadMessage::ListenButton(Motion::Up)) {\r\n                Ok(_) => {}\r\n                Err(e) => {\r\n                    error!(\"Failed to send thread message: {:?}\", e);\r\n                }\r\n            }\r\n        }\r\n        if t_act.just_pressed(TalkToolAction::ToggleAlwaysOn) {\r\n            let VoiceToTextStatus::Alive { api_key, listening } = voice_status.clone() else {\r\n                warn!(\"VoiceToTextStatus not Alive, ignoring event\");\r\n                continue;\r\n            };\r\n            let new_status = VoiceToTextStatus::Alive {\r\n                api_key: api_key.clone(),\r\n                listening: !listening,\r\n            };\r\n\r\n            let event = VoiceToTextCommandEvent::SetListening {\r\n                listening: !listening,\r\n                api_key,\r\n            };\r\n            info!(\"Sending event: {:?}\", event);\r\n            voice_command_events.send(event);\r\n\r\n            let event = VoiceToTextStatusEvent::Changed {\r\n                old_status: voice_status.clone(),\r\n                new_status: new_status.clone(),\r\n            };\r\n            info!(\"Sending event: {:?}\", event);\r\n            voice_status_events.send(event);\r\n\r\n            *voice_status = new_status;\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui_automation\\src\\resolve_vscode.rs\r\n\r\n````rust\r\nuse crate::gather_children::GatherChildrenable;\r\nuse crate::gather_children::StopBehaviour;\r\nuse anyhow::Context;\r\nuse anyhow::Result;\r\nuse bevy::math::IVec2;\r\nuse cursor_hero_ui_automation_types::prelude::*;\r\nuse itertools::Itertools;\r\nuse uiautomation::types::TreeScope;\r\nuse uiautomation::types::UIProperty;\r\nuse uiautomation::variants::Variant;\r\nuse uiautomation::UIAutomation;\r\nuse uiautomation::UIElement;\r\nuse uiautomation::UITreeWalker;\r\n\r\npub(crate) fn resolve_vscode(\r\n    elem: &UIElement,\r\n    automation: &UIAutomation,\r\n    focused: bool,\r\n) -> Result<AppWindow> {\r\n    let walker = automation.create_tree_walker().context(\"creating walker\")?;\r\n    let root = elem;\r\n\r\n    let temp = root\r\n        .drill(&walker, vec![0, 0, 0, 0, 0, 1])\r\n        .context(\"drilling temp\")?;\r\n\r\n    let body = temp\r\n        .drill(&walker, vec![1, 0, 1])\r\n        .context(\"drilling body\")?;\r\n    let body = match resolve_body(&body, &walker) {\r\n        Ok(body) => body,\r\n        Err(e) => {\r\n            return Err(e.context(\"resolving body\"));\r\n        }\r\n    };\r\n\r\n    let footer = temp.drill(&walker, vec![2, 0]).context(\"drilling footer\")?;\r\n    let footer = resolve_footer(&footer, automation).context(\"resolving footer\")?;\r\n    drop(temp);\r\n\r\n    Ok(AppWindow::VSCode(VSCodeWindow {\r\n        focused,\r\n        header: VSCodeWindowHeader {},\r\n        body,\r\n        footer,\r\n    }))\r\n}\r\n\r\nfn resolve_body(body: &UIElement, walker: &UITreeWalker) -> Result<VSCodeWindowBody> {\r\n    let workbench_parts_editor = body\r\n        .drill(walker, vec![0, 0, 1, 0, 0])\r\n        .context(\"drilling to find editor area\")?;\r\n    if workbench_parts_editor.get_automation_id()? != EditorArea::get_expected_automation_id() {\r\n        return Err(AppResolveError::BadStructure(format!(\r\n            \"workbench_parts_editor has wrong automation id, got unexpected element {:?}\",\r\n            workbench_parts_editor.get_runtime_id(),\r\n        ))\r\n        .into());\r\n    }\r\n    let editor_groups = workbench_parts_editor\r\n        .drill(walker, vec![0, 0, 0, 1])\r\n        .context(\"drilling to find editor groups\")?\r\n        .gather_children(walker, &StopBehaviour::EndOfSiblings)\r\n        .into_iter()\r\n        .map(|group_elem| {\r\n            let tab_container = group_elem\r\n                .drill(walker, vec![0, 0, 0])\r\n                .context(\"drilling to find editor groups tab container\")?;\r\n            let selected: Option<String> = tab_container\r\n                .get_property_value(UIProperty::SelectionSelection)?\r\n                .try_into()\r\n                .ok();\r\n            let group_tabs = tab_container\r\n                .gather_children(walker, &StopBehaviour::EndOfSiblings)\r\n                .into_iter()\r\n                .map(|group_tab_elem| {\r\n                    let title = group_tab_elem.get_name()?;\r\n                    let active = selected == Some(title.clone());\r\n                    Ok(EditorTab { title, active })\r\n                })\r\n                .filter_map(|r: Result<EditorTab>| r.ok())\r\n                .collect();\r\n            let content_elem = group_elem\r\n                .drill(walker, vec![1, 0, 0, 1])\r\n                .context(\"drilling to find group content\")?;\r\n            let content = content_elem\r\n                .get_property_value(UIProperty::LegacyIAccessibleValue)\r\n                .map(|variant| variant.to_string())\r\n                .map(|text_content| EditorContent {\r\n                    content: text_content,\r\n                })\r\n                .ok();\r\n\r\n            Ok(EditorGroup {\r\n                tabs: group_tabs,\r\n                content,\r\n            })\r\n        })\r\n        .filter_map(|r: Result<EditorGroup>| r.ok())\r\n        .collect();\r\n    let editor_area = EditorArea {\r\n        groups: editor_groups,\r\n    };\r\n\r\n    // let side_nav = state\r\n    //     .get_side_nav_tabs_root_elem()\r\n    //     .drill(walker, vec![0, 0]).context(\"drilling to find side_nav\")?\r\n    //     .gather_children(walker, &StopBehaviour::LastChildEncountered);\r\n    // // println!(\"side_nav: {:?}\", side_nav);\r\n    // let side_nav = side_nav\r\n    //     .into_iter()\r\n    //     .filter(|elem| elem.get_control_type() == Ok(ControlType::TabItem))\r\n    //     .map(|elem| {\r\n    //         let name = elem.get_name()?;\r\n    //         let kind: SideTabKind = SideTabKind::try_from(name)?;\r\n    //         let active = elem\r\n    //             .get_property_value(UIProperty::ExpandCollapseExpandCollapseState)\r\n    //             .map(|v| v.try_into() == Ok(ExpandCollapseState::Expanded as i32))\r\n    //             .unwrap_or_default();\r\n    //         if active {\r\n    //             let view = state\r\n    //                 .get_side_nav_view_root_elem()\r\n    //                 .drill(walker, vec![1]).context(\"drilling to find side tab view\")?;\r\n    //             let view = match view.get_automation_id() {\r\n    //                 Ok(id)\r\n    //                     if Some(id.as_str()) == SideTabKind::Explorer.get_view_automation_id() =>\r\n    //                 {\r\n    //                     fn as_explorer_item(\r\n    //                         walker: &UITreeWalker,\r\n    //                         tree_item: UIElement,\r\n    //                     ) -> Result<ExplorerItem> {\r\n    //                         let label = tree_item.get_name()?;\r\n    //                         let ui_position_in_set = tree_item\r\n    //                             .get_property_value(UIProperty::PositionInSet)?\r\n    //                             .try_into()?;\r\n    //                         let ui_size_of_set = tree_item\r\n    //                             .get_property_value(UIProperty::SizeOfSet)?\r\n    //                             .try_into()?;\r\n    //                         let ui_level = tree_item\r\n    //                             .get_property_value(UIProperty::Level)?\r\n    //                             .try_into()?;\r\n    //                         let bounds = tree_item.get_bounding_rectangle()?.to_bevy_irect();\r\n    //                         let kind = tree_item\r\n    //                             .get_pattern::<UIExpandCollapsePattern>()\r\n    //                             .ok()\r\n    //                             .map(|p| ExplorerItemKind::Directory {\r\n    //                                 expanded: p.get_state() == Ok(ExpandCollapseState::Expanded),\r\n    //                             })\r\n    //                             .unwrap_or(ExplorerItemKind::File);\r\n    //                         let path = tree_item\r\n    //                             .drill(\r\n    //                                 walker,\r\n    //                                 match kind {\r\n    //                                     ExplorerItemKind::File => vec![0, 1, 0],\r\n    //                                     ExplorerItemKind::Directory { .. } => {\r\n    //                                         vec![0, 2, 0]\r\n    //                                     }\r\n    //                                 },\r\n    //                             ).context(\"drilling to find explorer item path\")?\r\n    //                             .get_name()?;\r\n    //                         Ok(ExplorerItem {\r\n    //                             label,\r\n    //                             path,\r\n    //                             ui_position_in_set,\r\n    //                             ui_size_of_set,\r\n    //                             ui_level,\r\n    //                             bounds,\r\n    //                             kind,\r\n    //                         })\r\n    //                     }\r\n    //                     let sticky = view\r\n    //                         .drill(walker, vec![0, 1, 0, 0, 1, 0, 3]).context(\"drilling to find explorer sticky\")?\r\n    //                         .gather_children(walker, &StopBehaviour::EndOfSiblings)\r\n    //                         .into_iter()\r\n    //                         .filter_map(|tree_item| as_explorer_item(walker, tree_item).ok())\r\n    //                         .collect();\r\n    //                     let items = view\r\n    //                         .drill(walker, vec![0, 1, 0, 0, 1, 0, 0]).context(\"drilling to find explorer items\")?\r\n    //                         .gather_children(walker, &StopBehaviour::EndOfSiblings)\r\n    //                         .into_iter()\r\n    //                         .filter_map(|tree_item| as_explorer_item(walker, tree_item).ok())\r\n    //                         .collect();\r\n    //                     View::Explorer { sticky, items }\r\n    //                 }\r\n    //                 _ => {\r\n    //                     View::Unknown {}\r\n    //                     // elem: view.into()\r\n    //                 }\r\n    //             };\r\n\r\n    //             Ok(SideTab::Open {\r\n    //                 kind,\r\n    //                 // button: elem.into(),\r\n    //                 view,\r\n    //             })\r\n    //         } else {\r\n    //             Ok(SideTab::Closed {\r\n    //                 kind,\r\n    //                 // button: elem.into(),\r\n    //             })\r\n    //         }\r\n    //     })\r\n    //     .filter_map(|res: Result<SideTab>| res.ok())\r\n    //     .collect();\r\n\r\n    let right_tab = SideTab::Closed {\r\n        kind: SideTabKind::Explorer,\r\n    };\r\n\r\n    Ok(VSCodeWindowBody {\r\n        editor_area,\r\n        right_tab,\r\n    })\r\n}\r\n\r\nfn resolve_footer(\r\n    footer: &UIElement,\r\n    automation: &UIAutomation,\r\n) -> Result<VSCodeWindowFooter, AppResolveError> {\r\n    let condition = automation.create_property_condition(\r\n        UIProperty::AutomationId,\r\n        Variant::from(\"status.editor.selection\"),\r\n        None,\r\n    )?;\r\n    let cursor_position_elem = footer.find_first(TreeScope::Children, &condition)?;\r\n    let text = cursor_position_elem.get_name()?;\r\n    // \"Ln 218, Col 5\"\r\n    let cursor_position = text\r\n        .split(\", \")\r\n        .map(|part| part.split(' ').last().and_then(|s| s.parse::<usize>().ok()))\r\n        .collect_vec();\r\n    let cursor_position = match cursor_position.as_slice() {\r\n        [Some(line), Some(column)] => IVec2::new(*column as i32, *line as i32),\r\n        _ => {\r\n            return Err(AppResolveError::BadStructure(format!(\r\n                \"Bad cursor position {:?}\",\r\n                cursor_position\r\n            )))\r\n        }\r\n    };\r\n    Ok(VSCodeWindowFooter { cursor_position })\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\window_position\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_window_position\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\ncursor_hero_bevy = { workspace = true }\r\ncursor_hero_window_position_types = { workspace = true }\r\ncursor_hero_toolbelt_types = { workspace = true }\r\ncursor_hero_tools = { workspace = true }\r\ncursor_hero_winutils = { workspace = true }\r\ncursor_hero_math = { workspace = true }\r\nimage = { workspace = true}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\templates\\patterns\\new_plugin_with_types\\crates\\{{crate_name}}\\src\\{{crate_name}}_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n\r\npub struct {{crate_name_pascal}}Plugin;\r\n\r\nimpl Plugin for {{crate_name_pascal}}Plugin {\r\n    fn build(&self, app: &mut App) {\r\n    }\r\n}\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\agent_types\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_agent_types\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\tools\\src\\keyboard_wheel_tool.rs\r\n\r\n````rust\r\nuse crate::prelude::*;\r\nuse bevy::prelude::*;\r\nuse cursor_hero_toolbelt_types::prelude::*;\r\n\r\npub struct KeyboardWheelToolPlugin;\r\n\r\nimpl Plugin for KeyboardWheelToolPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<KeyboardWheelTool>();\r\n        app.add_systems(Update, toolbelt_events);\r\n        app.add_systems(Update, tick);\r\n    }\r\n}\r\n\r\n#[derive(Component, Reflect, Default)]\r\nstruct KeyboardWheelTool;\r\n\r\nfn toolbelt_events(\r\n    mut commands: Commands,\r\n    asset_server: Res<AssetServer>,\r\n    mut reader: EventReader<ToolbeltPopulateEvent>,\r\n) {\r\n    for event in reader.read() {\r\n        let ToolbeltLoadout::Default = event.loadout else {\r\n            continue;\r\n        };\r\n        ToolSpawnConfig::<KeyboardWheelTool, NoInputs>::new(KeyboardWheelTool, event.id, event)\r\n            .with_src_path(file!().into())\r\n            .guess_name(file!())\r\n            .guess_image(file!(), &asset_server, \"png\")\r\n            .with_description(\"Swaps to keyboard tools\")\r\n            .with_starting_state(StartingState::Inactive)\r\n            .spawn(&mut commands);\r\n    }\r\n}\r\n\r\nfn tick(\r\n    mut commands: Commands,\r\n    tool_query: Query<&Parent, (Added<ActiveTool>, With<KeyboardWheelTool>)>,\r\n    mut toolbelt_events: EventWriter<ToolbeltPopulateEvent>,\r\n) {\r\n    for toolbelt_id in tool_query.iter() {\r\n        info!(\"Switching toolbelt {:?} to keyboard tools\", toolbelt_id);\r\n        let toolbelt_id = toolbelt_id.get();\r\n        commands.entity(toolbelt_id).despawn_descendants();\r\n        toolbelt_events.send(ToolbeltPopulateEvent {\r\n            id: toolbelt_id,\r\n            loadout: ToolbeltLoadout::Keyboard,\r\n        });\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\window_position_types\\win_icons.rs\r\n\r\n````rust\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\fullscreen_tool_types\\src\\lib.rs\r\n\r\n````rust\r\npub mod fullscreen_tool_types;\r\npub mod fullscreen_tool_types_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::fullscreen_tool_types::*;\r\n    pub use crate::fullscreen_tool_types_plugin::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\tools\\src\\tool_spawning.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse bevy::utils::HashMap;\r\nuse bevy_xpbd_2d::prelude::*;\r\nuse cursor_hero_host_fs_types::host_fs_types::HostPath;\r\nuse cursor_hero_pointer_types::prelude::*;\r\n\r\nuse cursor_hero_toolbelt_types::prelude::*;\r\nuse leafwing_input_manager::prelude::*;\r\nuse std::path::Path;\r\nuse std::path::PathBuf;\r\n\r\n#[derive(Actionlike, PartialEq, Eq, Clone, Copy, Hash, Debug, Reflect)]\r\npub enum NoInputs {}\r\n\r\nimpl ToolAction for NoInputs {\r\n    fn default_input_map(_event: &ToolbeltPopulateEvent) -> Option<InputMap<Self>> {\r\n        None\r\n    }\r\n}\r\n\r\npub struct ToolSpawnConfig<T, Action>\r\nwhere\r\n    T: Bundle,\r\n    Action: ToolAction + Actionlike,\r\n{\r\n    tag: T,\r\n    event: ToolbeltPopulateEvent,\r\n    name: String,\r\n    description: String,\r\n    display_actions: HashMap<String, Vec<UserInput>>,\r\n    texture: Handle<Image>,\r\n    toolbelt_id: Entity,\r\n    starting_state: StartingState,\r\n    size: Option<Vec2>,\r\n    input_map: Option<InputMap<Action>>,\r\n    src_path: Option<PathBuf>,\r\n}\r\n\r\nimpl<T, Action> ToolSpawnConfig<T, Action>\r\nwhere\r\n    T: Bundle,\r\n    Action: ToolAction + Actionlike + core::fmt::Debug,\r\n{\r\n    pub fn new(tag: T, toolbelt_id: Entity, event: &ToolbeltPopulateEvent) -> Self {\r\n        Self {\r\n            tag,\r\n            event: *event,\r\n            name: \"Unnamed Tool\".to_string(),\r\n            description: \"Who knows what this does?\".to_string(),\r\n            texture: Handle::default(),\r\n            toolbelt_id,\r\n            starting_state: StartingState::Active,\r\n            size: Some(Vec2::new(100.0, 100.0)),\r\n            input_map: None,\r\n            display_actions: HashMap::new(),\r\n            src_path: None,\r\n        }\r\n        .with_input_map(Action::default_input_map(event))\r\n    }\r\n\r\n    pub fn with_src_path(mut self, path: PathBuf) -> Self {\r\n        self.src_path = Some(path);\r\n        self\r\n    }\r\n\r\n    pub fn with_name(mut self, name: String) -> Self {\r\n        self.name = name;\r\n        self\r\n    }\r\n\r\n    pub fn with_description(mut self, description: &'static str) -> Self {\r\n        self.description = description.to_string();\r\n        self\r\n    }\r\n\r\n    pub fn guess_name(mut self, file_path: &str) -> Self {\r\n        self.name = Self::format_tool_name_from_source(file_path);\r\n        self\r\n    }\r\n\r\n    pub fn with_input_map(mut self, input_map: Option<InputMap<Action>>) -> Self {\r\n        self.display_actions = match input_map {\r\n            None => HashMap::new(),\r\n            Some(ref input_map) => input_map\r\n                .iter()\r\n                .map(|v| (format!(\"{:?}\", v.0), v.1.clone()))\r\n                .collect(),\r\n        };\r\n        self.input_map = input_map;\r\n        self\r\n    }\r\n\r\n    fn format_tool_name_from_source(file_path: &str) -> String {\r\n        // Extract the file name from the path\r\n        Self::clean_name(file_path)\r\n            .split('_')\r\n            .map(|word| {\r\n                word.chars()\r\n                    .enumerate()\r\n                    .map(|(i, c)| {\r\n                        if i == 0 {\r\n                            c.to_uppercase().to_string()\r\n                        } else {\r\n                            c.to_string()\r\n                        }\r\n                    })\r\n                    .collect::<String>()\r\n            })\r\n            .collect::<Vec<_>>()\r\n            .join(\" \")\r\n    }\r\n\r\n    pub fn guess_image(\r\n        mut self,\r\n        file_path: &str,\r\n        asset_server: &Res<AssetServer>,\r\n        extension: &str,\r\n    ) -> Self {\r\n        self.texture = asset_server.load(Self::format_tool_image_from_source(file_path, extension));\r\n        self\r\n    }\r\n\r\n    fn clean_name(file_path: &str) -> &str {\r\n        Path::new(file_path)\r\n            .file_stem() // Get the file stem (file name without extension)\r\n            .and_then(|stem| stem.to_str()) // Convert OsStr to &str\r\n            .unwrap_or(\"\")\r\n            .trim_end_matches(\"_plugin\")\r\n            .trim_end_matches(\"_populate\")\r\n            .trim_start_matches(\"spawn_\")\r\n    }\r\n\r\n    fn format_tool_image_from_source(file_path: &str, extension: &str) -> String {\r\n        format!(\r\n            \"textures/tools/{}.{}\",\r\n            Self::clean_name(file_path),\r\n            extension\r\n        )\r\n    }\r\n\r\n    pub fn with_asset_image(\r\n        mut self,\r\n        file_name: &'static str,\r\n        asset_server: &Res<AssetServer>,\r\n    ) -> Self {\r\n        self.texture = asset_server.load(format!(\"textures/tools/{}\", file_name));\r\n        self\r\n    }\r\n\r\n    pub fn with_image(mut self, texture: Handle<Image>) -> Self {\r\n        self.texture = texture;\r\n        self\r\n    }\r\n\r\n    pub fn with_starting_state(mut self, state: StartingState) -> Self {\r\n        self.starting_state = state;\r\n        self\r\n    }\r\n\r\n    pub fn with_size(mut self, size: Vec2) -> Self {\r\n        self.size = Some(size);\r\n        self\r\n    }\r\n\r\n    pub fn spawn(self, commands: &mut Commands) {\r\n        commands.entity(self.toolbelt_id).with_children(|toolbelt| {\r\n            let mut tool = toolbelt.spawn((\r\n                Tool {\r\n                    name: self.name.clone(),\r\n                    description: self.description,\r\n                    actions: self.display_actions,\r\n                    texture: self.texture.clone(),\r\n                },\r\n                self.tag,\r\n                Name::new(self.name.clone()),\r\n                SpriteBundle {\r\n                    sprite: Sprite {\r\n                        custom_size: self.size,\r\n                        ..default()\r\n                    },\r\n                    texture: self.texture,\r\n                    visibility: Visibility::Hidden,\r\n                    ..default()\r\n                },\r\n                Sensor,\r\n                RigidBody::Kinematic,\r\n                Hoverable,\r\n                Collider::cuboid(100.0, 100.0),\r\n            ));\r\n            if let StartingState::Active = self.starting_state {\r\n                tool.insert(ActiveTool);\r\n            }\r\n            if let Some(src_path) = self.src_path {\r\n                tool.insert(HostPath { path: src_path });\r\n            }\r\n            let input_map = self.input_map.unwrap_or_default();\r\n            tool.insert(InputManagerBundle {\r\n                input_map,\r\n                ..default()\r\n            });\r\n        });\r\n        info!(\"{:?} => {:?}\", self.event, self.name);\r\n    }\r\n}\r\n\r\n#[allow(clippy::too_many_arguments)]\r\nfn spawn_tool_impl(\r\n    tool: Tool,\r\n    event: &ToolbeltPopulateEvent,\r\n    commands: &mut Commands,\r\n    toolbelt_id: Entity,\r\n    _asset_server: &Res<AssetServer>,\r\n    tool_component: impl Component,\r\n    input_manager: Option<impl Bundle>,\r\n    starting_state: StartingState,\r\n    custom_size: Option<Vec2>,\r\n) {\r\n    let tool_name = tool.name.clone();\r\n    commands.entity(toolbelt_id).with_children(|toolbelt| {\r\n        let name = Name::new(tool_name.clone());\r\n        let texture = tool.texture.clone();\r\n        let mut tool = toolbelt.spawn((\r\n            tool,\r\n            name,\r\n            SpriteBundle {\r\n                sprite: Sprite {\r\n                    custom_size: custom_size.or(Some(Vec2::new(100.0, 100.0))),\r\n                    ..default()\r\n                },\r\n                texture,\r\n                visibility: Visibility::Hidden,\r\n                ..default()\r\n            },\r\n            tool_component,\r\n            Sensor,\r\n            RigidBody::Kinematic,\r\n            Collider::cuboid(100.0, 100.0),\r\n        ));\r\n        if let StartingState::Active = starting_state {\r\n            tool.insert(ActiveTool);\r\n        }\r\n        if let Some(bundle) = input_manager {\r\n            tool.insert(bundle);\r\n        }\r\n    });\r\n    info!(\"{:?} => {:?}\", event, tool_name);\r\n}\r\n\r\n#[allow(clippy::too_many_arguments)]\r\npub fn spawn_action_tool<T>(\r\n    tool: Tool,\r\n    event: &ToolbeltPopulateEvent,\r\n    commands: &mut Commands,\r\n    toolbelt_id: Entity,\r\n    _character_id: Entity,\r\n    asset_server: &Res<AssetServer>,\r\n    tool_component: impl Component,\r\n    starting_state: StartingState,\r\n    custom_size: Option<Vec2>,\r\n) where\r\n    T: ToolAction + Actionlike,\r\n{\r\n    spawn_tool_impl(\r\n        tool,\r\n        event,\r\n        commands,\r\n        toolbelt_id,\r\n        asset_server,\r\n        tool_component,\r\n        T::default_input_map(event).map(|input_map| InputManagerBundle::<T> {\r\n            input_map,\r\n            ..default()\r\n        }),\r\n        starting_state,\r\n        custom_size,\r\n    )\r\n}\r\n\r\n#[derive(Bundle)]\r\npub struct NoopBundle {}\r\n\r\n#[derive(Debug)]\r\npub enum StartingState {\r\n    Active,\r\n    Inactive,\r\n}\r\nimpl StartingState {\r\n    pub fn as_active(&self) -> Option<ActiveTool> {\r\n        match self {\r\n            StartingState::Active => Some(ActiveTool),\r\n            StartingState::Inactive => None,\r\n        }\r\n    }\r\n}\r\n\r\n#[allow(clippy::too_many_arguments)]\r\npub fn spawn_tool(\r\n    tool: Tool,\r\n    event: &ToolbeltPopulateEvent,\r\n    commands: &mut Commands,\r\n    toolbelt_id: Entity,\r\n    _character_id: Entity,\r\n    asset_server: &Res<AssetServer>,\r\n    tool_component: impl Component,\r\n    starting_state: StartingState,\r\n    custom_size: Option<Vec2>,\r\n) {\r\n    spawn_tool_impl(\r\n        tool,\r\n        event,\r\n        commands,\r\n        toolbelt_id,\r\n        asset_server,\r\n        tool_component,\r\n        None::<NoopBundle>,\r\n        starting_state,\r\n        custom_size,\r\n    )\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\input\\src\\input_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n\r\nuse crate::active_input_state_plugin::ActiveInputStatePlugin;\r\nuse crate::update_gamepad_settings::update_gamepad_settings;\r\n\r\npub struct InputPlugin;\r\n\r\nimpl Plugin for InputPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_plugins(ActiveInputStatePlugin);\r\n        app.add_systems(Update, update_gamepad_settings);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\templates\\patterns\\new_tool\\crates\\plugins\\Cargo.toml\r\n\r\n````toml\r\n{{before_first_plugins_dependency}}\r\ncursor_hero_{{crate_name}}_tool = { workspace = true }\r\ncursor_hero_{{crate_name}}_tool_types = { workspace = true }\r\n{{first_plugins_dependency_onwards}}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\character\\src\\character_appearance_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n\r\npub struct CharacterAppearancePlugin;\r\nuse cursor_hero_camera::camera_plugin::CameraEvent;\r\nuse cursor_hero_character_types::prelude::*;\r\n\r\nimpl Plugin for CharacterAppearancePlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Update, update_character_appearance_from_camera_events);\r\n    }\r\n}\r\n\r\nfn update_character_appearance_from_camera_events(\r\n    mut camera_events: EventReader<CameraEvent>,\r\n    asset_server: Res<AssetServer>,\r\n    mut character_query: Query<&mut Handle<Image>, With<Character>>,\r\n) {\r\n    for event in camera_events.read() {\r\n        match event {\r\n            CameraEvent::BeginFollowing { target_id } => {\r\n                if let Ok(mut texture) = character_query.get_mut(*target_id) {\r\n                    *texture = asset_server.load(CharacterAppearance::Focused.get_texture_path());\r\n                    info!(\"Updated character appearance to focused\");\r\n                }\r\n            }\r\n            CameraEvent::StopFollowing { target_id } => {\r\n                if let Ok(mut texture) = character_query.get_mut(*target_id) {\r\n                    *texture = asset_server.load(CharacterAppearance::Unfocused.get_texture_path());\r\n                    info!(\"Updated character appearance to unfocused\");\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\cursor_mirror\\src\\lib.rs\r\n\r\n````rust\r\npub mod cursor_mirroring_plugin;\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\window_position_types\\src\\window_position_types_plugin.rs\r\n\r\n````rust\r\nuse crate::prelude::*;\r\nuse bevy::prelude::*;\r\n\r\npub struct WindowPositionTypesPlugin;\r\n\r\nimpl Plugin for WindowPositionTypesPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<crate::window_position_types::HostWindowPosition>();\r\n        app.register_type::<WindowPositionLoadoutSwitcherTool>();\r\n        app.register_type::<WindowPositionTool>();\r\n        app.register_type::<WindowPositionCommand>();\r\n        app.add_event::<WindowPositionCommand>();\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\taskbar_types\\src\\taskbar_types.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse bevy::reflect::TypePath;\r\nuse bevy::render::render_resource::AsBindGroup;\r\nuse bevy::render::render_resource::ShaderRef;\r\nuse bevy::sprite::Material2d;\r\n\r\n#[derive(Component, Debug, Reflect)]\r\npub struct AppWindow;\r\n\r\n#[derive(Component, Debug, Reflect)]\r\npub struct Taskbar {\r\n    pub size: Vec2,\r\n}\r\n\r\n#[derive(Event, Debug, Reflect)]\r\npub enum TaskbarEvent {\r\n    Populate { taskbar_id: Entity },\r\n}\r\n\r\n#[derive(Asset, TypePath, AsBindGroup, Debug, Clone)]\r\npub struct TaskbarMaterial {\r\n    #[uniform(0)]\r\n    pub taskbar_height: f32,\r\n    // pub taskbar_blur_radius: u32,\r\n    // pub taskbar_blur_total_samples: u32,\r\n    #[uniform(0)]\r\n    pub taskbar_color: Color,\r\n    #[texture(1)]\r\n    #[sampler(2)]\r\n    pub wallpaper_texture: Option<Handle<Image>>,\r\n    #[uniform(0)]\r\n    pub wallpaper_size: Vec2,\r\n    pub alpha_mode: AlphaMode,\r\n}\r\n\r\nimpl Material2d for TaskbarMaterial {\r\n    fn fragment_shader() -> ShaderRef {\r\n        \"shaders/taskbar_material.wgsl\".into()\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui_automation_types\\src\\lib.rs\r\n\r\n````rust\r\n#![feature(trivial_bounds)]\r\n\r\nmod calculator_ui_types;\r\nmod taskbar_ui_types;\r\nmod ui_automation_drill;\r\nmod ui_automation_error_types;\r\nmod ui_automation_types;\r\nmod ui_automation_types_plugin;\r\nmod vscode_ui_types;\r\n\r\npub mod prelude {\r\n    pub use crate::calculator_ui_types::*;\r\n    pub use crate::taskbar_ui_types::*;\r\n    pub use crate::ui_automation_drill::*;\r\n    pub use crate::ui_automation_error_types::*;\r\n    pub use crate::ui_automation_types::*;\r\n    pub use crate::ui_automation_types_plugin::*;\r\n    pub use crate::vscode_ui_types::*;\r\n    // pub use uiautomation;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\window_swap_tool_types\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_window_swap_tool_types\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\nleafwing-input-manager = { workspace = true }\r\nbevy-inspector-egui = { workspace = true }\r\ncursor_hero_toolbelt_types = { workspace = true }\r\ncursor_hero_input = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\observation\\src\\observation_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n\r\nuse crate::observation_buffer_plugin::ObservationBufferPlugin;\r\nuse crate::observation_log_plugin::ObservationLogPlugin;\r\nuse crate::observation_tool_plugin::ObservationToolPlugin;\r\nuse crate::observe_chat_plugin::ObserveChatPlugin;\r\n\r\npub struct ObservationPlugin;\r\n\r\nimpl Plugin for ObservationPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_plugins(ObservationLogPlugin);\r\n        app.add_plugins(ObservationToolPlugin);\r\n        app.add_plugins(ObservationBufferPlugin);\r\n        app.add_plugins(ObserveChatPlugin);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\plugins\\src\\default_launch_mode_plugin.rs\r\n\r\n````rust\r\nuse bevy::input::common_conditions::input_toggle_active;\r\nuse bevy::prelude::*;\r\nuse cursor_hero_input::active_input_state_plugin::InputMethod;\r\n\r\nuse bevy::audio::AudioPlugin;\r\nuse bevy::audio::SpatialScale;\r\nuse bevy::diagnostic::FrameTimeDiagnosticsPlugin;\r\nuse bevy::log::LogPlugin;\r\nuse bevy_embedded_assets::EmbeddedAssetPlugin;\r\nuse bevy_inspector_egui::quick::StateInspectorPlugin;\r\nuse bevy_inspector_egui::quick::WorldInspectorPlugin;\r\nuse cursor_hero_agent::agent_plugin::AgentPlugin;\r\nuse cursor_hero_camera::camera_plugin::CameraPlugin;\r\nuse cursor_hero_character::character_plugin::CharacterPlugin;\r\nuse cursor_hero_cursor_mirror::cursor_mirroring_plugin::CursorMirroringPlugin;\r\nuse cursor_hero_environment::environment_plugin::EnvironmentPlugin;\r\nuse cursor_hero_environment_nametag::environment_nametag_plugin::EnvironmentNametagPlugin;\r\nuse cursor_hero_hover::hover_tool::HoverToolPlugin;\r\nuse cursor_hero_hover::hover_ui_automation_plugin::HoverUiAutomationPlugin;\r\nuse cursor_hero_hover::inspect_wheel_tool::InspectWheelToolPlugin;\r\nuse cursor_hero_hover::screenshot_tool::ScreenshotToolPlugin;\r\nuse cursor_hero_icon::IconPlugin;\r\nuse cursor_hero_input::InputPlugin;\r\nuse cursor_hero_level_bounds::level_bounds_plugin::LevelBoundsPlugin;\r\nuse cursor_hero_math::prelude::MathPlugin;\r\nuse cursor_hero_memory::primary_window_memory_plugin::restore_window;\r\nuse cursor_hero_physics::damping_plugin::DampingPlugin;\r\nuse cursor_hero_physics::physics_plugin::PhysicsPlugin;\r\nuse cursor_hero_physics_debug::physics_debug_plugin::PhysicsDebugPlugin;\r\nuse cursor_hero_pointer::pointer_plugin::PointerPlugin;\r\nuse cursor_hero_pointer_types::pointer_types_plugin::PointerTypesPlugin;\r\nuse cursor_hero_pressure_plate::pressure_plate_plugin::PressurePlatePlugin;\r\nuse cursor_hero_screen::screen_plugin::ScreenPlugin;\r\nuse cursor_hero_screen::screen_update_plugin::ScreenUpdatePlugin;\r\nuse cursor_hero_sprint_tool::sprint_tool_plugin::SprintToolPlugin;\r\nuse cursor_hero_sprint_tool_types::sprint_tool_types_plugin::SprintToolTypesPlugin;\r\nuse cursor_hero_taskbar::taskbar_plugin::TaskbarPlugin;\r\nuse cursor_hero_toolbelt::toolbelt_plugin::ToolbeltPlugin;\r\nuse cursor_hero_toolbelt_types::toolbelt_types_plugin::ToolbeltTypesPlugin;\r\nuse cursor_hero_tools::ToolPlugin;\r\nuse cursor_hero_ui::about_text_plugin::AboutTextPlugin;\r\nuse cursor_hero_ui::fps_text_plugin::FpsTextPlugin;\r\nuse cursor_hero_version::version_plugin::Version;\r\nuse cursor_hero_wallpaper::wallpaper_plugin::WallpaperPlugin;\r\n\r\nuse cursor_hero_agent_types::agent_types_plugin::AgentTypesPlugin;\r\nuse cursor_hero_app::prelude::*;\r\nuse cursor_hero_app_types::prelude::*;\r\nuse cursor_hero_brick::prelude::*;\r\nuse cursor_hero_brick_types::prelude::*;\r\nuse cursor_hero_calculator_app::prelude::*;\r\nuse cursor_hero_calculator_app_types::prelude::*;\r\nuse cursor_hero_character_types::character_types_plugin::CharacterTypesPlugin;\r\nuse cursor_hero_chat::chat_plugin::ChatPlugin;\r\nuse cursor_hero_chat_types::chat_types_plugin::ChatTypesPlugin;\r\nuse cursor_hero_environment_types::environment_types_plugin::EnvironmentTypesPlugin;\r\nuse cursor_hero_floaty_nametag::prelude::*;\r\nuse cursor_hero_floaty_nametag_types::prelude::*;\r\nuse cursor_hero_fullscreen_tool::prelude::*;\r\nuse cursor_hero_fullscreen_tool_types::prelude::*;\r\nuse cursor_hero_glados_tts::prelude::*;\r\nuse cursor_hero_glados_tts_types::prelude::*;\r\nuse cursor_hero_host_event::prelude::*;\r\nuse cursor_hero_host_event_types::prelude::*;\r\nuse cursor_hero_host_fs::prelude::*;\r\nuse cursor_hero_host_fs_types::prelude::*;\r\nuse cursor_hero_inference::inference_plugin::InferencePlugin;\r\nuse cursor_hero_inference_types::inference_types_plugin::InferenceTypesPlugin;\r\nuse cursor_hero_memory::prelude::*;\r\nuse cursor_hero_memory_types::prelude::*;\r\nuse cursor_hero_movement_tool::movement_tool_plugin::MovementToolPlugin;\r\nuse cursor_hero_movement_tool_types::movement_tool_types_plugin::MovementToolTypesPlugin;\r\nuse cursor_hero_observation::observation_plugin::ObservationPlugin;\r\nuse cursor_hero_observation_types::observation_types_plugin::ObservationTypesPlugin;\r\nuse cursor_hero_ollama::prelude::*;\r\nuse cursor_hero_ollama_types::prelude::*;\r\nuse cursor_hero_secret::prelude::*;\r\nuse cursor_hero_secret_types::prelude::*;\r\nuse cursor_hero_start_menu::prelude::*;\r\nuse cursor_hero_start_menu_types::prelude::*;\r\nuse cursor_hero_taskbar_tool::prelude::*;\r\nuse cursor_hero_taskbar_types::prelude::TaskbarTypesPlugin;\r\nuse cursor_hero_text_asset::prelude::*;\r\nuse cursor_hero_text_asset_types::prelude::*;\r\nuse cursor_hero_ui_automation::prelude::*;\r\nuse cursor_hero_voice_to_text::prelude::*;\r\nuse cursor_hero_voice_to_text_types::prelude::*;\r\nuse cursor_hero_window_position::prelude::*;\r\nuse cursor_hero_window_position_types::prelude::*;\r\nuse cursor_hero_window_swap_tool::prelude::*;\r\nuse cursor_hero_window_swap_tool_types::prelude::*;\r\npub struct DefaultLaunchModePlugin;\r\n\r\nimpl Plugin for DefaultLaunchModePlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_plugins(MemoryTypesPlugin);\r\n        let memory_config = MemoryConfig {\r\n            save_dir: \"Cursor Hero Memory\".to_string(),\r\n        };\r\n        app.add_plugins(MemoryPlugin {\r\n            config: memory_config.clone(),\r\n            build_config: MemoryPluginBuildConfig::all_enabled(),\r\n        });\r\n        app.add_plugins(WindowSwapToolPlugin);\r\n        app.add_plugins(WindowSwapToolTypesPlugin);\r\n        app.add_plugins(HostFsTypesPlugin);\r\n        app.add_plugins(HostFsPlugin);\r\n        app.add_plugins(WindowPositionTypesPlugin);\r\n        app.add_plugins(WindowPositionPlugin);\r\n        app.add_plugins(UiAutomationTypesPlugin);\r\n        app.add_plugins(UiAutomationPlugin);\r\n        app.add_plugins(BrickTypesPlugin);\r\n        app.add_plugins(BrickPlugin);\r\n        app.add_plugins(FullscreenToolPlugin);\r\n        app.add_plugins(FullscreenToolTypesPlugin);\r\n        app.add_plugins(FloatyNametagTypesPlugin);\r\n        app.add_plugins(FloatyNametagPlugin);\r\n        app.add_plugins(HostEventTypesPlugin);\r\n        app.add_plugins(HostEventPlugin);\r\n        app.add_plugins(TaskbarToolPlugin);\r\n        app.add_plugins(StartMenuTypesPlugin);\r\n        app.add_plugins(StartMenuPlugin);\r\n        app.add_plugins(CalculatorAppTypesPlugin);\r\n        app.add_plugins(CalculatorAppPlugin);\r\n        app.add_plugins(AppTypesPlugin);\r\n        app.add_plugins(AppPlugin);\r\n        app.add_plugins(SecretsTypesPlugin);\r\n        app.add_plugins(SecretsPlugin);\r\n        app.add_plugins(VoiceToTextTypesPlugin);\r\n        app.add_plugins(VoiceToTextPlugin);\r\n        app.add_plugins(GladosTtsTypesPlugin);\r\n        app.add_plugins(GladosTtsPlugin);\r\n        app.add_plugins(OllamaTypesPlugin);\r\n        app.add_plugins(OllamaPlugin);\r\n        app.add_plugins(EnvironmentTypesPlugin);\r\n        app.add_plugins(ChatTypesPlugin);\r\n        app.add_plugins(ChatPlugin);\r\n        app.add_plugins(ObservationTypesPlugin);\r\n        app.add_plugins(ObservationPlugin);\r\n        app.add_plugins(InferenceTypesPlugin);\r\n        app.add_plugins(InferencePlugin);\r\n        app.add_plugins(MovementToolTypesPlugin);\r\n        app.add_plugins(MovementToolPlugin);\r\n        app.add_plugins(CharacterTypesPlugin);\r\n        app.add_plugins(AgentTypesPlugin);\r\n        app.add_plugins(AgentPlugin);\r\n        app.add_plugins(AboutTextPlugin);\r\n        app.add_plugins(CameraPlugin);\r\n        app.add_plugins(CharacterPlugin);\r\n        app.add_plugins(CursorMirroringPlugin);\r\n        app.add_plugins(DampingPlugin);\r\n        app.add_plugins(EnvironmentNametagPlugin);\r\n        app.add_plugins(EnvironmentPlugin);\r\n        app.add_plugins(FpsTextPlugin);\r\n        app.add_plugins(HoverToolPlugin);\r\n        app.add_plugins(HoverUiAutomationPlugin);\r\n        app.add_plugins(IconPlugin);\r\n        app.add_plugins(InputPlugin);\r\n        app.add_plugins(ScreenshotToolPlugin);\r\n        app.add_plugins(InspectWheelToolPlugin);\r\n        app.add_plugins(LevelBoundsPlugin);\r\n        app.add_plugins(MathPlugin);\r\n        app.add_plugins(PhysicsDebugPlugin);\r\n        app.add_plugins(PhysicsPlugin);\r\n        app.add_plugins(PointerPlugin);\r\n        app.add_plugins(PointerTypesPlugin);\r\n        app.add_plugins(PressurePlatePlugin);\r\n        app.add_plugins(ScreenPlugin);\r\n        app.add_plugins(ScreenUpdatePlugin);\r\n        app.add_plugins(SprintToolPlugin);\r\n        app.add_plugins(SprintToolTypesPlugin);\r\n        app.add_plugins(TaskbarPlugin);\r\n        app.add_plugins(ToolbeltPlugin);\r\n        app.add_plugins(ToolbeltTypesPlugin);\r\n        app.add_plugins(ToolPlugin);\r\n        app.add_plugins(WallpaperPlugin);\r\n\r\n        // must be before the default plugins\r\n        app.add_plugins(EmbeddedAssetPlugin {\r\n            mode: bevy_embedded_assets::PluginMode::ReplaceDefault,\r\n        });\r\n\r\n        #[cfg(debug_assertions)]\r\n        let log_plugin = LogPlugin {\r\n            level: bevy::log::Level::DEBUG,\r\n            filter: \"\r\ninfo,\r\nwgpu_core=warn,\r\nwgpu_hal=warn,\r\nbevy_ecs=info,\r\ncursor_hero=debug,\r\ncursor_hero_pointer::pointer_hover_plugin=info,\r\ncursor_hero_ollama::ollama_status_worker_plugin=info,\r\ncursor_hero_voice_to_text::voice_to_text_ping_plugin=info,\r\ncursor_hero_voice_to_text::voice_to_text_worker_plugin=info,\r\ncursor_hero_glados_tts::glados_tts_status_worker_plugin=info,\r\ncursor_hero_tools::click_tool=info,\r\ncursor_hero_memory=info\r\n            \"\r\n            .replace('\\n', \"\")\r\n            .trim()\r\n            .into(),\r\n            // TODO: fix warnings when minimized\r\n        };\r\n        //         #[cfg(debug_assertions)]\r\n        //         let log_plugin = LogPlugin {\r\n        //             level: bevy::log::Level::DEBUG,\r\n        //             filter: \"\r\n        // debug\r\n        //             \".replace('\\n',\"\").trim().into(),\r\n        //             // TODO: fix warnings when minimized\r\n        //         };\r\n        #[cfg(not(debug_assertions))]\r\n        let log_plugin = LogPlugin {\r\n            level: bevy::log::Level::INFO,\r\n            filter: \"info,wgpu_core=warn,wgpu_hal=warn\".into(),\r\n        };\r\n        const AUDIO_SCALE: f32 = 1. / 100.0;\r\n        let version = match app.world.get_resource::<Version>() {\r\n            Some(version) => version.0.clone(),\r\n            None => {\r\n                warn!(\"Version resource not found\");\r\n                \"Unknown\".to_string()\r\n            }\r\n        };\r\n        let mut window = Window {\r\n            title: format!(\"Cursor Hero v{}\", version),\r\n            resizable: true,\r\n            ..default()\r\n        };\r\n        if let Err(e) = restore_window(&memory_config, &mut window) {\r\n            error!(\"Failed to restore window: {:?}\", e);\r\n        }\r\n        app.add_plugins(\r\n            DefaultPlugins\r\n                .set(ImagePlugin::default_nearest())\r\n                .set(AudioPlugin {\r\n                    spatial_scale: SpatialScale::new_2d(AUDIO_SCALE),\r\n                    ..default()\r\n                })\r\n                .set(WindowPlugin {\r\n                    primary_window: Some(window),\r\n                    ..default()\r\n                })\r\n                .set(log_plugin)\r\n                .build(),\r\n        );\r\n\r\n        // must be after the default plugins (relies on assetserver existing)\r\n        app.add_plugins(TextAssetTypesPlugin);\r\n        app.add_plugins(TextAssetPlugin);\r\n        app.add_plugins(TaskbarTypesPlugin);\r\n\r\n        // must be after the default plugins\r\n        app.add_plugins(\r\n            WorldInspectorPlugin::default().run_if(input_toggle_active(false, KeyCode::Grave)),\r\n        );\r\n        app.add_plugins(\r\n            StateInspectorPlugin::<InputMethod>::default()\r\n                .run_if(input_toggle_active(false, KeyCode::Grave)),\r\n        );\r\n        app.add_plugins(FrameTimeDiagnosticsPlugin);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\inference_types\\src\\lib.rs\r\n\r\n````rust\r\npub mod inference_types;\r\npub mod inference_types_plugin;\r\npub mod prompt_types;\r\n\r\npub mod prelude {\r\n    pub use crate::inference_types::*;\r\n    pub use crate::inference_types_plugin::InferenceTypesPlugin;\r\n    pub use crate::prompt_types::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\math\\src\\lerp.rs\r\n\r\n````rust\r\npub trait Lerp {\r\n    fn lerp(self, open: f32) -> f32;\r\n}\r\n\r\nimpl Lerp for (f32, f32) {\r\n    fn lerp(self, open: f32) -> f32 {\r\n        let (start, end) = self;\r\n        start + (end - start) * open.clamp(0.0, 1.0)\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\use cases\\flip comments.md\r\n\r\n````markdown\r\n```rust\r\n    log_behaviour: PointerLogBehaviour::Errors,\r\n    // log_behaviour: PointerLogBehaviour::ErrorsAndPositionUpdates,\r\n```\r\ncontext action to swap which line is commented\r\n- identify based on line matching except for different enum variant\r\n\r\nor just suggest switching the variant, flag the variant as toggleable from IDE?\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\calculator_app\\src\\lib.rs\r\n\r\n````rust\r\npub mod calculator_app_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::calculator_app_plugin::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\environment_types\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_environment_types\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\bevy\\src\\neg_y.rs\r\n\r\n````rust\r\nuse bevy::math::IRect;\r\nuse bevy::math::IVec2;\r\nuse bevy::math::IVec3;\r\nuse bevy::math::Rect;\r\nuse bevy::math::Vec2;\r\nuse bevy::math::Vec3;\r\n\r\npub trait NegativeYRect {\r\n    fn neg_y(&self) -> Rect;\r\n}\r\nimpl NegativeYRect for Rect {\r\n    fn neg_y(&self) -> Rect {\r\n        Rect::from_center_size(self.center().neg_y(), self.size())\r\n    }\r\n}\r\n\r\npub trait NegativeYIRect {\r\n    fn neg_y(&self) -> IRect;\r\n}\r\nimpl NegativeYIRect for IRect {\r\n    fn neg_y(&self) -> IRect {\r\n        IRect::from_center_size(self.center().neg_y(), self.size())\r\n    }\r\n}\r\n\r\npub trait NegativeYVec2 {\r\n    fn neg_y(&self) -> Vec2;\r\n}\r\nimpl NegativeYVec2 for Vec2 {\r\n    fn neg_y(&self) -> Vec2 {\r\n        Vec2::new(self.x, -self.y)\r\n    }\r\n}\r\n\r\npub trait NegativeYIVec2 {\r\n    fn neg_y(&self) -> IVec2;\r\n}\r\nimpl NegativeYIVec2 for IVec2 {\r\n    fn neg_y(&self) -> IVec2 {\r\n        IVec2::new(self.x, -self.y)\r\n    }\r\n}\r\n\r\npub trait NegativeYVec3 {\r\n    fn neg_y(&self) -> Vec3;\r\n}\r\nimpl NegativeYVec3 for Vec3 {\r\n    fn neg_y(&self) -> Vec3 {\r\n        Vec3::new(self.x, -self.y, self.z)\r\n    }\r\n}\r\n\r\npub trait NegativeYIVec3 {\r\n    fn neg_y(&self) -> IVec3;\r\n}\r\nimpl NegativeYIVec3 for IVec3 {\r\n    fn neg_y(&self) -> IVec3 {\r\n        IVec3::new(self.x, -self.y, self.z)\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\memory\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_memory\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\ncursor_hero_memory_types = { workspace = true }\r\ncursor_hero_winutils = { workspace = true }\r\ncursor_hero_character_types = { workspace = true }\r\ncursor_hero_camera = { workspace = true }\r\ncursor_hero_toolbelt_types = { workspace = true }\r\ncursor_hero_voice_to_text_types = { workspace = true }\r\ncursor_hero_secret_types = { workspace = true }\r\ncursor_hero_observation_types = { workspace = true }\r\nraw-window-handle = { workspace = true }\r\nserde = { workspace = true, features=[\"derive\"] }\r\nserde_json = { workspace = true }\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui_automation\\src\\elements_at_point.rs\r\n\r\n````rust\r\nuse bevy::math::IVec2;\r\nuse std::collections::VecDeque;\r\nuse uiautomation::types::Point;\r\nuse uiautomation::UIAutomation;\r\nuse uiautomation::UIElement;\r\n\r\npub fn find_element_at(pos: IVec2) -> Result<UIElement, uiautomation::Error> {\r\n    let automation = UIAutomation::new()?;\r\n    automation.element_from_point(Point::new(pos.x, pos.y))\r\n}\r\n\r\npub fn gather_elements_at(pos: IVec2) -> Result<Vec<(UIElement, usize)>, uiautomation::Error> {\r\n    let automation = UIAutomation::new()?;\r\n    let walker = automation.create_tree_walker()?;\r\n    let start = automation.element_from_point(Point::new(pos.x, pos.y))?;\r\n    let mut rtn = vec![];\r\n    let mut next = VecDeque::new();\r\n    next.push_back((start, 0));\r\n    while let Some((elem, depth)) = next.pop_front() {\r\n        rtn.push((elem.clone(), depth));\r\n        if let Ok(child) = walker.get_first_child(&elem) {\r\n            next.push_back((child.clone(), depth + 1));\r\n            let mut next_sibling = child;\r\n            while let Ok(sibling) = walker.get_next_sibling(&next_sibling) {\r\n                next.push_back((sibling.clone(), depth + 1));\r\n                next_sibling = sibling;\r\n            }\r\n        }\r\n    }\r\n    Ok(rtn)\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\brick\\src\\lib.rs\r\n\r\n````rust\r\npub mod brick_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::brick_plugin::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\fullscreen_tool\\src\\fullscreen_tool_populate_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse bevy::window::PrimaryWindow;\r\nuse cursor_hero_fullscreen_tool_types::prelude::*;\r\nuse cursor_hero_toolbelt_types::prelude::*;\r\nuse cursor_hero_tools::tool_spawning::NoInputs;\r\nuse cursor_hero_tools::tool_spawning::ToolSpawnConfig;\r\n\r\npub struct FullscreenToolPopulatePlugin;\r\n\r\nimpl Plugin for FullscreenToolPopulatePlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Update, handle_toolbelt_events);\r\n    }\r\n}\r\n\r\nfn handle_toolbelt_events(\r\n    mut commands: Commands,\r\n    asset_server: Res<AssetServer>,\r\n    mut reader: EventReader<ToolbeltPopulateEvent>,\r\n    window_query: Query<&Window, With<PrimaryWindow>>,\r\n) {\r\n    for event in reader.read() {\r\n        let ToolbeltLoadout::WindowPosition = event.loadout else {\r\n            continue;\r\n        };\r\n\r\n        let mode = window_query\r\n            .iter()\r\n            .map(|w| w.mode)\r\n            .next()\r\n            .unwrap_or_default();\r\n        let state = FullscreenTool::state_for_mode(mode);\r\n        debug!(\"Window: {:?}, tool: {:?}\", mode, state);\r\n        ToolSpawnConfig::<_, NoInputs>::new(FullscreenTool, event.id, event)\r\n            .with_src_path(file!().into())\r\n            .guess_name(file!())\r\n            .guess_image(file!(), &asset_server, \"webp\")\r\n            .with_description(\"Toggles fullscreen mode.\")\r\n            .with_starting_state(state)\r\n            .spawn(&mut commands);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\plugins\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_plugins\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n\r\n[dependencies]\r\ncursor_hero_worker = { workspace = true }\r\ncursor_hero_worker_types = { workspace = true }\r\ncursor_hero_memory = { workspace = true }\r\ncursor_hero_memory_types = { workspace = true }\r\ncursor_hero_window_swap_tool = { workspace = true }\r\ncursor_hero_window_swap_tool_types = { workspace = true }\r\ncursor_hero_host_fs = { workspace = true }\r\ncursor_hero_host_fs_types = { workspace = true }\r\ncursor_hero_window_position = { workspace = true }\r\ncursor_hero_window_position_types = { workspace = true }\r\ncursor_hero_ui_automation = { workspace = true }\r\ncursor_hero_ui_automation_types = { workspace = true }\r\ncursor_hero_brick = { workspace = true }\r\ncursor_hero_brick_types = { workspace = true }\r\ncursor_hero_fullscreen_tool = { workspace = true }\r\ncursor_hero_fullscreen_tool_types = { workspace = true }\r\ncursor_hero_ui_watcher = { workspace = true }\r\ncursor_hero_ui_watcher_types = { workspace = true }\r\ncursor_hero_floaty_nametag = { workspace = true }\r\ncursor_hero_floaty_nametag_types = { workspace = true }\r\ncursor_hero_host_event = { workspace = true }\r\ncursor_hero_host_event_types = { workspace = true }\r\ncursor_hero_start_menu = { workspace = true }\r\ncursor_hero_start_menu_types = { workspace = true }\r\ncursor_hero_calculator_app = { workspace = true }\r\ncursor_hero_calculator_app_types = { workspace = true }\r\ncursor_hero_app = { workspace = true }\r\ncursor_hero_app_types = { workspace = true }\r\ncursor_hero_secret = { workspace = true }\r\ncursor_hero_secret_types = { workspace = true }\r\ncursor_hero_voice_to_text = { workspace = true }\r\ncursor_hero_voice_to_text_types = { workspace = true }\r\ncursor_hero_glados_tts = { workspace = true }\r\ncursor_hero_glados_tts_types = { workspace = true }\r\ncursor_hero_ollama = { workspace = true }\r\ncursor_hero_ollama_types = { workspace = true }\r\ncursor_hero_text_asset = { workspace = true }\r\ncursor_hero_text_asset_types = { workspace = true }\r\ncursor_hero_environment_types = { workspace = true }\r\ncursor_hero_chat_types = { workspace = true }\r\ncursor_hero_chat = { workspace = true }\r\ncursor_hero_observation_types = { workspace = true }\r\ncursor_hero_observation = { workspace = true }\r\ncursor_hero_inference_types = { workspace = true }\r\ncursor_hero_inference = { workspace = true }\r\ncursor_hero_movement_tool_types = { workspace = true }\r\ncursor_hero_movement_tool = { workspace = true }\r\ncursor_hero_character_types = { workspace = true }\r\ncursor_hero_agent_types = { workspace = true }\r\ncursor_hero_physics_debug = { workspace = true }\r\ncursor_hero_math = { workspace = true }\r\ncursor_hero_version = { workspace = true }\r\ncursor_hero_pointer_types = { workspace = true }\r\ncursor_hero_toolbelt_types = { workspace = true }\r\ncursor_hero_sprint_tool_types = { workspace = true }\r\ncursor_hero_sprint_tool = { workspace = true }\r\ncursor_hero_agent = { workspace = true }\r\ncursor_hero_taskbar = { workspace = true }\r\ncursor_hero_taskbar_tool = { workspace = true }\r\ncursor_hero_taskbar_types = { workspace = true }\r\ncursor_hero_environment_nametag = { workspace = true }\r\ncursor_hero_environment = { workspace = true }\r\ncursor_hero_xelu_prompts = { workspace = true }\r\ncursor_hero_wallpaper = { workspace = true }\r\ncursor_hero_cursor_mirror = {workspace = true}\r\ncursor_hero_hover = {workspace = true}\r\ncursor_hero_pressure_plate = {workspace = true}\r\ncursor_hero_level_bounds = {workspace = true}\r\ncursor_hero_input = {workspace = true}\r\ncursor_hero_camera = {workspace = true}\r\ncursor_hero_character = {workspace = true}\r\ncursor_hero_data = {workspace = true}\r\ncursor_hero_metrics = {workspace = true}\r\ncursor_hero_click_drag_character_movement = {workspace = true}\r\ncursor_hero_physics = {workspace = true}\r\ncursor_hero_pointer = {workspace = true}\r\ncursor_hero_screen = {workspace = true}\r\ncursor_hero_toolbelt = {workspace = true}\r\ncursor_hero_tools = {workspace = true}\r\ncursor_hero_ui = {workspace = true}\r\ncursor_hero_icon = {workspace = true}\r\ncursor_hero_winutils = {workspace = true}\r\nbevy = {workspace = true}\r\nbevy_embedded_assets = { workspace = true }\r\nbevy-inspector-egui = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\window_swap_tool\\src\\window_swap_tool_tick_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse cursor_hero_WindowSwap_tool_types::prelude::*;\r\nuse cursor_hero_toolbelt_types::prelude::*;\r\nuse leafwing_input_manager::prelude::*;\r\n\r\npub struct WindowSwapToolTickPlugin;\r\n\r\nimpl Plugin for WindowSwapToolTickPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_plugins(InputManagerPlugin::<WindowSwapToolAction>::default());\r\n        app.add_systems(Update, tick);\r\n    }\r\n}\r\n\r\nfn tick(\r\n    tool_query: Query<(&ActionState<WindowSwapToolAction>, &WindowSwapTool), With<ActiveTool>>,\r\n) {\r\n    for tool in tool_query.iter() {\r\n        let (tool_actions, tool) = tool;\r\n        if !tool_actions.pressed(WindowSwapToolAction::Use) {\r\n            continue;\r\n        }\r\n        info!(\"WindowSwapTool used!\");\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\camera\\src\\lib.rs\r\n\r\n````rust\r\n#![feature(let_chains)]\r\npub mod camera_plugin;\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\fullscreen_tool\\src\\lib.rs\r\n\r\n````rust\r\npub mod fullscreen_tool_plugin;\r\npub mod fullscreen_tool_populate_plugin;\r\npub mod fullscreen_tool_tick_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::fullscreen_tool_plugin::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\observation_types\\src\\observation_types_plugin.rs\r\n\r\n````rust\r\nuse crate::prelude::*;\r\nuse bevy::prelude::*;\r\npub struct ObservationTypesPlugin;\r\n\r\nimpl Plugin for ObservationTypesPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<ObservationTool>();\r\n        app.register_type::<ObservationBuffer>();\r\n        app.register_type::<ObservationBufferEntry>();\r\n        app.register_type::<WhatsNew>();\r\n        app.add_event::<SomethingObservableHappenedEvent>();\r\n        app.add_event::<ObservationBufferEvent>();\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\start_menu\\src\\start_menu_plugin.rs\r\n\r\n````rust\r\nuse crate::start_menu_button_plugin::StartMenuButtonPlugin;\r\nuse bevy::prelude::*;\r\nuse cursor_hero_start_menu_types::prelude::*;\r\nuse cursor_hero_winutils::win_colors::get_accent_color;\r\n\r\npub struct StartMenuPlugin;\r\n\r\nimpl Plugin for StartMenuPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_plugins(StartMenuButtonPlugin);\r\n        app.add_systems(Update, handle_open_events);\r\n        app.add_systems(Update, handle_close_events);\r\n    }\r\n}\r\nfn handle_open_events(\r\n    mut commands: Commands,\r\n    mut start_menu_events: EventReader<StartMenuEvent>,\r\n    start_menu_button_query: Query<&Sprite, With<StartMenuButton>>,\r\n) {\r\n    for event in start_menu_events.read() {\r\n        let StartMenuEvent::Open {\r\n            start_menu_button_id,\r\n        } = event\r\n        else {\r\n            continue;\r\n        };\r\n        info!(\"Opening start menu for button {:?}\", start_menu_button_id);\r\n        let Ok(Sprite {\r\n            custom_size: Some(start_menu_button_size),\r\n            ..\r\n        }) = start_menu_button_query.get(*start_menu_button_id)\r\n        else {\r\n            warn!(\r\n                \"Couldn't find start menu button sprite for {:?}\",\r\n                start_menu_button_id\r\n            );\r\n            continue;\r\n        };\r\n        let size = Vec2::new(400.0, 400.0);\r\n        let start_menu_pos = ((size / 2.0)\r\n            + Vec2::new(\r\n                -start_menu_button_size.x / 2.0,\r\n                start_menu_button_size.y / 2.0,\r\n            ))\r\n        .extend(3.0);\r\n        commands\r\n            .entity(*start_menu_button_id)\r\n            .with_children(|parent| {\r\n                parent.spawn((\r\n                    SpriteBundle {\r\n                        sprite: Sprite {\r\n                            custom_size: Some(size),\r\n                            color: match get_accent_color() {\r\n                                Ok(color) => color,\r\n                                Err(err) => {\r\n                                    warn!(\"Couldn't get start color: {}\", err);\r\n                                    Color::rgb(0.0, 0.0, 0.0)\r\n                                }\r\n                            },\r\n                            ..default()\r\n                        },\r\n                        transform: Transform::from_translation(start_menu_pos),\r\n                        ..Default::default()\r\n                    },\r\n                    StartMenu,\r\n                ));\r\n            });\r\n    }\r\n}\r\n\r\nfn handle_close_events(\r\n    mut commands: Commands,\r\n    mut start_menu_events: EventReader<StartMenuEvent>,\r\n    start_menu_button_query: Query<&Children, With<StartMenuButton>>,\r\n    start_menu_query: Query<(), With<StartMenu>>,\r\n) {\r\n    for event in start_menu_events.read() {\r\n        let StartMenuEvent::Close {\r\n            start_menu_button_id,\r\n        } = event\r\n        else {\r\n            continue;\r\n        };\r\n        info!(\"Closing start menu for button {:?}\", start_menu_button_id);\r\n        let Ok(start_menu_button_children) = start_menu_button_query.get(*start_menu_button_id)\r\n        else {\r\n            warn!(\r\n                \"Couldn't find start menu button children for {:?}\",\r\n                start_menu_button_id\r\n            );\r\n            continue;\r\n        };\r\n        let mut removed = vec![];\r\n        for child in start_menu_button_children.iter() {\r\n            if start_menu_query.get(*child).is_ok() {\r\n                commands.entity(*child).despawn_recursive();\r\n                removed.push(*child);\r\n            }\r\n        }\r\n        commands\r\n            .entity(*start_menu_button_id)\r\n            .remove_children(&removed);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\agent\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_agent\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\ncursor_hero_environment_types = { workspace = true }\r\ncursor_hero_character_types = { workspace = true }\r\ncursor_hero_movement_tool_types = { workspace = true }\r\ncursor_hero_agent_types = { workspace = true }\r\ncursor_hero_physics = { workspace = true }\r\ncursor_hero_input = { workspace = true }\r\ncursor_hero_bevy = { workspace = true }\r\ncursor_hero_toolbelt_types = { workspace = true }\r\ncursor_hero_observation_types = { workspace = true }\r\ncursor_hero_camera = { workspace = true }\r\nbevy_xpbd_2d = { workspace = true }\r\nbevy-inspector-egui = { workspace = true}\r\nleafwing-input-manager = { workspace = true }\r\ncursor_hero_floaty_nametag_types = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\character\\src\\lib.rs\r\n\r\n````rust\r\npub mod character_appearance_plugin;\r\npub mod character_plugin;\r\npub mod character_spawning_plugin;\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\use cases\\from keep.md\r\n\r\n````markdown\r\nSuggest rename\r\n- get llm to suggest multiple new names for a code symbol\r\n- give context to llm: recent voice and rename activity\r\n- display suggestions as radial menu\r\n- picking a suggestion runs the rename hotkey, types it, hits enter\r\n\r\n\r\n\r\nMake a music mix by picking tracks out of hour long mixes downloaded from YouTube. Use chapter splits and timestamp notices from notes to identify song boundaries\r\n\r\n\r\nView two peoples monitor sets on the same world. Click and drag a file between computers - doorway maybe to make it clear when the transfer will start;passing between the boundary\r\n\r\nPermission zones, read (screen, files, nothing), write (send files to downloads or other configured locations, add torrents to their client and only see the torrents you added) \r\nPermission of read/write for media player playback of a file to perform Syncplay duties\r\n\r\nMonitor set parent to be used as offset for positioning cursor; let them be repositioned as a group and individually\r\n\r\n\r\n\r\nWrapped - create a carousel of the year, a screenshot/file from each day\r\n\r\n\r\n\r\nWhen the computer is locked - map the controller to 0-9\r\nDpad 1,2,3,4\r\nButtins 5,6,7,8\r\nL1 9\r\nR1 0\r\nUnlock using the pin pad\r\n\r\n\r\nPrivacy guards - disable microphone when inputting a password as it can be used to identify keyboard inputs - I wonder how distinct the controller button press sounds are? Todo: train a model to predict controller inputs from their sound\r\nShould be easy to get a ground truth dataset\r\n\r\nMinecraft gear change sound when switching tool(belt)s\r\n\r\n\r\nToolbelts\r\n- numeric input - 0-9 buttons\r\n- intellisense - ctrl, space, tab, arrow keys\r\n- movement - sticks for character and pointer, l3 sprint\r\n- clicking - l1=m2 r1=m1\r\n- voice - r3=voice to text\r\n- pause - unbind all, chord l3+r3+start to equip switcher toolbelt again\r\n- switcher - start and select show different controller previews with keys shown\r\n\r\nSwitcher\r\nHold select to show the wheel\r\nHold start to show another wheel\r\nEach wheel entry is a box with the icons for the tools it contains\r\nSwitching to a Toolbelt will unequip Toolbelt that have conflicting bindings\r\n\r\n\r\nHolding start shows a diagram of the controller. Will need to build a representation of the controller in the game. The Dpad, the sticks, and the buttons can all be used as 8-directional picker wheels. L1, R1 can be used as additional shift keys to open more wheels. \r\n\r\n\r\nRebind tool - show 6 controller previews (select, select+L1, select+r2, start, start+R1, start+r2) with the picker wheels. Let user click and drag toolbelts between picker wheel slots. \r\n\r\nChord rebinding - record a key sequence to identify the source, record a second key sequence as the destination, perform move. \r\n\r\nRebinding is done by changing the runtime input maps in addition to editing the source code defaults so that the changes persist between runs. If the file is open with modifications in vscode, save the file before editing on disk. \r\n\r\n\r\nWindow management tool\r\nL3 - swap - switch the position of the cursor hero window with the window under the pointer. If cursor hero is on left monitor and vscode on main, easily swap the two sizes and positions.\r\nDpad - arrow keys\r\nWest - windows button\r\nSouth - alt\r\nL1 - tab\r\nR1 - mouse1\r\nNorth - maximize\r\nEast - minimize\r\nLets the user do win+tab or alt+tab chords.\r\nL2 - open task bar wheel. Take the task bar and stretch it to fit a circle. Map the pointer position from the wheel to the actual task bar position so when the user clicks with R1 it clicks the task bar. Make the icon at the edge of the circle and have the label on the outside (if at the left of the circle, the icon and label will be reversed from the usual taskbar layout where the icon is to the left of the window title) \r\nIf there are many windows open, the circle will wrap around. Each icon has a larger radius than the previous one, such that it is on a new orbit by the time it wraps around to the start. Only show the window titles for the orbit radius closest to the pointer. \r\n\r\n\r\nRight monitor is easy input switch. Left 2 monitors for work (mouse n keyboard), right monitor to control personal system with the controller. \r\n\r\n\r\nMedia controls\r\n- pause play\r\n- volume\r\n- skip, previous\r\n- show currently playing\r\n\r\n\r\n\r\nBoundary/zone tool\r\nDraw new boundaries\r\nDelete boundaries\r\nLock boundaries\r\nUnlock boundaries\r\n\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\bevy\\src\\lib.rs\r\n\r\n````rust\r\nmod neg_y;\r\nmod rect_expand;\r\nmod rect_extents;\r\nmod rect_in_rect;\r\nmod rect_scaled;\r\nmod rect_with_properties;\r\nmod translate;\r\nmod vec_into_rect;\r\n\r\npub mod prelude {\r\n    pub use crate::neg_y::*;\r\n    pub use crate::rect_expand::*;\r\n    pub use crate::rect_extents::*;\r\n    pub use crate::rect_in_rect::*;\r\n    pub use crate::rect_scaled::*;\r\n    pub use crate::rect_with_properties::*;\r\n    pub use crate::translate::*;\r\n    pub use crate::vec_into_rect::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\winutils\\examples\\app_icons_bevy_example.rs\r\n\r\n````rust\r\nuse bevy::input::common_conditions::input_toggle_active;\r\nuse bevy::log::LogPlugin;\r\nuse bevy::prelude::*;\r\nuse bevy::utils::HashMap;\r\nuse bevy_inspector_egui::quick::WorldInspectorPlugin;\r\nuse cursor_hero_winutils::win_errors::*;\r\nuse cursor_hero_winutils::win_icons::get_images_from_exe;\r\nuse cursor_hero_winutils::win_process::*;\r\nuse cursor_hero_worker::prelude::*;\r\nuse image::DynamicImage;\r\nuse image::RgbaImage;\r\nuse windows::core::PWSTR;\r\nuse windows::Win32::Foundation::E_ACCESSDENIED;\r\nfn main() {\r\n    let mut app = App::new();\r\n    app.add_plugins(\r\n        DefaultPlugins\r\n            .set(LogPlugin {\r\n                level: bevy::log::Level::DEBUG,\r\n                filter: \"\r\ninfo,\r\nwgpu_core=warn,\r\nwgpu_hal=warn,\r\ncursor_hero=debug,\r\napp_icons_bevy_example=trace,\r\n\"\r\n                .replace('\\n', \"\")\r\n                .trim()\r\n                .into(),\r\n            })\r\n            .build(),\r\n    );\r\n    app.add_plugins(WorkerPlugin {\r\n        config: WorkerConfig::<ThreadboundMessage, GameboundMessage> {\r\n            name: \"ui_snapshot\".to_string(),\r\n            is_ui_automation_thread: true,\r\n            handle_threadbound_message: |msg, reply_tx| {\r\n                handle_threadbound_message(msg, reply_tx).map_err(|e| Box::new(e) as _)\r\n            },\r\n            ..default()\r\n        },\r\n    });\r\n    app.add_systems(Update, receive);\r\n    app.add_systems(Startup, trigger);\r\n    app.add_systems(Startup, camera_setup);\r\n    app.add_plugins(\r\n        WorldInspectorPlugin::default().run_if(input_toggle_active(false, KeyCode::Grave)),\r\n    );\r\n    app.run();\r\n}\r\n\r\n#[derive(Debug, Reflect, Clone, Event)]\r\nenum ThreadboundMessage {\r\n    GatherRunningProcessIcons,\r\n}\r\nimpl Message for ThreadboundMessage {}\r\n\r\n#[derive(Debug, Clone, Event)]\r\nenum GameboundMessage {\r\n    RunningProcessIcons(HashMap<String, Vec<RgbaImage>>),\r\n}\r\nimpl Message for GameboundMessage {}\r\n\r\nfn handle_threadbound_message(\r\n    msg: &ThreadboundMessage,\r\n    reply_tx: &Sender<GameboundMessage>,\r\n) -> Result<()> {\r\n    let ThreadboundMessage::GatherRunningProcessIcons = msg;\r\n    let process_iter = ProcessIterator::new()?;\r\n    let mut result = HashMap::new();\r\n    unsafe {\r\n        for mut process in process_iter {\r\n            let exe_name_pwstr = PWSTR(process.szExeFile.as_mut_ptr());\r\n            let exe_name = exe_name_pwstr.to_string()?;\r\n            let exe_path = match get_process_full_name(process.th32ProcessID) {\r\n                Ok(s) => s,\r\n                Err(e) => {\r\n                    if matches!(\r\n                        e,\r\n                        Error::Windows(ref e) if e.code() == E_ACCESSDENIED\r\n                    ) {\r\n                        continue;\r\n                    }\r\n                    warn!(\r\n                        \"Failed to get full process name for PID {:05} ({}): {:?}\",\r\n                        process.th32ProcessID, exe_name, e\r\n                    );\r\n                    continue;\r\n                }\r\n            };\r\n            if result.contains_key(&exe_path) {\r\n                continue;\r\n            }\r\n            let icons = get_images_from_exe(exe_path.as_str())?;\r\n            result.insert(exe_path, icons);\r\n        }\r\n    }\r\n    if let Err(e) = reply_tx.send(GameboundMessage::RunningProcessIcons(result)) {\r\n        error!(\"Failed to send snapshot: {:?}\", e);\r\n    }\r\n\r\n    Ok(())\r\n}\r\n\r\nfn camera_setup(mut commands: Commands) {\r\n    commands.spawn(Camera2dBundle::default());\r\n    // commands.spawn((\r\n    //     SpriteBundle {\r\n    //         transform: Transform::from_translation(Vec3::new(0.0, 0.0, 0.0)),\r\n    //         sprite: Sprite {\r\n    //             color: Color::WHITE,\r\n    //             custom_size: Some(Vec2::new(100.0, 100.0)),\r\n    //             ..default()\r\n    //         },\r\n    //         ..default()\r\n    //     },\r\n    // ));\r\n}\r\n\r\nfn trigger(mut events: EventWriter<ThreadboundMessage>) {\r\n    events.send(ThreadboundMessage::GatherRunningProcessIcons);\r\n}\r\n\r\nfn receive(\r\n    mut commands: Commands,\r\n    mut bridge: EventReader<GameboundMessage>,\r\n    mut icons_so_far: Local<usize>,\r\n    mut textures: ResMut<Assets<Image>>,\r\n) {\r\n    for msg in bridge.read() {\r\n        match msg {\r\n            GameboundMessage::RunningProcessIcons(icons) => {\r\n                info!(\"Received icons: {:?}\", icons.len());\r\n                for (exe_path, images) in icons {\r\n                    for image in images {\r\n                        debug!(\"{}x{}\", image.width(), image.height());\r\n                        let dynamic = DynamicImage::ImageRgba8(image.clone());\r\n                        let handle = textures.add(Image::from_dynamic(dynamic, true));\r\n                        let icons_per_row = 5;\r\n                        let icon_size = 100.0;\r\n                        let margin = 10.0;\r\n                        commands.spawn((\r\n                            SpriteBundle {\r\n                                texture: handle,\r\n                                transform: Transform::from_translation(Vec3::new(\r\n                                    (*icons_so_far % icons_per_row) as f32 * (icon_size + margin),\r\n                                    (*icons_so_far / icons_per_row) as f32 * (icon_size + margin),\r\n                                    0.0,\r\n                                )),\r\n                                sprite: Sprite {\r\n                                    color: Color::hsl(\r\n                                        *icons_so_far as f32 / icons.len() as f32 * 360.0,\r\n                                        1.0,\r\n                                        0.5,\r\n                                    ),\r\n                                    custom_size: Some(Vec2::splat(icon_size)),\r\n                                    ..default()\r\n                                },\r\n                                ..default()\r\n                            },\r\n                            Name::new(exe_path.clone()),\r\n                        ));\r\n                        *icons_so_far += 1;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\observation_types\\src\\lib.rs\r\n\r\n````rust\r\n#![feature(trivial_bounds)]\r\npub mod observation_types;\r\npub mod observation_types_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::observation_types::*;\r\n    pub use crate::observation_types_plugin::ObservationTypesPlugin;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\chat\\src\\chat_sfx_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse cursor_hero_character_types::prelude::*;\r\nuse cursor_hero_chat_types::prelude::*;\r\nuse rand::prelude::SliceRandom;\r\npub struct ChatSfxPlugin;\r\n\r\nimpl Plugin for ChatSfxPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Update, play_sound_for_new_chat_messages);\r\n        app.add_systems(Update, play_sound_for_keystrokes);\r\n    }\r\n}\r\nfn play_sound_for_new_chat_messages(\r\n    mut commands: Commands,\r\n    mut events: EventReader<ChatEvent>,\r\n    character_query: Query<&Transform, With<Character>>,\r\n    asset_server: Res<AssetServer>,\r\n) {\r\n    for event in events.read() {\r\n        let ChatEvent::Chat { character_id, .. } = event;\r\n        let Ok(character) = character_query.get(*character_id) else {\r\n            warn!(\"Character not found for event {:?}\", event);\r\n            continue;\r\n        };\r\n        let character_transform = character;\r\n        commands.spawn((\r\n            AudioBundle {\r\n                source: asset_server.load(\"sounds/kenny_bong_001.ogg\"),\r\n                settings: PlaybackSettings::DESPAWN.with_spatial(true),\r\n            },\r\n            SpatialBundle {\r\n                transform: *character_transform,\r\n                ..default()\r\n            },\r\n        ));\r\n    }\r\n}\r\n\r\nfn play_sound_for_keystrokes(\r\n    mut commands: Commands,\r\n    mut events: EventReader<ChatInputEvent>,\r\n    character_query: Query<&Transform, With<Character>>,\r\n    asset_server: Res<AssetServer>,\r\n) {\r\n    for event in events.read() {\r\n        let ChatInputEvent::TextChanged { character_id, .. } = event else {\r\n            continue;\r\n        };\r\n        let Ok(character) = character_query.get(*character_id) else {\r\n            warn!(\"Character not found for event {:?}\", event);\r\n            continue;\r\n        };\r\n        let character_transform = character;\r\n\r\n        // optimization opportunity: avoid unnecessary allocations\r\n        let choices = [\"sounds/kenny_click_002.ogg\", \"sounds/kenny_click_003.ogg\"];\r\n        let Some(choice) = choices.choose(&mut rand::thread_rng()) else {\r\n            continue;\r\n        };\r\n\r\n        commands.spawn((\r\n            AudioBundle {\r\n                source: asset_server.load(*choice),\r\n                settings: PlaybackSettings::DESPAWN.with_spatial(true),\r\n            },\r\n            SpatialBundle {\r\n                transform: *character_transform,\r\n                ..default()\r\n            },\r\n        ));\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\environment\\src\\lib.rs\r\n\r\n````rust\r\npub mod environment_plugin;\r\npub mod environment_tracker_plugin;\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\movement_tool\\src\\movement_tool_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n\r\nuse crate::movement_speed_plugin::MovementSpeedPlugin;\r\nuse crate::movement_sprint_plugin::MovementSprintPlugin;\r\nuse crate::movement_target_plugin::MovementTargetPlugin;\r\nuse crate::movement_tool_populate_plugin::MovementToolPopulatePlugin;\r\nuse crate::movement_tool_tick_plugin::MovementToolTickPlugin;\r\n\r\npub struct MovementToolPlugin;\r\n\r\nimpl Plugin for MovementToolPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_plugins(MovementSpeedPlugin);\r\n        app.add_plugins(MovementSprintPlugin);\r\n        app.add_plugins(MovementToolTickPlugin);\r\n        app.add_plugins(MovementTargetPlugin);\r\n        app.add_plugins(MovementToolPopulatePlugin);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\app_types\\src\\lib.rs\r\n\r\n````rust\r\npub mod app_types;\r\npub mod app_types_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::app_types::*;\r\n    pub use crate::app_types_plugin::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\chat_types\\src\\chat_types.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse bevy::utils::HashSet;\r\nuse cursor_hero_toolbelt_types::prelude::*;\r\nuse leafwing_input_manager::prelude::*;\r\n\r\n#[derive(Component, Debug, Reflect, Default)]\r\npub struct ChatTool {\r\n    pub focused: bool,\r\n    pub buffer: String,\r\n    pub tools_disabled_during_focus: HashSet<Entity>,\r\n    pub state: ChatToolState,\r\n}\r\n\r\n#[derive(PartialEq, Reflect, Debug, Default, Clone)]\r\npub enum ChatToolState {\r\n    #[default]\r\n    Idle,\r\n    InitialRepeatDelay(Timer),\r\n    RepeatDelay(Timer),\r\n}\r\n\r\n#[derive(Component, Reflect, Default)]\r\npub struct ChatWheelTool;\r\n\r\n#[derive(Actionlike, PartialEq, Eq, Clone, Copy, Hash, Debug, Reflect)]\r\npub enum ChatToolAction {\r\n    Focus,\r\n    Unfocus,\r\n    Submit,\r\n    WordModifier,\r\n    Backspace,\r\n}\r\n\r\nimpl ChatToolAction {\r\n    fn default_gamepad_binding(&self) -> UserInput {\r\n        match self {\r\n            Self::Focus => GamepadButtonType::North.into(),\r\n            Self::Unfocus => GamepadButtonType::East.into(),\r\n            Self::Submit => GamepadButtonType::South.into(),\r\n            Self::WordModifier => GamepadButtonType::LeftTrigger.into(),\r\n            Self::Backspace => GamepadButtonType::West.into(),\r\n        }\r\n    }\r\n\r\n    fn default_mkb_binding(&self) -> UserInput {\r\n        match self {\r\n            Self::Focus => KeyCode::Return.into(),\r\n            Self::Unfocus => KeyCode::Escape.into(),\r\n            Self::Submit => KeyCode::Return.into(),\r\n            Self::WordModifier => KeyCode::ControlLeft.into(),\r\n            Self::Backspace => KeyCode::Back.into(),\r\n        }\r\n    }\r\n}\r\nimpl ToolAction for ChatToolAction {\r\n    fn default_input_map(_event: &ToolbeltPopulateEvent) -> Option<InputMap<ChatToolAction>> {\r\n        let mut input_map = InputMap::default();\r\n\r\n        for variant in ChatToolAction::variants() {\r\n            input_map.insert(variant.default_mkb_binding(), variant);\r\n            input_map.insert(variant.default_gamepad_binding(), variant);\r\n        }\r\n        Some(input_map)\r\n    }\r\n}\r\n\r\n#[derive(Event, PartialEq, Eq, Clone, Hash, Debug, Reflect)]\r\npub enum ChatEvent {\r\n    Chat {\r\n        character_id: Entity,\r\n        message: String,\r\n    },\r\n}\r\n\r\n#[derive(Event, PartialEq, Eq, Clone, Hash, Debug, Reflect)]\r\npub enum ChatInputEvent {\r\n    Focus {\r\n        tool_id: Entity,\r\n        toolbelt_id: Entity,\r\n        character_id: Entity,\r\n    },\r\n    Unfocus {\r\n        tool_id: Entity,\r\n        toolbelt_id: Entity,\r\n        character_id: Entity,\r\n    },\r\n    TextChanged {\r\n        character_id: Entity,\r\n        toolbelt_id: Entity,\r\n        tool_id: Entity,\r\n    },\r\n}\r\n\r\n#[derive(Component, Reflect, Debug, Default)]\r\npub struct ChatInput;\r\n\r\n#[derive(Component, Reflect, Debug, Default)]\r\npub struct ChatBubble {\r\n    pub lifetime: Timer,\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\observation\\src\\observation_tool_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse cursor_hero_character_types::character_types::AgentCharacter;\r\nuse cursor_hero_chat_types::chat_types::ChatEvent;\r\nuse cursor_hero_inference_types::prelude::*;\r\nuse cursor_hero_observation_types::prelude::*;\r\nuse cursor_hero_toolbelt_types::prelude::*;\r\nuse cursor_hero_tools::prelude::*;\r\n\r\npub struct ObservationToolPlugin;\r\n\r\nimpl Plugin for ObservationToolPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Update, toolbelt_events);\r\n        app.add_systems(Update, tool_tick);\r\n        app.add_systems(Update, handle_text_inference_response);\r\n        app.add_systems(Update, handle_tts_inference_response);\r\n    }\r\n}\r\n\r\nfn toolbelt_events(\r\n    mut commands: Commands,\r\n    asset_server: Res<AssetServer>,\r\n    mut reader: EventReader<ToolbeltPopulateEvent>,\r\n) {\r\n    for event in reader.read() {\r\n        if event.loadout == ToolbeltLoadout::Agent {\r\n            ToolSpawnConfig::<ObservationTool, NoInputs>::new(\r\n                ObservationTool::default(),\r\n                event.id,\r\n                event,\r\n            )\r\n            .with_src_path(file!().into())\r\n            .guess_name(file!())\r\n            .guess_image(file!(), &asset_server, \"png\")\r\n            .with_description(\"Logs information about the environment to the console.\")\r\n            .with_starting_state(StartingState::Inactive)\r\n            .spawn(&mut commands);\r\n        }\r\n    }\r\n}\r\n\r\n#[allow(clippy::type_complexity)]\r\nfn tool_tick(\r\n    mut tool_query: Query<(&Parent, &mut ObservationTool), With<ActiveTool>>,\r\n    toolbelt_query: Query<&Parent, With<Toolbelt>>,\r\n    mut character_query: Query<&mut ObservationBuffer>,\r\n    mut events: EventWriter<TextInferenceEvent>,\r\n) {\r\n    for tool in tool_query.iter_mut() {\r\n        let (tool_parent, mut tool) = tool;\r\n\r\n        let Ok(toolbelt) = toolbelt_query.get(tool_parent.get()) else {\r\n            warn!(\"Failed to get toolbelt\");\r\n            continue;\r\n        };\r\n        let toolbelt_parent = toolbelt;\r\n\r\n        let character_id = toolbelt_parent.get();\r\n        let Ok(character) = character_query.get_mut(character_id) else {\r\n            warn!(\"Failed to get character\");\r\n            continue;\r\n        };\r\n\r\n        let character_observation_buffer = character;\r\n        let whats_new = tool\r\n            .last_inference\r\n            .map(|last_inference| {\r\n                character_observation_buffer\r\n                    .observations\r\n                    .iter()\r\n                    .filter(|entry| entry.datetime > last_inference)\r\n                    .map(|entry| entry.origin.into_whats_new(character_id))\r\n                    .fold(WhatsNew::Nothing, |acc, new| acc.max(new))\r\n            })\r\n            .unwrap_or_else(|| {\r\n                character_observation_buffer\r\n                    .observations\r\n                    .iter()\r\n                    .map(|entry| entry.origin.into_whats_new(character_id))\r\n                    .fold(WhatsNew::Nothing, |acc, new| acc.max(new))\r\n            });\r\n\r\n        // Update the field for debug viewing in the inspector\r\n        tool._whats_new = Some(whats_new);\r\n\r\n        // the agent will observe its own chats\r\n        // so this check doesn't prevent all forms of loops\r\n        if let WhatsNew::Nothing = whats_new {\r\n            continue;\r\n        }\r\n\r\n        if let Some(last_inference) = tool.last_inference {\r\n            if last_inference + whats_new.reply_delay() > chrono::Local::now() {\r\n                continue;\r\n            }\r\n        }\r\n\r\n        let mut chat_history = String::new();\r\n        for entry in character_observation_buffer.observations.iter() {\r\n            // let timestamp = entry.datetime.format(\"%Y-%m-%d %H:%M:%S\").to_string();\r\n            chat_history.push_str(entry.origin.to_string().as_str());\r\n            chat_history.push('\\n');\r\n        }\r\n\r\n        events.send(TextInferenceEvent::Request {\r\n            session_id: character_id,\r\n            prompt: TextPrompt::Chat {\r\n                chat_history,\r\n                options: Some(TextInferenceOptions {\r\n                    stop: Some(vec![\r\n                        \"\\n\".to_string(),\r\n                        \"(Human)\".to_string(),\r\n                        \"(Tume Eena)\".to_string(),\r\n                        \"(Ithia Tig)\".to_string(),\r\n                    ]),\r\n                    ..default()\r\n                }),\r\n            },\r\n        });\r\n        debug!(\"ObservationToolPlugin: Sent observation event\");\r\n\r\n        tool.last_inference = Some(chrono::Local::now());\r\n    }\r\n}\r\n\r\nfn handle_text_inference_response(\r\n    mut inference_events: EventReader<TextInferenceEvent>,\r\n    mut chat_events: EventWriter<ChatEvent>,\r\n    mut tts_events: EventWriter<SpeechInferenceEvent>,\r\n    agent_query: Query<(), With<AgentCharacter>>,\r\n) {\r\n    for event in inference_events.read() {\r\n        let TextInferenceEvent::Response {\r\n            response,\r\n            session_id,\r\n            ..\r\n        } = event\r\n        else {\r\n            continue;\r\n        };\r\n        if agent_query.get(*session_id).is_err() {\r\n            // Only inference responses for agent sessions are to be converted to chat messages and spoken\r\n            continue;\r\n        }\r\n\r\n        if response.is_empty() {\r\n            debug!(\"Received empty response, skipping\");\r\n            continue;\r\n        }\r\n\r\n        let event = ChatEvent::Chat {\r\n            character_id: *session_id,\r\n            message: response.clone(),\r\n        };\r\n        debug!(\"Sending event: {:?}\", event);\r\n        chat_events.send(event);\r\n\r\n        let event = SpeechInferenceEvent::Request {\r\n            session_id: *session_id,\r\n            prompt: SpeechPrompt::Raw {\r\n                content: response.clone(),\r\n            },\r\n        };\r\n        debug!(\"Sending event: {:?}\", event);\r\n        tts_events.send(event);\r\n    }\r\n}\r\n\r\nfn handle_tts_inference_response(\r\n    mut commands: Commands,\r\n    mut tts_events: EventReader<SpeechInferenceEvent>,\r\n    agent_query: Query<(), With<AgentCharacter>>,\r\n    mut audio_assets: ResMut<Assets<AudioSource>>,\r\n) {\r\n    for event in tts_events.read() {\r\n        if let SpeechInferenceEvent::Response {\r\n            session_id, wav, ..\r\n        } = event\r\n        {\r\n            if agent_query.get(*session_id).is_ok() {\r\n                info!(\r\n                    \"Received TTS response for session {:?}, playing\",\r\n                    session_id\r\n                );\r\n                let audio = audio_assets.add(AudioSource {\r\n                    bytes: wav.clone().into(),\r\n                });\r\n                commands.entity(*session_id).insert({\r\n                    AudioBundle {\r\n                        source: audio,\r\n                        settings: PlaybackSettings::REMOVE.with_spatial(true),\r\n                    }\r\n                });\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\toolbelt\\src\\tool_visibility.rs\r\n\r\n````rust\r\nuse cursor_hero_toolbelt_types::toolbelt_types::*;\r\n\r\nuse bevy::prelude::*;\r\nuse leafwing_input_manager::action_state::ActionState;\r\n\r\n#[allow(clippy::type_complexity)]\r\npub fn tool_visibility(\r\n    mut toolbelts: Query<\r\n        (&ActionState<ToolbeltAction>, &mut Wheel, &Children),\r\n        (Without<Tool>, With<Toolbelt>),\r\n    >,\r\n    mut tool_query: Query<(Entity, &mut Transform, &mut Visibility, &mut Sprite), With<Tool>>,\r\n) {\r\n    for (toolbelt_actions, wheel, toolbelt_kids) in toolbelts.iter_mut() {\r\n        if toolbelt_actions.just_pressed(ToolbeltAction::Show) {\r\n            debug!(\"Updating toolbelt visibility => visible\");\r\n            for child_id in toolbelt_kids.iter() {\r\n                if let Ok((_, _, mut tool_visibility, _)) = tool_query.get_mut(*child_id) {\r\n                    *tool_visibility = Visibility::Visible;\r\n                }\r\n            }\r\n        } else if toolbelt_actions.just_released(ToolbeltAction::Show) {\r\n            debug!(\"Updating toolbelt visibility => hidden\");\r\n            for child_id in toolbelt_kids.iter() {\r\n                if let Ok((_, _, mut tool_visibility, _)) = tool_query.get_mut(*child_id) {\r\n                    *tool_visibility = Visibility::Hidden;\r\n                }\r\n            }\r\n        }\r\n        if wheel.open {\r\n            for child_id in toolbelt_kids.iter() {\r\n                if let Ok((_, _, _, mut tool_sprite)) = tool_query.get_mut(*child_id) {\r\n                    tool_sprite.color = tool_sprite.color.with_a(wheel.alpha);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\environment_types\\src\\environment_types_plugin.rs\r\n\r\n````rust\r\nuse crate::prelude::*;\r\nuse bevy::prelude::*;\r\n\r\npub struct EnvironmentTypesPlugin;\r\n\r\nimpl Plugin for EnvironmentTypesPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<TrackEnvironmentTag>();\r\n        app.register_type::<EnvironmentTracker>();\r\n        app.register_type::<EnvironmentKind>();\r\n        app.register_type::<HostEnvironment>();\r\n        app.register_type::<HostUIWatcherEnvironment>();\r\n        app.register_type::<GameEnvironment>();\r\n        app.register_type::<Nametag>();\r\n        app.add_event::<CreateEnvironmentRequestEvent>();\r\n        app.add_event::<PopulateEnvironmentEvent>();\r\n        app.add_event::<NametagEvent>();\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\glados_tts\\src\\glados_tts_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n\r\nuse crate::glados_tts_button_plugin::GladosTtsButtonPlugin;\r\nuse crate::glados_tts_inference_plugin::GladosTtsInferencePlugin;\r\nuse crate::glados_tts_status_plugin::GladosTtsStatusPlugin;\r\nuse crate::glados_tts_status_worker_plugin::GladosTtsStatusWorkerPlugin;\r\n\r\npub struct GladosTtsPlugin;\r\n\r\nimpl Plugin for GladosTtsPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_plugins(GladosTtsInferencePlugin);\r\n        app.add_plugins(GladosTtsButtonPlugin);\r\n        app.add_plugins(GladosTtsStatusPlugin);\r\n        app.add_plugins(GladosTtsStatusWorkerPlugin);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\floaty_nametag_types\\src\\floaty_nametag_types.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n\r\n#[derive(Component, Debug, Reflect)]\r\npub struct FloatyName {\r\n    pub text: String,\r\n    pub vertical_offset: f32,\r\n    pub appearance: NametagAppearance,\r\n}\r\n\r\n#[derive(Component, Debug, Reflect)]\r\npub struct FloatyNametag {\r\n    pub owner: Entity,\r\n}\r\n\r\n#[derive(Debug, Reflect)]\r\npub enum NametagAppearance {\r\n    Character,\r\n    Databrick,\r\n}\r\nimpl NametagAppearance {\r\n    pub fn get_font_path(&self) -> String {\r\n        match self {\r\n            NametagAppearance::Character => \"fonts/kenney_kenney-fonts/Fonts/Kenney Rocket.ttf\",\r\n            NametagAppearance::Databrick => \"fonts/kenney_kenney-fonts/Fonts/Kenney Blocks.ttf\",\r\n        }\r\n        .to_string()\r\n    }\r\n    pub fn get_text_color(&self) -> Color {\r\n        match self {\r\n            NametagAppearance::Character => Color::GREEN,\r\n            NametagAppearance::Databrick => Color::BLUE,\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\window_position\\src\\window_position_tool_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse bevy::window::PrimaryWindow;\r\nuse bevy::window::WindowMode;\r\nuse bevy::window::WindowResolution;\r\nuse cursor_hero_bevy::prelude::BottomRightI;\r\nuse cursor_hero_bevy::prelude::CornerOfIRect;\r\nuse cursor_hero_bevy::prelude::IRectScale;\r\nuse cursor_hero_bevy::prelude::TopLeftI;\r\nuse cursor_hero_bevy::prelude::TranslateIVec2;\r\nuse cursor_hero_math::prelude::Corner;\r\nuse cursor_hero_toolbelt_types::prelude::ToolbeltPopulateEvent;\r\nuse cursor_hero_toolbelt_types::toolbelt_types::ActiveTool;\r\nuse cursor_hero_toolbelt_types::toolbelt_types::ToolbeltLoadout;\r\nuse cursor_hero_tools::prelude::NoInputs;\r\nuse cursor_hero_tools::prelude::ToolSpawnConfig;\r\nuse cursor_hero_tools::tool_spawning::StartingState;\r\nuse cursor_hero_window_position_types::prelude::HostWindowPosition;\r\nuse cursor_hero_window_position_types::prelude::WindowPositionTool;\r\nuse cursor_hero_window_position_types::window_position_types::WindowPositionCommand;\r\nuse cursor_hero_winutils::win_mouse::set_cursor_position;\r\nuse cursor_hero_winutils::win_screen_capture::get_all_monitors;\r\nuse cursor_hero_winutils::win_screen_capture::get_monitor_infos;\r\nuse cursor_hero_winutils::win_screen_capture::Monitor;\r\nuse image::ImageBuffer;\r\nuse image::Rgba;\r\npub struct WindowPositionToolPlugin;\r\n\r\nimpl Plugin for WindowPositionToolPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Update, populate_toolbelts);\r\n        app.add_systems(Update, do_position);\r\n    }\r\n}\r\n\r\nfn populate_toolbelts(\r\n    mut commands: Commands,\r\n    mut reader: EventReader<ToolbeltPopulateEvent>,\r\n    mut textures: ResMut<Assets<Image>>,\r\n) {\r\n    for event in reader.read() {\r\n        if event.loadout != ToolbeltLoadout::WindowPosition {\r\n            continue;\r\n        }\r\n        let Ok(monitors) = get_all_monitors() else {\r\n            warn!(\"No monitors found\");\r\n            continue;\r\n        };\r\n        let icon_size = UVec2::new(500, 500);\r\n\r\n        let mut world = IRect::from_corners(\r\n            monitors\r\n                .iter()\r\n                .map(|monitor| monitor.info.rect.top_left())\r\n                .reduce(|a, b| a.min(b))\r\n                .unwrap_or_default(),\r\n            monitors\r\n                .iter()\r\n                .map(|monitor| monitor.info.rect.bottom_right())\r\n                .reduce(|a, b| a.max(b))\r\n                .unwrap_or_default(),\r\n        );\r\n\r\n        // expand it to be square aspect ratio\r\n        if world.size().x > world.size().y {\r\n            world = world.scale(Vec2::new(\r\n                1.0,\r\n                world.size().x as f32 / world.size().y as f32,\r\n            ));\r\n        } else {\r\n            world = world.scale(Vec2::new(\r\n                world.size().y as f32 / world.size().x as f32,\r\n                1.0,\r\n            ));\r\n        }\r\n\r\n        for monitor in monitors.iter() {\r\n            for corner in Corner::variants() {\r\n                let name = format!(\"{:?} Monitor {}\", corner, monitor.info.name);\r\n\r\n                let image = image_for_monitor_corner(icon_size, world, monitor, &corner);\r\n                let texture = textures.add(image);\r\n\r\n                ToolSpawnConfig::<WindowPositionTool, NoInputs>::new(\r\n                    WindowPositionTool {\r\n                        window_position: HostWindowPosition::Corner {\r\n                            corner,\r\n                            monitor: monitor.info.id,\r\n                        },\r\n                    },\r\n                    event.id,\r\n                    event,\r\n                )\r\n                .with_src_path(file!().into())\r\n                .with_name(name.clone())\r\n                .with_image(texture)\r\n                .with_description(\"Moves the game window\")\r\n                .with_size(Vec2::new(100.0, 100.0))\r\n                .with_starting_state(StartingState::Inactive)\r\n                .spawn(&mut commands);\r\n            }\r\n            let name = format!(\"fullscreen_monitor_{}\", monitor.info.id);\r\n            ToolSpawnConfig::<WindowPositionTool, NoInputs>::new(\r\n                WindowPositionTool {\r\n                    window_position: HostWindowPosition::Fullscreen {\r\n                        monitor: monitor.info.id,\r\n                    },\r\n                },\r\n                event.id,\r\n                event,\r\n            )\r\n            .with_src_path(file!().into())\r\n            .with_name(name.clone())\r\n            .with_image(textures.add(image_for_monitor(icon_size, world, monitor)))\r\n            .with_description(\"Moves the game window\")\r\n            .with_size(Vec2::new(100.0, 100.0))\r\n            .with_starting_state(StartingState::Inactive)\r\n            .spawn(&mut commands);\r\n        }\r\n    }\r\n}\r\n\r\nfn image_for_monitor_corner(\r\n    icon_size: UVec2,\r\n    world: IRect,\r\n    monitor: &Monitor,\r\n    corner: &Corner,\r\n) -> Image {\r\n    let mut imgbuf =\r\n        ImageBuffer::from_pixel(icon_size.x, icon_size.y, Rgba([173u8, 216u8, 230u8, 255u8])); // Light blue background\r\n\r\n    let scale = icon_size.as_vec2() / world.size().as_vec2();\r\n    let monitor_icon_region = monitor.info.rect.translate(&-world.min).scale(scale);\r\n    debug!(\r\n        \"Monitor icon region: {:?}, scale: {:?}\",\r\n        monitor_icon_region, scale\r\n    );\r\n\r\n    let dest_icon_region = IRect::from_corners(\r\n        monitor_icon_region.center(),\r\n        corner.of(&monitor_icon_region),\r\n    );\r\n    for (x, y, pixel) in imgbuf.enumerate_pixels_mut() {\r\n        if monitor_icon_region.contains(IVec2::new(x as i32, y as i32)) {\r\n            *pixel = Rgba([255u8, 0u8, 0u8, 255u8]);\r\n        }\r\n        if dest_icon_region.contains(IVec2::new(x as i32, y as i32)) {\r\n            *pixel = Rgba([0u8, 255u8, 0u8, 255u8]);\r\n        }\r\n    }\r\n    Image::from_dynamic(imgbuf.into(), true)\r\n}\r\n\r\nfn image_for_monitor(icon_size: UVec2, world: IRect, monitor: &Monitor) -> Image {\r\n    let mut imgbuf =\r\n        ImageBuffer::from_pixel(icon_size.x, icon_size.y, Rgba([173u8, 216u8, 230u8, 255u8])); // Light blue background\r\n\r\n    let scale = icon_size.as_vec2() / world.size().as_vec2();\r\n    let monitor_icon_region = monitor.info.rect.translate(&-world.min).scale(scale);\r\n    debug!(\r\n        \"Monitor icon region: {:?}, scale: {:?}\",\r\n        monitor_icon_region, scale\r\n    );\r\n    for (x, y, pixel) in imgbuf.enumerate_pixels_mut() {\r\n        if monitor_icon_region.contains(IVec2::new(x as i32, y as i32)) {\r\n            *pixel = Rgba([0u8, 0u8, 255u8, 255u8]);\r\n        }\r\n    }\r\n    Image::from_dynamic(imgbuf.into(), true)\r\n}\r\n\r\nfn do_position(\r\n    mut commands: Commands,\r\n    tool_query: Query<(Entity, &WindowPositionTool), With<ActiveTool>>,\r\n    mut window_query: Query<Entity, With<PrimaryWindow>>,\r\n    mut window_commands: EventWriter<WindowPositionCommand>,\r\n) {\r\n    let Ok(monitor_infos) = get_monitor_infos() else {\r\n        return;\r\n    };\r\n\r\n    for tool in tool_query.iter() {\r\n        let (tool_id, tool) = tool;\r\n        let Ok(window) = window_query.get_single_mut() else {\r\n            error!(\"No primary window found\");\r\n            return;\r\n        };\r\n        let window_id = window;\r\n        match tool.window_position {\r\n            HostWindowPosition::Corner {\r\n                ref corner,\r\n                monitor,\r\n            } => {\r\n                let Some(monitor) = monitor_infos.iter().find(|info| info.id == monitor) else {\r\n                    warn!(\"No monitor found with id: {}\", monitor);\r\n                    continue;\r\n                };\r\n                debug!(\r\n                    \"Activating corner: {:?} on monitor: {}\",\r\n                    corner, monitor.name\r\n                );\r\n                let dest_bounds = IRect::from_corners(\r\n                    monitor.work_area.center(),\r\n                    corner.of(&monitor.work_area)\r\n                        - ((corner.of(&monitor.work_area) - monitor.work_area.center())\r\n                            .as_vec2()\r\n                            .normalize()\r\n                            * 100.0)\r\n                            .as_ivec2(),\r\n                );\r\n                window_commands.send(WindowPositionCommand {\r\n                    window: window_id,\r\n                    position: Some(WindowPosition::At(dest_bounds.top_left())),\r\n                    resolution: Some(WindowResolution::new(\r\n                        dest_bounds.width() as f32,\r\n                        dest_bounds.height() as f32,\r\n                    )),\r\n                    mode: Some(WindowMode::Windowed),\r\n                });\r\n                if let Err(e) = set_cursor_position(dest_bounds.center()) {\r\n                    warn!(\"Failed to set cursor position: {}\", e);\r\n                }\r\n                commands.entity(tool_id).remove::<ActiveTool>();\r\n            }\r\n            HostWindowPosition::Fullscreen { monitor } => {\r\n                let Some(monitor) = monitor_infos.iter().find(|info| info.id == monitor) else {\r\n                    warn!(\"No monitor found with id: {}\", monitor);\r\n                    continue;\r\n                };\r\n                debug!(\"Activating fullscreen on monitor: {}\", monitor.name);\r\n                let margin = 50;\r\n                window_commands.send(WindowPositionCommand {\r\n                    window: window_id,\r\n                    position: Some(WindowPosition::At(\r\n                        monitor.work_area.top_left() + IVec2::splat(margin),\r\n                    )),\r\n                    resolution: Some(WindowResolution::new(\r\n                        (monitor.work_area.width() + margin * 2) as f32,\r\n                        (monitor.work_area.height() + margin * 2) as f32,\r\n                    )),\r\n                    mode: Some(WindowMode::Windowed),\r\n                });\r\n                // send second command to ensure fullscreen applies over the taskbar properly\r\n                let cmd = WindowPositionCommand {\r\n                    window: window_id,\r\n                    // position: Some(WindowPosition::At(monitor.work_area.top_left())),\r\n                    // resolution: Some(WindowResolution::new(\r\n                    //     monitor.work_area.width() as f32,\r\n                    //     monitor.work_area.height() as f32,\r\n                    // )),\r\n                    mode: Some(WindowMode::BorderlessFullscreen),\r\n                    position: None,\r\n                    resolution: None,\r\n                };\r\n                window_commands.send(cmd);\r\n\r\n                if let Err(e) = set_cursor_position(monitor.work_area.center()) {\r\n                    warn!(\"Failed to set cursor position: {}\", e);\r\n                }\r\n                commands.entity(tool_id).remove::<ActiveTool>();\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\input\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_input\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\ncursor_hero_host_event_types = { workspace = true}\r\ncursor_hero_pointer_types = { workspace = true}\r\nleafwing-input-manager = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\movement_tool\\src\\movement_tool_populate_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse cursor_hero_movement_tool_types::prelude::*;\r\nuse cursor_hero_toolbelt_types::prelude::*;\r\nuse cursor_hero_tools::tool_spawning::ToolSpawnConfig;\r\n\r\npub struct MovementToolPopulatePlugin;\r\n\r\nimpl Plugin for MovementToolPopulatePlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Update, handle_toolbelt_events);\r\n    }\r\n}\r\n\r\nfn handle_toolbelt_events(\r\n    mut commands: Commands,\r\n    asset_server: Res<AssetServer>,\r\n    mut reader: EventReader<ToolbeltPopulateEvent>,\r\n) {\r\n    for event in reader.read() {\r\n        match event.loadout {\r\n            ToolbeltLoadout::Default\r\n            | ToolbeltLoadout::Inspector\r\n            | ToolbeltLoadout::Taskbar\r\n            | ToolbeltLoadout::WindowPosition\r\n            | ToolbeltLoadout::Keyboard => {\r\n                ToolSpawnConfig::<_, MovementToolAction>::new(\r\n                    MovementTool::default(),\r\n                    event.id,\r\n                    event,\r\n                )\r\n                .with_src_path(file!().into())\r\n                .guess_name(file!())\r\n                .guess_image(file!(), &asset_server, \"png\")\r\n                .with_description(\"Go faster, reach further\")\r\n                .spawn(&mut commands);\r\n            }\r\n            ToolbeltLoadout::Agent => {\r\n                ToolSpawnConfig::<_, MovementToolAction>::new(\r\n                    MovementTool::default(),\r\n                    event.id,\r\n                    event,\r\n                )\r\n                .with_src_path(file!().into())\r\n                .with_input_map(None)\r\n                .guess_name(file!())\r\n                .guess_image(file!(), &asset_server, \"png\")\r\n                .with_description(\"Go faster, reach further\")\r\n                .spawn(&mut commands);\r\n            }\r\n            _ => {}\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\movement_tool_types\\src\\movement_tool_types.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse leafwing_input_manager::prelude::*;\r\nuse leafwing_input_manager::user_input::InputKind;\r\n\r\nuse bevy_inspector_egui::prelude::ReflectInspectorOptions;\r\nuse bevy_inspector_egui::InspectorOptions;\r\nuse cursor_hero_input::active_input_state_plugin::InputMethod;\r\nuse cursor_hero_toolbelt_types::prelude::*;\r\n\r\n#[derive(Component, Reflect, Debug, InspectorOptions)]\r\n#[reflect(Component, InspectorOptions)]\r\npub struct MovementTool {\r\n    #[inspector(min = 0.0)]\r\n    pub speed: f32,\r\n    #[inspector(min = 0.0)]\r\n    pub default_speed: f32,\r\n    #[inspector(min = 0.0)]\r\n    pub sprint_speed: f32,\r\n    pub target: MovementTarget,\r\n}\r\nimpl Default for MovementTool {\r\n    fn default() -> Self {\r\n        match InputMethod::default() {\r\n            InputMethod::MouseAndKeyboard | InputMethod::Keyboard => Self::default_mnk(),\r\n            InputMethod::Gamepad => Self::default_gamepad(),\r\n        }\r\n    }\r\n}\r\nimpl MovementTool {\r\n    pub fn default_mnk() -> MovementTool {\r\n        MovementTool {\r\n            speed: 8000.0,\r\n            default_speed: 8000.0,\r\n            sprint_speed: 40000.0,\r\n            target: MovementTarget::Character,\r\n        }\r\n    }\r\n    pub fn default_gamepad() -> MovementTool {\r\n        MovementTool {\r\n            speed: 800.0,\r\n            default_speed: 800.0,\r\n            sprint_speed: 80000.0,\r\n            target: MovementTarget::Character,\r\n        }\r\n    }\r\n}\r\n\r\n#[derive(Reflect, Debug, Clone, Copy)]\r\npub enum MovementTarget {\r\n    Character,\r\n    Camera(Entity),\r\n}\r\n\r\n#[derive(Event, Debug, Reflect)]\r\npub enum MovementTargetEvent {\r\n    SetTarget {\r\n        tool_id: Entity,\r\n        target: MovementTarget,\r\n    },\r\n}\r\n\r\n#[derive(Actionlike, PartialEq, Eq, Clone, Copy, Hash, Debug, Reflect)]\r\npub enum MovementToolAction {\r\n    Move,\r\n}\r\n\r\nimpl MovementToolAction {\r\n    fn default_gamepad_binding(&self) -> UserInput {\r\n        match self {\r\n            Self::Move => UserInput::Single(InputKind::DualAxis(DualAxis::left_stick())),\r\n        }\r\n    }\r\n\r\n    fn default_mkb_binding(&self) -> UserInput {\r\n        match self {\r\n            Self::Move => UserInput::VirtualDPad(VirtualDPad::wasd()),\r\n        }\r\n    }\r\n}\r\nimpl ToolAction for MovementToolAction {\r\n    fn default_input_map(_event: &ToolbeltPopulateEvent) -> Option<InputMap<MovementToolAction>> {\r\n        let mut input_map = InputMap::default();\r\n\r\n        for variant in MovementToolAction::variants() {\r\n            input_map.insert(variant.default_mkb_binding(), variant);\r\n            input_map.insert(variant.default_gamepad_binding(), variant);\r\n        }\r\n        Some(input_map)\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\pointer\\src\\pointer_positioning_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse bevy::transform::TransformSystem;\r\nuse bevy::window::PrimaryWindow;\r\nuse bevy_xpbd_2d::prelude::*;\r\nuse cursor_hero_bevy::prelude::NegativeYVec2;\r\nuse cursor_hero_camera::camera_plugin::MainCamera;\r\nuse cursor_hero_character_types::prelude::*;\r\nuse cursor_hero_environment_types::prelude::*;\r\nuse cursor_hero_input::active_input_state_plugin::InputMethod;\r\nuse cursor_hero_pointer_types::pointer_behaviour_types::PointerMovementBehaviour;\r\nuse cursor_hero_pointer_types::prelude::*;\r\nuse cursor_hero_winutils::win_mouse::set_cursor_position;\r\nuse cursor_hero_winutils::win_window::get_window_bounds;\r\nuse cursor_hero_winutils::win_window::get_window_inner_offset;\r\nuse leafwing_input_manager::prelude::*;\r\n\r\nuse bevy::window::RawHandleWrapper;\r\n\r\npub struct PointerPositioningPlugin;\r\nimpl Plugin for PointerPositioningPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(\r\n            PostUpdate,\r\n            (update_pointer)\r\n                .in_set(PointerSystemSet::Position)\r\n                .after(PhysicsSet::Sync)\r\n                .after(TransformSystem::TransformPropagate),\r\n        );\r\n    }\r\n}\r\n\r\n#[derive(Default, Debug)]\r\nstruct PointerUpdate {\r\n    local_target: Option<Vec2>,\r\n    global_target: Option<Vec2>,\r\n    host_target: Option<IVec2>,\r\n}\r\n\r\n#[derive(Debug)]\r\nstruct DecisionInfo {\r\n    current_behaviour: PointerMovementBehaviour,\r\n    is_main_character: bool,\r\n    in_host_environment: bool,\r\n    stick_in_use: bool,\r\n    active_input_method: InputMethod,\r\n}\r\n\r\n#[allow(clippy::type_complexity)]\r\n#[allow(clippy::too_many_arguments)]\r\nfn update_pointer(\r\n    mut pointer_query: Query<\r\n        (\r\n            &mut Transform,\r\n            &GlobalTransform,\r\n            &mut Position,\r\n            &ActionState<PointerAction>,\r\n            &mut Pointer,\r\n            Option<&EnvironmentTracker>,\r\n            &Parent,\r\n        ),\r\n        (Without<Character>, With<Pointer>),\r\n    >,\r\n    mut character_query: Query<\r\n        (Ref<GlobalTransform>, Option<&MainCharacter>),\r\n        (With<Character>, Without<Pointer>, Without<MainCamera>),\r\n    >,\r\n    camera_query: Query<\r\n        (&Camera, &GlobalTransform),\r\n        (With<MainCamera>, Without<Character>, Without<Pointer>),\r\n    >,\r\n    window_query: Query<(&Window, &RawHandleWrapper), With<PrimaryWindow>>,\r\n    input_method: Res<InputMethod>,\r\n    environment_query: Query<(), With<HostEnvironment>>,\r\n    mut last_known_cursor_position: Local<Option<Vec2>>,\r\n    mut previous_update: Local<PointerUpdate>,\r\n) {\r\n    for pointer in pointer_query.iter_mut() {\r\n        let (\r\n            mut pointer_transform,\r\n            pointer_global_transform,\r\n            mut pointer_position,\r\n            pointer_actions,\r\n            mut pointer,\r\n            pointer_environment,\r\n            pointer_parent,\r\n        ) = pointer;\r\n\r\n        let stick_in_use = pointer_actions.pressed(PointerAction::Move);\r\n        let in_host_environment = pointer_environment\r\n            .map(|e| environment_query.contains(e.environment_id))\r\n            .unwrap_or(false);\r\n\r\n        let Ok(character) = character_query.get_mut(pointer_parent.get()) else {\r\n            warn!(\"No character found\");\r\n            continue;\r\n        };\r\n        let (character_global_transform, is_main_character) = character;\r\n\r\n        let Ok(camera) = camera_query.get_single() else {\r\n            warn!(\"No camera found\");\r\n            return;\r\n        };\r\n        let (camera, camera_global_transform) = camera;\r\n\r\n        let Ok(window) = window_query.get_single() else {\r\n            warn!(\"No window found\");\r\n            return;\r\n        };\r\n        let (window, window_handle) = window;\r\n\r\n        let decision_info = DecisionInfo {\r\n            current_behaviour: pointer.movement_behaviour,\r\n            is_main_character: is_main_character.is_some(),\r\n            in_host_environment,\r\n            stick_in_use,\r\n            active_input_method: *input_method,\r\n        };\r\n\r\n        let next_behaviour = match decision_info {\r\n            DecisionInfo {\r\n                is_main_character: true,\r\n                in_host_environment: true,\r\n                stick_in_use: true,\r\n                ..\r\n            }\r\n            | DecisionInfo {\r\n                is_main_character: true,\r\n                in_host_environment: true,\r\n                active_input_method: InputMethod::Gamepad,\r\n                ..\r\n            }\r\n            | DecisionInfo {\r\n                is_main_character: true,\r\n                in_host_environment: true,\r\n                active_input_method: InputMethod::Keyboard,\r\n                ..\r\n            } => PointerMovementBehaviour::SetHostCursorFromPointerWorldCoords,\r\n            DecisionInfo {\r\n                is_main_character: true,\r\n                stick_in_use: false,\r\n                active_input_method: InputMethod::MouseAndKeyboard,\r\n                ..\r\n            } => PointerMovementBehaviour::SetPointerFromHostCursorWindowCoords,\r\n            DecisionInfo {\r\n                is_main_character: true,\r\n                in_host_environment: false,\r\n                stick_in_use: true,\r\n                ..\r\n            } => PointerMovementBehaviour::SetHostCursorFromWindowCoords,\r\n            DecisionInfo {\r\n                is_main_character: true,\r\n                in_host_environment: false,\r\n                stick_in_use: false,\r\n                ..\r\n            } => decision_info.current_behaviour,\r\n            DecisionInfo {\r\n                current_behaviour: PointerMovementBehaviour::None,\r\n                ..\r\n            } => PointerMovementBehaviour::None,\r\n            _ => {\r\n                warn!(\"Unhandled case: {:?}\", decision_info);\r\n                decision_info.current_behaviour\r\n            }\r\n        };\r\n\r\n        if next_behaviour != pointer.movement_behaviour {\r\n            info!(\r\n                \"Switching to {:?} given {:?}\",\r\n                next_behaviour, decision_info\r\n            );\r\n            pointer.movement_behaviour = next_behaviour;\r\n        }\r\n\r\n        let this_update = match pointer.movement_behaviour {\r\n            PointerMovementBehaviour::None => {\r\n                // sync physics to render\r\n                PointerUpdate {\r\n                    local_target: None,\r\n                    global_target: Some(pointer_global_transform.translation().xy()),\r\n                    host_target: None,\r\n                }\r\n            }\r\n            PointerMovementBehaviour::SetPointerFromHostCursorWindowCoords => {\r\n                // usual mode for mouse and keyboard input\r\n                match window.cursor_position().or(*last_known_cursor_position) {\r\n                    Some(host_cursor_xy) => {\r\n                        // Cache to avoid jitter\r\n                        *last_known_cursor_position = Some(host_cursor_xy);\r\n\r\n                        // Calculate target positions\r\n                        let Some(global_target) = camera\r\n                            .viewport_to_world(camera_global_transform, host_cursor_xy)\r\n                            .map(|ray| ray.origin.truncate())\r\n                        else {\r\n                            return;\r\n                        };\r\n                        let local_target =\r\n                            global_target - character_global_transform.translation().xy();\r\n                        PointerUpdate {\r\n                            local_target: Some(local_target),\r\n                            global_target: Some(global_target),\r\n                            host_target: None,\r\n                        }\r\n                    }\r\n                    None => {\r\n                        if pointer.log_behaviour == PointerLogBehaviour::ErrorsAndPositionUpdates {\r\n                            warn!(\"No cursor position found\");\r\n                        }\r\n                        PointerUpdate::default()\r\n                    }\r\n                }\r\n            }\r\n            PointerMovementBehaviour::SetHostCursorFromPointerWorldCoords => {\r\n                // host follows pointer, render and physics are the same\r\n                if stick_in_use {\r\n                    match pointer_actions.axis_pair(PointerAction::Move) {\r\n                        Some(axis_pair) => {\r\n                            let look = axis_pair.xy();\r\n                            if look.x.is_nan() || look.y.is_nan() {\r\n                                warn!(\"{} | look vector is unusable\", pointer.movement_behaviour);\r\n                                PointerUpdate::default()\r\n                            } else {\r\n                                let character_translation =\r\n                                    character_global_transform.translation();\r\n                                let local_target = look * pointer.reach;\r\n                                let global_target = character_translation.xy() + local_target;\r\n                                let host_target = global_target.neg_y().as_ivec2();\r\n                                PointerUpdate {\r\n                                    local_target: Some(local_target),\r\n                                    global_target: Some(global_target),\r\n                                    host_target: Some(host_target),\r\n                                }\r\n                            }\r\n                        }\r\n                        None => {\r\n                            warn!(\"{}, No axis pair found?\", pointer.movement_behaviour);\r\n                            PointerUpdate::default()\r\n                        }\r\n                    }\r\n                } else {\r\n                    // pointer stick not in use, reset pointer to the origin of the character\r\n                    let character_translation = character_global_transform.translation();\r\n                    let local_target = Vec2::ZERO;\r\n                    let global_target = character_translation.xy();\r\n                    let host_target = character_translation.xy().neg_y().as_ivec2();\r\n                    PointerUpdate {\r\n                        local_target: Some(local_target),\r\n                        global_target: Some(global_target),\r\n                        host_target: Some(host_target),\r\n                    }\r\n                }\r\n            }\r\n            PointerMovementBehaviour::SetHostCursorFromWindowCoords => {\r\n                if stick_in_use {\r\n                    // stick in use\r\n                    // the host cursor will go over the pointer's window position\r\n                    match pointer_actions.axis_pair(PointerAction::Move) {\r\n                        Some(axis_pair) => {\r\n                            let look = axis_pair.xy();\r\n\r\n                            // the look vector could be unusable\r\n                            if look.x.is_nan() || look.y.is_nan() {\r\n                                warn!(\"{} | look vector is unusable\", pointer.movement_behaviour);\r\n                                PointerUpdate::default()\r\n                            } else {\r\n                                // the spot you want to be is the character position + stick direction\r\n                                let character_translation =\r\n                                    character_global_transform.translation();\r\n                                let local_target = look * pointer.reach;\r\n                                let global_target =\r\n                                    character_translation + local_target.extend(0.0);\r\n\r\n                                // update the host cursor\r\n                                let window_bounds = match window_handle.window_handle {\r\n                                    raw_window_handle::RawWindowHandle::Win32(handle) => {\r\n                                        match get_window_bounds(handle.hwnd as _) {\r\n                                            Ok(bounds) => bounds,\r\n                                            Err(e) => {\r\n                                                error!(\"Failed to get window bounds: {:?}\", e);\r\n                                                return;\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                    _ => panic!(\"Unsupported window handle\"),\r\n                                };\r\n                                let host_target = camera\r\n                                    .world_to_viewport(camera_global_transform, global_target)\r\n                                    .map(|viewport| {\r\n                                        let mut host_target =\r\n                                            viewport.as_ivec2() + window_bounds.min;\r\n                                        // accomodate window decorations\r\n                                        let mut offset = get_window_inner_offset();\r\n                                        offset.x *= 2;\r\n                                        host_target += offset;\r\n                                        host_target\r\n                                    });\r\n\r\n                                PointerUpdate {\r\n                                    local_target: Some(local_target.xy()),\r\n                                    global_target: Some(global_target.xy()),\r\n                                    host_target,\r\n                                }\r\n                            }\r\n                        }\r\n                        None => {\r\n                            warn!(\"{} | No axis pair found?\", pointer.movement_behaviour);\r\n                            PointerUpdate::default()\r\n                        }\r\n                    }\r\n                } else {\r\n                    // stick not in use\r\n                    // reset pointer to the origin of the character\r\n                    let character_translation = character_global_transform.translation();\r\n                    let local_target = Vec2::ZERO;\r\n                    let global_target = character_translation.xy().neg_y();\r\n\r\n                    // update the host cursor\r\n                    let window_bounds = match window_handle.window_handle {\r\n                        raw_window_handle::RawWindowHandle::Win32(handle) => {\r\n                            match get_window_bounds(handle.hwnd as _) {\r\n                                Ok(bounds) => bounds,\r\n                                Err(e) => {\r\n                                    error!(\"Failed to get window bounds: {:?}\", e);\r\n                                    return;\r\n                                }\r\n                            }\r\n                        }\r\n                        _ => panic!(\"Unsupported window handle\"),\r\n                    };\r\n                    let host_target = camera\r\n                        .world_to_viewport(camera_global_transform, character_translation)\r\n                        .map(|viewport| {\r\n                            let mut host_target = viewport.as_ivec2() + window_bounds.min;\r\n                            // accomodate window decorations\r\n                            let mut offset = get_window_inner_offset();\r\n                            offset.x *= 2;\r\n                            // debug!(\"host_target={:?} offset={:?}\", host_target, offset);\r\n                            host_target += offset;\r\n                            host_target\r\n                        });\r\n\r\n                    PointerUpdate {\r\n                        local_target: Some(local_target),\r\n                        global_target: Some(global_target),\r\n                        host_target,\r\n                    }\r\n                }\r\n            }\r\n        };\r\n\r\n        // Update render body\r\n        let mut render_updated = false;\r\n        if this_update.local_target != previous_update.local_target\r\n            && let Some(local_target) = this_update.local_target\r\n        {\r\n            let target_distance = local_target - pointer_transform.translation.xy();\r\n            if target_distance != Vec2::ZERO {\r\n                // Not at destination, update render body (which physics will follow)\r\n                if pointer.log_behaviour == PointerLogBehaviour::ErrorsAndPositionUpdates {\r\n                    debug!(\r\n                        \"{} stick={:?} | target_distance={:?}, updating render body to local_target={:?}\",\r\n                        pointer.movement_behaviour, stick_in_use, target_distance, local_target\r\n                    );\r\n                }\r\n                pointer_transform.translation.x = local_target.x;\r\n                pointer_transform.translation.y = local_target.y;\r\n                render_updated = true;\r\n            }\r\n        }\r\n\r\n        // Update physics body\r\n        if !render_updated\r\n            && this_update.global_target != previous_update.global_target\r\n            && let Some(global_target) = this_update.global_target\r\n        {\r\n            let target_distance = global_target - pointer_position.xy();\r\n            if target_distance != Vec2::ZERO {\r\n                // Not at destination, update physics body\r\n                if pointer.log_behaviour == PointerLogBehaviour::ErrorsAndPositionUpdates {\r\n                    debug!(\r\n                        \"{} stick={:?} | target_distance={:?}, updating physics body to global_target={:?}\",\r\n                        pointer.movement_behaviour, stick_in_use, target_distance, global_target\r\n                    );\r\n                }\r\n                // prevent feedback loop\r\n                let pointer_position = pointer_position.bypass_change_detection();\r\n\r\n                // update physics body\r\n                pointer_position.x = global_target.x;\r\n                pointer_position.y = global_target.y;\r\n            }\r\n        }\r\n\r\n        if this_update.host_target != previous_update.host_target\r\n            && let Some(host_target) = this_update.host_target\r\n        {\r\n            match set_cursor_position(host_target) {\r\n                Ok(_) => {\r\n                    if pointer.log_behaviour == PointerLogBehaviour::ErrorsAndPositionUpdates {\r\n                        debug!(\r\n                            \"{} | set host cursor to {:?}\",\r\n                            pointer.movement_behaviour, host_target\r\n                        );\r\n                    }\r\n                }\r\n                Err(e) => {\r\n                    warn!(\r\n                        \"{} | host cursor update failed, tried setting to {:?}, error={:?}\",\r\n                        pointer.movement_behaviour, host_target, e\r\n                    );\r\n                }\r\n            }\r\n        }\r\n\r\n        *previous_update = this_update;\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\brick\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_brick\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\ncursor_hero_brick_types = { workspace = true }\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\inference\\src\\lib.rs\r\n\r\n````rust\r\npub mod inference_plugin;\r\npub mod prompt_asset_plugin;\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\pointer\\src\\pointer_reach_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse cursor_hero_character_types::prelude::*;\r\nuse cursor_hero_math::prelude::Lerp;\r\nuse cursor_hero_pointer_types::prelude::*;\r\n\r\nuse cursor_hero_sprint_tool_types::sprint_tool_types_plugin::SprintEvent;\r\nuse cursor_hero_toolbelt_types::toolbelt_types::Wheel;\r\n\r\npub struct PointerReachPlugin;\r\n\r\nimpl Plugin for PointerReachPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Update, handle_reach_events);\r\n        app.add_systems(Update, handle_sprint_events);\r\n    }\r\n}\r\n\r\nfn handle_reach_events(\r\n    mut reach_events: EventReader<PointerReachEvent>,\r\n    character_query: Query<&Children, With<Character>>,\r\n    mut pointer_query: Query<&mut Pointer>,\r\n) {\r\n    for event in reach_events.read() {\r\n        match event {\r\n            PointerReachEvent::SetPointer { pointer_id, reach } => {\r\n                let Ok(mut pointer) = pointer_query.get_mut(*pointer_id) else {\r\n                    warn!(\"Pointer not found processing {:?}\", event);\r\n                    continue;\r\n                };\r\n                pointer.reach = *reach;\r\n            }\r\n            PointerReachEvent::SetPointerPercent {\r\n                pointer_id,\r\n                percent,\r\n            } => {\r\n                let Ok(mut pointer) = pointer_query.get_mut(*pointer_id) else {\r\n                    warn!(\"Pointer not found processing {:?}\", event);\r\n                    continue;\r\n                };\r\n                pointer.reach = (pointer.default_reach, pointer.sprint_reach).lerp(*percent);\r\n            }\r\n\r\n            PointerReachEvent::SetCharacter {\r\n                character_id,\r\n                reach,\r\n            } => {\r\n                let Ok(character) = character_query.get(*character_id) else {\r\n                    warn!(\"Character not found processing {:?}\", event);\r\n                    continue;\r\n                };\r\n                let mut found = false;\r\n                for kid in character.iter() {\r\n                    let Ok(mut pointer) = pointer_query.get_mut(*kid) else {\r\n                        continue;\r\n                    };\r\n                    pointer.reach = *reach;\r\n                    found = true;\r\n                }\r\n                if !found {\r\n                    warn!(\"Pointer not found processing {:?}\", event);\r\n                }\r\n            }\r\n            PointerReachEvent::SetCharacterPercent {\r\n                character_id,\r\n                percent,\r\n            } => {\r\n                let Ok(character) = character_query.get(*character_id) else {\r\n                    warn!(\"Character not found processing {:?}\", event);\r\n                    continue;\r\n                };\r\n                let mut found = false;\r\n                for kid in character.iter() {\r\n                    let Ok(mut pointer) = pointer_query.get_mut(*kid) else {\r\n                        continue;\r\n                    };\r\n                    pointer.reach = (pointer.default_reach, pointer.sprint_reach).lerp(*percent);\r\n                    found = true;\r\n                }\r\n                if !found {\r\n                    warn!(\"Pointer not found processing {:?}\", event);\r\n                }\r\n            }\r\n\r\n            PointerReachEvent::ResetPointer { pointer_id } => {\r\n                let Ok(mut pointer) = pointer_query.get_mut(*pointer_id) else {\r\n                    warn!(\"Pointer not found processing {:?}\", event);\r\n                    continue;\r\n                };\r\n                pointer.reach = pointer.default_reach;\r\n            }\r\n            PointerReachEvent::ResetCharacter { character_id } => {\r\n                let Ok(character) = character_query.get(*character_id) else {\r\n                    warn!(\"Character not found processing {:?}\", event);\r\n                    continue;\r\n                };\r\n                let mut found = false;\r\n                for kid in character.iter() {\r\n                    let Ok(mut pointer) = pointer_query.get_mut(*kid) else {\r\n                        continue;\r\n                    };\r\n                    pointer.reach = pointer.default_reach;\r\n                    found = true;\r\n                }\r\n                if !found {\r\n                    warn!(\"Pointer not found processing {:?}\", event);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfn handle_sprint_events(\r\n    mut reach_events: EventWriter<PointerReachEvent>,\r\n    mut sprint_events: EventReader<SprintEvent>,\r\n    character_query: Query<&Children, With<Character>>,\r\n    toolbelt_query: Query<&Wheel, With<Character>>,\r\n) {\r\n    for event in sprint_events.read() {\r\n        let character_id = match event {\r\n            SprintEvent::Active { character_id, .. } => character_id,\r\n            SprintEvent::Stop { character_id } => character_id,\r\n        };\r\n        let Ok(character) = character_query.get(*character_id) else {\r\n            warn!(\"Character not found processing {:?}\", event);\r\n            continue;\r\n        };\r\n        let toolbelt_open = character.iter().any(|kid| {\r\n            let Ok(toolbelt) = toolbelt_query.get(*kid) else {\r\n                return false;\r\n            };\r\n            toolbelt.open\r\n        });\r\n        if toolbelt_open {\r\n            // Toolbelt reach updates take priority over sprint reach updates\r\n            continue;\r\n        }\r\n        match event {\r\n            SprintEvent::Active {\r\n                character_id,\r\n                throttle,\r\n            } => {\r\n                reach_events.send(PointerReachEvent::SetCharacterPercent {\r\n                    character_id: *character_id,\r\n                    percent: *throttle,\r\n                });\r\n            }\r\n            SprintEvent::Stop { character_id } => {\r\n                reach_events.send(PointerReachEvent::ResetCharacter {\r\n                    character_id: *character_id,\r\n                });\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\chat\\src\\chat_tool_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse cursor_hero_character_types::prelude::*;\r\nuse cursor_hero_chat_types::prelude::*;\r\nuse cursor_hero_toolbelt_types::prelude::*;\r\nuse cursor_hero_tools::prelude::*;\r\nuse cursor_hero_voice_to_text_types::voice_to_text_types::VoiceToTextTranscriptionEvent;\r\nuse leafwing_input_manager::prelude::*;\r\n\r\npub struct ChatToolPlugin;\r\n\r\nimpl Plugin for ChatToolPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_plugins(InputManagerPlugin::<ChatToolAction>::default());\r\n        app.add_systems(Update, toolbelt_events);\r\n        app.add_systems(Update, handle_input);\r\n        app.add_systems(Update, handle_voice_events);\r\n    }\r\n}\r\n\r\nfn toolbelt_events(\r\n    mut commands: Commands,\r\n    asset_server: Res<AssetServer>,\r\n    mut reader: EventReader<ToolbeltPopulateEvent>,\r\n) {\r\n    for event in reader.read() {\r\n        let (ToolbeltLoadout::Chat | ToolbeltLoadout::Default) = event.loadout else {\r\n            continue;\r\n        };\r\n        {\r\n            ToolSpawnConfig::<ChatTool, ChatToolAction>::new(ChatTool::default(), event.id, event)\r\n                .with_src_path(file!().into())\r\n                .guess_name(file!())\r\n                .guess_image(file!(), &asset_server, \"webp\")\r\n                .with_description(\"Send chat messages into the world\")\r\n                .spawn(&mut commands);\r\n        }\r\n    }\r\n}\r\n\r\nfn handle_input(\r\n    mut tool_query: Query<\r\n        (Entity, &ActionState<ChatToolAction>, &Parent, &mut ChatTool),\r\n        With<ActiveTool>,\r\n    >,\r\n    toolbelt_query: Query<&Parent, With<Toolbelt>>,\r\n    mut character_query: Query<Entity, With<Character>>,\r\n    mut chat_events: EventWriter<ChatEvent>,\r\n    mut chat_input_events: EventWriter<ChatInputEvent>,\r\n) {\r\n    for tool in tool_query.iter_mut() {\r\n        let (tool_id, tool_actions, tool_parent, mut tool) = tool;\r\n\r\n        let Ok(toolbelt) = toolbelt_query.get(tool_parent.get()) else {\r\n            warn!(\"Tool not inside a toolbelt?\");\r\n            continue;\r\n        };\r\n        let toolbelt_parent = toolbelt;\r\n        let Ok(character) = character_query.get_mut(toolbelt_parent.get()) else {\r\n            warn!(\"Toolbelt parent not a character?\");\r\n            continue;\r\n        };\r\n        let character_id = character;\r\n\r\n        if tool_actions.just_pressed(ChatToolAction::Focus) && !tool.focused {\r\n            let event = ChatInputEvent::Focus {\r\n                tool_id,\r\n                toolbelt_id: tool_parent.get(),\r\n                character_id,\r\n            };\r\n            info!(\"Sending focus event {:?}\", event);\r\n            chat_input_events.send(event);\r\n        } else if tool_actions.just_pressed(ChatToolAction::Unfocus) && tool.focused {\r\n            let event = ChatInputEvent::Unfocus {\r\n                tool_id,\r\n                toolbelt_id: tool_parent.get(),\r\n                character_id,\r\n            };\r\n            info!(\"Sending unfocus event {:?}\", event);\r\n            chat_input_events.send(event);\r\n        } else if tool_actions.just_pressed(ChatToolAction::Submit) && tool.focused {\r\n            let message = tool.buffer.clone();\r\n            if !message.is_empty() {\r\n                tool.buffer.clear();\r\n\r\n                let event = ChatEvent::Chat {\r\n                    character_id,\r\n                    message,\r\n                };\r\n                info!(\"Sending chat event {:?}\", event);\r\n                chat_events.send(event);\r\n            }\r\n            let event = ChatInputEvent::Unfocus {\r\n                tool_id,\r\n                toolbelt_id: tool_parent.get(),\r\n                character_id,\r\n            };\r\n            info!(\"Sending unfocus event {:?}\", event);\r\n            chat_input_events.send(event);\r\n        }\r\n    }\r\n}\r\n\r\nfn handle_voice_events(\r\n    mut voice_events: EventReader<VoiceToTextTranscriptionEvent>,\r\n    mut chat_events: EventWriter<ChatEvent>,\r\n    character_query: Query<Entity, With<MainCharacter>>,\r\n) {\r\n    let character_id = match character_query.get_single() {\r\n        Ok(character_id) => character_id,\r\n        Err(e) => {\r\n            warn!(\"Failed to get main character: {:?}\", e);\r\n            return;\r\n        }\r\n    };\r\n\r\n    for event in voice_events.read() {\r\n        let VoiceToTextTranscriptionEvent::Received { transcription } = event;\r\n        if transcription.is_empty() {\r\n            continue;\r\n        }\r\n        let event = ChatEvent::Chat {\r\n            character_id,\r\n            message: transcription.clone(),\r\n        };\r\n        info!(\"Sending chat event {:?}\", event);\r\n        chat_events.send(event);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ollama\\src\\ollama_status_plugin.rs\r\n\r\n````rust\r\nuse std::time::Duration;\r\n\r\nuse bevy::prelude::*;\r\nuse bevy::utils::Instant;\r\nuse cursor_hero_ollama_types::prelude::*;\r\n\r\npub struct OllamaStatusPlugin;\r\n\r\nimpl Plugin for OllamaStatusPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.init_resource::<OllamaStatus>();\r\n        app.add_systems(Update, handle_startup_event);\r\n        app.add_systems(Update, periodic_ping);\r\n        app.add_systems(Update, handle_pong);\r\n    }\r\n}\r\n\r\nfn handle_startup_event(\r\n    mut status_events: ParamSet<(\r\n        EventReader<OllamaStatusEvent>,\r\n        EventWriter<OllamaStatusEvent>,\r\n    )>,\r\n    mut ollama_status: ResMut<OllamaStatus>,\r\n) {\r\n    let starting = status_events\r\n        .p0()\r\n        .read()\r\n        .any(|event| matches!(event, OllamaStatusEvent::Startup));\r\n    if !starting {\r\n        return;\r\n    }\r\n    status_events.p0().clear();\r\n\r\n    *ollama_status = OllamaStatus::Starting {\r\n        instant: Instant::now(),\r\n        timeout: Duration::from_secs(60),\r\n    };\r\n    let event = OllamaStatusEvent::Changed {\r\n        new_value: *ollama_status,\r\n    };\r\n    debug!(\"Sending event {:?}\", event);\r\n    status_events.p1().send(event);\r\n}\r\n\r\nfn periodic_ping(\r\n    mut ping_events: EventWriter<OllamaPingEvent>,\r\n    mut last_ping: Local<Option<Instant>>,\r\n) {\r\n    if let Some(instant) = *last_ping {\r\n        if instant.elapsed().as_secs() > 5 {\r\n            ping_events.send(OllamaPingEvent::Ping);\r\n            *last_ping = Some(Instant::now());\r\n        }\r\n    } else {\r\n        ping_events.send(OllamaPingEvent::Ping);\r\n        *last_ping = Some(Instant::now());\r\n    }\r\n}\r\n\r\nfn handle_pong(\r\n    mut ping_events: EventReader<OllamaPingEvent>,\r\n    mut status_events: EventWriter<OllamaStatusEvent>,\r\n    mut ollama_status: ResMut<OllamaStatus>,\r\n) {\r\n    for event in ping_events.read() {\r\n        let OllamaPingEvent::Pong { status } = event else {\r\n            continue;\r\n        };\r\n        // identify the new state based on the pong\r\n        let new_status = match (*ollama_status, *status) {\r\n            // if starting, only change to dead if the timeout has been exceeded\r\n            (OllamaStatus::Starting { instant, timeout }, status) => {\r\n                if status == OllamaStatus::Alive {\r\n                    OllamaStatus::Alive\r\n                } else if instant.elapsed() > timeout {\r\n                    OllamaStatus::Dead\r\n                } else {\r\n                    OllamaStatus::Starting { instant, timeout }\r\n                }\r\n            }\r\n            // respect the new status if it's not starting\r\n            _ => *status,\r\n        };\r\n\r\n        if *ollama_status != new_status {\r\n            *ollama_status = new_status;\r\n            let event = OllamaStatusEvent::Changed {\r\n                new_value: new_status,\r\n            };\r\n            debug!(\"Sending event {:?}\", event);\r\n            status_events.send(event);\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\tools\\src\\level_bounds_visibility_tool.rs\r\n\r\n````rust\r\nuse crate::prelude::*;\r\nuse bevy::prelude::*;\r\nuse cursor_hero_level_bounds::level_bounds_plugin::LevelBounds;\r\nuse cursor_hero_toolbelt_types::prelude::*;\r\n\r\npub struct LevelBoundsVisibilityToolPlugin;\r\n\r\nimpl Plugin for LevelBoundsVisibilityToolPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<LevelBoundsVisibilityTool>();\r\n        app.add_systems(Update, toolbelt_events);\r\n        app.add_systems(Update, tick);\r\n    }\r\n}\r\n\r\n#[derive(Component, Reflect, Default)]\r\nstruct LevelBoundsVisibilityTool;\r\n\r\nfn toolbelt_events(\r\n    mut commands: Commands,\r\n    asset_server: Res<AssetServer>,\r\n    mut reader: EventReader<ToolbeltPopulateEvent>,\r\n) {\r\n    for event in reader.read() {\r\n        let ToolbeltLoadout::Inspector = event.loadout else {\r\n            continue;\r\n        };\r\n        ToolSpawnConfig::<LevelBoundsVisibilityTool, NoInputs>::new(\r\n            LevelBoundsVisibilityTool,\r\n            event.id,\r\n            event,\r\n        )\r\n        .with_src_path(file!().into())\r\n        .guess_name(file!())\r\n        .guess_image(file!(), &asset_server, \"png\")\r\n        .with_description(\"Shows the play area.\")\r\n        .with_starting_state(StartingState::Inactive)\r\n        .spawn(&mut commands);\r\n    }\r\n}\r\n\r\nfn tick(\r\n    mut commands: Commands,\r\n    tool_query: Query<Entity, (Added<ActiveTool>, With<LevelBoundsVisibilityTool>)>,\r\n    mut level_bounds_query: Query<&mut Visibility, With<LevelBounds>>,\r\n) {\r\n    for tool_id in tool_query.iter() {\r\n        commands.entity(tool_id).remove::<ActiveTool>();\r\n        for mut visibility in level_bounds_query.iter_mut() {\r\n            *visibility = match *visibility {\r\n                Visibility::Visible => Visibility::Hidden,\r\n                Visibility::Hidden => Visibility::Visible,\r\n                Visibility::Inherited => Visibility::Visible,\r\n            };\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\voice_to_text\\src\\lib.rs\r\n\r\n````rust\r\n#![feature(let_chains)]\r\npub mod voice_to_text;\r\npub mod voice_to_text_button_plugin;\r\npub mod voice_to_text_ping_plugin;\r\npub mod voice_to_text_plugin;\r\npub mod voice_to_text_worker_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::voice_to_text_plugin::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\physics\\src\\physics_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n\r\nuse bevy_xpbd_2d::math::Vector;\r\nuse bevy_xpbd_2d::plugins::setup::Physics;\r\nuse bevy_xpbd_2d::plugins::sync::SyncConfig;\r\nuse bevy_xpbd_2d::plugins::PhysicsPlugins;\r\nuse bevy_xpbd_2d::resources::Gravity;\r\n\r\npub struct PhysicsPlugin;\r\n\r\nimpl Plugin for PhysicsPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_plugins(PhysicsPlugins::default())\r\n            .insert_resource(Gravity(Vector::ZERO))\r\n            .insert_resource(Time::new_with(Physics::fixed_hz(144.0)))\r\n            .insert_resource(SyncConfig {\r\n                position_to_transform: true,\r\n                transform_to_position: true,\r\n            });\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\secret_types\\src\\secrets_types.rs\r\n\r\n````rust\r\nuse std::fmt::Debug;\r\nuse zeroize::Zeroize;\r\n\r\nuse serde::Deserialize;\r\nuse serde::Serialize;\r\n\r\n// shout out to the secrecy crate\r\n// ran into some issues with reflect so had to roll my own tho\r\n// https://github.com/iqlusioninc/crates/issues/632\r\n\r\nuse bevy::prelude::*;\r\n\r\n#[derive(Reflect, Clone, Default, Eq, PartialEq, Serialize, Deserialize)]\r\npub struct SecretString {\r\n    inner: String,\r\n}\r\n\r\nimpl SecretString {\r\n    pub fn new(secret: String) -> Self {\r\n        SecretString { inner: secret }\r\n    }\r\n    pub fn expose_secret(&self) -> &String {\r\n        &self.inner\r\n    }\r\n}\r\n\r\nimpl Debug for SecretString {\r\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\r\n        write!(\r\n            f,\r\n            \"{}\",\r\n            match self.inner.len() {\r\n                0 => \"<empty>\",\r\n                _ => \"<redacted>\",\r\n            }\r\n        )\r\n    }\r\n}\r\nimpl Drop for SecretString {\r\n    fn drop(&mut self) {\r\n        self.inner.zeroize();\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui_automation\\src\\gather_element_info.rs\r\n\r\n````rust\r\nuse bevy::math::IRect;\r\nuse cursor_hero_ui_automation_types::prelude::DrillId;\r\nuse cursor_hero_ui_automation_types::prelude::ElementInfo;\r\nuse cursor_hero_ui_automation_types::prelude::RuntimeId;\r\nuse itertools::Itertools;\r\nuse std::collections::VecDeque;\r\nuse uiautomation::Error;\r\nuse uiautomation::UIAutomation;\r\nuse uiautomation::UIElement;\r\nuse uiautomation::UITreeWalker;\r\n\r\nuse crate::gather_children::GatherChildrenable;\r\nuse crate::gather_children::StopBehaviour;\r\n\r\npub struct GatherUITreeOkResult {\r\n    pub ui_tree: ElementInfo,\r\n    pub start_info: ElementInfo,\r\n}\r\npub fn gather_incomplete_ui_tree_starting_deep(\r\n    start_element: UIElement,\r\n) -> Result<GatherUITreeOkResult, Error> {\r\n    let automation = UIAutomation::new()?;\r\n    let walker = automation.create_tree_walker()?;\r\n    let ancestors = collect_ancestors(&start_element, &walker)?;\r\n    // println!(\"ancestors: {:?}\", ancestors);\r\n\r\n    let root_element = ancestors\r\n        .front()\r\n        .ok_or(Error::new(-1, \"No root element found\"))?\r\n        .clone();\r\n    let mut root_info = gather_tree(&root_element, &walker, &ancestors, 0)?;\r\n    root_info.drill_id = DrillId::Root;\r\n\r\n    update_drill_ids(root_info.children.as_mut(), &DrillId::Root);\r\n\r\n    let start_info = root_info\r\n        .get_descendents()\r\n        .into_iter()\r\n        .find(|info| match start_element.get_runtime_id() {\r\n            Ok(id) => info.runtime_id.0 == id,\r\n            Err(_) => false,\r\n        })\r\n        .cloned();\r\n    let Some(start_info) = start_info else {\r\n        return Err(Error::new(\r\n            -1,\r\n            format!(\r\n                \"Start element {:?} (id: {:?}) not found in tree: {:?}\",\r\n                start_element,\r\n                start_element.get_runtime_id(),\r\n                root_info\r\n            )\r\n            .as_str(),\r\n        ));\r\n    };\r\n    // let start_info = start_info.unwrap_or_else(|| root_info.clone());\r\n\r\n    Ok(GatherUITreeOkResult {\r\n        ui_tree: root_info,\r\n        start_info,\r\n    })\r\n}\r\n\r\nfn collect_ancestors(\r\n    element: &UIElement,\r\n    walker: &UITreeWalker,\r\n) -> Result<VecDeque<UIElement>, Error> {\r\n    let mut ancestors = VecDeque::new();\r\n    let mut current_element = Some(element.clone());\r\n    while let Some(elem) = current_element {\r\n        ancestors.push_front(elem.clone());\r\n        current_element = walker.get_parent(&elem).ok();\r\n    }\r\n    Ok(ancestors)\r\n}\r\n\r\nfn gather_tree(\r\n    element: &UIElement,\r\n    walker: &UITreeWalker,\r\n    ancestors: &VecDeque<UIElement>,\r\n    depth: usize,\r\n) -> Result<ElementInfo, Error> {\r\n    let is_ancestor = |element: &UIElement| {\r\n        ancestors\r\n            .iter()\r\n            .any(|ancestor| ancestor.get_runtime_id() == element.get_runtime_id())\r\n    };\r\n    let on_ancestor = is_ancestor(element);\r\n    let mut element_info = gather_single_element_info(element)?;\r\n\r\n    if on_ancestor {\r\n        let children = element\r\n            .gather_children(\r\n                walker,\r\n                if depth == 0 {\r\n                    &StopBehaviour::RootEndEncountered\r\n                } else {\r\n                    &StopBehaviour::EndOfSiblings\r\n                },\r\n            )\r\n            .into_iter()\r\n            .enumerate()\r\n            .filter_map(|(i, child)| {\r\n                if is_ancestor(&child) {\r\n                    gather_tree(&child, walker, ancestors, depth + 1).ok()\r\n                } else {\r\n                    gather_single_element_info(&child).ok()\r\n                }\r\n                .map(|mut child_info| {\r\n                    child_info.drill_id = DrillId::Child(vec![i].into_iter().collect());\r\n                    child_info\r\n                })\r\n            })\r\n            .collect_vec();\r\n\r\n        element_info.children = Some(children);\r\n    }\r\n\r\n    Ok(element_info)\r\n}\r\n\r\npub fn update_drill_ids(children: Option<&mut Vec<ElementInfo>>, ancestor_path: &DrillId) {\r\n    if let Some(children) = children {\r\n        for child_info in children.iter_mut() {\r\n            // Check if the child has a base drill_id set\r\n            if let DrillId::Child(base_drill_id) = &child_info.drill_id {\r\n                let mut new_path = ancestor_path.clone();\r\n                if let Some(&child_position) = base_drill_id.back() {\r\n                    new_path = match new_path {\r\n                        DrillId::Root | DrillId::Unknown => {\r\n                            DrillId::Child(vec![child_position].into())\r\n                        }\r\n                        DrillId::Child(ref mut path) => {\r\n                            let mut new_path = path.clone();\r\n                            new_path.push_back(child_position);\r\n                            DrillId::Child(new_path)\r\n                        }\r\n                    };\r\n\r\n                    // Update the child's drill_id by concatenating the ancestor_path with its own position\r\n                    child_info.drill_id = new_path.clone();\r\n                }\r\n\r\n                // Recursively update this child's children\r\n                update_drill_ids(child_info.children.as_mut(), &new_path);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\npub fn gather_single_element_info(element: &UIElement) -> Result<ElementInfo, uiautomation::Error> {\r\n    let name = element.get_name()?;\r\n    let bb = element.get_bounding_rectangle()?;\r\n    let class_name = element.get_classname()?;\r\n    let control_type = element.get_control_type()?.into();\r\n    let localized_control_type = element.get_localized_control_type()?;\r\n    let automation_id = element.get_automation_id()?;\r\n    let runtime_id = RuntimeId(element.get_runtime_id()?);\r\n\r\n    let info = ElementInfo {\r\n        name,\r\n        bounding_rect: IRect::new(bb.get_left(), bb.get_top(), bb.get_right(), bb.get_bottom()),\r\n        control_type,\r\n        localized_control_type,\r\n        class_name,\r\n        automation_id,\r\n        runtime_id,\r\n        children: None,\r\n        drill_id: DrillId::Unknown,\r\n    };\r\n    Ok(info)\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n    use uiautomation::UIAutomation;\r\n\r\n    /// Discord doesn't play nice with new UIAutomaion\r\n    ///\r\n    /// Element children aren't shown like they are in the MSAA tree\r\n    #[test]\r\n    fn test_gather_discord_element_info() {\r\n        let automation = UIAutomation::new().unwrap();\r\n        let walker = automation.create_tree_walker().unwrap();\r\n        let start = automation\r\n            .element_from_point(uiautomation::types::Point::new(2359, 959))\r\n            .unwrap();\r\n        println!(\"start {:#?}\", start);\r\n        let info = gather_single_element_info(&start).unwrap();\r\n        println!(\"info {:#?}\", info);\r\n\r\n        // let parent = walker.get_parent(&start).unwrap();\r\n        // let parent_info = gather_single_element_info(&parent).unwrap();\r\n        // println!(\"parent_info {:#?}\", parent_info);\r\n\r\n        let ancestors = collect_ancestors(&start, &walker).unwrap();\r\n        println!(\"got {} ancestors\", ancestors.len());\r\n        // println!(\"ancestors {:#?}\", ancestors);\r\n        for ancestor in ancestors.iter().skip(1) {\r\n            print!(\r\n                \"ancestor {:?} (runtimeid={:?})\\t\",\r\n                ancestor,\r\n                ancestor.get_runtime_id()\r\n            );\r\n            for behaviour in vec![\r\n                StopBehaviour::EndOfSiblings,\r\n                // StopBehaviour::LastChildEncountered,\r\n                // StopBehaviour::TaskbarEndEncountered,\r\n                // StopBehaviour::RootEndEncountered,\r\n            ] {\r\n                let children = ancestor\r\n                    .gather_children(&walker, &behaviour)\r\n                    .into_iter()\r\n                    .map(|child| gather_single_element_info(&child).unwrap())\r\n                    .collect::<Vec<_>>();\r\n                if children.is_empty() {\r\n                    eprintln!(\"No children found using {:?}\", behaviour);\r\n                }\r\n                println!(\"children using {:?} {:#?}\", behaviour, children.len());\r\n            }\r\n        }\r\n\r\n        let gathered = gather_incomplete_ui_tree_starting_deep(start).unwrap();\r\n        // println!(\"tree {:#?}\", gathered.ui_tree);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui_automation_types\\src\\vscode_ui_types.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse itertools::Itertools;\r\nuse serde::Deserialize;\r\nuse serde::Serialize;\r\nuse std::fmt;\r\nuse std::fmt::Display;\r\nuse std::fmt::Formatter;\r\n\r\nuse crate::prelude::ElementInfo;\r\n\r\n#[derive(Debug)]\r\npub enum VSCodeResolveError {\r\n    UI(uiautomation::Error),\r\n    UnknownSideTabKind(String),\r\n    UnknownState { kids: Vec<ElementInfo> },\r\n}\r\nimpl std::error::Error for VSCodeResolveError {}\r\nimpl std::fmt::Display for VSCodeResolveError {\r\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\r\n        match self {\r\n            VSCodeResolveError::UI(e) => write!(f, \"UIAutomation error: {}\", e),\r\n            VSCodeResolveError::UnknownSideTabKind(s) => {\r\n                write!(f, \"Unknown side tab kind: {}\", s)\r\n            }\r\n            VSCodeResolveError::UnknownState { kids } => {\r\n                write!(f, \"Unknown state with {} children: {:?}\", kids.len(), kids)\r\n            }\r\n        }\r\n    }\r\n}\r\nimpl From<uiautomation::Error> for VSCodeResolveError {\r\n    fn from(e: uiautomation::Error) -> Self {\r\n        VSCodeResolveError::UI(e)\r\n    }\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]\r\npub enum View {\r\n    Explorer {\r\n        sticky: Vec<ExplorerItem>,\r\n        items: Vec<ExplorerItem>,\r\n    },\r\n    Unknown {},\r\n}\r\nimpl Display for View {\r\n    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {\r\n        match self {\r\n            View::Explorer { sticky, items } => {\r\n                writeln!(f, \"Explorer entries:\")?;\r\n                writeln!(f, \"=== BEGIN STICKY ===\")?;\r\n                for item in sticky.iter().sorted_by_key(|x| x.bounds.min.y) {\r\n                    writeln!(\r\n                        f,\r\n                        \"{}- {} ({})\",\r\n                        \" \".repeat(item.ui_level as usize),\r\n                        item.label.clone()\r\n                            + if matches!(item.kind, ExplorerItemKind::Directory { .. }) {\r\n                                \"/\"\r\n                            } else {\r\n                                \"\"\r\n                            },\r\n                        item.path\r\n                    )?;\r\n                }\r\n                writeln!(f, \"=== END STICKY ===\")?;\r\n                for item in items.iter().sorted_by_key(|x| x.bounds.min.y) {\r\n                    writeln!(\r\n                        f,\r\n                        \"{}- {} ({})\",\r\n                        \" \".repeat(item.ui_level as usize),\r\n                        item.label.clone()\r\n                            + if matches!(item.kind, ExplorerItemKind::Directory { .. }) {\r\n                                \"/\"\r\n                            } else {\r\n                                \"\"\r\n                            },\r\n                        item.path\r\n                    )?;\r\n                }\r\n                fmt::Result::Ok(())\r\n            }\r\n            View::Unknown {} => {\r\n                writeln!(f, \"Unknown view\")?;\r\n                fmt::Result::Ok(())\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]\r\npub struct VSCodeWindowHeader {}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]\r\npub struct VSCodeWindowBody {\r\n    pub editor_area: EditorArea,\r\n    pub right_tab: SideTab,\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]\r\npub struct VSCodeWindowFooter {\r\n    pub cursor_position: IVec2,\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]\r\npub struct VSCodeWindow {\r\n    pub focused: bool,\r\n    pub header: VSCodeWindowHeader,\r\n    pub body: VSCodeWindowBody,\r\n    pub footer: VSCodeWindowFooter,\r\n}\r\n\r\nimpl Display for VSCodeWindow {\r\n    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {\r\n        writeln!(\r\n            f,\r\n            \"Visual Studio Code{}\",\r\n            if self.focused { \" (focused)\" } else { \"\" }\r\n        )?;\r\n\r\n        // writeln!(f, \"Side tabs:\")?;\r\n        // for tab in self.body.side_nav.iter() {\r\n        //     match tab {\r\n        //         SideTab::Open { kind, view } => {\r\n        //             writeln!(f, \"- (open) {:?} {{{{\\n{}}}}}\", kind, view)?;\r\n        //         }\r\n        //         SideTab::Closed { kind } => {\r\n        //             writeln!(f, \"- {:?}\", kind)?;\r\n        //         }\r\n        //     }\r\n        // }\r\n\r\n        writeln!(f, \"Editor groups:\")?;\r\n        for (i, group) in self.body.editor_area.groups.iter().enumerate() {\r\n            writeln!(f, \"Group {} tabs:\", i + 1)?;\r\n            for tab in group.tabs.iter() {\r\n                if tab.active {\r\n                    writeln!(f, \"- (active) {}\", tab.title)?;\r\n                } else {\r\n                    writeln!(f, \"- {}\", tab.title)?;\r\n                }\r\n            }\r\n            if let Some(ref content) = group.content {\r\n                writeln!(\r\n                    f,\r\n                    \"Group {} buffer:\\n=======\\n{}\\n=======\",\r\n                    i + 1,\r\n                    content.content\r\n                )?;\r\n            }\r\n        }\r\n\r\n        writeln!(f, \"Cursor position: {:?}\", self.footer.cursor_position)?;\r\n\r\n        fmt::Result::Ok(())\r\n    }\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]\r\npub enum SideTab {\r\n    Closed { kind: SideTabKind },\r\n    Open { kind: SideTabKind, view: View },\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]\r\npub enum ExplorerItemKind {\r\n    File,\r\n    Directory { expanded: bool },\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]\r\npub struct ExplorerItem {\r\n    pub label: String,\r\n    pub path: String,\r\n    pub ui_position_in_set: u32,\r\n    pub ui_size_of_set: u32,\r\n    pub ui_level: u32,\r\n    pub bounds: IRect,\r\n    pub kind: ExplorerItemKind,\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]\r\npub struct EditorArea {\r\n    pub groups: Vec<EditorGroup>,\r\n}\r\nimpl EditorArea {\r\n    pub fn get_expected_automation_id() -> &'static str {\r\n        \"workbench.parts.editor\"\r\n    }\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]\r\npub struct EditorGroup {\r\n    pub tabs: Vec<EditorTab>,\r\n    pub content: Option<EditorContent>,\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]\r\npub struct EditorTab {\r\n    pub title: String,\r\n    pub active: bool,\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]\r\npub struct EditorContent {\r\n    pub content: String,\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]\r\npub enum SideTabKind {\r\n    Explorer,\r\n    Search,\r\n    SourceControl,\r\n    RunAndDebug,\r\n    Extensions,\r\n    GitLens,\r\n    Azure,\r\n    Jupyter,\r\n    Chat,\r\n    GitHubActions,\r\n    Todo,\r\n}\r\nimpl SideTabKind {\r\n    pub fn variants() -> Vec<SideTabKind> {\r\n        vec![\r\n            SideTabKind::Explorer,\r\n            SideTabKind::Search,\r\n            SideTabKind::SourceControl,\r\n            SideTabKind::RunAndDebug,\r\n            SideTabKind::Extensions,\r\n            SideTabKind::GitLens,\r\n            SideTabKind::Azure,\r\n            SideTabKind::Jupyter,\r\n            SideTabKind::Chat,\r\n            SideTabKind::GitHubActions,\r\n            SideTabKind::Todo,\r\n        ]\r\n    }\r\n    pub fn get_view_automation_id(&self) -> Option<&str> {\r\n        match self {\r\n            SideTabKind::Explorer => Some(\"workbench.view.explorer\"),\r\n            _ => None,\r\n        }\r\n    }\r\n}\r\nimpl TryFrom<String> for SideTabKind {\r\n    type Error = VSCodeResolveError;\r\n    fn try_from(s: String) -> Result<Self, Self::Error> {\r\n        let before_first_lparen = s.split_once(\" (\").map(|x| x.0).unwrap_or(s.as_str());\r\n        match before_first_lparen {\r\n            \"Explorer\" => Ok(SideTabKind::Explorer),\r\n            \"Search\" => Ok(SideTabKind::Search),\r\n            \"Source Control\" => Ok(SideTabKind::SourceControl),\r\n            \"Run and Debug\" => Ok(SideTabKind::RunAndDebug),\r\n            \"Extensions\" => Ok(SideTabKind::Extensions),\r\n            \"GitLens\" => Ok(SideTabKind::GitLens),\r\n            \"Azure\" => Ok(SideTabKind::Azure),\r\n            \"Jupyter\" => Ok(SideTabKind::Jupyter),\r\n            \"Chat\" => Ok(SideTabKind::Chat),\r\n            \"GitHub Actions\" => Ok(SideTabKind::GitHubActions),\r\n            \"TODOs\" => Ok(SideTabKind::Todo),\r\n            _ => Err(VSCodeResolveError::UnknownSideTabKind(s)),\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\version\\src\\version_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n\r\npub struct VersionPlugin(pub String);\r\n\r\nimpl Plugin for VersionPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.insert_resource(Version(self.0.clone()));\r\n    }\r\n}\r\n\r\n#[derive(Resource, Reflect, Default)]\r\n#[reflect(Resource)]\r\npub struct Version(pub String);\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\host_event\\src\\host_event_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n\r\nuse crossbeam_channel::Receiver;\r\nuse cursor_hero_host_event_types::prelude::HostEvent;\r\nuse cursor_hero_winutils::win_events::create_os_event_listener;\r\nuse cursor_hero_winutils::win_events::ProcMessage;\r\n\r\npub struct HostEventPlugin;\r\n\r\nimpl Plugin for HostEventPlugin {\r\n    #![allow(unused_variables)]\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Startup, start_worker);\r\n        app.add_systems(Update, process_events);\r\n    }\r\n}\r\n\r\n#[derive(Resource)]\r\nstruct EventBridge {\r\n    receiver: Receiver<ProcMessage>,\r\n}\r\n\r\nfn start_worker(mut commands: Commands) {\r\n    info!(\"Starting worker thread\");\r\n    let Ok(rx) = create_os_event_listener() else {\r\n        error!(\"Failed to create OS event listener\");\r\n        return;\r\n    };\r\n    commands.insert_resource(EventBridge { receiver: rx });\r\n}\r\n\r\nfn process_events(bridge: ResMut<EventBridge>, mut host_events: EventWriter<HostEvent>) {\r\n    for event in bridge.receiver.try_iter() {\r\n        if let ProcMessage::MouseMoved { .. } = event {\r\n            host_events.send(HostEvent::MousePhysicallyMoved);\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\movement_tool\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_movement_tool\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\ncursor_hero_toolbelt_types = { workspace = true }\r\ncursor_hero_physics = { workspace = true }\r\ncursor_hero_movement_tool_types = { workspace = true }\r\ncursor_hero_character_types = { workspace = true }\r\ncursor_hero_tools = { workspace = true }\r\ncursor_hero_sprint_tool_types = { workspace = true }\r\ncursor_hero_input = { workspace = true }\r\ncursor_hero_math = { workspace = true }\r\nleafwing-input-manager = { workspace = true }\r\nbevy_xpbd_2d = { workspace = true }\r\nitertools = {workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\metrics\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_metrics\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nindexmap = { workspace = true}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\plugins\\src\\lib.rs\r\n\r\n````rust\r\nmod default_launch_mode_plugin;\r\nmod inspect_launch_mode_plugin;\r\npub mod prelude {\r\n    pub use crate::default_launch_mode_plugin::DefaultLaunchModePlugin;\r\n    pub use crate::inspect_launch_mode_plugin::InspectLaunchModePlugin;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\templates\\patterns\\new_plugin_with_types\\__pattern__.py\r\n\r\n````py\r\ndef gather_global_variables() -> dict[str,str]:\r\n    crate_name = input(\"crate_name\")\r\n    assert crate_name, \"crate_name is required\"\r\n    crate_name_pascal = pascal(crate_name)\r\n    return {\r\n        \"crate_name\": crate_name,\r\n        \"crate_name_pascal\": crate_name_pascal,\r\n    }\r\n\r\ndef pascal(snake_string: str) -> str:\r\n    return ''.join(word.capitalize() for word in snake_string.split('_'))\r\n\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\agent\\src\\agent_plugin.rs\r\n\r\n````rust\r\nuse crate::agent_movement_plugin::AgentMovementPlugin;\r\nuse crate::agent_spawning_plugin::AgentSpawningPlugin;\r\nuse crate::insert_agent_toolbelt::InsertAgentToolbeltPlugin;\r\nuse bevy::prelude::*;\r\n\r\npub struct AgentPlugin;\r\n\r\nimpl Plugin for AgentPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_plugins(InsertAgentToolbeltPlugin);\r\n        app.add_plugins(AgentSpawningPlugin);\r\n        app.add_plugins(AgentMovementPlugin);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\host_event_types\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_host_event_types\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\worker_types\\src\\lib.rs\r\n\r\n````rust\r\nmod worker_types;\r\nmod worker_types_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::worker_types::*;\r\n    pub use crate::worker_types_plugin::*;\r\n    pub use anyhow;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\templates\\patterns\\new_tool\\crates\\{{crate_name}}_tool_types\\src\\lib.rs\r\n\r\n````rust\r\npub mod {{crate_name}}_tool_types;\r\npub mod {{crate_name}}_tool_types_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::{{crate_name}}_tool_types::*;\r\n    pub use crate::{{crate_name}}_tool_types_plugin::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\calculator_app\\src\\calculator_app_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n\r\npub struct CalculatorAppPlugin;\r\n\r\nimpl Plugin for CalculatorAppPlugin {\r\n    fn build(&self, _app: &mut App) {}\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\text_asset\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_text_asset\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\ncursor_hero_text_asset_types = { workspace = true }\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\sprint_tool\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_sprint_tool\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\ncursor_hero_character_types = { workspace = true }\r\ncursor_hero_sprint_tool_types = { workspace = true }\r\nbevy_xpbd_2d = { workspace = true }\r\ncursor_hero_toolbelt_types = { workspace = true }\r\ncursor_hero_tools = { workspace = true }\r\ncursor_hero_pointer_types = { workspace = true }\r\nleafwing-input-manager = { workspace = true }\r\nbevy-inspector-egui = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\tools\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_tools\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\ncursor_hero_toolbelt_types = { workspace = true }\r\ncursor_hero_input = { workspace = true }\r\ncursor_hero_bevy = { workspace = true }\r\ncursor_hero_screen = { workspace = true }\r\ncursor_hero_pointer_types = { workspace = true }\r\ncursor_hero_agent_types = { workspace = true }\r\ncursor_hero_winutils = { workspace = true }\r\ncursor_hero_camera = { workspace = true }\r\ncursor_hero_host_fs_types = { workspace = true }\r\ncursor_hero_inference_types = { workspace = true }\r\ncursor_hero_level_bounds = { workspace = true }\r\ncursor_hero_voice_to_text_types = { workspace = true }\r\ncursor_hero_environment_types = { workspace = true }\r\ncursor_hero_character_types = { workspace = true }\r\ncursor_hero_sprint_tool_types = { workspace = true }\r\ncursor_hero_data = { workspace = true }\r\ncursor_hero_math = { workspace = true }\r\ncursor_hero_movement_tool_types = { workspace = true }\r\ncursor_hero_click_drag_character_movement = { workspace = true }\r\ncursor_hero_physics = { workspace = true }\r\nbevy = { workspace = true, features=[\"webp\"] }\r\nbevy-inspector-egui = { workspace = true }\r\nbevy_xpbd_2d = { workspace = true }\r\ncrossbeam-channel = {workspace = true }\r\nitertools = {workspace = true }\r\nraw-window-handle = {workspace = true }\r\nleafwing-input-manager = { workspace = true }\r\nwindows = { workspace = true, features = [\r\n    \"Win32_Foundation\",\r\n    \"Win32_Graphics_Gdi\",\r\n    \"Win32_UI_WindowsAndMessaging\",\r\n    \"Win32_System_Com\",\r\n    \"Win32_UI_Accessibility\",\r\n    \"Win32_UI_Input_KeyboardAndMouse\",\r\n    \"Gaming_Input\",\r\n    \"Win32_Gaming\",\r\n    \"Win32_System_Threading\",\r\n] }\r\nenigo = { workspace = true }\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\voice_to_text\\src\\voice_to_text_ping_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse bevy::utils::Instant;\r\nuse cursor_hero_voice_to_text_types::prelude::*;\r\n\r\npub struct VoiceToTextPingPlugin;\r\n\r\nimpl Plugin for VoiceToTextPingPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Update, periodic_ping);\r\n        app.add_systems(Update, handle_pong);\r\n        app.add_systems(Update, init_receiver_once_alive);\r\n    }\r\n}\r\n\r\nfn periodic_ping(\r\n    mut ping_events: EventWriter<VoiceToTextPingEvent>,\r\n    mut last_ping: Local<Option<Instant>>,\r\n) {\r\n    if let Some(instant) = *last_ping {\r\n        if instant.elapsed().as_secs() > 5 {\r\n            ping_events.send(VoiceToTextPingEvent::Ping);\r\n            *last_ping = Some(Instant::now());\r\n        }\r\n    } else {\r\n        ping_events.send(VoiceToTextPingEvent::Ping);\r\n        *last_ping = Some(Instant::now());\r\n    }\r\n}\r\n\r\nfn handle_pong(\r\n    mut ping_events: EventReader<VoiceToTextPingEvent>,\r\n    mut status_events: EventWriter<VoiceToTextStatusEvent>,\r\n    mut current_status: ResMut<VoiceToTextStatus>,\r\n) {\r\n    for event in ping_events.read() {\r\n        let VoiceToTextPingEvent::Pong { status: new_status } = event else {\r\n            continue;\r\n        };\r\n        // identify the new state based on the pong\r\n        // if the pong says dead and the current state is starting, only change to dead if the timeout has been exceeded\r\n        let new_status = match (&*current_status, new_status) {\r\n            (\r\n                VoiceToTextStatus::Starting {\r\n                    instant,\r\n                    timeout,\r\n                    api_key,\r\n                },\r\n                status,\r\n            ) => {\r\n                if let VoiceToTextStatus::Alive {\r\n                    api_key: other_api_key,\r\n                    listening,\r\n                } = status\r\n                {\r\n                    // Unlikely branch, but lets be safe\r\n                    if other_api_key != api_key {\r\n                        warn!(\"Received pong with Alive status with an api key different from the one we tracked when starting the program, overwriting api key\")\r\n                    }\r\n                    VoiceToTextStatus::Alive {\r\n                        api_key: other_api_key.clone(),\r\n                        listening: *listening,\r\n                    }\r\n                } else if *status == VoiceToTextStatus::AliveButWeDontKnowTheApiKey {\r\n                    // A server has responded to our ping, assume the API key is the one we tracked when we started the program\r\n                    VoiceToTextStatus::Alive {\r\n                        api_key: api_key.clone(),\r\n                        listening: false,\r\n                    }\r\n                } else if instant.elapsed() > *timeout {\r\n                    // Only accept the dead status if the timeout has been exceeded\r\n                    VoiceToTextStatus::Dead\r\n                } else {\r\n                    // Timeout not exceeded, keep the current status (starting)\r\n                    current_status.clone()\r\n                }\r\n            }\r\n            (VoiceToTextStatus::Alive { .. }, VoiceToTextStatus::AliveButWeDontKnowTheApiKey) => {\r\n                // Ping is alive, retain the api key\r\n                current_status.clone()\r\n            }\r\n            (\r\n                VoiceToTextStatus::UnknownWithCachedApiKey { api_key },\r\n                VoiceToTextStatus::AliveButWeDontKnowTheApiKey,\r\n            ) => {\r\n                // Ping is alive, use the cached api key\r\n                VoiceToTextStatus::Alive {\r\n                    api_key: api_key.clone(),\r\n                    listening: false,\r\n                }\r\n            }\r\n            (a, b) => {\r\n                debug!(\r\n                    \"Received pong with status {:?} but the current status is {:?}\",\r\n                    b, a\r\n                );\r\n                new_status.clone()\r\n            }\r\n        };\r\n\r\n        if *current_status != new_status {\r\n            let event = VoiceToTextStatusEvent::Changed {\r\n                old_status: current_status.clone(),\r\n                new_status: new_status.clone(),\r\n            };\r\n            debug!(\"Sending event {:?}\", event);\r\n            status_events.send(event);\r\n\r\n            *current_status = new_status;\r\n        }\r\n    }\r\n}\r\n\r\nfn init_receiver_once_alive(\r\n    mut command_events: EventWriter<VoiceToTextCommandEvent>,\r\n    mut status_events: EventReader<VoiceToTextStatusEvent>,\r\n) {\r\n    for event in status_events.read() {\r\n        let VoiceToTextStatusEvent::Changed {\r\n            new_status,\r\n            old_status,\r\n        } = event;\r\n        if !matches!(\r\n            old_status,\r\n            VoiceToTextStatus::Starting { .. } | VoiceToTextStatus::UnknownWithCachedApiKey { .. }\r\n        ) {\r\n            continue;\r\n        }\r\n        let VoiceToTextStatus::Alive { api_key, .. } = new_status else {\r\n            continue;\r\n        };\r\n        let event = VoiceToTextCommandEvent::ConnectReceiver {\r\n            api_key: api_key.clone(),\r\n        };\r\n        debug!(\"Now alive, sending event: {:?}\", event);\r\n        command_events.send(event);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\inference\\src\\inference_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n\r\nuse crate::prompt_asset_plugin::PromptAssetPlugin;\r\n\r\npub struct InferencePlugin;\r\n\r\nimpl Plugin for InferencePlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_plugins(PromptAssetPlugin);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\pointer_types\\src\\pointer_hover_types.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n\r\n#[derive(Event, Debug, Reflect)]\r\npub enum HoverEvent {\r\n    Start {\r\n        target_id: Entity,\r\n        pointer_id: Entity,\r\n    },\r\n    End {\r\n        target_id: Entity,\r\n        pointer_id: Entity,\r\n    },\r\n}\r\n\r\n#[derive(Component, Reflect, Debug)]\r\npub struct Hovered;\r\n#[derive(Component, Reflect, Debug)]\r\npub struct Hoverable;\r\n#[derive(Component, Reflect, Debug)]\r\npub struct Hovering {\r\n    pub hovering: Vec<Entity>,\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\pointer_types\\src\\pointer_behaviour_types.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse std::fmt::Display;\r\nuse std::fmt::Formatter;\r\n\r\n#[derive(Eq, PartialEq, Debug, Reflect, Clone, Copy)]\r\npub enum PointerMovementBehaviour {\r\n    None,\r\n    SetHostCursorFromPointerWorldCoords,\r\n    SetHostCursorFromWindowCoords,\r\n    SetPointerFromHostCursorWindowCoords,\r\n}\r\n\r\nimpl Display for PointerMovementBehaviour {\r\n    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {\r\n        write!(\r\n            f,\r\n            \"{}\",\r\n            match self {\r\n                PointerMovementBehaviour::None => \"None\",\r\n                PointerMovementBehaviour::SetHostCursorFromPointerWorldCoords =>\r\n                    \"SetHostCursorFromPointerWorldCoords\",\r\n                PointerMovementBehaviour::SetHostCursorFromWindowCoords =>\r\n                    \"SetHostCursorFromWindowCoords\",\r\n                PointerMovementBehaviour::SetPointerFromHostCursorWindowCoords =>\r\n                    \"SetPointerFromHostCursorWindowCoords\",\r\n            }\r\n        )\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\secret_types\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_secret_types\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\nzeroize = { workspace = true }\r\nserde = { workspace = true }\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\sprint_tool\\src\\lib.rs\r\n\r\n````rust\r\npub mod sprint_tool_plugin;\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\winutils\\src\\win_events.rs\r\n\r\n````rust\r\nuse bevy::math::IRect;\r\nuse bevy::math::IVec2;\r\nuse bevy::prelude::default;\r\nuse crossbeam_channel::Receiver;\r\nuse crossbeam_channel::Sender;\r\nuse once_cell::sync::Lazy;\r\nuse std::collections::HashMap;\r\nuse std::sync::Mutex;\r\nuse windows::core::PCWSTR;\r\nuse windows::Win32::Devices::HumanInterfaceDevice::HID_USAGE_GENERIC_KEYBOARD;\r\nuse windows::Win32::Devices::HumanInterfaceDevice::HID_USAGE_GENERIC_MOUSE;\r\nuse windows::Win32::Devices::HumanInterfaceDevice::HID_USAGE_PAGE_GENERIC;\r\nuse windows::Win32::Foundation::HWND;\r\nuse windows::Win32::Foundation::*;\r\nuse windows::Win32::System::Variant::VARIANT;\r\nuse windows::Win32::System::Variant::VT_I4;\r\nuse windows::Win32::UI::Accessibility::*;\r\nuse windows::Win32::UI::Input::GetRawInputData;\r\nuse windows::Win32::UI::Input::RegisterRawInputDevices;\r\nuse windows::Win32::UI::Input::HRAWINPUT;\r\nuse windows::Win32::UI::Input::RAWINPUT;\r\nuse windows::Win32::UI::Input::RAWINPUTDEVICE;\r\nuse windows::Win32::UI::Input::RAWINPUTHEADER;\r\nuse windows::Win32::UI::Input::RIDEV_INPUTSINK;\r\nuse windows::Win32::UI::Input::RID_INPUT;\r\nuse windows::Win32::UI::Input::RIM_TYPEKEYBOARD;\r\nuse windows::Win32::UI::Input::RIM_TYPEMOUSE;\r\nuse windows::Win32::UI::WindowsAndMessaging::EVENT_OBJECT_CREATE;\r\nuse windows::Win32::UI::WindowsAndMessaging::EVENT_OBJECT_DESTROY;\r\nuse windows::Win32::UI::WindowsAndMessaging::EVENT_OBJECT_HIDE;\r\nuse windows::Win32::UI::WindowsAndMessaging::EVENT_OBJECT_LIVEREGIONCHANGED;\r\nuse windows::Win32::UI::WindowsAndMessaging::EVENT_OBJECT_STATECHANGE;\r\nuse windows::Win32::UI::WindowsAndMessaging::EVENT_OBJECT_VALUECHANGE;\r\nuse windows::Win32::UI::WindowsAndMessaging::*;\r\n\r\n#[derive(Debug)]\r\npub enum ProcMessage {\r\n    MouseMoved(IVec2),\r\n    KeyDown(char),\r\n    Event {\r\n        event_name: String,\r\n        name: Option<String>,\r\n        role: Option<String>,\r\n        state: Option<String>,\r\n        bounds: Option<IRect>,\r\n    },\r\n}\r\n\r\nstatic SENDERS: Lazy<Mutex<HashMap<isize, Sender<ProcMessage>>>> =\r\n    Lazy::new(|| Mutex::new(HashMap::new()));\r\nstatic HWND_TO_HOOK: Lazy<Mutex<HashMap<isize, isize>>> = Lazy::new(|| Mutex::new(HashMap::new()));\r\nfn store_sender_for_identifier(\r\n    identifier: isize,\r\n    sender: Sender<ProcMessage>,\r\n) -> Result<(), &'static str> {\r\n    let mut senders = SENDERS.lock().map_err(|_| \"Failed to lock SENDERS map\")?;\r\n    senders.insert(identifier, sender);\r\n    Ok(())\r\n}\r\nfn get_sender_for_window(hwnd: HWND) -> Option<Sender<ProcMessage>> {\r\n    let senders = SENDERS.lock().ok()?;\r\n    senders.get(&hwnd.0).cloned()\r\n}\r\nfn get_sender_for_hook(hook: HWINEVENTHOOK) -> Option<Sender<ProcMessage>> {\r\n    let senders = SENDERS.lock().ok()?;\r\n    senders.get(&hook.0).cloned()\r\n}\r\nfn store_sender(\r\n    hwnd: HWND,\r\n    hook: HWINEVENTHOOK,\r\n    sender: Sender<ProcMessage>,\r\n) -> Result<(), &'static str> {\r\n    store_sender_for_identifier(hwnd.0, sender.clone())?;\r\n    store_sender_for_identifier(hook.0, sender)?;\r\n    Ok(())\r\n}\r\nfn drop_senders_for_window(hwnd: HWND) -> Result<(), &'static str> {\r\n    let mut senders = SENDERS.lock().map_err(|_| \"Failed to lock SENDERS map\")?;\r\n\r\n    // Remove the sender for the window\r\n    senders.remove(&hwnd.0);\r\n\r\n    // Get the hook for the window\r\n    let mut hook_map = HWND_TO_HOOK\r\n        .lock()\r\n        .map_err(|_| \"Failed to lock HWND_TO_HOOK map\")?;\r\n    if let Some(hook) = hook_map.remove(&hwnd.0) {\r\n        // Drop the sender for the hook\r\n        senders.remove(&hook);\r\n    }\r\n\r\n    Ok(())\r\n}\r\n\r\npub fn create_os_event_listener() -> Result<Receiver<ProcMessage>, windows::core::Error> {\r\n    let (tx, rx) = crossbeam_channel::unbounded();\r\n    std::thread::spawn(move || match create_window_and_do_message_loop(tx) {\r\n        Ok(()) => {\r\n            unreachable!(\"create_window_and_do_message_loop should never return Ok\");\r\n        }\r\n        Err(e) => {\r\n            eprintln!(\"Error in os_event_listener_thread: {:?}\", e);\r\n        }\r\n    });\r\n    Ok(rx)\r\n}\r\n\r\nfn create_window_and_do_message_loop(tx: Sender<ProcMessage>) -> Result<(), windows::core::Error> {\r\n    let hwnd = init_window()?;\r\n    // attach_tx_pointer(hwnd, tx.clone());\r\n    let hook = register_os_event_listener()?;\r\n    store_sender(hwnd, hook, tx).map_err(|e| windows::core::Error::new(E_FAIL, e.into()))?;\r\n\r\n    register_interest_in_mouse_with_os(hwnd.0)?;\r\n    register_interest_in_keyboard_with_os(hwnd.0)?;\r\n    unsafe {\r\n        let mut message = MSG::default();\r\n        println!(\"Starting message loop\");\r\n        while GetMessageA(&mut message, hwnd, 0, 0).as_bool() {\r\n            TranslateMessage(&message);\r\n            DispatchMessageA(&message);\r\n            // println!(\"ballin, got {:?}\", message);\r\n        }\r\n        DestroyWindow(hwnd)?;\r\n    }\r\n    Ok(())\r\n}\r\n\r\nfn register_os_event_listener() -> Result<HWINEVENTHOOK, windows::core::Error> {\r\n    unsafe {\r\n        match SetWinEventHook(\r\n            EVENT_MIN, // or specific event codes\r\n            EVENT_MAX, // or specific event codes\r\n            None,      // hmodWinEventProc\r\n            Some(os_event_procedure),\r\n            0, // idProcess\r\n            0, // idThread\r\n            WINEVENT_OUTOFCONTEXT,\r\n        ) {\r\n            HWINEVENTHOOK(0) => Err(windows::core::Error::new(\r\n                E_FAIL,\r\n                \"Failed to register interest in all events\".into(),\r\n            )),\r\n            x => Ok(x),\r\n        }\r\n    }\r\n}\r\n\r\nfn register_interest_in_mouse_with_os(hwnd: isize) -> Result<(), windows::core::Error> {\r\n    unsafe {\r\n        let device = RAWINPUTDEVICE {\r\n            usUsagePage: HID_USAGE_PAGE_GENERIC,\r\n            usUsage: HID_USAGE_GENERIC_MOUSE,\r\n            dwFlags: RIDEV_INPUTSINK,\r\n            hwndTarget: HWND(hwnd),\r\n        };\r\n        RegisterRawInputDevices(&[device], std::mem::size_of::<RAWINPUTDEVICE>() as u32)\r\n    }\r\n}\r\n\r\nfn register_interest_in_keyboard_with_os(hwnd: isize) -> Result<(), windows::core::Error> {\r\n    unsafe {\r\n        let device = RAWINPUTDEVICE {\r\n            usUsagePage: HID_USAGE_PAGE_GENERIC,\r\n            usUsage: HID_USAGE_GENERIC_KEYBOARD,\r\n            dwFlags: RIDEV_INPUTSINK,\r\n            hwndTarget: HWND(hwnd),\r\n        };\r\n        RegisterRawInputDevices(&[device], std::mem::size_of::<RAWINPUTDEVICE>() as u32)\r\n    }\r\n}\r\n\r\nfn init_window() -> Result<HWND, windows::core::Error> {\r\n    let class_name =\r\n        widestring::U16CString::from_str(\"bruh\").map_err(|_| windows::core::Error::OK)?;\r\n    let class_name_ptr = class_name.as_ptr();\r\n    let class_name_pcwstr = PCWSTR(class_name_ptr);\r\n\r\n    let hinstance = unsafe { windows::Win32::System::LibraryLoader::GetModuleHandleW(None)? };\r\n\r\n    let wnd = WNDCLASSEXW {\r\n        cbSize: std::mem::size_of::<WNDCLASSEXW>() as u32,\r\n        lpfnWndProc: Some(window_message_procedure),\r\n        hInstance: hinstance.into(),\r\n        lpszClassName: class_name_pcwstr,\r\n        ..default()\r\n    };\r\n\r\n    let _reg = unsafe { RegisterClassExW(&wnd) };\r\n\r\n    let window = unsafe {\r\n        CreateWindowExW(\r\n            WINDOW_EX_STYLE::default(),\r\n            class_name_pcwstr,\r\n            None,\r\n            WINDOW_STYLE(0),\r\n            CW_USEDEFAULT,\r\n            CW_USEDEFAULT,\r\n            CW_USEDEFAULT,\r\n            CW_USEDEFAULT,\r\n            None,\r\n            None,\r\n            hinstance,\r\n            None,\r\n        )\r\n    };\r\n\r\n    unsafe { GetLastError()? };\r\n    if window.0 == 0 {\r\n        return Err(windows::core::Error::from_win32());\r\n    }\r\n\r\n    Ok(window)\r\n}\r\n\r\nunsafe extern \"system\" fn window_message_procedure(\r\n    hwnd: HWND,\r\n    msg: u32,\r\n    w_param: WPARAM,\r\n    l_param: LPARAM,\r\n) -> LRESULT {\r\n    let next = || DefWindowProcW(hwnd, msg, w_param, l_param);\r\n\r\n    // let tx = match get_tx_pointer(hwnd) {\r\n    //     Some(tx) => tx,\r\n    //     None => return next(),\r\n    // };\r\n\r\n    let tx = match get_sender_for_window(hwnd) {\r\n        Some(tx) => tx,\r\n        None => return next(),\r\n    };\r\n\r\n    match msg {\r\n        WM_INPUT => {\r\n            let mut size = 0;\r\n            let result = GetRawInputData(\r\n                HRAWINPUT(l_param.0),\r\n                RID_INPUT,\r\n                None, // Pointer to data is null, requesting size only\r\n                &mut size,\r\n                std::mem::size_of::<RAWINPUTHEADER>() as u32,\r\n            );\r\n            assert_eq!(result as i32, 0);\r\n\r\n            let mut data = vec![0u8; size as usize];\r\n            let recv_size = GetRawInputData(\r\n                HRAWINPUT(l_param.0),\r\n                RID_INPUT,\r\n                Some(data.as_mut_ptr() as *mut std::ffi::c_void),\r\n                &mut size,\r\n                std::mem::size_of::<RAWINPUTHEADER>() as u32,\r\n            );\r\n            assert_eq!(recv_size as i32, size as i32);\r\n            let input = &*(data.as_ptr() as *const RAWINPUT);\r\n\r\n            if input.header.dwType == RIM_TYPEKEYBOARD.0\r\n                && input.data.keyboard.Message == WM_KEYDOWN\r\n            {\r\n                let key = input.data.keyboard.VKey as u8 as char;\r\n                if let Err(e) = tx.send(ProcMessage::KeyDown(key)) {\r\n                    eprintln!(\"Error sending keyboard message: {:?}\", e);\r\n                    return LRESULT(0);\r\n                }\r\n            }\r\n\r\n            if input.header.dwType == RIM_TYPEMOUSE.0 {\r\n                let mouse_data = input.data.mouse;\r\n                let x = mouse_data.lLastX;\r\n                let y = mouse_data.lLastY;\r\n                if let Err(e) = tx.send(ProcMessage::MouseMoved(IVec2::new(x, y))) {\r\n                    eprintln!(\"Error sending mouse message: {:?}\", e);\r\n                    return LRESULT(0);\r\n                }\r\n            }\r\n\r\n            LRESULT(0)\r\n        }\r\n        WM_DESTROY => {\r\n            // detach_tx_pointer_and_drop(hwnd);\r\n            drop_senders_for_window(hwnd).unwrap();\r\n            PostQuitMessage(0);\r\n            LRESULT(0)\r\n        }\r\n        _ => next(),\r\n    }\r\n}\r\n\r\nunsafe extern \"system\" fn os_event_procedure(\r\n    hook: HWINEVENTHOOK,\r\n    event: u32,\r\n    hwnd: HWND,\r\n    object_id: i32,\r\n    child_id: i32,\r\n    _id_event_thread: u32,\r\n    _dwms_event_time: u32,\r\n) {\r\n    if event < 1000\r\n        || event == EVENT_OBJECT_SHOW\r\n        || event == EVENT_OBJECT_LOCATIONCHANGE\r\n        || event == EVENT_OBJECT_NAMECHANGE\r\n        || event == EVENT_OBJECT_REORDER\r\n        || event == EVENT_OBJECT_VALUECHANGE\r\n        || event == EVENT_OBJECT_CREATE\r\n        || event == EVENT_OBJECT_DESTROY\r\n        || event == EVENT_OBJECT_HIDE\r\n        || event == EVENT_OBJECT_LIVEREGIONCHANGED\r\n    {\r\n        return;\r\n    }\r\n    // if event < 1000 {\r\n    //     return;\r\n    // }\r\n\r\n    let event_name = event_to_name(event).to_string();\r\n    // println!(\r\n    //     \"Hook: {:?}, Event: {:?} ({}), HWND: {:?}, idObject: {:?}, idChild: {:?}\",\r\n    //     hook,\r\n    //     event,\r\n    //     event_name,\r\n    //     hwnd,\r\n    //     object_id,\r\n    //     child_id\r\n    // );\r\n\r\n    // println!(\"Attempting getting tx from window hwnd: {:?}\", hwnd);\r\n    let tx = match get_sender_for_hook(hook) {\r\n        Some(tx) => {\r\n            // println!(\"Got tx from hook {:?}\", hook);\r\n            tx\r\n        }\r\n        None => {\r\n            eprintln!(\"No tx found for hook {:?}\", hook);\r\n            return;\r\n        }\r\n    };\r\n\r\n    if object_id != OBJID_CLIENT.0 {\r\n        return;\r\n    }\r\n    // println!(\"happy path\");\r\n    // if (event == EVENT_OBJECT_SELECTIONADD || event == EVENT_OBJECT_STATECHANGE)\r\n    //     && object_id == OBJID_CLIENT.0 {}\r\n    // Here you get the name and state of the element that triggered the event.\r\n    // Implement the logic to retrieve the name and state using the AccessibleObjectFromEvent function.\r\n    let mut acc_ptr: Option<IAccessible> = None;\r\n    let mut elem = VARIANT::default();\r\n\r\n    // println!(\"Getting accessible object\");\r\n    let lookup = AccessibleObjectFromEvent(\r\n        hwnd,\r\n        object_id as u32,\r\n        child_id as u32,\r\n        &mut acc_ptr,\r\n        &mut elem,\r\n    );\r\n    if lookup.is_err() {\r\n        // eprintln!(\"Error getting accessible object: {:?}\", lookup);\r\n        return;\r\n    }\r\n    let acc = match acc_ptr {\r\n        Some(acc) => acc,\r\n        None => {\r\n            // eprintln!(\"Error getting accessible object\");\r\n            return;\r\n        }\r\n    };\r\n\r\n    // println!(\"Getting name\");\r\n    let name = acc.get_accName(elem.clone()).map(|x| x.to_string()).ok();\r\n\r\n    // println!(\"Getting role\");\r\n    let role = acc\r\n        .get_accRole(elem.clone())\r\n        .and_then(|variant| variant_to_int(&variant))\r\n        .map(|i| role_to_name(i as u32).to_string())\r\n        .ok();\r\n\r\n    // println!(\"Getting state\");\r\n    let state = acc\r\n        .get_accState(elem.clone())\r\n        .and_then(|variant| variant_to_int(&variant))\r\n        .map(|i| state_to_string(i as u32))\r\n        .ok();\r\n\r\n    let mut pxleft = 0;\r\n    let mut pytop = 0;\r\n    let mut pcxwidth = 0;\r\n    let mut pcyheight = 0;\r\n\r\n    // println!(\"Getting location\");\r\n    let bounds = match acc.accLocation(&mut pxleft, &mut pytop, &mut pcxwidth, &mut pcyheight, elem)\r\n    {\r\n        Ok(()) => Some(IRect::from_corners(\r\n            IVec2::new(pxleft, pytop),\r\n            IVec2::new(pxleft + pcxwidth, pytop + pcyheight),\r\n        )),\r\n        Err(_) => None,\r\n    };\r\n\r\n    // println!(\"Building msg\");\r\n    let msg = ProcMessage::Event {\r\n        event_name,\r\n        name,\r\n        role,\r\n        state,\r\n        bounds,\r\n    };\r\n\r\n    // println!(\"Sending event message {:?}\", msg);\r\n    if let Err(e) = tx.send(msg) {\r\n        eprintln!(\"Error sending event message: {:?}\", e);\r\n    } else {\r\n        // println!(\"Sent event message :D\");\r\n    }\r\n}\r\n\r\nfn variant_to_int(variant: &VARIANT) -> Result<i32, windows::core::Error> {\r\n    let var_type = unsafe { variant.Anonymous.Anonymous.vt };\r\n\r\n    match var_type {\r\n        VT_I4 => {\r\n            // Extract 32-bit integer\r\n            Ok(unsafe { variant.Anonymous.Anonymous.Anonymous.lVal })\r\n        }\r\n        _ => Err(windows::core::Error::new(\r\n            windows::Win32::Foundation::E_FAIL,\r\n            \"Unsupported VARIANT type\".into(),\r\n        )),\r\n    }\r\n}\r\n\r\n// fn decimal_to_string(decimal: DECIMAL) -> Result<String, windows::core::Error> {\r\n//     unsafe { VarBstrFromDec(&decimal, 0, 0).map(|bstr| bstr.to_string()) }\r\n// }\r\n\r\n// fn variant_to_string(variant: &VARIANT) -> Result<String, windows::core::Error> {\r\n//     let var_type = unsafe { variant.Anonymous.Anonymous.vt };\r\n\r\n//     match var_type {\r\n//         VT_BSTR => {\r\n//             // Extract BSTR and convert to String\r\n//             let bstr = unsafe { &variant.Anonymous.Anonymous.Anonymous.bstrVal };\r\n//             Ok(bstr.to_string())\r\n//         }\r\n//         VT_I4 => {\r\n//             // Extract 32-bit integer and convert to String\r\n//             let int_val = unsafe { variant.Anonymous.Anonymous.Anonymous.lVal };\r\n//             Ok(int_val.to_string())\r\n//         }\r\n//         // Add more cases as needed for other VARTYPEs you expect to handle\r\n//         _ => Err(windows::core::Error::new(\r\n//             windows::Win32::Foundation::E_FAIL,\r\n//             \"Unsupported VARIANT type\".into(),\r\n//         )),\r\n//     }\r\n// }\r\n\r\nfn state_to_string(state: u32) -> String {\r\n    let mut states = Vec::new();\r\n    if state & STATE_SYSTEM_ALERT_HIGH != 0 {\r\n        states.push(\"STATE_SYSTEM_ALERT_HIGH\")\r\n    }\r\n    if state & STATE_SYSTEM_ALERT_LOW != 0 {\r\n        states.push(\"STATE_SYSTEM_ALERT_LOW\")\r\n    }\r\n    if state & STATE_SYSTEM_ALERT_MEDIUM != 0 {\r\n        states.push(\"STATE_SYSTEM_ALERT_MEDIUM\")\r\n    }\r\n    if state & STATE_SYSTEM_ANIMATED != 0 {\r\n        states.push(\"STATE_SYSTEM_ANIMATED\")\r\n    }\r\n    if state & STATE_SYSTEM_BUSY != 0 {\r\n        states.push(\"STATE_SYSTEM_BUSY\")\r\n    }\r\n    if state & STATE_SYSTEM_CHECKED != 0 {\r\n        states.push(\"STATE_SYSTEM_CHECKED\")\r\n    }\r\n    if state & STATE_SYSTEM_COLLAPSED != 0 {\r\n        states.push(\"STATE_SYSTEM_COLLAPSED\")\r\n    }\r\n    if state & STATE_SYSTEM_DEFAULT != 0 {\r\n        states.push(\"STATE_SYSTEM_DEFAULT\")\r\n    }\r\n    if state & STATE_SYSTEM_EXPANDED != 0 {\r\n        states.push(\"STATE_SYSTEM_EXPANDED\")\r\n    }\r\n    if state & STATE_SYSTEM_EXTSELECTABLE != 0 {\r\n        states.push(\"STATE_SYSTEM_EXTSELECTABLE\")\r\n    }\r\n    if state & STATE_SYSTEM_FLOATING != 0 {\r\n        states.push(\"STATE_SYSTEM_FLOATING\")\r\n    }\r\n    if state & STATE_SYSTEM_FOCUSED != 0 {\r\n        states.push(\"STATE_SYSTEM_FOCUSED\")\r\n    }\r\n    if state & STATE_SYSTEM_HOTTRACKED != 0 {\r\n        states.push(\"STATE_SYSTEM_HOTTRACKED\")\r\n    }\r\n    if state & STATE_SYSTEM_INDETERMINATE != 0 {\r\n        states.push(\"STATE_SYSTEM_INDETERMINATE\")\r\n    }\r\n    if state & STATE_SYSTEM_LINKED != 0 {\r\n        states.push(\"STATE_SYSTEM_LINKED\")\r\n    }\r\n    if state & STATE_SYSTEM_MARQUEED != 0 {\r\n        states.push(\"STATE_SYSTEM_MARQUEED\")\r\n    }\r\n    if state & STATE_SYSTEM_MIXED != 0 {\r\n        states.push(\"STATE_SYSTEM_MIXED\")\r\n    }\r\n    if state & STATE_SYSTEM_MOVEABLE != 0 {\r\n        states.push(\"STATE_SYSTEM_MOVEABLE\")\r\n    }\r\n    if state & STATE_SYSTEM_MULTISELECTABLE != 0 {\r\n        states.push(\"STATE_SYSTEM_MULTISELECTABLE\")\r\n    }\r\n    if state & STATE_SYSTEM_PROTECTED != 0 {\r\n        states.push(\"STATE_SYSTEM_PROTECTED\")\r\n    }\r\n    if state & STATE_SYSTEM_READONLY != 0 {\r\n        states.push(\"STATE_SYSTEM_READONLY\")\r\n    }\r\n    if state & STATE_SYSTEM_SELECTABLE != 0 {\r\n        states.push(\"STATE_SYSTEM_SELECTABLE\")\r\n    }\r\n    if state & STATE_SYSTEM_SELECTED != 0 {\r\n        states.push(\"STATE_SYSTEM_SELECTED\")\r\n    }\r\n    if state & STATE_SYSTEM_SELFVOICING != 0 {\r\n        states.push(\"STATE_SYSTEM_SELFVOICING\")\r\n    }\r\n    if state & STATE_SYSTEM_SIZEABLE != 0 {\r\n        states.push(\"STATE_SYSTEM_SIZEABLE\")\r\n    }\r\n    if state & STATE_SYSTEM_TRAVERSED != 0 {\r\n        states.push(\"STATE_SYSTEM_TRAVERSED\")\r\n    }\r\n    if state & STATE_SYSTEM_VALID != 0 {\r\n        states.push(\"STATE_SYSTEM_VALID\")\r\n    }\r\n    states.join(\",\")\r\n}\r\n\r\npub fn role_to_name(role: u32) -> &'static str {\r\n    match role {\r\n        ROLE_SYSTEM_ALERT => \"ROLE_SYSTEM_ALERT\",\r\n        ROLE_SYSTEM_ANIMATION => \"ROLE_SYSTEM_ANIMATION\",\r\n        ROLE_SYSTEM_APPLICATION => \"ROLE_SYSTEM_APPLICATION\",\r\n        ROLE_SYSTEM_BORDER => \"ROLE_SYSTEM_BORDER\",\r\n        ROLE_SYSTEM_BUTTONDROPDOWN => \"ROLE_SYSTEM_BUTTONDROPDOWN\",\r\n        ROLE_SYSTEM_BUTTONDROPDOWNGRID => \"ROLE_SYSTEM_BUTTONDROPDOWNGRID\",\r\n        ROLE_SYSTEM_BUTTONMENU => \"ROLE_SYSTEM_BUTTONMENU\",\r\n        ROLE_SYSTEM_CARET => \"ROLE_SYSTEM_CARET\",\r\n        ROLE_SYSTEM_CELL => \"ROLE_SYSTEM_CELL\",\r\n        ROLE_SYSTEM_CHARACTER => \"ROLE_SYSTEM_CHARACTER\",\r\n        ROLE_SYSTEM_CHART => \"ROLE_SYSTEM_CHART\",\r\n        ROLE_SYSTEM_CHECKBUTTON => \"ROLE_SYSTEM_CHECKBUTTON\",\r\n        ROLE_SYSTEM_CLIENT => \"ROLE_SYSTEM_CLIENT\",\r\n        ROLE_SYSTEM_CLOCK => \"ROLE_SYSTEM_CLOCK\",\r\n        ROLE_SYSTEM_COLUMN => \"ROLE_SYSTEM_COLUMN\",\r\n        ROLE_SYSTEM_COLUMNHEADER => \"ROLE_SYSTEM_COLUMNHEADER\",\r\n        ROLE_SYSTEM_COMBOBOX => \"ROLE_SYSTEM_COMBOBOX\",\r\n        ROLE_SYSTEM_CURSOR => \"ROLE_SYSTEM_CURSOR\",\r\n        ROLE_SYSTEM_DIAGRAM => \"ROLE_SYSTEM_DIAGRAM\",\r\n        ROLE_SYSTEM_DIAL => \"ROLE_SYSTEM_DIAL\",\r\n        ROLE_SYSTEM_DIALOG => \"ROLE_SYSTEM_DIALOG\",\r\n        ROLE_SYSTEM_DOCUMENT => \"ROLE_SYSTEM_DOCUMENT\",\r\n        ROLE_SYSTEM_DROPLIST => \"ROLE_SYSTEM_DROPLIST\",\r\n        ROLE_SYSTEM_EQUATION => \"ROLE_SYSTEM_EQUATION\",\r\n        ROLE_SYSTEM_GRAPHIC => \"ROLE_SYSTEM_GRAPHIC\",\r\n        ROLE_SYSTEM_GRIP => \"ROLE_SYSTEM_GRIP\",\r\n        ROLE_SYSTEM_GROUPING => \"ROLE_SYSTEM_GROUPING\",\r\n        ROLE_SYSTEM_HELPBALLOON => \"ROLE_SYSTEM_HELPBALLOON\",\r\n        ROLE_SYSTEM_HOTKEYFIELD => \"ROLE_SYSTEM_HOTKEYFIELD\",\r\n        ROLE_SYSTEM_INDICATOR => \"ROLE_SYSTEM_INDICATOR\",\r\n        ROLE_SYSTEM_IPADDRESS => \"ROLE_SYSTEM_IPADDRESS\",\r\n        ROLE_SYSTEM_LINK => \"ROLE_SYSTEM_LINK\",\r\n        ROLE_SYSTEM_LIST => \"ROLE_SYSTEM_LIST\",\r\n        ROLE_SYSTEM_LISTITEM => \"ROLE_SYSTEM_LISTITEM\",\r\n        ROLE_SYSTEM_MENUBAR => \"ROLE_SYSTEM_MENUBAR\",\r\n        ROLE_SYSTEM_MENUITEM => \"ROLE_SYSTEM_MENUITEM\",\r\n        ROLE_SYSTEM_MENUPOPUP => \"ROLE_SYSTEM_MENUPOPUP\",\r\n        ROLE_SYSTEM_OUTLINE => \"ROLE_SYSTEM_OUTLINE\",\r\n        ROLE_SYSTEM_OUTLINEBUTTON => \"ROLE_SYSTEM_OUTLINEBUTTON\",\r\n        ROLE_SYSTEM_OUTLINEITEM => \"ROLE_SYSTEM_OUTLINEITEM\",\r\n        ROLE_SYSTEM_PAGETAB => \"ROLE_SYSTEM_PAGETAB\",\r\n        ROLE_SYSTEM_PAGETABLIST => \"ROLE_SYSTEM_PAGETABLIST\",\r\n        ROLE_SYSTEM_PANE => \"ROLE_SYSTEM_PANE\",\r\n        ROLE_SYSTEM_PROGRESSBAR => \"ROLE_SYSTEM_PROGRESSBAR\",\r\n        ROLE_SYSTEM_PROPERTYPAGE => \"ROLE_SYSTEM_PROPERTYPAGE\",\r\n        ROLE_SYSTEM_PUSHBUTTON => \"ROLE_SYSTEM_PUSHBUTTON\",\r\n        ROLE_SYSTEM_RADIOBUTTON => \"ROLE_SYSTEM_RADIOBUTTON\",\r\n        ROLE_SYSTEM_ROW => \"ROLE_SYSTEM_ROW\",\r\n        ROLE_SYSTEM_ROWHEADER => \"ROLE_SYSTEM_ROWHEADER\",\r\n        ROLE_SYSTEM_SCROLLBAR => \"ROLE_SYSTEM_SCROLLBAR\",\r\n        ROLE_SYSTEM_SEPARATOR => \"ROLE_SYSTEM_SEPARATOR\",\r\n        ROLE_SYSTEM_SLIDER => \"ROLE_SYSTEM_SLIDER\",\r\n        ROLE_SYSTEM_SOUND => \"ROLE_SYSTEM_SOUND\",\r\n        ROLE_SYSTEM_SPINBUTTON => \"ROLE_SYSTEM_SPINBUTTON\",\r\n        ROLE_SYSTEM_SPLITBUTTON => \"ROLE_SYSTEM_SPLITBUTTON\",\r\n        ROLE_SYSTEM_STATICTEXT => \"ROLE_SYSTEM_STATICTEXT\",\r\n        ROLE_SYSTEM_STATUSBAR => \"ROLE_SYSTEM_STATUSBAR\",\r\n        ROLE_SYSTEM_TABLE => \"ROLE_SYSTEM_TABLE\",\r\n        ROLE_SYSTEM_TEXT => \"ROLE_SYSTEM_TEXT\",\r\n        ROLE_SYSTEM_TITLEBAR => \"ROLE_SYSTEM_TITLEBAR\",\r\n        ROLE_SYSTEM_TOOLBAR => \"ROLE_SYSTEM_TOOLBAR\",\r\n        ROLE_SYSTEM_TOOLTIP => \"ROLE_SYSTEM_TOOLTIP\",\r\n        ROLE_SYSTEM_WHITESPACE => \"ROLE_SYSTEM_WHITESPACE\",\r\n        ROLE_SYSTEM_WINDOW => \"ROLE_SYSTEM_WINDOW\",\r\n        _ => \"<Unknown>\",\r\n    }\r\n}\r\n\r\npub fn event_to_name(event: u32) -> &'static str {\r\n    match event {\r\n        EVENT_AIA_END => \"EVENT_AIA_END\",\r\n        EVENT_AIA_START => \"EVENT_AIA_START\",\r\n        EVENT_CONSOLE_CARET => \"EVENT_CONSOLE_CARET\",\r\n        EVENT_CONSOLE_END => \"EVENT_CONSOLE_END\",\r\n        EVENT_CONSOLE_END_APPLICATION => \"EVENT_CONSOLE_END_APPLICATION\",\r\n        EVENT_CONSOLE_LAYOUT => \"EVENT_CONSOLE_LAYOUT\",\r\n        EVENT_CONSOLE_START_APPLICATION => \"EVENT_CONSOLE_START_APPLICATION\",\r\n        EVENT_CONSOLE_UPDATE_REGION => \"EVENT_CONSOLE_UPDATE_REGION\",\r\n        EVENT_CONSOLE_UPDATE_SCROLL => \"EVENT_CONSOLE_UPDATE_SCROLL\",\r\n        EVENT_CONSOLE_UPDATE_SIMPLE => \"EVENT_CONSOLE_UPDATE_SIMPLE\",\r\n        EVENT_OBJECT_ACCELERATORCHANGE => \"EVENT_OBJECT_ACCELERATORCHANGE\",\r\n        EVENT_OBJECT_CLOAKED => \"EVENT_OBJECT_CLOAKED\",\r\n        EVENT_OBJECT_CONTENTSCROLLED => \"EVENT_OBJECT_CONTENTSCROLLED\",\r\n        EVENT_OBJECT_CREATE => \"EVENT_OBJECT_CREATE\",\r\n        EVENT_OBJECT_DEFACTIONCHANGE => \"EVENT_OBJECT_DEFACTIONCHANGE\",\r\n        EVENT_OBJECT_DESCRIPTIONCHANGE => \"EVENT_OBJECT_DESCRIPTIONCHANGE\",\r\n        EVENT_OBJECT_DESTROY => \"EVENT_OBJECT_DESTROY\",\r\n        EVENT_OBJECT_DRAGCANCEL => \"EVENT_OBJECT_DRAGCANCEL\",\r\n        EVENT_OBJECT_DRAGCOMPLETE => \"EVENT_OBJECT_DRAGCOMPLETE\",\r\n        EVENT_OBJECT_DRAGDROPPED => \"EVENT_OBJECT_DRAGDROPPED\",\r\n        EVENT_OBJECT_DRAGENTER => \"EVENT_OBJECT_DRAGENTER\",\r\n        EVENT_OBJECT_DRAGLEAVE => \"EVENT_OBJECT_DRAGLEAVE\",\r\n        EVENT_OBJECT_DRAGSTART => \"EVENT_OBJECT_DRAGSTART\",\r\n        EVENT_OBJECT_END => \"EVENT_OBJECT_END\",\r\n        EVENT_OBJECT_FOCUS => \"EVENT_OBJECT_FOCUS\",\r\n        EVENT_OBJECT_HELPCHANGE => \"EVENT_OBJECT_HELPCHANGE\",\r\n        EVENT_OBJECT_HIDE => \"EVENT_OBJECT_HIDE\",\r\n        EVENT_OBJECT_HOSTEDOBJECTSINVALIDATED => \"EVENT_OBJECT_HOSTEDOBJECTSINVALIDATED\",\r\n        EVENT_OBJECT_IME_CHANGE => \"EVENT_OBJECT_IME_CHANGE\",\r\n        EVENT_OBJECT_IME_HIDE => \"EVENT_OBJECT_IME_HIDE\",\r\n        EVENT_OBJECT_IME_SHOW => \"EVENT_OBJECT_IME_SHOW\",\r\n        EVENT_OBJECT_INVOKED => \"EVENT_OBJECT_INVOKED\",\r\n        EVENT_OBJECT_LIVEREGIONCHANGED => \"EVENT_OBJECT_LIVEREGIONCHANGED\",\r\n        EVENT_OBJECT_LOCATIONCHANGE => \"EVENT_OBJECT_LOCATIONCHANGE\",\r\n        EVENT_OBJECT_NAMECHANGE => \"EVENT_OBJECT_NAMECHANGE\",\r\n        EVENT_OBJECT_PARENTCHANGE => \"EVENT_OBJECT_PARENTCHANGE\",\r\n        EVENT_OBJECT_REORDER => \"EVENT_OBJECT_REORDER\",\r\n        EVENT_OBJECT_SELECTION => \"EVENT_OBJECT_SELECTION\",\r\n        EVENT_OBJECT_SELECTIONADD => \"EVENT_OBJECT_SELECTIONADD\",\r\n        EVENT_OBJECT_SELECTIONREMOVE => \"EVENT_OBJECT_SELECTIONREMOVE\",\r\n        EVENT_OBJECT_SELECTIONWITHIN => \"EVENT_OBJECT_SELECTIONWITHIN\",\r\n        EVENT_OBJECT_SHOW => \"EVENT_OBJECT_SHOW\",\r\n        EVENT_OBJECT_STATECHANGE => \"EVENT_OBJECT_STATECHANGE\",\r\n        EVENT_OBJECT_TEXTEDIT_CONVERSIONTARGETCHANGED => {\r\n            \"EVENT_OBJECT_TEXTEDIT_CONVERSIONTARGETCHANGED\"\r\n        }\r\n        EVENT_OBJECT_TEXTSELECTIONCHANGED => \"EVENT_OBJECT_TEXTSELECTIONCHANGED\",\r\n        EVENT_OBJECT_UNCLOAKED => \"EVENT_OBJECT_UNCLOAKED\",\r\n        EVENT_OBJECT_VALUECHANGE => \"EVENT_OBJECT_VALUECHANGE\",\r\n        EVENT_OEM_DEFINED_END => \"EVENT_OEM_DEFINED_END\",\r\n        EVENT_OEM_DEFINED_START => \"EVENT_OEM_DEFINED_START\",\r\n        EVENT_SYSTEM_ALERT => \"EVENT_SYSTEM_ALERT\",\r\n        EVENT_SYSTEM_ARRANGMENTPREVIEW => \"EVENT_SYSTEM_ARRANGMENTPREVIEW\",\r\n        EVENT_SYSTEM_CAPTUREEND => \"EVENT_SYSTEM_CAPTUREEND\",\r\n        EVENT_SYSTEM_CAPTURESTART => \"EVENT_SYSTEM_CAPTURESTART\",\r\n        EVENT_SYSTEM_CONTEXTHELPEND => \"EVENT_SYSTEM_CONTEXTHELPEND\",\r\n        EVENT_SYSTEM_CONTEXTHELPSTART => \"EVENT_SYSTEM_CONTEXTHELPSTART\",\r\n        EVENT_SYSTEM_DESKTOPSWITCH => \"EVENT_SYSTEM_DESKTOPSWITCH\",\r\n        EVENT_SYSTEM_DIALOGEND => \"EVENT_SYSTEM_DIALOGEND\",\r\n        EVENT_SYSTEM_DIALOGSTART => \"EVENT_SYSTEM_DIALOGSTART\",\r\n        EVENT_SYSTEM_DRAGDROPEND => \"EVENT_SYSTEM_DRAGDROPEND\",\r\n        EVENT_SYSTEM_DRAGDROPSTART => \"EVENT_SYSTEM_DRAGDROPSTART\",\r\n        EVENT_SYSTEM_END => \"EVENT_SYSTEM_END\",\r\n        EVENT_SYSTEM_FOREGROUND => \"EVENT_SYSTEM_FOREGROUND\",\r\n        EVENT_SYSTEM_IME_KEY_NOTIFICATION => \"EVENT_SYSTEM_IME_KEY_NOTIFICATION\",\r\n        EVENT_SYSTEM_MENUEND => \"EVENT_SYSTEM_MENUEND\",\r\n        EVENT_SYSTEM_MENUPOPUPEND => \"EVENT_SYSTEM_MENUPOPUPEND\",\r\n        EVENT_SYSTEM_MENUPOPUPSTART => \"EVENT_SYSTEM_MENUPOPUPSTART\",\r\n        EVENT_SYSTEM_MENUSTART => \"EVENT_SYSTEM_MENUSTART\",\r\n        EVENT_SYSTEM_MINIMIZEEND => \"EVENT_SYSTEM_MINIMIZEEND\",\r\n        EVENT_SYSTEM_MINIMIZESTART => \"EVENT_SYSTEM_MINIMIZESTART\",\r\n        EVENT_SYSTEM_MOVESIZEEND => \"EVENT_SYSTEM_MOVESIZEEND\",\r\n        EVENT_SYSTEM_MOVESIZESTART => \"EVENT_SYSTEM_MOVESIZESTART\",\r\n        EVENT_SYSTEM_SCROLLINGEND => \"EVENT_SYSTEM_SCROLLINGEND\",\r\n        EVENT_SYSTEM_SCROLLINGSTART => \"EVENT_SYSTEM_SCROLLINGSTART\",\r\n        EVENT_SYSTEM_SOUND => \"EVENT_SYSTEM_SOUND\",\r\n        EVENT_SYSTEM_SWITCHEND => \"EVENT_SYSTEM_SWITCHEND\",\r\n        EVENT_SYSTEM_SWITCHER_APPDROPPED => \"EVENT_SYSTEM_SWITCHER_APPDROPPED\",\r\n        EVENT_SYSTEM_SWITCHER_APPGRABBED => \"EVENT_SYSTEM_SWITCHER_APPGRABBED\",\r\n        EVENT_SYSTEM_SWITCHER_APPOVERTARGET => \"EVENT_SYSTEM_SWITCHER_APPOVERTARGET\",\r\n        EVENT_SYSTEM_SWITCHER_CANCELLED => \"EVENT_SYSTEM_SWITCHER_CANCELLED\",\r\n        EVENT_SYSTEM_SWITCHSTART => \"EVENT_SYSTEM_SWITCHSTART\",\r\n        EVENT_UIA_EVENTID_END => \"EVENT_UIA_EVENTID_END\",\r\n        EVENT_UIA_EVENTID_START => \"EVENT_UIA_EVENTID_START\",\r\n        EVENT_UIA_PROPID_END => \"EVENT_UIA_PROPID_END\",\r\n        EVENT_UIA_PROPID_START => \"EVENT_UIA_PROPID_START\",\r\n        _ => \"<Unknown>\",\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n\r\n    #[test]\r\n    fn listen_all() -> Result<(), windows::core::Error> {\r\n        let rx = create_os_event_listener()?;\r\n        while let Ok(msg) = rx.recv() {\r\n            println!(\"Received message: {:?}\", msg);\r\n        }\r\n        Ok(())\r\n    }\r\n\r\n    #[test]\r\n    fn listen_events() -> Result<(), windows::core::Error> {\r\n        let rx = create_os_event_listener()?;\r\n        while let Ok(msg) = rx.recv() {\r\n            if !matches!(msg, ProcMessage::Event { .. }) {\r\n                continue;\r\n            }\r\n            println!(\"Received message: {:?}\", msg);\r\n        }\r\n        Ok(())\r\n    }\r\n\r\n    #[test]\r\n    fn listen_mouse() -> Result<(), windows::core::Error> {\r\n        let rx = create_os_event_listener()?;\r\n        while let Ok(msg) = rx.recv() {\r\n            if !matches!(msg, ProcMessage::MouseMoved { .. }) {\r\n                continue;\r\n            }\r\n            println!(\"Received message: {:?}\", msg);\r\n        }\r\n        Ok(())\r\n    }\r\n\r\n    #[test]\r\n    fn listen_keyboard() -> Result<(), windows::core::Error> {\r\n        let rx = create_os_event_listener()?;\r\n        while let Ok(msg) = rx.recv() {\r\n            if !matches!(msg, ProcMessage::KeyDown { .. }) {\r\n                continue;\r\n            }\r\n            println!(\"Received message: {:?}\", msg);\r\n        }\r\n        Ok(())\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\winutils\\src\\win_process.rs\r\n\r\n````rust\r\nuse crate::win_errors::*;\r\nuse windows::core::PWSTR;\r\nuse windows::Win32::Foundation::CloseHandle;\r\nuse windows::Win32::Foundation::HANDLE;\r\nuse windows::Win32::System::Diagnostics::ToolHelp::CreateToolhelp32Snapshot;\r\nuse windows::Win32::System::Diagnostics::ToolHelp::Process32FirstW;\r\nuse windows::Win32::System::Diagnostics::ToolHelp::Process32NextW;\r\nuse windows::Win32::System::Diagnostics::ToolHelp::PROCESSENTRY32W;\r\nuse windows::Win32::System::Diagnostics::ToolHelp::TH32CS_SNAPPROCESS;\r\nuse windows::Win32::System::Threading::OpenProcess;\r\nuse windows::Win32::System::Threading::QueryFullProcessImageNameW;\r\nuse windows::Win32::System::Threading::PROCESS_NAME_FORMAT;\r\nuse windows::Win32::System::Threading::PROCESS_QUERY_INFORMATION;\r\n\r\npub struct ProcessIterator {\r\n    snapshot: HANDLE,\r\n    process: PROCESSENTRY32W,\r\n    first_done: bool,\r\n}\r\n\r\nimpl ProcessIterator {\r\n    pub fn new() -> Result<Self> {\r\n        unsafe {\r\n            let snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0)?;\r\n            Ok(ProcessIterator {\r\n                snapshot,\r\n                process: PROCESSENTRY32W::default(),\r\n                first_done: false,\r\n            })\r\n        }\r\n    }\r\n}\r\n\r\nimpl Iterator for ProcessIterator {\r\n    type Item = PROCESSENTRY32W;\r\n\r\n    fn next(&mut self) -> Option<Self::Item> {\r\n        unsafe {\r\n            self.process.dwSize = std::mem::size_of::<PROCESSENTRY32W>() as u32;\r\n            if !self.first_done {\r\n                self.first_done = true;\r\n                match Process32FirstW(self.snapshot, &mut self.process) {\r\n                    Ok(()) => Some(self.process),\r\n                    Err(e) => {\r\n                        eprintln!(\"Failed to get first process: {:?}\", e);\r\n                        None\r\n                    }\r\n                }\r\n            } else {\r\n                match Process32NextW(self.snapshot, &mut self.process) {\r\n                    Ok(()) => Some(self.process),\r\n                    Err(e) => {\r\n                        if e.message() == \"There are no more files.\" {\r\n                            return None;\r\n                        }\r\n                        eprintln!(\"Failed to get next process: {:?}\", e);\r\n                        None\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nimpl Drop for ProcessIterator {\r\n    fn drop(&mut self) {\r\n        unsafe {\r\n            if let Err(e) = CloseHandle(self.snapshot) {\r\n                eprintln!(\"Failed to close snapshot: {:?}\", e);\r\n            }\r\n        };\r\n    }\r\n}\r\n\r\npub fn get_process_full_name(process_id: u32) -> Result<String> {\r\n    unsafe {\r\n        let process_handle: HANDLE = OpenProcess(PROCESS_QUERY_INFORMATION, false, process_id)?;\r\n        let result = (|| {\r\n            if process_handle.is_invalid() {\r\n                eprintln!(\"Failed to open process handle\");\r\n                return Err(windows::core::Error::from_win32());\r\n            }\r\n\r\n            let mut buffer: Vec<u16> = Vec::with_capacity(512);\r\n            let mut buffer_size = buffer.capacity() as u32;\r\n            let full_name_pwstr = PWSTR(buffer.as_mut_ptr());\r\n\r\n            QueryFullProcessImageNameW(\r\n                process_handle,\r\n                PROCESS_NAME_FORMAT(0),\r\n                full_name_pwstr,\r\n                &mut buffer_size,\r\n            )?;\r\n            buffer.set_len(buffer_size as usize);\r\n\r\n            Ok(String::from_utf16_lossy(&buffer))\r\n        })();\r\n        if let Err(e) = CloseHandle(process_handle) {\r\n            eprintln!(\"Failed to close process handle: {:?}\", e);\r\n        }\r\n        Ok(result?)\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\README.md\r\n\r\n````markdown\r\n# Cursor Hero\r\n\r\n[![Visitors](https://api.visitorbadge.io/api/visitors?path=github.com%2FTeamDman%2FCursor-Hero&countColor=%23263759)](https://visitorbadge.io/status?path=github.com%2FTeamDman%2FCursor-Hero)\r\n\r\n## Video demo\r\n\r\n[![yt thumbnail](https://img.youtube.com/vi/t1PYks0UTL8/0.jpg)](https://youtu.be/t1PYks0UTL8)\r\n\r\n## Regarding DualShock controllers\r\n\r\nTry [DS4Windows](https://ds4windows.dev/).\r\n\r\n## Integrations\r\n\r\n- [TeamDman/voice2text: Local speech recognition](https://github.com/teamdman/voice2text)\r\n- [ollama/ollama: Local LLM inference](https://github.com/ollama/ollama)\r\n- [R2D2FISH/glados-tts: GLaDOS speech synthesis](https://github.com/TeamDman/glados-tts.git)\r\n\r\n## Diagnosing problems\r\n\r\n```pwsh\r\n$env:RUST_BACKTRACE=\"1\"\r\n```\r\n\r\n## Project description\r\n\r\nCursor Hero is a thing built using Rust and the Bevy game engine.\r\n\r\nCursor Hero, when launched, presents you with a character that has a pointer. You can move the character and pointer independently using the mouse and keyboard, or using both sticks on a gamepad.\r\n\r\nIn the game world, you can see a scale representation of your monitors. I have three monitors, so when I launch the game I see the left, center, and right monitor, usually containing VSCode, Discord, and the Cursor Hero window itself.\r\n\r\nCursor Hero uses the `windows` crate to integrate tightly with the Windows operating system. It reads and writes the host cursor position, with integrations with the game to do things like position the host mouse \"cursor\" over the in-game \"pointer\", or updating the cursor so that it matches the game world position of the pointer, letting the player interact with the OS using the game representation of the screens.\r\n\r\nThis includes integrating with Windows UI automation to grab the locations of UI elements, copying the texture of the screen onto bricks in the game world that are physics objects.\r\n\r\nUI information is attached to the bricks, using `bevy-egui` to render UI elements with screen coordinates updated to correspond with world-coordinates of the bricks.\r\n\r\nUsing `egui`, the tree hierarchy of the UI is shown for the bricks created by clicking on UI elements in the screen texture. The tree could potentially grow to something like inspect.exe, where the properties of the UI element can be explored. Currently, the tree folding and selectable labels is working, but the properties panel on the right is not yet implemented.\r\n\r\nIn addition to showing the host environment, a game environment is also constructed. The game environment contains a virtual agent and a mimicry of the host OS. The mimicry extends to include a copy of the desktop background, a taskbar that pulls the colour from the OS preferences, and a start menu button that toggles visibility of an empty panel.\r\n\r\nThe virtual agent walks in circles. It has an observation buffer which other systems can publish events for something happening, and the buffer will conditionally append such events which are used in the construction of prompts for a local LLM ran using `ollama`.\r\n\r\nIn response to player chat messages, or in response to a period of inactivity, the agent will prompt the LLM in a chat format. With the response, it publishes its own chat message, and it invokes the `glados-tts` to speak the response to the player.\r\n\r\nThis agent behaviour, combined with integration to `voice2text`, allows the human to converse to the agent entirely locally using `whisper-x` to speak with the addition of a push-to-talk button and a toggle-active-listening button.\r\n\r\nGiven that the host cursor is being updated by the game pointer when in gamepad input mode, the game takes care to listen for raw mouse input events to determine when the player is trying to use mouse and keyboard input mode, avoiding holding the pointer captive since traditional input detection is not suitable. After all, if the pointer is programmatically controlled by the game, \"mouse moved events\" become less reliable when aiming for physical movement detection.\r\n\r\nAgain using the `windows` crate, the game is able to identify running processes and programmatically detect the exe path and extract the icons of the process from it.\r\nOpportunity exists to detect dynamic icons from process windows as well.\r\n\r\nThe game has a radial menu for enabling/disabling \"tools\", some of which start disabled and upon enabling will clear and repopulate the tools in the toolbelt with a different loadout.\r\n\r\nThe tool system has been used to show a radial menu of programs in the taskbar, using UI automation to grab the texture at the rect of each item to be displayed radially.\r\n\r\nThere is a tool loadout that lets you snap the game window to any corner or fullscreen of any monitors detected.\r\n\r\nThe default tool loadout starts you in click mode, letting you move your character and its pointer, with the ability to send click events to the OS, and to send click events to game objects using the ECS fundamentals. \r\n\r\nThe game has its own model system for the UI hierarchy, with support for detecting the details of running VSCode windows, including tabs on the left, open tab, contents of the explorer tab if open, editor groups open and involved tabs and file contents, current cursor line and position displayed in the bottom corner.\r\n\r\n## Where do we go from here\r\n\r\nI am continuously exploring many different trajectories for this project.\r\n\r\nSee [`./todo.md`](./todo.md) for brainstorming on potential features to add.\r\n\r\nSee [`./research_notes.md`](./research_notes.md) for links to internet resources that could be helpful.\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\chat\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_chat\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\ncursor_hero_character_types = { workspace = true }\r\ncursor_hero_toolbelt_types = { workspace = true }\r\ncursor_hero_chat_types = { workspace = true }\r\ncursor_hero_voice_to_text_types = { workspace = true }\r\ncursor_hero_tools = { workspace = true }\r\nleafwing-input-manager = { workspace = true }\r\ncursor_hero_observation_types = { workspace = true }\r\nrand = { workspace = true }\r\nbevy_xpbd_2d = { workspace = true }\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\floaty_nametag_types\\src\\lib.rs\r\n\r\n````rust\r\npub mod floaty_nametag_types;\r\npub mod floaty_nametag_types_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::floaty_nametag_types::*;\r\n    pub use crate::floaty_nametag_types_plugin::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\movement_tool\\src\\movement_sprint_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse cursor_hero_character_types::prelude::*;\r\nuse cursor_hero_math::prelude::Lerp;\r\nuse cursor_hero_movement_tool_types::prelude::*;\r\nuse cursor_hero_sprint_tool_types::sprint_tool_types_plugin::SprintEvent;\r\nuse cursor_hero_toolbelt_types::prelude::*;\r\nuse itertools::Itertools;\r\npub struct MovementSprintPlugin;\r\n\r\nimpl Plugin for MovementSprintPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Update, handle_sprint_events);\r\n    }\r\n}\r\n\r\nfn handle_sprint_events(\r\n    mut sprint_events: EventReader<SprintEvent>,\r\n    character_query: Query<&Children, With<Character>>,\r\n    toolbelt_query: Query<&Children, With<Toolbelt>>,\r\n    mut tool_query: Query<&mut MovementTool>,\r\n) {\r\n    for event in sprint_events.read() {\r\n        let character_id = match event {\r\n            SprintEvent::Active { character_id, .. } => character_id,\r\n            SprintEvent::Stop { character_id } => character_id,\r\n        };\r\n        let Ok(character) = character_query.get(*character_id) else {\r\n            warn!(\"Character {:?} does not exist\", character_id);\r\n            continue;\r\n        };\r\n        let character_kids = character;\r\n\r\n        let tool_ids = character_kids\r\n            .iter()\r\n            .filter_map(|kid| toolbelt_query.get(*kid).ok())\r\n            .flat_map(|toolbelt| toolbelt.iter())\r\n            .filter(|kid| tool_query.contains(**kid))\r\n            .cloned()\r\n            .collect_vec();\r\n\r\n        match event {\r\n            SprintEvent::Active { throttle, .. } => {\r\n                let mut iter = tool_query.iter_many_mut(&tool_ids);\r\n                while let Some(mut tool) = iter.fetch_next() {\r\n                    tool.speed = (tool.default_speed, tool.sprint_speed).lerp(*throttle);\r\n                }\r\n            }\r\n            SprintEvent::Stop { .. } => {\r\n                let mut iter = tool_query.iter_many_mut(&tool_ids);\r\n                while let Some(mut tool) = iter.fetch_next() {\r\n                    tool.speed = tool.default_speed;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\sprint_tool_types\\src\\sprint_tool_types_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n\r\npub struct SprintToolTypesPlugin;\r\n\r\nimpl Plugin for SprintToolTypesPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_event::<SprintEvent>();\r\n    }\r\n}\r\n\r\n#[derive(Event, Debug, Reflect)]\r\npub enum SprintEvent {\r\n    Active { character_id: Entity, throttle: f32 },\r\n    Stop { character_id: Entity },\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\taskbar\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_taskbar\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\nimage = { workspace = true}\r\ncursor_hero_environment_types = { workspace = true }\r\ncursor_hero_bevy = { workspace = true }\r\ncursor_hero_pointer_types = { workspace = true }\r\ncursor_hero_screen = { workspace = true }\r\ncursor_hero_toolbelt_types = { workspace = true }\r\ncursor_hero_taskbar_types = { workspace = true }\r\ncursor_hero_tools = { workspace = true }\r\nbevy_xpbd_2d = { workspace = true }\r\ncursor_hero_winutils = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\winutils\\src\\win_wallpaper.rs\r\n\r\n````rust\r\nuse std::env;\r\nuse std::ffi::OsString;\r\nuse std::os::raw::c_void;\r\nuse std::os::windows::ffi::OsStringExt;\r\nuse std::path::PathBuf;\r\nuse windows::Win32::UI::WindowsAndMessaging::SystemParametersInfoW;\r\nuse windows::Win32::UI::WindowsAndMessaging::SPIF_UPDATEINIFILE;\r\nuse windows::Win32::UI::WindowsAndMessaging::SPI_GETDESKWALLPAPER;\r\n/// This gets the path to the file at the time the user set the wallpaper.\r\n/// The file may have moved since then.\r\npub fn get_wallpaper_path() -> Result<OsString, windows::core::Error> {\r\n    let mut buffer = vec![0u16; 32768]; // theoretical max path after increase\r\n    unsafe {\r\n        SystemParametersInfoW(\r\n            SPI_GETDESKWALLPAPER,\r\n            buffer.len() as u32,\r\n            Some(buffer.as_mut_ptr() as *mut c_void),\r\n            SPIF_UPDATEINIFILE,\r\n        )\r\n    }?;\r\n\r\n    // Find the position of the first null character\r\n    let len = buffer.iter().position(|&c| c == 0).unwrap_or(buffer.len());\r\n\r\n    // Create a slice of the buffer up to the found position\r\n    let trimmed_buffer = &buffer[..len];\r\n\r\n    Ok(OsString::from_wide(trimmed_buffer))\r\n}\r\n\r\npub fn get_transcoded_wallpaper_path() -> Result<PathBuf, env::VarError> {\r\n    let app_data = env::var(\"APPDATA\")?; // Get the value of the APPDATA environment variable\r\n    let themes_path =\r\n        PathBuf::from(app_data).join(\"Microsoft\\\\Windows\\\\Themes\\\\TranscodedWallpaper\");\r\n    Ok(themes_path)\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    #[test]\r\n    fn test_get_wallpaper_path() {\r\n        let path = super::get_wallpaper_path();\r\n        println!(\"Wallpaper path: {:?}\", path);\r\n        assert!(path.is_ok());\r\n    }\r\n\r\n    #[test]\r\n    fn test_get_transcoded_wallpaper_path() {\r\n        let path = super::get_transcoded_wallpaper_path();\r\n        println!(\"Transcoded wallpaper path: {:?}\", path);\r\n        assert!(path.is_ok());\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\use cases\\run test.md\r\n\r\n````markdown\r\ngiven a rust file open, add a keyboard shortcut to run the test closest to the cursor\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\camera\\src\\camera_plugin.rs\r\n\r\n````rust\r\nuse bevy::ecs::query::QuerySingleError::MultipleEntities;\r\nuse bevy::ecs::query::QuerySingleError::NoEntities;\r\nuse bevy::input::mouse::MouseWheel;\r\nuse bevy::prelude::*;\r\nuse bevy::transform::TransformSystem;\r\nuse bevy::window::PrimaryWindow;\r\nuse bevy_egui::EguiContext;\r\nuse bevy_xpbd_2d::prelude::*;\r\nuse cursor_hero_physics::damping_plugin::MovementDamping;\r\npub struct CameraPlugin;\r\nimpl Plugin for CameraPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<MainCamera>();\r\n        app.add_event::<CameraEvent>();\r\n        app.add_systems(Startup, spawn_camera);\r\n        app.add_systems(Update, (update_camera_zoom, handle_events));\r\n        app.add_systems(\r\n            PostUpdate,\r\n            follow\r\n                .in_set(CameraSystemSet::Follow)\r\n                .after(PhysicsSet::Sync)\r\n                .before(TransformSystem::TransformPropagate),\r\n        );\r\n    }\r\n}\r\n\r\n#[derive(SystemSet, Clone, Hash, Debug, PartialEq, Eq)]\r\npub enum CameraSystemSet {\r\n    Follow,\r\n}\r\n\r\n#[derive(Component, Reflect)]\r\npub struct MainCamera;\r\n\r\nfn spawn_camera(mut commands: Commands) {\r\n    commands.spawn((\r\n        Camera2dBundle::default(),\r\n        MainCamera,\r\n        MovementDamping { factor: 0.90 },\r\n        MassPropertiesBundle::new_computed(&Collider::ball(10.0), 1.0),\r\n        RigidBody::Dynamic,\r\n        SpatialListener::new(-7.0),\r\n    ));\r\n}\r\n\r\n#[derive(Component)]\r\npub struct FollowWithMainCamera;\r\n\r\n#[derive(Event, Debug, Reflect)]\r\npub enum CameraEvent {\r\n    BeginFollowing { target_id: Entity },\r\n    StopFollowing { target_id: Entity },\r\n}\r\n\r\npub fn update_camera_zoom(\r\n    mut cam: Query<&mut Transform, With<MainCamera>>,\r\n    mut scroll: EventReader<MouseWheel>,\r\n    egui_context_query: Query<&EguiContext, With<PrimaryWindow>>,\r\n) {\r\n    let Ok(egui_context) = egui_context_query.get_single() else {\r\n        return;\r\n    };\r\n    let hovering_over_egui = egui_context.clone().get_mut().is_pointer_over_area();\r\n    if hovering_over_egui {\r\n        scroll.clear();\r\n        return;\r\n    }\r\n    for event in scroll.read() {\r\n        let mut scale = cam.single_mut().scale;\r\n        scale *= Vec2::splat(1.0 - event.y / 10.0).extend(1.0);\r\n        scale = scale.clamp(Vec3::splat(0.1), Vec3::splat(10.0));\r\n        cam.single_mut().scale = scale;\r\n    }\r\n}\r\n\r\nfn handle_events(\r\n    mut commands: Commands,\r\n    mut camera_events: EventReader<CameraEvent>,\r\n    character_query: Query<&GlobalTransform, Without<MainCamera>>,\r\n    mut camera_query: Query<&mut Transform, With<MainCamera>>,\r\n) {\r\n    for event in camera_events.read() {\r\n        match event {\r\n            CameraEvent::BeginFollowing { target_id } => {\r\n                info!(\"Camera following character '{:?}'\", target_id);\r\n                // tag character to mark it as being followed\r\n                commands.entity(*target_id).insert(FollowWithMainCamera);\r\n                if let Ok(mut camera_transform) = camera_query.get_single_mut()\r\n                    && let Ok(character_transform) = character_query.get_single()\r\n                {\r\n                    camera_transform.translation = character_transform.translation();\r\n                }\r\n            }\r\n            CameraEvent::StopFollowing { target_id } => {\r\n                info!(\"Camera stopped following character '{:?}'\", target_id);\r\n                // remove tag from character\r\n                commands.entity(*target_id).remove::<FollowWithMainCamera>();\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfn follow(\r\n    follow_query: Query<&GlobalTransform, With<FollowWithMainCamera>>,\r\n    mut cam_query: Query<&mut Transform, With<MainCamera>>,\r\n) {\r\n    let follow = match follow_query.get_single() {\r\n        Ok(follow) => follow,\r\n        Err(NoEntities(_)) => return,\r\n        Err(MultipleEntities(e)) => {\r\n            error!(\"Multiple entities are being followed: {:?}\", e);\r\n            return;\r\n        }\r\n    };\r\n    let follow_global_transform = follow;\r\n\r\n    let camera = match cam_query.get_single_mut() {\r\n        Ok(camera) => camera,\r\n        Err(NoEntities(_)) => return,\r\n        Err(MultipleEntities(e)) => {\r\n            error!(\"Multiple cameras found: {:?}\", e);\r\n            return;\r\n        }\r\n    };\r\n    let mut camera_transform = camera;\r\n\r\n    // update transform\r\n    let follow_translation = follow_global_transform.translation();\r\n    camera_transform.translation = follow_translation;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\secret\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_secret\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\ncursor_hero_secret_types = { workspace = true }\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\toolbelt_types\\src\\lib.rs\r\n\r\n````rust\r\npub mod toolbelt_types;\r\npub mod toolbelt_types_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::toolbelt_types::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\wallpaper\\src\\wallpaper_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse cursor_hero_environment_types::prelude::*;\r\n\r\npub struct WallpaperPlugin;\r\n\r\nimpl Plugin for WallpaperPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<Wallpaper>();\r\n        app.add_systems(Update, spawn_wallpaper);\r\n    }\r\n}\r\n\r\n#[derive(Component, Debug, Reflect)]\r\npub struct Wallpaper;\r\n\r\nfn spawn_wallpaper(\r\n    mut commands: Commands,\r\n    mut environment_events: EventReader<PopulateEnvironmentEvent>,\r\n    environment_query: Query<&GameEnvironment>,\r\n    asset_server: Res<AssetServer>,\r\n) {\r\n    for event in environment_events.read() {\r\n        if !environment_query.contains(event.environment_id) {\r\n            continue;\r\n        }\r\n        info!(\r\n            \"Spawning wallpaper for game environment {:?}\",\r\n            event.environment_id\r\n        );\r\n        commands\r\n            .entity(event.environment_id)\r\n            .with_children(|parent| {\r\n                parent.spawn((\r\n                    SpriteBundle {\r\n                        sprite: Sprite {\r\n                            custom_size: Some(Vec2::new(1920.0, 1080.0)),\r\n                            anchor: bevy::sprite::Anchor::TopLeft,\r\n                            ..default()\r\n                        },\r\n                        texture: asset_server.load(\"textures/environment/game/wallpaper.png\"),\r\n                        transform: Transform::from_translation(Vec3::new(0.0, 0.0, 1.0)),\r\n                        ..default()\r\n                    },\r\n                    Name::new(\"Wallpaper\"),\r\n                ));\r\n            });\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\host_fs_types\\src\\host_fs_types.rs\r\n\r\n````rust\r\nuse std::path::PathBuf;\r\n\r\nuse bevy::prelude::*;\r\n\r\n#[derive(Component, Debug, Reflect, Clone, Eq, PartialEq)]\r\npub struct HostPath {\r\n    pub path: PathBuf,\r\n}\r\n\r\n#[derive(Event, Debug, Reflect)]\r\npub enum HostPathAction {\r\n    OpenWithCode { path: HostPath },\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\memory_types\\src\\lib.rs\r\n\r\n````rust\r\nmod memory_types;\r\nmod memory_types_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::memory_types::*;\r\n    pub use crate::memory_types_plugin::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\math\\src\\corner.rs\r\n\r\n````rust\r\nuse bevy::reflect::Reflect;\r\n\r\n#[derive(Debug, Reflect, Eq, Clone, PartialEq, Hash)]\r\npub enum Corner {\r\n    TopLeft,\r\n    TopRight,\r\n    BottomLeft,\r\n    BottomRight,\r\n}\r\nimpl Corner {\r\n    pub fn variants() -> [Self; 4] {\r\n        [\r\n            Self::TopLeft,\r\n            Self::TopRight,\r\n            Self::BottomLeft,\r\n            Self::BottomRight,\r\n        ]\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\memory_types\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_memory_types\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\ncursor_hero_winutils = { workspace = true }\r\ncursor_hero_character_types = { workspace = true }\r\ncursor_hero_camera = { workspace = true }\r\ncursor_hero_toolbelt_types = { workspace = true }\r\ncursor_hero_voice_to_text_types = { workspace = true }\r\ncursor_hero_secret_types = { workspace = true }\r\ncursor_hero_observation_types = { workspace = true }\r\nraw-window-handle = { workspace = true }\r\nserde = { workspace = true, features=[\"derive\"] }\r\nserde_json = { workspace = true }\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\wallpaper\\src\\lib.rs\r\n\r\n````rust\r\npub mod wallpaper_plugin;\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\observation\\src\\observation_log_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse cursor_hero_observation_types::prelude::*;\r\n\r\npub struct ObservationLogPlugin;\r\n\r\nimpl Plugin for ObservationLogPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Update, log_observations);\r\n    }\r\n}\r\n\r\nfn log_observations(mut observation_event_reader: EventReader<SomethingObservableHappenedEvent>) {\r\n    for event in observation_event_reader.read() {\r\n        info!(\"{:?}\", event);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\voice_to_text_types\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_voice_to_text_types\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\ncursor_hero_secret_types = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\window_position\\src\\window_position_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n\r\nuse crate::window_position_command_plugin::WindowPositionCommandPlugin;\r\nuse crate::window_position_loadout_switcher_tool_plugin::WindowPositionLoadoutSwitcherToolPlugin;\r\nuse crate::window_position_tool_plugin::WindowPositionToolPlugin;\r\n\r\npub struct WindowPositionPlugin;\r\n\r\nimpl Plugin for WindowPositionPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_plugins(WindowPositionLoadoutSwitcherToolPlugin);\r\n        app.add_plugins(WindowPositionToolPlugin);\r\n        app.add_plugins(WindowPositionCommandPlugin);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\xelu_prompts\\src\\lib.rs\r\n\r\n````rust\r\n// https://thoseawesomeguys.com/prompts/\r\nuse bevy::input::gamepad::GamepadButtonType;\r\nuse bevy::input::keyboard::KeyCode;\r\nuse leafwing_input_manager::user_input::InputKind;\r\n\r\npub fn texture_path_for_input(kind: &InputKind) -> Option<&'static str> {\r\n    match kind {\r\n        InputKind::Keyboard(key) => {\r\n            match key {\r\n                KeyCode::Key0 => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/0_Key_Dark.png\"),\r\n                KeyCode::Key1 => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/1_Key_Dark.png\"),\r\n                KeyCode::Key2 => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/2_Key_Dark.png\"),\r\n                KeyCode::Key3 => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/3_Key_Dark.png\"),\r\n                KeyCode::Key4 => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/4_Key_Dark.png\"),\r\n                KeyCode::Key5 => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/5_Key_Dark.png\"),\r\n                KeyCode::Key6 => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/6_Key_Dark.png\"),\r\n                KeyCode::Key7 => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/7_Key_Dark.png\"),\r\n                KeyCode::Key8 => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/8_Key_Dark.png\"),\r\n                KeyCode::Key9 => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/9_Key_Dark.png\"),\r\n\r\n                KeyCode::Numpad0 => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/0_Key_Dark.png\")\r\n                }\r\n                KeyCode::Numpad1 => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/1_Key_Dark.png\")\r\n                }\r\n                KeyCode::Numpad2 => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/2_Key_Dark.png\")\r\n                }\r\n                KeyCode::Numpad3 => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/3_Key_Dark.png\")\r\n                }\r\n                KeyCode::Numpad4 => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/4_Key_Dark.png\")\r\n                }\r\n                KeyCode::Numpad5 => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/5_Key_Dark.png\")\r\n                }\r\n                KeyCode::Numpad6 => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/6_Key_Dark.png\")\r\n                }\r\n                KeyCode::Numpad7 => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/7_Key_Dark.png\")\r\n                }\r\n                KeyCode::Numpad8 => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/8_Key_Dark.png\")\r\n                }\r\n                KeyCode::Numpad9 => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/9_Key_Dark.png\")\r\n                }\r\n\r\n                KeyCode::F1 => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/F1_Key_Dark.png\"),\r\n                KeyCode::F2 => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/F2_Key_Dark.png\"),\r\n                KeyCode::F3 => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/F3_Key_Dark.png\"),\r\n                KeyCode::F4 => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/F4_Key_Dark.png\"),\r\n                KeyCode::F5 => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/F5_Key_Dark.png\"),\r\n                KeyCode::F6 => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/F6_Key_Dark.png\"),\r\n                KeyCode::F7 => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/F7_Key_Dark.png\"),\r\n                KeyCode::F8 => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/F8_Key_Dark.png\"),\r\n                KeyCode::F9 => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/F9_Key_Dark.png\"),\r\n                KeyCode::F10 => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/F10_Key_Dark.png\")\r\n                }\r\n                KeyCode::F11 => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/F11_Key_Dark.png\")\r\n                }\r\n                KeyCode::F12 => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/F12_Key_Dark.png\")\r\n                }\r\n                KeyCode::F13 => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/F13_Key_Dark.png\")\r\n                }\r\n                KeyCode::F14 => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/F14_Key_Dark.png\")\r\n                }\r\n                KeyCode::F15 => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/F15_Key_Dark.png\")\r\n                }\r\n                KeyCode::F16 => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/F16_Key_Dark.png\")\r\n                }\r\n                KeyCode::F17 => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/F17_Key_Dark.png\")\r\n                }\r\n                KeyCode::F18 => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/F18_Key_Dark.png\")\r\n                }\r\n                KeyCode::F19 => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/F19_Key_Dark.png\")\r\n                }\r\n                KeyCode::F20 => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/F20_Key_Dark.png\")\r\n                }\r\n                KeyCode::F21 => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/F21_Key_Dark.png\")\r\n                }\r\n                KeyCode::F22 => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/F22_Key_Dark.png\")\r\n                }\r\n                KeyCode::F23 => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/F23_Key_Dark.png\")\r\n                }\r\n                KeyCode::F24 => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/F24_Key_Dark.png\")\r\n                }\r\n\r\n                // Alt_Key_Dark.png\r\n                KeyCode::AltLeft => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Alt_Key_Dark.png\")\r\n                }\r\n                KeyCode::AltRight => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Alt_Key_Dark.png\")\r\n                }\r\n                // Arrow_Down_Key_Dark.png\r\n                KeyCode::Down => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Down_Key_Dark.png\")\r\n                }\r\n                // Arrow_Left_Key_Dark.png\r\n                KeyCode::Left => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Left_Key_Dark.png\")\r\n                }\r\n                // Arrow_Right_Key_Dark.png\r\n                KeyCode::Right => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Right_Key_Dark.png\")\r\n                }\r\n                // Arrow_Up_Key_Dark.png\r\n                KeyCode::Up => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Up_Key_Dark.png\"),\r\n                // Asterisk_Key_Dark.png\r\n                KeyCode::Asterisk => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Asterisk_Key_Dark.png\")\r\n                }\r\n                // Backspace_Alt_Key_Dark.png\r\n                // Backspace_Key_Dark.png\r\n                // KeyCode::Back => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Backspace_Alt_Key_Dark.png\"),\r\n                KeyCode::Back => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Backspace_Key_Dark.png\")\r\n                }\r\n                // Bracket_Left_Key_Dark.png\r\n                KeyCode::BracketLeft => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Bracket_Left_Key_Dark.png\")\r\n                }\r\n                // Bracket_Right_Key_Dark.png\r\n                KeyCode::BracketRight => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Bracket_Right_Key_Dark.png\")\r\n                }\r\n                // Caps_Lock_Key_Dark.png\r\n                KeyCode::Capital => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Caps_Lock_Key_Dark.png\")\r\n                }\r\n                // Command_Key_Dark.png\r\n                KeyCode::SuperLeft => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Command_Key_Dark.png\")\r\n                }\r\n                // Ctrl_Key_Dark.png\r\n                KeyCode::ControlLeft => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Ctrl_Key_Dark.png\")\r\n                }\r\n                KeyCode::ControlRight => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Ctrl_Key_Dark.png\")\r\n                }\r\n                // Del_Key_Dark.png\r\n                KeyCode::Delete => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Del_Key_Dark.png\")\r\n                }\r\n                // End_Key_Dark.png\r\n                KeyCode::End => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/End_Key_Dark.png\")\r\n                }\r\n                // Enter_Alt_Key_Dark.png\r\n                // KeyCode::Return => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Enter_Alt_Key_Dark.png\"),\r\n                // Enter_Tall_Key_Dark.png\r\n                // KeyCode::Return => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Enter_Tall_Key_Dark.png\"),\r\n                // Enter_Key_Dark.png\r\n                KeyCode::Return => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Enter_Key_Dark.png\")\r\n                }\r\n\r\n                // Esc_Key_Dark.png\r\n                KeyCode::Escape => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Esc_Key_Dark.png\")\r\n                }\r\n                // Home_Key_Dark.png\r\n                KeyCode::Home => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Home_Key_Dark.png\")\r\n                }\r\n                // Insert_Key_Dark.png\r\n                KeyCode::Insert => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Insert_Key_Dark.png\")\r\n                }\r\n                // Mark_Left_Key_Dark.png \"<\"\r\n                // Mark_Right_Key_Dark.png \">\"\r\n                // Minus_Key_Dark.png\r\n                KeyCode::Minus => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Minus_Key_Dark.png\")\r\n                }\r\n                // Mouse_Left_Key_Dark.png\r\n                // Mouse_Middle_Key_Dark.png\r\n                // Mouse_Right_Key_Dark.png\r\n                // Mouse_Simple_Key_Dark.png\r\n                // Num_Lock_Key_Dark.png\r\n                KeyCode::Numlock => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Num_Lock_Key_Dark.png\")\r\n                }\r\n                // Page_Down_Key_Dark.png\r\n                KeyCode::PageDown => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Page_Down_Key_Dark.png\")\r\n                }\r\n                // Page_Up_Key_Dark.png\r\n                KeyCode::PageUp => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Page_Up_Key_Dark.png\")\r\n                }\r\n                // Plus_Key_Dark.png\r\n                KeyCode::Plus => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Plus_Key_Dark.png\")\r\n                }\r\n                // Plus_Tall_Key_Dark.png\r\n                KeyCode::NumpadAdd => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Plus_Tall_Key_Dark.png\")\r\n                }\r\n                // Print_Screen_Key_Dark.png\r\n                KeyCode::Snapshot => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Print_Screen_Key_Dark.png\")\r\n                }\r\n                // Question_Key_Dark.png\r\n                KeyCode::Slash => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Question_Key_Dark.png\")\r\n                }\r\n                // Quote_Key_Dark.png\r\n                KeyCode::Apostrophe => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Quote_Key_Dark.png\")\r\n                }\r\n                // Semicolon_Key_Dark.png\r\n                KeyCode::Semicolon => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Semicolon_Key_Dark.png\")\r\n                }\r\n                // Shift_Alt_Key_Dark.png\r\n                KeyCode::ShiftLeft => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Shift_Alt_Key_Dark.png\")\r\n                }\r\n                // Shift_Key_Dark.png\r\n                KeyCode::ShiftRight => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Shift_Key_Dark.png\")\r\n                }\r\n                // Slash_Key_Dark.png\r\n                KeyCode::Backslash => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Slash_Key_Dark.png\")\r\n                }\r\n                // Space_Key_Dark.png\r\n                KeyCode::Space => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Space_Key_Dark.png\")\r\n                }\r\n                // Tab_Key_Dark.png\r\n                KeyCode::Tab => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Tab_Key_Dark.png\")\r\n                }\r\n                // Tilda_Key_Dark.png\r\n                KeyCode::Grave => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Tilda_Key_Dark.png\")\r\n                }\r\n                // Win_Key_Dark.png\r\n                KeyCode::SuperRight => {\r\n                    Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Win_Key_Dark.png\")\r\n                }\r\n\r\n                KeyCode::A => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/A_Key_Dark.png\"),\r\n                KeyCode::B => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/B_Key_Dark.png\"),\r\n                KeyCode::C => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/C_Key_Dark.png\"),\r\n                KeyCode::D => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/D_Key_Dark.png\"),\r\n                KeyCode::E => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/E_Key_Dark.png\"),\r\n                KeyCode::F => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/F_Key_Dark.png\"),\r\n                KeyCode::G => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/G_Key_Dark.png\"),\r\n                KeyCode::H => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/H_Key_Dark.png\"),\r\n                KeyCode::I => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/I_Key_Dark.png\"),\r\n                KeyCode::J => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/J_Key_Dark.png\"),\r\n                KeyCode::K => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/K_Key_Dark.png\"),\r\n                KeyCode::L => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/L_Key_Dark.png\"),\r\n                KeyCode::M => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/M_Key_Dark.png\"),\r\n                KeyCode::N => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/N_Key_Dark.png\"),\r\n                KeyCode::O => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/O_Key_Dark.png\"),\r\n                KeyCode::P => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/P_Key_Dark.png\"),\r\n                KeyCode::Q => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Q_Key_Dark.png\"),\r\n                KeyCode::R => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/R_Key_Dark.png\"),\r\n                KeyCode::S => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/S_Key_Dark.png\"),\r\n                KeyCode::T => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/T_Key_Dark.png\"),\r\n                KeyCode::U => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/U_Key_Dark.png\"),\r\n                KeyCode::V => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/V_Key_Dark.png\"),\r\n                KeyCode::W => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/W_Key_Dark.png\"),\r\n                KeyCode::X => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/X_Key_Dark.png\"),\r\n                KeyCode::Y => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Y_Key_Dark.png\"),\r\n                KeyCode::Z => Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Z_Key_Dark.png\"),\r\n                _ => None,\r\n            }\r\n        }\r\n        InputKind::Mouse(button) => match button {\r\n            bevy::input::mouse::MouseButton::Left => {\r\n                Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Mouse_Left_Key_Dark.png\")\r\n            }\r\n            bevy::input::mouse::MouseButton::Right => {\r\n                Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Mouse_Right_Key_Dark.png\")\r\n            }\r\n            bevy::input::mouse::MouseButton::Middle => {\r\n                Some(\"textures/xelu_prompts/Keyboard & Mouse/Dark/Mouse_Middle_Key_Dark.png\")\r\n            }\r\n            bevy::input::mouse::MouseButton::Other(_) => None,\r\n        },\r\n        InputKind::GamepadButton(button) => {\r\n            match button {\r\n                // XboxSeriesX_A.png\r\n                GamepadButtonType::South => {\r\n                    Some(\"textures/xelu_prompts/Xbox Series/XboxSeriesX_A.png\")\r\n                }\r\n                // XboxSeriesX_B.png\r\n                GamepadButtonType::East => {\r\n                    Some(\"textures/xelu_prompts/Xbox Series/XboxSeriesX_B.png\")\r\n                }\r\n                // XboxSeriesX_Diagram.png\r\n                // XboxSeriesX_Diagram_Simple.png\r\n                // XboxSeriesX_Dpad.png\r\n                // XboxSeriesX_Dpad_Down.png\r\n                GamepadButtonType::DPadDown => {\r\n                    Some(\"textures/xelu_prompts/Xbox Series/XboxSeriesX_Dpad_Down.png\")\r\n                }\r\n                // XboxSeriesX_Dpad_Left.png\r\n                GamepadButtonType::DPadLeft => {\r\n                    Some(\"textures/xelu_prompts/Xbox Series/XboxSeriesX_Dpad_Left.png\")\r\n                }\r\n                // XboxSeriesX_Dpad_Right.png\r\n                GamepadButtonType::DPadRight => {\r\n                    Some(\"textures/xelu_prompts/Xbox Series/XboxSeriesX_Dpad_Right.png\")\r\n                }\r\n                // XboxSeriesX_Dpad_Up.png\r\n                GamepadButtonType::DPadUp => {\r\n                    Some(\"textures/xelu_prompts/Xbox Series/XboxSeriesX_Dpad_Up.png\")\r\n                }\r\n                // XboxSeriesX_LB.png\r\n                GamepadButtonType::LeftTrigger => {\r\n                    Some(\"textures/xelu_prompts/Xbox Series/XboxSeriesX_LB.png\")\r\n                }\r\n                // XboxSeriesX_Left_Stick.png\r\n                // GamepadButtonType::LeftStick => Some(\"textures/xelu_prompts/Xbox Series/XboxSeriesX_Left_Stick.png\"),\r\n                // XboxSeriesX_Left_Stick_Click.png\r\n                GamepadButtonType::LeftThumb => {\r\n                    Some(\"textures/xelu_prompts/Xbox Series/XboxSeriesX_Left_Stick_Click.png\")\r\n                }\r\n                // XboxSeriesX_LT.png\r\n                GamepadButtonType::LeftTrigger2 => {\r\n                    Some(\"textures/xelu_prompts/Xbox Series/XboxSeriesX_LT.png\")\r\n                }\r\n                // XboxSeriesX_Menu.png\r\n                GamepadButtonType::Start => {\r\n                    Some(\"textures/xelu_prompts/Xbox Series/XboxSeriesX_Menu.png\")\r\n                }\r\n                // XboxSeriesX_RB.png\r\n                GamepadButtonType::RightTrigger => {\r\n                    Some(\"textures/xelu_prompts/Xbox Series/XboxSeriesX_RB.png\")\r\n                }\r\n                // XboxSeriesX_Right_Stick.png\r\n                // GamepadButtonType::RightStick => Some(\"textures/xelu_prompts/Xbox Series/XboxSeriesX_Right_Stick.png\"),\r\n                // XboxSeriesX_Right_Stick_Click.png\r\n                GamepadButtonType::RightThumb => {\r\n                    Some(\"textures/xelu_prompts/Xbox Series/XboxSeriesX_Right_Stick_Click.png\")\r\n                }\r\n                // XboxSeriesX_RT.png\r\n                GamepadButtonType::RightTrigger2 => {\r\n                    Some(\"textures/xelu_prompts/Xbox Series/XboxSeriesX_RT.png\")\r\n                }\r\n                // XboxSeriesX_Share.png\r\n                // XboxSeriesX_View.png\r\n                GamepadButtonType::Select => {\r\n                    Some(\"textures/xelu_prompts/Xbox Series/XboxSeriesX_View.png\")\r\n                }\r\n                // XboxSeriesX_X.png\r\n                GamepadButtonType::West => {\r\n                    Some(\"textures/xelu_prompts/Xbox Series/XboxSeriesX_X.png\")\r\n                }\r\n                // XboxSeriesX_Y.png\r\n                GamepadButtonType::North => {\r\n                    Some(\"textures/xelu_prompts/Xbox Series/XboxSeriesX_Y.png\")\r\n                }\r\n                _ => None,\r\n            }\r\n        }\r\n        _ => None,\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\templates\\patterns\\new_tool\\crates\\{{crate_name}}_tool\\src\\{{crate_name}}_tool_tick_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse cursor_hero_{{crate_name_pascal}}_tool_types::prelude::*;\r\nuse cursor_hero_toolbelt_types::prelude::*;\r\nuse leafwing_input_manager::prelude::*;\r\n\r\npub struct {{crate_name_pascal}}ToolTickPlugin;\r\n\r\nimpl Plugin for {{crate_name_pascal}}ToolTickPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_plugins(InputManagerPlugin::<{{crate_name_pascal}}ToolAction>::default());\r\n        app.add_systems(Update, tick);\r\n    }\r\n}\r\n\r\nfn tick(\r\n    tool_query: Query<(&ActionState<{{crate_name_pascal}}ToolAction>, &{{crate_name_pascal}}Tool), With<ActiveTool>>,\r\n) {\r\n    for tool in tool_query.iter() {\r\n        let (tool_actions, tool) = tool;\r\n        if !tool_actions.pressed({{crate_name_pascal}}ToolAction::Use) {\r\n            continue;\r\n        }\r\n        info!(\"{{crate_name_pascal}}Tool used!\");\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\bevy\\src\\translate.rs\r\n\r\n````rust\r\nuse bevy::math::IRect;\r\nuse bevy::math::IVec2;\r\nuse bevy::math::IVec3;\r\nuse bevy::math::Rect;\r\nuse bevy::math::Vec2;\r\nuse bevy::math::Vec3;\r\n\r\npub trait TranslateVec2 {\r\n    fn translate(&self, translation: &Vec2) -> Self;\r\n}\r\npub trait TranslateIVec2 {\r\n    fn translate(&self, translation: &IVec2) -> Self;\r\n}\r\npub trait TranslateVec3 {\r\n    fn translate(&self, translation: &Vec3) -> Self;\r\n}\r\npub trait TranslateIVec3 {\r\n    fn translate(&self, translation: &IVec3) -> Self;\r\n}\r\n\r\nimpl TranslateVec2 for Rect {\r\n    fn translate(&self, translation: &Vec2) -> Rect {\r\n        Rect {\r\n            min: self.min + *translation,\r\n            max: self.max + *translation,\r\n        }\r\n    }\r\n}\r\nimpl TranslateIVec2 for IRect {\r\n    fn translate(&self, translation: &IVec2) -> IRect {\r\n        IRect {\r\n            min: self.min + *translation,\r\n            max: self.max + *translation,\r\n        }\r\n    }\r\n}\r\n\r\nimpl TranslateVec2 for Vec2 {\r\n    fn translate(&self, translation: &Vec2) -> Vec2 {\r\n        *self + *translation\r\n    }\r\n}\r\nimpl TranslateIVec2 for IVec2 {\r\n    fn translate(&self, translation: &IVec2) -> IVec2 {\r\n        *self + *translation\r\n    }\r\n}\r\n\r\nimpl TranslateVec3 for Vec3 {\r\n    fn translate(&self, translation: &Vec3) -> Vec3 {\r\n        *self + *translation\r\n    }\r\n}\r\nimpl TranslateIVec3 for IVec3 {\r\n    fn translate(&self, translation: &IVec3) -> IVec3 {\r\n        *self + *translation\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\input\\src\\active_input_state_plugin.rs\r\n\r\n````rust\r\nuse bevy::input::gamepad::GamepadEvent;\r\nuse bevy::input::keyboard::KeyboardInput;\r\nuse bevy::prelude::*;\r\nuse cursor_hero_host_event_types::prelude::HostEvent;\r\nuse cursor_hero_pointer_types::pointer_action_types::PointerAction;\r\nuse cursor_hero_pointer_types::pointer_types::MainPointer;\r\nuse leafwing_input_manager::action_state::ActionState;\r\n\r\npub struct ActiveInputStatePlugin;\r\n\r\nimpl Plugin for ActiveInputStatePlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_state::<InputMethod>();\r\n        app.insert_resource(InputMethod::MouseAndKeyboard);\r\n        app.add_systems(Update, update_input_method);\r\n    }\r\n}\r\n\r\n#[derive(Resource, Reflect, Debug, Clone, Copy, Default, Eq, PartialEq, Hash, States)]\r\n#[reflect(Resource)]\r\npub enum InputMethod {\r\n    #[default]\r\n    MouseAndKeyboard,\r\n    Keyboard,\r\n    Gamepad,\r\n}\r\n\r\nfn update_input_method(\r\n    current_state: Res<State<InputMethod>>,\r\n    mut next_state: ResMut<NextState<InputMethod>>,\r\n    mut gamepad_events: EventReader<GamepadEvent>,\r\n    mut host_events: EventReader<HostEvent>,\r\n    mut keyboard_events: EventReader<KeyboardInput>,\r\n    pointer_actions: Query<&ActionState<PointerAction>, With<MainPointer>>,\r\n) {\r\n    let current_input_method = *current_state.get();\r\n    let keyboard_used = keyboard_events.read().count() > 0;\r\n    let gamepad_used = gamepad_events\r\n        .read()\r\n        .filter(|e| match e {\r\n            GamepadEvent::Button(_) => true,\r\n            GamepadEvent::Axis(ax) => ax.value != 0.0,\r\n            _ => false,\r\n        })\r\n        .count()\r\n        > 0;\r\n    let mouse_used = host_events\r\n        .read()\r\n        .filter(|e| **e == HostEvent::MousePhysicallyMoved)\r\n        .count()\r\n        > 0;\r\n    let pointer_moved = pointer_actions.iter().any(|a| {\r\n        a.axis_pair(PointerAction::Move)\r\n            .map(|xy| !xy.x().is_nan() && !xy.y().is_nan() && xy.xy() != Vec2::ZERO)\r\n            .unwrap_or(false)\r\n    });\r\n\r\n    #[derive(Debug)]\r\n    struct DecisionInfo {\r\n        current_input_method: InputMethod,\r\n        keyboard_used: bool,\r\n        gamepad_used: bool,\r\n        mouse_used: bool,\r\n        pointer_moved: bool,\r\n    }\r\n    let decision_info = DecisionInfo {\r\n        current_input_method,\r\n        keyboard_used,\r\n        gamepad_used,\r\n        mouse_used,\r\n        pointer_moved,\r\n    };\r\n    let proposed_state = match decision_info {\r\n        DecisionInfo {\r\n            gamepad_used: true, ..\r\n        } => InputMethod::Gamepad,\r\n        DecisionInfo {\r\n            current_input_method: InputMethod::MouseAndKeyboard,\r\n            pointer_moved: true,\r\n            ..\r\n        } => InputMethod::Keyboard,\r\n        DecisionInfo {\r\n            mouse_used: true, ..\r\n        }\r\n        | DecisionInfo {\r\n            current_input_method: InputMethod::Gamepad,\r\n            keyboard_used: true,\r\n            ..\r\n        } => InputMethod::MouseAndKeyboard,\r\n        DecisionInfo {\r\n            current_input_method,\r\n            ..\r\n        } => current_input_method,\r\n    };\r\n    if proposed_state != current_input_method {\r\n        next_state.set(proposed_state);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\screen\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_screen\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\ncursor_hero_metrics = { workspace = true }\r\ncursor_hero_bevy = { workspace = true }\r\ncursor_hero_environment_types = { workspace = true }\r\ncursor_hero_level_bounds = { workspace = true }\r\ncursor_hero_winutils = { workspace = true}\r\nbevy = { workspace = true }\r\nbevy-inspector-egui = { workspace = true }\r\nbevy_xpbd_2d = { workspace = true }\r\nimage = { workspace = true}\r\nscreenshots = { workspace = true}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\pointer_types\\src\\pointer_click_types.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n\r\n#[derive(Component, Reflect, Debug)]\r\npub struct Clickable;\r\n\r\n#[derive(Reflect, Debug)]\r\npub struct PointerPress {\r\n    pub pointer_id: Entity,\r\n    pub way: Way,\r\n}\r\n#[derive(Component, Reflect, Debug)]\r\npub struct Pressed {\r\n    pub presses: Vec<PointerPress>,\r\n}\r\n\r\n#[derive(Reflect, Debug, Hash, PartialEq, Eq, Copy, Clone)]\r\npub struct TargetPress {\r\n    pub target_id: Entity,\r\n    pub way: Way,\r\n}\r\n#[derive(Component, Reflect, Debug)]\r\npub struct Pressing {\r\n    pub pressing: Vec<TargetPress>,\r\n}\r\n\r\n#[derive(Reflect, Debug, Clone, Copy, Eq, PartialEq, Hash)]\r\npub enum Way {\r\n    Left,\r\n    Right,\r\n    Middle,\r\n}\r\n\r\n#[derive(Event, Debug, Reflect)]\r\npub enum ClickEvent {\r\n    Pressed {\r\n        target_id: Entity,\r\n        pointer_id: Entity,\r\n        way: Way,\r\n    },\r\n    Released {\r\n        target_id: Entity,\r\n        pointer_id: Entity,\r\n        way: Way,\r\n    },\r\n    Clicked {\r\n        target_id: Entity,\r\n        pointer_id: Entity,\r\n        way: Way,\r\n    },\r\n}\r\n#[derive(Event, Debug, Reflect)]\r\npub enum ToolClickEvent {\r\n    Pressed { pointer_id: Entity, way: Way },\r\n    Released { pointer_id: Entity, way: Way },\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ollama\\src\\lib.rs\r\n\r\n````rust\r\npub mod ollama;\r\npub mod ollama_button_plugin;\r\npub mod ollama_inference_plugin;\r\npub mod ollama_plugin;\r\npub mod ollama_status_plugin;\r\npub mod ollama_status_worker_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::ollama_plugin::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\sprint_tool_types\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_sprint_tool_types\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\nbevy-inspector-egui = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui_automation\\examples\\ui_hover_example.rs\r\n\r\n````rust\r\n#![feature(let_chains, trivial_bounds)]\r\nuse anyhow::Context;\r\nuse anyhow::Error;\r\nuse anyhow::Result;\r\nuse bevy::input::common_conditions::input_toggle_active;\r\nuse bevy::log::LogPlugin;\r\nuse bevy::prelude::*;\r\nuse bevy::utils::HashMap;\r\nuse bevy::window::PrimaryWindow;\r\nuse bevy_egui::egui;\r\nuse bevy_egui::egui::Align2;\r\nuse bevy_egui::EguiContexts;\r\nuse bevy_egui::EguiSet;\r\nuse bevy_inspector_egui::quick::WorldInspectorPlugin;\r\nuse bevy_inspector_egui::reflect_inspector::InspectorUi;\r\nuse cursor_hero_memory::primary_window_memory_plugin::PrimaryWindowMemoryPlugin;\r\nuse cursor_hero_ui_automation::prelude::*;\r\nuse cursor_hero_winutils::win_mouse::get_cursor_position;\r\nuse cursor_hero_worker::prelude::Message;\r\nuse cursor_hero_worker::prelude::Sender;\r\nuse cursor_hero_worker::prelude::WorkerConfig;\r\nuse cursor_hero_worker::prelude::WorkerPlugin;\r\nuse itertools::Itertools;\r\nuse uiautomation::UIAutomation;\r\nfn main() {\r\n    let mut app = App::new();\r\n    app.add_plugins(\r\n        DefaultPlugins\r\n            .set(LogPlugin {\r\n                level: bevy::log::Level::DEBUG,\r\n                filter: \"\r\ninfo,\r\nwgpu_core=warn,\r\nwgpu_hal=warn,\r\nui_hover_example=trace,\r\ncursor_hero_worker=debug,\r\n\"\r\n                .replace('\\n', \"\")\r\n                .trim()\r\n                .into(),\r\n            })\r\n            .build(),\r\n    );\r\n    app.add_plugins(WorkerPlugin {\r\n        config: WorkerConfig::<ThreadboundUISnapshotMessage, GameboundUISnapshotMessage> {\r\n            name: \"ui_hover\".to_string(),\r\n            is_ui_automation_thread: true,\r\n            handle_threadbound_message: handle_threadbound_message,\r\n            handle_threadbound_message_error_handler: handle_threadbound_message_error_handler,\r\n            ..default()\r\n        },\r\n    });\r\n    app.add_plugins(\r\n        WorldInspectorPlugin::default().run_if(input_toggle_active(false, KeyCode::Grave)),\r\n    );\r\n    app.add_plugins(PrimaryWindowMemoryPlugin);\r\n    app.insert_resource(ClearColor(Color::rgb(0.992, 0.714, 0.69)));\r\n    app.add_systems(Startup, spawn_camera);\r\n    app.add_systems(Update, periodic_snapshot);\r\n    app.add_systems(Update, fetch_requested);\r\n    app.add_systems(Update, receive);\r\n    app.add_systems(Update, gui.after(EguiSet::InitContexts));\r\n    app.init_resource::<UIData>();\r\n    app.register_type::<UIData>();\r\n    app.run();\r\n}\r\n\r\nfn spawn_camera(mut commands: Commands) {\r\n    commands.spawn(Camera2dBundle::default());\r\n}\r\n\r\n#[derive(Debug, Reflect, Clone, Event)]\r\nenum ThreadboundUISnapshotMessage {\r\n    CaptureHovered,\r\n    ChildrenFetchRequest {\r\n        drill_id: DrillId,\r\n        runtime_id: RuntimeId,\r\n    },\r\n}\r\nimpl Message for ThreadboundUISnapshotMessage {}\r\n\r\n#[derive(Debug, Reflect, Clone, Event)]\r\nenum GameboundUISnapshotMessage {\r\n    Hovered {\r\n        ui_tree: ElementInfo,\r\n        start: ElementInfo,\r\n        hovered: ElementInfo,\r\n    },\r\n    ChildrenFetchResponse {\r\n        drill_id: DrillId,\r\n        runtime_id: RuntimeId,\r\n        children: Vec<ElementInfo>,\r\n    },\r\n    Error,\r\n}\r\nimpl Message for GameboundUISnapshotMessage {}\r\n\r\n#[derive(Debug, Reflect)]\r\nenum FetchingState {\r\n    FetchRequest,\r\n    FetchDispatched,\r\n    Fetched(Vec<ElementInfo>),\r\n}\r\n\r\n#[derive(Resource, Debug, Reflect, Default)]\r\n#[reflect(Resource)]\r\nstruct UIData {\r\n    pub start: ElementInfo,\r\n    pub hovered: ElementInfo,\r\n    pub ui_tree: ElementInfo,\r\n    pub selected: Option<DrillId>,\r\n    pub expanded: Vec<DrillId>,\r\n    pub fresh: bool,\r\n    pub in_flight: bool,\r\n    pub paused: bool,\r\n    // Include runtime id in case tree changes and we quickly fetch something with the same drill_id before the first request comes back\r\n    pub fetching: HashMap<(DrillId, RuntimeId), FetchingState>,\r\n}\r\n\r\nfn handle_threadbound_message_error_handler(\r\n    _msg: &ThreadboundUISnapshotMessage,\r\n    reply_tx: &Sender<GameboundUISnapshotMessage>,\r\n    _error: &Error,\r\n) -> Result<()> {\r\n    reply_tx.send(GameboundUISnapshotMessage::Error)?;\r\n    Ok(())\r\n}\r\nfn handle_threadbound_message(\r\n    msg: &ThreadboundUISnapshotMessage,\r\n    reply_tx: &Sender<GameboundUISnapshotMessage>,\r\n) -> Result<()> {\r\n    match msg {\r\n        ThreadboundUISnapshotMessage::CaptureHovered => {\r\n            debug!(\"taking snapshot\");\r\n            let cursor_pos = get_cursor_position()?;\r\n            let hovered = find_element_at(cursor_pos)?;\r\n            let hovered_info = gather_single_element_info(&hovered)?;\r\n            let gathered = gather_incomplete_ui_tree_starting_deep(hovered)?;\r\n            if let Err(e) = reply_tx.send(GameboundUISnapshotMessage::Hovered {\r\n                ui_tree: gathered.ui_tree,\r\n                start: gathered.start_info,\r\n                hovered: hovered_info,\r\n            }) {\r\n                error!(\"Failed to send snapshot: {:?}\", e);\r\n            }\r\n        }\r\n        ThreadboundUISnapshotMessage::ChildrenFetchRequest {\r\n            drill_id,\r\n            runtime_id,\r\n        } => {\r\n            debug!(\"fetching children for {:?}\", drill_id);\r\n            let automation = UIAutomation::new().context(\"creating automation\")?;\r\n            let walker = automation.create_tree_walker().context(\"creating walker\")?;\r\n            let root = automation.get_root_element().context(\"getting root\")?;\r\n            let found = root.drill(&walker, drill_id.clone()).context(\"drilling\")?;\r\n            let mut children = found\r\n                .gather_children(&walker, &StopBehaviour::EndOfSiblings)\r\n                .into_iter()\r\n                .enumerate()\r\n                .filter_map(|(i, child)| {\r\n                    gather_single_element_info(&child)\r\n                        .ok()\r\n                        .map(|mut child_info| {\r\n                            child_info.drill_id = DrillId::Child(vec![i].into_iter().collect());\r\n                            child_info\r\n                        })\r\n                })\r\n                .collect_vec();\r\n\r\n            update_drill_ids(Some(&mut children), &drill_id);\r\n            if let Err(e) = reply_tx.send(GameboundUISnapshotMessage::ChildrenFetchResponse {\r\n                drill_id: drill_id.clone(),\r\n                runtime_id: runtime_id.clone(),\r\n                children,\r\n            }) {\r\n                error!(\"Failed to send ChildrenFetchResponse: {:?}\", e);\r\n            }\r\n        }\r\n    }\r\n    Ok(())\r\n}\r\n\r\nfn fetch_requested(\r\n    mut data: ResMut<UIData>,\r\n    mut events: EventWriter<ThreadboundUISnapshotMessage>,\r\n) {\r\n    for (key, state) in data.fetching.iter_mut() {\r\n        if let FetchingState::FetchRequest = state {\r\n            *state = FetchingState::FetchDispatched;\r\n            events.send(ThreadboundUISnapshotMessage::ChildrenFetchRequest {\r\n                drill_id: key.0.clone(),\r\n                runtime_id: key.1.clone(),\r\n            });\r\n        }\r\n    }\r\n}\r\n\r\nfn periodic_snapshot(\r\n    mut data: ResMut<UIData>,\r\n    mut cooldown: Local<Option<Timer>>,\r\n    time: Res<Time>,\r\n    mut events: EventWriter<ThreadboundUISnapshotMessage>,\r\n    window: Query<&Window, With<PrimaryWindow>>,\r\n) {\r\n    let Ok(window) = window.get_single() else {\r\n        return;\r\n    };\r\n    if window.cursor_position().is_some() {\r\n        return;\r\n    }\r\n    let cooldown_over = if let Some(cooldown) = cooldown.as_mut() {\r\n        if cooldown.tick(time.delta()).just_finished() {\r\n            cooldown.reset();\r\n            true\r\n        } else {\r\n            false\r\n        }\r\n    } else {\r\n        cooldown.replace(Timer::from_seconds(0.5, TimerMode::Repeating));\r\n        true\r\n    };\r\n    if !cooldown_over {\r\n        return;\r\n    }\r\n\r\n    if data.paused {\r\n        return;\r\n    }\r\n\r\n    if data.in_flight {\r\n        warn!(\"Too fast!\");\r\n        return;\r\n    }\r\n\r\n    events.send(ThreadboundUISnapshotMessage::CaptureHovered);\r\n    data.in_flight = true;\r\n}\r\n\r\nfn receive(mut snapshot: EventReader<GameboundUISnapshotMessage>, mut ui_data: ResMut<UIData>) {\r\n    for msg in snapshot.read() {\r\n        match msg {\r\n            GameboundUISnapshotMessage::Error => {\r\n                ui_data.in_flight = false;\r\n            }\r\n            GameboundUISnapshotMessage::Hovered {\r\n                ui_tree,\r\n                start,\r\n                hovered,\r\n            } => {\r\n                ui_data.in_flight = false;\r\n                ui_data.ui_tree = ui_tree.clone();\r\n                ui_data.start = start.clone();\r\n                ui_data.hovered = hovered.clone();\r\n                ui_data.selected = Some(start.drill_id.clone());\r\n                ui_data.expanded = ui_tree\r\n                    .get_descendents()\r\n                    .iter()\r\n                    .chain([ui_tree].iter())\r\n                    .filter(|x| x.children.is_some())\r\n                    .map(|x| x.drill_id.clone())\r\n                    .collect();\r\n                ui_data.fresh = true;\r\n                debug!(\"Received snapshot\");\r\n            }\r\n            GameboundUISnapshotMessage::ChildrenFetchResponse {\r\n                drill_id,\r\n                runtime_id,\r\n                children,\r\n            } => {\r\n                let key = (drill_id.clone(), runtime_id.clone());\r\n                if let Some(FetchingState::FetchDispatched) = ui_data.fetching.get(&key) {\r\n                    ui_data\r\n                        .fetching\r\n                        .insert(key, FetchingState::Fetched(children.clone()));\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfn gui(\r\n    mut contexts: EguiContexts,\r\n    mut ui_data: ResMut<UIData>,\r\n    type_registry: Res<AppTypeRegistry>,\r\n) {\r\n    let ctx = contexts.ctx_mut();\r\n\r\n    let mut cx = bevy_inspector_egui::reflect_inspector::Context {\r\n        world: None,\r\n        queue: None,\r\n    };\r\n\r\n    let type_registry = type_registry.0.clone();\r\n    let type_registry = type_registry.read();\r\n    let mut inspector = InspectorUi::for_bevy(&type_registry, &mut cx);\r\n\r\n    let id = egui::Id::new(\"Inspector\");\r\n    egui::Window::new(\"Inspector\")\r\n        .title_bar(false)\r\n        .id(id)\r\n        .default_pos((5.0, 5.0))\r\n        .default_width(1200.0)\r\n        .default_height(1000.0)\r\n        .show(ctx, |ui| {\r\n            egui::SidePanel::left(id.with(\"tree\"))\r\n                .resizable(true)\r\n                .width_range(100.0..=4000.0)\r\n                .default_width(600.0)\r\n                .show_inside(ui, |ui| {\r\n                    ui.vertical_centered(|ui| {\r\n                        ui.heading(\"UI Tree\");\r\n                    });\r\n                    egui::ScrollArea::both().show(ui, |ui| {\r\n                        let id = id.with(ui_data.ui_tree.runtime_id.clone());\r\n                        let mut elem = ui_data.ui_tree.clone();\r\n                        ui_for_element_info(id, ui, &mut ui_data, &mut elem, &mut inspector);\r\n                        ui_data.ui_tree = elem;\r\n                        ui.allocate_space(ui.available_size());\r\n                    });\r\n                });\r\n\r\n            egui::TopBottomPanel::bottom(id.with(\"invisible bottom panel\"))\r\n                .show_separator_line(false)\r\n                .show_inside(ui, |_| ());\r\n\r\n            egui::CentralPanel::default().show_inside(ui, |ui| {\r\n                ui.vertical_centered(|ui| {\r\n                    ui.heading(\"Properties\");\r\n                });\r\n                let id = ui_data.selected.clone();\r\n                if let Some(id) = id\r\n                    && let Some(x) = ui_data.ui_tree.lookup_drill_id_mut(id)\r\n                {\r\n                    inspector.ui_for_reflect_readonly(x, ui);\r\n                    ui.separator();\r\n                    ui.label(\"drill_id\");\r\n                    let drill_id = x.drill_id.to_string();\r\n                    inspector.ui_for_reflect_readonly(&drill_id, ui);\r\n                    if ui.button(\"copy\").clicked() {\r\n                        ui.output_mut(|out| {\r\n                            out.copied_text = drill_id.clone();\r\n                        });\r\n                        info!(\"Copied drill_id {} to clipboard\", drill_id);\r\n                    }\r\n                    ui.label(\"runtime_id\");\r\n                    let runtime_id = x.runtime_id.to_string();\r\n                    inspector.ui_for_reflect_readonly(&runtime_id, ui);\r\n                    if ui.button(\"copy\").clicked() {\r\n                        ui.output_mut(|out| {\r\n                            out.copied_text = runtime_id.clone();\r\n                        });\r\n                        info!(\"Copied runtime_id {} to clipboard\", runtime_id);\r\n                    }\r\n                }\r\n                // inspector.ui_for_reflect_readonly(&data, ui);\r\n            });\r\n        });\r\n\r\n    let id = egui::Id::new(\"Paused\");\r\n    egui::Window::new(\"Paused\")\r\n        .id(id)\r\n        .title_bar(false)\r\n        .anchor(Align2::RIGHT_TOP, (5.0, 5.0))\r\n        .show(ctx, |ui| {\r\n            ui.checkbox(&mut ui_data.paused, \"Paused\");\r\n        });\r\n    ui_data.fresh = false;\r\n}\r\n\r\n#[allow(clippy::too_many_arguments)]\r\nfn ui_for_element_info(\r\n    id: egui::Id,\r\n    ui: &mut egui::Ui,\r\n    data: &mut UIData,\r\n    element_info: &mut ElementInfo,\r\n    _inspector: &mut InspectorUi,\r\n) {\r\n    let default_open = data.expanded.contains(&element_info.drill_id);\r\n    let mut expando = egui::collapsing_header::CollapsingState::load_with_default_open(\r\n        ui.ctx(),\r\n        id,\r\n        default_open,\r\n    );\r\n    if data.fresh {\r\n        expando.set_open(default_open);\r\n        data.fetching.clear();\r\n    }\r\n    if expando.is_open() && element_info.children.is_none() {\r\n        let key = (\r\n            element_info.drill_id.clone(),\r\n            element_info.runtime_id.clone(),\r\n        );\r\n        let found = data.fetching.get_mut(&key);\r\n        if !found.is_some() {\r\n            data.fetching.insert(key, FetchingState::FetchRequest);\r\n        } else if let Some(FetchingState::Fetched(ref mut children)) = found {\r\n            element_info.children = Some(std::mem::take(children));\r\n            data.fetching.remove(&key);\r\n        } else {\r\n            ui.label(\"fetching...\");\r\n        }\r\n    }\r\n    expando\r\n        .show_header(ui, |ui| {\r\n            let mut selected = data.selected == Some(element_info.drill_id.clone());\r\n            if selected && data.fresh {\r\n                ui.scroll_to_cursor(Some(egui::Align::Center));\r\n            }\r\n            let label = if element_info.automation_id.is_empty() {\r\n                format!(\r\n                    \"{:?} | {}\",\r\n                    element_info.name, element_info.localized_control_type\r\n                )\r\n            } else {\r\n                format!(\r\n                    \"{:?} | {} | {}\",\r\n                    element_info.name,\r\n                    element_info.localized_control_type,\r\n                    element_info.automation_id\r\n                )\r\n            };\r\n            if ui.toggle_value(&mut selected, label).changed() {\r\n                data.selected = if selected {\r\n                    Some(element_info.drill_id.clone())\r\n                } else {\r\n                    None\r\n                };\r\n            };\r\n        })\r\n        .body(|ui| {\r\n            if let Some(ref mut children) = element_info.children {\r\n                for child in children.iter_mut() {\r\n                    ui_for_element_info(\r\n                        id.with(child.runtime_id.clone()),\r\n                        ui,\r\n                        data,\r\n                        child,\r\n                        _inspector,\r\n                    );\r\n                }\r\n            }\r\n        });\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\winutils\\examples\\win_events_example.rs\r\n\r\n````rust\r\nuse cursor_hero_winutils::win_events::create_os_event_listener;\r\nuse cursor_hero_winutils::win_events::ProcMessage;\r\n\r\nfn main() {\r\n    let args: Vec<String> = std::env::args().collect();\r\n    if args.len() != 2 {\r\n        eprintln!(\"Usage: <command> [all|events|mouse|keyboard]\");\r\n        std::process::exit(1);\r\n    }\r\n\r\n    let result = match args[1].as_str() {\r\n        \"all\" => listen_all(),\r\n        \"events\" => listen_events(),\r\n        \"mouse\" => listen_mouse(),\r\n        \"keyboard\" => listen_keyboard(),\r\n        _ => {\r\n            eprintln!(\"Invalid argument: choose from [all|events|mouse|keyboard]\");\r\n            std::process::exit(1);\r\n        }\r\n    };\r\n\r\n    if let Err(e) = result {\r\n        eprintln!(\"Error occurred: {:?}\", e);\r\n        std::process::exit(1);\r\n    }\r\n}\r\n\r\npub fn listen_all() -> Result<(), windows::core::Error> {\r\n    let rx = create_os_event_listener()?;\r\n    while let Ok(msg) = rx.recv() {\r\n        println!(\"Received message: {:?}\", msg);\r\n    }\r\n    Ok(())\r\n}\r\n\r\npub fn listen_events() -> Result<(), windows::core::Error> {\r\n    let rx = create_os_event_listener()?;\r\n    while let Ok(msg) = rx.recv() {\r\n        if !matches!(msg, ProcMessage::Event { .. }) {\r\n            continue;\r\n        }\r\n        println!(\"Received message: {:?}\", msg);\r\n    }\r\n    Ok(())\r\n}\r\n\r\npub fn listen_mouse() -> Result<(), windows::core::Error> {\r\n    let rx = create_os_event_listener()?;\r\n    while let Ok(msg) = rx.recv() {\r\n        if !matches!(msg, ProcMessage::MouseMoved { .. }) {\r\n            continue;\r\n        }\r\n        println!(\"Received message: {:?}\", msg);\r\n    }\r\n    Ok(())\r\n}\r\n\r\npub fn listen_keyboard() -> Result<(), windows::core::Error> {\r\n    let rx = create_os_event_listener()?;\r\n    while let Ok(msg) = rx.recv() {\r\n        if !matches!(msg, ProcMessage::KeyDown { .. }) {\r\n            continue;\r\n        }\r\n        println!(\"Received message: {:?}\", msg);\r\n    }\r\n    Ok(())\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\chat\\src\\chat_plugin.rs\r\n\r\n````rust\r\nuse crate::chat_bubble_plugin::ChatBubblePlugin;\r\nuse crate::chat_focus_exclusivity_plugin::ChatFocusExclusivityPlugin;\r\nuse crate::chat_input_buffer_plugin::ChatInputBufferPlugin;\r\nuse crate::chat_sfx_plugin::ChatSfxPlugin;\r\nuse crate::chat_tool_plugin::ChatToolPlugin;\r\nuse bevy::prelude::*;\r\npub struct ChatPlugin;\r\n\r\nimpl Plugin for ChatPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_plugins(ChatToolPlugin);\r\n        app.add_plugins(ChatFocusExclusivityPlugin);\r\n        app.add_plugins(ChatBubblePlugin);\r\n        app.add_plugins(ChatInputBufferPlugin);\r\n        app.add_plugins(ChatSfxPlugin);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\level_bounds\\src\\level_bounds_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse bevy_xpbd_2d::components::Collider;\r\nuse bevy_xpbd_2d::components::CollidingEntities;\r\nuse bevy_xpbd_2d::components::LinearVelocity;\r\n\r\nuse bevy_xpbd_2d::components::RigidBody;\r\nuse bevy_xpbd_2d::components::Sensor;\r\nuse cursor_hero_character_types::prelude::*;\r\nuse cursor_hero_environment_types::prelude::*;\r\n\r\npub struct LevelBoundsPlugin;\r\n\r\nimpl Plugin for LevelBoundsPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<LevelBounds>();\r\n        app.register_type::<LevelBoundsHolder>();\r\n        app.register_type::<LevelBoundsParentRef>();\r\n        app.add_event::<LevelBoundsEvent>();\r\n        app.add_systems(Update, enforce);\r\n        app.add_systems(\r\n            Update,\r\n            (\r\n                handle_populate_environment_events,\r\n                apply_deferred,\r\n                handle_level_bounds_events,\r\n            )\r\n                .chain(),\r\n        );\r\n    }\r\n}\r\n\r\n#[derive(Event, Reflect, Debug, Clone, Copy)]\r\npub enum LevelBoundsEvent {\r\n    AddPlayArea { environment_id: Entity, area: Rect },\r\n}\r\n\r\n#[derive(Component, Reflect)]\r\npub struct LevelBoundsHolder;\r\n#[derive(Component, Reflect)]\r\npub struct LevelBoundsParentRef(Entity);\r\nimpl LevelBoundsParentRef {\r\n    pub fn get(&self) -> Entity {\r\n        self.0\r\n    }\r\n}\r\n#[derive(Component, Reflect)]\r\npub struct LevelBounds;\r\n\r\n#[allow(clippy::type_complexity)]\r\nfn handle_populate_environment_events(\r\n    mut commands: Commands,\r\n    mut events: EventReader<PopulateEnvironmentEvent>,\r\n    environment_query: Query<(), Or<(With<HostEnvironment>, With<GameEnvironment>)>>,\r\n) {\r\n    for event in events.read() {\r\n        if !environment_query.contains(event.environment_id) {\r\n            continue;\r\n        }\r\n\r\n        info!(\r\n            \"Populating environment {:?} with level bounds parent\",\r\n            event\r\n        );\r\n        let mut level_bounds_holder_id = None;\r\n        commands\r\n            .entity(event.environment_id)\r\n            .with_children(|parent| {\r\n                level_bounds_holder_id = Some(\r\n                    parent\r\n                        .spawn((\r\n                            SpatialBundle::default(),\r\n                            LevelBoundsHolder,\r\n                            Name::new(\"Level Bounds\"),\r\n                        ))\r\n                        .id(),\r\n                );\r\n            });\r\n        let Some(level_bounds_holder_id) = level_bounds_holder_id else {\r\n            warn!(\r\n                \"Failed to create level bounds holder for environment {:?}\",\r\n                event\r\n            );\r\n            continue;\r\n        };\r\n        commands\r\n            .entity(event.environment_id)\r\n            .insert(LevelBoundsParentRef(level_bounds_holder_id));\r\n    }\r\n}\r\n\r\npub fn handle_level_bounds_events(\r\n    mut events: EventReader<LevelBoundsEvent>,\r\n    environment_query: Query<&LevelBoundsParentRef, With<EnvironmentKind>>,\r\n    mut commands: Commands,\r\n    mut deferred: Local<Vec<LevelBoundsEvent>>,\r\n) {\r\n    let mut new_deferred = Vec::new();\r\n    for event in events.read().chain(deferred.into_iter()) {\r\n        match event {\r\n            LevelBoundsEvent::AddPlayArea {\r\n                environment_id,\r\n                area,\r\n            } => {\r\n                if let Ok(level_bounds_parent_ref) = environment_query.get(*environment_id) {\r\n                    info!(\r\n                        \"Adding play area with size {:?} to level bounds for environment {:?}\",\r\n                        area.size(),\r\n                        environment_id\r\n                    );\r\n                    commands\r\n                        .entity(level_bounds_parent_ref.get())\r\n                        .with_children(|parent| {\r\n                            parent.spawn((\r\n                                SpriteBundle {\r\n                                    sprite: Sprite {\r\n                                        custom_size: Some(area.size()),\r\n                                        color: Color::ORANGE,\r\n                                        ..default()\r\n                                    },\r\n                                    transform: Transform::from_translation(\r\n                                        area.center().extend(-2.0),\r\n                                    ),\r\n                                    visibility: Visibility::Hidden,\r\n                                    ..default()\r\n                                },\r\n                                Sensor,\r\n                                RigidBody::Static,\r\n                                Collider::cuboid(area.size().x, area.size().y),\r\n                                LevelBounds,\r\n                                Name::new(\"Level Bounds\"),\r\n                            ));\r\n                        });\r\n                } else {\r\n                    debug!(\r\n                        \"Deferring level bounds event for environment {:?}\",\r\n                        environment_id\r\n                    );\r\n                    new_deferred.push(*event);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    *deferred = new_deferred;\r\n}\r\n\r\n#[allow(clippy::type_complexity)]\r\nfn enforce(\r\n    mut character_query: Query<\r\n        (Entity, &GlobalTransform, &mut LinearVelocity),\r\n        (With<Character>, Without<LevelBounds>),\r\n    >,\r\n    level_bounds: Query<\r\n        (&GlobalTransform, &CollidingEntities),\r\n        (With<LevelBounds>, Without<Character>),\r\n    >,\r\n) {\r\n    for (character_entity, character_transform, mut character_velocity) in\r\n        character_query.iter_mut()\r\n    {\r\n        let mut is_in_bounds = false;\r\n        for (_, in_bounds) in level_bounds.iter() {\r\n            if in_bounds.contains(&character_entity) {\r\n                is_in_bounds = true;\r\n                break;\r\n            }\r\n        }\r\n        if !is_in_bounds {\r\n            // debug!(\"Found {} level bounds\", level_bounds.iter().count());\r\n            // apply a force to to the character in the direction of the nearest boundary\r\n            let mut nearest_boundary = None;\r\n            let mut nearest_boundary_distance = f32::MAX;\r\n            for (bounds_transform, _) in level_bounds.iter() {\r\n                let distance = character_transform\r\n                    .translation()\r\n                    .distance(bounds_transform.translation());\r\n                // debug!(\"Distance to boundary: {}\", distance);\r\n                if distance < nearest_boundary_distance {\r\n                    nearest_boundary_distance = distance;\r\n                    nearest_boundary = Some(bounds_transform.translation());\r\n                }\r\n            }\r\n            if let Some(nearest_boundary) = nearest_boundary {\r\n                let direction = nearest_boundary - character_transform.translation();\r\n                character_velocity.0 +=\r\n                    direction.normalize().xy() * direction.length_squared() / 1000.0;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\screen\\src\\get_image.rs\r\n\r\n````rust\r\nuse bevy::ecs::system::SystemParam;\r\nuse bevy::prelude::*;\r\nuse image::DynamicImage;\r\nuse image::RgbImage;\r\n\r\nuse crate::screen_plugin::Screen;\r\n\r\npub enum GetImageError {\r\n    ElementEmpty,\r\n}\r\n\r\n#[derive(SystemParam)]\r\npub struct ScreensToImageParam<'w, 's> {\r\n    pub images: Res<'w, Assets<Image>>,\r\n    pub screens: Query<'w, 's, (&'static Handle<Image>, &'static GlobalTransform), With<Screen>>,\r\n}\r\n\r\npub fn get_image(\r\n    bounds: IRect,\r\n    screen_access: &ScreensToImageParam,\r\n) -> Result<Image, GetImageError> {\r\n    if bounds.is_empty() {\r\n        return Err(GetImageError::ElementEmpty);\r\n    }\r\n    let mut tex = RgbImage::new(bounds.width() as u32, bounds.height() as u32);\r\n\r\n    // find out what parts of each screen are intersecting with the element\r\n    for (screen_image_handle, screen_trans) in screen_access.screens.iter() {\r\n        // find out the image size\r\n        let screen_center_pos = screen_trans.translation();\r\n        match screen_access.images.get(screen_image_handle) {\r\n            None => {}\r\n            Some(screen_image) => {\r\n                // Calculate the overlapping area\r\n                let screen_size = screen_image.texture_descriptor.size;\r\n                let mut screen_origin = screen_center_pos.xy();\r\n                screen_origin.y *= -1.0;\r\n                let screen_rect = Rect::from_center_size(\r\n                    screen_origin,\r\n                    Vec2::new(screen_size.width as f32, screen_size.height as f32),\r\n                );\r\n\r\n                // find the overlap\r\n                // debug!(\"screen_rect: {:?}\", screen_rect);\r\n                let intersection = screen_rect.intersect(bounds.as_rect());\r\n                // debug!(\"intersection rect: {:?}\", intersection);\r\n\r\n                // convert to monitor coordinates\r\n                let origin = intersection.center() - screen_rect.min.xy();\r\n                let tex_grab_rect = Rect::from_center_size(origin, intersection.size());\r\n                // debug!(\"tex_grab_rect: {:?}\", tex_grab_rect);\r\n\r\n                if !tex_grab_rect.is_empty() {\r\n                    // debug!(\r\n                    //     \"Copying pixel range {} by {}\",\r\n                    //     tex_grab_rect.size().x,\r\n                    //     tex_grab_rect.size().y\r\n                    // );\r\n\r\n                    // Calculate where to start placing pixels in the element's texture\r\n                    let texture_start_x = (intersection.min.x - bounds.min.x as f32) as u32;\r\n                    let texture_start_y = (intersection.min.y - bounds.min.y as f32) as u32;\r\n                    // debug!(\"Texture start: {} {}\", texture_start_x, texture_start_y);\r\n                    // Copy the overlapping part of the screen texture to the element's texture.\r\n                    for y in tex_grab_rect.min.y as usize..tex_grab_rect.max.y as usize {\r\n                        for x in tex_grab_rect.min.x as usize..tex_grab_rect.max.x as usize {\r\n                            let start = (y * screen_size.width as usize + x) * 4;\r\n                            if start + 4 <= screen_image.data.len() {\r\n                                let pixel: [u8; 3] = [\r\n                                    screen_image.data[start],\r\n                                    screen_image.data[start + 1],\r\n                                    screen_image.data[start + 2],\r\n                                    // screen_image.data[start + 3],\r\n                                ];\r\n                                tex.put_pixel(\r\n                                    texture_start_x + x as u32 - tex_grab_rect.min.x as u32,\r\n                                    texture_start_y + y as u32 - tex_grab_rect.min.y as u32,\r\n                                    image::Rgb(pixel),\r\n                                );\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    let dynamic_image = DynamicImage::ImageRgb8(tex);\r\n    let image = Image::from_dynamic(dynamic_image, true);\r\n    Ok(image)\r\n    // let texture_handle = images.add(image);\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\secret_types\\src\\lib.rs\r\n\r\n````rust\r\npub mod secrets_types;\r\npub mod secrets_types_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::secrets_types::*;\r\n    pub use crate::secrets_types_plugin::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui_automation\\src\\resolve_calculator.rs\r\n\r\n````rust\r\nuse anyhow::Result;\r\nuse cursor_hero_ui_automation_types::prelude::*;\r\nuse uiautomation::UIAutomation;\r\nuse uiautomation::UIElement;\r\npub(crate) fn resolve_calculator(\r\n    elem: &UIElement,\r\n    automation: &UIAutomation,\r\n    _focused: bool,\r\n) -> Result<AppWindow> {\r\n    let walker = automation.create_tree_walker()?;\r\n    let root = elem;\r\n\r\n    let group = root.drill(&walker, vec![1, 2, 1])?;\r\n    let expression = group\r\n        .drill(&walker, vec![0])?\r\n        .get_name()?\r\n        .strip_prefix(\"Expression is \")\r\n        .unwrap_or_default()\r\n        .to_string();\r\n    let display = group.drill(&walker, vec![1, 0])?.get_name()?;\r\n\r\n    Ok(AppWindow::Calculator(CalculatorState {\r\n        expression,\r\n        display,\r\n    }))\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\templates\\patterns\\new_tool\\crates\\plugins\\src\\lib.rs\r\n\r\n````rust\r\n{{use_statements}}\r\nuse cursor_hero_{{crate_name}}_tool::prelude::*;\r\nuse cursor_hero_{{crate_name}}_tool_types::prelude::*;\r\n{{plugin_start}}\r\n        app.add_plugins({{crate_name_pascal}}ToolPlugin);\r\n        app.add_plugins({{crate_name_pascal}}ToolTypesPlugin);\r\n        {{plugin_remaining}}\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ollama_types\\src\\ollama_types.rs\r\n\r\n````rust\r\nuse std::time::Duration;\r\n\r\nuse bevy::prelude::*;\r\nuse bevy::utils::Instant;\r\n\r\n#[derive(Reflect, Resource, Default, Debug, Eq, PartialEq, Clone, Copy)]\r\n#[reflect(Resource)]\r\npub enum OllamaStatus {\r\n    #[default]\r\n    Unknown,\r\n    Alive,\r\n    Dead,\r\n    Starting {\r\n        instant: Instant,\r\n        timeout: Duration,\r\n    },\r\n}\r\n\r\n#[derive(Component, Debug, Reflect, Default)]\r\npub struct OllamaStatusButton {\r\n    pub visual_state: OllamaStatusButtonVisualState,\r\n}\r\n\r\n#[derive(Debug, Reflect, Eq, PartialEq)]\r\npub enum OllamaStatusButtonVisualState {\r\n    Default { status: OllamaStatus },\r\n    Hovered { status: OllamaStatus },\r\n    Pressed { status: OllamaStatus },\r\n}\r\nimpl Default for OllamaStatusButtonVisualState {\r\n    fn default() -> Self {\r\n        OllamaStatusButtonVisualState::Default {\r\n            status: OllamaStatus::Unknown,\r\n        }\r\n    }\r\n}\r\n\r\n#[derive(Event, Debug, Reflect)]\r\npub enum OllamaPingEvent {\r\n    Ping,\r\n    Pong { status: OllamaStatus },\r\n}\r\n\r\n#[derive(Event, Debug, Reflect)]\r\npub enum OllamaStatusEvent {\r\n    Changed { new_value: OllamaStatus },\r\n    Startup,\r\n}\r\n\r\n#[derive(Component, Debug, Reflect, Default)]\r\npub struct OllamaTerminalButton {\r\n    pub visual_state: OllamaTerminalButtonVisualState,\r\n}\r\n#[derive(Debug, Reflect, Eq, PartialEq, Default)]\r\npub enum OllamaTerminalButtonVisualState {\r\n    #[default]\r\n    Default,\r\n}\r\n#[derive(Event, Debug, Reflect)]\r\npub enum OllamaTerminalEvent {\r\n    Startup,\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\start_menu_types\\src\\lib.rs\r\n\r\n````rust\r\npub mod start_menu_types;\r\npub mod start_menu_types_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::start_menu_types::*;\r\n    pub use crate::start_menu_types_plugin::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\voice_to_text\\src\\voice_to_text_worker_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse crossbeam_channel::bounded;\r\nuse crossbeam_channel::Receiver;\r\nuse crossbeam_channel::Sender;\r\nuse cursor_hero_secret_types::secrets_types::SecretString;\r\nuse cursor_hero_voice_to_text_types::prelude::*;\r\nuse std::thread;\r\nuse std::time::Duration;\r\nuse std::time::Instant;\r\n\r\npub struct VoiceToTextWorkerPlugin;\r\n\r\nimpl Plugin for VoiceToTextWorkerPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Startup, create_worker_thread);\r\n        app.add_systems(Update, events_to_bridge);\r\n        app.add_systems(Update, bridge_to_events);\r\n    }\r\n}\r\n\r\n#[derive(Debug)]\r\npub(crate) enum GameboundMessage {\r\n    Pong { status: VoiceToTextStatus },\r\n    Starting { api_key: SecretString },\r\n    TranscriptionReceived { transcription: String },\r\n}\r\n\r\n#[derive(Debug)]\r\nenum ThreadboundMessage {\r\n    Ping,\r\n    Startup,\r\n    SetListening {\r\n        listening: bool,\r\n        api_key: SecretString,\r\n    },\r\n    ConnectReceiver {\r\n        api_key: SecretString,\r\n    },\r\n}\r\n\r\n#[derive(Resource)]\r\nstruct Bridge {\r\n    pub sender: Sender<ThreadboundMessage>,\r\n    pub receiver: Receiver<GameboundMessage>,\r\n}\r\n\r\nfn create_worker_thread(mut commands: Commands) {\r\n    let (game_tx, game_rx) = bounded::<_>(10);\r\n    let (thread_tx, thread_rx) = bounded::<_>(10);\r\n    commands.insert_resource(Bridge {\r\n        sender: thread_tx,\r\n        receiver: game_rx,\r\n    });\r\n\r\n    let game_tx_clone = game_tx.clone();\r\n    thread::Builder::new()\r\n        .name(\"Voice2Text status thread\".to_string())\r\n        .spawn(move || {\r\n            let rt = tokio::runtime::Runtime::new().unwrap();\r\n            rt.block_on(async {\r\n                let game_tx = game_tx_clone;\r\n                loop {\r\n                    let msg = match thread_rx.recv() {\r\n                        Ok(msg) => msg,\r\n                        Err(_) => {\r\n                            error!(\"Threadbound channel failure, exiting\");\r\n                            break;\r\n                        }\r\n                    };\r\n                    match msg {\r\n                        ThreadboundMessage::Ping => {\r\n                            debug!(\"Worker received ping request, pinging VoiceToText API\");\r\n                            let status = match crate::voice_to_text::get_status().await {\r\n                                Ok(status) => status,\r\n                                Err(e) => {\r\n                                    error!(\"Failed to get status: {:?}\", e);\r\n                                    VoiceToTextStatus::Unknown\r\n                                }\r\n                            };\r\n                            if let Err(e) = game_tx.send(GameboundMessage::Pong { status }) {\r\n                                error!(\"Gamebound channel failure, exiting: {}\", e);\r\n                                break;\r\n                            }\r\n                        }\r\n                        ThreadboundMessage::Startup => {\r\n                            debug!(\"Worker received startup request, starting VoiceToText API\");\r\n                            match crate::voice_to_text::start() {\r\n                                Ok(api_key) => {\r\n                                    debug!(\"VoiceToText API started successfully\");\r\n                                    if let Err(e) =\r\n                                        game_tx.send(GameboundMessage::Starting { api_key })\r\n                                    {\r\n                                        error!(\"Gamebound channel failure, exiting: {}\", e);\r\n                                        break;\r\n                                    }\r\n                                }\r\n                                Err(e) => {\r\n                                    error!(\"Failed to start: {:?}\", e);\r\n                                }\r\n                            };\r\n                        }\r\n                        ThreadboundMessage::SetListening { listening, api_key } => {\r\n                            debug!(\"Worker received set listening request: {}\", listening);\r\n                            match crate::voice_to_text::set_listening(listening, api_key).await {\r\n                                Ok(()) => {\r\n                                    info!(\r\n                                        \"VoiceToText API set listening={} successfully\",\r\n                                        listening\r\n                                    );\r\n                                }\r\n                                Err(e) => {\r\n                                    error!(\"Failed to set listening: {:?}\", e);\r\n                                }\r\n                            }\r\n                        }\r\n                        ThreadboundMessage::ConnectReceiver { api_key } => {\r\n                            info!(\"Worker received connect receiver request\");\r\n                            match crate::voice_to_text::connect_receiver(game_tx.clone(), api_key)\r\n                                .await\r\n                            {\r\n                                Ok(()) => {\r\n                                    info!(\"VoiceToText API connected receiver successfully\");\r\n                                }\r\n                                Err(e) => {\r\n                                    error!(\"Failed to connect receiver: {:?}\", e);\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    std::thread::sleep(std::time::Duration::from_millis(50));\r\n                }\r\n            });\r\n        })\r\n        .expect(\"Failed to spawn thread\");\r\n}\r\n\r\nfn events_to_bridge(\r\n    bridge: ResMut<Bridge>,\r\n    mut ping_events: EventReader<VoiceToTextPingEvent>,\r\n    mut command_events: EventReader<VoiceToTextCommandEvent>,\r\n) {\r\n    // Detect ping requests\r\n    for event in ping_events.read() {\r\n        let VoiceToTextPingEvent::Ping = event else {\r\n            continue;\r\n        };\r\n        let msg = ThreadboundMessage::Ping;\r\n        debug!(\"Sending bridge message: {:?}\", msg);\r\n        if let Err(e) = bridge.sender.send(msg) {\r\n            error!(\"Threadbound channel failure: {}\", e);\r\n        }\r\n    }\r\n\r\n    for event in command_events.read() {\r\n        let msg = match event {\r\n            VoiceToTextCommandEvent::Startup => ThreadboundMessage::Startup,\r\n            VoiceToTextCommandEvent::SetListening { listening, api_key } => {\r\n                ThreadboundMessage::SetListening {\r\n                    listening: *listening,\r\n                    api_key: api_key.clone(),\r\n                }\r\n            }\r\n            VoiceToTextCommandEvent::ConnectReceiver { api_key } => {\r\n                ThreadboundMessage::ConnectReceiver {\r\n                    api_key: api_key.clone(),\r\n                }\r\n            }\r\n        };\r\n        debug!(\"Sending bridge message: {:?}\", msg);\r\n        if let Err(e) = bridge.sender.send(msg) {\r\n            error!(\"Threadbound channel failure: {}\", e);\r\n        }\r\n    }\r\n}\r\n\r\nfn bridge_to_events(\r\n    bridge: ResMut<Bridge>,\r\n    mut ping_events: EventWriter<VoiceToTextPingEvent>,\r\n    mut status_events: EventWriter<VoiceToTextStatusEvent>,\r\n    mut transcription_events: EventWriter<VoiceToTextTranscriptionEvent>,\r\n    mut current_status: ResMut<VoiceToTextStatus>,\r\n) {\r\n    for msg in bridge.receiver.try_iter() {\r\n        match msg {\r\n            GameboundMessage::Pong { status } => {\r\n                let event = VoiceToTextPingEvent::Pong { status };\r\n                debug!(\"Received bridge response, sending game event {:?}\", event);\r\n                ping_events.send(event);\r\n            }\r\n            GameboundMessage::Starting { api_key } => {\r\n                let new_status = VoiceToTextStatus::Starting {\r\n                    instant: Instant::now(),\r\n                    timeout: Duration::from_secs(60),\r\n                    api_key: api_key.clone(),\r\n                };\r\n                let event = VoiceToTextStatusEvent::Changed {\r\n                    old_status: current_status.clone(),\r\n                    new_status: new_status.clone(),\r\n                };\r\n                debug!(\"Received bridge response, sending game event {:?}\", event);\r\n                status_events.send(event);\r\n\r\n                *current_status = new_status;\r\n            }\r\n            GameboundMessage::TranscriptionReceived { transcription } => {\r\n                let event = VoiceToTextTranscriptionEvent::Received { transcription };\r\n                debug!(\"Received bridge response, sending game event {:?}\", event);\r\n                transcription_events.send(event);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\winutils\\src\\win_window.rs\r\n\r\n````rust\r\nuse bevy::math::IRect;\r\nuse bevy::math::IVec2;\r\nuse windows::core::PCSTR;\r\nuse windows::Win32::Foundation::HWND;\r\nuse windows::Win32::Foundation::LPARAM;\r\nuse windows::Win32::Foundation::RECT;\r\nuse windows::Win32::Foundation::WPARAM;\r\nuse windows::Win32::UI::Input::KeyboardAndMouse::ReleaseCapture;\r\nuse windows::Win32::UI::WindowsAndMessaging::FindWindowA;\r\nuse windows::Win32::UI::WindowsAndMessaging::GetClientRect;\r\nuse windows::Win32::UI::WindowsAndMessaging::GetForegroundWindow;\r\nuse windows::Win32::UI::WindowsAndMessaging::GetSystemMetrics;\r\nuse windows::Win32::UI::WindowsAndMessaging::GetWindowRect;\r\nuse windows::Win32::UI::WindowsAndMessaging::IsWindowVisible;\r\nuse windows::Win32::UI::WindowsAndMessaging::SendMessageW;\r\nuse windows::Win32::UI::WindowsAndMessaging::SetForegroundWindow;\r\nuse windows::Win32::UI::WindowsAndMessaging::ShowWindow;\r\nuse windows::Win32::UI::WindowsAndMessaging::HTCAPTION;\r\nuse windows::Win32::UI::WindowsAndMessaging::SM_CYCAPTION;\r\nuse windows::Win32::UI::WindowsAndMessaging::SM_CYFRAME;\r\nuse windows::Win32::UI::WindowsAndMessaging::SW_RESTORE;\r\nuse windows::Win32::UI::WindowsAndMessaging::WM_NCLBUTTONDOWN;\r\n\r\nuse crate::ToBevyIRect;\r\n\r\nimpl ToBevyIRect for RECT {\r\n    fn to_bevy_irect(&self) -> IRect {\r\n        IRect {\r\n            min: IVec2::new(self.left, self.top),\r\n            max: IVec2::new(self.right, self.bottom),\r\n        }\r\n    }\r\n}\r\n\r\n#[derive(Debug)]\r\npub enum WindowBoundsError {\r\n    WindowNotFound,\r\n    WindowsError(windows::core::Error),\r\n}\r\n\r\n#[allow(dead_code)]\r\npub fn get_window_bounds_from_title(title: &str) -> Result<IRect, WindowBoundsError> {\r\n    unsafe {\r\n        let hwnd = FindWindowA(PCSTR::null(), PCSTR(title.as_ptr() as _));\r\n        if hwnd.0 == 0 {\r\n            return Err(WindowBoundsError::WindowNotFound);\r\n        }\r\n        let mut rect = RECT::default();\r\n        GetWindowRect(hwnd, &mut rect).map_err(WindowBoundsError::WindowsError)?;\r\n        Ok(rect.to_bevy_irect())\r\n    }\r\n}\r\n\r\npub fn get_window_bounds(hwnd: isize) -> Result<IRect, WindowBoundsError> {\r\n    unsafe {\r\n        let mut rect = RECT::default();\r\n        GetWindowRect(HWND(hwnd), &mut rect).map_err(WindowBoundsError::WindowsError)?;\r\n        Ok(rect.to_bevy_irect())\r\n    }\r\n}\r\n\r\npub fn get_window_inner_bounds(hwnd: isize) -> Result<IRect, WindowBoundsError> {\r\n    unsafe {\r\n        let hwnd = HWND(hwnd);\r\n        let mut rect = RECT::default();\r\n        if GetClientRect(hwnd, &mut rect).is_ok() {\r\n            Ok(rect.to_bevy_irect())\r\n        } else {\r\n            Err(WindowBoundsError::WindowsError(\r\n                windows::core::Error::from_win32(),\r\n            ))\r\n        }\r\n    }\r\n}\r\n\r\npub fn begin_dragging(hwnd: isize) -> Result<(), windows::core::Error> {\r\n    unsafe {\r\n        let _join_handle = std::thread::Builder::new()\r\n            .name(\"Begin move\".to_string())\r\n            .spawn(move || {\r\n                if let Err(e) = ReleaseCapture() {\r\n                    eprintln!(\"Failed to release capture: {:?}\", e);\r\n                }\r\n                let hwnd = HWND(hwnd);\r\n                SendMessageW(\r\n                    hwnd,\r\n                    WM_NCLBUTTONDOWN,\r\n                    WPARAM(HTCAPTION as usize),\r\n                    LPARAM(0),\r\n                );\r\n                println!(\"Sent message\");\r\n            });\r\n        Ok(())\r\n    }\r\n}\r\n\r\npub fn get_window_title_bar_center_position(hwnd: isize) -> Result<IVec2, WindowBoundsError> {\r\n    unsafe {\r\n        let bounds = get_window_bounds(hwnd)?;\r\n\r\n        // SM_CYCAPTION includes the height of the title bar\r\n        let caption_height = GetSystemMetrics(SM_CYCAPTION);\r\n\r\n        // SM_CYFRAME includes the height of the window frame (border)\r\n        let frame_height = GetSystemMetrics(SM_CYFRAME);\r\n\r\n        let pos =\r\n            bounds.min + IVec2::new((bounds.width()) / 2, (caption_height / 2) + frame_height);\r\n        Ok(pos)\r\n    }\r\n}\r\n\r\npub fn get_window_inner_offset() -> IVec2 {\r\n    unsafe {\r\n        // SM_CYCAPTION includes the height of the title bar\r\n        let caption_height = GetSystemMetrics(SM_CYCAPTION);\r\n\r\n        // SM_CYFRAME includes the height of the window frame (border)\r\n        let frame_height = GetSystemMetrics(SM_CYFRAME);\r\n\r\n        IVec2::new(frame_height, caption_height + frame_height * 2)\r\n    }\r\n}\r\n\r\npub fn focus_window(hwnd: isize) {\r\n    unsafe {\r\n        // Convert the isize to HWND\r\n        let hwnd = HWND(hwnd);\r\n\r\n        // If the window is minimized, restore it before setting it to the foreground.\r\n        if !IsWindowVisible(hwnd).as_bool() {\r\n            ShowWindow(hwnd, SW_RESTORE);\r\n        }\r\n\r\n        // Bring the window to the foreground\r\n        SetForegroundWindow(hwnd);\r\n    }\r\n}\r\n\r\npub fn note_window_info(hwnd: isize) -> Result<IRect, WindowBoundsError> {\r\n    unsafe {\r\n        let hwnd = HWND(hwnd);\r\n\r\n        // Get the window's size and location\r\n        let mut rect = RECT::default();\r\n        GetWindowRect(hwnd, &mut rect).map_err(WindowBoundsError::WindowsError)?;\r\n        Ok(rect.to_bevy_irect())\r\n    }\r\n}\r\n\r\npub fn is_window_focused(hwnd: HWND) -> bool {\r\n    unsafe {\r\n        // Get the handle to the currently focused (foreground) window.\r\n        let foreground_hwnd = GetForegroundWindow();\r\n\r\n        // Compare it with the provided hwnd.\r\n        foreground_hwnd == hwnd\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\start_menu\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_start_menu\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\ncursor_hero_start_menu_types = { workspace = true }\r\ncursor_hero_winutils = { workspace = true }\r\ncursor_hero_taskbar_types = { workspace = true }\r\ncursor_hero_pointer_types = { workspace = true }\r\nbevy_xpbd_2d = { workspace = true }\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui_automation\\src\\take_snapshot.rs\r\n\r\n````rust\r\nuse crate::gather_root_children::gather_root_children;\r\nuse crate::resolve_app::resolve_app;\r\nuse anyhow::Result;\r\nuse cursor_hero_ui_automation_types::prelude::*;\r\nuse uiautomation::UIAutomation;\r\n\r\npub fn take_snapshot() -> Result<UISnapshot> {\r\n    let automation = UIAutomation::new()?;\r\n    let walker = automation.create_tree_walker()?;\r\n    // let walker = automation.get_raw_view_walker()?;\r\n    let top_level_children = gather_root_children(&automation, &walker)?;\r\n\r\n    let focused = automation.get_focused_element()?;\r\n    let focused_app = walker.normalize(&focused)?;\r\n\r\n    let mut apps = vec![];\r\n    for elem in top_level_children {\r\n        let focused = elem.get_runtime_id() == focused_app.get_runtime_id();\r\n        let resolved = resolve_app(&elem, &automation, focused)?;\r\n        if resolved != AppWindow::Unknown {\r\n            apps.push((elem, resolved));\r\n        }\r\n    }\r\n\r\n    let snapshot = UISnapshot {\r\n        app_windows: apps.into_iter().map(|(_elem, app)| app).collect(),\r\n    };\r\n    Ok(snapshot)\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use windows::Win32::System::Com::CoInitializeEx;\r\n    use windows::Win32::System::Com::COINIT_MULTITHREADED;\r\n\r\n    use crate::prelude::take_snapshot;\r\n\r\n    #[test]\r\n    fn test_take_snapshot() {\r\n        //todo: put this in thread initialzed for COM like below\r\n        let snapshot = take_snapshot().unwrap();\r\n        assert!(snapshot.app_windows.len() > 0);\r\n    }\r\n\r\n    #[test]\r\n    fn test_take_snapshot_many() {\r\n        let handle = std::thread::spawn(move || -> windows::core::Result<()> {\r\n            unsafe {\r\n                // Initialize COM in MTA mode\r\n                // https://learn.microsoft.com/en-us/windows/win32/com/multithreaded-apartments\r\n                CoInitializeEx(None, COINIT_MULTITHREADED)?;\r\n\r\n                println!(\"COM initialized in MTA mode.\");\r\n\r\n                for i in 0..100 {\r\n                    let start = std::time::Instant::now();\r\n                    let snapshot = take_snapshot().unwrap();\r\n                    assert!(snapshot.app_windows.len() > 0);\r\n                    if i == 0 {\r\n                        println!(\"{}\", snapshot);\r\n                    }\r\n                    let end = std::time::Instant::now();\r\n                    println!(\"time: {:?}\", end - start);\r\n                    assert!(end - start < std::time::Duration::from_secs(1));\r\n                }\r\n\r\n                Ok(())\r\n            }\r\n        });\r\n\r\n        // Wait for the thread to complete its tasks and handle any errors\r\n        let _ = handle.join().unwrap();\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\voice_to_text_types\\src\\voice_to_text_types_plugin.rs\r\n\r\n````rust\r\nuse crate::prelude::*;\r\nuse bevy::prelude::*;\r\n\r\npub struct VoiceToTextTypesPlugin;\r\n\r\nimpl Plugin for VoiceToTextTypesPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<VoiceToTextStatus>();\r\n        app.register_type::<VoiceToTextStatusButton>();\r\n        app.register_type::<VoiceToTextStatusButtonVisualState>();\r\n        app.register_type::<VoiceToTextStatusEvent>();\r\n        app.add_event::<VoiceToTextStatusEvent>();\r\n\r\n        app.register_type::<VoiceToTextPingEvent>();\r\n        app.add_event::<VoiceToTextPingEvent>();\r\n\r\n        app.register_type::<VoiceToTextTranscriptionEvent>();\r\n        app.add_event::<VoiceToTextTranscriptionEvent>();\r\n\r\n        app.register_type::<VoiceToTextCommandEvent>();\r\n        app.add_event::<VoiceToTextCommandEvent>();\r\n\r\n        app.register_type::<VoiceToTextVscodeButton>();\r\n        app.register_type::<VoiceToTextVscodeButtonVisualState>();\r\n        app.register_type::<VoiceToTextVscodeEvent>();\r\n        app.add_event::<VoiceToTextVscodeEvent>();\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\chat\\src\\chat_input_buffer_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse cursor_hero_character_types::character_types::Character;\r\nuse cursor_hero_chat_types::prelude::*;\r\nuse cursor_hero_toolbelt_types::prelude::*;\r\nuse leafwing_input_manager::action_state::ActionState;\r\n\r\npub struct ChatInputBufferPlugin;\r\n\r\nimpl Plugin for ChatInputBufferPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Update, handle_char);\r\n        app.add_systems(Update, handle_input);\r\n    }\r\n}\r\n\r\nfn handle_char(\r\n    mut tool_query: Query<(Entity, &mut ChatTool, &Parent), With<ActiveTool>>,\r\n    toolbelt_query: Query<&Parent, With<Toolbelt>>,\r\n    character_query: Query<Entity, With<Character>>,\r\n    mut chat_input_events: EventWriter<ChatInputEvent>,\r\n    mut character_events: EventReader<ReceivedCharacter>,\r\n) {\r\n    for event in character_events.read() {\r\n        if event.char.is_control() {\r\n            continue;\r\n        }\r\n        for tool in tool_query.iter_mut() {\r\n            let (tool_id, mut tool, tool_parent) = tool;\r\n            if !tool.focused {\r\n                continue;\r\n            }\r\n            let Ok(toolbelt) = toolbelt_query.get(tool_parent.get()) else {\r\n                warn!(\"Tool not inside a toolbelt?\");\r\n                continue;\r\n            };\r\n            let toolbelt_parent = toolbelt;\r\n            let Ok(character) = character_query.get(toolbelt_parent.get()) else {\r\n                warn!(\"Toolbelt parent not a character?\");\r\n                continue;\r\n            };\r\n            let character_id = character;\r\n            tool.buffer.push(event.char);\r\n            chat_input_events.send(ChatInputEvent::TextChanged {\r\n                tool_id,\r\n                toolbelt_id: tool_parent.get(),\r\n                character_id,\r\n            });\r\n            debug!(\r\n                \"Appended char '{}' ({}) to chat buffer. New: {}\",\r\n                event.char, event.char as u32, tool.buffer\r\n            );\r\n        }\r\n    }\r\n}\r\n\r\nfn handle_input(\r\n    mut tool_query: Query<\r\n        (Entity, &mut ChatTool, &ActionState<ChatToolAction>, &Parent),\r\n        With<ActiveTool>,\r\n    >,\r\n    toolbelt_query: Query<&Parent, With<Toolbelt>>,\r\n    character_query: Query<Entity, With<Character>>,\r\n    mut chat_input_events: EventWriter<ChatInputEvent>,\r\n    time: Res<Time>,\r\n) {\r\n    for tool in tool_query.iter_mut() {\r\n        let (tool_id, mut tool, tool_actions, tool_parent) = tool;\r\n        if !tool.focused {\r\n            continue;\r\n        }\r\n        let input_active = tool_actions.pressed(ChatToolAction::Backspace);\r\n        match (input_active, &mut tool.state) {\r\n            // no input is active, return to default state\r\n            (false, state) => {\r\n                if *state != ChatToolState::Idle {\r\n                    tool.state = ChatToolState::Idle;\r\n                }\r\n                continue;\r\n            }\r\n            // first input, start initial delay\r\n            (true, ChatToolState::Idle) => {\r\n                tool.state =\r\n                    ChatToolState::InitialRepeatDelay(Timer::from_seconds(0.5, TimerMode::Once));\r\n            }\r\n            // check initial delay finished, start repeat delay\r\n            (true, ChatToolState::InitialRepeatDelay(ref mut timer)) => {\r\n                if timer.tick(time.delta()).just_finished() {\r\n                    tool.state =\r\n                        ChatToolState::RepeatDelay(Timer::from_seconds(0.03, TimerMode::Repeating));\r\n                } else {\r\n                    continue;\r\n                }\r\n            }\r\n            // been held, continue repeat delay\r\n            (true, ChatToolState::RepeatDelay(ref mut timer)) => {\r\n                if !timer.tick(time.delta()).just_finished() {\r\n                    continue;\r\n                }\r\n            }\r\n        }\r\n\r\n        let Ok(toolbelt) = toolbelt_query.get(tool_parent.get()) else {\r\n            warn!(\"Tool not inside a toolbelt?\");\r\n            continue;\r\n        };\r\n        let toolbelt_parent = toolbelt;\r\n        let Ok(character) = character_query.get(toolbelt_parent.get()) else {\r\n            warn!(\"Toolbelt parent not a character?\");\r\n            continue;\r\n        };\r\n        let character_id = character;\r\n        let original_buffer = tool.buffer.clone();\r\n        if tool_actions.pressed(ChatToolAction::Backspace) {\r\n            if tool_actions.pressed(ChatToolAction::WordModifier) {\r\n                // delete word\r\n                while let Some(c) = tool.buffer.pop() {\r\n                    if c.is_whitespace() {\r\n                        break;\r\n                    }\r\n                }\r\n            } else {\r\n                tool.buffer.pop();\r\n            }\r\n        }\r\n        if original_buffer == tool.buffer {\r\n            continue;\r\n        }\r\n        chat_input_events.send(ChatInputEvent::TextChanged {\r\n            tool_id,\r\n            toolbelt_id: tool_parent.get(),\r\n            character_id,\r\n        });\r\n        debug!(\"Updated chat buffer. New: {}\", tool.buffer);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\pointer\\src\\pointer_spawning_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse bevy::sprite::Anchor;\r\nuse bevy_xpbd_2d::prelude::*;\r\nuse cursor_hero_character_types::prelude::*;\r\nuse cursor_hero_environment_types::environment_types::TrackEnvironmentTag;\r\nuse cursor_hero_pointer_types::prelude::*;\r\nuse leafwing_input_manager::prelude::*;\r\n\r\npub struct PointerSpawningPlugin;\r\n\r\nimpl Plugin for PointerSpawningPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Update, insert_pointer);\r\n    }\r\n}\r\n\r\n#[allow(clippy::type_complexity)]\r\nfn insert_pointer(\r\n    mut commands: Commands,\r\n    asset_server: Res<AssetServer>,\r\n    character: Query<(Entity, Option<&MainCharacter>, Option<&AgentCharacter>), Added<Character>>,\r\n) {\r\n    for character in character.iter() {\r\n        let (character_id, is_main_character, is_agent_character) = character;\r\n        info!(\"Creating pointer for character '{:?}'\", character_id);\r\n        commands.entity(character_id).with_children(|parent| {\r\n            let mut p = parent.spawn((\r\n                Name::new(\"Pointer\"),\r\n                SpriteBundle {\r\n                    texture: asset_server.load(\"textures/cursor.png\"),\r\n                    transform: Transform::from_xyz(0.0, 0.0, 2.0),\r\n                    sprite: Sprite {\r\n                        color: Color::rgb(0.149, 0.549, 0.184),\r\n                        anchor: Anchor::TopLeft,\r\n                        ..default()\r\n                    },\r\n                    ..Default::default()\r\n                },\r\n                TrackEnvironmentTag,\r\n                RigidBody::Dynamic,\r\n                Collider::cuboid(10.0, 10.0),\r\n                Sensor,\r\n            ));\r\n            match (is_main_character.is_some(), is_agent_character.is_some()) {\r\n                (true, false) => {\r\n                    p.insert((\r\n                        MainPointer,\r\n                        Pointer::new_host_pointer(),\r\n                        InputManagerBundle::<PointerAction> {\r\n                            input_map: PointerAction::default_input_map(),\r\n                            action_state: ActionState::default(),\r\n                        },\r\n                    ));\r\n                }\r\n                (false, true) => {\r\n                    p.insert((\r\n                        Pointer::new_agent_pointer(),\r\n                        InputManagerBundle::<PointerAction> {\r\n                            input_map: InputMap::default(),\r\n                            action_state: ActionState::default(),\r\n                        },\r\n                    ));\r\n                }\r\n                (is_main, is_agent) => {\r\n                    error!(\r\n                        \"Character '{:?}' isn't exclusively main or agent: main: {:?}, agent: {:?}\",\r\n                        character_id, is_main, is_agent\r\n                    );\r\n                    p.insert((\r\n                        Pointer::new_unknown_pointer(),\r\n                        InputManagerBundle::<PointerAction> {\r\n                            input_map: InputMap::default(),\r\n                            action_state: ActionState::default(),\r\n                        },\r\n                    ));\r\n                }\r\n            }\r\n        });\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\pointer_types\\src\\pointer_action_types.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse leafwing_input_manager::prelude::*;\r\nuse leafwing_input_manager::user_input::InputKind;\r\n\r\npub struct PointerActionPlugin;\r\n\r\nimpl Plugin for PointerActionPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_plugins(InputManagerPlugin::<PointerAction>::default());\r\n    }\r\n}\r\n\r\n#[derive(Actionlike, PartialEq, Eq, Clone, Copy, Hash, Debug, Reflect)]\r\npub enum PointerAction {\r\n    Move,\r\n}\r\n\r\nimpl PointerAction {\r\n    fn default_gamepad_binding(&self) -> UserInput {\r\n        match self {\r\n            Self::Move => UserInput::Single(InputKind::DualAxis(DualAxis::right_stick())),\r\n        }\r\n    }\r\n\r\n    fn default_mkb_binding(&self) -> UserInput {\r\n        match self {\r\n            Self::Move => UserInput::VirtualDPad(VirtualDPad::arrow_keys()),\r\n        }\r\n    }\r\n\r\n    pub fn default_input_map() -> InputMap<PointerAction> {\r\n        let mut input_map = InputMap::default();\r\n\r\n        for variant in PointerAction::variants() {\r\n            input_map.insert(variant.default_mkb_binding(), variant);\r\n            input_map.insert(variant.default_gamepad_binding(), variant);\r\n        }\r\n        input_map\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\taskbar_types\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_taskbar_types\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\memory\\src\\lib.rs\r\n\r\n````rust\r\nmod agent_observation_memory_plugin;\r\nmod main_camera_memory_plugin;\r\nmod main_character_memory_plugin;\r\nmod memory_plugin;\r\npub mod primary_window_memory_plugin;\r\nmod voice_to_text_memory_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::memory_plugin::*;\r\n    pub use cursor_hero_memory_types;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\pointer\\src\\lib.rs\r\n\r\n````rust\r\n#![feature(let_chains)]\r\n\r\npub mod pointer_click_plugin;\r\npub mod pointer_hover_plugin;\r\npub mod pointer_plugin;\r\npub mod pointer_positioning_plugin;\r\npub mod pointer_reach_plugin;\r\npub mod pointer_spawning_plugin;\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\movement_tool_types\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_movement_tool_types\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\nleafwing-input-manager = { workspace = true }\r\nbevy-inspector-egui = { workspace = true }\r\ncursor_hero_toolbelt_types = { workspace = true }\r\ncursor_hero_input = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\physics\\src\\lib.rs\r\n\r\n````rust\r\npub mod damping_plugin;\r\npub mod physics_plugin;\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\pressure_plate\\src\\pressure_plate_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse bevy_xpbd_2d::components::CollidingEntities;\r\n\r\npub struct PressurePlatePlugin;\r\nimpl Plugin for PressurePlatePlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Update, update_plate)\r\n            .add_event::<PressurePlateActivationEvent>()\r\n            .register_type::<PressurePlate>();\r\n    }\r\n}\r\n\r\n#[derive(Event)]\r\npub struct PressurePlateActivationEvent(pub Entity);\r\n\r\n#[derive(Component, Reflect)]\r\npub struct PressurePlate {\r\n    active_time: f32,\r\n    debounce: bool,\r\n    indicator: Entity,\r\n}\r\n\r\n#[derive(Component, Default, Reflect)]\r\npub struct PressurePlateProgressIndicator {\r\n    visual_progress: f32,\r\n}\r\n\r\nimpl PressurePlate {\r\n    pub fn new(indicator: Entity) -> Self {\r\n        Self {\r\n            active_time: 0.0,\r\n            debounce: false,\r\n            indicator,\r\n        }\r\n    }\r\n}\r\n\r\n#[allow(clippy::type_complexity)]\r\nfn update_plate(\r\n    asset_server: Res<AssetServer>,\r\n    mut commands: Commands,\r\n    time: Res<Time>,\r\n    mut query: Query<\r\n        (\r\n            Entity,\r\n            &mut PressurePlate,\r\n            &mut Sprite,\r\n            &CollidingEntities,\r\n            Option<&SpatialAudioSink>,\r\n        ),\r\n        Without<PressurePlateProgressIndicator>,\r\n    >,\r\n    mut indicator_query: Query<\r\n        (&mut PressurePlateProgressIndicator, &mut Sprite),\r\n        Without<PressurePlate>,\r\n    >,\r\n    mut activation_writer: EventWriter<PressurePlateActivationEvent>,\r\n) {\r\n    for (entity, mut plate, mut sprite, colliding_entities, sink) in &mut query {\r\n        if colliding_entities.0.is_empty() {\r\n            sprite.color = Color::rgb(0.2, 0.7, 0.9);\r\n            plate.active_time = 0.0;\r\n            sink.map(SpatialAudioSink::stop);\r\n            plate.debounce = false;\r\n        } else {\r\n            if plate.debounce {\r\n                continue;\r\n            }\r\n            sprite.color = Color::rgb(0.9, 0.7, 0.2);\r\n            if plate.active_time == 0.0 {\r\n                let bundle = AudioBundle {\r\n                    source: asset_server.load(\"sounds/pressure plate activation.ogg\"),\r\n                    settings: PlaybackSettings::REMOVE.with_spatial(true),\r\n                };\r\n                commands.entity(entity).insert(bundle);\r\n                plate.active_time += time.delta_seconds();\r\n            } else {\r\n                plate.active_time += time.delta_seconds();\r\n                if plate.active_time > cursor_hero_data::sounds::PRESSURE_PLATE_ACTIVATION_DURATION\r\n                {\r\n                    plate.active_time = 0.0;\r\n                    plate.debounce = true;\r\n                    activation_writer.send(PressurePlateActivationEvent(entity));\r\n                }\r\n            }\r\n        }\r\n        if let Ok((mut indicator, mut indicator_sprite)) = indicator_query.get_mut(plate.indicator)\r\n        {\r\n            indicator.visual_progress =\r\n                plate.active_time / cursor_hero_data::sounds::PRESSURE_PLATE_ACTIVATION_DURATION;\r\n            indicator_sprite.color = Color::rgb(0.2, 0.7, 0.9) * indicator.visual_progress;\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\host_event_types\\src\\host_event_types_plugin.rs\r\n\r\n````rust\r\nuse crate::prelude::*;\r\nuse bevy::prelude::*;\r\n\r\npub struct HostEventTypesPlugin;\r\n\r\nimpl Plugin for HostEventTypesPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_event::<HostEvent>();\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\math\\src\\shuffle.rs\r\n\r\n````rust\r\n#[cfg(target_arch = \"x86\")]\r\nuse std::arch::x86::_mm_shuffle_epi8;\r\nuse std::arch::x86_64::__m128i;\r\nuse std::arch::x86_64::_mm_loadu_si128;\r\nuse std::arch::x86_64::_mm_setr_epi8;\r\n#[cfg(target_arch = \"x86_64\")]\r\nuse std::arch::x86_64::_mm_shuffle_epi8;\r\nuse std::arch::x86_64::_mm_storeu_si128;\r\n\r\n/// Convert BGRA to RGBA\r\n///\r\n/// Uses SIMD to go fast\r\npub fn bgra_to_rgba(data: &mut [u8]) {\r\n    // The shuffle mask for converting BGRA -> RGBA\r\n    let mask: __m128i = unsafe {\r\n        _mm_setr_epi8(\r\n            2, 1, 0, 3, // First pixel\r\n            6, 5, 4, 7, // Second pixel\r\n            10, 9, 8, 11, // Third pixel\r\n            14, 13, 12, 15, // Fourth pixel\r\n        )\r\n    };\r\n    // For each 16-byte chunk in your data\r\n    for chunk in data.chunks_exact_mut(16) {\r\n        let mut vector = unsafe { _mm_loadu_si128(chunk.as_ptr() as *const __m128i) };\r\n        vector = unsafe { _mm_shuffle_epi8(vector, mask) };\r\n        unsafe { _mm_storeu_si128(chunk.as_mut_ptr() as *mut __m128i, vector) };\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\glados_tts\\src\\glados_tts_status_plugin.rs\r\n\r\n````rust\r\nuse std::time::Duration;\r\n\r\nuse bevy::prelude::*;\r\nuse bevy::utils::Instant;\r\nuse cursor_hero_glados_tts_types::prelude::*;\r\n\r\npub struct GladosTtsStatusPlugin;\r\n\r\nimpl Plugin for GladosTtsStatusPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.init_resource::<GladosTtsStatus>();\r\n        app.add_systems(Update, handle_startup_event);\r\n        app.add_systems(Update, periodic_ping);\r\n        app.add_systems(Update, handle_pong);\r\n    }\r\n}\r\n\r\nfn handle_startup_event(\r\n    mut status_events: ParamSet<(\r\n        EventReader<GladosTtsStatusEvent>,\r\n        EventWriter<GladosTtsStatusEvent>,\r\n    )>,\r\n    mut glados_tts_status: ResMut<GladosTtsStatus>,\r\n) {\r\n    let starting = status_events\r\n        .p0()\r\n        .read()\r\n        .any(|event| matches!(event, GladosTtsStatusEvent::Startup));\r\n    if !starting {\r\n        return;\r\n    }\r\n    status_events.p0().clear();\r\n\r\n    *glados_tts_status = GladosTtsStatus::Starting {\r\n        instant: Instant::now(),\r\n        timeout: Duration::from_secs(60),\r\n    };\r\n    let event = GladosTtsStatusEvent::Changed {\r\n        new_value: *glados_tts_status,\r\n    };\r\n    debug!(\"Sending event {:?}\", event);\r\n    status_events.p1().send(event);\r\n}\r\n\r\nfn periodic_ping(\r\n    mut ping_events: EventWriter<GladosTtsPingEvent>,\r\n    mut last_ping: Local<Option<Instant>>,\r\n) {\r\n    if let Some(instant) = *last_ping {\r\n        if instant.elapsed().as_secs() > 5 {\r\n            ping_events.send(GladosTtsPingEvent::Ping);\r\n            *last_ping = Some(Instant::now());\r\n        }\r\n    } else {\r\n        ping_events.send(GladosTtsPingEvent::Ping);\r\n        *last_ping = Some(Instant::now());\r\n    }\r\n}\r\n\r\nfn handle_pong(\r\n    mut ping_events: EventReader<GladosTtsPingEvent>,\r\n    mut status_events: EventWriter<GladosTtsStatusEvent>,\r\n    mut glados_tts_status: ResMut<GladosTtsStatus>,\r\n) {\r\n    for event in ping_events.read() {\r\n        let GladosTtsPingEvent::Pong { status } = event else {\r\n            continue;\r\n        };\r\n        // identify the new state based on the pong\r\n        let new_status = match (*glados_tts_status, *status) {\r\n            // if starting, only change to dead if the timeout has been exceeded\r\n            (GladosTtsStatus::Starting { instant, timeout }, status) => {\r\n                if status == GladosTtsStatus::Alive {\r\n                    GladosTtsStatus::Alive\r\n                } else if instant.elapsed() > timeout {\r\n                    GladosTtsStatus::Dead\r\n                } else {\r\n                    GladosTtsStatus::Starting { instant, timeout }\r\n                }\r\n            }\r\n            // respect the new status if it's not starting\r\n            _ => *status,\r\n        };\r\n\r\n        if *glados_tts_status != new_status {\r\n            *glados_tts_status = new_status;\r\n            let event = GladosTtsStatusEvent::Changed {\r\n                new_value: new_status,\r\n            };\r\n            debug!(\"Sending event {:?}\", event);\r\n            status_events.send(event);\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\host_fs_types\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_host_fs_types\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui_automation\\src\\lib.rs\r\n\r\n````rust\r\nmod elements_at_point;\r\nmod formatting;\r\nmod gather_children;\r\nmod gather_element_info;\r\nmod gather_root_children;\r\nmod resolve_app;\r\nmod resolve_calculator;\r\nmod resolve_vscode;\r\nmod take_snapshot;\r\nmod taskbar;\r\nmod ui_automation_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::elements_at_point::*;\r\n    pub use crate::formatting::*;\r\n    pub use crate::gather_children::*;\r\n    pub use crate::gather_element_info::*;\r\n    pub use crate::take_snapshot::*;\r\n    pub use crate::taskbar::*;\r\n    pub use crate::ui_automation_plugin::*;\r\n    pub use cursor_hero_ui_automation_types::prelude::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\voice_to_text_types\\src\\voice_to_text_types.rs\r\n\r\n````rust\r\nuse std::fmt::Debug;\r\nuse std::time::Duration;\r\n\r\nuse bevy::prelude::*;\r\nuse bevy::utils::Instant;\r\nuse cursor_hero_secret_types::prelude::*;\r\n\r\n#[derive(Reflect, Resource, Default, Debug, Clone, Eq, PartialEq)]\r\n#[reflect(Resource)]\r\npub enum VoiceToTextStatus {\r\n    #[default]\r\n    Unknown,\r\n    UnknownWithCachedApiKey {\r\n        api_key: SecretString,\r\n    },\r\n    Alive {\r\n        api_key: SecretString,\r\n        listening: bool,\r\n    },\r\n    AliveButWeDontKnowTheApiKey,\r\n    Dead,\r\n    Starting {\r\n        instant: Instant,\r\n        timeout: Duration,\r\n        api_key: SecretString,\r\n    },\r\n}\r\n\r\n#[derive(Event, Debug, Reflect)]\r\npub enum VoiceToTextPingEvent {\r\n    Ping,\r\n    Pong { status: VoiceToTextStatus },\r\n}\r\n\r\n#[derive(Event, Debug, Reflect)]\r\npub enum VoiceToTextStatusEvent {\r\n    Changed {\r\n        old_status: VoiceToTextStatus,\r\n        new_status: VoiceToTextStatus,\r\n    },\r\n}\r\n\r\n#[derive(Event, Debug, Reflect)]\r\npub enum VoiceToTextTranscriptionEvent {\r\n    Received { transcription: String },\r\n}\r\n\r\n#[derive(Event, Debug, Reflect)]\r\npub enum VoiceToTextCommandEvent {\r\n    Startup,\r\n    SetListening {\r\n        listening: bool,\r\n        api_key: SecretString,\r\n    },\r\n    ConnectReceiver {\r\n        api_key: SecretString,\r\n    },\r\n}\r\n\r\n#[derive(Component, Debug, Reflect, Default)]\r\npub struct VoiceToTextStatusButton {\r\n    pub visual_state: VoiceToTextStatusButtonVisualState,\r\n}\r\n\r\n#[derive(Debug, Reflect, Eq, PartialEq)]\r\npub enum VoiceToTextStatusButtonVisualState {\r\n    Default { status: VoiceToTextStatus },\r\n    Hovered { status: VoiceToTextStatus },\r\n    Pressed { status: VoiceToTextStatus },\r\n}\r\nimpl Default for VoiceToTextStatusButtonVisualState {\r\n    fn default() -> Self {\r\n        VoiceToTextStatusButtonVisualState::Default {\r\n            status: VoiceToTextStatus::Unknown,\r\n        }\r\n    }\r\n}\r\n\r\n#[derive(Component, Debug, Reflect, Default)]\r\npub struct VoiceToTextVscodeButton {\r\n    pub visual_state: VoiceToTextVscodeButtonVisualState,\r\n}\r\n#[derive(Debug, Reflect, Eq, PartialEq, Default)]\r\npub enum VoiceToTextVscodeButtonVisualState {\r\n    #[default]\r\n    Default,\r\n}\r\n#[derive(Event, Debug, Reflect)]\r\npub enum VoiceToTextVscodeEvent {\r\n    Startup,\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\physics_debug\\src\\physics_debug_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n\r\npub struct PhysicsDebugPlugin;\r\n\r\nimpl Plugin for PhysicsDebugPlugin {\r\n    #[allow(unused_variables)]\r\n    fn build(&self, app: &mut App) {\r\n        // side effect: enabling this will cause tools to spawn visible instead of hidden\r\n        // app.add_plugins(bevy_xpbd_2d::plugins::PhysicsDebugPlugin::default());\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\toolbelt_types\\src\\toolbelt_types_plugin.rs\r\n\r\n````rust\r\nuse crate::toolbelt_types::*;\r\nuse bevy::prelude::*;\r\n\r\npub struct ToolbeltTypesPlugin;\r\n\r\nimpl Plugin for ToolbeltTypesPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<Toolbelt>();\r\n        app.register_type::<Wheel>();\r\n        app.register_type::<Tool>();\r\n        app.register_type::<ActiveTool>();\r\n        app.add_event::<ToolbeltPopulateEvent>();\r\n        app.add_event::<ToolbeltOpeningEvent>();\r\n        app.add_event::<ToolActivationEvent>();\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\app_types\\src\\app_types.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n\r\n#[derive(Component, Debug, Reflect)]\r\npub struct MyComponent;\r\n\r\n#[derive(Event, Debug, Reflect)]\r\npub enum MyEvent {\r\n    Guh,\r\n    Uh,\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\use cases\\copilot.md\r\n\r\n````markdown\r\nWhen having multiple cursors from using a snippet and copilot provides a suggestion and you hit tab it only inserts the suggestion at the first cursor. Need to recognize copilot ghost suggestions and type them out instead of hitting tab.\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\toolbelt\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_toolbelt\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\ncursor_hero_character_types = { workspace = true }\r\ncursor_hero_bevy = { workspace = true }\r\ncursor_hero_pointer_types = { workspace = true }\r\ncursor_hero_input = { workspace = true }\r\ncursor_hero_math = { workspace = true }\r\ncursor_hero_sprint_tool_types = { workspace = true }\r\ncursor_hero_toolbelt_types = { workspace = true }\r\ncursor_hero_window_position_types = { workspace = true }\r\ncursor_hero_xelu_prompts = { workspace = true }\r\nbevy = { workspace = true }\r\nbevy-inspector-egui = { workspace = true }\r\nbevy_xpbd_2d = { workspace = true }\r\nleafwing-input-manager = { workspace = true }\r\nitertools = { workspace = true }\r\ncursor_hero_host_fs_types = { workspace = true }\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui\\src\\about_text_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse cursor_hero_version::version_plugin::Version;\r\n\r\npub struct AboutTextPlugin;\r\n\r\nimpl Plugin for AboutTextPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Startup, spawn_text);\r\n    }\r\n}\r\n\r\nfn spawn_text(mut commands: Commands, asset_server: Res<AssetServer>, version: Res<Version>) {\r\n    commands.spawn((\r\n        TextBundle::from_section(\r\n            format!(\"Cursor Hero v{}\\nby @TeamDman\", version.0),\r\n            TextStyle {\r\n                font: asset_server.load(\"fonts/FiraSans-Bold.ttf\"),\r\n                font_size: 16.0,\r\n                ..default()\r\n            },\r\n        )\r\n        .with_style(Style {\r\n            position_type: PositionType::Absolute,\r\n            bottom: Val::Px(5.0),\r\n            right: Val::Px(5.0),\r\n            ..default()\r\n        }),\r\n        Name::new(\"About Text\"),\r\n    ));\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\templates\\patterns\\new_plugin_with_types\\crates\\{{crate_name}}_types\\src\\{{crate_name}}_types.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n\r\n#[derive(Component, Debug, Reflect)]\r\npub struct MyComponent;\r\n\r\n#[derive(Event, Debug, Reflect)]\r\npub enum MyEvent {\r\n    Guh,\r\n    Uh\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\host_event\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_host_event\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\ncursor_hero_host_event_types = { workspace = true }\r\ncursor_hero_winutils = {workspace = true}\r\nraw-window-handle = { workspace = true }\r\ncrossbeam-channel = { workspace = true }\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\math\\src\\math_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n\r\nuse crate::prelude::Corner;\r\n\r\npub struct MathPlugin;\r\n\r\nimpl Plugin for MathPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<Corner>();\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\use cases\\intellisense.md\r\n\r\n````markdown\r\nwhen prompting for suggestions in a rust file, the imports may be using\r\n\r\nuse whatever_types::prelude::*;\r\n\r\nit should be a farily simple operation to materialize a list of all the types that are now present.\r\nLanguage server integration with the prompting mechanism.\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\toolbelt\\src\\hover_frame.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse cursor_hero_pointer_types::prelude::*;\r\n\r\n#[derive(Component, Debug)]\r\npub struct ToolFrame;\r\n\r\n#[allow(clippy::type_complexity)]\r\npub fn insert_hover_frame(\r\n    mut reader: EventReader<HoverEvent>,\r\n    mut commands: Commands,\r\n    asset_server: Res<AssetServer>,\r\n    hovered_query: Query<&Sprite>,\r\n) {\r\n    for event in reader.read() {\r\n        if let HoverEvent::Start {\r\n            target_id,\r\n            pointer_id: _,\r\n        } = event\r\n        {\r\n            // Ensure the entity hasn't despawned since the event was sent\r\n            if commands.get_entity(*target_id).is_none() {\r\n                warn!(\"Hovered entity {:?} has despawned\", target_id);\r\n                continue;\r\n            }\r\n            let mut size = Vec2::new(200.0, 200.0);\r\n            if let Ok(hovered_sprite) = hovered_query.get(*target_id)\r\n                && let Some(hovered_size) = hovered_sprite.custom_size\r\n            {\r\n                size = hovered_size * 2.0;\r\n            }\r\n\r\n            commands.entity(*target_id).with_children(|hovered| {\r\n                hovered.spawn((\r\n                    SpriteBundle {\r\n                        sprite: Sprite {\r\n                            custom_size: Some(size),\r\n                            ..default()\r\n                        },\r\n                        texture: asset_server.load(\"textures/wood frame.png\"),\r\n                        ..default()\r\n                    },\r\n                    ToolFrame,\r\n                ));\r\n            });\r\n        }\r\n    }\r\n}\r\n#[allow(clippy::type_complexity)]\r\npub fn remove_hover_frame(\r\n    mut reader: EventReader<HoverEvent>,\r\n    mut commands: Commands,\r\n    tool_query: Query<&Children>,\r\n    frame_query: Query<Entity, With<ToolFrame>>,\r\n) {\r\n    for event in reader.read() {\r\n        if let HoverEvent::End {\r\n            target_id,\r\n            pointer_id: _,\r\n        } = event\r\n        {\r\n            if let Ok(tool_children) = tool_query.get(*target_id) {\r\n                for tool_child in tool_children.iter() {\r\n                    if let Ok(frame_id) = frame_query.get(*tool_child) {\r\n                        commands.entity(*target_id).remove_children(&[frame_id]);\r\n                        commands.entity(frame_id).despawn();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\templates\\copy_notebook.ps1\r\n\r\n````powershell\r\nparam (\r\n    [Parameter(Mandatory=$true, Position=0)]\r\n    [ValidateScript({Test-Path $_ -PathType 'Leaf'})]\r\n    [string]$NotebookPath,\r\n\r\n    [Parameter(Position=1)]\r\n    [switch]$IncludeOutputs\r\n)\r\n\r\n# Load the notebook as JSON\r\n$notebook = Get-Content -Raw -Path $NotebookPath | ConvertFrom-Json\r\n\r\n# Function to format code cells as markdown entries, correctly handling the array of lines in $Content\r\nfunction Format-CodeCell {\r\n    param (\r\n        [Parameter(Mandatory=$true)]\r\n        [Object[]]$Content, # Changed to Object[] to handle both source and outputs correctly\r\n\r\n        [Parameter(Mandatory=$false)]\r\n        [Object[]]$Outputs\r\n    )\r\n\r\n    $formattedContent = $Content -join \"\"\r\n    $markdown = \"``````py`n$formattedContent`n``````\"\r\n\r\n    if ($IncludeOutputs -and $Outputs) {\r\n        $formattedOutputs = $Outputs | ForEach-Object {\r\n            if ($_.output_type -eq \"stream\") {\r\n                $_.text -join \"`n\"\r\n            }\r\n            elseif ($_.output_type -eq \"execute_result\" -or $_.output_type -eq \"display_data\") {\r\n                $_.data.\"text/plain\" -join \"`n\"\r\n            }\r\n        } -join \"`n\"\r\n\r\n        if ($formattedOutputs) {\r\n            $markdown += \"`n```````n$formattedOutputs`n``````\"\r\n        }\r\n    }\r\n\r\n    $markdown\r\n}\r\n\r\n# Map code cells to formatted markdown entries\r\n$markdownEntries = $notebook.cells | Where-Object { $_.cell_type -eq 'code' } | ForEach-Object {\r\n    $source = $_.source\r\n    $outputs = if ($IncludeOutputs) { $_.outputs } else { $null }\r\n    Format-CodeCell -Content $source -Outputs $outputs\r\n}\r\n\r\n# Copy the result to the clipboard\r\n$markdownEntries -join \"`n`n\" | Set-Clipboard\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui_watcher_types\\src\\ui_watcher_types_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n// use crate::prelude::*;\r\n\r\npub struct UiWatcherTypesPlugin;\r\n\r\nimpl Plugin for UiWatcherTypesPlugin {\r\n    fn build(&self, _app: &mut App) {}\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\toolbelt\\src\\wheel_audio.rs\r\n\r\n````rust\r\nuse cursor_hero_toolbelt_types::toolbelt_types::*;\r\n\r\nuse bevy::audio::Volume;\r\nuse bevy::audio::VolumeLevel;\r\nuse bevy::prelude::*;\r\n\r\n#[derive(Component)]\r\npub struct WheelAudio;\r\n\r\npub fn wheel_audio(\r\n    mut commands: Commands,\r\n    asset_server: Res<AssetServer>,\r\n    mut toolbelt_events: EventReader<ToolbeltOpeningEvent>,\r\n    toolbelt_query: Query<&GlobalTransform>,\r\n) {\r\n    for event in toolbelt_events.read() {\r\n        match event {\r\n            ToolbeltOpeningEvent::Opened { toolbelt_id } => {\r\n                let Ok(toolbelt_transform) = toolbelt_query.get(*toolbelt_id) else {\r\n                    continue;\r\n                };\r\n                commands.spawn((\r\n                    AudioBundle {\r\n                        source: asset_server.load(\"sounds/plastic toy snapping shut 1.ogg\"),\r\n                        settings: PlaybackSettings::DESPAWN\r\n                            .with_spatial(true)\r\n                            .with_volume(Volume::Relative(VolumeLevel::new(0.5))),\r\n                    },\r\n                    SpatialBundle {\r\n                        transform: toolbelt_transform.compute_transform(),\r\n                        ..default()\r\n                    },\r\n                    WheelAudio,\r\n                    Name::new(\"opening sound\"),\r\n                ));\r\n            }\r\n            ToolbeltOpeningEvent::Closed { toolbelt_id } => {\r\n                let Ok(toolbelt_transform) = toolbelt_query.get(*toolbelt_id) else {\r\n                    continue;\r\n                };\r\n                commands.spawn((\r\n                    AudioBundle {\r\n                        source: asset_server\r\n                            .load(\"sounds/plastic toy snapping shut 1 reversed.ogg\"),\r\n                        settings: PlaybackSettings::DESPAWN\r\n                            .with_spatial(true)\r\n                            .with_volume(Volume::Relative(VolumeLevel::new(0.5))),\r\n                    },\r\n                    SpatialBundle {\r\n                        transform: toolbelt_transform.compute_transform(),\r\n                        ..default()\r\n                    },\r\n                    WheelAudio,\r\n                    Name::new(\"closing sound\"),\r\n                ));\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui_automation_types\\src\\ui_automation_drill.rs\r\n\r\n````rust\r\nuse crate::prelude::DrillId;\r\nuse anyhow::Context;\r\nuse anyhow::Result;\r\nuse std::collections::VecDeque;\r\nuse uiautomation::UIElement;\r\nuse uiautomation::UITreeWalker;\r\n\r\n#[derive(Debug)]\r\npub enum DrillError {\r\n    UI(uiautomation::Error),\r\n    EmptyPath,\r\n    BadPath,\r\n    OutOfBounds {\r\n        given: u32,\r\n        max: u32,\r\n        error: uiautomation::Error,\r\n    },\r\n}\r\nimpl std::error::Error for DrillError {}\r\nimpl std::fmt::Display for DrillError {\r\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\r\n        match self {\r\n            DrillError::UI(e) => write!(f, \"UIAutomation error: {}\", e),\r\n            DrillError::EmptyPath => write!(f, \"Empty path\"),\r\n            DrillError::BadPath => write!(f, \"Bad path\"),\r\n            DrillError::OutOfBounds { given, max, error } => write!(\r\n                f,\r\n                \"Out of bounds: given {}, max {}, error: {}\",\r\n                given, max, error\r\n            ),\r\n        }\r\n    }\r\n}\r\nimpl From<uiautomation::Error> for DrillError {\r\n    fn from(e: uiautomation::Error) -> Self {\r\n        DrillError::UI(e)\r\n    }\r\n}\r\npub trait Drillable {\r\n    fn drill<T: Into<DrillId>>(&self, walker: &UITreeWalker, path: T) -> Result<UIElement>;\r\n}\r\nimpl Drillable for UIElement {\r\n    fn drill<T: Into<DrillId>>(&self, walker: &UITreeWalker, path: T) -> Result<UIElement> {\r\n        let drill_id: DrillId = path.into();\r\n        match drill_id {\r\n            DrillId::Child(path) => {\r\n                let mut path = path\r\n                    .into_iter()\r\n                    .map(|x| x as u32)\r\n                    .collect::<VecDeque<u32>>();\r\n                if path.iter().any(|x| (*x as i32) < 0) {\r\n                    return Err(DrillError::BadPath.into());\r\n                }\r\n                drill_inner(self, walker, &mut path)\r\n            }\r\n            DrillId::Root | DrillId::Unknown => Err(DrillError::BadPath.into()),\r\n        }\r\n    }\r\n}\r\nfn drill_inner(\r\n    start: &UIElement,\r\n    walker: &UITreeWalker,\r\n    path: &mut VecDeque<u32>,\r\n) -> Result<UIElement> {\r\n    let target_index = match path.pop_front() {\r\n        Some(x) => x,\r\n        None => return Err(DrillError::EmptyPath.into()),\r\n    };\r\n    let mut child = walker\r\n        .get_first_child(start)\r\n        .context(\"get first child of start\")?;\r\n    let mut i = 0;\r\n    while i < target_index {\r\n        i += 1;\r\n        child = match walker.get_next_sibling(&child) {\r\n            Ok(x) => x,\r\n            Err(e) => {\r\n                return Err(DrillError::OutOfBounds {\r\n                    given: i,\r\n                    max: target_index,\r\n                    error: e,\r\n                }\r\n                .into())\r\n            }\r\n        };\r\n    }\r\n    if path.is_empty() {\r\n        Ok(child)\r\n    } else {\r\n        drill_inner(&child, walker, path)\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\observation_types\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_observation_types\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\nchrono = {workspace = true, features=[\"serde\"]}\r\nserde = {workspace = true}\r\ncursor_hero_ui_automation_types = { workspace = true}\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\cursor_mirror\\src\\cursor_mirroring_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse bevy::sprite::Anchor;\r\n\r\nuse cursor_hero_winutils::win_mouse::get_cursor_position;\r\n\r\npub struct CursorMirroringPlugin;\r\nimpl Plugin for CursorMirroringPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<CursorMirror>();\r\n        app.add_systems(Startup, setup);\r\n        app.add_systems(Update, (update_cursor_position, update_visuals).chain());\r\n        app.insert_resource(CursorPosition::default());\r\n    }\r\n}\r\n\r\n#[derive(Component, Reflect)]\r\npub struct CursorMirror;\r\n\r\n#[derive(Resource, Deref, Default, Reflect)]\r\n#[reflect(Resource)]\r\npub struct CursorPosition(pub IVec2);\r\n\r\nfn setup(mut commands: Commands, asset_server: Res<AssetServer>) {\r\n    commands.spawn((\r\n        SpriteBundle {\r\n            transform: Transform::from_xyz(0.0, 0.0, 20.0),\r\n            sprite: Sprite {\r\n                // custom_size: Some(Vec2::new(20.0, 20.0)),\r\n                anchor: Anchor::TopLeft,\r\n                ..default()\r\n            },\r\n\r\n            texture: asset_server.load(\"textures/cursor.png\"),\r\n            ..default()\r\n        },\r\n        CursorMirror,\r\n        Name::new(\"Cursor Mirror\"),\r\n    ));\r\n}\r\n\r\nfn update_cursor_position(mut res: ResMut<CursorPosition>) {\r\n    if let Ok(pos) = get_cursor_position() {\r\n        res.0 = pos;\r\n    }\r\n}\r\n\r\nfn update_visuals(\r\n    mut cursor_mirrors: Query<(&mut Transform, &CursorMirror)>,\r\n    cursor_position: Res<CursorPosition>,\r\n) {\r\n    for (mut transform, _) in &mut cursor_mirrors.iter_mut() {\r\n        transform.translation.x = cursor_position.x as f32;\r\n        transform.translation.y = -cursor_position.y as f32;\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\inference\\src\\prompt_asset_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse cursor_hero_inference_types::prelude::*;\r\n\r\npub struct PromptAssetPlugin;\r\n\r\nimpl Plugin for PromptAssetPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.init_resource::<TextPromptHandles>();\r\n        app.add_systems(Startup, load_prompt_assets);\r\n    }\r\n}\r\n\r\nfn load_prompt_assets(mut commands: Commands, asset_server: Res<AssetServer>) {\r\n    commands.insert_resource(TextPromptHandles {\r\n        raw: asset_server.load(\"prompt_templates/raw.txt\"),\r\n        chat: asset_server.load(\"prompt_templates/chat.txt\"),\r\n    });\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\taskbar_tool\\src\\lib.rs\r\n\r\n````rust\r\npub mod taskbar_tool_plugin;\r\npub mod taskbar_wheel_tool;\r\n\r\npub mod prelude {\r\n    pub use crate::taskbar_tool_plugin::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\taskbar_types\\src\\lib.rs\r\n\r\n````rust\r\npub mod taskbar_types;\r\npub mod taskbar_types_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::taskbar_types::*;\r\n    pub use crate::taskbar_types_plugin::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui_automation\\src\\gather_root_children.rs\r\n\r\n````rust\r\nuse std::collections::VecDeque;\r\n\r\nuse uiautomation::UIAutomation;\r\nuse uiautomation::UIElement;\r\nuse uiautomation::UITreeWalker;\r\n\r\nuse crate::gather_children::gather_children;\r\nuse crate::gather_children::StopBehaviour;\r\n\r\npub fn gather_root_children(\r\n    automation: &UIAutomation,\r\n    walker: &UITreeWalker,\r\n) -> Result<VecDeque<UIElement>, uiautomation::Error> {\r\n    let root = automation.get_root_element()?;\r\n    // println!(\"Boutta gather top level children\");\r\n    let top_level_children = gather_children(walker, &root, &StopBehaviour::RootEndEncountered);\r\n    // let condition = &automation.create_true_condition()?;\r\n    // let found = root.find_all(TreeScope::Children, condition)?;\r\n    // println!(\"Found {} top level children\", top_level_children.len());\r\n    Ok(top_level_children)\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n    use uiautomation::UIAutomation;\r\n\r\n    #[test]\r\n    fn test_gather_root_children() {\r\n        let automation = UIAutomation::new().unwrap();\r\n        let walker = automation.create_tree_walker().unwrap();\r\n        for _ in 0..100 {\r\n            let start = std::time::Instant::now();\r\n            let children = gather_root_children(&automation, &walker).unwrap();\r\n            let end = std::time::Instant::now();\r\n            let elapsed = end - start;\r\n            println!(\"Gathered {} children in {:?}\", children.len(), elapsed);\r\n            assert!(!children.is_empty());\r\n            assert!(elapsed.as_millis() < 1000);\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\hover\\src\\inspect_wheel_tool.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse cursor_hero_toolbelt_types::prelude::*;\r\nuse cursor_hero_tools::prelude::*;\r\n\r\npub struct InspectWheelToolPlugin;\r\n\r\nimpl Plugin for InspectWheelToolPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<InspectWheelTool>();\r\n        app.add_systems(Update, toolbelt_events);\r\n        app.add_systems(Update, tick);\r\n    }\r\n}\r\n\r\n#[derive(Component, Reflect, Default)]\r\nstruct InspectWheelTool;\r\n\r\nfn toolbelt_events(\r\n    mut commands: Commands,\r\n    asset_server: Res<AssetServer>,\r\n    mut reader: EventReader<ToolbeltPopulateEvent>,\r\n) {\r\n    for event in reader.read() {\r\n        let ToolbeltLoadout::Default = event.loadout else {\r\n            continue;\r\n        };\r\n        ToolSpawnConfig::<InspectWheelTool, NoInputs>::new(InspectWheelTool, event.id, event)\r\n            .with_src_path(file!().into())\r\n            .guess_name(file!())\r\n            .guess_image(file!(), &asset_server, \"png\")\r\n            .with_description(\"Swaps to inspection tools\")\r\n            .with_starting_state(StartingState::Inactive)\r\n            .spawn(&mut commands);\r\n    }\r\n}\r\n\r\nfn tick(\r\n    mut commands: Commands,\r\n    tool_query: Query<&Parent, (Added<ActiveTool>, With<InspectWheelTool>)>,\r\n    mut toolbelt_events: EventWriter<ToolbeltPopulateEvent>,\r\n) {\r\n    for toolbelt_id in tool_query.iter() {\r\n        let toolbelt_id = toolbelt_id.get();\r\n        commands.entity(toolbelt_id).despawn_descendants();\r\n        toolbelt_events.send(ToolbeltPopulateEvent {\r\n            id: toolbelt_id,\r\n            loadout: ToolbeltLoadout::Inspector,\r\n        });\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\secret\\src\\lib.rs\r\n\r\n````rust\r\npub mod secrets_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::secrets_plugin::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ollama_types\\src\\lib.rs\r\n\r\n````rust\r\npub mod ollama_types;\r\npub mod ollama_types_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::ollama_types::*;\r\n    pub use crate::ollama_types_plugin::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\pointer_types\\src\\pointer_types_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n\r\nuse crate::prelude::*;\r\n\r\npub struct PointerTypesPlugin;\r\nimpl Plugin for PointerTypesPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<Pointer>();\r\n        app.register_type::<MainPointer>();\r\n        app.configure_sets(Update, PointerSystemSet::Position);\r\n\r\n        app.add_event::<PointerReachEvent>();\r\n\r\n        app.register_type::<Hovered>();\r\n        app.register_type::<Hoverable>();\r\n        app.register_type::<Hovering>();\r\n        app.add_event::<HoverEvent>();\r\n\r\n        app.register_type::<Clickable>();\r\n        app.register_type::<Pressed>();\r\n        app.register_type::<Pressing>();\r\n        app.add_event::<ClickEvent>();\r\n        app.add_event::<ToolClickEvent>();\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\bevy\\src\\rect_expand.rs\r\n\r\n````rust\r\nuse bevy::math::IRect;\r\nuse bevy::math::IVec2;\r\n\r\nuse cursor_hero_math::prelude::Corner;\r\npub trait IExpandable {\r\n    fn expand(&self, amount: IVec2) -> IRect;\r\n    fn expand_from(&self, corner: Corner, amount: IVec2) -> IRect;\r\n}\r\nimpl IExpandable for IRect {\r\n    fn expand(&self, amount: IVec2) -> IRect {\r\n        IRect::from_center_size(self.center(), self.size() + amount)\r\n    }\r\n    fn expand_from(&self, corner: Corner, amount: IVec2) -> IRect {\r\n        match corner {\r\n            Corner::TopLeft => IRect {\r\n                min: self.min - amount,\r\n                max: self.max,\r\n            },\r\n            Corner::TopRight => IRect {\r\n                min: self.min - IVec2::new(0, amount.y),\r\n                max: self.max + IVec2::new(amount.x, 0),\r\n            },\r\n            Corner::BottomLeft => IRect {\r\n                min: self.min - IVec2::new(amount.x, 0),\r\n                max: self.max + IVec2::new(0, amount.y),\r\n            },\r\n            Corner::BottomRight => IRect {\r\n                min: self.min,\r\n                max: self.max + amount,\r\n            },\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\glados_tts_types\\src\\glados_tts_types.rs\r\n\r\n````rust\r\nuse std::time::Duration;\r\n\r\nuse bevy::prelude::*;\r\nuse bevy::utils::Instant;\r\n\r\n#[derive(Reflect, Resource, Default, Debug, Eq, PartialEq, Clone, Copy)]\r\n#[reflect(Resource)]\r\npub enum GladosTtsStatus {\r\n    #[default]\r\n    Unknown,\r\n    Alive,\r\n    Dead,\r\n    Starting {\r\n        instant: Instant,\r\n        timeout: Duration,\r\n    },\r\n}\r\n\r\n#[derive(Component, Debug, Reflect, Default)]\r\npub struct GladosTtsStatusButton {\r\n    pub visual_state: GladosTtsStatusButtonVisualState,\r\n}\r\n\r\n#[derive(Debug, Reflect, Eq, PartialEq)]\r\npub enum GladosTtsStatusButtonVisualState {\r\n    Default { status: GladosTtsStatus },\r\n    Hovered { status: GladosTtsStatus },\r\n    Pressed { status: GladosTtsStatus },\r\n}\r\nimpl Default for GladosTtsStatusButtonVisualState {\r\n    fn default() -> Self {\r\n        GladosTtsStatusButtonVisualState::Default {\r\n            status: GladosTtsStatus::Unknown,\r\n        }\r\n    }\r\n}\r\n\r\n#[derive(Component, Debug, Reflect, Default)]\r\npub struct GladosTtsVscodeButton {\r\n    pub visual_state: GladosTtsVscodeButtonVisualState,\r\n}\r\n#[derive(Debug, Reflect, Eq, PartialEq, Default)]\r\npub enum GladosTtsVscodeButtonVisualState {\r\n    #[default]\r\n    Default,\r\n}\r\n#[derive(Event, Debug, Reflect)]\r\npub enum GladosTtsVscodeEvent {\r\n    Startup,\r\n}\r\n\r\n#[derive(Event, Debug, Reflect)]\r\npub enum GladosTtsPingEvent {\r\n    Ping,\r\n    Pong { status: GladosTtsStatus },\r\n}\r\n\r\n#[derive(Event, Debug, Reflect)]\r\npub enum GladosTtsStatusEvent {\r\n    Changed { new_value: GladosTtsStatus },\r\n    Startup,\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\tools\\src\\placeholder_tool.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse leafwing_input_manager::action_state::ActionState;\r\nuse leafwing_input_manager::input_map::InputMap;\r\nuse leafwing_input_manager::prelude::*;\r\nuse leafwing_input_manager::user_input::UserInput;\r\nuse leafwing_input_manager::Actionlike;\r\n\r\nuse cursor_hero_toolbelt_types::prelude::*;\r\n\r\nuse crate::prelude::*;\r\npub struct PlaceholderToolPlugin;\r\n\r\nimpl Plugin for PlaceholderToolPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<PlaceholderTool>();\r\n        app.add_plugins(InputManagerPlugin::<PlaceholderToolAction>::default());\r\n        app.add_systems(Update, toolbelt_events);\r\n        app.add_systems(Update, handle_input);\r\n    }\r\n}\r\n\r\n#[derive(Component, Reflect, Default)]\r\nstruct PlaceholderTool;\r\n\r\n#[derive(Actionlike, PartialEq, Eq, Clone, Copy, Hash, Debug, Reflect)]\r\nenum PlaceholderToolAction {\r\n    Action1,\r\n    Action2,\r\n    Action3,\r\n}\r\n\r\nimpl PlaceholderToolAction {\r\n    fn default_gamepad_binding(&self) -> UserInput {\r\n        match self {\r\n            Self::Action1 => GamepadButtonType::South.into(),\r\n            Self::Action2 => GamepadButtonType::East.into(),\r\n            Self::Action3 => GamepadButtonType::West.into(),\r\n        }\r\n    }\r\n\r\n    fn default_mkb_binding(&self) -> UserInput {\r\n        match self {\r\n            Self::Action1 => KeyCode::ControlLeft.into(),\r\n            Self::Action2 => KeyCode::ControlRight.into(),\r\n            Self::Action3 => KeyCode::AltRight.into(),\r\n        }\r\n    }\r\n}\r\nimpl ToolAction for PlaceholderToolAction {\r\n    fn default_input_map(\r\n        _event: &ToolbeltPopulateEvent,\r\n    ) -> Option<InputMap<PlaceholderToolAction>> {\r\n        let mut input_map = InputMap::default();\r\n\r\n        for variant in PlaceholderToolAction::variants() {\r\n            input_map.insert(variant.default_mkb_binding(), variant);\r\n            input_map.insert(variant.default_gamepad_binding(), variant);\r\n        }\r\n        Some(input_map)\r\n    }\r\n}\r\n\r\nfn toolbelt_events(\r\n    mut commands: Commands,\r\n    asset_server: Res<AssetServer>,\r\n    mut reader: EventReader<ToolbeltPopulateEvent>,\r\n) {\r\n    for event in reader.read() {\r\n        let ToolbeltLoadout::Default = event.loadout else {\r\n            continue;\r\n        };\r\n        for _ in 0..1 {\r\n            // disabled for now\r\n            ToolSpawnConfig::<PlaceholderTool, PlaceholderToolAction>::new(\r\n                PlaceholderTool,\r\n                event.id,\r\n                event,\r\n            )\r\n            .with_src_path(file!().into())\r\n            .guess_name(file!())\r\n            .guess_image(file!(), &asset_server, \"png\")\r\n            .with_description(\"Balances the wheel\")\r\n            .spawn(&mut commands);\r\n        }\r\n    }\r\n}\r\n\r\nfn handle_input(actors: Query<(&ActionState<PlaceholderToolAction>, Option<&ActiveTool>)>) {\r\n    for (action_state, active_tool_tag) in actors.iter() {\r\n        if active_tool_tag.is_none() {\r\n            continue;\r\n        }\r\n        if action_state.just_pressed(PlaceholderToolAction::Action1) {\r\n            info!(\"Just pressed Action1\");\r\n        }\r\n        if action_state.just_pressed(PlaceholderToolAction::Action2) {\r\n            info!(\"Just pressed Action2\");\r\n        }\r\n        if action_state.just_pressed(PlaceholderToolAction::Action3) {\r\n            info!(\"Just pressed Action3\");\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\templates\\patterns\\new_plugin_with_types\\Cargo.toml\r\n\r\n````toml\r\n{{before_first_workspace_dependency}}\r\ncursor_hero_{{crate_name}}_types = { path = \"./crates/{{crate_name}}_types\" }\r\ncursor_hero_{{crate_name}} = { path = \"./crates/{{crate_name}}\" }\r\n{{first_workspace_dependency_onwards}}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\agent\\src\\lib.rs\r\n\r\n````rust\r\npub mod agent_movement_plugin;\r\npub mod agent_plugin;\r\npub mod agent_spawning_plugin;\r\npub mod insert_agent_toolbelt;\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\math\\src\\lib.rs\r\n\r\n````rust\r\nmod corner;\r\nmod lerp;\r\nmod math_plugin;\r\nmod shuffle;\r\n\r\npub mod prelude {\r\n    pub use crate::corner::*;\r\n    pub use crate::lerp::*;\r\n    pub use crate::math_plugin::*;\r\n    pub use crate::shuffle::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui_automation_types\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_ui_automation_types\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\nuiautomation = {workspace = true}\r\nserde = { version = \"1.0\", features = [\"derive\"] }\r\nitertools = { workspace = true }\r\nbevy-inspector-egui = { workspace = true }\r\nanyhow = {workspace = true}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\data\\src\\lib.rs\r\n\r\n````rust\r\npub mod paths;\r\npub mod sounds;\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\tools\\src\\default_wheel_tool.rs\r\n\r\n````rust\r\nuse crate::prelude::*;\r\nuse bevy::prelude::*;\r\nuse cursor_hero_toolbelt_types::prelude::*;\r\n\r\npub struct DefaultWheelToolPlugin;\r\n\r\nimpl Plugin for DefaultWheelToolPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<DefaultWheelTool>();\r\n        app.add_systems(Update, toolbelt_events);\r\n        app.add_systems(Update, tick);\r\n    }\r\n}\r\n\r\n#[derive(Component, Reflect, Default)]\r\nstruct DefaultWheelTool;\r\n\r\nfn toolbelt_events(\r\n    mut commands: Commands,\r\n    asset_server: Res<AssetServer>,\r\n    mut reader: EventReader<ToolbeltPopulateEvent>,\r\n) {\r\n    for event in reader.read() {\r\n        let (ToolbeltLoadout::Inspector\r\n        | ToolbeltLoadout::Taskbar\r\n        | ToolbeltLoadout::Chat\r\n        | ToolbeltLoadout::Keyboard\r\n        | ToolbeltLoadout::WindowPosition) = event.loadout\r\n        else {\r\n            continue;\r\n        };\r\n        ToolSpawnConfig::<DefaultWheelTool, NoInputs>::new(DefaultWheelTool, event.id, event)\r\n            .with_src_path(file!().into())\r\n            .guess_name(file!())\r\n            .guess_image(file!(), &asset_server, \"png\")\r\n            .with_description(\"Swaps to default tools\")\r\n            .with_starting_state(StartingState::Inactive)\r\n            .spawn(&mut commands);\r\n    }\r\n}\r\n\r\nfn tick(\r\n    mut commands: Commands,\r\n    tool_query: Query<&Parent, (Added<ActiveTool>, With<DefaultWheelTool>)>,\r\n    mut toolbelt_events: EventWriter<ToolbeltPopulateEvent>,\r\n) {\r\n    for toolbelt_id in tool_query.iter() {\r\n        info!(\"Switching toolbelt {:?} to default tools\", toolbelt_id);\r\n        let toolbelt_id = toolbelt_id.get();\r\n        commands.entity(toolbelt_id).despawn_descendants();\r\n        toolbelt_events.send(ToolbeltPopulateEvent {\r\n            id: toolbelt_id,\r\n            loadout: ToolbeltLoadout::Default,\r\n        });\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\worker_types\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_worker_types\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\ncrossbeam-channel = { workspace = true }\r\nanyhow = { workspace = true }\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\templates\\matchers\\new_plugin_with_types\\crates\\plugins\\Cargo.toml.py\r\n\r\n````py\r\n# {{before_first_plugins_dependency}}\r\n# cursor_hero_{{crate_name}} = { workspace = true }\r\n# {{first_plugins_dependency_onwards}}\r\n\r\ndef gather_variables(text: str) -> dict[str,str]:\r\n    # before_first_plugins_dependency\r\n    find = \"[dependencies]\"\r\n    include = True\r\n    index = text.find(find)\r\n    assert index != -1, f\"Coult not find `{find}`\"\r\n    index = index + len(find) if include else index\r\n    before_first_plugins_dependency, remaining = text[:index],text[index:]\r\n\r\n    # first_plugins_dependency_onwards\r\n    first_plugins_dependency_onwards = remaining\r\n\r\n    return {\r\n        \"before_first_plugins_dependency\": before_first_plugins_dependency,\r\n        \"first_plugins_dependency_onwards\": first_plugins_dependency_onwards,\r\n    }\r\n\r\n#region OLD CONTENT OF THIS FILE\r\n\r\n# # {{before_first_plugins_dependency}}\r\n# # cursor_hero_{{crate_name}} = { workspace = true }\r\n# # {{first_plugins_dependency_onwards}\r\n# \r\n# from typing import Tuple\r\n# \r\n# def chunk(text: str) -> Tuple[str, str]:\r\n#     index = text.find(\"[dependencies]\")\r\n#     if index == -1:\r\n#         return text, \"# !!!SPLIT FAILED!!!\"\r\n#     return text[:index], text[index:]\r\n# \r\n#endregion\r\n\r\n#region WORKSPACE CONTENT\r\n#[package]\r\n#name = \"cursor_hero_plugins\"\r\n#version = \"0.1.0\"\r\n#edition = \"2021\"\r\n#\r\n## See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n#\r\n#\r\n#[dependencies]\r\n#cursor_hero_environment_types = { workspace = true }\r\n#cursor_hero_chat_types = { workspace = true }\r\n#cursor_hero_chat = { workspace = true }\r\n#cursor_hero_tts = { workspace = true }\r\n#cursor_hero_tts_types = { workspace = true }\r\n#cursor_hero_observation_types = { workspace = true }\r\n#cursor_hero_observation = { workspace = true }\r\n#cursor_hero_inference_types = { workspace = true }\r\n#cursor_hero_inference = { workspace = true }\r\n#cursor_hero_movement_tool_types = { workspace = true }\r\n#cursor_hero_movement_tool = { workspace = true }\r\n#cursor_hero_character_types = { workspace = true }\r\n#cursor_hero_agent_types = { workspace = true }\r\n#cursor_hero_physics_debug = { workspace = true }\r\n#cursor_hero_math = { workspace = true }\r\n#cursor_hero_version = { workspace = true }\r\n#cursor_hero_pointer_types = { workspace = true }\r\n#cursor_hero_toolbelt_types = { workspace = true }\r\n#cursor_hero_sprint_tool_types = { workspace = true }\r\n#cursor_hero_sprint_tool = { workspace = true }\r\n#cursor_hero_agent = { workspace = true }\r\n#cursor_hero_taskbar = { workspace = true }\r\n#cursor_hero_environment_nametag = { workspace = true }\r\n#cursor_hero_environment = { workspace = true }\r\n#cursor_hero_xelu_prompts = { workspace = true }\r\n#cursor_hero_pause_tool = { workspace = true }\r\n#cursor_hero_wallpaper = { workspace = true }\r\n#cursor_hero_cursor_mirror = {workspace = true}\r\n#cursor_hero_hover = {workspace = true}\r\n#cursor_hero_pressure_plate = {workspace = true}\r\n#cursor_hero_level_bounds = {workspace = true}\r\n#cursor_hero_input = {workspace = true}\r\n#cursor_hero_camera = {workspace = true}\r\n#cursor_hero_character = {workspace = true}\r\n#cursor_hero_data = {workspace = true}\r\n#cursor_hero_metrics = {workspace = true}\r\n#cursor_hero_click_drag_character_movement = {workspace = true}\r\n#cursor_hero_physics = {workspace = true}\r\n#cursor_hero_pointer = {workspace = true}\r\n#cursor_hero_screen = {workspace = true}\r\n#cursor_hero_toolbelt = {workspace = true}\r\n#cursor_hero_tools = {workspace = true}\r\n#cursor_hero_ui = {workspace = true}\r\n#cursor_hero_icon = {workspace = true}\r\n#cursor_hero_winutils = {workspace = true}\r\n#cursor_hero_restart_memory = {workspace = true}\r\n#bevy = {workspace = true}\r\n#bevy_embedded_assets = { workspace = true }\r\n#bevy-inspector-egui = { workspace = true }\r\n#\r\n#[dev-dependencies]\r\n#cursor_hero_restart_memory = {workspace = true}\r\n#\r\n#endregion\r\n\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\glados_tts_types\\src\\glados_tts_types_plugin.rs\r\n\r\n````rust\r\nuse crate::prelude::*;\r\nuse bevy::prelude::*;\r\n\r\npub struct GladosTtsTypesPlugin;\r\n\r\nimpl Plugin for GladosTtsTypesPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<GladosTtsStatus>();\r\n        app.register_type::<GladosTtsStatusButton>();\r\n        app.register_type::<GladosTtsStatusButtonVisualState>();\r\n        app.register_type::<GladosTtsStatusEvent>();\r\n        app.add_event::<GladosTtsStatusEvent>();\r\n\r\n        app.register_type::<GladosTtsPingEvent>();\r\n        app.add_event::<GladosTtsPingEvent>();\r\n\r\n        app.register_type::<GladosTtsVscodeButton>();\r\n        app.register_type::<GladosTtsVscodeButtonVisualState>();\r\n        app.register_type::<GladosTtsVscodeEvent>();\r\n        app.add_event::<GladosTtsVscodeEvent>();\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\glados_tts_types\\src\\lib.rs\r\n\r\n````rust\r\npub mod glados_tts_types;\r\npub mod glados_tts_types_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::glados_tts_types::*;\r\n    pub use crate::glados_tts_types_plugin::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui_automation\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_ui_automation\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\nuiautomation = { workspace = true }\r\nitertools = { workspace = true }\r\ncursor_hero_ui_automation_types = { workspace = true }\r\ncursor_hero_winutils = { workspace = true }\r\ncursor_hero_metrics = { workspace = true }\r\nwindows = { workspace = true, features = [\r\n    \"Win32_Foundation\",\r\n    \"Win32_Security\",\r\n    \"Win32_System_Com\",\r\n    \"Win32_System_Diagnostics_ToolHelp\",\r\n    \"Win32_System_ProcessStatus\",\r\n    \"Win32_System_Threading\",\r\n    \"Win32_UI_WindowsAndMessaging\",\r\n] }\r\nimage = { workspace = true }\r\nanyhow = {workspace = true}\r\n\r\n[dev-dependencies]\r\ncursor_hero_memory_types = { workspace = true }\r\ncursor_hero_memory = { workspace = true }\r\ncursor_hero_worker = { workspace = true }\r\nbevy_egui = {workspace = true}\r\nbevy-inspector-egui = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui_automation_types\\src\\edge_ui_types.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse itertools::Itertools;\r\nuse serde::Deserialize;\r\nuse serde::Serialize;\r\nuse std::collections::VecDeque;\r\nuse std::fmt;\r\nuse std::fmt::Display;\r\nuse std::fmt::Formatter;\r\nuse uiautomation::UIElement;\r\n\r\npub enum EdgeResolveError {\r\n    BadChildCount { tried_accessing: u32 },\r\n    UI(uiautomation::Error),\r\n    UnknownSideTabKind(String),\r\n    UnknownState,\r\n}\r\nimpl From<u32> for EdgeResolveError {\r\n    fn from(tried_accessing: u32) -> Self {\r\n        EdgeResolveError::BadChildCount { tried_accessing }\r\n    }\r\n}\r\n\r\nimpl From<uiautomation::Error> for EdgeResolveError {\r\n    fn from(e: uiautomation::Error) -> Self {\r\n        EdgeResolveError::UI(e)\r\n    }\r\n}\r\nimpl TryFrom<VecDeque<UIElement>> for EdgeCrawlState {\r\n    type Error = EdgeResolveError;\r\n    fn try_from(mut kids: VecDeque<UIElement>) -> Result<Self, Self::Error> {\r\n        let state = match kids.len() {\r\n            2 => EdgeCrawlState::LeftTabClosed {\r\n                tabs: kids.pop_front().ok_or(0u32)?,\r\n                editor: kids.pop_front().ok_or(1u32)?,\r\n            },\r\n            3 => EdgeCrawlState::LeftTabOpen {\r\n                side_nav_tabs: kids.pop_front().ok_or(0u32)?,\r\n                side_nav_view: kids.pop_front().ok_or(1u32)?,\r\n                editor: kids.pop_front().ok_or(2u32)?,\r\n            },\r\n            _ => EdgeCrawlState::Unknown,\r\n        };\r\n        Ok(state)\r\n    }\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]\r\npub enum View {\r\n    Explorer {\r\n        sticky: Vec<ExplorerItem>,\r\n        items: Vec<ExplorerItem>,\r\n    },\r\n    Unknown {},\r\n}\r\nimpl Display for View {\r\n    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {\r\n        match self {\r\n            View::Explorer { sticky, items } => {\r\n                writeln!(f, \"Explorer entries:\")?;\r\n                writeln!(f, \"=== BEGIN STICKY ===\")?;\r\n                for item in sticky.iter().sorted_by_key(|x| x.bounds.min.y) {\r\n                    writeln!(\r\n                        f,\r\n                        \"{}- {} ({})\",\r\n                        \" \".repeat(item.ui_level as usize),\r\n                        item.label.clone()\r\n                            + if matches!(item.kind, ExplorerItemKind::Directory { .. }) {\r\n                                \"/\"\r\n                            } else {\r\n                                \"\"\r\n                            },\r\n                        item.path\r\n                    )?;\r\n                }\r\n                writeln!(f, \"=== END STICKY ===\")?;\r\n                for item in items.iter().sorted_by_key(|x| x.bounds.min.y) {\r\n                    writeln!(\r\n                        f,\r\n                        \"{}- {} ({})\",\r\n                        \" \".repeat(item.ui_level as usize),\r\n                        item.label.clone()\r\n                            + if matches!(item.kind, ExplorerItemKind::Directory { .. }) {\r\n                                \"/\"\r\n                            } else {\r\n                                \"\"\r\n                            },\r\n                        item.path\r\n                    )?;\r\n                }\r\n                fmt::Result::Ok(())\r\n            }\r\n            View::Unknown {} => {\r\n                writeln!(f, \"Unknown view\")?;\r\n                fmt::Result::Ok(())\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\npub enum EdgeCrawlState {\r\n    LeftTabClosed {\r\n        tabs: UIElement,\r\n        editor: UIElement,\r\n    },\r\n    LeftTabOpen {\r\n        side_nav_tabs: UIElement,\r\n        side_nav_view: UIElement,\r\n        editor: UIElement,\r\n    },\r\n    Unknown,\r\n}\r\nimpl EdgeCrawlState {\r\n    pub fn get_side_nav_tabs_root_elem(&self) -> Result<&UIElement, EdgeResolveError> {\r\n        match self {\r\n            EdgeCrawlState::LeftTabClosed { tabs, .. } => Ok(tabs),\r\n            EdgeCrawlState::LeftTabOpen {\r\n                side_nav_tabs: tabs,\r\n                ..\r\n            } => Ok(tabs),\r\n            EdgeCrawlState::Unknown => Err(EdgeResolveError::UnknownState),\r\n        }\r\n    }\r\n    pub fn get_side_nav_view_root_elem(&self) -> Result<&UIElement, EdgeResolveError> {\r\n        match self {\r\n            EdgeCrawlState::LeftTabClosed { tabs, .. } => Ok(tabs),\r\n            EdgeCrawlState::LeftTabOpen {\r\n                side_nav_view: view,\r\n                ..\r\n            } => Ok(view),\r\n            EdgeCrawlState::Unknown => Err(EdgeResolveError::UnknownState),\r\n        }\r\n    }\r\n    pub fn get_editor_root_elem(&self) -> Result<&UIElement, EdgeResolveError> {\r\n        match self {\r\n            EdgeCrawlState::LeftTabClosed { editor, .. } => Ok(editor),\r\n            EdgeCrawlState::LeftTabOpen { editor, .. } => Ok(editor),\r\n            EdgeCrawlState::Unknown => Err(EdgeResolveError::UnknownState),\r\n        }\r\n    }\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]\r\npub struct EdgeWindowHeader {}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]\r\npub struct EdgeWindowBody {\r\n    pub editor_area: EditorArea,\r\n    pub side_nav: Vec<SideTab>,\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]\r\npub struct EdgeWindowFooter {\r\n    pub cursor_position: IVec2,\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]\r\npub struct EdgeWindow {\r\n    pub focused: bool,\r\n    pub header: EdgeWindowHeader,\r\n    pub body: EdgeWindowBody,\r\n    pub footer: EdgeWindowFooter,\r\n}\r\n\r\nimpl Display for EdgeWindow {\r\n    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {\r\n        writeln!(\r\n            f,\r\n            \":D :D :D Visual Studio Code {} owo owo owo\",\r\n            if self.focused { \"(focused)\" } else { \"\" }\r\n        )?;\r\n\r\n        writeln!(f, \"Side tabs:\")?;\r\n        for tab in self.body.side_nav.iter() {\r\n            match tab {\r\n                SideTab::Open { kind, view } => {\r\n                    writeln!(f, \"- (open) {:?} {{{{\\n{}}}}}\", kind, view)?;\r\n                }\r\n                SideTab::Closed { kind } => {\r\n                    writeln!(f, \"- {:?}\", kind)?;\r\n                }\r\n            }\r\n        }\r\n\r\n        writeln!(f, \"Editor groups:\")?;\r\n        for (i, group) in self.body.editor_area.groups.iter().enumerate() {\r\n            writeln!(f, \"Group {} tabs:\", i + 1)?;\r\n            for tab in group.tabs.iter() {\r\n                if tab.active {\r\n                    writeln!(f, \"- (active) {}\", tab.title)?;\r\n                } else {\r\n                    writeln!(f, \"- {}\", tab.title)?;\r\n                }\r\n            }\r\n            if let Some(ref content) = group.content {\r\n                writeln!(\r\n                    f,\r\n                    \"Group {} buffer:\\n=======\\n{}\\n=======\",\r\n                    i + 1,\r\n                    content.content\r\n                )?;\r\n            }\r\n        }\r\n\r\n        writeln!(f, \"Cursor position: {:?}\", self.footer.cursor_position)?;\r\n\r\n        fmt::Result::Ok(())\r\n    }\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]\r\npub enum SideTab {\r\n    Closed { kind: SideTabKind },\r\n    Open { kind: SideTabKind, view: View },\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]\r\npub enum ExplorerItemKind {\r\n    File,\r\n    Directory { expanded: bool },\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]\r\npub struct ExplorerItem {\r\n    pub label: String,\r\n    pub path: String,\r\n    pub ui_position_in_set: u32,\r\n    pub ui_size_of_set: u32,\r\n    pub ui_level: u32,\r\n    pub bounds: IRect,\r\n    pub kind: ExplorerItemKind,\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]\r\npub struct EditorArea {\r\n    pub groups: Vec<EditorGroup>,\r\n}\r\nimpl EditorArea {\r\n    pub fn get_expected_automation_id() -> &'static str {\r\n        \"workbench.parts.editor\"\r\n    }\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]\r\npub struct EditorGroup {\r\n    pub tabs: Vec<EditorTab>,\r\n    pub content: Option<EditorContent>,\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]\r\npub struct EditorTab {\r\n    pub title: String,\r\n    pub active: bool,\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]\r\npub struct EditorContent {\r\n    pub content: String,\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]\r\npub enum SideTabKind {\r\n    Explorer,\r\n    Search,\r\n    SourceControl,\r\n    RunAndDebug,\r\n    Extensions,\r\n    GitLens,\r\n    Azure,\r\n    Jupyter,\r\n    Chat,\r\n    GitHubActions,\r\n    Todo,\r\n}\r\nimpl SideTabKind {\r\n    pub fn variants() -> Vec<SideTabKind> {\r\n        vec![\r\n            SideTabKind::Explorer,\r\n            SideTabKind::Search,\r\n            SideTabKind::SourceControl,\r\n            SideTabKind::RunAndDebug,\r\n            SideTabKind::Extensions,\r\n            SideTabKind::GitLens,\r\n            SideTabKind::Azure,\r\n            SideTabKind::Jupyter,\r\n            SideTabKind::Chat,\r\n            SideTabKind::GitHubActions,\r\n            SideTabKind::Todo,\r\n        ]\r\n    }\r\n    pub fn get_view_automation_id(&self) -> Option<&str> {\r\n        match self {\r\n            SideTabKind::Explorer => Some(\"workbench.view.explorer\"),\r\n            _ => None,\r\n        }\r\n    }\r\n}\r\nimpl TryFrom<String> for SideTabKind {\r\n    type Error = EdgeResolveError;\r\n    fn try_from(s: String) -> Result<Self, Self::Error> {\r\n        let before_first_lparen = s.split_once(\" (\").map(|x| x.0).unwrap_or(s.as_str());\r\n        match before_first_lparen {\r\n            \"Explorer\" => Ok(SideTabKind::Explorer),\r\n            \"Search\" => Ok(SideTabKind::Search),\r\n            \"Source Control\" => Ok(SideTabKind::SourceControl),\r\n            \"Run and Debug\" => Ok(SideTabKind::RunAndDebug),\r\n            \"Extensions\" => Ok(SideTabKind::Extensions),\r\n            \"GitLens\" => Ok(SideTabKind::GitLens),\r\n            \"Azure\" => Ok(SideTabKind::Azure),\r\n            \"Jupyter\" => Ok(SideTabKind::Jupyter),\r\n            \"Chat\" => Ok(SideTabKind::Chat),\r\n            \"GitHub Actions\" => Ok(SideTabKind::GitHubActions),\r\n            \"TODOs\" => Ok(SideTabKind::Todo),\r\n            _ => Err(EdgeResolveError::UnknownSideTabKind(s)),\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\chat\\src\\chat_bubble_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse bevy::text::Text2dBounds;\r\nuse bevy_xpbd_2d::prelude::*;\r\nuse cursor_hero_character_types::prelude::*;\r\nuse cursor_hero_chat_types::prelude::*;\r\npub struct ChatBubblePlugin;\r\n\r\nimpl Plugin for ChatBubblePlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Update, handle_chat_input_events);\r\n        app.add_systems(Update, handle_chat_events);\r\n        app.add_systems(Update, chat_bubble_lifetime);\r\n    }\r\n}\r\nfn handle_chat_input_events(\r\n    mut commands: Commands,\r\n    tool_query: Query<&mut ChatTool>,\r\n    character_query: Query<&Children, With<Character>>,\r\n    chat_input_query: Query<&Children, With<ChatInput>>,\r\n    mut text_query: Query<&mut Text>,\r\n    mut chat_input_events: EventReader<ChatInputEvent>,\r\n) {\r\n    for event in chat_input_events.read() {\r\n        match event {\r\n            ChatInputEvent::Focus {\r\n                character_id,\r\n                tool_id,\r\n                ..\r\n            } => {\r\n                if let Ok(character_children) = character_query.get(*character_id) {\r\n                    for child in character_children.iter() {\r\n                        if chat_input_query.get(*child).is_ok() {\r\n                            warn!(\"Chat input entity already exists?\");\r\n                            continue;\r\n                        }\r\n                    }\r\n                }\r\n                let starting_text = match tool_query.get(*tool_id) {\r\n                    Ok(tool) => tool.buffer.clone(),\r\n                    Err(_) => {\r\n                        warn!(\r\n                            \"Chat tool {:?} not found? Skipping chat bubble creation.\",\r\n                            tool_id\r\n                        );\r\n                        continue;\r\n                    }\r\n                };\r\n                debug!(\r\n                    \"Creating chat input entity for character {:?}\",\r\n                    character_id\r\n                );\r\n                commands.entity(*character_id).with_children(|parent| {\r\n                    let size = Vec2::new(300.0, 100.0);\r\n                    let resolution = 3.0;\r\n                    let padding = Vec2::new(10.0, 10.0);\r\n                    parent\r\n                        .spawn((\r\n                            SpriteBundle {\r\n                                sprite: Sprite {\r\n                                    color: Color::ALICE_BLUE,\r\n                                    custom_size: Some(size),\r\n                                    ..default()\r\n                                },\r\n                                transform: Transform::from_translation(Vec3::new(0.0, 100.0, -1.0)),\r\n                                ..default()\r\n                            },\r\n                            ChatInput,\r\n                            Name::new(\"Chat Input Bubble\"),\r\n                        ))\r\n                        .with_children(|parent| {\r\n                            parent.spawn((Text2dBundle {\r\n                                text: Text::from_section(\r\n                                    starting_text,\r\n                                    TextStyle {\r\n                                        font_size: 20.0 * resolution,\r\n                                        color: Color::MIDNIGHT_BLUE,\r\n                                        ..default()\r\n                                    },\r\n                                ),\r\n                                text_2d_bounds: Text2dBounds {\r\n                                    size: size * resolution - padding,\r\n                                },\r\n                                transform: Transform::from_translation(Vec3::new(0.0, 0.0, 1.0))\r\n                                    .with_scale(Vec3::new(1.0 / resolution, 1.0 / resolution, 1.0)),\r\n                                ..default()\r\n                            },));\r\n                        });\r\n                });\r\n            }\r\n            ChatInputEvent::Unfocus { character_id, .. } => {\r\n                debug!(\r\n                    \"Removing chat input entity for character {:?}\",\r\n                    character_id\r\n                );\r\n                if let Ok(character_children) = character_query.get(*character_id) {\r\n                    for child in character_children.iter() {\r\n                        if chat_input_query.get(*child).is_ok() {\r\n                            commands.entity(*child).despawn_recursive();\r\n                            commands.entity(*character_id).remove_children(&[*child]);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            ChatInputEvent::TextChanged {\r\n                character_id,\r\n                tool_id,\r\n                ..\r\n            } => {\r\n                let new_text = match tool_query.get(*tool_id) {\r\n                    Ok(tool) => tool.buffer.clone(),\r\n                    Err(_) => {\r\n                        warn!(\r\n                            \"Chat tool {:?} not found? Skipping chat bubble update.\",\r\n                            tool_id\r\n                        );\r\n                        continue;\r\n                    }\r\n                };\r\n                debug!(\r\n                    \"Updating chat input entity for character {:?}\",\r\n                    character_id\r\n                );\r\n                if let Ok(character_children) = character_query.get(*character_id) {\r\n                    for child in character_children.iter() {\r\n                        if let Ok(chat_input) = chat_input_query.get(*child) {\r\n                            let chat_input_children = chat_input;\r\n                            for child in chat_input_children.iter() {\r\n                                if let Ok(mut text) = text_query.get_mut(*child) {\r\n                                    text.sections[0].value = new_text.clone();\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                } else {\r\n                    warn!(\r\n                        \"Character {:?} not found? Skipping chat bubble update.\",\r\n                        character_id\r\n                    );\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfn handle_chat_events(\r\n    mut events: EventReader<ChatEvent>,\r\n    mut commands: Commands,\r\n    character_query: Query<&GlobalTransform, With<Character>>,\r\n) {\r\n    for event in events.read() {\r\n        match event {\r\n            ChatEvent::Chat {\r\n                character_id,\r\n                message,\r\n            } => {\r\n                if let Ok(character) = character_query.get(*character_id) {\r\n                    let character_transform = character;\r\n                    info!(\r\n                        \"Creating chat bubble for character {:?} at position {:?}\",\r\n                        character_id,\r\n                        character_transform.translation()\r\n                    );\r\n                    let size = Vec2::new(300.0, 100.0);\r\n                    let resolution = 3.0;\r\n                    let padding = Vec2::new(10.0, 10.0);\r\n                    let mut transform = character_transform.compute_transform();\r\n                    transform.translation -= Vec3::new(0.0, 100.0, 10.0);\r\n                    commands\r\n                        .spawn((\r\n                            SpriteBundle {\r\n                                sprite: Sprite {\r\n                                    color: Color::BLACK,\r\n                                    custom_size: Some(size),\r\n                                    ..default()\r\n                                },\r\n                                transform,\r\n                                ..default()\r\n                            },\r\n                            ChatBubble {\r\n                                lifetime: Timer::from_seconds(25.0, TimerMode::Once),\r\n                            },\r\n                            RigidBody::Dynamic,\r\n                            LinearVelocity(Vec2::new(0.0, -30.0)),\r\n                            Collider::cuboid(size.x, size.y),\r\n                            Name::new(\"Chat Bubble\"),\r\n                        ))\r\n                        .with_children(|parent| {\r\n                            parent.spawn((Text2dBundle {\r\n                                text: Text::from_section(\r\n                                    message.clone(),\r\n                                    TextStyle {\r\n                                        font_size: 20.0 * resolution,\r\n                                        color: Color::WHITE,\r\n                                        ..default()\r\n                                    },\r\n                                ),\r\n                                text_2d_bounds: Text2dBounds {\r\n                                    size: size * resolution - padding,\r\n                                },\r\n                                transform: Transform::from_translation(Vec3::new(0.0, 0.0, 1.0))\r\n                                    .with_scale(Vec3::new(1.0 / resolution, 1.0 / resolution, 1.0)),\r\n                                ..default()\r\n                            },));\r\n                        });\r\n                } else {\r\n                    warn!(\r\n                        \"Character {:?} not found? Skipping chat bubble creation.\",\r\n                        character_id\r\n                    );\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfn chat_bubble_lifetime(\r\n    mut commands: Commands,\r\n    time: Res<Time>,\r\n    mut query: Query<(Entity, &mut ChatBubble)>,\r\n) {\r\n    for (entity, mut chat_bubble) in query.iter_mut() {\r\n        chat_bubble.lifetime.tick(time.delta());\r\n        if chat_bubble.lifetime.finished() {\r\n            commands.entity(entity).despawn_recursive();\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\data\\src\\paths.rs\r\n\r\n````rust\r\npub const CURSOR_HERO_GIT_DIR: &str = \"D:/Repos/Games/Cursor-Hero/\";\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui_watcher\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_ui_watcher\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\ncursor_hero_ui_watcher_types = { workspace = true }\r\ncrossbeam-channel = { workspace = true }\r\ncursor_hero_ui_automation = { workspace = true }\r\ncursor_hero_environment_types = { workspace = true }\r\ncursor_hero_observation_types = { workspace = true }\r\ncursor_hero_memory_types = { workspace = true }\r\ncursor_hero_character_types = { workspace = true }\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\src\\main.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse cursor_hero_plugins::prelude::*;\r\nuse cursor_hero_version::version_plugin::VersionPlugin;\r\n\r\nenum LaunchMode {\r\n    Default,\r\n    Inspect,\r\n}\r\n\r\nfn main() {\r\n    let args = std::env::args().collect::<Vec<String>>();\r\n    let launch_mode = match args.get(1).map(|s| s.as_str()) {\r\n        Some(\"inspect\") => LaunchMode::Inspect,\r\n        _ => LaunchMode::Default,\r\n    };\r\n\r\n    let mut app = App::new();\r\n    app.add_plugins(VersionPlugin(env!(\"CARGO_PKG_VERSION\").to_string()));\r\n\r\n    match launch_mode {\r\n        LaunchMode::Default => {\r\n            app.add_plugins(DefaultLaunchModePlugin);\r\n        }\r\n        LaunchMode::Inspect => {\r\n            app.add_plugins(InspectLaunchModePlugin);\r\n        }\r\n    }\r\n    app.run();\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\glados_tts\\src\\glados_tts_inference_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse crossbeam_channel::bounded;\r\nuse crossbeam_channel::Receiver;\r\nuse crossbeam_channel::Sender;\r\nuse cursor_hero_inference_types::prelude::*;\r\nuse std::thread;\r\n\r\npub struct GladosTtsInferencePlugin;\r\n\r\nimpl Plugin for GladosTtsInferencePlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Startup, create_worker_thread);\r\n        app.add_systems(Update, bridge_requests);\r\n        app.add_systems(Update, bridge_responses);\r\n    }\r\n}\r\n\r\n#[derive(Debug)]\r\nenum GameboundMessage {\r\n    Response {\r\n        session_id: Entity,\r\n        prompt: SpeechPrompt,\r\n        response: Vec<u8>,\r\n    },\r\n}\r\n\r\n#[derive(Debug)]\r\nenum ThreadboundMessage {\r\n    Generate {\r\n        session_id: Entity,\r\n        prompt: SpeechPrompt,\r\n    },\r\n}\r\n\r\n#[derive(Resource)]\r\nstruct Bridge {\r\n    pub sender: Sender<ThreadboundMessage>,\r\n    pub receiver: Receiver<GameboundMessage>,\r\n}\r\n\r\nfn create_worker_thread(mut commands: Commands) {\r\n    let (game_tx, game_rx) = bounded::<_>(10);\r\n    let (thread_tx, thread_rx) = bounded::<_>(10);\r\n    commands.insert_resource(Bridge {\r\n        sender: thread_tx,\r\n        receiver: game_rx,\r\n    });\r\n\r\n    let game_tx_clone = game_tx.clone();\r\n    thread::Builder::new()\r\n        .name(\"GLaDOSTTS thread\".to_string())\r\n        .spawn(move || {\r\n            let rt = tokio::runtime::Runtime::new().unwrap();\r\n            rt.block_on(async {\r\n                let game_tx = game_tx_clone;\r\n                loop {\r\n                    let msg = match thread_rx.recv() {\r\n                        Ok(msg) => msg,\r\n                        Err(_) => {\r\n                            error!(\"Threadbound channel failure, exiting\");\r\n                            break;\r\n                        }\r\n                    };\r\n                    match msg {\r\n                        ThreadboundMessage::Generate { session_id, prompt } => {\r\n                            debug!(\"Worker received generate request for session {:?}, generating response\", session_id);\r\n                            let prompt_str = match &prompt {\r\n                                SpeechPrompt::Raw { content } => content,\r\n                            };\r\n                            let data = match crate::glados_tts::generate(prompt_str).await {\r\n                                Ok(data) => data,\r\n                                Err(e) => {\r\n                                    error!(\"Failed to generate TTS: {:?}\", e);\r\n                                    continue;\r\n                                }\r\n                            };\r\n                            if let Err(e) = game_tx.send(GameboundMessage::Response {\r\n                                session_id,\r\n                                prompt: prompt.clone(),\r\n                                response: data,\r\n                            }) {\r\n                                error!(\"Gamebound channel failure, exiting: {:?}\", e);\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                    std::thread::sleep(std::time::Duration::from_millis(50));\r\n                }\r\n            });\r\n        })\r\n        .expect(\"Failed to spawn thread\");\r\n}\r\n\r\nfn bridge_requests(bridge: ResMut<Bridge>, mut events: EventReader<SpeechInferenceEvent>) {\r\n    for event in events.read() {\r\n        if let SpeechInferenceEvent::Request { session_id, prompt } = event {\r\n            debug!(\r\n                \"Received generate request for session {:?}, sending over bridge to worker thread\",\r\n                session_id\r\n            );\r\n            if let Err(e) = bridge.sender.send(ThreadboundMessage::Generate {\r\n                session_id: *session_id,\r\n                prompt: prompt.clone(),\r\n            }) {\r\n                error!(\"Threadbound channel failure: {:?}\", e);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfn bridge_responses(bridge: ResMut<Bridge>, mut events: EventWriter<SpeechInferenceEvent>) {\r\n    for msg in bridge.receiver.try_iter() {\r\n        match msg {\r\n            GameboundMessage::Response {\r\n                session_id,\r\n                prompt,\r\n                response,\r\n            } => {\r\n                debug!(\r\n                    \"Received bridge response for session {:?}, sending game event\",\r\n                    session_id\r\n                );\r\n                events.send(SpeechInferenceEvent::Response {\r\n                    session_id,\r\n                    prompt,\r\n                    wav: response,\r\n                });\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\tools\\src\\window_drag_tool.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse bevy::window::PrimaryWindow;\r\nuse bevy::winit::WinitWindows;\r\nuse bevy_inspector_egui::bevy_egui::EguiContext;\r\nuse cursor_hero_toolbelt_types::prelude::*;\r\nuse leafwing_input_manager::prelude::*;\r\n\r\nuse crate::prelude::*;\r\n\r\npub struct WindowDragToolPlugin;\r\n\r\nimpl Plugin for WindowDragToolPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<WindowDragTool>();\r\n        app.register_type::<WindowDragToolInteractable>();\r\n        app.add_plugins(InputManagerPlugin::<WindowDragToolAction>::default());\r\n        app.add_systems(Update, toolbelt_events);\r\n        app.add_systems(Update, handle_input);\r\n    }\r\n}\r\n\r\n#[derive(Component, Reflect, Default)]\r\nstruct WindowDragTool;\r\n\r\nfn toolbelt_events(\r\n    mut commands: Commands,\r\n    asset_server: Res<AssetServer>,\r\n    mut reader: EventReader<ToolbeltPopulateEvent>,\r\n) {\r\n    for event in reader.read() {\r\n        let ToolbeltLoadout::Default = event.loadout else {\r\n            continue;\r\n        };\r\n        ToolSpawnConfig::<WindowDragTool, WindowDragToolAction>::new(\r\n            WindowDragTool,\r\n            event.id,\r\n            event,\r\n        )\r\n        .with_src_path(file!().into())\r\n        .guess_name(file!())\r\n        .guess_image(file!(), &asset_server, \"png\")\r\n        .with_description(\"Drag the window from its body\")\r\n        .spawn(&mut commands);\r\n    }\r\n}\r\n\r\n#[derive(Actionlike, PartialEq, Eq, Clone, Copy, Hash, Debug, Reflect)]\r\nenum WindowDragToolAction {\r\n    Drag,\r\n}\r\n\r\nimpl WindowDragToolAction {\r\n    fn default_gamepad_binding(&self) -> UserInput {\r\n        match self {\r\n            Self::Drag => GamepadButtonType::LeftThumb.into(),\r\n        }\r\n    }\r\n\r\n    fn default_mkb_binding(&self) -> UserInput {\r\n        match self {\r\n            Self::Drag => MouseButton::Left.into(),\r\n        }\r\n    }\r\n}\r\nimpl ToolAction for WindowDragToolAction {\r\n    fn default_input_map(_event: &ToolbeltPopulateEvent) -> Option<InputMap<WindowDragToolAction>> {\r\n        let mut input_map = InputMap::default();\r\n\r\n        for variant in WindowDragToolAction::variants() {\r\n            input_map.insert(variant.default_mkb_binding(), variant);\r\n            input_map.insert(variant.default_gamepad_binding(), variant);\r\n        }\r\n        Some(input_map)\r\n    }\r\n}\r\n\r\n#[derive(Component, Reflect)]\r\npub struct WindowDragToolInteractable;\r\n\r\nfn handle_input(\r\n    tool_query: Query<&ActionState<WindowDragToolAction>, With<ActiveTool>>,\r\n    window_query: Query<Entity, With<PrimaryWindow>>,\r\n    winit_windows: NonSend<WinitWindows>,\r\n    egui_context_query: Query<&EguiContext, With<PrimaryWindow>>,\r\n) {\r\n    let Ok(egui_context) = egui_context_query.get_single() else {\r\n        return;\r\n    };\r\n    let hovering_over_egui = egui_context.clone().get_mut().is_pointer_over_area();\r\n    for action_state in tool_query.iter() {\r\n        if action_state.just_pressed(WindowDragToolAction::Drag) {\r\n            if hovering_over_egui {\r\n                continue;\r\n            }\r\n            let Ok(window_id) = window_query.get_single() else {\r\n                error!(\"No primary window found\");\r\n                return;\r\n            };\r\n            if let Some(winit_window) = winit_windows.get_window(window_id) {\r\n                // winit_window.window_state_lock\r\n                if let Err(x) = winit_window.drag_window() {\r\n                    error!(\"Failed to drag window: {:?}\", x);\r\n                }\r\n            }\r\n            return;\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\floaty_nametag\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_floaty_nametag\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\ncursor_hero_floaty_nametag_types = { workspace = true }\r\nbevy_xpbd_2d = { workspace = true }\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\text_asset_types\\src\\text_asset_types_plugin.rs\r\n\r\n````rust\r\nuse crate::prelude::*;\r\nuse bevy::prelude::*;\r\n\r\npub struct TextAssetTypesPlugin;\r\n\r\nimpl Plugin for TextAssetTypesPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<TextAsset>();\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui_automation\\examples\\ui_snapshot_example.rs\r\n\r\n````rust\r\nuse bevy::log::LogPlugin;\r\nuse bevy::prelude::*;\r\nuse bevy::window::ExitCondition;\r\nuse cursor_hero_memory_types::prelude::get_persist_file;\r\nuse cursor_hero_memory_types::prelude::Usage;\r\nuse cursor_hero_ui_automation::prelude::*;\r\nuse cursor_hero_worker::prelude::*;\r\nuse std::io::Write;\r\nfn main() {\r\n    let mut app = App::new();\r\n    app.add_plugins(\r\n        DefaultPlugins\r\n            .set(LogPlugin {\r\n                level: bevy::log::Level::DEBUG,\r\n                filter: \"\r\ninfo,\r\nwgpu_core=warn,\r\nwgpu_hal=warn,\r\nui_snapshot_example=trace,\r\ncursor_hero_worker=debug,\r\n\"\r\n                .replace('\\n', \"\")\r\n                .trim()\r\n                .into(),\r\n            })\r\n            .set(WindowPlugin {\r\n                primary_window: None,\r\n                exit_condition: ExitCondition::DontExit,\r\n                ..default()\r\n            })\r\n            .build(),\r\n    );\r\n    app.add_plugins(WorkerPlugin {\r\n        config: WorkerConfig::<ThreadboundUISnapshotMessage, GameboundUISnapshotMessage> {\r\n            name: \"ui_snapshot\".to_string(),\r\n            is_ui_automation_thread: true,\r\n            handle_threadbound_message: handle_threadbound_message,\r\n            ..default()\r\n        },\r\n    });\r\n    app.add_systems(Update, trigger);\r\n    app.add_systems(Update, receive);\r\n    app.run();\r\n}\r\n\r\n#[derive(Debug, Reflect, Clone, Event)]\r\nenum ThreadboundUISnapshotMessage {\r\n    TakeSnapshot,\r\n}\r\nimpl Message for ThreadboundUISnapshotMessage {}\r\n\r\n#[derive(Debug, Reflect, Clone, Event)]\r\nenum GameboundUISnapshotMessage {\r\n    Snapshot(UISnapshot),\r\n}\r\nimpl Message for GameboundUISnapshotMessage {}\r\n\r\nfn handle_threadbound_message(\r\n    msg: &ThreadboundUISnapshotMessage,\r\n    reply_tx: &Sender<GameboundUISnapshotMessage>,\r\n) -> anyhow::Result<()> {\r\n    let ThreadboundUISnapshotMessage::TakeSnapshot = msg;\r\n    debug!(\"taking snapshot\");\r\n    let snapshot = take_snapshot()?;\r\n    if let Err(e) = reply_tx.send(GameboundUISnapshotMessage::Snapshot(snapshot)) {\r\n        error!(\"Failed to send snapshot: {:?}\", e);\r\n    }\r\n    Ok(())\r\n}\r\n\r\nfn trigger(\r\n    mut cooldown: Local<Option<Timer>>,\r\n    time: Res<Time>,\r\n    mut events: EventWriter<ThreadboundUISnapshotMessage>,\r\n) {\r\n    let should_tick = if let Some(cooldown) = cooldown.as_mut() {\r\n        if cooldown.tick(time.delta()).just_finished() {\r\n            cooldown.reset();\r\n            true\r\n        } else {\r\n            false\r\n        }\r\n    } else {\r\n        cooldown.replace(Timer::from_seconds(3.0, TimerMode::Repeating));\r\n        true\r\n    };\r\n    if !should_tick {\r\n        return;\r\n    }\r\n    events.send(ThreadboundUISnapshotMessage::TakeSnapshot);\r\n}\r\n\r\nfn receive(mut snapshot: EventReader<GameboundUISnapshotMessage>) {\r\n    for msg in snapshot.read() {\r\n        match msg {\r\n            GameboundUISnapshotMessage::Snapshot(snapshot) => {\r\n                debug!(\"received snapshot, writing to file\");\r\n                match get_persist_file(\r\n                    memory_config.as_ref(),\r\n                    file!(),\r\n                    \"ui_snapshot.txt\",\r\n                    Usage::Persist,\r\n                ) {\r\n                    Ok(mut file) => {\r\n                        if let Err(e) = file.write_all(snapshot.to_string().as_bytes()) {\r\n                            debug!(\"Failed to write to file: {:?}\", e);\r\n                        }\r\n                    }\r\n                    Err(e) => {\r\n                        error!(\"Failed to open file: {:?}\", e);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui_watcher_types\\src\\lib.rs\r\n\r\n````rust\r\npub mod ui_watcher_types;\r\npub mod ui_watcher_types_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::ui_watcher_types::*;\r\n    pub use crate::ui_watcher_types_plugin::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\voice_to_text\\src\\voice_to_text_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse cursor_hero_voice_to_text_types::voice_to_text_types::VoiceToTextStatus;\r\n\r\nuse crate::voice_to_text_button_plugin::VoiceToTextButtonPlugin;\r\nuse crate::voice_to_text_ping_plugin::VoiceToTextPingPlugin;\r\nuse crate::voice_to_text_worker_plugin::VoiceToTextWorkerPlugin;\r\n\r\npub struct VoiceToTextPlugin;\r\n\r\nimpl Plugin for VoiceToTextPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.init_resource::<VoiceToTextStatus>();\r\n        app.add_plugins(VoiceToTextButtonPlugin);\r\n        app.add_plugins(VoiceToTextPingPlugin);\r\n        app.add_plugins(VoiceToTextWorkerPlugin);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\templates\\patterns\\new_plugin_with_types\\crates\\{{crate_name}}_types\\src\\lib.rs\r\n\r\n````rust\r\nmod {{crate_name}}_types_plugin;\r\nmod {{crate_name}}_types;\r\n\r\npub mod prelude {\r\n    pub use crate::{{crate_name}}_types::*;\r\n    pub use crate::{{crate_name}}_types_plugin::*;\r\n}\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\calculator_app_types\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_calculator_app_types\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\environment_nametag\\src\\lib.rs\r\n\r\n````rust\r\npub mod environment_nametag_plugin;\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ollama\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_ollama\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\ncursor_hero_ollama_types = { workspace = true }\r\nollama-rs = { workspace = true }\r\ncrossbeam-channel = { workspace = true }\r\ncursor_hero_inference_types = {workspace = true}\r\ncursor_hero_math = {workspace = true}\r\ncursor_hero_pointer_types = {workspace = true}\r\ncursor_hero_environment_types = {workspace = true}\r\ncursor_hero_text_asset_types = {workspace = true}\r\ntokio = {workspace = true}\r\nreqwest = {workspace = true, features=[\"json\"]}\r\nserde = { version = \"1.0\", features = [\"derive\"] }\r\nserde_json = \"1.0\"\r\nbevy_xpbd_2d = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ollama\\src\\ollama_inference_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse crossbeam_channel::bounded;\r\nuse crossbeam_channel::Receiver;\r\nuse crossbeam_channel::Sender;\r\nuse cursor_hero_inference_types::prelude::*;\r\nuse cursor_hero_text_asset_types::prelude::*;\r\nuse std::thread;\r\n\r\npub struct OllamaInferencePlugin;\r\n\r\nimpl Plugin for OllamaInferencePlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Startup, create_worker_thread);\r\n        app.add_systems(Update, bridge_generate_requests);\r\n        app.add_systems(Update, bridge_generate_responses);\r\n    }\r\n}\r\n\r\n#[derive(Debug)]\r\nenum GameboundMessage {\r\n    Response {\r\n        session_id: Entity,\r\n        prompt: MaterializedTextPrompt,\r\n        response: String,\r\n    },\r\n}\r\n\r\n#[derive(Debug)]\r\nenum ThreadboundMessage {\r\n    Generate {\r\n        session_id: Entity,\r\n        prompt: MaterializedTextPrompt,\r\n    },\r\n}\r\n\r\n#[derive(Resource)]\r\nstruct Bridge {\r\n    pub sender: Sender<ThreadboundMessage>,\r\n    pub receiver: Receiver<GameboundMessage>,\r\n}\r\n\r\nfn create_worker_thread(mut commands: Commands) {\r\n    let (game_tx, game_rx) = bounded::<_>(10);\r\n    let (thread_tx, thread_rx) = bounded::<_>(10);\r\n    commands.insert_resource(Bridge {\r\n        sender: thread_tx,\r\n        receiver: game_rx,\r\n    });\r\n\r\n    let game_tx_clone = game_tx.clone();\r\n    thread::Builder::new()\r\n        .name(\"Ollama thread\".to_string())\r\n        .spawn(move || {\r\n            let rt = tokio::runtime::Runtime::new().unwrap();\r\n            rt.block_on(async {\r\n                let game_tx = game_tx_clone;\r\n                loop {\r\n                    let msg = match thread_rx.recv() {\r\n                        Ok(msg) => msg,\r\n                        Err(_) => {\r\n                            error!(\"Threadbound channel failure, exiting\");\r\n                            break;\r\n                        }\r\n                    };\r\n                    match msg {\r\n                        ThreadboundMessage::Generate { session_id, prompt } => {\r\n                            debug!(\"Worker received generate request for session {:?}, generating response\", session_id);\r\n                            let data = match crate::ollama::generate(&prompt.materialized, prompt.prompt.options()).await {\r\n                                Ok(data) => data,\r\n                                Err(e) => {\r\n                                    error!(\"Failed to generate: {:?}\", e);\r\n                                    continue;\r\n                                }\r\n                            };\r\n                            if let Err(e) = game_tx.send(GameboundMessage::Response {\r\n                                session_id,\r\n                                prompt: prompt.clone(),\r\n                                response: data,\r\n                            }) {\r\n                                error!(\"Gamebound channel failure, exiting: {:?}\", e);\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                    std::thread::sleep(std::time::Duration::from_millis(50));\r\n                }\r\n            });\r\n        })\r\n        .expect(\"Failed to spawn thread\");\r\n}\r\n\r\nfn bridge_generate_requests(\r\n    bridge: ResMut<Bridge>,\r\n    mut events: EventReader<TextInferenceEvent>,\r\n    prompts: Res<TextPromptHandles>,\r\n    text_assets: Res<Assets<TextAsset>>,\r\n) {\r\n    for event in events.read() {\r\n        if let TextInferenceEvent::Request { session_id, prompt } = event {\r\n            debug!(\r\n                \"Received generate request for session {:?}, sending over bridge to worker thread\",\r\n                session_id\r\n            );\r\n\r\n            // we gotta load the prompt from the asset server to materialize it before we can send it\r\n            let handle = match prompt {\r\n                TextPrompt::Raw { .. } => &prompts.raw,\r\n                TextPrompt::Chat { .. } => &prompts.chat,\r\n            };\r\n            let prompt_asset = match text_assets.get(handle) {\r\n                Some(asset) => asset,\r\n                None => {\r\n                    error!(\r\n                        \"Failed to load prompt asset {:?} for prompt type {:?}\",\r\n                        handle,\r\n                        std::any::type_name_of_val(&prompt)\r\n                    );\r\n                    continue;\r\n                }\r\n            };\r\n            let materialized_prompt = MaterializedTextPrompt {\r\n                prompt: prompt.clone(),\r\n                materialized: match prompt {\r\n                    TextPrompt::Raw { content, .. } => {\r\n                        prompt_asset.value.replace(\"{{content}}\", content)\r\n                    }\r\n                    TextPrompt::Chat { chat_history, .. } => {\r\n                        prompt_asset.value.replace(\"{{chat_history}}\", chat_history)\r\n                    }\r\n                },\r\n            };\r\n\r\n            info!(\r\n                \"Sending prompt to text generation worker:\\n{}\",\r\n                materialized_prompt.materialized\r\n            );\r\n\r\n            if let Err(e) = bridge.sender.send(ThreadboundMessage::Generate {\r\n                session_id: *session_id,\r\n                prompt: materialized_prompt,\r\n            }) {\r\n                error!(\"Threadbound channel failure: {}\", e);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfn bridge_generate_responses(bridge: ResMut<Bridge>, mut events: EventWriter<TextInferenceEvent>) {\r\n    for msg in bridge.receiver.try_iter() {\r\n        match msg {\r\n            GameboundMessage::Response {\r\n                session_id,\r\n                prompt,\r\n                response,\r\n            } => {\r\n                let event = TextInferenceEvent::Response {\r\n                    session_id,\r\n                    response,\r\n                    prompt,\r\n                };\r\n                debug!(\"Received bridge response, sending game event {:?}\", event);\r\n                events.send(event);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\environment\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_environment\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\ncursor_hero_environment_types = { workspace = true}\r\ncursor_hero_level_bounds = { workspace = true }\r\ncursor_hero_pointer_types = { workspace = true }\r\nbevy_xpbd_2d = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\memory\\src\\agent_observation_memory_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse bevy::utils::HashMap;\r\nuse cursor_hero_character_types::prelude::*;\r\n\r\nuse cursor_hero_memory_types::prelude::*;\r\nuse cursor_hero_observation_types::observation_types::ObservationBuffer;\r\nuse cursor_hero_observation_types::observation_types::SomethingObservableHappenedEvent;\r\nuse serde::Deserialize;\r\nuse serde::Serialize;\r\n\r\npub struct AgentObservationMemoryPlugin;\r\n\r\nimpl Plugin for AgentObservationMemoryPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.insert_resource(MainCharacterMemoryConfig::default());\r\n        app.add_systems(Update, persist.pipe(handle_persist_errors));\r\n        app.add_systems(Update, restore.pipe(handle_restore_errors));\r\n    }\r\n}\r\nconst PERSIST_FILE_NAME: &str = \"agent_memory.json\";\r\n\r\n// not moved to lib to ensure log contains this module name\r\nfn handle_persist_errors(In(result): In<Result<PersistSuccess, PersistError>>) {\r\n    if let Err(e) = result {\r\n        error!(\"Persist error occurred: {:?}\", e);\r\n    } else if let Ok(PersistSuccess::WritePerformed) = result {\r\n        debug!(\"Persisted succeeded\");\r\n    }\r\n}\r\n\r\nfn handle_restore_errors(In(result): In<Result<RestoreSuccess, RestoreError>>) {\r\n    if let Err(e) = result {\r\n        error!(\"Restore error occurred: {:?}\", e);\r\n    } else if let Ok(RestoreSuccess::Performed) = result {\r\n        info!(\"Restore succeeded\");\r\n    }\r\n}\r\n\r\n#[derive(Debug, Resource, Reflect)]\r\n#[reflect(Resource)]\r\nstruct MainCharacterMemoryConfig {\r\n    pub persist_cooldown: Timer,\r\n}\r\nimpl Default for MainCharacterMemoryConfig {\r\n    fn default() -> Self {\r\n        Self {\r\n            persist_cooldown: Timer::from_seconds(10.0, TimerMode::Repeating),\r\n        }\r\n    }\r\n}\r\n\r\n#[derive(Debug, Serialize, Deserialize, PartialEq, Clone, Default)]\r\nstruct DiskData {\r\n    observations_by_observer_name: HashMap<String, ObservationBuffer>,\r\n}\r\n\r\nfn persist(\r\n    mut config: ResMut<MainCharacterMemoryConfig>,\r\n    memory_config: Res<MemoryConfig>,\r\n    mut debounce: Local<Option<DiskData>>,\r\n    time: Res<Time>,\r\n    agent_query: Query<(&Name, &ObservationBuffer), With<AgentCharacter>>,\r\n) -> Result<PersistSuccess, PersistError> {\r\n    if !config.persist_cooldown.tick(time.delta()).just_finished() {\r\n        return Ok(PersistSuccess::Cooldown);\r\n    }\r\n\r\n    let mut data = DiskData::default();\r\n    for agent in agent_query.iter() {\r\n        data.observations_by_observer_name\r\n            .insert(agent.0.as_str().to_string(), agent.1.clone());\r\n    }\r\n\r\n    if debounce.is_none() || debounce.as_ref().unwrap() != &data {\r\n        let file = get_persist_file(memory_config.as_ref(), PERSIST_FILE_NAME, Usage::Persist)\r\n            .map_err(PersistError::Io)?;\r\n        write_to_disk(file, data.clone())?;\r\n        *debounce = Some(data);\r\n        Ok(PersistSuccess::WritePerformed)\r\n    } else {\r\n        Ok(PersistSuccess::Debounce)\r\n    }\r\n}\r\n\r\nfn restore(\r\n    memory_config: Res<MemoryConfig>,\r\n    mut agent_query: Query<(Entity, &Name, &mut ObservationBuffer), Added<AgentCharacter>>,\r\n    mut observation_events: EventWriter<SomethingObservableHappenedEvent>,\r\n) -> Result<RestoreSuccess, RestoreError> {\r\n    if agent_query.is_empty() {\r\n        return Ok(RestoreSuccess::NoAction);\r\n    }\r\n\r\n    let file = get_persist_file(memory_config.as_ref(), PERSIST_FILE_NAME, Usage::Restore)\r\n        .map_err(RestoreError::Io)?;\r\n    let mut data: DiskData = read_from_disk(file)?;\r\n    info!(\r\n        \"Restoring agent memories, found {} entries\",\r\n        data.observations_by_observer_name.len()\r\n    );\r\n    for agent in agent_query.iter_mut() {\r\n        let (agent_id, agent_name, mut agent_buffer) = agent;\r\n        let agent_name = agent_name.as_str();\r\n        // Each agent's observations is keyed by its name in the save file.\r\n        if let Some(buffer) = data.observations_by_observer_name.remove(agent_name) {\r\n            // Previous observations that reference entity IDs will have odd appearances in world inspectors because the IDs have been reused from restarts.\r\n\r\n            *agent_buffer = buffer;\r\n\r\n            let event = SomethingObservableHappenedEvent::MemoryRestored {\r\n                observation_buffer_id: agent_id,\r\n            };\r\n            debug!(\"Sending event {:?}\", event);\r\n            observation_events.send(event);\r\n        }\r\n    }\r\n    Ok(RestoreSuccess::Performed)\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\sprint_tool_types\\src\\lib.rs\r\n\r\n````rust\r\npub mod sprint_tool_types_plugin;\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui_automation\\src\\ui_automation_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n\r\npub struct UiAutomationPlugin;\r\n\r\nimpl Plugin for UiAutomationPlugin {\r\n    fn build(&self, _app: &mut App) {}\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\camera\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_camera\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\nbevy_xpbd_2d = { workspace = true }\r\nbevy_egui = {workspace = true}\r\nleafwing-input-manager = { workspace = true }\r\ncursor_hero_physics = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\floaty_nametag\\src\\lib.rs\r\n\r\n````rust\r\npub mod floaty_nametag_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::floaty_nametag_plugin::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\physics_debug\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_physics_debug\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\nbevy_xpbd_2d = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\pointer\\src\\pointer_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse cursor_hero_pointer_types::pointer_action_types::PointerActionPlugin;\r\n\r\nuse crate::pointer_click_plugin::PointerClickPlugin;\r\nuse crate::pointer_hover_plugin::PointerHoverPlugin;\r\nuse crate::pointer_positioning_plugin::PointerPositioningPlugin;\r\nuse crate::pointer_reach_plugin::PointerReachPlugin;\r\nuse crate::pointer_spawning_plugin::PointerSpawningPlugin;\r\n\r\npub struct PointerPlugin;\r\nimpl Plugin for PointerPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_plugins((\r\n            PointerHoverPlugin,\r\n            PointerReachPlugin,\r\n            PointerClickPlugin,\r\n            PointerPositioningPlugin,\r\n            PointerSpawningPlugin,\r\n            PointerActionPlugin,\r\n        ));\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\taskbar\\src\\lib.rs\r\n\r\n````rust\r\npub mod taskbar_plugin;\r\npub mod taskbar_spawn_plugin;\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui_automation\\src\\taskbar.rs\r\n\r\n````rust\r\nuse crate::gather_children::gather_children;\r\nuse crate::gather_children::StopBehaviour;\r\nuse crate::prelude::*;\r\nuse uiautomation::controls::ControlType;\r\nuse uiautomation::UIAutomation;\r\n\r\npub fn get_taskbar() -> Result<Taskbar, uiautomation::Error> {\r\n    let automation = UIAutomation::new()?;\r\n    let root = automation.get_root_element()?;\r\n    let taskbar_matcher = automation\r\n        .create_matcher()\r\n        .from(root)\r\n        .classname(\"MSTaskListWClass\")\r\n        .control_type(ControlType::ToolBar);\r\n    let taskbar = taskbar_matcher.find_first()?;\r\n    let taskbar_entry_walker = automation.create_tree_walker()?;\r\n    let taskbar_entries = gather_children(\r\n        &taskbar_entry_walker,\r\n        &taskbar,\r\n        &StopBehaviour::TaskbarEndEncountered,\r\n    );\r\n    let entries = taskbar_entries\r\n        .into_iter()\r\n        .map(|entry| TaskbarEntry {\r\n            name: entry.get_name().unwrap_or_default(),\r\n            bounds: entry\r\n                .get_bounding_rectangle()\r\n                .unwrap_or_default()\r\n                .to_bevy_irect(),\r\n        })\r\n        .collect();\r\n    Ok(Taskbar { entries })\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use crate::prelude::get_taskbar;\r\n\r\n    #[test]\r\n    fn test_get_taskbar() {\r\n        let taskbar = get_taskbar().unwrap();\r\n        assert!(taskbar.entries.len() > 0);\r\n        // print the entries\r\n        for entry in taskbar.entries {\r\n            println!(\"entry: {:?}\", entry);\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\agent_types\\src\\agent_types.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n\r\n#[derive(Component, Reflect, Debug)]\r\npub struct Agent;\r\n\r\n#[derive(Reflect, Eq, PartialEq, Debug)]\r\npub enum AgentAppearance {\r\n    Default,\r\n}\r\nimpl AgentAppearance {\r\n    pub fn get_texture_path(&self) -> &'static str {\r\n        match self {\r\n            Self::Default => \"textures/agent/default_agent.png\",\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\brick_types\\src\\brick_types_plugin.rs\r\n\r\n````rust\r\nuse crate::prelude::*;\r\nuse bevy::prelude::*;\r\n\r\npub struct BrickTypesPlugin;\r\n\r\nimpl Plugin for BrickTypesPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<Brick>();\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\window_swap_tool_types\\src\\lib.rs\r\n\r\n````rust\r\npub mod window_swap_tool_types;\r\npub mod window_swap_tool_types_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::window_swap_tool_types::*;\r\n    pub use crate::window_swap_tool_types_plugin::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\environment_types\\src\\environment_types.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n\r\n#[derive(Component, Debug, Reflect, Clone, Copy)]\r\npub enum EnvironmentKind {\r\n    Host,\r\n    HostUIWatcher,\r\n    Game,\r\n}\r\n\r\n#[derive(Component, Debug, Reflect, Eq, PartialEq)]\r\npub struct EnvironmentTracker {\r\n    pub environment_id: Entity,\r\n}\r\n\r\n#[derive(Component, Debug, Reflect)]\r\npub struct HostEnvironment;\r\n#[derive(Component, Debug, Reflect)]\r\npub struct HostUIWatcherEnvironment;\r\n#[derive(Component, Debug, Reflect)]\r\npub struct GameEnvironment;\r\n\r\n#[derive(Component, Default, Reflect)]\r\npub struct Nametag;\r\n\r\n#[derive(Component, Debug, Reflect)]\r\npub struct TrackEnvironmentTag;\r\n\r\n#[derive(Event, Debug, Reflect)]\r\npub struct CreateEnvironmentRequestEvent {\r\n    pub name: String,\r\n    pub origin: Vec2,\r\n    pub kind: EnvironmentKind,\r\n}\r\n\r\n#[derive(Event, Debug, Reflect)]\r\npub struct PopulateEnvironmentEvent {\r\n    pub environment_id: Entity,\r\n}\r\n\r\n#[derive(Event, Debug, Reflect)]\r\npub enum NametagEvent {\r\n    Update {\r\n        environment_id: Entity,\r\n        name: String,\r\n    },\r\n    RecalculatePosition {\r\n        environment_id: Entity,\r\n    },\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\movement_tool\\src\\movement_tool_tick_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse cursor_hero_character_types::prelude::*;\r\nuse cursor_hero_movement_tool_types::prelude::*;\r\nuse cursor_hero_physics::damping_plugin::DampingSystemSet;\r\nuse cursor_hero_toolbelt_types::prelude::*;\r\nuse leafwing_input_manager::prelude::*;\r\n\r\nuse bevy_xpbd_2d::math::*;\r\nuse bevy_xpbd_2d::prelude::*;\r\n\r\npub struct MovementToolTickPlugin;\r\n\r\nimpl Plugin for MovementToolTickPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_plugins(InputManagerPlugin::<MovementToolAction>::default());\r\n        app.add_systems(Update, handle_inputs.after(DampingSystemSet::Dampen));\r\n    }\r\n}\r\n\r\nfn handle_inputs(\r\n    time: Res<Time<Physics>>,\r\n    tool_query: Query<(&ActionState<MovementToolAction>, &MovementTool, &Parent), With<ActiveTool>>,\r\n    toolbelt_query: Query<&Parent, With<Toolbelt>>,\r\n    mut character_query: Query<&mut LinearVelocity, (With<Character>, Without<Camera>)>,\r\n    mut camera_query: Query<&mut LinearVelocity, (With<Camera>, Without<Character>)>,\r\n) {\r\n    let delta_time = time.delta_seconds_f64().adjust_precision();\r\n    for tool in tool_query.iter() {\r\n        let (tool_actions, tool, tool_parent) = tool;\r\n        if !tool_actions.pressed(MovementToolAction::Move) {\r\n            continue;\r\n        }\r\n        let Ok(toolbelt_parent) = toolbelt_query.get(tool_parent.get()) else {\r\n            continue;\r\n        };\r\n        let move_delta = delta_time\r\n            * tool_actions\r\n                .clamped_axis_pair(MovementToolAction::Move)\r\n                .unwrap()\r\n                .xy();\r\n        match tool.target {\r\n            MovementTarget::Character => {\r\n                let Ok(character) = character_query.get_mut(toolbelt_parent.get()) else {\r\n                    warn!(\"Character {:?} does not exist\", toolbelt_parent);\r\n                    continue;\r\n                };\r\n                let mut character_velocity = character;\r\n                character_velocity.x += move_delta.x * tool.speed;\r\n                character_velocity.y += move_delta.y * tool.speed;\r\n            }\r\n            MovementTarget::Camera(camera_id) => {\r\n                let Ok(camera) = camera_query.get_mut(camera_id) else {\r\n                    warn!(\"Camera {:?} does not exist\", camera_id);\r\n                    continue;\r\n                };\r\n                let mut camera_velocity = camera;\r\n                camera_velocity.x += move_delta.x * tool.speed;\r\n                camera_velocity.y += move_delta.y * tool.speed;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\voice_to_text\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_voice_to_text\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\ncursor_hero_inference_types = { workspace = true }\r\ncursor_hero_voice_to_text_types = { workspace = true }\r\ntokio = { workspace = true }\r\ntokio-tungstenite = { workspace = true, features = [\"native-tls\"]}\r\nfutures-util = { workspace = true }\r\nreqwest = { workspace = true }\r\nurlencoding = { workspace = true }\r\ncrossbeam-channel = { workspace = true }\r\ncursor_hero_environment_types = { workspace = true }\r\ncursor_hero_pointer_types = { workspace = true }\r\ncursor_hero_math = { workspace = true }\r\nbevy_xpbd_2d = { workspace = true }\r\nrand = { workspace = true }\r\nrodio = { workspace = true, features = [\"wav\"] }\r\ncursor_hero_secret_types = { workspace = true }\r\nserde = { workspace = true }\r\nserde_json = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\agent_types\\src\\agent_types_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n\r\nuse crate::prelude::*;\r\n\r\npub struct AgentTypesPlugin;\r\n\r\nimpl Plugin for AgentTypesPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<Agent>();\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\tools\\src\\lib.rs\r\n\r\n````rust\r\n#![feature(let_chains)]\r\n\r\npub mod click_tool;\r\npub mod cube_tool;\r\npub mod default_wheel_tool;\r\npub mod focus_tool;\r\npub mod hello_tool;\r\npub mod keyboard_tool;\r\npub mod keyboard_wheel_tool;\r\npub mod level_bounds_visibility_tool;\r\npub mod placeholder_tool;\r\npub mod restart_tool;\r\npub mod scroll_tool;\r\npub mod talk_tool;\r\npub mod tool_plugin;\r\npub mod tool_spawning;\r\npub mod window_drag_tool;\r\npub mod zoom_tool;\r\n\r\npub use crate::tool_plugin::ToolPlugin;\r\n\r\npub mod prelude {\r\n    pub use crate::tool_spawning::NoInputs;\r\n    pub use crate::tool_spawning::StartingState;\r\n    pub use crate::tool_spawning::ToolSpawnConfig;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\hover\\src\\screenshot_tool.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse bevy::window::PrimaryWindow;\r\nuse bevy_egui::egui;\r\nuse bevy_egui::egui::Pos2;\r\nuse bevy_egui::EguiContext;\r\nuse bevy_egui::EguiContexts;\r\nuse bevy_inspector_egui::reflect_inspector::Context;\r\nuse bevy_inspector_egui::reflect_inspector::InspectorUi;\r\nuse bevy_xpbd_2d::components::Collider;\r\nuse bevy_xpbd_2d::components::RigidBody;\r\nuse crossbeam_channel::Sender;\r\nuse cursor_hero_bevy::prelude::NegativeYIVec3;\r\nuse cursor_hero_bevy::prelude::NegativeYVec2;\r\nuse cursor_hero_camera::camera_plugin::MainCamera;\r\nuse cursor_hero_character_types::prelude::*;\r\nuse cursor_hero_environment_types::prelude::TrackEnvironmentTag;\r\nuse cursor_hero_physics::damping_plugin::MovementDamping;\r\nuse cursor_hero_pointer_types::prelude::*;\r\nuse cursor_hero_screen::get_image::get_image;\r\nuse cursor_hero_screen::get_image::ScreensToImageParam;\r\nuse cursor_hero_toolbelt_types::prelude::*;\r\nuse cursor_hero_tools::cube_tool::CubeToolInteractable;\r\nuse cursor_hero_tools::prelude::*;\r\nuse cursor_hero_ui_automation::prelude::find_element_at;\r\nuse cursor_hero_ui_automation::prelude::gather_elements_at;\r\nuse cursor_hero_ui_automation::prelude::gather_incomplete_ui_tree_starting_deep;\r\nuse cursor_hero_ui_automation::prelude::DrillId;\r\nuse cursor_hero_ui_automation::prelude::ElementInfo;\r\nuse cursor_hero_worker::prelude::anyhow::Result;\r\nuse cursor_hero_worker::prelude::Message;\r\nuse cursor_hero_worker::prelude::WorkerConfig;\r\nuse cursor_hero_worker::prelude::WorkerPlugin;\r\nuse leafwing_input_manager::prelude::*;\r\nuse rand::thread_rng;\r\nuse rand::Rng;\r\n\r\npub struct ScreenshotToolPlugin;\r\n\r\nimpl Plugin for ScreenshotToolPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_plugins(WorkerPlugin {\r\n            config: WorkerConfig::<ThreadboundMessage, GameboundMessage> {\r\n                name: \"screenshot_tool\".to_string(),\r\n                is_ui_automation_thread: true,\r\n                handle_threadbound_message,\r\n                ..default()\r\n            },\r\n        });\r\n        app.register_type::<ScreenshotTool>();\r\n        app.register_type::<ScreenshotBrick>();\r\n        app.add_plugins(InputManagerPlugin::<ScreenshotToolAction>::default());\r\n        app.add_systems(Update, toolbelt_events);\r\n        app.add_systems(Update, handle_input);\r\n        app.add_systems(Update, handle_replies);\r\n        app.add_systems(Update, ui);\r\n    }\r\n}\r\n\r\n#[derive(Debug, Reflect, Clone, Event)]\r\nenum ThreadboundMessage {\r\n    Capture { world_position: Vec3 },\r\n    CaptureBrick { world_position: Vec3 },\r\n    Print { world_position: Vec3 },\r\n    Fracture { world_position: Vec3 },\r\n}\r\nimpl Message for ThreadboundMessage {}\r\n\r\n#[derive(Debug, Reflect, Clone, Event)]\r\nenum GameboundMessage {\r\n    Capture {\r\n        ui_tree: ElementInfo,\r\n        hovered_element: ElementInfo,\r\n        world_position: Vec3,\r\n    },\r\n    CaptureBrick {\r\n        ui_tree: ElementInfo,\r\n        hovered_element: ElementInfo,\r\n        world_position: Vec3,\r\n    },\r\n    Print(ElementInfo),\r\n    Fracture {\r\n        data: Vec<(ElementInfo, usize)>,\r\n        world_position: Vec3,\r\n    },\r\n}\r\nimpl Message for GameboundMessage {}\r\n\r\n#[derive(Component, Reflect, Default)]\r\nstruct ScreenshotTool;\r\n\r\n#[derive(Actionlike, PartialEq, Eq, Clone, Copy, Hash, Debug, Reflect)]\r\nenum ScreenshotToolAction {\r\n    Capture,\r\n    CaptureBrick,\r\n    Print,\r\n    Fracture,\r\n}\r\nimpl ScreenshotToolAction {\r\n    fn default_gamepad_binding(&self) -> UserInput {\r\n        match self {\r\n            Self::Capture => GamepadButtonType::RightTrigger.into(),\r\n            Self::CaptureBrick => GamepadButtonType::South.into(),\r\n            Self::Print => GamepadButtonType::North.into(),\r\n            Self::Fracture => GamepadButtonType::Select.into(),\r\n        }\r\n    }\r\n\r\n    fn default_mkb_binding(&self) -> UserInput {\r\n        match self {\r\n            Self::Capture => MouseButton::Left.into(),\r\n            Self::CaptureBrick => MouseButton::Middle.into(),\r\n            Self::Print => MouseButton::Right.into(),\r\n            Self::Fracture => KeyCode::G.into(),\r\n        }\r\n    }\r\n}\r\nimpl ToolAction for ScreenshotToolAction {\r\n    fn default_input_map(_event: &ToolbeltPopulateEvent) -> Option<InputMap<ScreenshotToolAction>> {\r\n        let mut input_map = InputMap::default();\r\n\r\n        for variant in ScreenshotToolAction::variants() {\r\n            input_map.insert(variant.default_mkb_binding(), variant);\r\n            input_map.insert(variant.default_gamepad_binding(), variant);\r\n        }\r\n        Some(input_map)\r\n    }\r\n}\r\n\r\n#[derive(Reflect, Default)]\r\nstruct ScreenshotBrickEguiState {\r\n    selected: Option<DrillId>,\r\n    expanded: Vec<DrillId>,\r\n}\r\n\r\n#[derive(Component, Reflect)]\r\nstruct ScreenshotBrick {\r\n    ui_tree: ElementInfo,\r\n    hero_element: ElementInfo,\r\n    egui_state: ScreenshotBrickEguiState,\r\n}\r\n\r\nfn toolbelt_events(\r\n    mut commands: Commands,\r\n    asset_server: Res<AssetServer>,\r\n    mut reader: EventReader<ToolbeltPopulateEvent>,\r\n) {\r\n    for event in reader.read() {\r\n        if event.loadout == ToolbeltLoadout::Inspector {\r\n            ToolSpawnConfig::<ScreenshotTool, ScreenshotToolAction>::new(\r\n                ScreenshotTool,\r\n                event.id,\r\n                event,\r\n            )\r\n            .with_src_path(file!().into())\r\n            .guess_name(file!())\r\n            .guess_image(file!(), &asset_server, \"webp\")\r\n            .with_description(\"Turn UI elements into information.\")\r\n            .spawn(&mut commands);\r\n        }\r\n    }\r\n}\r\n\r\nfn handle_input(\r\n    tools: Query<(&ActionState<ScreenshotToolAction>, &Parent), With<ActiveTool>>,\r\n    toolbelts: Query<&Parent, With<Toolbelt>>,\r\n    characters: Query<&Children, With<Character>>,\r\n    pointers: Query<&GlobalTransform, With<Pointer>>,\r\n    mut bridge: EventWriter<ThreadboundMessage>,\r\n    egui_context_query: Query<&EguiContext, With<PrimaryWindow>>,\r\n) {\r\n    for tool in tools.iter() {\r\n        let (tool_actions, tool_parent) = tool;\r\n\r\n        let Ok(toolbelt) = toolbelts.get(tool_parent.get()) else {\r\n            warn!(\"Tool not inside a toolbelt?\");\r\n            continue;\r\n        };\r\n        let toolbelt_parent = toolbelt;\r\n\r\n        let Ok(character) = characters.get(toolbelt_parent.get()) else {\r\n            warn!(\"Toolbelt parent not a character?\");\r\n            continue;\r\n        };\r\n        let character_children = character;\r\n\r\n        let Some(pointer) = character_children\r\n            .iter()\r\n            .filter_map(|x| pointers.get(*x).ok())\r\n            .next()\r\n        else {\r\n            //TODO: warn if more than one pointer found\r\n            warn!(\"Character {:?} missing a pointer?\", toolbelt_parent.get());\r\n            debug!(\"Character children: {:?}\", character_children);\r\n            continue;\r\n        };\r\n        let pointer_transform = pointer;\r\n        let pointer_translation = pointer_transform.translation();\r\n        let hovering_over_egui = egui_context_query\r\n            .get_single()\r\n            .ok()\r\n            .map(|egui_context| egui_context.clone().get_mut().is_pointer_over_area())\r\n            .unwrap_or(false);\r\n        if hovering_over_egui {\r\n            continue;\r\n        }\r\n        if tool_actions.just_pressed(ScreenshotToolAction::Capture) {\r\n            info!(\"Capture\");\r\n            let msg = ThreadboundMessage::Capture {\r\n                world_position: pointer_translation,\r\n            };\r\n            bridge.send(msg);\r\n        }\r\n        if tool_actions.just_pressed(ScreenshotToolAction::CaptureBrick) {\r\n            info!(\"CaptureBrick\");\r\n            let msg = ThreadboundMessage::CaptureBrick {\r\n                world_position: pointer_translation,\r\n            };\r\n            bridge.send(msg);\r\n        }\r\n        if tool_actions.just_pressed(ScreenshotToolAction::Print) {\r\n            info!(\"Print\");\r\n            let msg = ThreadboundMessage::Print {\r\n                world_position: pointer_translation,\r\n            };\r\n            bridge.send(msg);\r\n        }\r\n        if tool_actions.just_pressed(ScreenshotToolAction::Fracture) {\r\n            info!(\"Fracture\");\r\n            let msg = ThreadboundMessage::Fracture {\r\n                world_position: pointer_translation,\r\n            };\r\n            bridge.send(msg);\r\n        }\r\n    }\r\n}\r\n\r\nfn handle_threadbound_message(\r\n    msg: &ThreadboundMessage,\r\n    reply_tx: &Sender<GameboundMessage>,\r\n) -> Result<()> {\r\n    match msg {\r\n        ThreadboundMessage::Capture { world_position }\r\n        | ThreadboundMessage::CaptureBrick { world_position } => {\r\n            let mouse_position = world_position.xy().neg_y().as_ivec2();\r\n            debug!(\"Worker received click: {:?} {:?}\", msg, mouse_position);\r\n\r\n            let elem = find_element_at(mouse_position)?;\r\n            info!(\"{} - {}\", elem.get_classname()?, elem.get_name()?);\r\n\r\n            let id = elem.get_automation_id()?;\r\n            info!(\"Automation ID: {}\", id);\r\n            let gathered = gather_incomplete_ui_tree_starting_deep(elem)?;\r\n            // debug!(\"Element info: {:?}\", element_info);\r\n            let msg = match msg {\r\n                ThreadboundMessage::Capture { world_position } => GameboundMessage::Capture {\r\n                    ui_tree: gathered.ui_tree,\r\n                    hovered_element: gathered.start_info,\r\n                    world_position: *world_position,\r\n                },\r\n                ThreadboundMessage::CaptureBrick { world_position } => {\r\n                    GameboundMessage::CaptureBrick {\r\n                        ui_tree: gathered.ui_tree,\r\n                        hovered_element: gathered.start_info,\r\n                        world_position: *world_position,\r\n                    }\r\n                }\r\n                _ => unreachable!(),\r\n            };\r\n            reply_tx.send(msg)?;\r\n        }\r\n        ThreadboundMessage::Print { world_position } => {\r\n            let mouse_position = world_position.xy().neg_y().as_ivec2();\r\n            debug!(\"Worker received click: {:?} {:?}\", msg, mouse_position);\r\n\r\n            let elem = find_element_at(mouse_position)?;\r\n            info!(\"{:?}\", elem);\r\n\r\n            // Can we click on elements with this?\r\n            // elem.send_keys(keys, interval) exists!\r\n\r\n            // Send the info\r\n            let id = elem.get_automation_id()?;\r\n            info!(\"Automation ID: {}\", id);\r\n            let gathered = gather_incomplete_ui_tree_starting_deep(elem)?;\r\n            reply_tx.send(GameboundMessage::Print(gathered.ui_tree))?;\r\n        }\r\n        ThreadboundMessage::Fracture { world_position } => {\r\n            let mouse_position = world_position.xy().neg_y().as_ivec2();\r\n            debug!(\"Worker received click: {:?} {:?}\", msg, mouse_position);\r\n\r\n            let found = gather_elements_at(mouse_position)?;\r\n            let data = found\r\n                .into_iter()\r\n                .filter_map(|(elem, depth)| {\r\n                    gather_incomplete_ui_tree_starting_deep(elem)\r\n                        .ok()\r\n                        .map(|info| (info.start_info, depth))\r\n                })\r\n                .collect();\r\n            reply_tx.send(GameboundMessage::Fracture {\r\n                data,\r\n                world_position: *world_position,\r\n            })?;\r\n        }\r\n    }\r\n\r\n    Ok(())\r\n}\r\n\r\nfn handle_replies(\r\n    mut commands: Commands,\r\n    mut bridge: EventReader<GameboundMessage>,\r\n    screen_access: ScreensToImageParam,\r\n    asset_server: Res<AssetServer>,\r\n) {\r\n    for msg in bridge.read() {\r\n        match &msg {\r\n            GameboundMessage::Capture {\r\n                ui_tree,\r\n                hovered_element,\r\n                world_position,\r\n            }\r\n            | GameboundMessage::CaptureBrick {\r\n                ui_tree,\r\n                hovered_element,\r\n                world_position,\r\n            } => {\r\n                let (size, pos, texture_region) = match msg {\r\n                    GameboundMessage::Capture { .. } => (\r\n                        hovered_element.bounding_rect.size().as_vec2(),\r\n                        hovered_element\r\n                            .bounding_rect\r\n                            .center()\r\n                            .extend(20)\r\n                            .neg_y()\r\n                            .as_vec3(),\r\n                        hovered_element.bounding_rect,\r\n                    ),\r\n                    GameboundMessage::CaptureBrick { .. } => (\r\n                        hovered_element.bounding_rect.size().as_vec2().normalize() * 60.0,\r\n                        *world_position,\r\n                        hovered_element.bounding_rect,\r\n                    ),\r\n                    _ => unreachable!(),\r\n                };\r\n                spawn_brick(\r\n                    &mut commands,\r\n                    ui_tree,\r\n                    hovered_element,\r\n                    size,\r\n                    pos,\r\n                    texture_region,\r\n                    &screen_access,\r\n                    &asset_server,\r\n                );\r\n            }\r\n            GameboundMessage::Print(info) => {\r\n                info!(\"Received info for element {:?}\", info);\r\n                commands.spawn((\r\n                    AudioBundle {\r\n                        source: asset_server.load(\"sounds/tape recorder eject 4.ogg\"),\r\n                        settings: PlaybackSettings::REMOVE,\r\n                    },\r\n                    Name::new(format!(\"SFX Element - {}\", info.name)),\r\n                ));\r\n            }\r\n            GameboundMessage::Fracture {\r\n                data,\r\n                world_position,\r\n            } => {\r\n                info!(\"Received info with {} elements\", data.len());\r\n                if !data.is_empty() {\r\n                    commands.spawn((\r\n                        SpatialBundle {\r\n                            transform: Transform::from_translation(*world_position),\r\n                            ..default()\r\n                        },\r\n                        AudioBundle {\r\n                            source: asset_server.load(\"sounds/spring strung light 4.ogg\"),\r\n                            settings: PlaybackSettings::DESPAWN.with_spatial(true),\r\n                        },\r\n                        Name::new(\"Fracture Sound\"),\r\n                    ));\r\n                }\r\n                for (info, depth) in data {\r\n                    // let Ok(image) = get_image(info.bounding_rect, &access) else {\r\n                    //     continue;\r\n                    // };\r\n                    // let texture_handle = asset_server.add(image);\r\n\r\n                    // spawn the element image\r\n                    let mut elem_center_pos =\r\n                        info.bounding_rect.center().as_vec2().extend(*depth as f32);\r\n                    elem_center_pos.y *= -1.0;\r\n                    commands.spawn((\r\n                        SpriteBundle {\r\n                            transform: Transform::from_translation(elem_center_pos),\r\n                            sprite: Sprite {\r\n                                custom_size: Some(info.bounding_rect.size().as_vec2()),\r\n                                color: Color::hsl(thread_rng().gen_range(0.0..360.0), 0.5, 0.5),\r\n                                ..default()\r\n                            },\r\n                            // texture: texture_handle,\r\n                            ..default()\r\n                        },\r\n                        CubeToolInteractable,\r\n                        RigidBody::Dynamic,\r\n                        Collider::cuboid(\r\n                            info.bounding_rect.width() as f32,\r\n                            info.bounding_rect.height() as f32,\r\n                        ),\r\n                        MovementDamping::default(),\r\n                        Name::new(format!(\"Element - {}\", info.name)),\r\n                    ));\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n#[allow(clippy::too_many_arguments)]\r\nfn spawn_brick(\r\n    commands: &mut Commands,\r\n    ui_tree: &ElementInfo,\r\n    hero_element: &ElementInfo,\r\n    size: Vec2,\r\n    pos: Vec3,\r\n    texture_region: IRect,\r\n    screen_access: &ScreensToImageParam,\r\n    asset_server: &Res<AssetServer>,\r\n) {\r\n    let Ok(image) = get_image(texture_region, screen_access) else {\r\n        return;\r\n    };\r\n    let texture_handle = asset_server.add(image);\r\n    let expanded = ui_tree\r\n        .get_descendents()\r\n        .iter()\r\n        .chain([ui_tree].iter())\r\n        .filter(|x| x.children.is_some())\r\n        .map(|x| x.drill_id.clone())\r\n        .collect();\r\n    commands.spawn((\r\n        SpriteBundle {\r\n            transform: Transform::from_translation(pos),\r\n            sprite: Sprite {\r\n                custom_size: Some(size),\r\n                ..default()\r\n            },\r\n            texture: texture_handle,\r\n            ..default()\r\n        },\r\n        AudioBundle {\r\n            source: asset_server.load(\"sounds/spring strung light 4.ogg\"),\r\n            settings: PlaybackSettings::REMOVE.with_spatial(true),\r\n        },\r\n        // FloatyName {\r\n        //     text: element_info.name.clone(),\r\n        //     vertical_offset: 40.0,\r\n        //     appearance: NametagAppearance::Databrick,\r\n        // },\r\n        Hoverable,\r\n        Clickable,\r\n        CubeToolInteractable,\r\n        RigidBody::Dynamic,\r\n        TrackEnvironmentTag,\r\n        ScreenshotBrick {\r\n            ui_tree: ui_tree.clone(),\r\n            hero_element: hero_element.clone(),\r\n            egui_state: ScreenshotBrickEguiState {\r\n                selected: Some(hero_element.drill_id.clone()),\r\n                expanded,\r\n            },\r\n        },\r\n        Collider::cuboid(size.x, size.y),\r\n        MovementDamping::default(),\r\n        Name::new(format!(\"Element - {}\", hero_element.name)),\r\n    ));\r\n}\r\n\r\nfn ui(\r\n    mut commands: Commands,\r\n    screen_access: ScreensToImageParam,\r\n    asset_server: Res<AssetServer>,\r\n    mut contexts: EguiContexts,\r\n    mut brick_query: Query<(\r\n        Entity,\r\n        &mut ScreenshotBrick,\r\n        &Sprite,\r\n        &Name,\r\n        &GlobalTransform,\r\n    )>,\r\n    camera_query: Query<(&GlobalTransform, &Camera), With<MainCamera>>,\r\n    type_registry: Res<AppTypeRegistry>,\r\n) {\r\n    let Ok(camera) = camera_query.get_single() else {\r\n        warn!(\"No camera found\");\r\n        return;\r\n    };\r\n    let (camera_transform, camera) = camera;\r\n\r\n    let ctx = contexts.ctx_mut();\r\n    // let scale = (camera_transform.compute_transform().scale.x * 1.0).round();\r\n    // debug!(\"Scale: {}\", scale);\r\n    // ctx.set_zoom_factor(scale);\r\n\r\n    if brick_query.is_empty() {\r\n        return;\r\n    }\r\n\r\n    let mut cx = Context {\r\n        world: None,\r\n        queue: None,\r\n    };\r\n\r\n    let type_registry = type_registry.0.clone();\r\n    let type_registry = type_registry.read();\r\n\r\n    let mut inspector = InspectorUi::for_bevy(&type_registry, &mut cx);\r\n\r\n    for brick in brick_query.iter_mut() {\r\n        let (brick_id, mut brick, brick_sprite, brick_name, brick_global_transform) = brick;\r\n        let brick_global_translation = brick_global_transform.translation();\r\n        let popout_pos = brick_global_translation\r\n            + Vec3::new(\r\n                brick_sprite.custom_size.unwrap_or_default().x + 50.0,\r\n                0.0,\r\n                0.0,\r\n            );\r\n        let egui_pos = camera\r\n            .world_to_viewport(camera_transform, brick_global_translation)\r\n            .unwrap_or_default();\r\n\r\n        let id = egui::Id::new(brick_id);\r\n\r\n        egui::Window::new(brick_name.chars().take(64).collect::<String>())\r\n            .id(id)\r\n            .fixed_pos(Pos2::new(egui_pos.x, egui_pos.y))\r\n            .default_width(1200.0)\r\n            // .resizable(true)\r\n            .show(ctx, |ui| {\r\n                egui::SidePanel::left(id.with(\"tree\"))\r\n                    .resizable(true)\r\n                    .width_range(100.0..=4000.0)\r\n                    .default_width(600.0)\r\n                    .show_inside(ui, |ui| {\r\n                        ui.vertical_centered(|ui| {\r\n                            ui.heading(\"UI Tree\");\r\n                        });\r\n                        egui::ScrollArea::both().show(ui, |ui| {\r\n                            let id = id.with(brick.ui_tree.runtime_id.clone());\r\n\r\n                            let mut temp_egui_state = std::mem::take(&mut brick.egui_state);\r\n                            let mut temp_info = std::mem::take(&mut brick.ui_tree);\r\n                            ui_for_element_info(\r\n                                &mut temp_egui_state,\r\n                                id,\r\n                                &mut commands,\r\n                                &screen_access,\r\n                                &asset_server,\r\n                                ui,\r\n                                &mut temp_info,\r\n                                &mut inspector,\r\n                                &popout_pos,\r\n                            );\r\n                            brick.egui_state = temp_egui_state;\r\n                            brick.ui_tree = temp_info;\r\n\r\n                            ui.allocate_space(ui.available_size());\r\n                        });\r\n                    });\r\n\r\n                egui::TopBottomPanel::bottom(id.with(\"invisible bottom panel\"))\r\n                    .show_separator_line(false)\r\n                    .show_inside(ui, |_| ());\r\n\r\n                egui::CentralPanel::default().show_inside(ui, |ui| {\r\n                    ui.heading(\"AHOY!\");\r\n                    let id = brick.egui_state.selected.clone();\r\n                    if let Some(id) = id\r\n                        && let Some(x) = brick.ui_tree.lookup_drill_id_mut(id)\r\n                    {\r\n                        inspector.ui_for_reflect(x, ui);\r\n                    }\r\n                    // inspector.ui_for_reflect_readonly(&data, ui);\r\n                });\r\n            });\r\n    }\r\n}\r\n\r\n#[derive(Reflect, Debug)]\r\nstruct ElementUIData {\r\n    runtime_id: String,\r\n    frick: String,\r\n}\r\n\r\n#[allow(clippy::too_many_arguments)]\r\nfn ui_for_element_info(\r\n    state: &mut ScreenshotBrickEguiState,\r\n    id: egui::Id,\r\n    _commands: &mut Commands,\r\n    _screen_access: &ScreensToImageParam,\r\n    _asset_server: &Res<AssetServer>,\r\n    ui: &mut egui::Ui,\r\n    element_info: &mut ElementInfo,\r\n    _inspector: &mut InspectorUi,\r\n    _popout_pos: &Vec3,\r\n) {\r\n    egui::collapsing_header::CollapsingState::load_with_default_open(\r\n        ui.ctx(),\r\n        id,\r\n        state.expanded.contains(&element_info.drill_id),\r\n    )\r\n    .show_header(ui, |ui| {\r\n        let mut selected = state.selected == Some(element_info.drill_id.clone());\r\n        if ui\r\n            .toggle_value(\r\n                &mut selected,\r\n                format!(\r\n                    \"{:?} | {}\",\r\n                    element_info.name, element_info.localized_control_type\r\n                ),\r\n            )\r\n            .changed()\r\n        {\r\n            state.selected = if selected {\r\n                Some(element_info.drill_id.clone())\r\n            } else {\r\n                None\r\n            };\r\n        };\r\n    })\r\n    .body(|ui| {\r\n        // if ui.button(\"Popout\").clicked() {\r\n        //     spawn_brick(\r\n        //         commands,\r\n        //         element_info,\r\n        //         element_info.bounding_rect.size(),\r\n        //         *popout_pos,\r\n        //         screen_access,\r\n        //         asset_server,\r\n        //     )\r\n        // }\r\n\r\n        if let Some(children) = &mut element_info.children {\r\n            for child in children.iter_mut() {\r\n                ui_for_element_info(\r\n                    state,\r\n                    id.with(child.runtime_id.clone()),\r\n                    _commands,\r\n                    _screen_access,\r\n                    _asset_server,\r\n                    ui,\r\n                    child,\r\n                    _inspector,\r\n                    _popout_pos,\r\n                );\r\n            }\r\n        }\r\n    });\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\taskbar_tool\\src\\taskbar_tool_plugin.rs\r\n\r\n````rust\r\nuse crate::taskbar_wheel_tool::TaskbarWheelToolPlugin;\r\nuse bevy::prelude::*;\r\npub struct TaskbarToolPlugin;\r\n\r\nimpl Plugin for TaskbarToolPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_plugins(TaskbarWheelToolPlugin);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\tools\\src\\hello_tool.rs\r\n\r\n````rust\r\nuse crate::prelude::*;\r\nuse bevy::prelude::*;\r\nuse cursor_hero_inference_types::inference_types::SpeechInferenceEvent;\r\nuse cursor_hero_inference_types::inference_types::TextInferenceEvent;\r\nuse cursor_hero_inference_types::inference_types::TextInferenceOptions;\r\nuse cursor_hero_inference_types::prompt_types::SpeechPrompt;\r\nuse cursor_hero_inference_types::prompt_types::TextPrompt;\r\nuse cursor_hero_toolbelt_types::prelude::*;\r\n\r\npub struct HelloToolPlugin;\r\n\r\nimpl Plugin for HelloToolPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<HelloTool>();\r\n        app.add_systems(Update, toolbelt_events);\r\n        app.add_systems(Update, activation);\r\n        app.add_systems(Update, inference_response);\r\n        app.add_systems(Update, tts_response);\r\n    }\r\n}\r\n\r\n#[derive(Component, Reflect, Default)]\r\nstruct HelloTool;\r\n\r\nfn toolbelt_events(\r\n    mut commands: Commands,\r\n    asset_server: Res<AssetServer>,\r\n    mut reader: EventReader<ToolbeltPopulateEvent>,\r\n) {\r\n    for event in reader.read() {\r\n        if event.loadout == ToolbeltLoadout::Inspector {\r\n            ToolSpawnConfig::<HelloTool, NoInputs>::new(HelloTool, event.id, event)\r\n                .with_src_path(file!().into())\r\n                .guess_name(file!())\r\n                .guess_image(file!(), &asset_server, \"png\")\r\n                .with_description(\"Prints hello.\")\r\n                .with_starting_state(StartingState::Inactive)\r\n                .spawn(&mut commands);\r\n        }\r\n    }\r\n}\r\n\r\nfn activation(\r\n    mut commands: Commands,\r\n    tool_query: Query<Entity, (Added<ActiveTool>, With<HelloTool>)>,\r\n    mut inference_events: EventWriter<TextInferenceEvent>,\r\n) {\r\n    for tool_id in tool_query.iter() {\r\n        commands.entity(tool_id).remove::<ActiveTool>();\r\n        info!(\"Hello, world!\");\r\n        inference_events.send(TextInferenceEvent::Request {\r\n            session_id: tool_id,\r\n            prompt: TextPrompt::Raw {\r\n                content: \"Here is a random word:\".to_string(),\r\n                options: Some(TextInferenceOptions {\r\n                    num_predict: Some(7),\r\n                    ..default()\r\n                }),\r\n            },\r\n        });\r\n    }\r\n}\r\n\r\nfn inference_response(\r\n    mut llm_events: EventReader<TextInferenceEvent>,\r\n    mut tts_events: EventWriter<SpeechInferenceEvent>,\r\n    tool_query: Query<Entity, With<HelloTool>>,\r\n) {\r\n    for event in llm_events.read() {\r\n        if let TextInferenceEvent::Response {\r\n            session_id,\r\n            response,\r\n            prompt: _,\r\n        } = event\r\n        {\r\n            if tool_query.get(*session_id).is_ok() {\r\n                tts_events.send(SpeechInferenceEvent::Request {\r\n                    session_id: *session_id,\r\n                    prompt: SpeechPrompt::Raw {\r\n                        content: response.clone(),\r\n                    },\r\n                });\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfn tts_response(\r\n    mut commands: Commands,\r\n    mut tts_events: EventReader<SpeechInferenceEvent>,\r\n    tool_query: Query<Entity, With<HelloTool>>,\r\n    mut audio_assets: ResMut<Assets<AudioSource>>,\r\n) {\r\n    for event in tts_events.read() {\r\n        if let SpeechInferenceEvent::Response {\r\n            session_id, wav, ..\r\n        } = event\r\n        {\r\n            if tool_query.get(*session_id).is_ok() {\r\n                info!(\r\n                    \"Received TTS response for session {:?}, playing\",\r\n                    session_id\r\n                );\r\n                let audio = audio_assets.add(AudioSource {\r\n                    bytes: wav.clone().into(),\r\n                });\r\n                commands.entity(*session_id).insert({\r\n                    AudioBundle {\r\n                        source: audio,\r\n                        settings: PlaybackSettings::REMOVE.with_spatial(true),\r\n                    }\r\n                });\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\calculator_app\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_calculator_app\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\ncursor_hero_calculator_app_types = { workspace = true }\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\floaty_nametag_types\\src\\floaty_nametag_types_plugin.rs\r\n\r\n````rust\r\nuse crate::prelude::*;\r\nuse bevy::prelude::*;\r\n\r\npub struct FloatyNametagTypesPlugin;\r\n\r\nimpl Plugin for FloatyNametagTypesPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<FloatyName>();\r\n        app.register_type::<FloatyNametag>();\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\toolbelt\\src\\tool_help_populate.rs\r\n\r\n````rust\r\nuse cursor_hero_host_fs_types::host_fs_types::HostPath;\r\nuse cursor_hero_toolbelt_types::toolbelt_types::*;\r\n\r\nuse bevy::prelude::*;\r\nuse bevy_xpbd_2d::components::Collider;\r\nuse bevy_xpbd_2d::components::RigidBody;\r\nuse bevy_xpbd_2d::components::Sensor;\r\nuse cursor_hero_pointer_types::prelude::*;\r\n\r\nuse leafwing_input_manager::action_state::ActionState;\r\n\r\n#[allow(clippy::type_complexity)]\r\npub fn tool_help_lifecycle(\r\n    mut commands: Commands,\r\n    toolbelt_query: Query<\r\n        (&ActionState<ToolbeltAction>, &Children),\r\n        (Without<Tool>, With<Toolbelt>),\r\n    >,\r\n    tool_query: Query<(Entity, Option<&HostPath>, Option<&Children>, Option<&Name>), With<Tool>>,\r\n    tool_help_triggger_query: Query<Entity, With<ToolHelpTrigger>>,\r\n    asset_server: Res<AssetServer>,\r\n) {\r\n    for (toolbelt_actions, toolbelt_kids) in toolbelt_query.iter() {\r\n        if toolbelt_actions.just_pressed(ToolbeltAction::Show) {\r\n            for child_id in toolbelt_kids.iter() {\r\n                let Ok(tool) = tool_query.get(*child_id) else {\r\n                    continue;\r\n                };\r\n\r\n                let (tool_id, tool_src_path, _, tool_name) = tool;\r\n                commands.entity(tool_id).with_children(|parent| {\r\n                    let mut help = parent.spawn((\r\n                        Name::new(format!(\"Help Trigger for {:?} ({:?})\", tool_name, tool_id)),\r\n                        SpriteBundle {\r\n                            sprite: Sprite {\r\n                                custom_size: Some(Vec2::new(50.0, 50.0)),\r\n                                ..default()\r\n                            },\r\n                            transform: Transform::from_xyz(0.0, 0.0, 1.0),\r\n                            texture: asset_server.load(\"textures/toolbelt_wheel/help_trigger.png\"),\r\n                            ..default()\r\n                        },\r\n                        Hoverable,\r\n                        Clickable,\r\n                        ToolHelpTrigger,\r\n                        Sensor,\r\n                        RigidBody::Kinematic,\r\n                        Collider::cuboid(50.0, 50.0),\r\n                    ));\r\n                    if let Some(src_path) = tool_src_path {\r\n                        help.insert(src_path.clone());\r\n                    }\r\n                });\r\n            }\r\n        } else if toolbelt_actions.just_released(ToolbeltAction::Show) {\r\n            for child_id in toolbelt_kids.iter() {\r\n                let Ok(tool) = tool_query.get(*child_id) else {\r\n                    continue;\r\n                };\r\n                let (tool_id, _, Some(tool_children), _) = tool else {\r\n                    continue;\r\n                };\r\n                for child_id in tool_children.iter() {\r\n                    if let Ok(tool_help_trigger_id) = tool_help_triggger_query.get(*child_id) {\r\n                        commands\r\n                            .entity(tool_id)\r\n                            .remove_children(&[tool_help_trigger_id]);\r\n                        commands.entity(tool_help_trigger_id).despawn_recursive();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\worker\\src\\worker_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse crossbeam_channel::bounded;\r\nuse cursor_hero_worker_types::prelude::*;\r\nuse std::thread;\r\n\r\nuse windows::Win32::System::Com::CoInitializeEx;\r\nuse windows::Win32::System::Com::COINIT_MULTITHREADED;\r\npub struct WorkerPlugin<T, G>\r\nwhere\r\n    T: Message,\r\n    G: Message,\r\n{\r\n    pub config: WorkerConfig<T, G>,\r\n}\r\n\r\nimpl<T, G> Plugin for WorkerPlugin<T, G>\r\nwhere\r\n    T: Message,\r\n    G: Message,\r\n{\r\n    fn build(&self, app: &mut App) {\r\n        // TODO: conditionally register if T or G support it\r\n        // app.register_type::<T>();\r\n        // app.register_type::<G>();\r\n        app.add_event::<T>();\r\n        app.add_event::<G>();\r\n        app.insert_resource(self.config.clone());\r\n        app.add_systems(Startup, create_worker_thread::<T, G>);\r\n        app.add_systems(Update, bridge_requests::<T, G>);\r\n        app.add_systems(Update, bridge_responses::<T, G>);\r\n    }\r\n}\r\n\r\nfn create_worker_thread<T: Message, G: Message>(\r\n    config: Res<WorkerConfig<T, G>>,\r\n    mut commands: Commands,\r\n) {\r\n    let (game_tx, game_rx) = bounded::<G>(10);\r\n    let (thread_tx, thread_rx) = bounded::<T>(10);\r\n\r\n    commands.insert_resource(Bridge {\r\n        sender: thread_tx,\r\n        receiver: game_rx,\r\n    });\r\n\r\n    let name = config.name.clone();\r\n    let handler = config.handle_threadbound_message;\r\n    let handler_error_handler = config.handle_threadbound_message_error_handler;\r\n    let sleep_duration = config.sleep_duration;\r\n    let is_ui_automation_thread = config.is_ui_automation_thread;\r\n    if let Err(e) = thread::Builder::new().name(name.clone()).spawn(move || {\r\n        if is_ui_automation_thread {\r\n            unsafe {\r\n                // Initialize COM in MTA mode\r\n                // https://learn.microsoft.com/en-us/dotnet/framework/ui-automation/ui-automation-threading-issues\r\n                // https://learn.microsoft.com/en-us/windows/win32/com/multithreaded-apartments\r\n                if let Err(e) = CoInitializeEx(None, COINIT_MULTITHREADED) {\r\n                    error!(\"[{}] Failed to initialize COM: {:?}\", name, e);\r\n                }\r\n                debug!(\"[{}] COM initialized in MTA mode.\", name);\r\n            }\r\n        }\r\n\r\n        let rt = tokio::runtime::Runtime::new().unwrap();\r\n        rt.block_on(async {\r\n            loop {\r\n                let msg = match thread_rx.recv() {\r\n                    Ok(msg) => msg,\r\n                    Err(e) => {\r\n                        error!(\r\n                            \"[{}] Threadbound channel recv failure {:?}, exiting: \",\r\n                            name, e\r\n                        );\r\n                        break;\r\n                    }\r\n                };\r\n                if let Err(e) = (handler)(&msg, &game_tx) {\r\n                    // eprintln cause bevy logging isn't guaranteed to display\r\n                    // eprintln!(\r\n                    //     \"[{}] Failed to process thread message {:?}, got error {:?}\",\r\n                    //     name, msg, e\r\n                    // );\r\n                    error!(\r\n                        \"[{}] Failed to process thread message {:?}, got error {:?}\",\r\n                        name, msg, e\r\n                    );\r\n                    if let Err(ee) = (handler_error_handler)(&msg, &game_tx, &e) {\r\n                        error!(\r\n                            \"[{}] BAD NEWS! Failed while processing error handler for message {:?} that produced error {:?}, got new error {:?}\",\r\n                            name, msg, e, ee\r\n                        );\r\n                    }\r\n                }\r\n                std::thread::sleep(sleep_duration);\r\n            }\r\n        });\r\n    }) {\r\n        error!(\"[{}] Failed to spawn thread: {:?}\", config.name, e);\r\n    } else {\r\n        info!(\"[{}] Thread created\", config.name);\r\n    }\r\n}\r\n\r\nfn bridge_requests<T: Message, G: Message>(\r\n    config: Res<WorkerConfig<T, G>>,\r\n    bridge: ResMut<Bridge<T, G>>,\r\n    mut events: EventReader<T>,\r\n) {\r\n    for event in events.read() {\r\n        trace!(\"[{}] Bevy => Thread: {:?}\", config.name, event);\r\n        if let Err(e) = bridge.sender.send(event.clone()) {\r\n            error!(\"[{}] Threadbound channel failure: {:?}\", config.name, e);\r\n        }\r\n    }\r\n}\r\n\r\nfn bridge_responses<T: Message, G: Message>(\r\n    config: Res<WorkerConfig<T, G>>,\r\n    bridge: ResMut<Bridge<T, G>>,\r\n    mut events: EventWriter<G>,\r\n) {\r\n    for msg in bridge.receiver.try_iter() {\r\n        trace!(\"[{}] Thread => Bevy: {:?}\", config.name, msg);\r\n        events.send(msg);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\app\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_app\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\ncursor_hero_app_types = { workspace = true }\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\start_menu\\src\\start_menu_button_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse bevy_xpbd_2d::components::Collider;\r\nuse bevy_xpbd_2d::components::RigidBody;\r\nuse bevy_xpbd_2d::components::Sensor;\r\nuse cursor_hero_pointer_types::prelude::*;\r\nuse cursor_hero_start_menu_types::prelude::*;\r\nuse cursor_hero_taskbar_types::prelude::*;\r\n\r\npub struct StartMenuButtonPlugin;\r\n\r\nimpl Plugin for StartMenuButtonPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Update, add_start_menu_button_to_new_taskbars);\r\n        app.add_systems(Update, click_listener);\r\n        app.add_systems(Update, visuals);\r\n    }\r\n}\r\n\r\nfn add_start_menu_button_to_new_taskbars(\r\n    asset_server: Res<AssetServer>,\r\n    mut commands: Commands,\r\n    mut taskbar_events: EventReader<TaskbarEvent>,\r\n    taskbar_query: Query<(&Taskbar, &Transform, &Parent)>,\r\n) {\r\n    for event in taskbar_events.read() {\r\n        let TaskbarEvent::Populate { taskbar_id } = event;\r\n        let Ok(taskbar) = taskbar_query.get(*taskbar_id) else {\r\n            warn!(\"Taskbar {:?} not found\", taskbar_id);\r\n            continue;\r\n        };\r\n        let (taskbar, taskbar_transform, taskbar_parent) = taskbar;\r\n        let taskbar_size = taskbar.size;\r\n        let start_menu_button_size = Vec2::new(48.0, 40.0);\r\n        let start_menu_button_translation = Vec3::new(\r\n            -taskbar_size.x / 2.0 + start_menu_button_size.x / 2.0,\r\n            0.0,\r\n            1.0,\r\n        ) + taskbar_transform.translation;\r\n        info!(\"Adding start menu button for taskbar {:?}\", taskbar_id);\r\n        commands\r\n            .entity(taskbar_parent.get())\r\n            .with_children(|parent| {\r\n                parent.spawn((\r\n                    SpriteBundle {\r\n                        sprite: Sprite {\r\n                            custom_size: Some(start_menu_button_size),\r\n                            ..default()\r\n                        },\r\n                        texture: asset_server\r\n                            .load(\"textures/environment/game/start_menu_button.png\"),\r\n                        transform: Transform::from_translation(start_menu_button_translation),\r\n                        ..Default::default()\r\n                    },\r\n                    RigidBody::Static,\r\n                    Collider::cuboid(start_menu_button_size.x, start_menu_button_size.y),\r\n                    Sensor,\r\n                    Name::new(\"Start Menu Button\"),\r\n                    StartMenuButton,\r\n                    Hoverable,\r\n                    Clickable,\r\n                ));\r\n            });\r\n    }\r\n}\r\n\r\nfn click_listener(\r\n    mut click_events: EventReader<ClickEvent>,\r\n    start_menu_button_query: Query<&Children, With<StartMenuButton>>,\r\n    start_menu_query: Query<(), With<StartMenu>>,\r\n    mut start_menu_events: EventWriter<StartMenuEvent>,\r\n) {\r\n    for event in click_events.read() {\r\n        let ClickEvent::Clicked {\r\n            target_id,\r\n            pointer_id: _,\r\n            way,\r\n        } = event\r\n        else {\r\n            continue;\r\n        };\r\n        if way != &Way::Left {\r\n            continue;\r\n        }\r\n        if let Ok(children) = start_menu_button_query.get(*target_id) {\r\n            info!(\"Start menu button clicked\");\r\n            let open = children\r\n                .iter()\r\n                .any(|child| start_menu_query.get(*child).is_ok());\r\n            if open {\r\n                start_menu_events.send(StartMenuEvent::Close {\r\n                    start_menu_button_id: *target_id,\r\n                });\r\n            } else {\r\n                start_menu_events.send(StartMenuEvent::Open {\r\n                    start_menu_button_id: *target_id,\r\n                });\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nenum VisualState {\r\n    Normal,\r\n    Hovered,\r\n    Pressed,\r\n}\r\n\r\n#[allow(clippy::type_complexity)]\r\nfn visuals(\r\n    mut start_menu_button_query: Query<\r\n        (&mut Sprite, Option<&Pressed>, Option<&Hovered>),\r\n        With<StartMenuButton>,\r\n    >,\r\n) {\r\n    for (mut sprite, pressed, hovered) in start_menu_button_query.iter_mut() {\r\n        let mut visual_state = VisualState::Normal;\r\n        if pressed.is_some() {\r\n            visual_state = VisualState::Pressed;\r\n        } else if hovered.is_some() {\r\n            visual_state = VisualState::Hovered;\r\n        }\r\n        match visual_state {\r\n            VisualState::Normal => {\r\n                sprite.color = Color::WHITE;\r\n            }\r\n            VisualState::Hovered => {\r\n                sprite.color = Color::ORANGE_RED;\r\n            }\r\n            VisualState::Pressed => {\r\n                sprite.color = Color::RED;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\bevy\\src\\rect_in_rect.rs\r\n\r\n````rust\r\nuse bevy::math::Rect;\r\nuse bevy::math::Vec2;\r\n\r\npub trait AtInsideBottom {\r\n    fn at_inside_bottom(&self, other: &Rect) -> Rect;\r\n}\r\nimpl AtInsideBottom for Rect {\r\n    fn at_inside_bottom(&self, other: &Rect) -> Rect {\r\n        Rect::from_center_size(\r\n            Vec2::new(\r\n                other.center().x,\r\n                other.center().y - other.height() / 2.0 + self.height() / 2.0,\r\n            ),\r\n            self.size(),\r\n        )\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\templates\\matchers\\new_plugin_with_types\\Cargo.toml.py\r\n\r\n````py\r\n# {{before_first_workspace_dependency}}\r\n# cursor_hero_{{crate_name}}_types = { path = \"./crates/{{crate_name}}_types\" }\r\n# cursor_hero_{{crate_name}} = { path = \"./crates/{{crate_name}}\" }\r\n# {{first_workspace_dependency_onwards}}\r\n\r\ndef gather_variables(text: str) -> dict[str,str]:\r\n    # before_first_workspace_dependency\r\n    find = \"[workspace.dependencies]\"\r\n    include = True\r\n    index = text.find(find)\r\n    assert index != -1, f\"Coult not find `{find}`\"\r\n    index = index + len(find) if include else index\r\n    before_first_workspace_dependency, remaining = text[:index],text[index:]\r\n\r\n    # first_workspace_dependency_onwards\r\n    first_workspace_dependency_onwards = remaining\r\n\r\n    return {\r\n        \"before_first_workspace_dependency\": before_first_workspace_dependency,\r\n        \"first_workspace_dependency_onwards\": first_workspace_dependency_onwards,\r\n    }\r\n\r\n##### OLD CONTENT OF THIS FILE\r\n\r\n# # {{before_first_workspace_dependency}}\r\n# # cursor_hero_{{crate_name}}_tool = { path = \"./crates/{{crate_name}}_tool\" }\r\n# # {{first_workspace_dependency_onwards}\r\n# \r\n# \r\n# \r\n# def gather_variables(text: str) -> dict[str,str]:\r\n#     find = \"some part of the file\"\r\n#     include = True\r\n#     index = text.find(find)\r\n#     assert index != -1, f\"Coult not find `{find}`\"\r\n#     index = index + len(find) if include else index\r\n#     before_first_workspace_dependency, remaining = text[:index],text[index:]\r\n# \r\n#     first_workspace_dependency_onwards = remaining\r\n# \r\n#     return {\r\n#         \"before_first_workspace_dependency\": before_first_workspace_dependency,\r\n#         \"first_workspace_dependency_onwards\": first_workspace_dependency_onwards,\r\n#     }\r\n# \r\n# ##### OLD CONTENT OF THIS FILE\r\n# \r\n# # # {{before_first_workspace_dependency}}\r\n# # # cursor_hero_{{crate_name}}_tool = { path = \"./crates/{{crate_name}}_tool\" }\r\n# # # {{first_workspace_dependency_onwards}\r\n# # \r\n# # \r\n# # \r\n# # def gather_variables(text: str) -> dict[str,str]:\r\n# #     find = \"some part of the file\"\r\n# #     include = True\r\n# #     index = text.find(find)\r\n# #     assert index != -1, f\"Coult not find `{find}`\"\r\n# #     index = index + len(find) if include else index\r\n# #     before_first_workspace_dependency, remaining = text[:index],text[index:]\r\n# # \r\n# #     first_workspace_dependency_onwards = remaining\r\n# #     return {\r\n# #         \"before_first_workspace_dependency\": before_first_workspace_dependency,\r\n# #         \"first_workspace_dependency_onwards\": first_workspace_dependency_onwards,\r\n# #     }\r\n# # \r\n# # ##### OLD CONTENT OF THIS FILE\r\n# # \r\n# # # # {{before_first_workspace_dependency}}\r\n# # # # cursor_hero_{{crate_name}}_tool = { path = \"./crates/{{crate_name}}_tool\" }\r\n# # # # {{first_workspace_dependency_onwards}\r\n# # # \r\n# # # \r\n# # # \r\n# # # def gather_variables(text: str) -> dict[str,str]:\r\n# # #     find = \"some part of the file\"\r\n# # #     include = True\r\n# # #     index = text.find(find)\r\n# # #     assert index != -1, f\"Coult not find `{find}`\"\r\n# # #     index = index + len(find) if include else index\r\n# # #     before_first_workspace_dependency, remaining = text[:index],text[index:]\r\n# # # \r\n# # #     find = \"some part of the file\"\r\n# # #     include = True\r\n# # #     index = remaining.find(find)\r\n# # #     assert index != -1, f\"Coult not find `{find}`\"\r\n# # #     index = index + len(find) if include else index\r\n# # #     first_workspace_dependency_onwards, remaining = remaining[:index],remaining[index:]\r\n# # # \r\n# # #     return {\r\n# # #         \"before_first_workspace_dependency\": before_first_workspace_dependency,\r\n# # #         \"first_workspace_dependency_onwards\": first_workspace_dependency_onwards,\r\n# # #     }\r\n# # # \r\n# # # ##### OLD CONTENT OF THIS FILE\r\n# # # \r\n# # # # # {{before_first_workspace_dependency}}\r\n# # # # # cursor_hero_{{crate_name}}_tool = { path = \"./crates/{{crate_name}}_tool\" }\r\n# # # # # {{first_workspace_dependency_onwards}\r\n# # # # \r\n# # # # \r\n# # # # \r\n# # # # def gather_variables(text: str) -> dict[str,str]:\r\n# # # #     find = \"some part of the file\"\r\n# # # #     include = True\r\n# # # #     index = text.find(find)\r\n# # # #     assert index != -1, f\"Coult not find `{find}`\"\r\n# # # #     index = index + len(find) if include else index\r\n# # # #     before_first_workspace_dependency, remaining = text[:index],text[index:]\r\n# # # # \r\n# # # #     find = \"some part of the file\"\r\n# # # #     include = True\r\n# # # #     index = remaining.find(find)\r\n# # # #     assert index != -1, f\"Coult not find `{find}`\"\r\n# # # #     index = index + len(find) if include else index\r\n# # # #     first_workspace_dependency_onwards, remaining = remaining[:index],remaining[index:]\r\n# # # # \r\n# # # #     return {\r\n# # # #         \"before_first_workspace_dependency\": before_first_workspace_dependency,\r\n# # # #         \"first_workspace_dependency_onwards\": first_workspace_dependency_onwards,\r\n# # # #     }\r\n# # # # \r\n# # # # ##### OLD CONTENT OF THIS FILE\r\n# # # # \r\n# # # # # # {{before_first_workspace_dependency}}\r\n# # # # # # cursor_hero_{{crate_name}}_tool = { path = \"./crates/{{crate_name}}_tool\" }\r\n# # # # # # {{first_workspace_dependency_onwards}\r\n# # # # # \r\n# # # # # \r\n# # # # # \r\n# # # # # def gather_variables(text: str) -> dict[str,str]:\r\n# # # # #     find = \"some part of the file\"\r\n# # # # #     include = True\r\n# # # # #     index = text.find(find)\r\n# # # # #     assert index != -1, f\"Coult not find `{find}`\"\r\n# # # # #     before_first_workspace_dependency, remaining = text[:index],text[index:]\r\n# # # # # \r\n# # # # #     find = \"some part of the file\"\r\n# # # # #     include = True\r\n# # # # #     index = remaining.find(find)\r\n# # # # #     assert index != -1, f\"Coult not find `{find}`\"\r\n# # # # #     first_workspace_dependency_onwards, remaining = remaining[:index],remaining[index:]\r\n# # # # # \r\n# # # # #     return {\r\n# # # # #         \"before_first_workspace_dependency\": before_first_workspace_dependency,\r\n# # # # #         \"first_workspace_dependency_onwards\": first_workspace_dependency_onwards,\r\n# # # # #     }\r\n# # # # # \r\n# # # # # ##### OLD CONTENT OF THIS FILE\r\n# # # # # \r\n# # # # # # # {{before_first_workspace_dependency}}\r\n# # # # # # # cursor_hero_{{crate_name}}_tool = { path = \"./crates/{{crate_name}}_tool\" }\r\n# # # # # # # {{first_workspace_depndency_onwards}}\r\n# # # # # # \r\n# # # # # # \r\n# # # # # # \r\n# # # # # # def gather_variables(text: str) -> dict[str,str]:\r\n# # # # # #     find = \"some part of the file\"\r\n# # # # # #     include = true\r\n# # # # # #     index = text.find(find)\r\n# # # # # #     assert index != -1, f\"Coult not find `{find}`\"\r\n# # # # # #     before_first_workspace_dependency, remaining = text[:index],text[index:]\r\n# # # # # # \r\n# # # # # #     find = \"some part of the file\"\r\n# # # # # #     include = true\r\n# # # # # #     index = remaining.find(find)\r\n# # # # # #     assert index != -1, f\"Coult not find `{find}`\"\r\n# # # # # #     first_workspace_dependency_onwards, remaining = remaining[:index],remaining[index:]\r\n# # # # # # \r\n# # # # # #     return {\r\n# # # # # #         \"before_first_workspace_dependency\": before_first_workspace_dependency,\r\n# # # # # #         \"first_workspace_dependency_onwards\": first_workspace_dependency_onwards,\r\n# # # # # #     }\r\n# # # # # # \r\n# # # # # # ##### OLD CONTENT OF THIS FILE\r\n# # # # # # \r\n# # # # # # # # {{before_first_workspace_dependency}}\r\n# # # # # # # # cursor_hero_{{crate_name}}_tool = { path = \"./crates/{{crate_name}}_tool\" }\r\n# # # # # # # # {{first_workspace_dependency_onwards}\r\n# # # # # # # \r\n# # # # # # # \r\n# # # # # # # \r\n# # # # # # # def gather_variables(text: str) -> dict[str,str]:\r\n# # # # # # #     find = \"some part of the file\"\r\n# # # # # # #     include = true    index = text.find(find)\r\n# # # # # # #     assert index != -1, f\"Coult not find `{find}`\"\r\n# # # # # # #     before_first_workspace_dependency, remaining = text[:index],text[index:]\r\n# # # # # # # \r\n# # # # # # #     find = \"some part of the file\"\r\n# # # # # # #     include = true    index = remaining.find(find)\r\n# # # # # # #     assert index != -1, f\"Coult not find `{find}`\"\r\n# # # # # # #     first_workspace_dependency_onwards, remaining = remaining[:index],remaining[index:]\r\n# # # # # # # \r\n# # # # # # #     return {\r\n# # # # # # #         \"before_first_workspace_dependency\": before_first_workspace_dependency,\r\n# # # # # # #         \"first_workspace_dependency_onwards\": first_workspace_dependency_onwards,\r\n# # # # # # #     }\r\n# # # # # # # \r\n# # # # # # # ##### OLD CONTENT OF THIS FILE\r\n# # # # # # # \r\n# # # # # # # # # {{before_first_workspace_dependency}}\r\n# # # # # # # # # cursor_hero_{{crate_name}}_tool = { path = \"./crates/{{crate_name}}_tool\" }\r\n# # # # # # # # # {{first_workspace_dependency_onw\r\n# # # # # # # # \r\n# # # # # # # # \r\n# # # # # # # # \r\n# # # # # # # # def gather_variables(text: str) -> dict[str,str]:\r\n# # # # # # # #     find = \"some part of the file\"\r\n# # # # # # # #     include = true    index = text.find(find)\r\n# # # # # # # #     assert index != -1, f\"Coult not find `{find}`\"\r\n# # # # # # # #     before_first_workspace_dependency, remaining = text[:index],text[index:]\r\n# # # # # # # # \r\n# # # # # # # #     find = \"some part of the file\"\r\n# # # # # # # #     include = true    index = remaining.find(find)\r\n# # # # # # # #     assert index != -1, f\"Coult not find `{find}`\"\r\n# # # # # # # #     first_workspace_dependency_onwards, remaining = remaining[:index],remaining[index:]\r\n# # # # # # # # \r\n# # # # # # # #     return {\r\n# # # # # # # #         \"before_first_workspace_dependency\": before_first_workspace_dependency,\r\n# # # # # # # #         \"first_workspace_dependency_onwards\": first_workspace_dependency_onwards,\r\n# # # # # # # #     }\r\n# # # # # # # # \r\n# # # # # # # # ##### OLD CONTENT OF THIS FILE# # {{before_first_workspace_dependency}}\r\n# # # # # # # # # # cursor_hero_{{crate_name}}_tool = { path = \"./crates/{{crate_name}}_tool\" }\r\n# # # # # # # # # \r\n# # # # # # # # # \r\n# # # # # # # # # \r\n# # # # # # # # # \r\n# # # # # # # # # def gather_variables(text: str) -> dict[str,str]:\r\n# # # # # # # # #     find = \"some part of the file\"\r\n# # # # # # # # #     include = true    index = text.find(find)\r\n# # # # # # # # #     assert index != -1, f\"Coult not find `{find}`\"\r\n# # # # # # # # #     before_first_workspace_dependency, remaining = text[:index],text[index:]\r\n# # # # # # # # # \r\n# # # # # # # # #     find = \"some part of the file\"\r\n# # # # # # # # #     include = true    index = remaining.find(find)\r\n# # # # # # # # #     assert index != -1, f\"Coult not find `{find}`\"\r\n# # # # # # # # #     first_workspace_dependency_onwards, remaining = remaining[:index],remaining[index:]\r\n# # # # # # # # # \r\n# # # # # # # # #     return {\r\n# # # # # # # # #         \"before_first_workspace_dependency\": before_first_workspace_dependency,\r\n# # # # # # # # #         \"first_workspace_dependency_onwards\": first_workspace_dependency_onwards,\r\n# # # # # # # # #     }\r\n# # # # # # # # \r\n# # # # # # # # \r\n# # # # # # # \r\n# # # # # # # \r\n# # # # # # \r\n# # # # # # \r\n# # # # # \r\n# # # # # \r\n# # # # \r\n# # # # \r\n# # # \r\n# # # \r\n# # \r\n# # \r\n# \r\n# \r\n\r\n\r\n##### WORKSPACE CONTENT\r\n#[package]\r\n#name = \"cursor_hero\"\r\n#version = \"0.3.0\"\r\n#edition = \"2021\"\r\n#\r\n#[workspace]\r\n#members = [\"crates/*\", \"other/gamepad_hell\", \"other/uparrow-enter\"]\r\n#\r\n## See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n#\r\n#[workspace.dependencies]\r\n#cursor_hero_environment_types = { path = \"./crates/environment_types\" }\r\n#cursor_hero_chat_types = { path = \"./crates/chat_types\" }\r\n#cursor_hero_chat = { path = \"./crates/chat\" }\r\n#cursor_hero_tts = { path = \"./crates/tts\" }\r\n#cursor_hero_tts_types = { path = \"./crates/tts_types\" }\r\n#cursor_hero_observation_types = { path = \"./crates/observation_types\" }\r\n#cursor_hero_observation = { path = \"./crates/observation\" }\r\n#cursor_hero_inference_types = { path = \"./crates/inference_types\" }\r\n#cursor_hero_inference = { path = \"./crates/inference\" }\r\n#cursor_hero_movement_tool_types = { path = \"./crates/movement_tool_types\" }\r\n#cursor_hero_movement_tool = { path = \"./crates/movement_tool\" }\r\n#cursor_hero_character_types = { path = \"./crates/character_types\" }\r\n#cursor_hero_agent_types = { path = \"./crates/agent_types\" }\r\n#cursor_hero_physics_debug = { path = \"./crates/physics_debug\" }\r\n#cursor_hero_math = { path = \"./crates/math\" }\r\n#cursor_hero_pointer_types = { path = \"./crates/pointer_types\" }\r\n#cursor_hero_toolbelt_types = { path = \"./crates/toolbelt_types\" }\r\n#cursor_hero_sprint_tool_types = { path = \"./crates/sprint_tool_types\" }\r\n#cursor_hero_sprint_tool = { path = \"./crates/sprint_tool\" }\r\n#cursor_hero_agent = { path = \"./crates/agent\" }\r\n#cursor_hero_taskbar = { path = \"./crates/taskbar\" }\r\n#cursor_hero_environment_nametag = { path = \"./crates/environment_nametag\" }\r\n#cursor_hero_environment = { path = \"./crates/environment\" }\r\n#cursor_hero_xelu_prompts = { path = \"./crates/xelu_prompts\" }\r\n#cursor_hero_pause_tool = { path = \"./crates/pause_tool\" }\r\n#cursor_hero_wallpaper = { path = \"./crates/wallpaper\" }\r\n#cursor_hero_cursor_mirror = { path = \"./crates/cursor_mirror\" }\r\n#cursor_hero_hover = { path = \"./crates/hover\" }\r\n#cursor_hero_pressure_plate = { path = \"./crates/pressure_plate\" }\r\n#cursor_hero_level_bounds = { path = \"./crates/level_bounds\" }\r\n#cursor_hero_bevy = { path = \"./crates/bevy\" }\r\n#cursor_hero_input = { path = \"./crates/input\" }\r\n#cursor_hero_camera = { path = \"./crates/camera\" }\r\n#cursor_hero_character = { path = \"./crates/character\" }\r\n#cursor_hero_data = { path = \"./crates/data\" }\r\n#cursor_hero_metrics = { path = \"./crates/metrics\" }\r\n#cursor_hero_click_drag_character_movement = { path = \"./crates/click_drag_character_movement\" }\r\n#cursor_hero_physics = { path = \"./crates/physics\" }\r\n#cursor_hero_pointer = { path = \"./crates/pointer\" }\r\n#cursor_hero_screen = { path = \"./crates/screen\" }\r\n#cursor_hero_toolbelt = { path = \"./crates/toolbelt\" }\r\n#cursor_hero_tools = { path = \"./crates/tools\" }\r\n#cursor_hero_ui = { path = \"./crates/ui\" }\r\n#cursor_hero_winutils = { path = \"./crates/winutils\" }\r\n#cursor_hero_restart_memory = { path = \"./crates/restart_memory\" }\r\n#cursor_hero_version = { path = \"./crates/version\" }\r\n#cursor_hero_plugins = { path = \"./crates/plugins\" }\r\n#cursor_hero_icon = { path = \"./crates/icon\" }\r\n##inline_tweak = {git = \"https://github.com/Uriopass/inline_tweak\", version = \"1.1.0\", tag = \"v1.1.0\"} # features=[\"derive\"]\r\n#anyhow = \"1.0.75\"\r\n#glam = \"0.25.0\"\r\n## bevy = { path = \"../bevy\", features = [\"dynamic_linking\"] }\r\n#bevy = { version = \"0.12.1\", git = \"https://github.com/TeamDman/bevy.git\", branch = \"cursor_hero\" }\r\n#bevy-inspector-egui = { version = \"0.22.1\", git = \"https://github.com/TeamDman/bevy-inspector-egui.git\", branch = \"cursor_hero\" }\r\n#bevy_xpbd_2d = { git = \"https://github.com/TeamDman/bevy_xpbd.git\", branch = \"cursor_hero\", features = [\r\n#  \"simd\",\r\n#  \"parallel\",\r\n#] }\r\n#bevy_egui = { git = \"https://github.com/TeamDman/bevy_egui.git\", branch = \"cursor_hero\", version = \"0.24\" }\r\n## enigo = {git = \"https://github.com/TeamDman/enigo\", branch = \"cursor_hero\", version = \"0.1.3\"}\r\n## enigo = {path = \"../../rust/enigo\", version = \"0.1.3\"}\r\n#enigo = \"0.2.0-rc2\"\r\n#egui = \"0.24\"\r\n#crossbeam-channel = \"0.5.8\"\r\n#itertools = \"0.12.0\"\r\n#raw-window-handle = \"0.5.2\"\r\n#leafwing-input-manager = { git = \"https://github.com/TeamDman/leafwing-input-manager.git\", branch = \"cursor_hero\" }\r\n#windows = \"0.51.1\"\r\n#indexmap = \"2.1.0\"\r\n#image = \"0.24.7\"\r\n#screenshots = \"0.8.4\"\r\n#uiautomation = \"0.7.3\"\r\n#serde = { version = \"1.0\", features = [\"derive\"] }\r\n#serde_json = \"1.0\"\r\n#tokio = { version = \"1.32.0\", features = [\"net\", \"full\"] }\r\n#tokio-named-pipes = \"0.1.0\"\r\n#syn = { version = \"2.0.48\", features = [\"full\", \"visit-mut\", \"visit\"] }\r\n#quote = \"1.0.35\"\r\n#proc-macro2 = \"1.0.76\"\r\n#bevy_embedded_assets = { version = \"0.9.1\", git = \"https://github.com/TeamDman/bevy_embedded_assets.git\", branch = \"cursor_hero\" }\r\n#winit = \"0.28.7\"\r\n#fxhash = \"0.2.1\"\r\n#widestring = \"1.0.2\"\r\n#winreg = \"0.52.0\"\r\n#rand = \"0.8.5\"\r\n#ollama-rs = \"0.1.6\"\r\n#reqwest = \"0.11.24\"\r\n#urlencoding = \"2.1.3\"\r\n#chrono = \"0.4.33\"\r\n#\r\n#[dependencies]\r\n#cursor_hero_plugins = { workspace = true }\r\n#cursor_hero_version = { workspace = true }\r\n#bevy = { workspace = true }\r\n#\r\n#\r\n#[dev-dependencies]\r\n#bevy = { workspace = true, features = [\"dynamic_linking\"] }\r\n#\r\n#\r\n#[build-dependencies]\r\n#embed-resource = \"1.6.3\"\r\n#\r\n#[profile.dev]\r\n#opt-level = 1\r\n#\r\n#[profile.dev.package.\"*\"]\r\n#opt-level = 3\r\n#\r\n## [patch.crates-io]\r\n## winit = { path = \"D:/Repos/rust/winit\" }\r\n#\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\hover\\src\\lib.rs\r\n\r\n````rust\r\n#![feature(let_chains)]\r\npub mod hover_tool;\r\npub mod hover_ui_automation_plugin;\r\npub mod inspect_wheel_tool;\r\npub mod screenshot_tool;\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\version\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_version\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\toolbelt\\src\\tool_help_click.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse cursor_hero_host_fs_types::host_fs_types::HostPath;\r\nuse cursor_hero_host_fs_types::host_fs_types::HostPathAction;\r\nuse cursor_hero_pointer_types::pointer_click_types::ClickEvent;\r\nuse cursor_hero_pointer_types::pointer_click_types::Way;\r\nuse cursor_hero_toolbelt_types::toolbelt_types::ToolHelpTrigger;\r\n\r\n/// Doesn't work with loadouts without the click tool lol\r\npub fn help_click_listener(\r\n    mut click_events: EventReader<ClickEvent>,\r\n    help_query: Query<&HostPath, With<ToolHelpTrigger>>,\r\n    mut host_fs_events: EventWriter<HostPathAction>,\r\n) {\r\n    for event in click_events.read() {\r\n        let ClickEvent::Clicked {\r\n            target_id,\r\n            way: Way::Left,\r\n            ..\r\n        } = event\r\n        else {\r\n            continue;\r\n        };\r\n        let Ok(help) = help_query.get(*target_id) else {\r\n            continue;\r\n        };\r\n        let src_path = help;\r\n        let msg = HostPathAction::OpenWithCode {\r\n            path: src_path.clone(),\r\n        };\r\n        info!(\"Sending message: {:?}\", msg);\r\n        host_fs_events.send(msg);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\window_swap_tool\\src\\lib.rs\r\n\r\n````rust\r\npub mod window_swap_tool_plugin;\r\npub mod window_swap_tool_populate_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::window_swap_tool_plugin::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\physics\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_physics\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\nbevy-inspector-egui = { workspace = true }\r\nbevy_xpbd_2d = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\text_asset\\src\\lib.rs\r\n\r\n````rust\r\npub mod text_asset_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::text_asset_plugin::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\winutils\\src\\win_cursor.rs\r\n\r\n````rust\r\nuse crate::win_errors::*;\r\nuse crate::win_icons::convert_hcursor_to_rgba_image;\r\nuse image::RgbaImage;\r\nuse windows::Win32::UI::WindowsAndMessaging::LoadCursorW;\r\nuse windows::Win32::UI::WindowsAndMessaging::IDC_APPSTARTING;\r\nuse windows::Win32::UI::WindowsAndMessaging::IDC_ARROW;\r\nuse windows::Win32::UI::WindowsAndMessaging::IDC_CROSS;\r\nuse windows::Win32::UI::WindowsAndMessaging::IDC_HAND;\r\nuse windows::Win32::UI::WindowsAndMessaging::IDC_HELP;\r\nuse windows::Win32::UI::WindowsAndMessaging::IDC_IBEAM;\r\nuse windows::Win32::UI::WindowsAndMessaging::IDC_NO;\r\nuse windows::Win32::UI::WindowsAndMessaging::IDC_SIZEALL;\r\nuse windows::Win32::UI::WindowsAndMessaging::IDC_SIZENESW;\r\nuse windows::Win32::UI::WindowsAndMessaging::IDC_SIZENS;\r\nuse windows::Win32::UI::WindowsAndMessaging::IDC_SIZENWSE;\r\nuse windows::Win32::UI::WindowsAndMessaging::IDC_SIZEWE;\r\nuse windows::Win32::UI::WindowsAndMessaging::IDC_UPARROW;\r\nuse windows::Win32::UI::WindowsAndMessaging::IDC_WAIT;\r\n\r\npub fn get_all_cursor_icons() -> Result<Vec<RgbaImage>> {\r\n    let mut icons = Vec::new();\r\n\r\n    // Load each cursor and convert it to an RgbaImage\r\n    for cursor_id in [\r\n        IDC_ARROW,\r\n        IDC_IBEAM,\r\n        IDC_WAIT,\r\n        IDC_CROSS,\r\n        IDC_UPARROW,\r\n        IDC_SIZEALL,\r\n        IDC_SIZENESW,\r\n        IDC_SIZENS,\r\n        IDC_SIZENWSE,\r\n        IDC_SIZEWE,\r\n        IDC_HAND,\r\n        IDC_HELP,\r\n        IDC_NO,\r\n        IDC_APPSTARTING,\r\n    ] {\r\n        let hcursor = unsafe { LoadCursorW(None, cursor_id)? };\r\n        if hcursor.is_invalid() {\r\n            return Err(Error::from_win32()\r\n                .with_description(format!(\"Failed to load cursor with ID {:?}\", cursor_id.0)));\r\n        }\r\n        let image = convert_hcursor_to_rgba_image(&hcursor)?;\r\n        icons.push(image);\r\n    }\r\n\r\n    Ok(icons)\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use std::path::PathBuf;\r\n\r\n    #[test]\r\n    fn test_get_all_cursor_icons() {\r\n        let icons = super::get_all_cursor_icons().unwrap();\r\n\r\n        // Ensure the expected amount is present\r\n        assert_eq!(icons.len(), 14);\r\n\r\n        // Save icons\r\n        let mut path = PathBuf::from(\"target/cursor_icons\");\r\n        std::fs::create_dir_all(&path).unwrap();\r\n        for (i, icon) in icons.iter().enumerate() {\r\n            let mut icon_path = path.clone();\r\n            icon_path.push(format!(\"{}.png\", i));\r\n            icon.save(icon_path).unwrap();\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\templates\\matchers\\new_plugin_with_types\\crates\\plugins\\src\\lib.rs.py\r\n\r\n````py\r\n# {{use_statements}}\r\n# use cursor_hero_{{crate_name}}::prelude::*;\r\n# use cursor_hero_{{crate_name}}_types::prelude::*;\r\n# {{plugin_start}}\r\n#         app.add_plugins({{crate_name_pascal}}TypesPlugin);\r\n#         app.add_plugins({{crate_name_pascal}}Plugin);\r\n# {{plugin_remaining}}\r\n\r\ndef gather_variables(text: str) -> dict[str,str]:\r\n    # use_statements\r\n    find = \"pub struct MyPlugin;\"\r\n    include = False\r\n    index = text.find(find)\r\n    assert index != -1, f\"Coult not find `{find}`\"\r\n    index = index + len(find) if include else index\r\n    use_statements, remaining = text[:index],text[index:]\r\n\r\n    # plugin_start\r\n    find = \"fn build(&self, app: &mut App) {\"\r\n    include = True\r\n    index = remaining.find(find)\r\n    assert index != -1, f\"Coult not find `{find}`\"\r\n    index = index + len(find) if include else index\r\n    plugin_start, remaining = remaining[:index],remaining[index:]\r\n\r\n    # plugin_remaining\r\n    plugin_remaining = remaining\r\n\r\n    return {\r\n        \"use_statements\": use_statements,\r\n        \"plugin_start\": plugin_start,\r\n        \"plugin_remaining\": plugin_remaining,\r\n    }\r\n\r\n#region WORKSPACE CONTENT\r\n#use bevy::input::common_conditions::input_toggle_active;\r\n#use bevy::prelude::*;\r\n#\r\n#use bevy::audio::AudioPlugin;\r\n#use bevy::audio::SpatialScale;\r\n#use bevy::diagnostic::FrameTimeDiagnosticsPlugin;\r\n#use bevy::log::LogPlugin;\r\n#use bevy_embedded_assets::EmbeddedAssetPlugin;\r\n#use bevy_inspector_egui::quick::WorldInspectorPlugin;\r\n#use cursor_hero_agent::agent_plugin::AgentPlugin;\r\n#use cursor_hero_camera::camera_plugin::CameraPlugin;\r\n#use cursor_hero_character::character_plugin::CharacterPlugin;\r\n#use cursor_hero_cursor_mirror::cursor_mirroring_plugin::CursorMirroringPlugin;\r\n#use cursor_hero_environment::environment_plugin::EnvironmentPlugin;\r\n#use cursor_hero_environment_nametag::environment_nametag_plugin::EnvironmentNametagPlugin;\r\n#use cursor_hero_hover::afterimage_plugin::AfterimagePlugin;\r\n#use cursor_hero_hover::hover_tool::HoverToolPlugin;\r\n#use cursor_hero_hover::hover_ui_automation_plugin::HoverUiAutomationPlugin;\r\n#use cursor_hero_hover::inspect_tool::InspectToolPlugin;\r\n#use cursor_hero_hover::inspect_wheel_tool::InspectWheelToolPlugin;\r\n#use cursor_hero_icon::IconPlugin;\r\n#use cursor_hero_input::InputPlugin;\r\n#use cursor_hero_level_bounds::level_bounds_plugin::LevelBoundsPlugin;\r\n#use cursor_hero_math::math_plugin::MathPlugin;\r\n#use cursor_hero_pause_tool::pause_tool_plugin::PauseToolPlugin;\r\n#use cursor_hero_physics::damping_plugin::DampingPlugin;\r\n#use cursor_hero_physics::physics_plugin::PhysicsPlugin;\r\n#use cursor_hero_physics_debug::physics_debug_plugin::PhysicsDebugPlugin;\r\n#use cursor_hero_pointer::pointer_plugin::PointerPlugin;\r\n#use cursor_hero_pointer_types::pointer_types_plugin::PointerTypesPlugin;\r\n#use cursor_hero_pressure_plate::pressure_plate_plugin::PressurePlatePlugin;\r\n#use cursor_hero_restart_memory::MemoryPlugin;\r\n##[cfg(debug_assertions)]\r\n#use cursor_hero_screen::screen_plugin::ScreenPlugin;\r\n#use cursor_hero_screen::screen_update_plugin::ScreenUpdatePlugin;\r\n#use cursor_hero_sprint_tool::sprint_tool_plugin::SprintToolPlugin;\r\n#use cursor_hero_sprint_tool_types::sprint_tool_types_plugin::SprintToolTypesPlugin;\r\n#use cursor_hero_taskbar::taskbar_plugin::TaskbarPlugin;\r\n#use cursor_hero_toolbelt::toolbelt_plugin::ToolbeltPlugin;\r\n#use cursor_hero_toolbelt_types::toolbelt_types_plugin::ToolbeltTypesPlugin;\r\n#use cursor_hero_tools::ToolPlugin;\r\n#use cursor_hero_ui::about_text_plugin::AboutTextPlugin;\r\n#use cursor_hero_ui::fps_text_plugin::FpsTextPlugin;\r\n#use cursor_hero_version::version_plugin::Version;\r\n#use cursor_hero_wallpaper::wallpaper_plugin::WallpaperPlugin;\r\n#\r\n#use cursor_hero_agent_types::agent_types_plugin::AgentTypesPlugin;\r\n#use cursor_hero_character_types::character_types_plugin::CharacterTypesPlugin;\r\n#use cursor_hero_chat::chat_plugin::ChatPlugin;\r\n#use cursor_hero_chat_types::chat_types_plugin::ChatTypesPlugin;\r\n#use cursor_hero_inference::inference_plugin::InferencePlugin;\r\n#use cursor_hero_inference_types::inference_types_plugin::InferenceTypesPlugin;\r\n#use cursor_hero_movement_tool::movement_tool_plugin::MovementToolPlugin;\r\n#use cursor_hero_movement_tool_types::movement_tool_types_plugin::MovementToolTypesPlugin;\r\n#use cursor_hero_observation::observation_plugin::ObservationPlugin;\r\n#use cursor_hero_observation_types::observation_types_plugin::ObservationTypesPlugin;\r\n#use cursor_hero_tts::tts_plugin::TtsPlugin;\r\n#use cursor_hero_tts_types::tts_types_plugin::TtsTypesPlugin;\r\n#use cursor_hero_environment_types::environment_types_plugin::EnvironmentTypesPlugin;\r\n#pub struct MyPlugin;\r\n#\r\n#impl Plugin for MyPlugin {\r\n#    fn build(&self, app: &mut App) {\r\n#        app.add_plugins(EnvironmentTypesPlugin);\r\n#        app.add_plugins(ChatTypesPlugin);\r\n#        app.add_plugins(ChatPlugin);\r\n#        app.add_plugins(TtsPlugin);\r\n#        app.add_plugins(TtsTypesPlugin);\r\n#        app.add_plugins(ObservationTypesPlugin);\r\n#        app.add_plugins(ObservationPlugin);\r\n#        app.add_plugins(InferenceTypesPlugin);\r\n#        app.add_plugins(InferencePlugin);\r\n#        app.add_plugins(MovementToolTypesPlugin);\r\n#        app.add_plugins(MovementToolPlugin);\r\n#        app.add_plugins(CharacterTypesPlugin);\r\n#        app.add_plugins(AgentTypesPlugin);\r\n#        app.add_plugins(AgentPlugin);\r\n#        //app.add_plugins(ClickDragMovementPlugin);\r\n#        //app.add_plugins(HoverShowerRelayPlugin);\r\n#        //app.add_plugins(HoverShowerServicePlugin);\r\n#        app.add_plugins(AboutTextPlugin);\r\n#        app.add_plugins(AfterimagePlugin);\r\n#        app.add_plugins(CameraPlugin);\r\n#        app.add_plugins(CharacterPlugin);\r\n#        app.add_plugins(CursorMirroringPlugin);\r\n#        app.add_plugins(DampingPlugin);\r\n#        app.add_plugins(EnvironmentNametagPlugin);\r\n#        app.add_plugins(EnvironmentPlugin);\r\n#        app.add_plugins(FpsTextPlugin);\r\n#        app.add_plugins(HoverToolPlugin);\r\n#        app.add_plugins(HoverUiAutomationPlugin);\r\n#        app.add_plugins(IconPlugin);\r\n#        app.add_plugins(InputPlugin);\r\n#        app.add_plugins(InspectToolPlugin);\r\n#        app.add_plugins(InspectWheelToolPlugin);\r\n#        app.add_plugins(LevelBoundsPlugin);\r\n#        app.add_plugins(MathPlugin);\r\n#        app.add_plugins(MemoryPlugin);\r\n#        app.add_plugins(PauseToolPlugin);\r\n#        app.add_plugins(PhysicsDebugPlugin);\r\n#        app.add_plugins(PhysicsPlugin);\r\n#        app.add_plugins(PointerPlugin);\r\n#        app.add_plugins(PointerTypesPlugin);\r\n#        // app.add_plugins(PositionTextPlugin);\r\n#        app.add_plugins(PressurePlatePlugin);\r\n#        app.add_plugins(ScreenPlugin);\r\n#        app.add_plugins(ScreenUpdatePlugin);\r\n#        app.add_plugins(SprintToolPlugin);\r\n#        app.add_plugins(SprintToolTypesPlugin);\r\n#        app.add_plugins(TaskbarPlugin);\r\n#        app.add_plugins(ToolbeltPlugin);\r\n#        app.add_plugins(ToolbeltTypesPlugin);\r\n#        app.add_plugins(ToolPlugin);\r\n#        app.add_plugins(WallpaperPlugin);\r\n#\r\n#        // must be before the default plugins\r\n#        app.add_plugins(EmbeddedAssetPlugin {\r\n#            mode: bevy_embedded_assets::PluginMode::ReplaceDefault,\r\n#        });\r\n#\r\n#        #[cfg(debug_assertions)]\r\n#        let log_plugin = LogPlugin {\r\n#            level: bevy::log::Level::DEBUG,\r\n#            filter: \"info,wgpu_core=warn,wgpu_hal=warn,bevy_ecs=info,cursor_hero=debug\".into(),\r\n#            // filter: \"debug,wgpu_core=warn,wgpu_hal=warn,bevy_ecs=info,cursor_hero=debug\".into(),\r\n#        };\r\n#        #[cfg(not(debug_assertions))]\r\n#        let log_plugin = LogPlugin {\r\n#            level: bevy::log::Level::INFO,\r\n#            filter: \"info,wgpu_core=warn,wgpu_hal=warn\".into(),\r\n#        };\r\n#        const AUDIO_SCALE: f32 = 1. / 100.0;\r\n#        let version = match app.world.get_resource::<Version>() {\r\n#            Some(version) => version.0.clone(),\r\n#            None => {\r\n#                warn!(\"Version resource not found\");\r\n#                \"Unknown\".to_string()\r\n#            }\r\n#        };\r\n#        app.add_plugins(\r\n#            DefaultPlugins\r\n#                .set(ImagePlugin::default_nearest())\r\n#                .set(AudioPlugin {\r\n#                    spatial_scale: SpatialScale::new_2d(AUDIO_SCALE),\r\n#                    ..default()\r\n#                })\r\n#                .set(WindowPlugin {\r\n#                    primary_window: Some(Window {\r\n#                        transparent: true,\r\n#                        title: format!(\"Cursor Hero v{}\", version),\r\n#                        resizable: true,\r\n#                        ..default()\r\n#                    }),\r\n#                    ..default()\r\n#                })\r\n#                .set(log_plugin)\r\n#                .build(),\r\n#        );\r\n#\r\n#        // must be after the default plugins\r\n#        app.add_plugins(\r\n#            WorldInspectorPlugin::default().run_if(input_toggle_active(false, KeyCode::Grave)),\r\n#        );\r\n#        app.add_plugins(FrameTimeDiagnosticsPlugin);\r\n#    }\r\n#}\r\n#\r\n#endregion\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\calculator_app_types\\src\\calculator_app_types.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n\r\n#[derive(Component, Debug, Reflect)]\r\npub struct AppWindow;\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\toolbelt\\src\\tool_help_cleanup.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n\r\nuse cursor_hero_toolbelt_types::toolbelt_types::ToolHelp;\r\n\r\npub fn tool_help_cleanup(\r\n    mut commands: Commands,\r\n    mut tool_help_query: Query<(Entity, &mut ToolHelp)>,\r\n    time: Res<Time>,\r\n) {\r\n    for (tool_help_id, mut tool_help) in &mut tool_help_query {\r\n        if tool_help.timer.tick(time.delta()).just_finished() {\r\n            commands.entity(tool_help_id).despawn_recursive();\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\memory\\src\\main_camera_memory_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse cursor_hero_camera::camera_plugin::MainCamera;\r\nuse cursor_hero_memory_types::prelude::*;\r\nuse serde::Deserialize;\r\nuse serde::Serialize;\r\n\r\npub struct MainCameraMemoryPlugin;\r\n\r\nimpl Plugin for MainCameraMemoryPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.insert_resource(MainCameraMemoryConfig::default());\r\n        app.add_systems(Update, persist.pipe(handle_persist_errors));\r\n        app.add_systems(Update, restore.pipe(handle_restore_errors));\r\n    }\r\n}\r\nconst PERSIST_FILE_NAME: &str = \"main_camera.json\";\r\n\r\n// not moved to lib to ensure log contains this module name\r\nfn handle_persist_errors(In(result): In<Result<PersistSuccess, PersistError>>) {\r\n    if let Err(e) = result {\r\n        error!(\"Persist error occurred: {:?}\", e);\r\n    } else if let Ok(PersistSuccess::WritePerformed) = result {\r\n        debug!(\"Persisted succeeded\");\r\n    }\r\n}\r\n\r\nfn handle_restore_errors(In(result): In<Result<RestoreSuccess, RestoreError>>) {\r\n    if let Err(e) = result {\r\n        error!(\"Restore error occurred: {:?}\", e);\r\n    } else if let Ok(RestoreSuccess::Performed) = result {\r\n        info!(\"Restore succeeded\");\r\n    }\r\n}\r\n\r\n#[derive(Debug, Resource, Reflect)]\r\n#[reflect(Resource)]\r\nstruct MainCameraMemoryConfig {\r\n    pub debounce_timer: Timer,\r\n}\r\nimpl Default for MainCameraMemoryConfig {\r\n    fn default() -> Self {\r\n        Self {\r\n            debounce_timer: Timer::from_seconds(10.0, TimerMode::Repeating),\r\n        }\r\n    }\r\n}\r\n\r\n#[derive(Debug, Serialize, Deserialize, PartialEq, Clone, Copy)]\r\nstruct DiskData {\r\n    scale: Vec3,\r\n}\r\n\r\nfn persist(\r\n    mut config: ResMut<MainCameraMemoryConfig>,\r\n    memory_config: Res<MemoryConfig>,\r\n    mut debounce: Local<Option<DiskData>>,\r\n    time: Res<Time>,\r\n    camera_query: Query<&Transform, With<MainCamera>>,\r\n) -> Result<PersistSuccess, PersistError> {\r\n    if !config.debounce_timer.tick(time.delta()).just_finished() {\r\n        return Ok(PersistSuccess::Cooldown);\r\n    }\r\n\r\n    let camera_transform = camera_query.get_single().map_err(|_| PersistError::Query)?;\r\n\r\n    let data = DiskData {\r\n        scale: camera_transform.scale,\r\n    };\r\n    if debounce.is_none() || debounce.as_ref().unwrap() != &data {\r\n        let file = get_persist_file(memory_config.as_ref(), PERSIST_FILE_NAME, Usage::Persist)\r\n            .map_err(PersistError::Io)?;\r\n        write_to_disk(file, data)?;\r\n        *debounce = Some(data);\r\n        Ok(PersistSuccess::WritePerformed)\r\n    } else {\r\n        Ok(PersistSuccess::Debounce)\r\n    }\r\n}\r\n\r\nfn restore(\r\n    memory_config: Res<MemoryConfig>,\r\n    mut camera_query: Query<&mut Transform, Added<MainCamera>>,\r\n) -> Result<RestoreSuccess, RestoreError> {\r\n    let Ok(mut camera_transform) = camera_query.get_single_mut() else {\r\n        return Ok(RestoreSuccess::NoAction);\r\n    };\r\n    let file = get_persist_file(memory_config.as_ref(), PERSIST_FILE_NAME, Usage::Restore)\r\n        .map_err(RestoreError::Io)?;\r\n    let data: DiskData = read_from_disk(file)?;\r\n    info!(\"Restoring main camera scale to {:?}\", data.scale);\r\n    camera_transform.scale = data.scale;\r\n    Ok(RestoreSuccess::Performed)\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\movement_tool\\src\\movement_tool.rs\r\n\r\n````rust\r\nuse crate::tool_spawning::ToolSpawnConfig;\r\nuse bevy::prelude::*;\r\nuse bevy_xpbd_2d::math::*;\r\nuse bevy_xpbd_2d::prelude::*;\r\nuse cursor_hero_character_types::prelude::*;\r\nuse cursor_hero_math::prelude::Lerp;\r\nuse itertools::Itertools;\r\nuse leafwing_input_manager::prelude::*;\r\nuse leafwing_input_manager::user_input::InputKind;\r\n\r\npub struct MovementToolPlugin;\r\n\r\nimpl Plugin for MovementToolPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        \r\n    }\r\n}\r\n\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\observation_types\\src\\observation_types.rs\r\n\r\n````rust\r\nuse std::fmt;\r\nuse std::fmt::Display;\r\nuse std::fmt::Formatter;\r\nuse std::time::Duration;\r\n\r\nuse bevy::prelude::*;\r\nuse chrono::DateTime;\r\nuse chrono::Local;\r\nuse cursor_hero_ui_automation_types::prelude::UISnapshot;\r\nuse serde::Deserialize;\r\nuse serde::Serialize;\r\n#[derive(Component, Reflect, Default)]\r\npub struct ObservationTool {\r\n    #[reflect(ignore)]\r\n    pub last_inference: Option<DateTime<Local>>,\r\n    pub _whats_new: Option<WhatsNew>, // latest value for visual inspection\r\n}\r\n\r\n#[derive(Debug, Reflect, PartialEq, Eq, Clone, Copy)]\r\npub enum WhatsNew {\r\n    Nothing,\r\n    SelfChat,\r\n    ChatReceived,\r\n    ChatReceivedButTheyProbablyStillThinking,\r\n    MemoryRestored,\r\n    UISnapshot,\r\n}\r\n\r\nimpl WhatsNew {\r\n    /// When the agent replies, it sends a chat, which becomes its own observation\r\n    /// Letting this trigger the inference again is a loop\r\n    /// We want to allow this loop, but only after a longer period of inactivity compared\r\n    /// to if a chat was received from another entity.\r\n    pub fn reply_delay(&self) -> Duration {\r\n        match self {\r\n            WhatsNew::SelfChat => Duration::from_secs(60),\r\n            WhatsNew::Nothing => Duration::MAX,\r\n            WhatsNew::ChatReceived => Duration::ZERO,\r\n            WhatsNew::ChatReceivedButTheyProbablyStillThinking => Duration::from_secs(25),\r\n            WhatsNew::MemoryRestored => Duration::from_secs(5),\r\n            WhatsNew::UISnapshot => Duration::from_secs(60 * 2),\r\n        }\r\n    }\r\n}\r\n\r\nimpl Ord for WhatsNew {\r\n    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\r\n        // In-declaration order of importance, higher is more important\r\n        (*self as u32).cmp(&(*other as u32))\r\n    }\r\n}\r\nimpl PartialOrd for WhatsNew {\r\n    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {\r\n        Some(self.cmp(other))\r\n    }\r\n}\r\n\r\n#[derive(Component, Reflect, Default, Serialize, Deserialize, Debug, Clone, PartialEq)]\r\npub struct ObservationBuffer {\r\n    pub observations: Vec<ObservationBufferEntry>,\r\n    pub log_level: ObservationLogLevel, // TODO: investigate always logging but updating the log filter instead of not logging based on level\r\n}\r\n\r\n#[derive(Debug, Reflect, Default, PartialEq, Eq, Serialize, Deserialize, Clone)]\r\npub enum ObservationLogLevel {\r\n    #[default]\r\n    Default,\r\n    All,\r\n}\r\n\r\n#[derive(Component, Reflect, Debug, Serialize, Deserialize, PartialEq, Clone)]\r\npub struct ObservationBufferEntry {\r\n    #[reflect(ignore)]\r\n    pub datetime: DateTime<Local>,\r\n    pub origin: SomethingObservableHappenedEvent,\r\n}\r\n\r\n#[derive(Event, Debug, Clone, Reflect)]\r\npub enum ObservationBufferEvent {\r\n    Updated { buffer_id: Entity },\r\n}\r\n\r\n#[derive(Event, Debug, Clone, Reflect, Serialize, Deserialize, PartialEq)]\r\npub enum SomethingObservableHappenedEvent {\r\n    Chat {\r\n        environment_id: Option<Entity>,\r\n        character_id: Entity,\r\n        character_name: String,\r\n        message: String,\r\n    },\r\n    MemoryRestored {\r\n        observation_buffer_id: Entity,\r\n    },\r\n    UISnapshot {\r\n        environment_id: Option<Entity>,\r\n        snapshot: UISnapshot,\r\n    },\r\n    // BrickEnteredEnvironment {\r\n\r\n    // }\r\n}\r\nimpl Display for SomethingObservableHappenedEvent {\r\n    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {\r\n        match self {\r\n            SomethingObservableHappenedEvent::Chat {\r\n                character_name,\r\n                message,\r\n                ..\r\n            } => {\r\n                write!(f, \"{}: {}\", character_name, message)\r\n            }\r\n            SomethingObservableHappenedEvent::MemoryRestored { .. } => {\r\n                write!(\r\n                    f,\r\n                    \"The game has restarted and the agent memory has been restored.\"\r\n                )\r\n            }\r\n            SomethingObservableHappenedEvent::UISnapshot { snapshot, .. } => {\r\n                write!(f, \"Snapshot of an app window: {:?}\", snapshot)\r\n            }\r\n        }\r\n    }\r\n}\r\nimpl SomethingObservableHappenedEvent {\r\n    pub fn into_whats_new(&self, observation_buffer_id: Entity) -> WhatsNew {\r\n        match self {\r\n            SomethingObservableHappenedEvent::Chat {\r\n                character_id: event_character_id,\r\n                ..\r\n            } if *event_character_id == observation_buffer_id => WhatsNew::SelfChat,\r\n            SomethingObservableHappenedEvent::Chat { message, .. }\r\n                if message.ends_with(\"...\")\r\n                    || !message.ends_with('.')\r\n                        && !message.ends_with('!')\r\n                        && !message.ends_with('?') =>\r\n            {\r\n                WhatsNew::ChatReceivedButTheyProbablyStillThinking\r\n            }\r\n            SomethingObservableHappenedEvent::Chat { .. } => WhatsNew::ChatReceived,\r\n            SomethingObservableHappenedEvent::MemoryRestored { .. } => WhatsNew::MemoryRestored,\r\n            SomethingObservableHappenedEvent::UISnapshot { .. } => WhatsNew::UISnapshot,\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\app_types\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_app_types\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\inference_types\\src\\inference_types.rs\r\n\r\n````rust\r\nuse crate::prelude::*;\r\nuse bevy::prelude::*;\r\n\r\n#[derive(Reflect, Debug, Clone, Default, Eq, PartialEq)]\r\npub struct TextInferenceOptions {\r\n    pub num_predict: Option<usize>,\r\n    pub stop: Option<Vec<String>>,\r\n}\r\n\r\n#[derive(Event, Reflect, Debug, Clone)]\r\npub enum TextInferenceEvent {\r\n    Request {\r\n        session_id: Entity,\r\n        prompt: TextPrompt,\r\n    },\r\n    Response {\r\n        session_id: Entity,\r\n        prompt: MaterializedTextPrompt,\r\n        response: String,\r\n    },\r\n}\r\n\r\n#[derive(Event, Reflect, Debug, Clone)]\r\npub enum SpeechInferenceEvent {\r\n    Request {\r\n        session_id: Entity,\r\n        prompt: SpeechPrompt,\r\n    },\r\n    Response {\r\n        session_id: Entity,\r\n        prompt: SpeechPrompt,\r\n        wav: Vec<u8>,\r\n    },\r\n}\r\n\r\n#[derive(Event, Reflect, Debug, Clone)]\r\npub enum TranscriptionInferenceEvent {\r\n    Request {\r\n        session_id: Entity,\r\n        prompt: TranscriptionPrompt,\r\n    },\r\n    Response {\r\n        session_id: Entity,\r\n        prompt: TranscriptionPrompt,\r\n        transcription: String,\r\n    },\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\toolbelt\\src\\toolbelt_circle_layout_plugin.rs\r\n\r\n````rust\r\nuse std::f32::consts::PI;\r\n\r\nuse bevy_xpbd_2d::components::Position;\r\nuse bevy_xpbd_2d::components::Rotation;\r\nuse bevy_xpbd_2d::PhysicsSet;\r\nuse cursor_hero_toolbelt_types::toolbelt_types::*;\r\n\r\nuse bevy::prelude::*;\r\nuse bevy::transform::TransformSystem;\r\nuse cursor_hero_input::update_gamepad_settings::PRESS_THRESHOLD;\r\nuse cursor_hero_pointer_types::prelude::*;\r\n\r\nuse itertools::Itertools;\r\nuse leafwing_input_manager::action_state::ActionState;\r\n\r\npub struct ToolbeltCircleLayoutPlugin;\r\n\r\nimpl Plugin for ToolbeltCircleLayoutPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Update, update_render_data);\r\n        app.add_systems(Update, reset_reach);\r\n        app.add_systems(\r\n            PostUpdate,\r\n            position_tools\r\n                .after(PhysicsSet::Sync)\r\n                .after(TransformSystem::TransformPropagate),\r\n        );\r\n    }\r\n}\r\n\r\n#[allow(clippy::type_complexity)]\r\npub fn update_render_data(\r\n    mut toolbelt_query: Query<\r\n        (\r\n            &mut Toolbelt,\r\n            &ActionState<ToolbeltAction>,\r\n            &Parent,\r\n            &Children,\r\n        ),\r\n        Without<Tool>,\r\n    >,\r\n    tool_query: Query<Entity, With<Tool>>,\r\n    mut pointer_reach_events: EventWriter<PointerReachEvent>,\r\n) {\r\n    for toolbelt in toolbelt_query.iter_mut() {\r\n        let (mut toolbelt, toolbelt_actions, toolbelt_parent, toolbelt_children) = toolbelt;\r\n        if !toolbelt.open {\r\n            continue;\r\n        }\r\n        let ToolbeltLayout::Circle { wheel, .. } = &mut toolbelt.layout else {\r\n            continue;\r\n        };\r\n        let tool_count = toolbelt_children\r\n            .iter()\r\n            .filter(|e| tool_query.get(**e).is_ok())\r\n            .count();\r\n        let open = ((toolbelt_actions.value(ToolbeltAction::Show) - PRESS_THRESHOLD)\r\n            / (1.0 - PRESS_THRESHOLD)\r\n            * 1.01)\r\n            .min(1.0);\r\n        wheel.radius = wheel.radius_start\r\n            + ((wheel.radius_end\r\n                + wheel.radius_end_bonus_per_tool_after_8\r\n                    * (tool_count as isize - 8).max(0) as f32)\r\n                - wheel.radius_start)\r\n                * open;\r\n        wheel.spin = wheel.spin_start + (wheel.spin_end - wheel.spin_start) * open;\r\n        wheel.scale = wheel.scale_start + (wheel.scale_end - wheel.scale_start) * open;\r\n        wheel.alpha = wheel.alpha_start + (wheel.alpha_end - wheel.alpha_start) * open;\r\n        pointer_reach_events.send(PointerReachEvent::SetCharacter {\r\n            character_id: toolbelt_parent.get(),\r\n            reach: wheel.radius,\r\n        });\r\n    }\r\n}\r\n\r\nfn reset_reach(\r\n    mut pointer_reach_events: EventWriter<PointerReachEvent>,\r\n    mut toolbelt_opening_events: EventReader<ToolbeltOpeningEvent>,\r\n    toolbelt_query: Query<&Parent, With<Toolbelt>>,\r\n) {\r\n    for event in toolbelt_opening_events.read() {\r\n        let ToolbeltOpeningEvent::Closed { toolbelt_id } = event else {\r\n            continue;\r\n        };\r\n        let Ok(toolbelt) = toolbelt_query.get(*toolbelt_id) else {\r\n            continue;\r\n        };\r\n        let character_id = toolbelt.get();\r\n        pointer_reach_events.send(PointerReachEvent::ResetCharacter { character_id });\r\n    }\r\n}\r\n\r\n#[allow(clippy::type_complexity)]\r\npub fn position_tools(\r\n    toolbelt_query: Query<(Ref<Toolbelt>, &Children, &Parent), Without<Tool>>,\r\n    character_query: Query<&GlobalTransform>,\r\n    mut tool_query: Query<\r\n        (&mut Transform, &mut Position, &mut Rotation, &Children),\r\n        (With<Tool>, Without<ToolHelpTrigger>),\r\n    >,\r\n    mut tool_help_query: Query<\r\n        (&mut Transform, &mut Position, &mut Rotation),\r\n        (With<ToolHelpTrigger>, Without<Tool>),\r\n    >,\r\n) {\r\n    for (toolbelt, toolbelt_kids, toolbelt_parent) in toolbelt_query.iter() {\r\n        if !toolbelt.is_changed() {\r\n            continue;\r\n        }\r\n        let ToolbeltLayout::Circle { wheel } = toolbelt.layout else {\r\n            continue;\r\n        };\r\n        if let Ok(character_position) = character_query.get(**toolbelt_parent) {\r\n            let tool_ids = toolbelt_kids\r\n                .iter()\r\n                .filter(|e| tool_query.contains(**e))\r\n                .collect_vec();\r\n            position_tools_helper(\r\n                character_position,\r\n                tool_ids,\r\n                &mut tool_query,\r\n                &mut tool_help_query,\r\n                &wheel,\r\n            );\r\n        }\r\n    }\r\n}\r\n\r\n#[allow(clippy::type_complexity)]\r\nfn position_tools_helper(\r\n    character_position: &GlobalTransform,\r\n    tool_ids: Vec<&Entity>,\r\n    tool_query: &mut Query<\r\n        (&mut Transform, &mut Position, &mut Rotation, &Children),\r\n        (With<Tool>, Without<ToolHelpTrigger>),\r\n    >,\r\n    tool_help_query: &mut Query<\r\n        (&mut Transform, &mut Position, &mut Rotation),\r\n        (With<ToolHelpTrigger>, Without<Tool>),\r\n    >,\r\n    wheel: &Wheel,\r\n) {\r\n    let count = tool_ids.len();\r\n    for (i, tool_id) in tool_ids.iter().enumerate() {\r\n        if let Ok((mut tool_transform, mut tool_position, mut tool_rotation, tool_children)) =\r\n            tool_query.get_mut(**tool_id)\r\n        {\r\n            let angle = 2.0 * PI / (count as f32) * i as f32;\r\n            let x = angle.cos();\r\n            let y = angle.sin();\r\n            tool_transform.scale = Vec2::splat(wheel.scale).extend(1.0);\r\n            let character_position = character_position.translation().xy();\r\n            tool_position.0 = character_position + Vec2::new(x * wheel.radius, y * wheel.radius);\r\n            *tool_rotation = Rotation::from_degrees(wheel.spin);\r\n            for tool_child in tool_children.iter() {\r\n                if let Ok((\r\n                    mut tool_help_transform,\r\n                    mut tool_help_position,\r\n                    mut tool_help_rotation,\r\n                )) = tool_help_query.get_mut(*tool_child)\r\n                {\r\n                    tool_help_transform.scale = Vec2::splat(wheel.scale).extend(1.0);\r\n                    tool_help_position.0 = tool_position.xy()\r\n                        + Vec2::new(x * -wheel.radius * 0.5, y * -wheel.radius * 0.5);\r\n                    *tool_help_rotation = Rotation::from_degrees(wheel.spin);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui_watcher_types\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_ui_watcher_types\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\nuiautomation = {workspace = true}\r\ncursor_hero_ui_automation = {workspace = true}\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\worker_types\\src\\worker_types.rs\r\n\r\n````rust\r\nuse anyhow::Error;\r\nuse anyhow::Result;\r\nuse bevy::prelude::*;\r\npub use crossbeam_channel::Receiver;\r\npub use crossbeam_channel::Sender;\r\nuse std::marker::PhantomData;\r\n\r\n#[derive(Resource)]\r\npub struct Bridge<T, G>\r\nwhere\r\n    T: Message,\r\n    G: Message,\r\n{\r\n    pub sender: Sender<T>,\r\n    pub receiver: Receiver<G>,\r\n}\r\n\r\npub trait Message:\r\n    std::fmt::Debug\r\n    // + GetTypeRegistration\r\n    + Event\r\n    + Send\r\n    + Sync\r\n    + Clone\r\n    // + Reflect\r\n    // + TypePath\r\n    // + FromReflect\r\n    + 'static\r\n{\r\n}\r\n\r\npub type ThreadboundMessageHandler<T, G> = fn(msg: &T, reply_tx: &Sender<G>) -> Result<()>;\r\n\r\npub type ThreadboundMessageErrorHandler<T, G> =\r\n    fn(msg: &T, reply_tx: &Sender<G>, error: &Error) -> Result<()>;\r\n\r\n#[derive(Resource, Reflect, Clone)]\r\npub struct WorkerConfig<T, G> {\r\n    pub name: String,\r\n    pub sleep_duration: std::time::Duration,\r\n    pub is_ui_automation_thread: bool,\r\n    pub handle_threadbound_message: ThreadboundMessageHandler<T, G>,\r\n    pub handle_threadbound_message_error_handler: ThreadboundMessageErrorHandler<T, G>,\r\n    pub _phantom_t: PhantomData<T>,\r\n    pub _phantom_g: PhantomData<G>,\r\n}\r\nimpl<T: Message, G: Message> Default for WorkerConfig<T, G> {\r\n    fn default() -> Self {\r\n        WorkerConfig {\r\n            name: \"Unknown Worker\".to_string(),\r\n            is_ui_automation_thread: false,\r\n            sleep_duration: std::time::Duration::from_millis(100),\r\n            handle_threadbound_message: |_, _| Ok(()),\r\n            handle_threadbound_message_error_handler: |_, _, _| Ok(()),\r\n            _phantom_t: PhantomData,\r\n            _phantom_g: PhantomData,\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\templates\\patterns\\new_plugin_with_types\\crates\\{{crate_name}}\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_{{crate_name}}\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\ncursor_hero_{{crate_name}}_types = { workspace = true }\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\app\\src\\app_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n\r\npub struct AppPlugin;\r\n\r\nimpl Plugin for AppPlugin {\r\n    fn build(&self, _app: &mut App) {}\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\host_event_types\\src\\host_event_types.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n\r\n#[derive(Event, Debug, Reflect, Eq, PartialEq)]\r\npub enum HostEvent {\r\n    MousePhysicallyMoved,\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\movement_tool\\src\\movement_target_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse cursor_hero_movement_tool_types::prelude::*;\r\n\r\npub struct MovementTargetPlugin;\r\n\r\nimpl Plugin for MovementTargetPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Update, handle_set_movement_events);\r\n    }\r\n}\r\n\r\nfn handle_set_movement_events(\r\n    mut movement_target_events: EventReader<MovementTargetEvent>,\r\n    mut tool_query: Query<&mut MovementTool>,\r\n) {\r\n    for event in movement_target_events.read() {\r\n        match event {\r\n            MovementTargetEvent::SetTarget { tool_id, target } => {\r\n                let Ok(mut tool) = tool_query.get_mut(*tool_id) else {\r\n                    warn!(\"Tool {:?} does not exist\", tool_id);\r\n                    continue;\r\n                };\r\n                tool.target = *target;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\start_menu\\src\\lib.rs\r\n\r\n````rust\r\npub mod start_menu_button_plugin;\r\npub mod start_menu_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::start_menu_plugin::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui\\src\\fps_text_plugin.rs\r\n\r\n````rust\r\nuse bevy::diagnostic::DiagnosticsStore;\r\nuse bevy::diagnostic::FrameTimeDiagnosticsPlugin;\r\nuse bevy::prelude::*;\r\npub struct FpsTextPlugin;\r\nimpl Plugin for FpsTextPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Startup, setup);\r\n        app.add_systems(Update, update_fps_text);\r\n    }\r\n}\r\n\r\n#[derive(Component)]\r\nstruct FpsText;\r\n\r\nfn setup(mut commands: Commands) {\r\n    commands.spawn((\r\n        TextBundle::from_section(\r\n            \"FPS: \",\r\n            TextStyle {\r\n                font: default(),\r\n                font_size: 20.0,\r\n                color: Color::TOMATO,\r\n            },\r\n        )\r\n        .with_style(Style {\r\n            position_type: PositionType::Absolute,\r\n            top: Val::Px(5.0),\r\n            left: Val::Px(5.0),\r\n            ..default()\r\n        }),\r\n        FpsText,\r\n    ));\r\n}\r\n\r\nfn update_fps_text(diagnostics: Res<DiagnosticsStore>, mut query: Query<&mut Text, With<FpsText>>) {\r\n    for mut text in &mut query {\r\n        if let Some(fps) = diagnostics.get(FrameTimeDiagnosticsPlugin::FPS) {\r\n            if let Some(value) = fps.smoothed() {\r\n                // Update the value of the second section\r\n                text.sections[0].value = format!(\"FPS: {value:.2}\");\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui_automation\\src\\gather_children.rs\r\n\r\n````rust\r\nuse std::collections::VecDeque;\r\n\r\nuse cursor_hero_metrics::Metrics;\r\nuse uiautomation::UIElement;\r\nuse uiautomation::UITreeWalker;\r\n\r\n#[allow(dead_code)]\r\n#[derive(Debug)]\r\npub enum StopBehaviour {\r\n    EndOfSiblings,\r\n    LastChildEncountered,\r\n    TaskbarEndEncountered,\r\n    RootEndEncountered, // Calling get_next_sibling on the last child of root will hang, so use this to mitigate\r\n}\r\nimpl StopBehaviour {\r\n    fn include_last_child(&self) -> bool {\r\n        !matches!(self, StopBehaviour::TaskbarEndEncountered)\r\n    }\r\n}\r\ntrait GatherChildrenStopBehaviourFn {\r\n    fn should_stop(&self, next: &UIElement) -> bool;\r\n}\r\n\r\n#[derive(Debug)]\r\nstruct EndOfSiblings;\r\nimpl GatherChildrenStopBehaviourFn for EndOfSiblings {\r\n    fn should_stop(&self, _element: &UIElement) -> bool {\r\n        false\r\n    }\r\n}\r\n\r\n#[derive(Debug)]\r\nstruct LastChildEncountered {\r\n    runtime_id_of_last: Vec<i32>,\r\n}\r\nimpl GatherChildrenStopBehaviourFn for LastChildEncountered {\r\n    fn should_stop(&self, element: &UIElement) -> bool {\r\n        element.get_runtime_id() == Ok(self.runtime_id_of_last.clone())\r\n    }\r\n}\r\n\r\n#[derive(Debug)]\r\nstruct TaskbarEndEncountered;\r\nimpl GatherChildrenStopBehaviourFn for TaskbarEndEncountered {\r\n    fn should_stop(&self, element: &UIElement) -> bool {\r\n        element.get_automation_id() == Ok(\"TaskbarEndAccessibilityElement\".to_string())\r\n    }\r\n}\r\n\r\n#[derive(Debug)]\r\nstruct RootEndEncountered;\r\nimpl GatherChildrenStopBehaviourFn for RootEndEncountered {\r\n    fn should_stop(&self, element: &UIElement) -> bool {\r\n        element.get_name() == Ok(\"Program Manager\".to_string())\r\n            && element.get_classname() == Ok(\"Progman\".to_string())\r\n        // This could be more specific, but until a false positive is encountered, this is fine\r\n    }\r\n}\r\n\r\npub trait GatherChildrenable {\r\n    fn gather_children(\r\n        &self,\r\n        walker: &UITreeWalker,\r\n        stop_behaviour: &StopBehaviour,\r\n    ) -> VecDeque<UIElement>;\r\n}\r\nimpl GatherChildrenable for UIElement {\r\n    fn gather_children(\r\n        &self,\r\n        walker: &UITreeWalker,\r\n        stop_behaviour: &StopBehaviour,\r\n    ) -> VecDeque<UIElement> {\r\n        gather_children(walker, self, stop_behaviour)\r\n    }\r\n}\r\n\r\npub fn gather_children(\r\n    walker: &UITreeWalker,\r\n    parent: &UIElement,\r\n    stop_behaviour: &StopBehaviour,\r\n) -> VecDeque<UIElement> {\r\n    // println!(\"Gathering children of {:?}\", parent);\r\n    let mut children = VecDeque::new();\r\n    let mut metrics = Metrics::default();\r\n\r\n    // println!(\"Constructing stop behaviour fn for {:?}\", stop_behaviour);\r\n    metrics.begin(\"construct stop behaviour\");\r\n    let stop: Box<dyn GatherChildrenStopBehaviourFn> = match stop_behaviour {\r\n        StopBehaviour::EndOfSiblings => Box::new(EndOfSiblings),\r\n        StopBehaviour::LastChildEncountered => {\r\n            // println!(\"Getting last child of {:?}\", parent);\r\n            let last = walker.get_last_child(parent);\r\n            let last = match last {\r\n                Ok(last) => last,\r\n                Err(_) => {\r\n                    eprintln!(\"Failed to get last child of {:?}\", parent);\r\n                    return children;\r\n                }\r\n            };\r\n            let runtime_id_of_last = last.get_runtime_id();\r\n            let runtime_id_of_last = match runtime_id_of_last {\r\n                Ok(runtime_id_of_last) => runtime_id_of_last,\r\n                Err(_) => {\r\n                    eprintln!(\r\n                        \"Failed to get runtime id of last child {:?} of {:?}\",\r\n                        last, parent\r\n                    );\r\n                    return children;\r\n                }\r\n            };\r\n            Box::new(LastChildEncountered { runtime_id_of_last })\r\n        }\r\n        StopBehaviour::TaskbarEndEncountered => Box::new(TaskbarEndEncountered),\r\n        StopBehaviour::RootEndEncountered => Box::new(RootEndEncountered),\r\n    };\r\n    metrics.end(\"construct stop behaviour\");\r\n    // println!(\"Constructed stop behaviour {:?}\", stop_behaviour);\r\n\r\n    // println!(\"Finding first child\");\r\n    metrics.begin(\"find first child\");\r\n    let first = walker.get_first_child(parent);\r\n    metrics.end(\"find first child\");\r\n    // println!(\"Found first child\");\r\n\r\n    let Ok(first) = first else {\r\n        return children;\r\n    };\r\n    children.push_back(first.clone());\r\n    let mut next = first;\r\n    let mut i = 0;\r\n    loop {\r\n        // println!(\"About to grab next sibling of {:?}\", next);\r\n        metrics.begin(format!(\"get next sibling {}\", i).as_str());\r\n        let sibling = walker.get_next_sibling(&next);\r\n        metrics.end(format!(\"get next sibling {}\", i).as_str());\r\n        i += 1;\r\n\r\n        if let Ok(sibling) = sibling {\r\n            // println!(\"Got sibling {:?}\", sibling);\r\n            // println!(\"Checking if should stop\");\r\n            if stop.should_stop(&sibling) {\r\n                // println!(\"Should stop\");\r\n                if stop_behaviour.include_last_child() {\r\n                    // println!(\"Including last child\");\r\n                    children.push_back(sibling.clone());\r\n                }\r\n                break;\r\n            } else {\r\n                // println!(\"Should not stop\");\r\n                children.push_back(sibling.clone());\r\n                next = sibling;\r\n            }\r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n    // println!(\"Gathered {} children\", children.len());\r\n    // println!(\"| {}\", metrics.report().split(\" | \").join(\"\\n| \"));\r\n    children\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\window_swap_tool\\src\\window_swap_tool_populate_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse cursor_hero_toolbelt_types::prelude::*;\r\nuse cursor_hero_tools::tool_spawning::ToolSpawnConfig;\r\nuse cursor_hero_window_swap_tool_types::prelude::*;\r\n\r\npub struct WindowSwapToolPopulatePlugin;\r\n\r\nimpl Plugin for WindowSwapToolPopulatePlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Update, handle_toolbelt_events);\r\n    }\r\n}\r\n\r\nfn handle_toolbelt_events(\r\n    mut commands: Commands,\r\n    asset_server: Res<AssetServer>,\r\n    mut reader: EventReader<ToolbeltPopulateEvent>,\r\n) {\r\n    for event in reader.read() {\r\n        let ToolbeltPopulateEvent {\r\n            loadout: ToolbeltLoadout::WindowPosition,\r\n            ..\r\n        } = event\r\n        else {\r\n            continue;\r\n        };\r\n        ToolSpawnConfig::<_, WindowSwapToolAction>::new(WindowSwapTool, event.id, event)\r\n            .with_src_path(file!().into())\r\n            .guess_name(file!())\r\n            .guess_image(file!(), &asset_server, \"webp\")\r\n            .with_description(\"Swap the positions of windows.\")\r\n            .spawn(&mut commands);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\character\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_character\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\ncursor_hero_camera = { workspace = true }\r\ncursor_hero_bevy = { workspace = true }\r\ncursor_hero_input = { workspace = true }\r\ncursor_hero_physics = { workspace = true }\r\ncursor_hero_winutils = { workspace = true}\r\ncursor_hero_toolbelt_types = { workspace = true}\r\ncursor_hero_environment_types = { workspace = true}\r\ncursor_hero_floaty_nametag_types = { workspace = true}\r\ncursor_hero_character_types = { workspace = true}\r\nbevy = { workspace = true }\r\nbevy_xpbd_2d = { workspace = true }\r\nleafwing-input-manager = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\fullscreen_tool\\src\\fullscreen_tool_tick_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse bevy::window::PrimaryWindow;\r\nuse cursor_hero_fullscreen_tool_types::prelude::*;\r\nuse cursor_hero_toolbelt_types::prelude::*;\r\nuse cursor_hero_tools::tool_spawning::StartingState;\r\n\r\npub struct FullscreenToolTickPlugin;\r\n\r\nimpl Plugin for FullscreenToolTickPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Update, handle_toggle);\r\n        app.add_systems(Update, match_window_state);\r\n    }\r\n}\r\n\r\nfn match_window_state(\r\n    mut commands: Commands,\r\n    tool_query: Query<(Entity, Option<&ActiveTool>), With<FullscreenTool>>,\r\n    window_query: Query<&Window, With<PrimaryWindow>>,\r\n) {\r\n    let Some(mode) = window_query.iter().map(|w| w.mode).next() else {\r\n        warn!(\"No window found\");\r\n        return;\r\n    };\r\n    for tool in tool_query.iter() {\r\n        let (tool_id, tool_active) = tool;\r\n        let desired_state = FullscreenTool::state_for_mode(mode);\r\n        if tool_active == desired_state.as_active().as_ref() {\r\n            continue;\r\n        }\r\n        match desired_state {\r\n            StartingState::Active => {\r\n                info!(\"Activating FullscreenTool without event to match window state\");\r\n                commands.entity(tool_id).insert(ActiveTool);\r\n            }\r\n            StartingState::Inactive => {\r\n                info!(\"Deactivating FullscreenTool without event to match window state\");\r\n                commands.entity(tool_id).remove::<ActiveTool>();\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfn handle_toggle(\r\n    tool_query: Query<(), With<FullscreenTool>>,\r\n    mut window_query: Query<&mut Window, With<PrimaryWindow>>,\r\n    mut tool_events: EventReader<ToolActivationEvent>,\r\n) {\r\n    for event in tool_events.read() {\r\n        match event {\r\n            ToolActivationEvent::Activate(tool_id) if tool_query.contains(*tool_id) => {\r\n                info!(\"FullscreenTool activated, setting window to fullscreen.\");\r\n                if window_query.is_empty() {\r\n                    warn!(\"No window found\");\r\n                    continue;\r\n                }\r\n                for mut window in window_query.iter_mut() {\r\n                    window.mode = bevy::window::WindowMode::BorderlessFullscreen;\r\n                }\r\n            }\r\n            ToolActivationEvent::Deactivate(tool_id) if tool_query.contains(*tool_id) => {\r\n                info!(\"FullscreenTool deactivated, setting window to windowed.\");\r\n                if window_query.is_empty() {\r\n                    warn!(\"No window found\");\r\n                    continue;\r\n                }\r\n                for mut window in window_query.iter_mut() {\r\n                    window.mode = bevy::window::WindowMode::Windowed;\r\n                }\r\n            }\r\n            _ => {}\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\toolbelt\\src\\toolbelt_properties_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse cursor_hero_toolbelt_types::toolbelt_types::Toolbelt;\r\nuse cursor_hero_toolbelt_types::toolbelt_types::ToolbeltPopulateEvent;\r\n\r\npub struct ToolbeltPropertiesPlugin;\r\n\r\nimpl Plugin for ToolbeltPropertiesPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Update, switch_layout);\r\n    }\r\n}\r\npub fn switch_layout(\r\n    mut toolbelt_events: EventReader<ToolbeltPopulateEvent>,\r\n    mut toolbelt_query: Query<&mut Toolbelt>,\r\n) {\r\n    for event in toolbelt_events.read() {\r\n        let ToolbeltPopulateEvent { id, loadout } = event;\r\n        if let Ok(mut toolbelt) = toolbelt_query.get_mut(*id) {\r\n            toolbelt.loadout = *loadout;\r\n            toolbelt.layout = loadout.layout();\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\movement_tool_types\\src\\lib.rs\r\n\r\n````rust\r\npub mod movement_tool_types;\r\npub mod movement_tool_types_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::movement_tool_types::*;\r\n    pub use crate::movement_tool_types_plugin::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\pointer\\src\\pointer_hover_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse bevy_xpbd_2d::components::CollidingEntities;\r\nuse cursor_hero_pointer_types::prelude::*;\r\n\r\npub struct PointerHoverPlugin;\r\n\r\nimpl Plugin for PointerHoverPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Update, hover_detection);\r\n    }\r\n}\r\n\r\n#[allow(clippy::type_complexity)]\r\npub fn hover_detection(\r\n    mut commands: Commands,\r\n    mut pointer_query: Query<(Entity, &CollidingEntities, Option<&mut Hovering>), With<Pointer>>,\r\n    target_query: Query<(Entity, &Visibility, Option<&Hovered>), With<Hoverable>>,\r\n    mut events: EventWriter<HoverEvent>,\r\n) {\r\n    for (pointer_id, pointer_touching, pointer_hovering) in pointer_query.iter_mut() {\r\n        // find out what the pointer is touching\r\n        let mut still_touching = vec![];\r\n        for touching_id in pointer_touching.iter() {\r\n            let Ok((target_id, target_visible, target_hovered)) = target_query.get(*touching_id)\r\n            else {\r\n                continue;\r\n            };\r\n            if target_visible == Visibility::Hidden {\r\n                continue;\r\n            }\r\n            if target_hovered.is_none() {\r\n                commands.entity(target_id).insert(Hovered);\r\n                debug!(\"HoverStart: {:?}\", target_id);\r\n                events.send(HoverEvent::Start {\r\n                    target_id,\r\n                    pointer_id,\r\n                });\r\n            }\r\n            still_touching.push(target_id);\r\n        }\r\n        // update the pointer tracker\r\n        match pointer_hovering {\r\n            Some(mut pointer_hovering) => {\r\n                for entry in pointer_hovering.hovering.iter() {\r\n                    if !still_touching.contains(entry) {\r\n                        if let Some(mut target_commands) = commands.get_entity(*entry) {\r\n                            target_commands.remove::<Hovered>();\r\n                            debug!(\"HoverEnd: {:?}\", entry);\r\n                            events.send(HoverEvent::End {\r\n                                target_id: *entry,\r\n                                pointer_id,\r\n                            });\r\n                        }\r\n                    }\r\n                }\r\n                if still_touching.is_empty() {\r\n                    commands.entity(pointer_id).remove::<Hovering>();\r\n                } else {\r\n                    pointer_hovering.hovering = still_touching;\r\n                }\r\n            }\r\n            None => {\r\n                if !still_touching.is_empty() {\r\n                    commands.entity(pointer_id).insert(Hovering {\r\n                        hovering: still_touching,\r\n                    });\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\tools\\src\\scroll_tool.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse bevy_inspector_egui::prelude::ReflectInspectorOptions;\r\nuse bevy_inspector_egui::InspectorOptions;\r\nuse cursor_hero_character_types::prelude::*;\r\nuse cursor_hero_math::prelude::Lerp;\r\nuse cursor_hero_sprint_tool_types::sprint_tool_types_plugin::SprintEvent;\r\nuse cursor_hero_toolbelt_types::prelude::*;\r\nuse cursor_hero_winutils::win_mouse::scroll_wheel;\r\nuse itertools::Itertools;\r\nuse leafwing_input_manager::prelude::*;\r\n\r\nuse crate::prelude::*;\r\n\r\npub struct ScrollToolPlugin;\r\n\r\nimpl Plugin for ScrollToolPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<ScrollTool>();\r\n        app.add_plugins(InputManagerPlugin::<ScrollToolAction>::default());\r\n        app.add_systems(Update, toolbelt_events);\r\n        app.add_systems(Update, handle_input);\r\n        app.add_systems(Update, handle_sprint_events);\r\n    }\r\n}\r\n\r\n#[derive(Component, InspectorOptions, Reflect)]\r\n#[reflect(Component, InspectorOptions)]\r\nstruct ScrollTool {\r\n    #[inspector(min = 0.0)]\r\n    pub speed: f32,\r\n    #[inspector(min = 0.0)]\r\n    pub default_speed: f32,\r\n    #[inspector(min = 0.0)]\r\n    pub sprint_speed: f32,\r\n}\r\nimpl Default for ScrollTool {\r\n    fn default() -> Self {\r\n        Self {\r\n            speed: 1.0,\r\n            default_speed: 1.0,\r\n            sprint_speed: 100.0,\r\n        }\r\n    }\r\n}\r\n\r\nfn toolbelt_events(\r\n    mut commands: Commands,\r\n    asset_server: Res<AssetServer>,\r\n    mut reader: EventReader<ToolbeltPopulateEvent>,\r\n) {\r\n    for event in reader.read() {\r\n        let (ToolbeltLoadout::Inspector | ToolbeltLoadout::Default) = event.loadout else {\r\n            continue;\r\n        };\r\n        ToolSpawnConfig::<_, ScrollToolAction>::new(ScrollTool::default(), event.id, event)\r\n            .with_src_path(file!().into())\r\n            .guess_name(file!())\r\n            .guess_image(file!(), &asset_server, \"png\")\r\n            .with_description(\"Send scroll events\")\r\n            .spawn(&mut commands);\r\n    }\r\n}\r\n\r\n#[derive(Actionlike, PartialEq, Eq, Clone, Copy, Hash, Debug, Reflect)]\r\nenum ScrollToolAction {\r\n    ScrollUp,\r\n    ScrollDown,\r\n}\r\n\r\nimpl ScrollToolAction {\r\n    fn default_gamepad_binding(&self) -> UserInput {\r\n        match self {\r\n            Self::ScrollUp => GamepadButtonType::DPadUp.into(),\r\n            Self::ScrollDown => GamepadButtonType::DPadDown.into(),\r\n        }\r\n    }\r\n\r\n    fn default_mkb_binding(&self) -> UserInput {\r\n        match self {\r\n            Self::ScrollUp => KeyCode::PageDown.into(),\r\n            Self::ScrollDown => KeyCode::PageUp.into(),\r\n        }\r\n    }\r\n}\r\nimpl ToolAction for ScrollToolAction {\r\n    fn default_input_map(_event: &ToolbeltPopulateEvent) -> Option<InputMap<ScrollToolAction>> {\r\n        let mut input_map = InputMap::default();\r\n\r\n        for variant in ScrollToolAction::variants() {\r\n            input_map.insert(variant.default_mkb_binding(), variant);\r\n            input_map.insert(variant.default_gamepad_binding(), variant);\r\n        }\r\n        Some(input_map)\r\n    }\r\n}\r\n\r\nfn handle_input(\r\n    tool_query: Query<(&ActionState<ScrollToolAction>, &ScrollTool), With<ActiveTool>>,\r\n    time: Res<Time>,\r\n) {\r\n    for zoom_tool in tool_query.iter() {\r\n        let (tool_actions, tool) = zoom_tool;\r\n        let mut amount = None;\r\n        if tool_actions.pressed(ScrollToolAction::ScrollUp) {\r\n            if tool_actions.just_pressed(ScrollToolAction::ScrollUp) {\r\n                info!(\"Scrolling up\");\r\n            }\r\n            amount = Some(tool.speed * time.delta_seconds());\r\n        }\r\n        if tool_actions.pressed(ScrollToolAction::ScrollDown) {\r\n            if tool_actions.just_pressed(ScrollToolAction::ScrollDown) {\r\n                info!(\"Scrolling down\");\r\n            }\r\n            amount = Some(-tool.speed * time.delta_seconds());\r\n        }\r\n        if let Some(amount) = amount {\r\n            match scroll_wheel(amount) {\r\n                Ok(_) => {}\r\n                Err(e) => {\r\n                    error!(\"Error scrolling up: {:?}\", e);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfn handle_sprint_events(\r\n    mut sprint_events: EventReader<SprintEvent>,\r\n    character_query: Query<&Children, With<Character>>,\r\n    toolbelt_query: Query<&Children, With<Toolbelt>>,\r\n    mut tool_query: Query<&mut ScrollTool>,\r\n) {\r\n    for event in sprint_events.read() {\r\n        let character_id = match event {\r\n            SprintEvent::Active { character_id, .. } => character_id,\r\n            SprintEvent::Stop { character_id } => character_id,\r\n        };\r\n        let Ok(character) = character_query.get(*character_id) else {\r\n            warn!(\"Character {:?} does not exist\", character_id);\r\n            continue;\r\n        };\r\n        let character_kids = character;\r\n        let tool_ids = character_kids\r\n            .iter()\r\n            .filter_map(|kid| toolbelt_query.get(*kid).ok())\r\n            .flat_map(|toolbelt| toolbelt.iter())\r\n            .filter(|kid| tool_query.contains(**kid))\r\n            .cloned()\r\n            .collect_vec();\r\n\r\n        match event {\r\n            SprintEvent::Active { throttle, .. } => {\r\n                let mut iter = tool_query.iter_many_mut(&tool_ids);\r\n                while let Some(mut tool) = iter.fetch_next() {\r\n                    tool.speed = (tool.default_speed, tool.sprint_speed).lerp(*throttle);\r\n                }\r\n            }\r\n            SprintEvent::Stop { .. } => {\r\n                let mut iter = tool_query.iter_many_mut(&tool_ids);\r\n                while let Some(mut tool) = iter.fetch_next() {\r\n                    tool.speed = tool.default_speed;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\toolbelt\\src\\tool_activation.rs\r\n\r\n````rust\r\nuse cursor_hero_toolbelt_types::toolbelt_types::*;\r\n\r\nuse bevy::prelude::*;\r\nuse cursor_hero_pointer_types::prelude::*;\r\n\r\nuse leafwing_input_manager::action_state::ActionState;\r\n\r\n#[allow(clippy::type_complexity)]\r\npub fn tool_activation(\r\n    mut commands: Commands,\r\n    hovered_query: Query<(Entity, Option<&ActiveTool>, Option<&Name>), With<Hovered>>,\r\n    toolbelt_query: Query<(&ActionState<ToolbeltAction>, &Children)>,\r\n    mut events: EventWriter<ToolActivationEvent>,\r\n) {\r\n    for (toolbelt_actions, toolbelt_kids) in toolbelt_query.iter() {\r\n        if toolbelt_actions.just_released(ToolbeltAction::Show) {\r\n            for (hovered_id, hovered_active, hovered_name) in toolbelt_kids\r\n                .iter()\r\n                .filter_map(|h| hovered_query.get(*h).ok())\r\n            {\r\n                if hovered_active.is_some() {\r\n                    commands.entity(hovered_id).remove::<ActiveTool>();\r\n                    events.send(ToolActivationEvent::Deactivate(hovered_id));\r\n                    info!(\"Deactivating tool: {:?} ({:?})\", hovered_name, hovered_id);\r\n                } else {\r\n                    commands.entity(hovered_id).insert(ActiveTool);\r\n                    events.send(ToolActivationEvent::Activate(hovered_id));\r\n                    info!(\"Activating tool: {:?} ({:?})\", hovered_name, hovered_id);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui_automation_types\\src\\ui_automation_types_plugin.rs\r\n\r\n````rust\r\nuse crate::prelude::*;\r\nuse bevy::prelude::*;\r\n\r\npub struct UiAutomationTypesPlugin;\r\n\r\nimpl Plugin for UiAutomationTypesPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<ElementInfo>();\r\n        app.register_type::<DrillId>();\r\n        app.register_type::<RuntimeId>();\r\n        app.register_type::<ControlType>();\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\window_position_types\\src\\lib.rs\r\n\r\n````rust\r\npub mod window_position_types;\r\npub mod window_position_types_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::window_position_types::*;\r\n    pub use crate::window_position_types_plugin::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\chat_types\\src\\chat_types_plugin.rs\r\n\r\n````rust\r\nuse crate::prelude::*;\r\nuse bevy::prelude::*;\r\npub struct ChatTypesPlugin;\r\n\r\nimpl Plugin for ChatTypesPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<ChatWheelTool>();\r\n        app.register_type::<ChatTool>();\r\n        app.register_type::<ChatBubble>();\r\n        app.register_type::<ChatInput>();\r\n        app.add_event::<ChatEvent>();\r\n        app.add_event::<ChatInputEvent>();\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\text_asset\\src\\text_asset_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse cursor_hero_text_asset_types::prelude::*;\r\npub struct TextAssetPlugin;\r\n\r\nimpl Plugin for TextAssetPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.init_asset::<TextAsset>();\r\n        app.init_asset_loader::<TextAssetLoader>();\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\memory_types\\src\\memory_types_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n// use crate::prelude::*;\r\n\r\npub struct MemoryTypesPlugin;\r\n\r\nimpl Plugin for MemoryTypesPlugin {\r\n    fn build(&self, _app: &mut App) {}\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui_automation\\src\\resolve_app.rs\r\n\r\n````rust\r\nuse cursor_hero_ui_automation_types::prelude::*;\r\nuse uiautomation::controls::ControlType;\r\nuse uiautomation::UIAutomation;\r\nuse uiautomation::UIElement;\r\n\r\nuse anyhow::Context;\r\nuse anyhow::Result;\r\n\r\nuse crate::resolve_calculator::resolve_calculator;\r\nuse crate::resolve_vscode::resolve_vscode;\r\n\r\npub(crate) fn resolve_app(\r\n    elem: &UIElement,\r\n    automation: &UIAutomation,\r\n    focused: bool,\r\n) -> Result<AppWindow> {\r\n    match (\r\n        elem.get_name(),\r\n        elem.get_control_type(),\r\n        elem.get_classname(),\r\n    ) {\r\n        (Ok(name), Ok(ControlType::Pane), Ok(class_name))\r\n            if name.ends_with(\"Visual Studio Code\") && class_name == \"Chrome_WidgetWin_1\" =>\r\n        {\r\n            resolve_vscode(elem, automation, focused).context(\"resolving vscode\")\r\n        }\r\n        (Ok(name), Ok(ControlType::Window), Ok(class_name))\r\n            if name == \"Calculator\" && class_name == \"ApplicationFrameWindow\" =>\r\n        {\r\n            resolve_calculator(elem, automation, focused).context(\"resolving calculator\")\r\n        }\r\n        _ => Ok(AppWindow::Unknown),\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\templates\\patterns\\new_tool\\crates\\{{crate_name}}_tool_types\\src\\{{crate_name}}_tool_types_plugin.rs\r\n\r\n````rust\r\nuse crate::prelude::*;\r\nuse bevy::prelude::*;\r\n\r\npub struct {{crate_name_pascal}}ToolTypesPlugin;\r\n\r\nimpl Plugin for {{crate_name_pascal}}ToolTypesPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<{{crate_name_pascal}}Tool>();\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\click_drag_character_movement\\src\\lib.rs\r\n\r\n````rust\r\nuse bevy::input::mouse::MouseButtonInput;\r\nuse bevy::input::mouse::MouseMotion;\r\nuse bevy::prelude::*;\r\nuse bevy::window::PrimaryWindow;\r\nuse bevy_xpbd_2d::components::Position;\r\n\r\nuse cursor_hero_camera::camera_plugin::update_camera_zoom;\r\nuse cursor_hero_camera::camera_plugin::FollowWithMainCamera;\r\nuse cursor_hero_camera::camera_plugin::MainCamera;\r\nuse cursor_hero_character_types::prelude::*;\r\n\r\npub struct ClickDragMovementPlugin;\r\n\r\nimpl Plugin for ClickDragMovementPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(\r\n            Update,\r\n            (\r\n                mouse_drag_update.after(update_camera_zoom),\r\n                teleport_character_to_camera\r\n                    .after(mouse_drag_update)\r\n                    .run_if(should_teleport_character_to_camera),\r\n            ),\r\n        )\r\n        .insert_resource(MouseDragState::default())\r\n        .register_type::<MouseDragState>();\r\n    }\r\n}\r\n\r\n#[derive(Reflect)]\r\nstruct Anchor {\r\n    drag_start_world_position: Vec2,\r\n}\r\n\r\n#[derive(Resource, Reflect, Default)]\r\n#[reflect(Resource)]\r\nstruct MouseDragState {\r\n    anchor: Option<Anchor>,\r\n    is_dragging: bool,\r\n}\r\n\r\nfn should_teleport_character_to_camera(\r\n    query: Query<&FollowWithMainCamera, Added<FollowWithMainCamera>>,\r\n    mouse_drag_state: Res<MouseDragState>,\r\n) -> bool {\r\n    query.iter().next().is_some() && mouse_drag_state.is_dragging\r\n}\r\n\r\n/// when the camera starts following a character while dragging, teleport the character to the camera\r\nfn teleport_character_to_camera(\r\n    mut character: Query<&mut Transform, (With<Character>, Without<MainCamera>)>,\r\n    camera_transform_query: Query<&Transform, (With<MainCamera>, Without<Character>)>,\r\n) {\r\n    character.single_mut().translation = camera_transform_query.single().translation;\r\n}\r\n\r\n#[allow(clippy::type_complexity)]\r\nfn mouse_drag_update(\r\n    mut mouse_button_input_events: EventReader<MouseButtonInput>,\r\n    mut mouse_drag_state: ResMut<MouseDragState>,\r\n    mut mouse_motion_events: EventReader<MouseMotion>,\r\n    mut follow: Query<&mut Position, (With<FollowWithMainCamera>, Without<MainCamera>)>,\r\n    window_query: Query<&Window, With<PrimaryWindow>>,\r\n    camera_query: Query<(&Camera, &GlobalTransform), (With<MainCamera>, Without<Character>)>,\r\n    mut camera_transform_query: Query<&mut Transform, (With<MainCamera>, Without<Character>)>,\r\n) {\r\n    let (camera, camera_global_transform) = camera_query.single();\r\n    let window = window_query.single();\r\n\r\n    // drag start and end logic\r\n    for event in mouse_button_input_events.read() {\r\n        if event.button == MouseButton::Left {\r\n            mouse_drag_state.is_dragging = event.state.is_pressed();\r\n            if mouse_drag_state.is_dragging {\r\n                // begin dragging\r\n                if let Some(screen_position) = window.cursor_position() {\r\n                    if let Some(world_position) = camera\r\n                        .viewport_to_world(camera_global_transform, screen_position)\r\n                        .map(|ray| ray.origin.truncate())\r\n                    {\r\n                        mouse_drag_state.anchor = Some(Anchor {\r\n                            drag_start_world_position: world_position,\r\n                        });\r\n                    }\r\n                }\r\n            } else {\r\n                // finish dragging\r\n                mouse_drag_state.anchor = None;\r\n            }\r\n        }\r\n    }\r\n\r\n    if mouse_drag_state.is_dragging {\r\n        // perform drag update\r\n        if let Some(anchor) = &mouse_drag_state.anchor {\r\n            if let Some(current_screen_position) = window.cursor_position() {\r\n                // mouse is inside the window, convert to world coords\r\n                if let Some(current_world_position) = camera\r\n                    .viewport_to_world(camera_global_transform, current_screen_position)\r\n                    .map(|ray| ray.origin.truncate())\r\n                {\r\n                    // calculate delta from the anchor\r\n                    let delta = anchor.drag_start_world_position - current_world_position;\r\n                    if let Ok(mut follow) = follow.get_single_mut() {\r\n                        // reposition the thing the camera is following\r\n                        follow.0 += delta;\r\n                    } else {\r\n                        // move the camera when not following something\r\n                        camera_transform_query.single_mut().translation += delta.extend(0.0);\r\n                    }\r\n                    // track info needed to keep alignment with starting point\r\n                    mouse_drag_state.anchor = Some(Anchor {\r\n                        drag_start_world_position: anchor.drag_start_world_position,\r\n                    });\r\n                }\r\n            } else {\r\n                // cursor is outside the window, use delta to approximate mouse position\r\n                let mut delta = mouse_motion_events\r\n                    .read()\r\n                    .fold(Vec2::ZERO, |acc, event| acc + event.delta);\r\n                delta.x *= -1.0;\r\n                if let Ok(mut follow) = follow.get_single_mut() {\r\n                    // reposition the thing the camera is following\r\n                    follow.0 += delta;\r\n                } else {\r\n                    // move the camera when not following something\r\n                    camera_transform_query.single_mut().translation += delta.extend(0.0);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\hover\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_hover\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nimage = { workspace = true}\r\nbevy_egui = {workspace = true}\r\ncursor_hero_tools = { workspace = true }\r\ncursor_hero_physics = { workspace = true }\r\ncursor_hero_toolbelt_types = { workspace = true}\r\ncursor_hero_pressure_plate = { workspace = true}\r\ncursor_hero_environment_types = { workspace = true}\r\ncursor_hero_screen = { workspace = true}\r\ncursor_hero_pointer_types = { workspace = true}\r\ncursor_hero_character_types = { workspace = true}\r\ncursor_hero_camera = { workspace = true}\r\ncursor_hero_bevy = { workspace = true}\r\ncursor_hero_ui_automation = { workspace = true}\r\ncursor_hero_winutils = { workspace = true}\r\nbevy = { workspace = true }\r\nitertools = { workspace = true }\r\nbevy-inspector-egui = { workspace = true }\r\nserde = { workspace = true }\r\nserde_json = { workspace = true }\r\nleafwing-input-manager = { workspace = true }\r\nuiautomation = { workspace = true }\r\nwindows = { workspace = true, features = [\r\n  \"Win32_Foundation\",\r\n  \"Win32_Graphics_Gdi\",\r\n  \"Win32_UI_WindowsAndMessaging\",\r\n  \"Win32_System_Com\",\r\n  \"Win32_UI_Accessibility\",\r\n  \"Win32_UI_Input_KeyboardAndMouse\",\r\n  \"Gaming_Input\",\r\n  \"Win32_Gaming\",\r\n  \"Win32_System_Threading\",\r\n] }\r\ncrossbeam-channel = { workspace = true }\r\ntokio = { workspace = true, features = [\"net\", \"full\"] }\r\ntokio-named-pipes = { workspace = true }\r\nbevy_xpbd_2d = { workspace = true }\r\nrand = { workspace = true }\r\ncursor_hero_floaty_nametag_types = { workspace = true }\r\ncursor_hero_worker = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\tools\\src\\focus_tool.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse bevy::window::PrimaryWindow;\r\nuse bevy::window::RawHandleWrapper;\r\nuse cursor_hero_camera::camera_plugin::FollowWithMainCamera;\r\nuse cursor_hero_camera::camera_plugin::MainCamera;\r\nuse cursor_hero_winutils::win_mouse::set_cursor_position;\r\nuse cursor_hero_winutils::win_window::get_window_title_bar_center_position;\r\nuse leafwing_input_manager::prelude::*;\r\n\r\nuse cursor_hero_camera::camera_plugin::CameraEvent;\r\nuse cursor_hero_character_types::prelude::*;\r\nuse cursor_hero_winutils::win_window::focus_window;\r\n\r\nuse cursor_hero_toolbelt_types::prelude::*;\r\n\r\nuse crate::prelude::*;\r\nuse cursor_hero_movement_tool_types::prelude::*;\r\n\r\npub struct FocusToolPlugin;\r\n\r\nimpl Plugin for FocusToolPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<FocusTool>();\r\n        app.add_plugins(InputManagerPlugin::<FocusToolAction>::default());\r\n        app.add_systems(Update, toolbelt_events);\r\n        app.add_systems(Update, handle_input);\r\n    }\r\n}\r\n#[derive(Component, Reflect, Default)]\r\nstruct FocusTool;\r\n\r\nfn toolbelt_events(\r\n    mut commands: Commands,\r\n    asset_server: Res<AssetServer>,\r\n    mut reader: EventReader<ToolbeltPopulateEvent>,\r\n) {\r\n    for event in reader.read() {\r\n        let (ToolbeltLoadout::Inspector | ToolbeltLoadout::Default) = event.loadout else {\r\n            continue;\r\n        };\r\n        {\r\n            ToolSpawnConfig::<FocusTool, FocusToolAction>::new(FocusTool, event.id, event)\r\n                .with_src_path(file!().into())\r\n                .guess_name(file!())\r\n                .guess_image(file!(), &asset_server, \"png\")\r\n                .with_description(\"Camera follows the character\")\r\n                .spawn(&mut commands);\r\n        }\r\n    }\r\n}\r\n\r\n#[derive(Actionlike, PartialEq, Eq, Clone, Copy, Hash, Debug, Reflect)]\r\nenum FocusToolAction {\r\n    ToggleFollowCharacter,\r\n    FocusMainWindow,\r\n}\r\n// TODO: add an action to focus the character without teleporting it to the camera.\r\n\r\nimpl FocusToolAction {\r\n    fn default_gamepad_binding(&self) -> UserInput {\r\n        match self {\r\n            Self::ToggleFollowCharacter => GamepadButtonType::LeftThumb.into(),\r\n            Self::FocusMainWindow => GamepadButtonType::RightThumb.into(),\r\n        }\r\n    }\r\n\r\n    fn default_mkb_binding(&self) -> UserInput {\r\n        match self {\r\n            Self::ToggleFollowCharacter => KeyCode::Space.into(),\r\n            Self::FocusMainWindow => KeyCode::Home.into(),\r\n        }\r\n    }\r\n}\r\nimpl ToolAction for FocusToolAction {\r\n    fn default_input_map(_event: &ToolbeltPopulateEvent) -> Option<InputMap<FocusToolAction>> {\r\n        let mut input_map = InputMap::default();\r\n\r\n        for variant in FocusToolAction::variants() {\r\n            input_map.insert(variant.default_mkb_binding(), variant);\r\n            input_map.insert(variant.default_gamepad_binding(), variant);\r\n        }\r\n        Some(input_map)\r\n    }\r\n}\r\n\r\n#[allow(clippy::type_complexity)]\r\n#[allow(clippy::too_many_arguments)]\r\nfn handle_input(\r\n    focus_tool_query: Query<(&ActionState<FocusToolAction>, &Parent), With<ActiveTool>>,\r\n    movement_tool_query: Query<Entity, With<MovementTool>>,\r\n    toolbelt_query: Query<(&Parent, &Children), With<Toolbelt>>,\r\n    mut character_query: Query<\r\n        (Entity, &mut Transform, Option<&FollowWithMainCamera>),\r\n        (With<Character>, Without<MainCamera>),\r\n    >,\r\n    camera_query: Query<(Entity, &Transform), (With<MainCamera>, Without<Character>)>,\r\n    window_query: Query<&RawHandleWrapper, With<PrimaryWindow>>,\r\n    mut camera_events: EventWriter<CameraEvent>,\r\n    mut movement_target_events: EventWriter<MovementTargetEvent>,\r\n) {\r\n    for tool in focus_tool_query.iter() {\r\n        let (tool_actions, tool_parent) = tool;\r\n\r\n        if tool_actions.just_pressed(FocusToolAction::ToggleFollowCharacter) {\r\n            info!(\"Toggle follow character\");\r\n            let Ok(toolbelt) = toolbelt_query.get(tool_parent.get()) else {\r\n                warn!(\"Toolbelt should have a parent\");\r\n                continue;\r\n            };\r\n\r\n            let (toolbelt_parent, toolbelt_children) = toolbelt;\r\n            let movement_tool_ids = toolbelt_children\r\n                .iter()\r\n                .filter_map(|child| movement_tool_query.get(*child).ok());\r\n\r\n            let Ok(character) = character_query.get_mut(toolbelt_parent.get()) else {\r\n                warn!(\"Toolbelt should have a character\");\r\n                continue;\r\n            };\r\n            let (character_id, mut character_transform, character_is_followed) = character;\r\n\r\n            let camera = camera_query.single();\r\n            let (camera_id, camera_transform) = camera;\r\n            if character_is_followed.is_none() {\r\n                camera_events.send(CameraEvent::BeginFollowing {\r\n                    target_id: character_id,\r\n                });\r\n                movement_tool_ids.for_each(|id| {\r\n                    movement_target_events.send(MovementTargetEvent::SetTarget {\r\n                        tool_id: id,\r\n                        target: MovementTarget::Character,\r\n                    });\r\n                });\r\n                info!(\"Sent follow events\");\r\n                info!(\"Updating character to be at camera position\");\r\n                character_transform.translation = camera_transform.translation;\r\n            } else {\r\n                camera_events.send(CameraEvent::StopFollowing {\r\n                    target_id: character_id,\r\n                });\r\n                movement_tool_ids.for_each(|id| {\r\n                    movement_target_events.send(MovementTargetEvent::SetTarget {\r\n                        tool_id: id,\r\n                        target: MovementTarget::Camera(camera_id),\r\n                    });\r\n                });\r\n                info!(\"Sent unfollow events\");\r\n            }\r\n        }\r\n        if tool_actions.just_pressed(FocusToolAction::FocusMainWindow) {\r\n            info!(\"Focus main window\");\r\n            let Ok(window_handle) = window_query.get_single() else {\r\n                error!(\"No primary window found\");\r\n                return;\r\n            };\r\n            let win32handle = match window_handle.window_handle {\r\n                raw_window_handle::RawWindowHandle::Win32(handle) => handle,\r\n                _ => panic!(\"Unsupported window handle\"),\r\n            };\r\n            focus_window(win32handle.hwnd as isize);\r\n            if let Ok(position) = get_window_title_bar_center_position(win32handle.hwnd as isize) {\r\n                match set_cursor_position(position) {\r\n                    Ok(_) => info!(\"Moved cursor to window title bar\"),\r\n                    Err(e) => error!(\"Failed to move cursor to window title bar: {:?}\", e),\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\fullscreen_tool_types\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_fullscreen_tool_types\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\nleafwing-input-manager = { workspace = true }\r\nbevy-inspector-egui = { workspace = true }\r\ncursor_hero_toolbelt_types = { workspace = true }\r\ncursor_hero_input = { workspace = true }\r\ncursor_hero_tools = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\memory_types\\src\\memory_types.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse std::fs::File;\r\nuse std::fs::OpenOptions;\r\nuse std::io::Read;\r\nuse std::io::Write;\r\nuse std::path::PathBuf;\r\n\r\n#[derive(Resource, Reflect, Clone)]\r\npub struct MemoryConfig {\r\n    pub save_dir: String,\r\n}\r\n\r\n#[derive(Reflect, Default)]\r\npub struct MemoryPluginBuildConfig {\r\n    pub main_character_memory_enabled: bool,\r\n    pub primary_window_memory_enabled: bool,\r\n    pub main_camera_memory_enabled: bool,\r\n    pub voice_to_text_memory_enabled: bool,\r\n    pub agent_observation_memory_enabled: bool,\r\n}\r\n\r\nimpl MemoryPluginBuildConfig {\r\n    pub fn all_enabled() -> Self {\r\n        Self {\r\n            main_character_memory_enabled: true,\r\n            primary_window_memory_enabled: true,\r\n            main_camera_memory_enabled: true,\r\n            voice_to_text_memory_enabled: true,\r\n            agent_observation_memory_enabled: true,\r\n        }\r\n    }\r\n}\r\n\r\n#[derive(Debug)]\r\n#[allow(dead_code)]\r\npub enum PersistError {\r\n    Io(std::io::Error),\r\n    WindowBounds(cursor_hero_winutils::win_window::WindowBoundsError),\r\n    Query,\r\n    Json(serde_json::Error),\r\n}\r\n\r\n#[derive(Debug)]\r\npub enum PersistSuccess {\r\n    WritePerformed,\r\n    Debounce,\r\n    Cooldown,\r\n    NoAction,\r\n}\r\n\r\n#[derive(Debug)]\r\n#[allow(dead_code)]\r\npub enum RestoreError {\r\n    Io(std::io::Error),\r\n    Json(serde_json::Error),\r\n    Query,\r\n}\r\n\r\n#[derive(Debug)]\r\npub enum RestoreSuccess {\r\n    Performed,\r\n    NoAction,\r\n}\r\n\r\n#[derive(Eq, PartialEq)]\r\npub enum Usage {\r\n    Persist,\r\n    Restore,\r\n}\r\n\r\npub fn get_persist_file(\r\n    config: &MemoryConfig,\r\n    file_name: &str,\r\n    usage: Usage,\r\n) -> Result<std::fs::File, std::io::Error> {\r\n    let mut file_path = PathBuf::from(config.save_dir.clone());\r\n    if usage == Usage::Persist && !file_path.exists() {\r\n        std::fs::create_dir_all(&file_path)?;\r\n    }\r\n    file_path.push(file_name);\r\n\r\n    let file = match usage {\r\n        Usage::Persist => OpenOptions::new()\r\n            .write(true)\r\n            .truncate(true)\r\n            .create(true)\r\n            .open(file_path)?,\r\n        Usage::Restore => OpenOptions::new().read(true).open(file_path)?,\r\n    };\r\n    Ok(file)\r\n}\r\n\r\npub fn write_to_disk<T>(mut file: File, data: T) -> Result<PersistSuccess, PersistError>\r\nwhere\r\n    T: serde::Serialize,\r\n{\r\n    let serialized = serde_json::to_string_pretty(&data).map_err(PersistError::Json)?;\r\n    file.write_all(serialized.as_bytes())\r\n        .map_err(PersistError::Io)?;\r\n    Ok(PersistSuccess::WritePerformed)\r\n}\r\n\r\npub fn read_from_disk<T>(mut file: File) -> Result<T, RestoreError>\r\nwhere\r\n    T: serde::de::DeserializeOwned,\r\n{\r\n    let mut contents = String::new();\r\n    file.read_to_string(&mut contents)\r\n        .map_err(RestoreError::Io)?;\r\n    let data = serde_json::from_str(&contents).map_err(RestoreError::Json)?;\r\n    Ok(data)\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\templates\\patterns\\new_tool\\crates\\{{crate_name}}_tool\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_{{crate_name}}_tool\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\ncursor_hero_{{crate_name}}_tool_types = { workspace = true }\r\ncursor_hero_toolbelt_types = { workspace = true }\r\ncursor_hero_tools = { workspace = true }\r\nleafwing-input-manager = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\physics\\src\\damping_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse bevy_xpbd_2d::math::*;\r\nuse bevy_xpbd_2d::prelude::*;\r\n\r\npub struct DampingPlugin;\r\n\r\n#[derive(SystemSet, Clone, Hash, Debug, PartialEq, Eq)]\r\npub enum DampingSystemSet {\r\n    Dampen,\r\n}\r\n\r\nimpl Plugin for DampingPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<MovementDamping>();\r\n        app.configure_sets(Update, DampingSystemSet::Dampen);\r\n        app.add_systems(\r\n            Update,\r\n            apply_movement_damping.in_set(DampingSystemSet::Dampen),\r\n        );\r\n    }\r\n}\r\n\r\n#[derive(Component, Reflect, Debug)]\r\npub struct MovementDamping {\r\n    pub factor: Scalar,\r\n}\r\n\r\nimpl Default for MovementDamping {\r\n    fn default() -> Self {\r\n        Self { factor: 0.95 }\r\n    }\r\n}\r\n\r\n#[allow(clippy::type_complexity)]\r\nfn apply_movement_damping(\r\n    mut query: Query<\r\n        (&MovementDamping, &mut LinearVelocity, &mut AngularVelocity),\r\n        Without<Sleeping>,\r\n    >,\r\n    time: Res<Time<Physics>>,\r\n) {\r\n    if time.is_paused() {\r\n        return;\r\n    }\r\n    for (damping, mut linear_velocity, mut angular_velocity) in &mut query {\r\n        linear_velocity.x *= damping.factor;\r\n        if linear_velocity.x.abs() < 10.0 {\r\n            linear_velocity.x = 0.0;\r\n        }\r\n        linear_velocity.y *= damping.factor;\r\n        if linear_velocity.y.abs() < 10.0 {\r\n            linear_velocity.y = 0.0;\r\n        }\r\n        angular_velocity.0 *= damping.factor;\r\n        if angular_velocity.0.abs() < 10.0 {\r\n            angular_velocity.0 = 0.0;\r\n        }\r\n        // if linear_velocity.x != 0.0 && linear_velocity.y != 0.0 {\r\n        //     debug!(\"linear_velocity: {:?}\", linear_velocity);\r\n        // }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\winutils\\src\\win_screen_capture.rs\r\n\r\n````rust\r\n#![allow(unused_imports)]\r\n// most code from https://github.com/nashaofu/screenshots-rs/ commit 999faac06f85bd93638c2a9cda6cbb25ad9f5c73\r\n// my changes are MPLv2, original code is Apache 2.0\r\n// modifications aim to reduce redundant work for successive screen capture calls\r\n\r\n// might also be interesting:\r\n// https://github.com/rhinostream/win_desktop_duplication/tree/master\r\n// https://github.com/rustdesk/rustdesk\r\n// https://github.com/RustBuddies/desktop-sharing\r\n// https://github.com/mira-screen-share/sharer/blob/main/src/capture/wgc/display.rs\r\n\r\n#[cfg(target_arch = \"x86\")]\r\nuse std::arch::x86::_mm_shuffle_epi8;\r\nuse std::arch::x86_64::__m128i;\r\nuse std::arch::x86_64::_mm_loadu_si128;\r\nuse std::arch::x86_64::_mm_setr_epi8;\r\n#[cfg(target_arch = \"x86_64\")]\r\nuse std::arch::x86_64::_mm_shuffle_epi8;\r\nuse std::arch::x86_64::_mm_storeu_si128;\r\nuse std::sync::Arc;\r\n\r\nuse anyhow::anyhow;\r\nuse anyhow::Result;\r\nuse bevy::math::IRect;\r\nuse cursor_hero_bevy::prelude::LeftI;\r\nuse cursor_hero_bevy::prelude::TopI;\r\nuse cursor_hero_bevy::prelude::TopLeftI;\r\nuse cursor_hero_bevy::prelude::TranslateIVec2;\r\nuse cursor_hero_math::prelude::bgra_to_rgba;\r\n// use display_info::DisplayInfo;\r\n// use fxhash::hash32;\r\nuse image::RgbaImage;\r\nuse std::mem;\r\nuse std::ops::Deref;\r\nuse std::ptr;\r\nuse std::rc::Rc;\r\nuse widestring::U16CString;\r\nuse windows::core::PCWSTR;\r\nuse windows::Win32::Foundation::BOOL;\r\nuse windows::Win32::Foundation::LPARAM;\r\nuse windows::Win32::Foundation::RECT;\r\nuse windows::Win32::Graphics::Gdi::BitBlt;\r\nuse windows::Win32::Graphics::Gdi::CreateCompatibleBitmap;\r\nuse windows::Win32::Graphics::Gdi::CreateCompatibleDC;\r\nuse windows::Win32::Graphics::Gdi::CreateDCW;\r\nuse windows::Win32::Graphics::Gdi::DeleteDC;\r\nuse windows::Win32::Graphics::Gdi::DeleteObject;\r\nuse windows::Win32::Graphics::Gdi::EnumDisplayMonitors;\r\nuse windows::Win32::Graphics::Gdi::GetDIBits;\r\nuse windows::Win32::Graphics::Gdi::GetMonitorInfoW;\r\nuse windows::Win32::Graphics::Gdi::GetObjectW;\r\nuse windows::Win32::Graphics::Gdi::SelectObject;\r\nuse windows::Win32::Graphics::Gdi::SetStretchBltMode;\r\nuse windows::Win32::Graphics::Gdi::StretchBlt;\r\nuse windows::Win32::Graphics::Gdi::BITMAP;\r\nuse windows::Win32::Graphics::Gdi::BITMAPINFO;\r\nuse windows::Win32::Graphics::Gdi::BITMAPINFOHEADER;\r\nuse windows::Win32::Graphics::Gdi::DIB_RGB_COLORS;\r\nuse windows::Win32::Graphics::Gdi::HBITMAP;\r\nuse windows::Win32::Graphics::Gdi::HDC;\r\nuse windows::Win32::Graphics::Gdi::HMONITOR;\r\nuse windows::Win32::Graphics::Gdi::MONITORINFOEXW;\r\nuse windows::Win32::Graphics::Gdi::RGBQUAD;\r\nuse windows::Win32::Graphics::Gdi::SRCCOPY;\r\nuse windows::Win32::Graphics::Gdi::STRETCH_HALFTONE;\r\n\r\nuse cursor_hero_metrics::Metrics;\r\n\r\nuse crate::ToBevyIRect;\r\n\r\n//////////////////////\r\n/// GET MONITOR INFOS\r\n//////////////////////\r\n\r\n#[derive(Debug)]\r\npub struct MonitorInfo {\r\n    pub id: u32,\r\n    pub name: String,\r\n    pub rect: IRect,\r\n    pub work_area: IRect, // the area of the monitor not covered by the taskbar\r\n    pub is_primary: bool,\r\n}\r\n\r\npub fn get_monitor_infos() -> Result<Vec<MonitorInfo>> {\r\n    // box it up so we can pass it to the callback\r\n    let results: *mut Vec<MONITORINFOEXW> = Box::into_raw(Box::default());\r\n\r\n    // use proc method to iterate monitors and collect into results vec\r\n    unsafe {\r\n        EnumDisplayMonitors(\r\n            HDC::default(),\r\n            None,\r\n            Some(monitor_enum_proc),\r\n            LPARAM(results as isize),\r\n        )\r\n        .ok()?;\r\n    };\r\n\r\n    // convert results back into a vec\r\n    let results = unsafe { &Box::from_raw(results) };\r\n\r\n    // convert vec of MONITORINFOEXW into vec of MonitorInfo\r\n    let results = results\r\n        .iter()\r\n        .map(|info| {\r\n            let sz_device_ptr = info.szDevice.as_ptr();\r\n            let sz_device_string =\r\n                unsafe { U16CString::from_ptr_str(sz_device_ptr).to_string_lossy() };\r\n            MonitorInfo {\r\n                id: fxhash::hash32(sz_device_string.as_bytes()), // same algorithm as screen crate\r\n                name: sz_device_string,\r\n                rect: info.monitorInfo.rcMonitor.to_bevy_irect(),\r\n                work_area: info.monitorInfo.rcWork.to_bevy_irect(),\r\n                is_primary: info.monitorInfo.dwFlags == 1,\r\n            }\r\n        })\r\n        .collect::<Vec<MonitorInfo>>();\r\n    Ok(results)\r\n}\r\n\r\nextern \"system\" fn monitor_enum_proc(\r\n    h_monitor: HMONITOR,\r\n    _: HDC,\r\n    _: *mut RECT,\r\n    data: LPARAM,\r\n) -> BOOL {\r\n    let results = unsafe { Box::from_raw(data.0 as *mut Vec<MONITORINFOEXW>) };\r\n    let results = Box::leak(results);\r\n\r\n    match get_monitor_info_exw(h_monitor) {\r\n        Ok(monitor_info_exw) => {\r\n            results.push(monitor_info_exw);\r\n            BOOL::from(true)\r\n        }\r\n        Err(_) => BOOL::from(false),\r\n    }\r\n}\r\n\r\nfn get_monitor_info_exw(h_monitor: HMONITOR) -> Result<MONITORINFOEXW> {\r\n    let mut monitor_info_exw: MONITORINFOEXW = unsafe { mem::zeroed() };\r\n    monitor_info_exw.monitorInfo.cbSize = mem::size_of::<MONITORINFOEXW>() as u32;\r\n    let monitor_info_exw_ptr = <*mut _>::cast(&mut monitor_info_exw);\r\n\r\n    unsafe {\r\n        GetMonitorInfoW(h_monitor, monitor_info_exw_ptr).ok()?;\r\n    };\r\n    Ok(monitor_info_exw)\r\n}\r\n\r\n//////////////////\r\n/// GET MONITORS\r\n//////////////////\r\npub struct Monitor {\r\n    pub info: MonitorInfo,\r\n    device_context: HDC,\r\n}\r\n\r\npub fn get_all_monitors() -> Result<Vec<Monitor>> {\r\n    let monitor_infos = get_monitor_infos()?;\r\n    let mut monitors = Vec::new();\r\n\r\n    for monitor_info in monitor_infos {\r\n        // intermediate variables are required to ensure the pointer contents remain in scope\r\n        let a = U16CString::from_str(&monitor_info.name)?;\r\n        let b = a.as_ptr();\r\n        let name_pcwstr = PCWSTR(b);\r\n        let device_context =\r\n            unsafe { CreateDCW(name_pcwstr, name_pcwstr, PCWSTR(ptr::null()), None) };\r\n\r\n        monitors.push(Monitor {\r\n            info: monitor_info,\r\n            device_context,\r\n        });\r\n    }\r\n\r\n    Ok(monitors)\r\n}\r\n\r\n/////////////////////////////\r\n/// MONITOR REGION CAPTURER\r\n/////////////////////////////\r\n\r\npub struct MonitorRegionCapturer {\r\n    pub monitor: Arc<Monitor>,\r\n    pub capture_region: IRect,\r\n    device_context: HDC,\r\n    bitmap: HBITMAP,\r\n}\r\n\r\npub fn get_full_monitor_capturers() -> Result<Vec<MonitorRegionCapturer>> {\r\n    let monitors = get_all_monitors()?;\r\n    let mut capturers = Vec::new();\r\n\r\n    for monitor in monitors {\r\n        let region = monitor.info.rect;\r\n        let capturer = get_monitor_capturer(Arc::new(monitor), region);\r\n        capturers.push(capturer);\r\n    }\r\n\r\n    Ok(capturers)\r\n}\r\n\r\npub fn get_monitor_capturer(monitor: Arc<Monitor>, capture_region: IRect) -> MonitorRegionCapturer {\r\n    let capture_device_context = unsafe { CreateCompatibleDC(monitor.device_context) };\r\n    let bitmap = unsafe {\r\n        CreateCompatibleBitmap(\r\n            monitor.device_context,\r\n            capture_region.width(),\r\n            capture_region.height(),\r\n        )\r\n    };\r\n\r\n    unsafe {\r\n        SelectObject(capture_device_context, bitmap);\r\n        SetStretchBltMode(monitor.device_context, STRETCH_HALFTONE);\r\n    };\r\n\r\n    MonitorRegionCapturer {\r\n        monitor,\r\n        device_context: capture_device_context,\r\n        bitmap,\r\n        capture_region,\r\n    }\r\n}\r\n\r\nimpl Drop for MonitorRegionCapturer {\r\n    fn drop(&mut self) {\r\n        unsafe {\r\n            DeleteObject(self.bitmap);\r\n            DeleteDC(self.device_context);\r\n        }\r\n    }\r\n}\r\nimpl MonitorRegionCapturer {\r\n    // pub fn capture(&self) -> Result<RgbaImage> {\r\n    pub fn capture(&self, metrics: &mut Option<Metrics>) -> Result<RgbaImage> {\r\n        // todo: try https://learn.microsoft.com/en-us/windows/win32/api/dxgi1_2/nf-dxgi1_2-idxgioutputduplication-acquirenextframe\r\n        unsafe {\r\n            if let Some(metrics) = metrics {\r\n                metrics.begin(\"blit\");\r\n            }\r\n            StretchBlt(\r\n                self.device_context,\r\n                0,\r\n                0,\r\n                self.capture_region.width(),\r\n                self.capture_region.height(),\r\n                self.monitor.device_context,\r\n                self.monitor.info.rect.left() - self.capture_region.left(),\r\n                self.monitor.info.rect.top() - self.capture_region.top(),\r\n                self.capture_region.width(),\r\n                self.capture_region.height(),\r\n                SRCCOPY,\r\n            )\r\n            .ok()?;\r\n            if let Some(metrics) = metrics {\r\n                metrics.end(\"blit\");\r\n            }\r\n        };\r\n\r\n        let mut bitmap_info = BITMAPINFO {\r\n            bmiHeader: BITMAPINFOHEADER {\r\n                biSize: mem::size_of::<BITMAPINFOHEADER>() as u32,\r\n                biWidth: self.capture_region.width(),\r\n                biHeight: -self.capture_region.height(),\r\n                biPlanes: 1,\r\n                biBitCount: 32,\r\n                biCompression: 0,\r\n                biSizeImage: 0,\r\n                biXPelsPerMeter: 0,\r\n                biYPelsPerMeter: 0,\r\n                biClrUsed: 0,\r\n                biClrImportant: 0,\r\n            },\r\n            bmiColors: [RGBQUAD::default(); 1],\r\n        };\r\n\r\n        let mut data =\r\n            vec![0u8; (self.capture_region.width() * self.capture_region.height()) as usize * 4];\r\n        let buf_prt = data.as_ptr() as *mut _;\r\n\r\n        if let Some(metrics) = metrics {\r\n            metrics.begin(\"getdibits\");\r\n        }\r\n        let err = unsafe {\r\n            GetDIBits(\r\n                self.device_context,\r\n                self.bitmap,\r\n                0,\r\n                self.capture_region.height() as u32,\r\n                Some(buf_prt),\r\n                &mut bitmap_info,\r\n                DIB_RGB_COLORS,\r\n            ) == 0\r\n        };\r\n        if let Some(metrics) = metrics {\r\n            metrics.end(\"getdibits\");\r\n        }\r\n\r\n        if err {\r\n            return Err(anyhow!(\"Get RGBA data failed\"));\r\n        }\r\n\r\n        let mut bitmap = BITMAP::default();\r\n        let bitmap_ptr = <*mut _>::cast(&mut bitmap);\r\n\r\n        if let Some(metrics) = metrics {\r\n            metrics.begin(\"getobject\");\r\n        }\r\n        unsafe {\r\n            // Get the BITMAP from the HBITMAP.\r\n            GetObjectW(\r\n                self.bitmap,\r\n                mem::size_of::<BITMAP>() as i32,\r\n                Some(bitmap_ptr),\r\n            );\r\n        }\r\n        if let Some(metrics) = metrics {\r\n            metrics.end(\"getobject\");\r\n        }\r\n\r\n        if let Some(metrics) = metrics {\r\n            metrics.begin(\"shuffle\");\r\n        }\r\n        bgra_to_rgba(data.as_mut_slice());\r\n        if let Some(metrics) = metrics {\r\n            metrics.end(\"shuffle\");\r\n        }\r\n\r\n        let data = RgbaImage::from_vec(\r\n            self.capture_region.width() as u32,\r\n            self.capture_region.height() as u32,\r\n            data,\r\n        );\r\n        data.ok_or_else(|| anyhow!(\"Invalid image data\"))\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\n#[allow(unused_imports)]\r\nmod tests {\r\n    use bevy::math::IVec2;\r\n\r\n    use super::*;\r\n\r\n    #[test]\r\n    fn names() {\r\n        get_monitor_infos().unwrap().iter().for_each(|info| {\r\n            println!(\"{:?}\", info);\r\n        });\r\n    }\r\n\r\n    #[test]\r\n    fn full_screenshots() {\r\n        let capturers = get_full_monitor_capturers().unwrap();\r\n        std::fs::create_dir_all(\"target/capture\").unwrap();\r\n\r\n        capturers.iter().for_each(|capturer| {\r\n            let capture = capturer.capture(&mut None).unwrap();\r\n            let mon_name_good = capturer.monitor.info.name.replace(r\"\\\\.\\\", \"\");\r\n            let path = format!(\"target/capture/full-{}.png\", mon_name_good);\r\n            capture.save(path).unwrap();\r\n        });\r\n    }\r\n\r\n    #[test]\r\n    fn region_screenshots() {\r\n        let monitors = get_all_monitors().unwrap();\r\n        let mut capturers = Vec::new();\r\n\r\n        for monitor in monitors {\r\n            let p0 = monitor.info.rect.top_left();\r\n            let p1 = p0 + IVec2::new(100, 100);\r\n            let region = IRect::from_corners(p0, p1);\r\n            let capturer = get_monitor_capturer(Arc::new(monitor), region);\r\n            capturers.push(capturer);\r\n        }\r\n        std::fs::create_dir_all(\"target/capture\").unwrap();\r\n\r\n        capturers.iter().for_each(|capturer| {\r\n            let capture = capturer.capture(&mut None).unwrap();\r\n            let mon_name_good = capturer.monitor.info.name.replace(r\"\\\\.\\\", \"\");\r\n            let path = format!(\"target/capture/region-{}.png\", mon_name_good);\r\n            capture.save(path).unwrap();\r\n        });\r\n    }\r\n\r\n    #[test]\r\n    fn capture_avg() {\r\n        let capturers = get_full_monitor_capturers().unwrap();\r\n        std::fs::create_dir_all(\"target/capture\").unwrap();\r\n\r\n        for _ in 0..100 {\r\n            capturers.iter().for_each(|capturer| {\r\n                let capture = capturer.capture(&mut None).unwrap();\r\n                let (mut tot_r, mut tot_g, mut tot_b) = (0, 0, 0);\r\n\r\n                for pixel in capture.enumerate_pixels() {\r\n                    let image::Rgba([r, g, b, _]) = pixel.2; // Destructure the Rgba struct\r\n                    tot_r += *r as u64;\r\n                    tot_g += *g as u64;\r\n                    tot_b += *b as u64;\r\n                }\r\n                let size = capture.iter().count() as u64;\r\n                print!(\r\n                    \"{} -- avg: {:?}\\t\",\r\n                    capturer.monitor.info.name,\r\n                    (tot_r / size, tot_g / size, tot_b / size)\r\n                );\r\n            });\r\n            print!(\"\\n\");\r\n            std::thread::sleep(std::time::Duration::from_millis(100));\r\n        }\r\n    }\r\n\r\n    #[test]\r\n    fn screenshot_speed() {\r\n        let capturers = get_full_monitor_capturers().unwrap();\r\n        let mut durations = Vec::new();\r\n        for _ in 0..100 {\r\n            capturers.iter().for_each(|capturer| {\r\n                let start = std::time::Instant::now();\r\n                let _ = capturer.capture(&mut None).unwrap();\r\n                let duration = start.elapsed();\r\n                durations.push(duration.as_millis());\r\n            });\r\n            std::thread::sleep(std::time::Duration::from_millis(1));\r\n        }\r\n        let avg = durations.iter().sum::<u128>() / durations.len() as u128;\r\n        println!(\"avg: {:?}ms\", avg);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\templates\\patterns\\new_plugin_with_types\\crates\\{{crate_name}}_types\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_{{crate_name}}_types\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\calculator_app_types\\src\\calculator_app_types_plugin.rs\r\n\r\n````rust\r\nuse crate::prelude::*;\r\nuse bevy::prelude::*;\r\n\r\npub struct CalculatorAppTypesPlugin;\r\n\r\nimpl Plugin for CalculatorAppTypesPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<AppWindow>();\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\fullscreen_tool\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_fullscreen_tool\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\ncursor_hero_fullscreen_tool_types = { workspace = true }\r\ncursor_hero_toolbelt_types = { workspace = true }\r\ncursor_hero_tools = { workspace = true }\r\nleafwing-input-manager = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\tools\\src\\restart_tool.rs\r\n\r\n````rust\r\nuse std::os::windows::process::CommandExt;\r\nuse std::path::PathBuf;\r\n\r\nuse bevy::prelude::*;\r\nuse leafwing_input_manager::prelude::*;\r\n\r\nuse windows::Win32::System::Threading::CREATE_NEW_PROCESS_GROUP;\r\n\r\nuse cursor_hero_data::paths::CURSOR_HERO_GIT_DIR;\r\nuse cursor_hero_toolbelt_types::prelude::*;\r\n\r\nuse crate::prelude::*;\r\npub struct RestartToolPlugin;\r\n\r\nimpl Plugin for RestartToolPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<RestartTool>();\r\n        app.add_plugins(InputManagerPlugin::<RestartToolAction>::default());\r\n        app.add_systems(Update, toolbelt_events);\r\n        app.add_systems(Update, handle_input);\r\n    }\r\n}\r\n\r\n#[derive(Component, Reflect, Default)]\r\nstruct RestartTool;\r\n\r\nfn toolbelt_events(\r\n    mut commands: Commands,\r\n    asset_server: Res<AssetServer>,\r\n    mut reader: EventReader<ToolbeltPopulateEvent>,\r\n) {\r\n    for event in reader.read() {\r\n        let (ToolbeltLoadout::Inspector | ToolbeltLoadout::Default) = event.loadout else {\r\n            continue;\r\n        };\r\n        {\r\n            ToolSpawnConfig::<RestartTool, RestartToolAction>::new(RestartTool, event.id, event)\r\n                .with_src_path(file!().into())\r\n                .guess_name(file!())\r\n                .guess_image(file!(), &asset_server, \"png\")\r\n                .with_description(\"Send Ctrl+C, uparrow, enter\")\r\n                .spawn(&mut commands);\r\n        }\r\n    }\r\n}\r\n\r\n#[derive(Actionlike, PartialEq, Eq, Clone, Copy, Hash, Debug, Reflect)]\r\nenum RestartToolAction {\r\n    CancelAndRunPreviousTerminalCommand,\r\n}\r\n\r\nimpl RestartToolAction {\r\n    fn default_gamepad_binding(&self) -> UserInput {\r\n        match self {\r\n            Self::CancelAndRunPreviousTerminalCommand => GamepadButtonType::Start.into(),\r\n        }\r\n    }\r\n\r\n    fn default_mkb_binding(&self) -> UserInput {\r\n        match self {\r\n            Self::CancelAndRunPreviousTerminalCommand => KeyCode::Plus.into(),\r\n        }\r\n    }\r\n}\r\nimpl ToolAction for RestartToolAction {\r\n    fn default_input_map(_event: &ToolbeltPopulateEvent) -> Option<InputMap<RestartToolAction>> {\r\n        let mut input_map = InputMap::default();\r\n\r\n        for variant in RestartToolAction::variants() {\r\n            input_map.insert(variant.default_mkb_binding(), variant);\r\n            input_map.insert(variant.default_gamepad_binding(), variant);\r\n        }\r\n        Some(input_map)\r\n    }\r\n}\r\n\r\n#[allow(clippy::type_complexity)]\r\nfn handle_input(tools: Query<&ActionState<RestartToolAction>, With<ActiveTool>>) {\r\n    for t_act in tools.iter() {\r\n        if t_act.just_pressed(RestartToolAction::CancelAndRunPreviousTerminalCommand) {\r\n            // run target/release/uparrow-enter.exe\r\n\r\n            let mut path = PathBuf::from(CURSOR_HERO_GIT_DIR);\r\n            path.push(\"target/release/uparrow-enter.exe\");\r\n\r\n            // if it doesn't exist\r\n            if !path.exists() {\r\n                let mut other_project_path = PathBuf::from(CURSOR_HERO_GIT_DIR);\r\n                other_project_path.push(\"other/uparrow-enter\");\r\n                // run cargo build --release\r\n                match std::process::Command::new(\"cargo\")\r\n                    .arg(\"build\")\r\n                    .arg(\"--release\")\r\n                    .current_dir(other_project_path)\r\n                    .spawn()\r\n                {\r\n                    Ok(_) => info!(\"Successfully ran cargo build --release\"),\r\n                    Err(e) => error!(\"Failed to run cargo build --release: {}\", e),\r\n                }\r\n            }\r\n\r\n            match std::process::Command::new(path)\r\n                .creation_flags(CREATE_NEW_PROCESS_GROUP.0)\r\n                .spawn()\r\n            {\r\n                Ok(_) => info!(\"Successfully ran uparrow-enter.exe\"),\r\n                Err(e) => error!(\"Failed to run uparrow-enter.exe: {}\", e),\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\observation\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_observation\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\ncursor_hero_observation_types = { workspace = true }\r\ncursor_hero_inference_types = { workspace = true }\r\ncursor_hero_toolbelt_types = { workspace = true }\r\ncursor_hero_tools = { workspace = true }\r\ncursor_hero_chat_types = { workspace = true }\r\ncursor_hero_character_types = { workspace = true }\r\ncursor_hero_environment_types = { workspace = true }\r\nchrono = {workspace = true}\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\tools\\src\\keyboard_tool.rs\r\n\r\n````rust\r\nuse crate::prelude::*;\r\nuse bevy::prelude::*;\r\nuse bevy::utils::HashMap;\r\nuse bevy_inspector_egui::prelude::ReflectInspectorOptions;\r\nuse bevy_inspector_egui::InspectorOptions;\r\nuse cursor_hero_character_types::prelude::*;\r\nuse cursor_hero_math::prelude::Lerp;\r\nuse cursor_hero_sprint_tool_types::sprint_tool_types_plugin::SprintEvent;\r\nuse cursor_hero_toolbelt_types::prelude::*;\r\nuse enigo::Direction::Press;\r\nuse enigo::Direction::Release;\r\nuse enigo::*;\r\nuse itertools::Itertools;\r\nuse leafwing_input_manager::prelude::*;\r\n\r\npub struct KeyboardToolPlugin;\r\n\r\nimpl Plugin for KeyboardToolPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_plugins(InputManagerPlugin::<KeyboardToolAction>::default());\r\n        app.add_systems(\r\n            Update,\r\n            (toolbelt_events, handle_input, handle_sprint_events),\r\n        );\r\n    }\r\n}\r\n\r\n#[derive(Component, InspectorOptions, Debug, Reflect)]\r\n#[reflect(Component, InspectorOptions)]\r\nstruct KeyboardTool {\r\n    #[inspector(min = 0.0)]\r\n    repeat_delay: f32,\r\n    #[inspector(min = 0.0)]\r\n    default_repeat_delay: f32,\r\n    #[inspector(min = 0.0)]\r\n    sprint_repeat_delay: f32,\r\n}\r\nimpl Default for KeyboardTool {\r\n    fn default() -> Self {\r\n        Self {\r\n            repeat_delay: 0.1,\r\n            default_repeat_delay: 0.1,\r\n            sprint_repeat_delay: 0.001,\r\n        }\r\n    }\r\n}\r\n\r\nfn toolbelt_events(\r\n    mut commands: Commands,\r\n    asset_server: Res<AssetServer>,\r\n    mut reader: EventReader<ToolbeltPopulateEvent>,\r\n) {\r\n    for event in reader.read() {\r\n        if event.loadout != ToolbeltLoadout::Keyboard {\r\n            continue;\r\n        }\r\n        ToolSpawnConfig::<KeyboardTool, KeyboardToolAction>::new(\r\n            KeyboardTool::default(),\r\n            event.id,\r\n            event,\r\n        )\r\n        .with_src_path(file!().into())\r\n        .guess_name(file!())\r\n        .guess_image(file!(), &asset_server, \"png\")\r\n        .with_description(\"Keyboard inputs\")\r\n        .spawn(&mut commands);\r\n    }\r\n}\r\n\r\n#[derive(Actionlike, PartialEq, Eq, Clone, Copy, Hash, Debug, Reflect)]\r\nenum KeyboardToolAction {\r\n    Ctrl,\r\n    Tab,\r\n    Enter,\r\n    Backspace,\r\n    // Escape,\r\n    Shift,\r\n    Space,\r\n    Windows,\r\n    UpArrow,\r\n    DownArrow,\r\n    LeftArrow,\r\n    RightArrow,\r\n}\r\n\r\nimpl KeyboardToolAction {\r\n    fn to_enigo(self) -> Key {\r\n        match self {\r\n            Self::Ctrl => Key::Control,\r\n            Self::Tab => Key::Tab,\r\n            Self::Enter => Key::Return,\r\n            Self::Backspace => Key::Backspace,\r\n            // Self::Escape => Key::Escape,\r\n            Self::Shift => Key::Shift,\r\n            Self::Space => Key::Space,\r\n            Self::Windows => Key::Meta,\r\n            Self::UpArrow => Key::UpArrow,\r\n            Self::DownArrow => Key::DownArrow,\r\n            Self::LeftArrow => Key::LeftArrow,\r\n            Self::RightArrow => Key::RightArrow,\r\n        }\r\n    }\r\n}\r\n\r\nimpl KeyboardToolAction {\r\n    fn default_gamepad_binding(&self) -> UserInput {\r\n        match self {\r\n            Self::Ctrl => GamepadButtonType::RightTrigger.into(),\r\n            Self::Tab => GamepadButtonType::West.into(),\r\n            Self::Enter => GamepadButtonType::North.into(),\r\n            Self::Backspace => GamepadButtonType::East.into(),\r\n            // Self::Escape => GamepadButtonType::Select.into(),\r\n            Self::Shift => GamepadButtonType::LeftTrigger.into(),\r\n            Self::Space => GamepadButtonType::South.into(),\r\n            Self::Windows => GamepadButtonType::Start.into(),\r\n            Self::UpArrow => GamepadButtonType::DPadUp.into(),\r\n            Self::DownArrow => GamepadButtonType::DPadDown.into(),\r\n            Self::LeftArrow => GamepadButtonType::DPadLeft.into(),\r\n            Self::RightArrow => GamepadButtonType::DPadRight.into(),\r\n        }\r\n    }\r\n\r\n    fn default_mkb_binding(&self) -> UserInput {\r\n        match self {\r\n            Self::Ctrl => KeyCode::ControlLeft.into(),\r\n            Self::Tab => KeyCode::Tab.into(),\r\n            Self::Enter => KeyCode::Return.into(),\r\n            Self::Backspace => KeyCode::Back.into(),\r\n            // Self::Escape => KeyCode::Escape.into(),\r\n            Self::Shift => KeyCode::ShiftLeft.into(),\r\n            Self::Space => KeyCode::Space.into(),\r\n            Self::Windows => KeyCode::SuperLeft.into(),\r\n            Self::UpArrow => KeyCode::Up.into(),\r\n            Self::DownArrow => KeyCode::Down.into(),\r\n            Self::LeftArrow => KeyCode::Left.into(),\r\n            Self::RightArrow => KeyCode::Right.into(),\r\n        }\r\n    }\r\n}\r\n\r\nimpl ToolAction for KeyboardToolAction {\r\n    fn default_input_map(_event: &ToolbeltPopulateEvent) -> Option<InputMap<KeyboardToolAction>> {\r\n        let mut input_map = InputMap::default();\r\n\r\n        for variant in KeyboardToolAction::variants() {\r\n            input_map.insert(variant.default_mkb_binding(), variant);\r\n            input_map.insert(variant.default_gamepad_binding(), variant);\r\n        }\r\n        Some(input_map)\r\n    }\r\n}\r\n\r\nfn handle_input(\r\n    tool_query: Query<(Entity, &ActionState<KeyboardToolAction>, &KeyboardTool), With<ActiveTool>>,\r\n    mut enigo: Local<Option<Enigo>>,\r\n    time: Res<Time>,\r\n    mut debounce: Local<HashMap<(Entity, KeyboardToolAction), Timer>>,\r\n) {\r\n    debounce.values_mut().for_each(|timer| {\r\n        timer.tick(time.delta());\r\n    });\r\n    debounce.retain(|_, timer| !timer.finished());\r\n\r\n    if enigo.is_none() {\r\n        *enigo = Enigo::new(&Settings::default()).ok();\r\n    }\r\n    let Some(ref mut enigo) = *enigo else {\r\n        warn!(\"Failed to create enigo\");\r\n        return;\r\n    };\r\n\r\n    for tool in tool_query.iter() {\r\n        let (tool_id, tool_actions, tool) = tool;\r\n        for variant in KeyboardToolAction::variants() {\r\n            if tool_actions.pressed(variant) {\r\n                if tool_actions.just_pressed(variant) {\r\n                    info!(\"{:?} key down\", variant);\r\n                }\r\n                if (*debounce).contains_key(&(tool_id, variant)) {\r\n                    continue;\r\n                } else {\r\n                    debounce.insert(\r\n                        (tool_id, variant),\r\n                        Timer::from_seconds(tool.repeat_delay, TimerMode::Once),\r\n                    );\r\n                }\r\n                if let Err(e) = enigo.key(variant.to_enigo(), Press) {\r\n                    warn!(\"Failed to send key: {:?}\", e);\r\n                }\r\n            }\r\n            if tool_actions.just_released(variant) {\r\n                info!(\"{:?} key up\", variant);\r\n                if let Err(e) = enigo.key(variant.to_enigo(), Release) {\r\n                    warn!(\"Failed to send key: {:?}\", e);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n#[cfg(test)]\r\nmod tests {\r\n    // test that sending shift + arrow keys is highlighting text\r\n    #[test]\r\n    fn test_shift_arrow() {\r\n        use enigo::Direction::Press;\r\n        use enigo::Direction::Release;\r\n        use enigo::Enigo;\r\n        use enigo::Key;\r\n        use enigo::Keyboard;\r\n        use enigo::Settings;\r\n        use std::thread::sleep;\r\n        use std::time::Duration;\r\n\r\n        let mut enigo = Enigo::new(&Settings::default()).unwrap();\r\n\r\n        sleep(Duration::from_secs(1));\r\n        enigo.key(Key::Shift, Press).unwrap();\r\n        enigo.key(Key::Control, Press).unwrap();\r\n        enigo.key(Key::RightArrow, Press).unwrap();\r\n\r\n        enigo.key(Key::RightArrow, Release).unwrap();\r\n        enigo.key(Key::Control, Release).unwrap();\r\n        enigo.key(Key::Shift, Release).unwrap();\r\n    }\r\n}\r\n\r\nfn handle_sprint_events(\r\n    mut sprint_events: EventReader<SprintEvent>,\r\n    character_query: Query<&Children, With<Character>>,\r\n    toolbelt_query: Query<&Children, With<Toolbelt>>,\r\n    mut tool_query: Query<&mut KeyboardTool>,\r\n) {\r\n    for event in sprint_events.read() {\r\n        let character_id = match event {\r\n            SprintEvent::Active { character_id, .. } => character_id,\r\n            SprintEvent::Stop { character_id } => character_id,\r\n        };\r\n        let Ok(character) = character_query.get(*character_id) else {\r\n            warn!(\"Character {:?} does not exist\", character_id);\r\n            continue;\r\n        };\r\n        let character_kids = character;\r\n        let tool_ids = character_kids\r\n            .iter()\r\n            .filter_map(|kid| toolbelt_query.get(*kid).ok())\r\n            .flat_map(|toolbelt| toolbelt.iter())\r\n            .filter(|kid| tool_query.contains(**kid))\r\n            .cloned()\r\n            .collect_vec();\r\n\r\n        match event {\r\n            SprintEvent::Active { throttle, .. } => {\r\n                let mut iter = tool_query.iter_many_mut(&tool_ids);\r\n                while let Some(mut tool) = iter.fetch_next() {\r\n                    tool.repeat_delay =\r\n                        (tool.default_repeat_delay, tool.sprint_repeat_delay).lerp(*throttle);\r\n                }\r\n            }\r\n            SprintEvent::Stop { .. } => {\r\n                let mut iter = tool_query.iter_many_mut(&tool_ids);\r\n                while let Some(mut tool) = iter.fetch_next() {\r\n                    tool.repeat_delay = tool.default_repeat_delay;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\host_event\\src\\lib.rs\r\n\r\n````rust\r\npub mod host_event_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::host_event_plugin::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\icon\\src\\lib.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse bevy::winit::WinitWindows;\r\nuse winit::window::Icon;\r\n\r\npub struct IconPlugin;\r\n\r\nimpl Plugin for IconPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Startup, load_window_icon);\r\n    }\r\n}\r\n\r\n#[derive(Resource, Reflect, Default)]\r\n#[reflect(Resource)]\r\nstruct WindowIconResource(Handle<Image>);\r\n\r\nfn load_window_icon(mut commands: Commands, asset_server: Res<AssetServer>) {\r\n    let icon_handle = asset_server.load(\"textures/icon.png\");\r\n    commands.add(|world: &mut World| {\r\n        // register the system\r\n        let system_id = world.register_system(update_window_icon);\r\n        info!(\r\n            \"Registered update_window_icon system with id {:?}\",\r\n            system_id\r\n        );\r\n\r\n        // add it to the update schedule\r\n        let mut schedules = world.resource_mut::<Schedules>();\r\n        if let Some(schedule) = schedules.get_mut(Update) {\r\n            schedule.add_systems(update_window_icon);\r\n        } else {\r\n            let mut new_schedule = Schedule::new(Update);\r\n            new_schedule.add_systems(update_window_icon);\r\n            schedules.insert(new_schedule);\r\n        }\r\n\r\n        // add handle holder with system id for later removal\r\n        world.insert_resource(WindowIconResource(icon_handle));\r\n    });\r\n}\r\n\r\nfn update_window_icon(\r\n    windows: NonSend<WinitWindows>,\r\n    materials: Res<Assets<Image>>,\r\n    icon_resource: Res<WindowIconResource>,\r\n    // mut commands: Commands,\r\n    mut flag: Local<bool>,\r\n) {\r\n    if *flag {\r\n        return;\r\n    }\r\n    if let Some(icon) = materials.get(&icon_resource.0) {\r\n        // update the icon\r\n        let icon = Icon::from_rgba(icon.clone().data, icon.size().x, icon.size().y).unwrap();\r\n        for window in windows.windows.values() {\r\n            window.set_window_icon(Some(icon.clone()));\r\n        }\r\n        info!(\"Updated window icon\");\r\n\r\n        // remove this system\r\n        // commands.add(move |world: &mut World| {\r\n        //     match world.remove_system(system_id) {\r\n        //         Ok(_) => info!(\"Removed update_window_icon system since it did its job\"),\r\n        //         Err(e) => error!(\"Failed to remove update_window_icon system: {}\", e),\r\n        //     }\r\n        //     let mut schedules = world.resource_mut::<Schedules>();\r\n        //     if let Some(_schedule) = schedules.get_mut(Update) {\r\n        //         /*\r\n        //         https://discord.com/channels/691052431525675048/749335865876021248/1138225592064561243\r\n        //         Alice \ud83c\udf39 \u2014 08/07/2023 5:42 PM\r\n        //         We're also missing a Schedule::remove_system API, with a solution for\r\n        //         a) dependency invalidation and\r\n        //         b) disambiguation of multiple copies of a system in the same schedule\r\n        //                              */\r\n        //         // this method does not exist yet.\r\n        //         // should probably make a PR for it\r\n        //         // and should also include a simplified way to remove a system from a schedule\r\n        //         // maybe a .remove_when similar to .run_if\r\n        //         // schedule.remove_system(system_id);\r\n        //     }\r\n        // });\r\n        *flag = true;\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\inference\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_inference\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\ncursor_hero_inference_types = {workspace = true}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\observation\\src\\lib.rs\r\n\r\n````rust\r\npub mod observation_buffer_plugin;\r\npub mod observation_log_plugin;\r\npub mod observation_plugin;\r\npub mod observation_tool_plugin;\r\npub mod observe_chat_plugin;\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\winutils\\src\\win_colors.rs\r\n\r\n````rust\r\nuse bevy::render::color::Color;\r\nuse std::error::Error;\r\nuse winreg::enums::*;\r\nuse winreg::RegKey;\r\n\r\npub fn get_accent_color() -> Result<Color, Box<dyn Error>> {\r\n    let hklm = RegKey::predef(HKEY_CURRENT_USER);\r\n    let personalization =\r\n        hklm.open_subkey(\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Explorer\\\\Accent\")?;\r\n    let accent_color: u32 = personalization.get_value(\"AccentColorMenu\")?;\r\n    Ok(abgr_to_rgba(accent_color))\r\n}\r\n\r\npub fn get_start_color() -> Result<Color, Box<dyn Error>> {\r\n    let hklm = RegKey::predef(HKEY_CURRENT_USER);\r\n    let personalization =\r\n        hklm.open_subkey(\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Explorer\\\\Accent\")?;\r\n    let accent_color: u32 = personalization.get_value(\"StartColorMenu\")?;\r\n    Ok(abgr_to_rgba(accent_color))\r\n}\r\n\r\nfn abgr_to_rgba(abgr: u32) -> Color {\r\n    let a = ((abgr >> 24) & 0xff) as u8;\r\n    let b = ((abgr >> 16) & 0xff) as u8;\r\n    let g = ((abgr >> 8) & 0xff) as u8;\r\n    let r = (abgr & 0xff) as u8;\r\n\r\n    Color::rgba_u8(r, g, b, a)\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    #[test]\r\n    fn test_get_accent_color() {\r\n        match super::get_accent_color() {\r\n            Ok(color) => println!(\"Accent color: {:?}\", color),\r\n            Err(e) => panic!(\"Error reading accent color: {}\", e),\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\templates\\patterns\\new_tool\\crates\\{{crate_name}}_tool_types\\src\\{{crate_name}}_tool_types.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse leafwing_input_manager::prelude::*;\r\nuse leafwing_input_manager::user_input::InputKind;\r\n\r\nuse bevy_inspector_egui::prelude::ReflectInspectorOptions;\r\nuse bevy_inspector_egui::InspectorOptions;\r\nuse cursor_hero_input::active_input_state_plugin::ActiveInput;\r\nuse cursor_hero_toolbelt_types::prelude::*;\r\n\r\n#[derive(Component, Reflect, Debug, InspectorOptions)]\r\n#[reflect(Component, InspectorOptions)]\r\npub struct {{crate_name_pascal}}Tool;\r\n\r\nimpl Default for {{crate_name_pascal}}Tool {\r\n    fn default() -> Self {\r\n        match ActiveInput::default() {\r\n            ActiveInput::MouseAndKeyboard => Self::default_mnk(),\r\n            ActiveInput::Gamepad => Self::default_gamepad(),\r\n        }\r\n    }\r\n}\r\nimpl {{crate_name_pascal}}Tool {\r\n    pub fn default_mnk() -> {{crate_name_pascal}}Tool {\r\n        {{crate_name_pascal}}Tool\r\n    }\r\n    pub fn default_gamepad() -> {{crate_name_pascal}}Tool {\r\n        {{crate_name_pascal}}Tool\r\n    }\r\n}\r\n\r\n#[derive(Actionlike, PartialEq, Eq, Clone, Copy, Hash, Debug, Reflect)]\r\npub enum {{crate_name_pascal}}ToolAction {\r\n    Use,\r\n}\r\n\r\nimpl {{crate_name_pascal}}ToolAction {\r\n    fn default_gamepad_binding(&self) -> UserInput {\r\n        match self {\r\n            Self::Use => GamepadButtonType::South.into(),\r\n        }\r\n    }\r\n\r\n    fn default_mkb_binding(&self) -> UserInput {\r\n        match self {\r\n            Self::Use => MouseButton::Left.into(),\r\n        }\r\n    }\r\n}\r\nimpl ToolAction for {{crate_name_pascal}}ToolAction {\r\n    fn default_input_map(_event: &PopulateToolbeltEvent) -> Option<InputMap<{{crate_name_pascal}}ToolAction>> {\r\n        let mut input_map = InputMap::default();\r\n\r\n        for variant in {{crate_name_pascal}}ToolAction::variants() {\r\n            input_map.insert(variant.default_mkb_binding(), variant);\r\n            input_map.insert(variant.default_gamepad_binding(), variant);\r\n        }\r\n        Some(input_map)\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\chat\\src\\chat_focus_exclusivity_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse cursor_hero_chat_types::prelude::*;\r\nuse cursor_hero_toolbelt_types::prelude::*;\r\n\r\npub struct ChatFocusExclusivityPlugin;\r\n\r\nimpl Plugin for ChatFocusExclusivityPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Update, handle_focus_changed);\r\n    }\r\n}\r\n\r\nfn handle_focus_changed(\r\n    mut commands: Commands,\r\n    mut events: EventReader<ChatInputEvent>,\r\n    mut tool_query: Query<&mut ChatTool, With<ChatTool>>,\r\n    toolbelt_query: Query<&Children, With<Toolbelt>>,\r\n    active_tool_query: Query<(), (With<ActiveTool>, Without<ChatTool>)>,\r\n) {\r\n    for event in events.read() {\r\n        let (ChatInputEvent::Focus {\r\n            tool_id,\r\n            toolbelt_id,\r\n            ..\r\n        }\r\n        | ChatInputEvent::Unfocus {\r\n            tool_id,\r\n            toolbelt_id,\r\n            ..\r\n        }) = event\r\n        else {\r\n            continue;\r\n        };\r\n        let focusing = matches!(event, ChatInputEvent::Focus { .. });\r\n\r\n        let Ok(tool) = tool_query.get_mut(*tool_id) else {\r\n            warn!(\"Tool {:?} not found for event {:?}\", tool_id, event);\r\n            continue;\r\n        };\r\n        let mut tool = tool;\r\n\r\n        let Ok(toolbelt) = toolbelt_query.get(*toolbelt_id) else {\r\n            warn!(\"Toolbelt {:?} not found for event {:?}\", toolbelt_id, event);\r\n            continue;\r\n        };\r\n        let toolbelt_children = toolbelt;\r\n        if focusing {\r\n            tool.focused = true;\r\n            for tool_id in toolbelt_children.iter() {\r\n                if active_tool_query.contains(*tool_id) {\r\n                    tool.tools_disabled_during_focus.insert(*tool_id);\r\n                    commands.entity(*tool_id).remove::<ActiveTool>();\r\n                    debug!(\"Disabled tool {:?} while focused\", tool_id);\r\n                }\r\n            }\r\n            debug!(\"Set tool {:?} as focused\", tool_id);\r\n        } else {\r\n            tool.focused = false;\r\n            for tool_id in tool.tools_disabled_during_focus.iter() {\r\n                match commands.get_entity(*tool_id) {\r\n                    Some(mut entity) => {\r\n                        entity.insert(ActiveTool);\r\n                    }\r\n                    None => {\r\n                        warn!(\"Error re-enabling tool {:?}, does not exist\", tool_id);\r\n                    }\r\n                }\r\n                debug!(\"Re-enabled tool {:?} after unfocusing\", tool_id);\r\n            }\r\n            tool.tools_disabled_during_focus.clear();\r\n            debug!(\"Set tool {:?} as unfocused\", tool_id);\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\floaty_nametag_types\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_floaty_nametag_types\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\todo.md\r\n\r\n````markdown\r\n# Current Priorities\r\n\r\n## Active\r\n\r\nUI tree egui improvements.\r\n- \"Copy drill ID\" button\r\n- UI element picture-in-picture\r\n- \"Copy rust expression\" which uses reflection to get the rust code to lift a property into a new variable\r\n\r\n\r\n## Up Next\r\n\r\n\r\n\r\n## Grab Bag\r\n\r\n- Game environment representation of VSCode window\r\n- Game environment representation of a kanban board, move todo list to it. Mapping to GitHub project board?\r\n- Game environment representation of todo list, make it structured\r\n- Game environment representation of Task Manager\r\n- Game environment representation of qBitTorrent\r\n- Game environment representation of VPN\r\n- Game environment representation of Edge\r\n- Game environment representation of Windows Explorer; notes and files searchable? brick-per-file representation in game world\r\n- Game environment representation of mpv\r\n- Game environment representation of SyncPlay\r\n- Game environment representation of Discord\r\n- Game environment representation of Windows Terminal\r\n- move click tool to its own crate pair\r\n- click toggle inspector for game objects\r\n- rename plugin refactoring action - rename file snake case, rename plugin pascal case\r\n- fix r3 position cursor at title bar\r\n- emoji text in world and in egui test\r\n- add world representation of all our cursor_hero crates where clicking them will toggle their log level to warn\r\n  - button to set all scope to warn and all open tabs to trace\r\n- rustdoc_json to create buttons to toggle log level for individual crates from within the game, persisting changes by modifying the log plugin init code \r\n- window swap: swap the position of the game window with the window under the cursor\r\n- switch LLM to one that is better for programming and knows about VS Code.\r\n- Keyboard Tool D-Pad Chords for Arbitrary Letters\r\n- Understand why I can't use the app to hit its own close button\r\n\r\n- home and end buttons in keyboard tool\r\n\r\n- data brick - screenshot tool creates physics object cube that contains the data\r\n  - only show hover preview and only process clicks for ui elements that match a known data provider pattern\r\n  - agent can manipulate and observe the cube\r\n  - cube observations do not map to the inner info, apps may be summarized in a few lines with hints about what subdata can be extracted\r\n  - UI databrick - contains information extracted from UI Automation\r\n  - File databrick - contains file contents and file handle info (path, size, etc)\r\n  - Chat databrick - contains chat history\r\n  - brick observations shouldn't be retained from previous messages, only keep chat history / purge brick history? if the agent can only observe the bricks around it, and we create a brick to represent chat history, then we can have the agent manage its own context window by summarizing and discarding bricks. problem: how large is the context window? we need indicators. Not contained within, but referenced to be gathered later. \r\n\r\n\r\n- context teleport tool\r\n  - tab to place marker\r\n  - mouse1 to teleport cube to marker\r\n\r\n- camera tool\r\n  - f1 - env 1\r\n  - f2 - env 2\r\n  - 1 - teleport object to 1\r\n  - 2 - teleport object to 2\r\n\r\n\r\n- start menu button\r\n- button creates a window with icon, title, decorations\r\n- taskbar lists windows\r\n- \r\n- update tool plugin template\r\n\r\n- tree structure component that can render a tree structure following the flat-but-annotated style of the inspect.exe tree of the vscode file explorer\r\n- agent memory reset (gun?)\r\n  - points towards pointer\r\n  - projectile shoot\r\n  - sfx\r\n  - projectile hit\r\n  - sfx\r\n  - hitreg wipe memory\r\n- name labels above characters\r\n- character positions in observation\r\n  - snapshot at time for observation, or record ongoing activity?\r\n  - \"X walked by, 25s ago\"\r\n  - \"Y stopped moving at [12.0, 255.0], 5s ago\"\r\n\r\n- sfx when service comes online\r\n- better prompt history\r\n- vscode buffer observations\r\n- Onboarder startup button\r\n- Screen pause toggle button\r\n- add \"thinking\" bubble above agent head when request in flight\r\n\r\n- customizable launch params for the wt invocation to launch ollama and stuff in case people have different WSL distros than ubuntu\r\n  - restart memory, edit in game\r\n- ollama server documentation button to open the github\r\n- character selection room, displaying all the variants of the character using a closet that you scroll through the hangers that describe the situation in which each sprite is used, exploded view to show all variants / the sprite sheet\r\n- run animation\r\n\r\n- performance profiling (so I can close the browser tab I have open for the rust metrics lib)\r\n- reduce background CPU usage from 22% \ud83d\ude31 https://learn.microsoft.com/en-us/windows-hardware/test/wpt/introduction-to-wpr\r\n\r\n- switcher wheel to collect all switcher tools for predictable navigation\r\n  - gamepad rumble on hover\r\n  - sound effect on hover tool\r\n- fullscreen tool binding f11 to fullscreen toggle\r\n- set clippy rule to flag `unwrap` and `expect` usage\r\n- post to openai discord use-cases channel https://discord.com/channels/974519864045756446/1155775326253756456\r\n  - tag @abdubs (Alex)\r\n- window switcher tool; window wheel -> focus, teleport\r\n- Github releases in world\r\n- File browser in world\r\n- Voice input tool\r\n  - Push to talk\r\n  - Push to toggle talk\r\n  - Insert period\r\n  - Insert space\r\n  - Hit enter\r\n\r\n- interpreter agent that acts as \"middleware\" that will process user speech transcription to clean it up typos and other errors that can decrease model performance before it gets included in main agent observations\r\n- track recently played sounds and empower the user to adjust the volume of individual sounds and future sounds of the same class\r\n- sprint tool scales scroll speed\r\n\r\n- couple click tool with window/screen mouse position tool\r\n- make overlay logic stop when inspection tool disabled\r\n\r\n- add version number to binary as part of build\r\n\r\n- show tools which have conflicting keys in red\r\n- tool to focus the game window and maximize it on the monitors with dpad\r\n\r\n- jump tool - aimlock with right stick to jump to targets at varying distances\r\n\r\n- new tool tool\r\n  - bind: type \"plug\"\r\n  - bind: press tab\r\n  - bind: rename symbol refactor hotkey (Shift+F6)\r\n  - bind: voice2text\r\n  - bind: enter\r\n- new file tool\r\n  - bind: left click (on folder -> new file)\r\n  - bind: voice prompt with instructions on file name preference, include txt of tree output next to the cursor in the vscode file explorer\r\n  - bind: hit enter\r\n\r\n\r\nheuristics!\r\n\r\nadd a binding to the voice tool for hitting the enter button.Add a binding.for the Ctrl-S hotkey.add a hotkey to thefor inserting a new line.Add a camera tool to own the hotkey for fire.following the character.- tool selection wheel show on rstick click, left stick to pick item in the wheel - is the toolbelt a tool?\r\n- teleport tool - rstick in maps left stick to full screen coords. Full left stick places cursor as far left, across all screens, as possible\r\n- find way to overlay on top of other windows without drawing the screens\r\n- text buffer - a change-listenable history-queryable place to store text\r\n- d-pad keyboard navigation tool , arrow keys, wasd, hjkl\r\n- clipboard tool - keybind to push text buffer to system clipboard, keybind to pull from system clipboard to text buffer, keybind to send ctrl+v input\r\n- voice2text tool - hold to talk to transcribe your voice into the text buffer\r\n- annotation tool - keybind to append to a file (timestamp, cursor pos, element under cursor persistent id, text buffer)\r\n- cursor tool - mapping to shift to enable shift-clicking, mapping control to enable control clicking.Combinable with shift.\r\n- summarize tool - summarize the clicked element. north/south: summary length adjust. east/west: level of detail adjust\r\n- dump tool - poop emoji icon, dumps context of the current timestep to the text buffer. keybind to adjust detail\r\n- zoom tool - right trigger to control zoom\r\n- type tool - send keyboard inputs according to the text buffer\r\n- d-pad quick toggle tool system\r\n- timestamp marking tool - save to file with note\r\n- describe hovered element tool\r\n- llm inference for arbitrary string payloads\r\n- rebind hotkey tool that analyzes project for keybinding defaults in code and edits the code in place to change the default\r\n- todo tool that reads top 3 todo.md entries and top 3 git log into LLM to suggest the next thing to work on\r\n- TTS (glados)\r\n- more real time voice 2 text\r\n- indicator out of bounds when OBS is not recording / status lights for OBS\r\n- detect periods of waiting and replace progress spinners / cargo build logs / chatgpt still typing a response with a video from my watch later, my move in a chess game, a chess puzzle, an email -- predict the length of the time spinning to pick a thing to that will take that amount of time, \r\n- point at program and open the source code - mapping from program to disk location\r\n- automate bevy cloning and dependency update to point at local clones of the repos\r\n\r\n# use case\r\n\r\nselect multiple files from vscode, tool read the contents of those files and format in markdown code blocks including file path \r\n\r\n```main.rs\r\npub mod other;\r\n\r\nfn main() {\r\n    println!(\"hello world\");\r\n}\r\n```\r\n\r\n```other.rs\r\npub fn other() {\r\n    println!(\"other\");\r\n}\r\n```\r\n\r\nto be combined in non-conflicting keys\r\n\r\n- left click\r\n- enter\r\n- voice2text\r\n- copy to clipboard\r\n- append to selection\r\n- remove from selection\r\n\r\n# use case - slider hub\r\n\r\nvolume slider hub\r\n\r\nMaster slider\r\nAudio mixer slider per app\r\nApp slider - game master volume slider, music/sfx slider; youtube video slider, mpv volume slider\r\ncontrol all from single location - can use browser extension to control youtube without bringing the video to the front\r\n\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\window_position\\src\\lib.rs\r\n\r\n````rust\r\npub mod window_position_command_plugin;\r\npub mod window_position_loadout_switcher_tool_plugin;\r\npub mod window_position_plugin;\r\npub mod window_position_tool_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::window_position_plugin::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\window_swap_tool\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_window_swap_tool\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\ncursor_hero_window_swap_tool_types = { workspace = true }\r\ncursor_hero_toolbelt_types = { workspace = true }\r\ncursor_hero_tools = { workspace = true }\r\nleafwing-input-manager = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\winutils\\src\\win_errors.rs\r\n\r\n````rust\r\nuse std::rc::Rc;\r\nuse std::string::FromUtf16Error;\r\nuse widestring::error::ContainsNul;\r\nuse windows::Win32::Foundation::BOOL;\r\n\r\n#[derive(Debug, Clone)]\r\npub enum Error {\r\n    Windows(windows::core::Error),\r\n    WideString(ContainsNul<u16>),\r\n    FromUtf16Error,\r\n    Described(Rc<Error>, String),\r\n    ImageContainerNotBigEnough,\r\n    Other(Rc<dyn std::error::Error>),\r\n}\r\nimpl std::fmt::Display for Error {\r\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\r\n        match self {\r\n            Error::Windows(e) => write!(f, \"Windows error: {}\", e.message()),\r\n            Error::WideString(e) => write!(f, \"Wide string error: {}\", e),\r\n            Error::FromUtf16Error => write!(f, \"FromUtf16Error\"),\r\n            Error::Described(e, description) => write!(f, \"{}: {}\", e, description),\r\n            Error::ImageContainerNotBigEnough => write!(f, \"Image container not big enough\"),\r\n            Error::Other(e) => write!(f, \"(other) {}\", e),\r\n        }\r\n    }\r\n}\r\nimpl std::error::Error for Error {}\r\nimpl Error {\r\n    pub fn from_win32() -> Self {\r\n        Error::Windows(windows::core::Error::from_win32())\r\n    }\r\n    pub fn with_description(self, description: String) -> Self {\r\n        Error::Described(Rc::new(self), description)\r\n    }\r\n}\r\nimpl From<windows::core::Error> for Error {\r\n    fn from(e: windows::core::Error) -> Self {\r\n        Error::Windows(e)\r\n    }\r\n}\r\nimpl From<ContainsNul<u16>> for Error {\r\n    fn from(e: ContainsNul<u16>) -> Self {\r\n        Error::WideString(e)\r\n    }\r\n}\r\nimpl From<FromUtf16Error> for Error {\r\n    fn from(_e: FromUtf16Error) -> Self {\r\n        Error::FromUtf16Error\r\n    }\r\n}\r\n\r\npub type Result<T> = std::result::Result<T, Error>;\r\n\r\npub trait WithDescription<T> {\r\n    fn with_description(self, description: String) -> Result<T>;\r\n}\r\nimpl<T> WithDescription<T> for windows::core::Result<T> {\r\n    fn with_description(self, description: String) -> Result<T> {\r\n        self.map_err(|e| Error::Windows(e).with_description(description))\r\n    }\r\n}\r\n\r\npub trait OkWithDescription<T> {\r\n    fn ok_with_description(self, description: String) -> Result<T>;\r\n}\r\nimpl OkWithDescription<()> for BOOL {\r\n    fn ok_with_description(self, description: String) -> Result<()> {\r\n        self.ok()\r\n            .map_err(|e| Error::Windows(e).with_description(description))\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\templates\\patterns\\new_plugin_with_types\\crates\\plugins\\Cargo.toml\r\n\r\n````toml\r\n{{before_first_plugins_dependency}}\r\ncursor_hero_{{crate_name}} = { workspace = true }\r\ncursor_hero_{{crate_name}}_types = { workspace = true }\r\n{{first_plugins_dependency_onwards}}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\toolbelt_types\\src\\toolbelt_types.rs\r\n\r\n````rust\r\nuse std::fmt::Debug;\r\n\r\nuse bevy::prelude::*;\r\nuse bevy::utils::HashMap;\r\nuse leafwing_input_manager::prelude::*;\r\nuse leafwing_input_manager::user_input::InputKind;\r\nuse serde::Deserialize;\r\nuse serde::Serialize;\r\n\r\n#[derive(Actionlike, PartialEq, Eq, Clone, Copy, Hash, Debug, Reflect)]\r\npub enum ToolbeltAction {\r\n    Show,\r\n}\r\n\r\nimpl ToolbeltAction {\r\n    fn default_mkb_binding(&self) -> UserInput {\r\n        match self {\r\n            Self::Show => UserInput::Single(InputKind::Keyboard(KeyCode::AltLeft)),\r\n        }\r\n    }\r\n    fn default_gamepad_binding(&self) -> UserInput {\r\n        match self {\r\n            Self::Show => GamepadButtonType::RightTrigger2.into(),\r\n        }\r\n    }\r\n\r\n    // TODO: convert toolbelt to normal tool structure\r\n    pub fn default_input_map() -> InputMap<ToolbeltAction> {\r\n        let mut input_map = InputMap::default();\r\n\r\n        for variant in ToolbeltAction::variants() {\r\n            input_map.insert(variant.default_mkb_binding(), variant);\r\n            input_map.insert(variant.default_gamepad_binding(), variant);\r\n        }\r\n        input_map\r\n    }\r\n}\r\n\r\n#[derive(Component, Reflect, Clone, Copy, Debug, Serialize, Deserialize, PartialEq)]\r\npub struct Toolbelt {\r\n    pub open: bool,\r\n    pub loadout: ToolbeltLoadout,\r\n    pub layout: ToolbeltLayout,\r\n}\r\nimpl Default for Toolbelt {\r\n    fn default() -> Self {\r\n        Self {\r\n            open: false,\r\n            loadout: ToolbeltLoadout::Default,\r\n            layout: ToolbeltLoadout::Default.layout(),\r\n        }\r\n    }\r\n}\r\n\r\n#[derive(Bundle)]\r\npub struct ToolbeltBundle {\r\n    pub circle: Wheel,\r\n    pub spatial: SpatialBundle,\r\n    pub name: Name,\r\n    pub input_manager: InputManagerBundle<ToolbeltAction>,\r\n    pub toolbelt: Toolbelt,\r\n}\r\nimpl Default for ToolbeltBundle {\r\n    fn default() -> Self {\r\n        Self {\r\n            circle: Wheel::default(),\r\n            spatial: SpatialBundle {\r\n                visibility: Visibility::Hidden,\r\n                ..default()\r\n            },\r\n            name: Name::new(\"Toolbelt\"),\r\n            input_manager: InputManagerBundle::<ToolbeltAction> {\r\n                input_map: ToolbeltAction::default_input_map(),\r\n                ..Default::default()\r\n            },\r\n            toolbelt: Toolbelt::default(),\r\n        }\r\n    }\r\n}\r\n\r\n#[derive(Reflect, Clone, Copy, Debug, Default, Eq, PartialEq, Serialize, Deserialize)]\r\npub enum ToolbeltLoadout {\r\n    #[default]\r\n    Default,\r\n    Inspector,\r\n    Taskbar,\r\n    Keyboard,\r\n    Agent,\r\n    Chat,\r\n    WindowPosition,\r\n}\r\nimpl ToolbeltLoadout {\r\n    pub fn layout(&self) -> ToolbeltLayout {\r\n        match self {\r\n            Self::Taskbar => ToolbeltLayout::Taskbar {\r\n                wheel: Wheel::default(),\r\n            },\r\n            _ => ToolbeltLayout::default(),\r\n        }\r\n    }\r\n}\r\n\r\n#[derive(Reflect, Clone, Copy, Debug, Serialize, Deserialize, PartialEq)]\r\npub enum ToolbeltLayout {\r\n    Circle { wheel: Wheel },\r\n    Taskbar { wheel: Wheel },\r\n}\r\nimpl Default for ToolbeltLayout {\r\n    fn default() -> Self {\r\n        Self::Circle {\r\n            wheel: Wheel::default(),\r\n        }\r\n    }\r\n}\r\n\r\n#[derive(Event, Debug, Reflect, Clone, Copy)]\r\npub struct ToolbeltPopulateEvent {\r\n    pub id: Entity,\r\n    pub loadout: ToolbeltLoadout,\r\n}\r\n\r\n#[derive(Event, Debug, Reflect)]\r\npub enum ToolbeltOpeningEvent {\r\n    Opened { toolbelt_id: Entity },\r\n    Closed { toolbelt_id: Entity },\r\n}\r\n\r\n#[derive(Component, Reflect, Clone, Copy, Debug, Serialize, Deserialize, PartialEq)]\r\npub struct Wheel {\r\n    pub radius: f32,\r\n    pub radius_start: f32,\r\n    pub radius_end: f32,\r\n    pub radius_end_bonus_per_tool_after_8: f32,\r\n    pub spin: f32,\r\n    pub spin_start: f32,\r\n    pub spin_end: f32,\r\n    pub scale: f32,\r\n    pub scale_start: f32,\r\n    pub scale_end: f32,\r\n    pub alpha: f32,\r\n    pub alpha_start: f32,\r\n    pub alpha_end: f32,\r\n    pub open: bool,\r\n}\r\nimpl Default for Wheel {\r\n    fn default() -> Self {\r\n        Self {\r\n            radius: 200.0,\r\n            // min_radius: 50.0,\r\n            radius_start: 200.0,\r\n            radius_end: 200.0,\r\n            radius_end_bonus_per_tool_after_8: 10.0,\r\n            spin: 0.0,\r\n            spin_start: 300.0,\r\n            spin_end: 360.0,\r\n            scale: 1.0,\r\n            scale_start: 0.5,\r\n            scale_end: 1.0,\r\n            alpha: 0.0,\r\n            alpha_start: 0.0,\r\n            alpha_end: 1.0,\r\n            open: false,\r\n        }\r\n    }\r\n}\r\n\r\n#[derive(Component, Reflect, Clone, Debug)]\r\npub struct Tool {\r\n    pub name: String,\r\n    pub description: String,\r\n    pub actions: HashMap<String, Vec<UserInput>>,\r\n    pub texture: Handle<Image>,\r\n}\r\n\r\n#[derive(Component, Reflect, Clone, Copy, Debug)]\r\npub struct ToolHelpTrigger;\r\n\r\npub trait ToolAction: Actionlike {\r\n    fn default_input_map(_event: &ToolbeltPopulateEvent) -> Option<InputMap<Self>>;\r\n    fn with_defaults<G, K>(gamepad: G, keyboard: K) -> InputMap<Self>\r\n    where\r\n        G: Fn(&Self) -> UserInput,\r\n        K: Fn(&Self) -> UserInput,\r\n        Self: Clone,\r\n    {\r\n        let mut input_map = InputMap::default();\r\n\r\n        for variant in Self::variants() {\r\n            let g = gamepad(&variant);\r\n            let k = keyboard(&variant);\r\n            input_map.insert(g, variant.clone());\r\n            input_map.insert(k, variant);\r\n        }\r\n        input_map\r\n    }\r\n}\r\n\r\n#[derive(Component, Reflect, Debug, PartialEq, Eq)]\r\npub struct ActiveTool;\r\n\r\n#[derive(Event, Debug, Reflect)]\r\npub enum ToolActivationEvent {\r\n    Activate(Entity),\r\n    Deactivate(Entity),\r\n}\r\n\r\n#[derive(Component, Reflect, Debug)]\r\npub struct ToolHelp {\r\n    pub timer: Timer,\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_ui\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\ncursor_hero_camera = { workspace = true }\r\ncursor_hero_character_types = { workspace = true }\r\ncursor_hero_version = { workspace = true }\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\data\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_data\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\tools\\src\\zoom_tool.rs\r\n\r\n````rust\r\nuse crate::prelude::*;\r\nuse bevy::prelude::*;\r\nuse bevy_inspector_egui::prelude::ReflectInspectorOptions;\r\nuse bevy_inspector_egui::InspectorOptions;\r\nuse cursor_hero_camera::camera_plugin::MainCamera;\r\nuse cursor_hero_character_types::prelude::*;\r\nuse cursor_hero_math::prelude::Lerp;\r\nuse cursor_hero_sprint_tool_types::sprint_tool_types_plugin::SprintEvent;\r\nuse cursor_hero_toolbelt_types::prelude::*;\r\nuse itertools::Itertools;\r\nuse leafwing_input_manager::prelude::*;\r\npub struct ZoomToolPlugin;\r\n\r\nimpl Plugin for ZoomToolPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<ZoomTool>();\r\n        app.add_plugins(InputManagerPlugin::<ZoomToolAction>::default());\r\n        app.add_systems(\r\n            Update,\r\n            (toolbelt_events, handle_input, handle_sprint_events),\r\n        );\r\n    }\r\n}\r\n\r\n#[derive(Component, InspectorOptions, Debug, Reflect)]\r\n#[reflect(Component, InspectorOptions)]\r\nstruct ZoomTool {\r\n    #[inspector(min = 0.0)]\r\n    speed: f32,\r\n    #[inspector(min = 0.0)]\r\n    default_speed: f32,\r\n    #[inspector(min = 0.0)]\r\n    sprint_speed: f32,\r\n    #[inspector(min = 0.0001, max = 10000.0)]\r\n    scale_min: f32,\r\n    #[inspector(min = 0.0001, max = 10000.0)]\r\n    scale_max: f32,\r\n}\r\nimpl Default for ZoomTool {\r\n    fn default() -> Self {\r\n        Self {\r\n            speed: 1.0,\r\n            default_speed: 1.0,\r\n            sprint_speed: 50.0,\r\n            scale_min: 0.001,\r\n            scale_max: 10.0,\r\n        }\r\n    }\r\n}\r\nfn toolbelt_events(\r\n    mut commands: Commands,\r\n    asset_server: Res<AssetServer>,\r\n    mut reader: EventReader<ToolbeltPopulateEvent>,\r\n) {\r\n    for event in reader.read() {\r\n        let (ToolbeltLoadout::Default | ToolbeltLoadout::Inspector) = event.loadout else {\r\n            continue;\r\n        };\r\n        ToolSpawnConfig::<_, ZoomToolAction>::new(ZoomTool::default(), event.id, event)\r\n            .with_src_path(file!().into())\r\n            .guess_name(file!())\r\n            .guess_image(file!(), &asset_server, \"png\")\r\n            .with_description(\"Send scroll events\")\r\n            .spawn(&mut commands);\r\n    }\r\n}\r\n\r\n#[derive(Actionlike, PartialEq, Eq, Clone, Copy, Hash, Debug, Reflect)]\r\nenum ZoomToolAction {\r\n    Out,\r\n    In,\r\n}\r\n\r\nimpl ZoomToolAction {\r\n    fn default_gamepad_binding(&self) -> UserInput {\r\n        match self {\r\n            Self::Out => GamepadButtonType::DPadLeft.into(),\r\n            Self::In => GamepadButtonType::DPadRight.into(),\r\n        }\r\n    }\r\n\r\n    fn default_mkb_binding(&self) -> UserInput {\r\n        match self {\r\n            Self::Out => KeyCode::Home.into(),\r\n            Self::In => KeyCode::End.into(),\r\n        }\r\n    }\r\n}\r\nimpl ToolAction for ZoomToolAction {\r\n    fn default_input_map(_event: &ToolbeltPopulateEvent) -> Option<InputMap<ZoomToolAction>> {\r\n        let mut input_map = InputMap::default();\r\n\r\n        for variant in ZoomToolAction::variants() {\r\n            input_map.insert(variant.default_mkb_binding(), variant);\r\n            input_map.insert(variant.default_gamepad_binding(), variant);\r\n        }\r\n        Some(input_map)\r\n    }\r\n}\r\n\r\nfn handle_input(\r\n    tool_query: Query<(&ActionState<ZoomToolAction>, &ZoomTool), With<ActiveTool>>,\r\n    mut camera_query: Query<&mut Transform, With<MainCamera>>,\r\n    time: Res<Time>,\r\n) {\r\n    for zoom_tool in tool_query.iter() {\r\n        let (tool_actions, tool) = zoom_tool;\r\n        let camera = camera_query.single_mut();\r\n        let mut camera_transform = camera;\r\n        if tool_actions.pressed(ZoomToolAction::Out) {\r\n            let mut scale = camera_transform.scale;\r\n            let diff = 0.1 * time.delta_seconds() * tool.speed;\r\n            scale *= Vec3::splat(1.0) + Vec2::splat(diff).extend(0.0);\r\n            debug!(\r\n                \"scale_min: {}, scale_max: {}\",\r\n                tool.scale_min, tool.scale_max\r\n            );\r\n            scale = scale.clamp(Vec3::splat(tool.scale_min), Vec3::splat(tool.scale_max));\r\n            camera_transform.scale = scale;\r\n            if tool_actions.just_pressed(ZoomToolAction::Out) {\r\n                info!(\"Zooming out\");\r\n            }\r\n        }\r\n        if tool_actions.pressed(ZoomToolAction::In) {\r\n            let mut scale = camera_transform.scale;\r\n            let diff = 0.1 * time.delta_seconds() * tool.speed;\r\n            scale *= Vec3::splat(1.0) - Vec2::splat(diff).extend(0.0);\r\n            debug!(\r\n                \"scale_min: {}, scale_max: {}\",\r\n                tool.scale_min, tool.scale_max\r\n            );\r\n            scale = scale.clamp(Vec3::splat(tool.scale_min), Vec3::splat(tool.scale_max));\r\n            camera_transform.scale = scale;\r\n            if tool_actions.just_pressed(ZoomToolAction::In) {\r\n                info!(\"Zooming in\");\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfn handle_sprint_events(\r\n    mut sprint_events: EventReader<SprintEvent>,\r\n    character_query: Query<&Children, With<Character>>,\r\n    toolbelt_query: Query<&Children, With<Toolbelt>>,\r\n    mut tool_query: Query<&mut ZoomTool>,\r\n) {\r\n    for event in sprint_events.read() {\r\n        let character_id = match event {\r\n            SprintEvent::Active { character_id, .. } => character_id,\r\n            SprintEvent::Stop { character_id } => character_id,\r\n        };\r\n        let Ok(character) = character_query.get(*character_id) else {\r\n            warn!(\"Character {:?} does not exist\", character_id);\r\n            continue;\r\n        };\r\n        let character_kids = character;\r\n        let tool_ids = character_kids\r\n            .iter()\r\n            .filter_map(|kid| toolbelt_query.get(*kid).ok())\r\n            .flat_map(|toolbelt| toolbelt.iter())\r\n            .filter(|kid| tool_query.contains(**kid))\r\n            .cloned()\r\n            .collect_vec();\r\n\r\n        match event {\r\n            SprintEvent::Active { throttle, .. } => {\r\n                let mut iter = tool_query.iter_many_mut(&tool_ids);\r\n                while let Some(mut tool) = iter.fetch_next() {\r\n                    tool.speed = (tool.default_speed, tool.sprint_speed).lerp(*throttle);\r\n                }\r\n            }\r\n            SprintEvent::Stop { .. } => {\r\n                let mut iter = tool_query.iter_many_mut(&tool_ids);\r\n                while let Some(mut tool) = iter.fetch_next() {\r\n                    tool.speed = tool.default_speed;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\start_menu_types\\src\\start_menu_types.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n\r\n#[derive(Component, Debug, Reflect)]\r\npub struct StartMenuButton;\r\n\r\n#[derive(Component, Debug, Reflect)]\r\npub struct StartMenu;\r\n\r\n#[derive(Event, Debug, Reflect)]\r\npub enum StartMenuEvent {\r\n    Open { start_menu_button_id: Entity },\r\n    Close { start_menu_button_id: Entity },\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\fullscreen_tool_types\\src\\fullscreen_tool_types_plugin.rs\r\n\r\n````rust\r\nuse crate::prelude::*;\r\nuse bevy::prelude::*;\r\n\r\npub struct FullscreenToolTypesPlugin;\r\n\r\nimpl Plugin for FullscreenToolTypesPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<FullscreenTool>();\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\plugins\\src\\inspect_launch_mode_plugin.rs\r\n\r\n````rust\r\nuse bevy::input::common_conditions::input_toggle_active;\r\nuse bevy::log::LogPlugin;\r\nuse bevy::prelude::*;\r\nuse bevy_inspector_egui::quick::WorldInspectorPlugin;\r\nuse cursor_hero_camera::camera_plugin::CameraPlugin;\r\nuse cursor_hero_memory::prelude::MemoryPlugin;\r\nuse cursor_hero_memory::primary_window_memory_plugin::restore_window;\r\nuse cursor_hero_memory_types::prelude::MemoryConfig;\r\nuse cursor_hero_memory_types::prelude::MemoryPluginBuildConfig;\r\nuse cursor_hero_memory_types::prelude::MemoryTypesPlugin;\r\nuse cursor_hero_observation_types::observation_types_plugin::ObservationTypesPlugin;\r\nuse cursor_hero_ui_automation::prelude::UiAutomationPlugin;\r\nuse cursor_hero_ui_automation::prelude::UiAutomationTypesPlugin;\r\nuse cursor_hero_ui_watcher::ui_watcher_plugin::UiWatcherPlugin;\r\nuse cursor_hero_ui_watcher_types::ui_watcher_types_plugin::UiWatcherTypesPlugin;\r\nuse cursor_hero_version::version_plugin::Version;\r\npub struct InspectLaunchModePlugin;\r\n\r\nimpl Plugin for InspectLaunchModePlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_plugins(MemoryTypesPlugin);\r\n\r\n        let memory_config = MemoryConfig {\r\n            save_dir: \"Cursor Hero Memory (inspect mode)\".to_string(),\r\n        };\r\n        app.add_plugins(MemoryPlugin {\r\n            config: memory_config.clone(),\r\n            build_config: MemoryPluginBuildConfig {\r\n                primary_window_memory_enabled: true,\r\n                ..default()\r\n            },\r\n        });\r\n        app.add_plugins(ObservationTypesPlugin);\r\n        app.add_plugins(UiWatcherTypesPlugin);\r\n        app.add_plugins(UiWatcherPlugin);\r\n        app.add_plugins(UiAutomationTypesPlugin);\r\n        app.add_plugins(UiAutomationPlugin);\r\n        app.add_plugins(CameraPlugin);\r\n\r\n        let version = match app.world.get_resource::<Version>() {\r\n            Some(version) => version.0.clone(),\r\n            None => {\r\n                warn!(\"Version resource not found\");\r\n                \"Unknown\".to_string()\r\n            }\r\n        };\r\n        let mut window = Window {\r\n            title: format!(\"Cursor Hero Inspector v{}\", version),\r\n            resizable: true,\r\n            ..default()\r\n        };\r\n        if let Err(e) = restore_window(&memory_config, &mut window) {\r\n            error!(\"Failed to restore window: {:?}\", e);\r\n        }\r\n        app.add_plugins(\r\n            DefaultPlugins\r\n                .set(LogPlugin {\r\n                    level: bevy::log::Level::DEBUG,\r\n                    filter: \"\r\ninfo,\r\nwgpu_core=warn,\r\nwgpu_hal=warn,\r\nui_hover_example=trace,\r\ncursor_hero_worker=debug,\r\n\"\r\n                    .replace('\\n', \"\")\r\n                    .trim()\r\n                    .into(),\r\n                })\r\n                .set(WindowPlugin {\r\n                    primary_window: Some(window),\r\n                    ..default()\r\n                })\r\n                .build(),\r\n        );\r\n        // app.add_plugins(WorkerPlugin {\r\n        //     config: WorkerConfig::<ThreadboundUISnapshotMessage, GameboundUISnapshotMessage> {\r\n        //         name: \"ui_hover\".to_string(),\r\n        //         is_ui_automation_thread: true,\r\n        //         handle_threadbound_message: handle_threadbound_message,\r\n        //         handle_threadbound_message_error_handler: handle_threadbound_message_error_handler,\r\n        //         ..default()\r\n        //     },\r\n        // });\r\n        app.add_plugins(\r\n            WorldInspectorPlugin::default().run_if(input_toggle_active(false, KeyCode::Grave)),\r\n        );\r\n        app.insert_resource(ClearColor(Color::rgb(0.992, 0.714, 0.69)));\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\level_bounds\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_level_bounds\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\ncursor_hero_character_types = { workspace = true }\r\ncursor_hero_environment_types = { workspace = true }\r\nbevy = { workspace = true }\r\nbevy_xpbd_2d = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ollama_types\\src\\ollama_types_plugin.rs\r\n\r\n````rust\r\nuse crate::prelude::*;\r\nuse bevy::prelude::*;\r\n\r\npub struct OllamaTypesPlugin;\r\n\r\nimpl Plugin for OllamaTypesPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<OllamaStatus>();\r\n        app.register_type::<OllamaStatusButton>();\r\n        app.register_type::<OllamaStatusButtonVisualState>();\r\n        app.register_type::<OllamaStatusEvent>();\r\n        app.add_event::<OllamaStatusEvent>();\r\n\r\n        app.register_type::<OllamaPingEvent>();\r\n        app.add_event::<OllamaPingEvent>();\r\n\r\n        app.register_type::<OllamaTerminalButton>();\r\n        app.register_type::<OllamaTerminalButtonVisualState>();\r\n        app.register_type::<OllamaTerminalEvent>();\r\n        app.add_event::<OllamaTerminalEvent>();\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\character_types\\src\\lib.rs\r\n\r\n````rust\r\npub mod character_types;\r\npub mod character_types_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::character_types::*;\r\n    pub use crate::character_types_plugin::CharacterTypesPlugin;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\window_swap_tool_types\\src\\window_swap_tool_types.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse leafwing_input_manager::prelude::*;\r\n\r\nuse bevy_inspector_egui::prelude::ReflectInspectorOptions;\r\nuse bevy_inspector_egui::InspectorOptions;\r\nuse cursor_hero_input::active_input_state_plugin::InputMethod;\r\nuse cursor_hero_toolbelt_types::prelude::*;\r\n\r\n#[derive(Component, Reflect, Debug, InspectorOptions)]\r\n#[reflect(Component, InspectorOptions)]\r\npub struct WindowSwapTool;\r\n\r\nimpl Default for WindowSwapTool {\r\n    fn default() -> Self {\r\n        match InputMethod::default() {\r\n            InputMethod::MouseAndKeyboard | InputMethod::Keyboard => Self::default_mnk(),\r\n            InputMethod::Gamepad => Self::default_gamepad(),\r\n        }\r\n    }\r\n}\r\nimpl WindowSwapTool {\r\n    pub fn default_mnk() -> WindowSwapTool {\r\n        WindowSwapTool\r\n    }\r\n    pub fn default_gamepad() -> WindowSwapTool {\r\n        WindowSwapTool\r\n    }\r\n}\r\n\r\n#[derive(Actionlike, PartialEq, Eq, Clone, Copy, Hash, Debug, Reflect)]\r\npub enum WindowSwapToolAction {\r\n    Use,\r\n}\r\n\r\nimpl WindowSwapToolAction {\r\n    fn default_gamepad_binding(&self) -> UserInput {\r\n        match self {\r\n            Self::Use => GamepadButtonType::North.into(),\r\n        }\r\n    }\r\n\r\n    fn default_mkb_binding(&self) -> UserInput {\r\n        match self {\r\n            Self::Use => KeyCode::Q.into(),\r\n        }\r\n    }\r\n}\r\nimpl ToolAction for WindowSwapToolAction {\r\n    fn default_input_map(_event: &ToolbeltPopulateEvent) -> Option<InputMap<WindowSwapToolAction>> {\r\n        let mut input_map = InputMap::default();\r\n\r\n        for variant in WindowSwapToolAction::variants() {\r\n            input_map.insert(variant.default_mkb_binding(), variant);\r\n            input_map.insert(variant.default_gamepad_binding(), variant);\r\n        }\r\n        Some(input_map)\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\winutils\\src\\lib.rs\r\n\r\n````rust\r\n#![feature(let_chains)]\r\n\r\nuse bevy::math::IRect;\r\n\r\npub mod win_colors;\r\npub mod win_cursor;\r\npub mod win_errors;\r\npub mod win_events;\r\npub mod win_icons;\r\npub mod win_keyboard;\r\npub mod win_mouse;\r\npub mod win_process;\r\npub mod win_screen_capture;\r\npub mod win_wallpaper;\r\npub mod win_window;\r\n\r\npub trait ToBevyIRect {\r\n    fn to_bevy_irect(&self) -> IRect;\r\n}\r\n\r\npub use widestring;\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\use cases\\asset picking.md\r\n\r\n````markdown\r\nI have some folders in my documents containing game sound effects.\r\nIt's a pain to preview them in windows.\r\n\r\nI should make an environment that lets me browse the files and preview them by walking over them.\r\nHit a to play the sound again.\r\n\r\nSend the sound to the game assets folder.\r\nOpen the sound in audacity.\r\nInternal sound editor?\r\nSFXR integration?\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ollama\\src\\ollama.rs\r\n\r\n````rust\r\nuse cursor_hero_inference_types::inference_types::TextInferenceOptions;\r\nuse cursor_hero_ollama_types::ollama_types::OllamaStatus;\r\nuse reqwest::Client;\r\nuse std::error::Error;\r\n\r\nuse serde::Deserialize;\r\n\r\n#[derive(Debug, Deserialize)]\r\nstruct ApiResponse {\r\n    response: String,\r\n}\r\n\r\npub async fn generate(\r\n    prompt: &str,\r\n    options: Option<TextInferenceOptions>,\r\n) -> Result<String, Box<dyn Error>> {\r\n    let mut payload = serde_json::json!({\r\n        \"model\": \"whatevs\",\r\n        \"prompt\": prompt,\r\n        \"stream\": false\r\n    });\r\n    if let Some(options) = options {\r\n        // create empty object\r\n        let mut options_json = serde_json::json!({});\r\n\r\n        if let Some(num_predict) = options.num_predict {\r\n            options_json[\"num_predict\"] = serde_json::json!(num_predict);\r\n        }\r\n\r\n        if let Some(stop) = options.stop {\r\n            options_json[\"stop\"] = serde_json::json!(stop);\r\n        }\r\n\r\n        payload[\"options\"] = options_json;\r\n    }\r\n\r\n    let client = Client::new();\r\n\r\n    let res = client\r\n        .post(\"http://localhost:11434/api/generate\")\r\n        .json(&payload)\r\n        .send()\r\n        .await?;\r\n\r\n    if res.status().is_success() {\r\n        let api_response = res.json::<ApiResponse>().await?;\r\n        let mut text = api_response.response.as_str();\r\n        text = text.trim_end_matches(\"<dummy32000>\");\r\n        text = text.trim();\r\n        Ok(text.to_string())\r\n    } else {\r\n        let status = res.status();\r\n        let body = res.text().await?;\r\n        Err(Box::new(std::io::Error::new(\r\n            std::io::ErrorKind::Other,\r\n            format!(\"Failed to call API. Status: {} Body: {}\", status, body),\r\n        )))\r\n    }\r\n}\r\n\r\npub async fn get_status() -> Result<OllamaStatus, Box<dyn Error>> {\r\n    let client = Client::new();\r\n    match client.get(\"http://localhost:11434/\").send().await {\r\n        Ok(res) => match res.status().is_success() {\r\n            true => Ok(OllamaStatus::Alive),\r\n            false => Ok(OllamaStatus::Dead),\r\n        },\r\n        Err(_) => Ok(OllamaStatus::Dead),\r\n    }\r\n}\r\n\r\npub fn start() -> Result<(), Box<dyn Error>> {\r\n    // wt --window 0 --profile \"Ubuntu-22.04\" --colorScheme \"Ubuntu-22.04-ColorScheme\" --title \"Ollama Serve\" wsl -d Ubuntu-22.04 -- ollama serve\r\n    match std::process::Command::new(\"wt\")\r\n        .args([\r\n            \"--window\",\r\n            \"0\",\r\n            \"--profile\",\r\n            \"Ubuntu 22.04.3 LTS\",\r\n            \"--colorScheme\",\r\n            \"Ubuntu-22.04-ColorScheme\",\r\n            \"--title\",\r\n            \"Ollama Serve\",\r\n            \"wsl\",\r\n            \"-d\",\r\n            \"Ubuntu-22.04\",\r\n            \"--\",\r\n            \"ollama\",\r\n            \"serve\",\r\n        ])\r\n        .spawn()\r\n    {\r\n        Ok(_) => Ok(()),\r\n        Err(e) => Err(Box::new(e)),\r\n    }\r\n}\r\n\r\npub fn start_terminal() -> Result<(), Box<dyn Error>> {\r\n    match std::process::Command::new(\"wt\")\r\n        .args([\r\n            \"--window\",\r\n            \"0\",\r\n            \"--profile\",\r\n            \"Ubuntu 22.04.3 LTS\",\r\n            \"--colorScheme\",\r\n            \"Ubuntu-22.04-ColorScheme\",\r\n            \"--title\",\r\n            \"Ollama\",\r\n            \"wsl\",\r\n            \"-d\",\r\n            \"Ubuntu-22.04\",\r\n            \"--\",\r\n            \"bash\",\r\n            \"-l\",\r\n            \"-c\",\r\n            \"cd ~ && exec pwsh\",\r\n        ])\r\n        .spawn()\r\n    {\r\n        Ok(_) => Ok(()),\r\n        Err(e) => Err(Box::new(e)),\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\taskbar_tool\\src\\taskbar_wheel_tool.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse bevy_xpbd_2d::components::Position;\r\nuse cursor_hero_bevy::prelude::NegativeYVec2;\r\nuse cursor_hero_screen::get_image::get_image;\r\nuse cursor_hero_screen::get_image::ScreensToImageParam;\r\nuse cursor_hero_toolbelt_types::prelude::*;\r\nuse cursor_hero_tools::prelude::*;\r\nuse cursor_hero_ui_automation::prelude::find_element_at;\r\nuse cursor_hero_ui_automation::prelude::get_taskbar;\r\nuse cursor_hero_ui_automation::prelude::TaskbarEntry;\r\n\r\npub struct TaskbarWheelToolPlugin;\r\n\r\nimpl Plugin for TaskbarWheelToolPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<TaskbarWheelTool>();\r\n        app.register_type::<TaskbarEntryTool>();\r\n        app.add_systems(Update, toolbelt_events);\r\n        app.add_systems(Update, tick_wheel_switcher);\r\n        app.add_systems(Update, tick_taskbar_switcher);\r\n    }\r\n}\r\n\r\n#[derive(Component, Reflect, Default)]\r\nstruct TaskbarWheelTool;\r\n\r\n#[derive(Component, Reflect)]\r\nstruct TaskbarEntryTool {\r\n    entry: TaskbarEntry,\r\n}\r\n\r\nfn toolbelt_events(\r\n    mut commands: Commands,\r\n    asset_server: Res<AssetServer>,\r\n    mut reader: EventReader<ToolbeltPopulateEvent>,\r\n    access: ScreensToImageParam,\r\n) {\r\n    for event in reader.read() {\r\n        match event.loadout {\r\n            ToolbeltLoadout::Default => {\r\n                ToolSpawnConfig::<TaskbarWheelTool, NoInputs>::new(\r\n                    TaskbarWheelTool,\r\n                    event.id,\r\n                    event,\r\n                )\r\n                .with_src_path(file!().into())\r\n                .guess_name(file!())\r\n                .guess_image(file!(), &asset_server, \"png\")\r\n                .with_description(\"Swaps to taskbar tools\")\r\n                .with_starting_state(StartingState::Inactive)\r\n                .spawn(&mut commands);\r\n            }\r\n            ToolbeltLoadout::Taskbar => {\r\n                let Ok(taskbar) = get_taskbar() else {\r\n                    continue;\r\n                };\r\n                for entry in taskbar.entries {\r\n                    let Ok(image) = get_image(entry.bounds, &access) else {\r\n                        warn!(\"Failed to get image for {:?}\", &entry);\r\n                        continue;\r\n                    };\r\n                    ToolSpawnConfig::<TaskbarEntryTool, NoInputs>::new(\r\n                        TaskbarEntryTool {\r\n                            entry: entry.clone(),\r\n                        },\r\n                        event.id,\r\n                        event,\r\n                    )\r\n                    .with_src_path(file!().into())\r\n                    .with_name(entry.name)\r\n                    .with_description(\"Swaps to taskbar tools\")\r\n                    .with_image(asset_server.add(image))\r\n                    .with_size(entry.bounds.size().as_vec2())\r\n                    .with_starting_state(StartingState::Inactive)\r\n                    .spawn(&mut commands);\r\n                }\r\n            }\r\n            _ => {}\r\n        }\r\n    }\r\n}\r\n\r\nfn tick_wheel_switcher(\r\n    mut commands: Commands,\r\n    tool_query: Query<&Parent, (Added<ActiveTool>, With<TaskbarWheelTool>)>,\r\n    mut toolbelt_events: EventWriter<ToolbeltPopulateEvent>,\r\n) {\r\n    for toolbelt_id in tool_query.iter() {\r\n        let toolbelt_id = toolbelt_id.get();\r\n        commands.entity(toolbelt_id).despawn_descendants();\r\n        toolbelt_events.send(ToolbeltPopulateEvent {\r\n            id: toolbelt_id,\r\n            loadout: ToolbeltLoadout::Taskbar,\r\n        });\r\n    }\r\n}\r\n\r\nfn tick_taskbar_switcher(\r\n    mut commands: Commands,\r\n    tool_query: Query<(&Parent, &TaskbarEntryTool), Added<ActiveTool>>,\r\n    toolbelt_query: Query<&Parent, With<Toolbelt>>,\r\n    mut character_query: Query<&mut Position>,\r\n    mut toolbelt_events: EventWriter<ToolbeltPopulateEvent>,\r\n) {\r\n    for (toolbelt_id, tool) in tool_query.iter() {\r\n        let toolbelt_id = toolbelt_id.get();\r\n        if let Ok(character_id) = toolbelt_query.get(toolbelt_id) {\r\n            info!(\"Switching toolbelt {:?} to default tools\", toolbelt_id);\r\n            let character_id = character_id.get();\r\n            commands.entity(toolbelt_id).despawn_descendants();\r\n            toolbelt_events.send(ToolbeltPopulateEvent {\r\n                id: toolbelt_id,\r\n                loadout: ToolbeltLoadout::Default,\r\n            });\r\n            if let Ok(mut position) = character_query.get_mut(character_id) {\r\n                let center = tool.entry.bounds.center();\r\n                position.0 = center.as_vec2().neg_y();\r\n                if let Ok(elem) = find_element_at(center) {\r\n                    if let Err(e) = elem.click() {\r\n                        warn!(\"Failed to click taskbar entry: {:?}\", e);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui\\src\\lib.rs\r\n\r\n````rust\r\npub mod about_text_plugin;\r\npub mod fps_text_plugin;\r\npub mod position_text_plugin;\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\winutils\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_winutils\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\ncursor_hero_metrics = { workspace = true }\r\nbevy = { workspace = true }\r\nwindows = { workspace = true, features = [\r\n    \"Win32_Devices_HumanInterfaceDevice\",\r\n    \"Win32_Foundation\",\r\n    \"Win32_Graphics_Gdi\",\r\n    \"Win32_Security\",\r\n    \"Win32_System_Com\",\r\n    \"Win32_System_Diagnostics_ToolHelp\",\r\n    \"Win32_System_LibraryLoader\",\r\n    \"Win32_System_Ole\",\r\n    \"Win32_System_ProcessStatus\",\r\n    \"Win32_System_Threading\",\r\n    \"Win32_System_Variant\",\r\n    \"Win32_UI_Input_KeyboardAndMouse\",\r\n    \"Win32_UI_WindowsAndMessaging\",\r\n    # \"Win32_UI_Accessibility\",\r\n    # \"Gaming_Input\",\r\n    # \"Win32_Gaming\",\r\n    # \"Win32_System_Threading\",\r\n] }\r\nimage = {workspace = true}\r\nanyhow = {workspace = true}\r\nuiautomation = {workspace = true}\r\nfxhash = {workspace = true}\r\nwidestring = {workspace = true}\r\nenigo = {workspace = true}\r\nonce_cell = {workspace = true}\r\nitertools = {workspace = true}\r\nwinreg = { workspace = true }\r\ncrossbeam-channel = { workspace = true }\r\ncursor_hero_bevy = { workspace = true }\r\ncursor_hero_math = { workspace = true }\r\nwinit = { workspace = true } # TODO: remove me\r\n\r\n[dev-dependencies]\r\ncursor_hero_memory_types = { workspace = true }\r\ncursor_hero_worker = { workspace = true }\r\nbevy-inspector-egui = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\build.rs\r\n\r\n````rust\r\nextern crate embed_resource;\r\nuse std::env;\r\n// use std::fs;\r\n// use std::path::Path;\r\n\r\nfn main() {\r\n    let target = env::var(\"TARGET\").unwrap();\r\n    if target.contains(\"windows\") {\r\n        embed_resource::compile(\"icon.rc\");\r\n    }\r\n\r\n    // Check if it is a release build\r\n    // let profile = env::var(\"PROFILE\").unwrap();\r\n    // if profile == \"release\" {\r\n    //     // Get the crate version\r\n    //     let version = env::var(\"CARGO_PKG_VERSION\").unwrap();\r\n    //     // Define the original and new binary names\r\n    //     let original_binary_name = \"cursor_hero\"; // Replace with your binary name\r\n    //     let new_binary_name = format!(\"{}_v{}.exe\", original_binary_name, version);\r\n\r\n    //     // Set the output directory (where Cargo puts the compiled binaries)\r\n    //     let out_dir = env::var(\"OUT_DIR\").unwrap();\r\n    //     let target_dir = Path::new(&out_dir)\r\n    //         .parent()\r\n    //         .unwrap()\r\n    //         .parent()\r\n    //         .unwrap()\r\n    //         .parent()\r\n    //         .unwrap();\r\n\r\n    //     // Construct the paths to the original and new binaries\r\n    //     let original_binary_path = target_dir.join(original_binary_name).with_extension(\"exe\");\r\n    //     let new_binary_path = target_dir.join(new_binary_name).with_extension(\"exe\");\r\n\r\n    //     // Copy the binary\r\n    //     fs::copy(original_binary_path, new_binary_path).expect(\"Failed to copy the file\");\r\n    // }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\click_drag_character_movement\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_click_drag_character_movement\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\ncursor_hero_camera = { workspace = true }\r\ncursor_hero_character_types = { workspace = true }\r\nbevy = { workspace = true }\r\nbevy_xpbd_2d = { workspace = true }\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\calculator_app_types\\src\\lib.rs\r\n\r\n````rust\r\npub mod calculator_app_types;\r\npub mod calculator_app_types_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::calculator_app_types::*;\r\n    pub use crate::calculator_app_types_plugin::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\environment_types\\src\\lib.rs\r\n\r\n````rust\r\npub mod environment_types;\r\npub mod environment_types_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::environment_types::*;\r\n    pub use crate::environment_types_plugin::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\agent_types\\src\\lib.rs\r\n\r\n````rust\r\npub mod agent_types;\r\npub mod agent_types_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::agent_types::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\bevy\\src\\rect_with_properties.rs\r\n\r\n````rust\r\nuse bevy::math::Rect;\r\nuse bevy::math::Vec2;\r\n\r\npub trait RectWithHeight {\r\n    fn with_height(&self, height: f32) -> Rect;\r\n}\r\nimpl RectWithHeight for Rect {\r\n    fn with_height(&self, height: f32) -> Rect {\r\n        Rect::from_center_size(self.center(), Vec2::new(self.width(), height))\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\taskbar_tool\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_taskbar_tool\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\ncursor_hero_taskbar_types = { workspace = true }\r\ncursor_hero_ui_automation = { workspace = true }\r\ncursor_hero_toolbelt_types = { workspace = true }\r\ncursor_hero_screen = { workspace = true }\r\ncursor_hero_bevy = { workspace = true }\r\ncursor_hero_tools = { workspace = true }\r\nbevy_xpbd_2d = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\taskbar_types\\src\\taskbar_types_plugin.rs\r\n\r\n````rust\r\nuse crate::prelude::*;\r\nuse bevy::prelude::*;\r\nuse bevy::sprite::Material2dPlugin;\r\n\r\npub struct TaskbarTypesPlugin;\r\n\r\nimpl Plugin for TaskbarTypesPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<Taskbar>();\r\n        app.add_event::<TaskbarEvent>();\r\n        app.add_plugins(Material2dPlugin::<TaskbarMaterial>::default());\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\app\\src\\lib.rs\r\n\r\n````rust\r\npub mod app_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::app_plugin::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ollama\\src\\ollama_status_worker_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse crossbeam_channel::bounded;\r\nuse crossbeam_channel::Receiver;\r\nuse crossbeam_channel::Sender;\r\nuse cursor_hero_ollama_types::prelude::*;\r\nuse std::thread;\r\n\r\npub struct OllamaStatusWorkerPlugin;\r\n\r\nimpl Plugin for OllamaStatusWorkerPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Startup, create_worker_thread);\r\n        app.add_systems(Update, events_to_bridge);\r\n        app.add_systems(Update, bridge_to_events);\r\n    }\r\n}\r\n\r\n#[derive(Debug)]\r\nenum GameboundMessage {\r\n    Pong { status: OllamaStatus },\r\n}\r\n\r\n#[derive(Debug)]\r\nenum ThreadboundMessage {\r\n    Ping,\r\n    Startup,\r\n}\r\n\r\n#[derive(Resource)]\r\nstruct Bridge {\r\n    pub sender: Sender<ThreadboundMessage>,\r\n    pub receiver: Receiver<GameboundMessage>,\r\n}\r\n\r\nfn create_worker_thread(mut commands: Commands) {\r\n    let (game_tx, game_rx) = bounded::<_>(10);\r\n    let (thread_tx, thread_rx) = bounded::<_>(10);\r\n    commands.insert_resource(Bridge {\r\n        sender: thread_tx,\r\n        receiver: game_rx,\r\n    });\r\n\r\n    let game_tx_clone = game_tx.clone();\r\n    thread::Builder::new()\r\n        .name(\"Ollama status thread\".to_string())\r\n        .spawn(move || {\r\n            let rt = tokio::runtime::Runtime::new().unwrap();\r\n            rt.block_on(async {\r\n                let game_tx = game_tx_clone;\r\n                loop {\r\n                    let msg = match thread_rx.recv() {\r\n                        Ok(msg) => msg,\r\n                        Err(_) => {\r\n                            error!(\"Threadbound channel failure, exiting\");\r\n                            break;\r\n                        }\r\n                    };\r\n                    match msg {\r\n                        ThreadboundMessage::Ping => {\r\n                            debug!(\"Worker received ping request, pinging Ollama API\");\r\n                            let status = match crate::ollama::get_status().await {\r\n                                Ok(status) => status,\r\n                                Err(e) => {\r\n                                    error!(\"Failed to get status: {:?}\", e);\r\n                                    OllamaStatus::Unknown\r\n                                }\r\n                            };\r\n                            if let Err(e) = game_tx.send(GameboundMessage::Pong { status }) {\r\n                                error!(\"Gamebound channel failure, exiting: {}\", e);\r\n                                break;\r\n                            }\r\n                        }\r\n                        ThreadboundMessage::Startup => {\r\n                            debug!(\"Worker received startup request, starting Ollama API\");\r\n                            if let Err(e) = crate::ollama::start() {\r\n                                error!(\"Failed to start: {:?}\", e);\r\n                            };\r\n                        }\r\n                    }\r\n                    std::thread::sleep(std::time::Duration::from_millis(50));\r\n                }\r\n            });\r\n        })\r\n        .expect(\"Failed to spawn thread\");\r\n}\r\n\r\nfn events_to_bridge(\r\n    bridge: ResMut<Bridge>,\r\n    mut ping_events: EventReader<OllamaPingEvent>,\r\n    mut status_events: EventReader<OllamaStatusEvent>,\r\n) {\r\n    // Detect ping requests\r\n    for event in ping_events.read() {\r\n        let OllamaPingEvent::Ping = event else {\r\n            continue;\r\n        };\r\n        let msg = ThreadboundMessage::Ping;\r\n        debug!(\"Sending bridge message: {:?}\", msg);\r\n        if let Err(e) = bridge.sender.send(msg) {\r\n            error!(\"Threadbound channel failure: {}\", e);\r\n        }\r\n    }\r\n\r\n    // Detect startup requests\r\n    let starting = status_events\r\n        .read()\r\n        .any(|event| matches!(event, OllamaStatusEvent::Startup));\r\n    if starting {\r\n        status_events.clear();\r\n        let msg = ThreadboundMessage::Startup;\r\n        debug!(\"Sending bridge message: {:?}\", msg);\r\n        if let Err(e) = bridge.sender.send(msg) {\r\n            error!(\"Threadbound channel failure: {}\", e);\r\n        }\r\n    }\r\n}\r\n\r\nfn bridge_to_events(bridge: ResMut<Bridge>, mut events: EventWriter<OllamaPingEvent>) {\r\n    for msg in bridge.receiver.try_iter() {\r\n        match msg {\r\n            GameboundMessage::Pong { status } => {\r\n                let event = OllamaPingEvent::Pong { status };\r\n                debug!(\"Received bridge response, sending game event {:?}\", event);\r\n                events.send(event);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\pointer_types\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_pointer_types\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\nbevy-inspector-egui = { workspace = true }\r\n# cursor_hero_toolbelt_types = { workspace = true }\r\nleafwing-input-manager = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\brick_types\\src\\lib.rs\r\n\r\n````rust\r\npub mod brick_types;\r\npub mod brick_types_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::brick_types::*;\r\n    pub use crate::brick_types_plugin::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\text_asset_types\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_text_asset_types\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\nserde = { workspace = true }\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\host_fs\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_host_fs\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\ncursor_hero_host_fs_types = { workspace = true }\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\physics_debug\\src\\lib.rs\r\n\r\n````rust\r\npub mod physics_debug_plugin;\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\level_bounds\\src\\lib.rs\r\n\r\n````rust\r\npub mod level_bounds_plugin;\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\sprint_tool\\src\\sprint_tool_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse cursor_hero_character_types::prelude::*;\r\nuse cursor_hero_sprint_tool_types::sprint_tool_types_plugin::SprintEvent;\r\nuse cursor_hero_toolbelt_types::prelude::*;\r\nuse cursor_hero_tools::prelude::*;\r\nuse leafwing_input_manager::prelude::*;\r\n\r\npub struct SprintToolPlugin;\r\n\r\nimpl Plugin for SprintToolPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        // TODO: move to sprint_tool_types crate\r\n        app.register_type::<SprintTool>();\r\n        app.register_type::<SpawnedCube>();\r\n        app.add_plugins(InputManagerPlugin::<SprintToolAction>::default());\r\n        app.add_systems(Update, (toolbelt_events, handle_input));\r\n    }\r\n}\r\n\r\n#[derive(Component, Reflect, Default)]\r\nstruct SprintTool;\r\n#[derive(Actionlike, PartialEq, Eq, Clone, Copy, Hash, Debug, Reflect)]\r\nenum SprintToolAction {\r\n    Sprint,\r\n}\r\n\r\nimpl SprintToolAction {\r\n    fn default_gamepad_binding(&self) -> UserInput {\r\n        match self {\r\n            Self::Sprint => GamepadButtonType::LeftTrigger2.into(),\r\n        }\r\n    }\r\n\r\n    fn default_mkb_binding(&self) -> UserInput {\r\n        match self {\r\n            Self::Sprint => KeyCode::ShiftLeft.into(),\r\n        }\r\n    }\r\n}\r\nimpl ToolAction for SprintToolAction {\r\n    fn default_input_map(_event: &ToolbeltPopulateEvent) -> Option<InputMap<SprintToolAction>> {\r\n        let mut input_map = InputMap::default();\r\n\r\n        for variant in SprintToolAction::variants() {\r\n            input_map.insert(variant.default_mkb_binding(), variant);\r\n            input_map.insert(variant.default_gamepad_binding(), variant);\r\n        }\r\n        Some(input_map)\r\n    }\r\n}\r\n\r\nfn toolbelt_events(\r\n    mut commands: Commands,\r\n    asset_server: Res<AssetServer>,\r\n    mut reader: EventReader<ToolbeltPopulateEvent>,\r\n) {\r\n    for event in reader.read() {\r\n        let (ToolbeltLoadout::Default | ToolbeltLoadout::Inspector | ToolbeltLoadout::Keyboard) =\r\n            event.loadout\r\n        else {\r\n            continue;\r\n        };\r\n        ToolSpawnConfig::<SprintTool, SprintToolAction>::new(SprintTool, event.id, event)\r\n            .with_src_path(file!().into())\r\n            .guess_name(file!())\r\n            .guess_image(file!(), &asset_server, \"png\")\r\n            .with_description(\"Go faster, reach further\")\r\n            .spawn(&mut commands);\r\n    }\r\n}\r\n\r\n#[derive(Component, Reflect)]\r\npub struct SpawnedCube;\r\n\r\nfn handle_input(\r\n    sprint_tool_query: Query<(&ActionState<SprintToolAction>, &Parent), With<ActiveTool>>,\r\n    toolbelt_query: Query<&Parent, With<Toolbelt>>,\r\n    mut character_query: Query<Entity, With<Character>>,\r\n    mut sprint_events: EventWriter<SprintEvent>,\r\n) {\r\n    for sprint_tool in sprint_tool_query.iter() {\r\n        let (tool_actions, tool_parent) = sprint_tool;\r\n\r\n        let Ok(toolbelt) = toolbelt_query.get(tool_parent.get()) else {\r\n            warn!(\"Tool not inside a toolbelt?\");\r\n            continue;\r\n        };\r\n        let toolbelt_parent = toolbelt;\r\n        let Ok(character) = character_query.get_mut(toolbelt_parent.get()) else {\r\n            warn!(\"Toolbelt parent not a character?\");\r\n            continue;\r\n        };\r\n        let character_id = character;\r\n\r\n        if tool_actions.pressed(SprintToolAction::Sprint) {\r\n            if tool_actions.just_pressed(SprintToolAction::Sprint) {\r\n                debug!(\"Sprint tool action just pressed\");\r\n            }\r\n            let mut throttle = tool_actions.value(SprintToolAction::Sprint);\r\n            throttle = throttle.powf(2.0);\r\n            sprint_events.send(SprintEvent::Active {\r\n                character_id,\r\n                throttle,\r\n            });\r\n        } else if tool_actions.just_released(SprintToolAction::Sprint) {\r\n            debug!(\"Sprint tool action released\");\r\n            sprint_events.send(SprintEvent::Stop { character_id });\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui\\src\\position_text_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse bevy::window::PrimaryWindow;\r\nuse cursor_hero_camera::camera_plugin::MainCamera;\r\nuse cursor_hero_character_types::prelude::*;\r\n\r\npub struct PositionTextPlugin;\r\n\r\nimpl Plugin for PositionTextPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<CharacterPositionText>();\r\n        app.register_type::<MouseWorldPositionText>();\r\n        app.register_type::<MouseScreenPositionText>();\r\n        app.add_systems(Startup, setup_position_text);\r\n        app.add_systems(Update, update_position_text);\r\n    }\r\n}\r\n\r\n#[derive(Component, Reflect)]\r\nstruct CharacterPositionText;\r\n#[derive(Component, Reflect)]\r\nstruct MouseWorldPositionText;\r\n#[derive(Component, Reflect)]\r\nstruct MouseScreenPositionText;\r\n\r\nfn setup_position_text(mut commands: Commands, asset_server: Res<AssetServer>) {\r\n    commands.spawn((\r\n        TextBundle::from_section(\r\n            \"Character: \",\r\n            TextStyle {\r\n                font: asset_server.load(\"fonts/FiraSans-Bold.ttf\"),\r\n                font_size: 16.0,\r\n                ..default()\r\n            },\r\n        )\r\n        .with_style(Style {\r\n            position_type: PositionType::Absolute,\r\n            bottom: Val::Px(5.0),\r\n            left: Val::Px(5.0),\r\n            ..default()\r\n        }),\r\n        CharacterPositionText,\r\n        Name::new(\"Character Position Text\"),\r\n    ));\r\n    commands.spawn((\r\n        TextBundle::from_section(\r\n            \"Mouse Cursor: \",\r\n            TextStyle {\r\n                font: asset_server.load(\"fonts/FiraSans-Bold.ttf\"),\r\n                font_size: 16.0,\r\n                ..default()\r\n            },\r\n        )\r\n        .with_style(Style {\r\n            position_type: PositionType::Absolute,\r\n            bottom: Val::Px(15.0),\r\n            left: Val::Px(5.0),\r\n            ..default()\r\n        }),\r\n        MouseWorldPositionText,\r\n        Name::new(\"Mouse Cursor Position Text\"),\r\n    ));\r\n    commands.spawn((\r\n        TextBundle::from_section(\r\n            \"Mouse Screen: \",\r\n            TextStyle {\r\n                font: asset_server.load(\"fonts/FiraSans-Bold.ttf\"),\r\n                font_size: 16.0,\r\n                ..default()\r\n            },\r\n        )\r\n        .with_style(Style {\r\n            position_type: PositionType::Absolute,\r\n            bottom: Val::Px(25.0),\r\n            left: Val::Px(5.0),\r\n            ..default()\r\n        }),\r\n        MouseScreenPositionText,\r\n        Name::new(\"Mouse Screen Position Text\"),\r\n    ));\r\n}\r\n\r\n#[allow(clippy::type_complexity)]\r\nfn update_position_text(\r\n    character_query: Query<(&Character, &Transform), With<Character>>,\r\n    camera_query: Query<(&Camera, &GlobalTransform), With<MainCamera>>,\r\n    window_query: Query<&Window, With<PrimaryWindow>>,\r\n    mut character_position_text_query: Query<\r\n        &mut Text,\r\n        (\r\n            With<CharacterPositionText>,\r\n            Without<MouseWorldPositionText>,\r\n            Without<MouseScreenPositionText>,\r\n        ),\r\n    >,\r\n    mut mouse_world_position_text_query: Query<\r\n        &mut Text,\r\n        (\r\n            With<MouseWorldPositionText>,\r\n            Without<CharacterPositionText>,\r\n            Without<MouseScreenPositionText>,\r\n        ),\r\n    >,\r\n    mut mouse_screen_position_text_query: Query<\r\n        &mut Text,\r\n        (\r\n            With<MouseScreenPositionText>,\r\n            Without<CharacterPositionText>,\r\n            Without<MouseWorldPositionText>,\r\n        ),\r\n    >,\r\n    // mut text_query: Query<&mut Text, With<CharacterPositionText>>,\r\n) {\r\n    for (_character, transform) in character_query.iter() {\r\n        character_position_text_query.single_mut().sections[0].value = format!(\r\n            \"Character: {:.2}, {:.2}, {:.2}\",\r\n            transform.translation.x, transform.translation.y, transform.translation.z\r\n        );\r\n    }\r\n\r\n    let (camera, camera_transform) = camera_query.single();\r\n    let window = window_query.single();\r\n    // check if the cursor is inside the window and get its position\r\n    // then, ask bevy to convert into world coordinates, and truncate to discard Z\r\n    if let Some(world_position) = window\r\n        .cursor_position()\r\n        .and_then(|cursor| camera.viewport_to_world(camera_transform, cursor))\r\n        .map(|ray| ray.origin.truncate())\r\n    {\r\n        mouse_world_position_text_query.single_mut().sections[0].value = format!(\r\n            \"Mouse world: {:.2}, {:.2}\",\r\n            world_position.x, world_position.y,\r\n        );\r\n    } else {\r\n        mouse_world_position_text_query.single_mut().sections[0].value =\r\n            \"Mouse world: None\".to_string();\r\n    }\r\n    if let Some(cursor_position) = window.cursor_position() {\r\n        mouse_screen_position_text_query.single_mut().sections[0].value = format!(\r\n            \"Mouse screen: {:.2}, {:.2}\",\r\n            cursor_position.x, cursor_position.y,\r\n        );\r\n    } else {\r\n        mouse_screen_position_text_query.single_mut().sections[0].value =\r\n            \"Mouse screen: None\".to_string();\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui_watcher\\src\\lib.rs\r\n\r\n````rust\r\npub mod ui_watcher_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::ui_watcher_plugin::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\use cases\\monologuing.md\r\n\r\n````markdown\r\nI am recording in OBS. I am using VSCode.\r\nI have ChatGPT open. \r\nSo I'm talking and describing the problem that I want solved.And I'm gesturing in the editor, but ChatGPT cannot see the gestures at this time.Currently the best I can do is hold a push-to-talk button that will transcribe things as I say them, but that is not capturing information such as the selection under my mouse changing or tabs being changed in VS Code.One thing that I think would be good is a visual feedback for when the push-to-talk is actively listening.and that won't give misinformation. So if it says it's listening, it must be accurate.Because you can't be second-guessing the indicatorThe current best indicator is focusing the Windows Terminal, which has multiple tabs open, but one of those tabs is the Python program, which does have logging for when it is listening and other activities.So this could be leveraged.One possible way to do it would be to havethe tool programmatically focus the Windows Terminal window and then grab the content inside of it.a different way to do it would be to have the startup script for the thing that is running theWindows, or the voice-to-text thing.The thing that launches that would do so in a way that it captures the system and feeds it back to our program.One way to grab the logs would be to focus the Windows terminal, programmatically click and drag from the top left to the bottom right to select all the content, and then right-click to copy it.This causes problems though because the scenario where we are using the push-to-talk might be where we have something focused and we expect to type the response into it, but the act of focusing the Windows terminal to capture the content of it using click-and-drag would unfocus the text box we were previously at.That could be remediated by placing a marker fora reference on how to return to the current state.so that when we deviate from the state to analyze something, we know how to return to it. So the act of focusing the Windows terminal and unfocusing the text input, we would need to be able to...have a course of action for refocusing the text input. I need a way to be able to toggle the listening instead of holding it, because if I'm talking for a long time, I might just want it to listen continuously without having to hold down a button. and want to make a tool for the clipboard. It will be called the clipboard tool. The clipboard tool, when equipped, will...disable all the other tools so that it is the last one. So instead of adding to my to-do list an item that I could finish now but want to put on hold to pursue a different idea, it is just better for me to finish it.\r\n\r\n```ipynb\r\nimport os\r\nimport re\r\n\r\n# Get the list of all Cargo.toml files\r\ncargo_files = []\r\nfor root, dirs, files in os.walk('./crates'):\r\n    for file in files:\r\n        if file == 'Cargo.toml':\r\n            cargo_files.append(os.path.join(root, file))\r\n\r\n# Iterate over each Cargo.toml file\r\nfor cargo_file in cargo_files:\r\n    with open(cargo_file, 'r') as file:\r\n        lines = file.readlines()\r\n\r\n    # Find entries in [dependencies] that don't begin with \"cursor_\"\r\n    dependencies = []\r\n    for i, line in enumerate(lines):\r\n        if line.strip() == '[dependencies]':\r\n            j = i + 1\r\n            while j < len(lines) and not lines[j].startswith('['):\r\n                dependency = lines[j].strip()\r\n                if not dependency.startswith('cursor_'):\r\n                    dependencies.append(dependency)\r\n                j += 1\r\n\r\n    # Update the dependencies to { workspace = true }\r\n    for i, dependency in enumerate(dependencies):\r\n        lines[lines.index(dependency)] = dependency.replace(dependency, f'{dependency} = {{ workspace = true }}')\r\n\r\n    # Append features block to the windows crate\r\n    if 'windows' in cargo_file:\r\n        for i, line in enumerate(lines):\r\n            if line.strip() == '[dependencies.windows]':\r\n                j = i + 1\r\n                while j < len(lines) and not lines[j].startswith('['):\r\n                    if lines[j].startswith('features'):\r\n                        lines[j] = lines[j].strip()[:-1] + ', \"abc\"]\\n'\r\n                    j += 1\r\n\r\n    # Log the replaced entries\r\n    replaced_entries = [dependency.split('=')[0].strip() for dependency in dependencies]\r\n    print(f'Replaced entries in {cargo_file}: {replaced_entries}')\r\n\r\n    # Write the updated lines back to the Cargo.toml file\r\n    # with open(cargo_file, 'w') as file:\r\n    #     file.writelines(lines)\r\n```\r\nThat is an attempt at a notebook to...adjust dependencies to rely on the parent create.\r\nIt doesn't print anything when ran.\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\brick_types\\src\\brick_types.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n\r\n#[derive(Component, Debug, Reflect)]\r\npub struct Brick;\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\host_fs\\src\\lib.rs\r\n\r\n````rust\r\npub mod host_fs_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::host_fs_plugin::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\data\\src\\sounds.rs\r\n\r\n````rust\r\n/*\r\n * WARNING: THIS FILE IS AUTOGENERATED\r\n * DO NOT EDIT THIS FILE DIRECTLY\r\n *\r\n */\r\npub const PRESSURE_PLATE_ACTIVATION_DURATION: f32 = 1.84;\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\fullscreen_tool\\src\\fullscreen_tool_plugin.rs\r\n\r\n````rust\r\nuse crate::fullscreen_tool_populate_plugin::FullscreenToolPopulatePlugin;\r\nuse crate::fullscreen_tool_tick_plugin::FullscreenToolTickPlugin;\r\nuse bevy::prelude::*;\r\n\r\npub struct FullscreenToolPlugin;\r\n\r\nimpl Plugin for FullscreenToolPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_plugins(FullscreenToolPopulatePlugin);\r\n        app.add_plugins(FullscreenToolTickPlugin);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\toolbelt\\src\\lib.rs\r\n\r\n````rust\r\n#![feature(let_chains)]\r\n\r\npub mod hover_frame;\r\npub mod tool_activation;\r\npub mod tool_color;\r\npub mod tool_help_activate;\r\npub mod tool_help_cleanup;\r\npub mod tool_help_click;\r\npub mod tool_help_populate;\r\npub mod tool_visibility;\r\npub mod toolbelt_circle_layout_plugin;\r\npub mod toolbelt_opening_plugin;\r\npub mod toolbelt_plugin;\r\npub mod toolbelt_properties_plugin;\r\npub mod toolbelt_taskbar_layout_plugin;\r\npub mod wheel_audio;\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\toolbelt_types\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_toolbelt_types\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\nleafwing-input-manager = { workspace = true }\r\nserde = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\agent\\src\\insert_agent_toolbelt.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse cursor_hero_agent_types::agent_types::Agent;\r\nuse cursor_hero_character_types::prelude::*;\r\nuse cursor_hero_toolbelt_types::toolbelt_types::*;\r\n\r\npub struct InsertAgentToolbeltPlugin;\r\n\r\nimpl Plugin for InsertAgentToolbeltPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Update, insert_agent_toolbelt);\r\n    }\r\n}\r\n\r\npub fn insert_agent_toolbelt(\r\n    mut commands: Commands,\r\n    mut writer: EventWriter<ToolbeltPopulateEvent>,\r\n    fresh_characters: Query<Entity, (Added<Agent>, With<Character>)>,\r\n) {\r\n    for character in fresh_characters.iter() {\r\n        let character_id = character;\r\n        commands.entity(character_id).with_children(|c_commands| {\r\n            let toolbelt = c_commands.spawn(ToolbeltBundle::default());\r\n            writer.send(ToolbeltPopulateEvent {\r\n                id: toolbelt.id(),\r\n                loadout: ToolbeltLoadout::Agent,\r\n            });\r\n            info!(\r\n                \"Sent populate agent toolbelt event for agent {:?}\",\r\n                character_id\r\n            );\r\n        });\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\chat_types\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_chat_types\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\nleafwing-input-manager = { workspace = true }\r\ncursor_hero_toolbelt_types = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\pressure_plate\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_pressure_plate\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\ncursor_hero_data = { workspace = true }\r\nbevy = { workspace = true }\r\nbevy_xpbd_2d = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\text_asset_types\\src\\text_asset_loader_types.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n\r\nuse bevy::asset::io::Reader;\r\nuse bevy::asset::AssetLoader;\r\nuse bevy::asset::AsyncReadExt;\r\nuse bevy::asset::LoadContext;\r\nuse bevy::utils::thiserror;\r\nuse bevy::utils::BoxedFuture;\r\nuse serde::Deserialize;\r\nuse thiserror::Error;\r\n\r\n#[derive(Asset, Reflect, Debug, Deserialize)]\r\npub struct TextAsset {\r\n    pub value: String,\r\n}\r\n\r\n#[derive(Default)]\r\npub struct TextAssetLoader;\r\n\r\n/// Possible errors that can be produced by [`TextAssetLoader`]\r\n#[non_exhaustive]\r\n#[derive(Debug, Error)]\r\npub enum TextAssetLoaderError {\r\n    /// An [IO](std::io) Error\r\n    #[error(\"Could not load asset: {0}\")]\r\n    Io(#[from] std::io::Error),\r\n}\r\n\r\nimpl AssetLoader for TextAssetLoader {\r\n    type Asset = TextAsset;\r\n    type Settings = ();\r\n    type Error = TextAssetLoaderError;\r\n    fn load<'a>(\r\n        &'a self,\r\n        reader: &'a mut Reader,\r\n        _settings: &'a (),\r\n        _load_context: &'a mut LoadContext,\r\n    ) -> BoxedFuture<'a, Result<Self::Asset, Self::Error>> {\r\n        Box::pin(async move {\r\n            let mut bytes = Vec::new();\r\n            reader.read_to_end(&mut bytes).await?;\r\n            let custom_asset = TextAsset {\r\n                value: String::from_utf8(bytes).unwrap(),\r\n            };\r\n            Ok(custom_asset)\r\n        })\r\n    }\r\n\r\n    fn extensions(&self) -> &[&str] {\r\n        &[\"txt\"]\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui_watcher_types\\src\\ui_watcher_types.rs\r\n\r\n````rust\r\nuse std::fmt;\r\nuse std::fmt::Display;\r\nuse std::fmt::Formatter;\r\nuse uiautomation::controls::ControlType;\r\nuse uiautomation::UIElement;\r\n\r\npub enum AppUIElement {\r\n    VSCode(UIElement),\r\n    Unknown(UIElement),\r\n}\r\n\r\nimpl From<UIElement> for AppUIElement {\r\n    fn from(elem: UIElement) -> Self {\r\n        let name = elem.get_name();\r\n        let control_type = elem.get_control_type();\r\n        let class_name = elem.get_classname();\r\n        match (name, control_type, class_name) {\r\n            (Ok(name), Ok(ControlType::Pane), Ok(class_name))\r\n                if name.ends_with(\"Visual Studio Code\") && class_name == \"Chrome_WidgetWin_1\" =>\r\n            {\r\n                AppUIElement::VSCode(elem)\r\n            }\r\n            _ => AppUIElement::Unknown(elem),\r\n        }\r\n    }\r\n}\r\n\r\nimpl Display for AppUIElement {\r\n    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {\r\n        match self {\r\n            AppUIElement::VSCode(elem) => {\r\n                write!(f, \"Visual Studio Code: {:?}\", elem.get_name())\r\n                // match get_tree_string(elem) {\r\n                //     Ok(text) => write!(f, \"Visual Studio Code: {}\", text),\r\n                //     Err(e) => write!(f, \"Visual Studio Code: {:?}\", e),\r\n                // }\r\n            }\r\n            AppUIElement::Unknown(elem) => write!(f, \"Unknown: {:?}\", elem),\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\winutils\\src\\win_icons.rs\r\n\r\n````rust\r\nuse crate::win_errors::*;\r\nuse bevy::prelude::default;\r\nuse cursor_hero_math::prelude::bgra_to_rgba;\r\nuse image::ImageBuffer;\r\nuse image::RgbaImage;\r\nuse itertools::Itertools;\r\nuse widestring::U16CString;\r\nuse windows::core::PCWSTR;\r\nuse windows::Win32::Graphics::Gdi::CreateCompatibleDC;\r\nuse windows::Win32::Graphics::Gdi::DeleteDC;\r\nuse windows::Win32::Graphics::Gdi::DeleteObject;\r\nuse windows::Win32::Graphics::Gdi::GetDIBits;\r\nuse windows::Win32::Graphics::Gdi::SelectObject;\r\nuse windows::Win32::Graphics::Gdi::BITMAPINFO;\r\nuse windows::Win32::Graphics::Gdi::BITMAPINFOHEADER;\r\nuse windows::Win32::Graphics::Gdi::DIB_RGB_COLORS;\r\nuse windows::Win32::UI::Shell::ExtractIconExW;\r\nuse windows::Win32::UI::WindowsAndMessaging::CopyIcon;\r\nuse windows::Win32::UI::WindowsAndMessaging::DestroyIcon;\r\nuse windows::Win32::UI::WindowsAndMessaging::GetIconInfoExW;\r\nuse windows::Win32::UI::WindowsAndMessaging::HCURSOR;\r\nuse windows::Win32::UI::WindowsAndMessaging::HICON;\r\nuse windows::Win32::UI::WindowsAndMessaging::ICONINFOEXW;\r\n\r\npub fn get_images_from_exe(executable_path: &str) -> Result<Vec<RgbaImage>> {\r\n    unsafe {\r\n        let path_cstr = U16CString::from_str(executable_path)?;\r\n        let path_pcwstr = PCWSTR(path_cstr.as_ptr());\r\n        let num_icons_total = ExtractIconExW(path_pcwstr, -1, None, None, 0);\r\n        if num_icons_total == 0 {\r\n            return Ok(Vec::new()); // No icons extracted\r\n        }\r\n\r\n        let mut large_icons = vec![HICON::default(); num_icons_total as usize];\r\n        let mut small_icons = vec![HICON::default(); num_icons_total as usize];\r\n        let num_icons_fetched = ExtractIconExW(\r\n            path_pcwstr,\r\n            0,\r\n            Some(large_icons.as_mut_ptr()),\r\n            Some(small_icons.as_mut_ptr()),\r\n            num_icons_total,\r\n        );\r\n\r\n        if num_icons_fetched == 0 {\r\n            return Ok(Vec::new()); // No icons extracted\r\n        }\r\n\r\n        let images = large_icons\r\n            .iter()\r\n            .chain(small_icons.iter())\r\n            .map(convert_hicon_to_rgba_image)\r\n            .filter_map(|r| match r {\r\n                Ok(img) => Some(img),\r\n                Err(e) => {\r\n                    eprintln!(\"Failed to convert HICON to RgbaImage: {:?}\", e);\r\n                    None\r\n                }\r\n            })\r\n            .collect_vec();\r\n\r\n        large_icons\r\n            .iter()\r\n            .chain(small_icons.iter())\r\n            .filter(|icon| !icon.is_invalid())\r\n            .map(|icon| DestroyIcon(*icon))\r\n            .filter_map(|r| r.err())\r\n            .for_each(|e| eprintln!(\"Failed to destroy icon: {:?}\", e));\r\n\r\n        Ok(images)\r\n    }\r\n}\r\n\r\npub fn convert_hicon_to_rgba_image(hicon: &HICON) -> Result<RgbaImage> {\r\n    unsafe {\r\n        let mut icon_info = ICONINFOEXW {\r\n            cbSize: std::mem::size_of::<ICONINFOEXW>() as u32,\r\n            ..default()\r\n        };\r\n\r\n        if !GetIconInfoExW(*hicon, &mut icon_info).as_bool() {\r\n            return Err(Error::from_win32().with_description(format!(\r\n                \"icon \u2022 GetIconInfoExW: {} {}:{}\",\r\n                file!(),\r\n                line!(),\r\n                column!()\r\n            )));\r\n        }\r\n        let hdc_screen = CreateCompatibleDC(None);\r\n        let hdc_mem = CreateCompatibleDC(hdc_screen);\r\n        let hbm_old = SelectObject(hdc_mem, icon_info.hbmColor);\r\n\r\n        let mut bmp_info = BITMAPINFO {\r\n            bmiHeader: BITMAPINFOHEADER {\r\n                biSize: std::mem::size_of::<BITMAPINFOHEADER>() as u32,\r\n                biWidth: icon_info.xHotspot as i32 * 2,\r\n                biHeight: -(icon_info.yHotspot as i32 * 2),\r\n                biPlanes: 1,\r\n                biBitCount: 32,\r\n                biCompression: DIB_RGB_COLORS.0,\r\n                ..Default::default()\r\n            },\r\n            ..Default::default()\r\n        };\r\n\r\n        let mut buffer: Vec<u8> =\r\n            vec![0; (icon_info.xHotspot * 2 * icon_info.yHotspot * 2 * 4) as usize];\r\n\r\n        if GetDIBits(\r\n            hdc_mem,\r\n            icon_info.hbmColor,\r\n            0,\r\n            icon_info.yHotspot * 2,\r\n            Some(buffer.as_mut_ptr() as *mut _),\r\n            &mut bmp_info,\r\n            DIB_RGB_COLORS,\r\n        ) == 0\r\n        {\r\n            return Err(Error::from_win32().with_description(format!(\r\n                \"GetDIBits: {} {}:{}\",\r\n                file!(),\r\n                line!(),\r\n                column!()\r\n            )));\r\n        }\r\n        // Clean up\r\n        SelectObject(hdc_mem, hbm_old);\r\n        DeleteDC(hdc_mem);\r\n        DeleteDC(hdc_screen);\r\n        DeleteObject(icon_info.hbmColor);\r\n        DeleteObject(icon_info.hbmMask);\r\n\r\n        bgra_to_rgba(buffer.as_mut_slice());\r\n\r\n        let image = ImageBuffer::from_raw(icon_info.xHotspot * 2, icon_info.yHotspot * 2, buffer)\r\n            .ok_or_else(|| Error::ImageContainerNotBigEnough)?;\r\n        Ok(image)\r\n    }\r\n}\r\n\r\npub fn convert_hcursor_to_rgba_image(hcursor: &HCURSOR) -> Result<RgbaImage> {\r\n    unsafe {\r\n        // Convert HCURSOR to HICON\r\n        let hicon = CopyIcon(*hcursor)?;\r\n\r\n        // Use the existing convert_hicon_to_rgba_image function\r\n        let image = convert_hicon_to_rgba_image(&hicon)?;\r\n\r\n        // Destroy the HICON (since it was copied)\r\n        DestroyIcon(hicon)?;\r\n\r\n        Ok(image)\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use bevy::math::IVec4;\r\n    use std::path::PathBuf;\r\n\r\n    #[test]\r\n    fn test_convert_hicon_to_rgba_image() {\r\n        let exe_path = r\"C:\\Program Files (x86)\\Microsoft\\Edge\\Application\\msedge.exe\";\r\n        let icons = super::get_images_from_exe(exe_path).unwrap();\r\n\r\n        // Ensure the expected amount is present\r\n        assert_eq!(icons.len(), 30);\r\n\r\n        // Save icons\r\n        let mut path = PathBuf::from(\"target/app_icons\");\r\n        path.push(\"msedge.exe\");\r\n        std::fs::create_dir_all(&path).unwrap();\r\n        for (i, icon) in icons.iter().enumerate() {\r\n            let mut icon_path = path.clone();\r\n            icon_path.push(format!(\"{}.png\", i));\r\n            icon.save(icon_path).unwrap();\r\n        }\r\n\r\n        // Assert all icons are more than just transparent images\r\n        // Also count rgb totals\r\n        let mut passed = vec![false; icons.len()];\r\n        for (i, icon) in icons.iter().enumerate() {\r\n            let mut rgb_count = IVec4::ZERO;\r\n            for pixel in icon.pixels() {\r\n                let pixel = IVec4::new(\r\n                    pixel[0] as i32,\r\n                    pixel[1] as i32,\r\n                    pixel[2] as i32,\r\n                    pixel[3] as i32,\r\n                );\r\n                rgb_count += pixel;\r\n            }\r\n            if rgb_count != IVec4::ZERO {\r\n                passed[i] = true;\r\n            }\r\n        }\r\n        println!(\"{:?}\", passed);\r\n        assert!(passed.iter().all(|&x| x));\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\winutils\\src\\win_keyboard.rs\r\n\r\n````rust\r\n\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\glados_tts\\src\\glados_tts_button_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse bevy_xpbd_2d::prelude::*;\r\nuse cursor_hero_environment_types::prelude::*;\r\nuse cursor_hero_glados_tts_types::prelude::*;\r\nuse cursor_hero_math::prelude::Lerp;\r\nuse cursor_hero_pointer_types::prelude::*;\r\n\r\nuse crate::glados_tts;\r\npub struct GladosTtsButtonPlugin;\r\n\r\nimpl Plugin for GladosTtsButtonPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Update, populate_new_host_environments);\r\n        app.add_systems(Update, update_visuals);\r\n        app.add_systems(Update, status_button_click);\r\n        app.add_systems(Update, vscode_button_click);\r\n        app.add_systems(Update, handle_vscode_events);\r\n    }\r\n}\r\n\r\nfn populate_new_host_environments(\r\n    mut commands: Commands,\r\n    mut environment_events: EventReader<PopulateEnvironmentEvent>,\r\n    environment_query: Query<&HostEnvironment>,\r\n    asset_server: Res<AssetServer>,\r\n) {\r\n    for event in environment_events.read() {\r\n        if !environment_query.contains(event.environment_id) {\r\n            continue;\r\n        }\r\n        info!(\r\n            \"Adding button to new host environment {:?}\",\r\n            event.environment_id\r\n        );\r\n        commands\r\n            .entity(event.environment_id)\r\n            .with_children(|parent| {\r\n                parent\r\n                    .spawn((\r\n                        GladosTtsStatusButton::default(),\r\n                        Name::new(\"GLaDOS TTS Button\"),\r\n                        SpriteBundle {\r\n                            sprite: Sprite {\r\n                                custom_size: Some(Vec2::new(200.0, 100.0)),\r\n                                color: Color::PURPLE,\r\n                                ..default()\r\n                            },\r\n                            transform: Transform::from_translation(Vec3::new(\r\n                                1920.0 / 2.0 - 600.0,\r\n                                -1080.0 - 200.0,\r\n                                0.0,\r\n                            )),\r\n                            ..default()\r\n                        },\r\n                        Clickable,\r\n                        Hoverable,\r\n                        RigidBody::Static,\r\n                        Sensor,\r\n                        Collider::cuboid(200.0, 100.0),\r\n                    ))\r\n                    .with_children(|parent| {\r\n                        parent.spawn((Text2dBundle {\r\n                            text: Text::from_section(\r\n                                \"GLaDOS TTS Server Control\".to_string(),\r\n                                TextStyle {\r\n                                    font: asset_server.load(\"fonts/FiraSans-Bold.ttf\"),\r\n                                    font_size: 32.0,\r\n                                    color: Color::WHITE,\r\n                                },\r\n                            )\r\n                            .with_alignment(TextAlignment::Center),\r\n                            transform: Transform::from_xyz(0.0, 70.0, 1.0),\r\n                            ..default()\r\n                        },));\r\n                    });\r\n                parent\r\n                    .spawn((\r\n                        GladosTtsVscodeButton::default(),\r\n                        Name::new(\"GLaDOS TTS VSCode Button\"),\r\n                        SpriteBundle {\r\n                            sprite: Sprite {\r\n                                custom_size: Some(Vec2::new(200.0, 100.0)),\r\n                                color: Color::rgb(0.0, 0.6, 0.8),\r\n                                ..default()\r\n                            },\r\n                            transform: Transform::from_translation(Vec3::new(\r\n                                1920.0 / 2.0 - 600.0,\r\n                                -1080.0 - 350.0,\r\n                                0.0,\r\n                            )),\r\n                            ..default()\r\n                        },\r\n                        Clickable,\r\n                        Hoverable,\r\n                        RigidBody::Static,\r\n                        Sensor,\r\n                        Collider::cuboid(200.0, 100.0),\r\n                    ))\r\n                    .with_children(|parent| {\r\n                        parent.spawn((Text2dBundle {\r\n                            text: Text::from_section(\r\n                                \"open in vscode\".to_string(),\r\n                                TextStyle {\r\n                                    font: asset_server.load(\"fonts/FiraSans-Bold.ttf\"),\r\n                                    font_size: 32.0,\r\n                                    color: Color::WHITE,\r\n                                },\r\n                            )\r\n                            .with_alignment(TextAlignment::Center),\r\n                            transform: Transform::from_xyz(0.0, 0.0, 1.0),\r\n                            ..default()\r\n                        },));\r\n                    });\r\n            });\r\n    }\r\n}\r\n\r\nfn update_visuals(\r\n    mut events: EventReader<GladosTtsStatusEvent>,\r\n    mut button_query: Query<(&mut Sprite, &Children, &mut GladosTtsStatusButton)>,\r\n    mut button_text_query: Query<&mut Text>,\r\n) {\r\n    for event in events.read() {\r\n        let GladosTtsStatusEvent::Changed { new_value: status } = event else {\r\n            continue;\r\n        };\r\n        debug!(\"Updating GladosTts Server Control visuals to {:?}\", status);\r\n        for button in button_query.iter_mut() {\r\n            let (mut button_sprite, button_children, mut button) = button;\r\n            button.visual_state = match button.visual_state {\r\n                GladosTtsStatusButtonVisualState::Default { .. } => {\r\n                    GladosTtsStatusButtonVisualState::Default { status: *status }\r\n                }\r\n                GladosTtsStatusButtonVisualState::Hovered { .. } => {\r\n                    GladosTtsStatusButtonVisualState::Hovered { status: *status }\r\n                }\r\n                GladosTtsStatusButtonVisualState::Pressed { .. } => {\r\n                    GladosTtsStatusButtonVisualState::Pressed { status: *status }\r\n                }\r\n            };\r\n            match status {\r\n                GladosTtsStatus::Alive => {\r\n                    button_sprite.color = Color::GREEN;\r\n                }\r\n                GladosTtsStatus::Dead => {\r\n                    button_sprite.color = Color::RED;\r\n                }\r\n                GladosTtsStatus::Unknown => {\r\n                    button_sprite.color = Color::PURPLE;\r\n                }\r\n                GladosTtsStatus::Starting { instant, timeout } => {\r\n                    button_sprite.color = Color::YELLOW\r\n                        * (1.0, 0.1).lerp(instant.elapsed().as_secs_f32() / timeout.as_secs_f32());\r\n                }\r\n            }\r\n            for child in button_children.iter() {\r\n                if let Ok(mut text) = button_text_query.get_mut(*child) {\r\n                    match status {\r\n                        GladosTtsStatus::Alive => {\r\n                            text.sections[0].value =\r\n                                \"GLaDOS TTS Server Control (Alive)\".to_string();\r\n                        }\r\n                        GladosTtsStatus::Dead => {\r\n                            text.sections[0].value = \"GLaDOS TTS Server Control (Dead)\".to_string();\r\n                        }\r\n                        GladosTtsStatus::Unknown => {\r\n                            text.sections[0].value =\r\n                                \"GLaDOS TTS Server Control (Unknown)\".to_string();\r\n                        }\r\n                        GladosTtsStatus::Starting { instant, .. } => {\r\n                            text.sections[0].value = format!(\r\n                                \"GLaDOS TTS Server Control (Starting {}s ago)\",\r\n                                instant.elapsed().as_secs()\r\n                            );\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    for button in button_query.iter_mut() {\r\n        let (mut sprite, children, button) = button;\r\n        // if the visual state status is starting, update the text to show the time elapsed\r\n        let (GladosTtsStatusButtonVisualState::Default {\r\n            status: GladosTtsStatus::Starting { instant, timeout },\r\n        }\r\n        | GladosTtsStatusButtonVisualState::Hovered {\r\n            status: GladosTtsStatus::Starting { instant, timeout },\r\n        }\r\n        | GladosTtsStatusButtonVisualState::Pressed {\r\n            status: GladosTtsStatus::Starting { instant, timeout },\r\n        }) = button.visual_state\r\n        else {\r\n            continue;\r\n        };\r\n        sprite.color = Color::YELLOW\r\n            * (1.0, 0.1).lerp(instant.elapsed().as_secs_f32() / timeout.as_secs_f32());\r\n        for child in children.iter() {\r\n            if let Ok(mut text) = button_text_query.get_mut(*child) {\r\n                text.sections[0].value = format!(\r\n                    \"GladosTts Server Control (Starting {}s ago)\",\r\n                    instant.elapsed().as_secs()\r\n                );\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfn status_button_click(\r\n    mut click_events: EventReader<ClickEvent>,\r\n    button_query: Query<&GladosTtsStatusButton>,\r\n    mut status_events: EventWriter<GladosTtsStatusEvent>,\r\n) {\r\n    for event in click_events.read() {\r\n        let ClickEvent::Clicked {\r\n            target_id,\r\n            pointer_id: _,\r\n            way,\r\n        } = event\r\n        else {\r\n            continue;\r\n        };\r\n        if way != &Way::Left {\r\n            continue;\r\n        }\r\n        if let Ok(button) = button_query.get(*target_id) {\r\n            info!(\"GladosTts Server Control clicked\");\r\n            // if the button visual status is alive, do nothing\r\n            match button.visual_state {\r\n                GladosTtsStatusButtonVisualState::Default {\r\n                    status: GladosTtsStatus::Alive,\r\n                }\r\n                | GladosTtsStatusButtonVisualState::Hovered {\r\n                    status: GladosTtsStatus::Alive,\r\n                }\r\n                | GladosTtsStatusButtonVisualState::Pressed {\r\n                    status: GladosTtsStatus::Alive,\r\n                } => {\r\n                    warn!(\"GladosTts Server Control is already alive\");\r\n                    continue;\r\n                }\r\n                _ => {}\r\n            }\r\n            let event = GladosTtsStatusEvent::Startup;\r\n            debug!(\"Sending event {:?}\", event);\r\n            status_events.send(event);\r\n        }\r\n    }\r\n}\r\n\r\nfn vscode_button_click(\r\n    mut click_events: EventReader<ClickEvent>,\r\n    button_query: Query<&GladosTtsVscodeButton>,\r\n    mut vscode_events: EventWriter<GladosTtsVscodeEvent>,\r\n) {\r\n    for event in click_events.read() {\r\n        let ClickEvent::Clicked {\r\n            target_id,\r\n            pointer_id: _,\r\n            way,\r\n        } = event\r\n        else {\r\n            continue;\r\n        };\r\n        if way != &Way::Left {\r\n            continue;\r\n        }\r\n        if button_query.get(*target_id).is_ok() {\r\n            info!(\"GladosTts vscode clicked\");\r\n            let event = GladosTtsVscodeEvent::Startup;\r\n            debug!(\"Sending event {:?}\", event);\r\n            vscode_events.send(event);\r\n        }\r\n    }\r\n}\r\n\r\nfn handle_vscode_events(mut vscode_events: EventReader<GladosTtsVscodeEvent>) {\r\n    let should_start = vscode_events\r\n        .read()\r\n        .any(|event| matches!(event, GladosTtsVscodeEvent::Startup));\r\n    if should_start {\r\n        info!(\"Opening vscode\");\r\n        if let Err(e) = glados_tts::start_vscode() {\r\n            error!(\"Failed to start vscode: {:?}\", e);\r\n        }\r\n    }\r\n    vscode_events.clear();\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\input\\src\\update_gamepad_settings.rs\r\n\r\n````rust\r\nuse bevy::input::gamepad::ButtonSettings;\r\nuse bevy::input::gamepad::GamepadConnectionEvent;\r\nuse bevy::input::gamepad::GamepadSettings;\r\nuse bevy::prelude::*;\r\n\r\npub const PRESS_THRESHOLD: f32 = 0.1;\r\npub const RELEASE_THRESHOLD: f32 = 0.08;\r\n\r\n/// Responsible for updating the trigger thresholds for Mining Laser\r\n/// https://github.com/Leafwing-Studios/leafwing-input-manager/issues/405\r\npub fn update_gamepad_settings(\r\n    mut gamepad_events: EventReader<GamepadConnectionEvent>,\r\n    mut gamepad_settings: ResMut<GamepadSettings>,\r\n) {\r\n    gamepad_events.read().for_each(|event| {\r\n        info!(\"Updating Gamepad Settings\");\r\n\r\n        gamepad_settings.button_settings.insert(\r\n            GamepadButton {\r\n                gamepad: event.gamepad,\r\n                button_type: GamepadButtonType::RightTrigger2,\r\n            },\r\n            ButtonSettings::new(PRESS_THRESHOLD, RELEASE_THRESHOLD).unwrap(), //Ok because this would be programmer error\r\n        );\r\n\r\n        gamepad_settings.button_settings.insert(\r\n            GamepadButton {\r\n                gamepad: event.gamepad,\r\n                button_type: GamepadButtonType::LeftTrigger2,\r\n            },\r\n            ButtonSettings::new(PRESS_THRESHOLD, RELEASE_THRESHOLD).unwrap(), //Ok because this would be programmer error\r\n        );\r\n    });\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\pointer_types\\src\\pointer_reach_types.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n\r\n#[derive(Event, Debug, Reflect)]\r\npub enum PointerReachEvent {\r\n    SetPointer { pointer_id: Entity, reach: f32 },\r\n    SetPointerPercent { pointer_id: Entity, percent: f32 },\r\n    SetCharacter { character_id: Entity, reach: f32 },\r\n    SetCharacterPercent { character_id: Entity, percent: f32 },\r\n    ResetPointer { pointer_id: Entity },\r\n    ResetCharacter { character_id: Entity },\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui_automation_types\\src\\calculator_ui_types.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse serde::Deserialize;\r\nuse serde::Serialize;\r\n\r\n#[derive(Debug, Reflect, Default, Clone, Serialize, Deserialize, PartialEq)]\r\npub struct CalculatorState {\r\n    pub expression: String,\r\n    pub display: String,\r\n}\r\nimpl std::fmt::Display for CalculatorState {\r\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\r\n        write!(f, \"Calculator ({}{})\", self.expression, self.display)\r\n    }\r\n}\r\n#[derive(Component, Debug, Reflect, Default, Clone, Serialize, Deserialize, PartialEq)]\r\npub struct Calculator;\r\n\r\n#[derive(Component, Debug, Reflect, Default)]\r\npub struct NumberDisplayPanel;\r\n\r\n#[derive(Component, Debug, Reflect, Default)]\r\npub struct DigitInputButton(u8);\r\n\r\n#[derive(Component, Debug, Reflect, Default)]\r\npub struct EqualsButton;\r\n\r\n#[derive(Component, Debug, Reflect, Default)]\r\npub struct PlusButton;\r\n\r\n#[derive(Component, Debug, Reflect, Default, Clone, Serialize, Deserialize, PartialEq)]\r\npub struct CalculatorMemory {\r\n    pub buffer: f64,\r\n}\r\n\r\n#[derive(Event, Debug, Reflect, Default)]\r\npub struct SpawnCalculatorRequest {\r\n    calculator: CalculatorState,\r\n}\r\n#[derive(Event, Debug, Reflect)]\r\npub struct CalculatorRequestDefaultPositioningRequest {\r\n    calculator: Entity,\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\environment\\src\\environment_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse cursor_hero_environment_types::prelude::*;\r\n\r\nuse crate::environment_tracker_plugin::EnvironmentTrackerPlugin;\r\n\r\npub struct EnvironmentPlugin;\r\n\r\nimpl Plugin for EnvironmentPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_plugins(EnvironmentTrackerPlugin);\r\n        app.add_systems(Startup, send_create_host_event);\r\n        app.add_systems(Startup, send_create_game_event);\r\n        app.add_systems(Update, handle_create_events);\r\n        app.add_systems(Update, send_populate_events);\r\n    }\r\n}\r\n\r\nfn send_create_host_event(mut events: EventWriter<CreateEnvironmentRequestEvent>) {\r\n    events.send(CreateEnvironmentRequestEvent {\r\n        kind: EnvironmentKind::Host,\r\n        origin: Vec2::new(0.0, 0.0),\r\n        name: \"Host Environment\".to_string(),\r\n    });\r\n}\r\n\r\nfn send_create_game_event(mut events: EventWriter<CreateEnvironmentRequestEvent>) {\r\n    events.send(CreateEnvironmentRequestEvent {\r\n        kind: EnvironmentKind::Game,\r\n        origin: Vec2::new(0.0, -3000.0),\r\n        name: \"Game Environment\".to_string(),\r\n    });\r\n}\r\n\r\n#[allow(clippy::type_complexity)]\r\nfn send_populate_events(\r\n    environment_query: Query<Entity, Added<EnvironmentKind>>,\r\n    mut populate_events: EventWriter<PopulateEnvironmentEvent>,\r\n) {\r\n    for environment in environment_query.iter() {\r\n        let environment_id = environment;\r\n        let event = PopulateEnvironmentEvent { environment_id };\r\n        debug!(\"Sending populate event: {:?}\", event);\r\n        populate_events.send(event);\r\n    }\r\n}\r\n\r\nfn handle_create_events(\r\n    mut commands: Commands,\r\n    mut create_events: EventReader<CreateEnvironmentRequestEvent>,\r\n) {\r\n    for event in create_events.read() {\r\n        info!(\"Creating host environment at {:?}\", event.origin);\r\n        let mut c = commands.spawn((\r\n            SpatialBundle {\r\n                transform: Transform::from_translation(event.origin.extend(0.0)),\r\n                ..default()\r\n            },\r\n            event.kind,\r\n            Name::new(event.name.clone()),\r\n        ));\r\n        match event.kind {\r\n            EnvironmentKind::Host => {\r\n                c.insert(HostEnvironment);\r\n            }\r\n            EnvironmentKind::Game => {\r\n                c.insert(GameEnvironment);\r\n            }\r\n            EnvironmentKind::HostUIWatcher => {\r\n                c.insert(HostUIWatcherEnvironment);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\inference_types\\src\\prompt_types.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse cursor_hero_text_asset_types::text_asset_loader_types::TextAsset;\r\n\r\nuse crate::prelude::TextInferenceOptions;\r\n\r\n#[derive(Reflect, Debug, PartialEq, Eq, Clone)]\r\npub enum TextPrompt {\r\n    Raw {\r\n        content: String,\r\n        options: Option<TextInferenceOptions>,\r\n    },\r\n    Chat {\r\n        chat_history: String,\r\n        options: Option<TextInferenceOptions>,\r\n    },\r\n}\r\n\r\nimpl TextPrompt {\r\n    pub fn options(&self) -> Option<TextInferenceOptions> {\r\n        match self {\r\n            TextPrompt::Raw { options, .. } => options.clone(),\r\n            TextPrompt::Chat { options, .. } => options.clone(),\r\n        }\r\n    }\r\n}\r\n\r\n#[derive(Reflect, Debug, PartialEq, Eq, Clone)]\r\npub struct MaterializedTextPrompt {\r\n    pub prompt: TextPrompt,\r\n    pub materialized: String,\r\n}\r\n\r\n#[derive(Resource, Debug, Default, Reflect, PartialEq, Eq, Clone)]\r\n#[reflect(Resource)]\r\npub struct TextPromptHandles {\r\n    pub raw: Handle<TextAsset>,\r\n    pub chat: Handle<TextAsset>,\r\n}\r\n\r\n#[derive(Reflect, Debug, PartialEq, Eq, Clone)]\r\npub enum SpeechPrompt {\r\n    Raw { content: String },\r\n}\r\n\r\n#[derive(Reflect, Debug, PartialEq, Eq, Clone)]\r\npub enum TranscriptionPrompt {\r\n    Raw { content: Vec<u8> },\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\secret_types\\src\\secrets_types_plugin.rs\r\n\r\n````rust\r\nuse crate::prelude::*;\r\nuse bevy::prelude::*;\r\n\r\npub struct SecretsTypesPlugin;\r\n\r\nimpl Plugin for SecretsTypesPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<SecretString>();\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero\"\r\nversion = \"0.4.0\"\r\nedition = \"2021\"\r\n\r\n[workspace]\r\nmembers = [\"crates/*\", \"other/gamepad_hell\",  \"other/uparrow-enter\"]\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[workspace.dependencies]\r\ncursor_hero_worker_types = { path = \"./crates/worker_types\" }\r\ncursor_hero_worker = { path = \"./crates/worker\" }\r\ncursor_hero_memory_types = { path = \"./crates/memory_types\" }\r\ncursor_hero_memory = { path = \"./crates/memory\" }\r\ncursor_hero_window_swap_tool = { path = \"./crates/window_swap_tool\" }\r\ncursor_hero_window_swap_tool_types = { path = \"./crates/window_swap_tool_types\" }\r\ncursor_hero_host_fs_types = { path = \"./crates/host_fs_types\" }\r\ncursor_hero_host_fs = { path = \"./crates/host_fs\" }\r\ncursor_hero_window_position_types = { path = \"./crates/window_position_types\" }\r\ncursor_hero_window_position = { path = \"./crates/window_position\" }\r\ncursor_hero_ui_automation_types = { path = \"./crates/ui_automation_types\" }\r\ncursor_hero_ui_automation = { path = \"./crates/ui_automation\" }\r\ncursor_hero_brick_types = { path = \"./crates/brick_types\" }\r\ncursor_hero_brick = { path = \"./crates/brick\" }\r\ncursor_hero_fullscreen_tool = { path = \"./crates/fullscreen_tool\" }\r\ncursor_hero_fullscreen_tool_types = { path = \"./crates/fullscreen_tool_types\" }\r\ncursor_hero_ui_watcher_types = { path = \"./crates/ui_watcher_types\" }\r\ncursor_hero_ui_watcher = { path = \"./crates/ui_watcher\" }\r\ncursor_hero_floaty_nametag_types = { path = \"./crates/floaty_nametag_types\" }\r\ncursor_hero_floaty_nametag = { path = \"./crates/floaty_nametag\" }\r\ncursor_hero_host_event_types = { path = \"./crates/host_event_types\" }\r\ncursor_hero_host_event = { path = \"./crates/host_event\" }\r\ncursor_hero_taskbar_tool = { path = \"./crates/taskbar_tool\" }\r\ncursor_hero_start_menu_types = { path = \"./crates/start_menu_types\" }\r\ncursor_hero_start_menu = { path = \"./crates/start_menu\" }\r\ncursor_hero_calculator_app_types = { path = \"./crates/calculator_app_types\" }\r\ncursor_hero_calculator_app = { path = \"./crates/calculator_app\" }\r\ncursor_hero_app_types = { path = \"./crates/app_types\" }\r\ncursor_hero_app = { path = \"./crates/app\" }\r\ncursor_hero_secret_types = { path = \"./crates/secret_types\" }\r\ncursor_hero_secret = { path = \"./crates/secret\" }\r\ncursor_hero_voice_to_text_types = { path = \"./crates/voice_to_text_types\" }\r\ncursor_hero_voice_to_text = { path = \"./crates/voice_to_text\" }\r\ncursor_hero_glados_tts_types = { path = \"./crates/glados_tts_types\" }\r\ncursor_hero_glados_tts = { path = \"./crates/glados_tts\" }\r\ncursor_hero_ollama_types = { path = \"./crates/ollama_types\" }\r\ncursor_hero_ollama = { path = \"./crates/ollama\" }\r\ncursor_hero_text_asset_types = { path = \"./crates/text_asset_types\" }\r\ncursor_hero_text_asset = { path = \"./crates/text_asset\" }\r\ncursor_hero_environment_types = { path = \"./crates/environment_types\" }\r\ncursor_hero_chat_types = { path = \"./crates/chat_types\" }\r\ncursor_hero_chat = { path = \"./crates/chat\" }\r\ncursor_hero_observation_types = { path = \"./crates/observation_types\" }\r\ncursor_hero_observation = { path = \"./crates/observation\" }\r\ncursor_hero_inference_types = { path = \"./crates/inference_types\" }\r\ncursor_hero_inference = { path = \"./crates/inference\" }\r\ncursor_hero_movement_tool_types = { path = \"./crates/movement_tool_types\" }\r\ncursor_hero_movement_tool = { path = \"./crates/movement_tool\" }\r\ncursor_hero_character_types = { path = \"./crates/character_types\" }\r\ncursor_hero_agent_types = { path = \"./crates/agent_types\" }\r\ncursor_hero_physics_debug = { path = \"./crates/physics_debug\" }\r\ncursor_hero_math = { path = \"./crates/math\" }\r\ncursor_hero_pointer_types = { path = \"./crates/pointer_types\" }\r\ncursor_hero_toolbelt_types = { path = \"./crates/toolbelt_types\" }\r\ncursor_hero_sprint_tool_types = { path = \"./crates/sprint_tool_types\" }\r\ncursor_hero_sprint_tool = { path = \"./crates/sprint_tool\" }\r\ncursor_hero_agent = { path = \"./crates/agent\" }\r\ncursor_hero_taskbar = { path = \"./crates/taskbar\" }\r\ncursor_hero_taskbar_types = { path = \"./crates/taskbar_types\" }\r\ncursor_hero_environment_nametag = { path = \"./crates/environment_nametag\" }\r\ncursor_hero_environment = { path = \"./crates/environment\" }\r\ncursor_hero_xelu_prompts = { path = \"./crates/xelu_prompts\" }\r\ncursor_hero_pause_tool = { path = \"./crates/pause_tool\" }\r\ncursor_hero_wallpaper = { path = \"./crates/wallpaper\" }\r\ncursor_hero_cursor_mirror = { path = \"./crates/cursor_mirror\" }\r\ncursor_hero_hover = { path = \"./crates/hover\" }\r\ncursor_hero_pressure_plate = { path = \"./crates/pressure_plate\" }\r\ncursor_hero_level_bounds = { path = \"./crates/level_bounds\" }\r\ncursor_hero_bevy = { path = \"./crates/bevy\" }\r\ncursor_hero_input = { path = \"./crates/input\" }\r\ncursor_hero_camera = { path = \"./crates/camera\" }\r\ncursor_hero_character = { path = \"./crates/character\" }\r\ncursor_hero_data = { path = \"./crates/data\" }\r\ncursor_hero_metrics = { path = \"./crates/metrics\" }\r\ncursor_hero_click_drag_character_movement = { path = \"./crates/click_drag_character_movement\" }\r\ncursor_hero_physics = { path = \"./crates/physics\" }\r\ncursor_hero_pointer = { path = \"./crates/pointer\" }\r\ncursor_hero_screen = { path = \"./crates/screen\" }\r\ncursor_hero_toolbelt = { path = \"./crates/toolbelt\" }\r\ncursor_hero_tools = { path = \"./crates/tools\" }\r\ncursor_hero_ui = { path = \"./crates/ui\" }\r\ncursor_hero_winutils = { path = \"./crates/winutils\" }\r\ncursor_hero_restart_memory = { path = \"./crates/restart_memory\" }\r\ncursor_hero_version = { path = \"./crates/version\" }\r\ncursor_hero_plugins = { path = \"./crates/plugins\" }\r\ncursor_hero_icon = { path = \"./crates/icon\" }\r\n#inline_tweak = {git = \"https://github.com/Uriopass/inline_tweak\", version = \"1.1.0\", tag = \"v1.1.0\"} # features=[\"derive\"]\r\nanyhow = \"1.0.75\"\r\nglam = \"0.25.0\"\r\n# bevy = { path = \"../bevy\", features = [\"dynamic_linking\"] }\r\nbevy = { version = \"0.12.1\", git = \"https://github.com/TeamDman/bevy.git\", branch = \"cursor_hero\" }\r\n# bevy-inspector-egui = { version = \"0.22.1\", path=\"../bevy-inspector-egui/crates/bevy-inspector-egui\" }\r\nbevy-inspector-egui = { version = \"0.22.1\", git = \"https://github.com/TeamDman/bevy-inspector-egui.git\", branch = \"cursor_hero\" }\r\nbevy_xpbd_2d = { git = \"https://github.com/TeamDman/bevy_xpbd.git\", branch = \"cursor_hero\", features = [\r\n  \"simd\",\r\n  \"parallel\",\r\n] }\r\nbevy_egui = { git = \"https://github.com/TeamDman/bevy_egui.git\", branch = \"cursor_hero\", version = \"0.24\" }\r\n# enigo = {git = \"https://github.com/TeamDman/enigo\", branch = \"cursor_hero\", version = \"0.1.3\"}\r\n# enigo = {path = \"../../rust/enigo\", version = \"0.1.3\"}\r\nenigo = \"0.2.0-rc2\"\r\negui = \"0.24\"\r\ncrossbeam-channel = \"0.5.8\"\r\nitertools = \"0.12.0\"\r\nraw-window-handle = \"0.5.2\"\r\nleafwing-input-manager = { git = \"https://github.com/TeamDman/leafwing-input-manager.git\", branch = \"cursor_hero\" }\r\nwindows = \"0.52.0\"\r\nindexmap = \"2.1.0\"\r\nimage = \"0.24.7\"\r\nscreenshots = \"0.8.4\"\r\nuiautomation = \"0.7.3\"\r\nserde = { version = \"1.0\", features = [\"derive\"] }\r\nserde_json = \"1.0\"\r\ntokio = { version = \"1.32.0\", features = [\"net\", \"full\"] }\r\ntokio-named-pipes = \"0.1.0\"\r\nsyn = { version = \"2.0.48\", features = [\"full\", \"visit-mut\", \"visit\"] }\r\nquote = \"1.0.35\"\r\nproc-macro2 = \"1.0.76\"\r\nbevy_embedded_assets = { version = \"0.9.1\", git = \"https://github.com/TeamDman/bevy_embedded_assets.git\", branch = \"cursor_hero\" }\r\nwinit = \"0.28.7\"\r\nfxhash = \"0.2.1\"\r\nwidestring = \"1.0.2\"\r\nwinreg = \"0.52.0\"\r\nrand = \"0.8.5\"\r\nollama-rs = \"0.1.6\"\r\nreqwest = \"0.11.24\"\r\nurlencoding = \"2.1.3\"\r\nchrono = \"0.4.33\"\r\nrodio = { version = \"0.17\", default-features = false }\r\nzeroize = \"1.7.0\"\r\ntokio-tungstenite = \"0.21.0\"\r\nfutures-util = \"0.3.30\"\r\nonce_cell = \"1.19.0\"\r\n\r\n[dependencies]\r\ncursor_hero_plugins = { workspace = true }\r\ncursor_hero_version = { workspace = true }\r\nbevy = { workspace = true }\r\n\r\n[dev-dependencies]\r\n# bevy = { workspace = true, features = [\"dynamic_linking\"] }\r\nbevy = { workspace = true }\r\n\r\n\r\n[build-dependencies]\r\nembed-resource = \"1.6.3\"\r\n\r\n[profile.dev]\r\nopt-level = 1\r\n\r\n[profile.dev.package.\"*\"]\r\nopt-level = 3\r\n\r\n# [patch.crates-io]\r\n# winit = { path = \"D:/Repos/rust/winit\" }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\brick_types\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_brick_types\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\toolbelt\\src\\tool_color.rs\r\n\r\n````rust\r\nuse cursor_hero_toolbelt_types::toolbelt_types::*;\r\n\r\nuse bevy::prelude::*;\r\nuse cursor_hero_pointer_types::prelude::*;\r\n\r\nenum ToolColor {\r\n    Active,\r\n    Hovered,\r\n    HoveredActive,\r\n    Disabled,\r\n}\r\n\r\nimpl ToolColor {\r\n    fn color(&self) -> Color {\r\n        match self {\r\n            ToolColor::Active => Color::WHITE,\r\n            ToolColor::Hovered => Color::YELLOW,\r\n            ToolColor::HoveredActive => Color::ORANGE,\r\n            ToolColor::Disabled => Color::GRAY,\r\n        }\r\n    }\r\n\r\n    fn from(hovered: bool, active: bool) -> Self {\r\n        match (hovered, active) {\r\n            (true, true) => ToolColor::HoveredActive,\r\n            (true, false) => ToolColor::Hovered,\r\n            (false, true) => ToolColor::Active,\r\n            (false, false) => ToolColor::Disabled,\r\n        }\r\n    }\r\n}\r\n\r\n#[allow(clippy::type_complexity)]\r\npub fn tool_color(\r\n    mut query: Query<(&mut Sprite, Option<&Hovered>, Option<&ActiveTool>), With<Tool>>,\r\n) {\r\n    for (mut sprite, hovered, active) in query.iter_mut() {\r\n        let color = ToolColor::from(hovered.is_some(), active.is_some()).color();\r\n        sprite.color = color;\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\voice_to_text\\src\\voice_to_text.rs\r\n\r\n````rust\r\nuse bevy::log::debug;\r\nuse bevy::log::error;\r\nuse bevy::log::info;\r\nuse crossbeam_channel::Sender;\r\nuse cursor_hero_secret_types::secrets_types::SecretString;\r\nuse cursor_hero_voice_to_text_types::prelude::*;\r\nuse futures_util::stream::StreamExt;\r\nuse futures_util::SinkExt;\r\nuse rand::distributions::Alphanumeric;\r\nuse rand::Rng;\r\nuse reqwest::Client;\r\nuse std::error::Error;\r\nuse std::process::Command;\r\nuse tokio_tungstenite::connect_async;\r\nuse tokio_tungstenite::tungstenite::client::IntoClientRequest;\r\nuse tokio_tungstenite::tungstenite::http::header::AUTHORIZATION;\r\nuse tokio_tungstenite::tungstenite::http::HeaderValue;\r\nuse tokio_tungstenite::tungstenite::protocol::Message;\r\n\r\nuse crate::voice_to_text_worker_plugin::GameboundMessage;\r\n\r\npub(crate) const URL: &str = \"https://localhost:9127\";\r\n\r\npub(crate) async fn get_status() -> Result<VoiceToTextStatus, Box<dyn Error>> {\r\n    let client = Client::new();\r\n    match client.get(format!(\"{}/\", URL)).send().await {\r\n        Ok(res) => match res.status().is_success() {\r\n            true => Ok(VoiceToTextStatus::AliveButWeDontKnowTheApiKey),\r\n            false => Ok(VoiceToTextStatus::Dead),\r\n        },\r\n        Err(_) => Ok(VoiceToTextStatus::Dead),\r\n    }\r\n}\r\n\r\nfn generate_api_key(len: usize) -> SecretString {\r\n    let rng = rand::thread_rng();\r\n    let inner = rng\r\n        .sample_iter(&Alphanumeric)\r\n        .take(len)\r\n        .map(char::from)\r\n        .collect();\r\n    SecretString::new(inner)\r\n}\r\n\r\npub(crate) fn start() -> Result<SecretString, Box<dyn Error>> {\r\n    let port = 9127;\r\n    let api_key = generate_api_key(32);\r\n    match std::process::Command::new(\"wt\")\r\n        .args([\r\n            \"--window\",\r\n            \"0\",\r\n            \"--profile\",\r\n            \"PowerShell\",\r\n            \"--title\",\r\n            \"Voice2Text\",\r\n            \"--\",\r\n            \"pwsh\",\r\n            \"-Command\",\r\n            r\"cd D:\\Repos\\ml\\voice2text && conda activate whisperx && python .\\transcribe_hotkey_typer.py $env:port $env:api_key\",\r\n        ])\r\n        .env(\"port\", port.to_string())\r\n        .env(\"api_key\", api_key.expose_secret())\r\n        .spawn()\r\n    {\r\n        Ok(_) => Ok(api_key),\r\n        Err(e) => Err(Box::new(e)),\r\n    }\r\n}\r\n\r\npub(crate) fn start_vscode() -> Result<(), Box<dyn Error>> {\r\n    match Command::new(r\"C:\\Program Files\\Microsoft VS Code\\Code.exe\")\r\n        .args([r\"D:\\Repos\\ml\\voice2text\"])\r\n        .spawn()\r\n    {\r\n        Ok(_) => Ok(()),\r\n        Err(e) => Err(Box::new(e)),\r\n    }\r\n}\r\n\r\npub(crate) async fn set_listening(\r\n    listening: bool,\r\n    api_key: SecretString,\r\n) -> Result<(), Box<dyn Error>> {\r\n    let client = Client::new();\r\n    let endpoint = match listening {\r\n        true => format!(\"{}/start_listening\", URL),\r\n        false => format!(\"{}/stop_listening\", URL),\r\n    };\r\n    match client\r\n        .post(endpoint)\r\n        .header(reqwest::header::AUTHORIZATION, api_key.expose_secret())\r\n        .send()\r\n        .await\r\n    {\r\n        Ok(res) => match res.status().is_success() {\r\n            true => Ok(()),\r\n            false => Err(Box::new(std::io::Error::new(\r\n                std::io::ErrorKind::Other,\r\n                format!(\r\n                    \"Failed to set listening: {:?}\",\r\n                    match res.text().await {\r\n                        Ok(text) => text,\r\n                        Err(e) =>\r\n                            format!(\"Failed to get response text during failure handler: {}\", e),\r\n                    }\r\n                ),\r\n            )))?,\r\n        },\r\n        Err(e) => Err(Box::new(e)),\r\n    }\r\n}\r\n\r\nuse serde::Deserialize;\r\n#[derive(Debug, Deserialize)]\r\nstruct TranscriptionResponse {\r\n    segments: Vec<Segment>,\r\n    // language: String,\r\n}\r\n\r\n#[derive(Debug, Deserialize)]\r\nstruct Segment {\r\n    text: String,\r\n    // start: f64,\r\n    // end: f64,\r\n}\r\n\r\npub(crate) async fn connect_receiver(\r\n    game_tx: Sender<GameboundMessage>,\r\n    api_key: SecretString,\r\n) -> Result<(), Box<dyn Error>> {\r\n    // Assuming the WebSocket endpoint is similar to HTTP but with ws(s) protocol\r\n    let url = format!(\"{URL}/results\").replace(\"http\", \"ws\");\r\n\r\n    // Add our auth header\r\n    let mut req = url.into_client_request()?;\r\n    let val = HeaderValue::from_str(api_key.expose_secret().as_str())?;\r\n    req.headers_mut().insert(AUTHORIZATION, val);\r\n\r\n    // Start worker to listen to responses without blocking the main thread\r\n    tokio::spawn(async move {\r\n        let (ws_stream, _) = match connect_async(req).await {\r\n            Ok(conn) => {\r\n                info!(\"Connected to WebSocket\");\r\n                conn\r\n            }\r\n            Err(e) => {\r\n                error!(\"Failed to connect to WebSocket: {:?}\", e);\r\n                return;\r\n            }\r\n        };\r\n\r\n        let (mut write, mut read) = ws_stream.split();\r\n        debug!(\"Starting keepalive thread\");\r\n        tokio::spawn(async move {\r\n            debug!(\"Keepalive thread started, entering main loop\");\r\n            loop {\r\n                tokio::time::sleep(tokio::time::Duration::from_secs(5)).await;\r\n                if let Err(e) = write.send(Message::text(\"keepalive\")).await {\r\n                    error!(\"Failed to send keepalive: {:?}\", e);\r\n                    break;\r\n                }\r\n            }\r\n        });\r\n\r\n        // Listening for messages\r\n        while let Some(message) = read.next().await {\r\n            match message {\r\n                Ok(msg) => {\r\n                    if let Message::Text(text) = msg {\r\n                        // Deserialize the JSON text into TranscriptionResponse\r\n                        debug!(\"Received message: {}\", text);\r\n                        match serde_json::from_str::<TranscriptionResponse>(&text) {\r\n                            Ok(transcription) => {\r\n                                // Concatenate the text of all segments\r\n                                let concatenated_text = transcription\r\n                                    .segments\r\n                                    .iter()\r\n                                    .map(|s| s.text.as_str())\r\n                                    .collect::<Vec<&str>>()\r\n                                    .join(\" \");\r\n                                let msg = GameboundMessage::TranscriptionReceived {\r\n                                    transcription: concatenated_text,\r\n                                };\r\n                                debug!(\"Sending transcription to game: {:?}\", msg);\r\n                                if let Err(e) = game_tx.send(msg) {\r\n                                    error!(\"Failed to send transcription to game: {:?}\", e);\r\n                                }\r\n                            }\r\n                            Err(e) => error!(\"Failed to deserialize message: {:?}\", e),\r\n                        }\r\n                    }\r\n                }\r\n                Err(e) => {\r\n                    error!(\"WebSocket error: {:?}\", e);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    });\r\n\r\n    Ok(())\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\chat_types\\src\\lib.rs\r\n\r\n````rust\r\npub mod chat_types;\r\npub mod chat_types_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::chat_types::*;\r\n    pub use crate::chat_types_plugin::ChatTypesPlugin;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\environment\\src\\environment_tracker_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse bevy::utils::HashSet;\r\nuse bevy_xpbd_2d::components::CollidingEntities;\r\nuse cursor_hero_environment_types::prelude::*;\r\nuse cursor_hero_level_bounds::level_bounds_plugin::LevelBounds;\r\nuse cursor_hero_level_bounds::level_bounds_plugin::LevelBoundsHolder;\r\n\r\npub struct EnvironmentTrackerPlugin;\r\n\r\nimpl Plugin for EnvironmentTrackerPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Update, track);\r\n    }\r\n}\r\n\r\nfn track(\r\n    mut commands: Commands,\r\n    mut thing_query: Query<(Entity, Option<&mut EnvironmentTracker>, &CollidingEntities)>,\r\n    level_bounds_query: Query<&Parent, With<LevelBounds>>,\r\n    level_bounds_holder_query: Query<&Parent, With<LevelBoundsHolder>>,\r\n) {\r\n    for (thing_id, thing_environment_tag, thing_colliding_entities) in thing_query.iter_mut() {\r\n        // find out what level bounds the pointer is touching\r\n        // find those bounds' parent\r\n        // find the parent of the parent to get the environment ID\r\n        let environment_ids = thing_colliding_entities\r\n            .0\r\n            .iter()\r\n            .filter_map(|entity| {\r\n                if let Ok(level_bounds_holder_id) = level_bounds_query.get(*entity) {\r\n                    if let Ok(environment_id) =\r\n                        level_bounds_holder_query.get(level_bounds_holder_id.get())\r\n                    {\r\n                        return Some(environment_id.get());\r\n                    }\r\n                }\r\n                None\r\n            })\r\n            .collect::<HashSet<Entity>>();\r\n        if environment_ids.len() > 1 {\r\n            warn!(\r\n                \"Thing {:?} is touching multiple environments: {:?}\",\r\n                thing_id, environment_ids\r\n            );\r\n        }\r\n        if let Some(environment_id) = environment_ids.iter().next() {\r\n            if let Some(mut tag) = thing_environment_tag {\r\n                tag.environment_id = *environment_id;\r\n            } else {\r\n                commands.entity(thing_id).insert(EnvironmentTracker {\r\n                    environment_id: *environment_id,\r\n                });\r\n            }\r\n        } else if thing_environment_tag.is_some() {\r\n            commands.entity(thing_id).remove::<EnvironmentTracker>();\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\start_menu_types\\src\\start_menu_types_plugin.rs\r\n\r\n````rust\r\nuse crate::prelude::*;\r\nuse bevy::prelude::*;\r\n\r\npub struct StartMenuTypesPlugin;\r\n\r\nimpl Plugin for StartMenuTypesPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<StartMenuButton>();\r\n\r\n        app.register_type::<StartMenu>();\r\n        app.add_event::<StartMenuEvent>();\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\templates\\matchers\\new_tool\\crates\\plugins\\src\\lib.rs.py\r\n\r\n````py\r\n# {{use_statements}}\r\n# use cursor_hero_{{crate_name}}_tool::prelude::*;\r\n# {{plugin_start}}\r\n#         app.add_plugins({{crate_name_pascal}}ToolPlugin);\r\n# {{plugin_remaining}}\r\n\r\ndef gather_variables(text: str) -> dict[str,str]:\r\n    # use_statements\r\n    find = \"pub struct MyPlugin;\"\r\n    include = False\r\n    index = text.find(find)\r\n    assert index != -1, f\"Coult not find `{find}`\"\r\n    index = index + len(find) if include else index\r\n    use_statements, remaining = text[:index],text[index:]\r\n\r\n    # plugin_start\r\n    find = \"fn build(&self, app: &mut App) {\"\r\n    include = True\r\n    index = remaining.find(find)\r\n    assert index != -1, f\"Coult not find `{find}`\"\r\n    index = index + len(find) if include else index\r\n    plugin_start, remaining = remaining[:index],remaining[index:]\r\n\r\n    # plugin_remaining\r\n    plugin_remaining = remaining\r\n\r\n    return {\r\n        \"use_statements\": use_statements,\r\n        \"plugin_start\": plugin_start,\r\n        \"plugin_remaining\": plugin_remaining,\r\n    }\r\n\r\n#region WORKSPACE CONTENT\r\n#use bevy::input::common_conditions::input_toggle_active;\r\n#use bevy::prelude::*;\r\n#\r\n#use bevy::audio::AudioPlugin;\r\n#use bevy::audio::SpatialScale;\r\n#use bevy::diagnostic::FrameTimeDiagnosticsPlugin;\r\n#use bevy::log::LogPlugin;\r\n#use bevy_embedded_assets::EmbeddedAssetPlugin;\r\n#use bevy_inspector_egui::quick::WorldInspectorPlugin;\r\n#use cursor_hero_agent::agent_plugin::AgentPlugin;\r\n#use cursor_hero_camera::camera_plugin::CameraPlugin;\r\n#use cursor_hero_character::character_plugin::CharacterPlugin;\r\n#use cursor_hero_cursor_mirror::cursor_mirroring_plugin::CursorMirroringPlugin;\r\n#use cursor_hero_environment::environment_plugin::EnvironmentPlugin;\r\n#use cursor_hero_environment_nametag::environment_nametag_plugin::EnvironmentNametagPlugin;\r\n#use cursor_hero_hover::afterimage_plugin::AfterimagePlugin;\r\n#use cursor_hero_hover::hover_tool::HoverToolPlugin;\r\n#use cursor_hero_hover::hover_ui_automation_plugin::HoverUiAutomationPlugin;\r\n#use cursor_hero_hover::inspect_tool::InspectToolPlugin;\r\n#use cursor_hero_hover::inspect_wheel_tool::InspectWheelToolPlugin;\r\n#use cursor_hero_icon::IconPlugin;\r\n#use cursor_hero_input::InputPlugin;\r\n#use cursor_hero_level_bounds::level_bounds_plugin::LevelBoundsPlugin;\r\n#use cursor_hero_math::math_plugin::MathPlugin;\r\n#use cursor_hero_pause_tool::pause_tool_plugin::PauseToolPlugin;\r\n#use cursor_hero_physics::damping_plugin::DampingPlugin;\r\n#use cursor_hero_physics::physics_plugin::PhysicsPlugin;\r\n#use cursor_hero_physics_debug::physics_debug_plugin::PhysicsDebugPlugin;\r\n#use cursor_hero_pointer::pointer_plugin::PointerPlugin;\r\n#use cursor_hero_pointer_types::pointer_types_plugin::PointerTypesPlugin;\r\n#use cursor_hero_pressure_plate::pressure_plate_plugin::PressurePlatePlugin;\r\n#use cursor_hero_restart_memory::MemoryPlugin;\r\n##[cfg(debug_assertions)]\r\n#use cursor_hero_screen::screen_plugin::ScreenPlugin;\r\n#use cursor_hero_screen::screen_update_plugin::ScreenUpdatePlugin;\r\n#use cursor_hero_sprint_tool::sprint_tool_plugin::SprintToolPlugin;\r\n#use cursor_hero_sprint_tool_types::sprint_tool_types_plugin::SprintToolTypesPlugin;\r\n#use cursor_hero_taskbar::taskbar_plugin::TaskbarPlugin;\r\n#use cursor_hero_toolbelt::toolbelt_plugin::ToolbeltPlugin;\r\n#use cursor_hero_toolbelt_types::toolbelt_types_plugin::ToolbeltTypesPlugin;\r\n#use cursor_hero_tools::ToolPlugin;\r\n#use cursor_hero_ui::about_text_plugin::AboutTextPlugin;\r\n#use cursor_hero_ui::fps_text_plugin::FpsTextPlugin;\r\n#use cursor_hero_version::version_plugin::Version;\r\n#use cursor_hero_wallpaper::wallpaper_plugin::WallpaperPlugin;\r\n#\r\n#use cursor_hero_agent_types::agent_types_plugin::AgentTypesPlugin;\r\n#use cursor_hero_character_types::character_types_plugin::CharacterTypesPlugin;\r\n#use cursor_hero_chat::chat_plugin::ChatPlugin;\r\n#use cursor_hero_chat_types::chat_types_plugin::ChatTypesPlugin;\r\n#use cursor_hero_inference::inference_plugin::InferencePlugin;\r\n#use cursor_hero_inference_types::inference_types_plugin::InferenceTypesPlugin;\r\n#use cursor_hero_movement_tool::movement_tool_plugin::MovementToolPlugin;\r\n#use cursor_hero_movement_tool_types::movement_tool_types_plugin::MovementToolTypesPlugin;\r\n#use cursor_hero_observation::observation_plugin::ObservationPlugin;\r\n#use cursor_hero_observation_types::observation_types_plugin::ObservationTypesPlugin;\r\n#use cursor_hero_tts::tts_plugin::TtsPlugin;\r\n#use cursor_hero_tts_types::tts_types_plugin::TtsTypesPlugin;\r\n#use cursor_hero_environment_types::environment_types_plugin::EnvironmentTypesPlugin;\r\n#pub struct MyPlugin;\r\n#\r\n#impl Plugin for MyPlugin {\r\n#    fn build(&self, app: &mut App) {\r\n#        app.add_plugins(EnvironmentTypesPlugin);\r\n#        app.add_plugins(ChatTypesPlugin);\r\n#        app.add_plugins(ChatPlugin);\r\n#        app.add_plugins(TtsPlugin);\r\n#        app.add_plugins(TtsTypesPlugin);\r\n#        app.add_plugins(ObservationTypesPlugin);\r\n#        app.add_plugins(ObservationPlugin);\r\n#        app.add_plugins(InferenceTypesPlugin);\r\n#        app.add_plugins(InferencePlugin);\r\n#        app.add_plugins(MovementToolTypesPlugin);\r\n#        app.add_plugins(MovementToolPlugin);\r\n#        app.add_plugins(CharacterTypesPlugin);\r\n#        app.add_plugins(AgentTypesPlugin);\r\n#        app.add_plugins(AgentPlugin);\r\n#        //app.add_plugins(ClickDragMovementPlugin);\r\n#        //app.add_plugins(HoverShowerRelayPlugin);\r\n#        //app.add_plugins(HoverShowerServicePlugin);\r\n#        app.add_plugins(AboutTextPlugin);\r\n#        app.add_plugins(AfterimagePlugin);\r\n#        app.add_plugins(CameraPlugin);\r\n#        app.add_plugins(CharacterPlugin);\r\n#        app.add_plugins(CursorMirroringPlugin);\r\n#        app.add_plugins(DampingPlugin);\r\n#        app.add_plugins(EnvironmentNametagPlugin);\r\n#        app.add_plugins(EnvironmentPlugin);\r\n#        app.add_plugins(FpsTextPlugin);\r\n#        app.add_plugins(HoverToolPlugin);\r\n#        app.add_plugins(HoverUiAutomationPlugin);\r\n#        app.add_plugins(IconPlugin);\r\n#        app.add_plugins(InputPlugin);\r\n#        app.add_plugins(InspectToolPlugin);\r\n#        app.add_plugins(InspectWheelToolPlugin);\r\n#        app.add_plugins(LevelBoundsPlugin);\r\n#        app.add_plugins(MathPlugin);\r\n#        app.add_plugins(MemoryPlugin);\r\n#        app.add_plugins(PauseToolPlugin);\r\n#        app.add_plugins(PhysicsDebugPlugin);\r\n#        app.add_plugins(PhysicsPlugin);\r\n#        app.add_plugins(PointerPlugin);\r\n#        app.add_plugins(PointerTypesPlugin);\r\n#        // app.add_plugins(PositionTextPlugin);\r\n#        app.add_plugins(PressurePlatePlugin);\r\n#        app.add_plugins(ScreenPlugin);\r\n#        app.add_plugins(ScreenUpdatePlugin);\r\n#        app.add_plugins(SprintToolPlugin);\r\n#        app.add_plugins(SprintToolTypesPlugin);\r\n#        app.add_plugins(TaskbarPlugin);\r\n#        app.add_plugins(ToolbeltPlugin);\r\n#        app.add_plugins(ToolbeltTypesPlugin);\r\n#        app.add_plugins(ToolPlugin);\r\n#        app.add_plugins(WallpaperPlugin);\r\n#\r\n#        // must be before the default plugins\r\n#        app.add_plugins(EmbeddedAssetPlugin {\r\n#            mode: bevy_embedded_assets::PluginMode::ReplaceDefault,\r\n#        });\r\n#\r\n#        #[cfg(debug_assertions)]\r\n#        let log_plugin = LogPlugin {\r\n#            level: bevy::log::Level::DEBUG,\r\n#            filter: \"info,wgpu_core=warn,wgpu_hal=warn,bevy_ecs=info,cursor_hero=debug\".into(),\r\n#            // filter: \"debug,wgpu_core=warn,wgpu_hal=warn,bevy_ecs=info,cursor_hero=debug\".into(),\r\n#        };\r\n#        #[cfg(not(debug_assertions))]\r\n#        let log_plugin = LogPlugin {\r\n#            level: bevy::log::Level::INFO,\r\n#            filter: \"info,wgpu_core=warn,wgpu_hal=warn\".into(),\r\n#        };\r\n#        const AUDIO_SCALE: f32 = 1. / 100.0;\r\n#        let version = match app.world.get_resource::<Version>() {\r\n#            Some(version) => version.0.clone(),\r\n#            None => {\r\n#                warn!(\"Version resource not found\");\r\n#                \"Unknown\".to_string()\r\n#            }\r\n#        };\r\n#        app.add_plugins(\r\n#            DefaultPlugins\r\n#                .set(ImagePlugin::default_nearest())\r\n#                .set(AudioPlugin {\r\n#                    spatial_scale: SpatialScale::new_2d(AUDIO_SCALE),\r\n#                    ..default()\r\n#                })\r\n#                .set(WindowPlugin {\r\n#                    primary_window: Some(Window {\r\n#                        transparent: true,\r\n#                        title: format!(\"Cursor Hero v{}\", version),\r\n#                        resizable: true,\r\n#                        ..default()\r\n#                    }),\r\n#                    ..default()\r\n#                })\r\n#                .set(log_plugin)\r\n#                .build(),\r\n#        );\r\n#\r\n#        // must be after the default plugins\r\n#        app.add_plugins(\r\n#            WorldInspectorPlugin::default().run_if(input_toggle_active(false, KeyCode::Grave)),\r\n#        );\r\n#        app.add_plugins(FrameTimeDiagnosticsPlugin);\r\n#    }\r\n#}\r\n#\r\n#endregion\r\n\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\inference_types\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_inference_types\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\nollama-rs = { workspace = true }\r\ncursor_hero_text_asset_types = {workspace = true}\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\inference_types\\src\\inference_types_plugin.rs\r\n\r\n````rust\r\nuse crate::prelude::*;\r\nuse bevy::prelude::*;\r\npub struct InferenceTypesPlugin;\r\n\r\nimpl Plugin for InferenceTypesPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<TextPrompt>();\r\n        app.register_type::<MaterializedTextPrompt>();\r\n        app.register_type::<TextInferenceEvent>();\r\n        app.add_event::<TextInferenceEvent>();\r\n\r\n        app.register_type::<SpeechPrompt>();\r\n        app.register_type::<SpeechInferenceEvent>();\r\n        app.add_event::<SpeechInferenceEvent>();\r\n\r\n        app.register_type::<TranscriptionPrompt>();\r\n        app.register_type::<TranscriptionInferenceEvent>();\r\n        app.add_event::<TranscriptionInferenceEvent>();\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\host_fs\\src\\host_fs_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse cursor_hero_host_fs_types::host_fs_types::HostPathAction;\r\n\r\npub struct HostFsPlugin;\r\n\r\nimpl Plugin for HostFsPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Update, handle_host_path_events);\r\n    }\r\n}\r\n\r\nfn handle_host_path_events(mut host_path_events: EventReader<HostPathAction>) {\r\n    for event in host_path_events.read() {\r\n        match event {\r\n            HostPathAction::OpenWithCode { path } => {\r\n                println!(\"Open with code: {:?}\", path);\r\n                let Some(x) = path.path.to_str() else {\r\n                    continue;\r\n                };\r\n                if let Err(e) = std::process::Command::new(\"code.cmd\").arg(x).spawn() {\r\n                    error!(\"Failed to open with code: {:?}\", e);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\hover\\src\\hover_ui_automation_plugin.rs\r\n\r\n````rust\r\nuse std::thread;\r\n\r\nuse bevy::prelude::*;\r\nuse bevy::window::PrimaryWindow;\r\nuse crossbeam_channel::bounded;\r\nuse crossbeam_channel::Receiver;\r\nuse crossbeam_channel::Sender;\r\nuse cursor_hero_ui_automation::prelude::find_element_at;\r\nuse cursor_hero_ui_automation::prelude::gather_single_element_info;\r\nuse cursor_hero_ui_automation::prelude::ElementInfo;\r\nuse cursor_hero_winutils::win_mouse::get_cursor_position;\r\n\r\nuse cursor_hero_camera::camera_plugin::MainCamera;\r\n\r\npub struct HoverUiAutomationPlugin;\r\n\r\nimpl Plugin for HoverUiAutomationPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        info!(\"Adding HoverInfo resource\");\r\n        app.insert_resource(HoverInfo::default());\r\n        app.register_type::<HoveredElement>();\r\n        app.add_systems(Startup, setup);\r\n        app.add_systems(\r\n            Update,\r\n            (\r\n                update_game_mouse_position,\r\n                update_hover_info,\r\n                show_hovered_rect,\r\n            )\r\n                .chain(),\r\n        );\r\n    }\r\n}\r\n\r\n#[derive(Debug)]\r\nenum GameboundMessage {\r\n    ScreenHoverInfo(ElementInfo),\r\n    ScreenHoverInfoNone,\r\n    GameHoverInfo(ElementInfo),\r\n    GameHoverInfoNone,\r\n}\r\n\r\n#[derive(Debug)]\r\nenum ThreadboundMessage {\r\n    CursorPosition(IVec2),\r\n    CursorPositionNone,\r\n}\r\n\r\n#[derive(Resource)]\r\nstruct Bridge {\r\n    pub sender: Sender<ThreadboundMessage>,\r\n    pub receiver: Receiver<GameboundMessage>,\r\n}\r\n\r\n#[derive(Resource, Default)]\r\npub struct HoverInfo {\r\n    screen_element: Option<ElementInfo>,\r\n    game_element: Option<ElementInfo>,\r\n    enabled: bool,\r\n}\r\nimpl HoverInfo {\r\n    pub fn set_enabled(&mut self, enabled: bool) {\r\n        self.enabled = enabled;\r\n        if !enabled {\r\n            self.screen_element = None;\r\n            self.game_element = None;\r\n        }\r\n    }\r\n    pub fn is_enabled(&self) -> bool {\r\n        self.enabled\r\n    }\r\n}\r\n\r\n#[derive(Component, Reflect)]\r\npub struct HoveredElement {\r\n    pub info: ElementInfo,\r\n}\r\n\r\nfn setup(mut commands: Commands) {\r\n    let (game_tx, game_rx) = bounded::<_>(10);\r\n    let (thread_tx, thread_rx) = bounded::<_>(10);\r\n    commands.insert_resource(Bridge {\r\n        sender: thread_tx,\r\n        receiver: game_rx,\r\n    });\r\n\r\n    let game_tx_clone = game_tx.clone();\r\n    thread::Builder::new()\r\n        .name(\"Screen element hover info thread\".to_string())\r\n        .spawn(move || {\r\n            let game_tx = game_tx_clone;\r\n            loop {\r\n                if let Ok(cursor_pos) = get_cursor_position() {\r\n                    if let Ok(root) = find_element_at(cursor_pos) {\r\n                        let info = gather_single_element_info(&root);\r\n                        match info {\r\n                            Ok(info) => {\r\n                                game_tx\r\n                                    .send(GameboundMessage::ScreenHoverInfo(info))\r\n                                    .unwrap();\r\n                            }\r\n                            Err(_) => {\r\n                                game_tx.send(GameboundMessage::ScreenHoverInfoNone).unwrap();\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                std::thread::sleep(std::time::Duration::from_millis(50));\r\n            }\r\n        })\r\n        .expect(\"Failed to spawn screen element hover info thread\");\r\n\r\n    thread::Builder::new()\r\n        .name(\"Game element hover info thread\".to_string())\r\n        .spawn(move || {\r\n            loop {\r\n                // Block until at least one message is available\r\n                let mut msg = match thread_rx.recv() {\r\n                    Ok(msg) => msg,\r\n                    Err(e) => {\r\n                        error!(\"Failed to receive thread message, exiting: {:?}\", e);\r\n                        break;\r\n                    }\r\n                };\r\n\r\n                // Check for and use the latest message available\r\n                while let Ok(newer_msg) = thread_rx.try_recv() {\r\n                    msg = newer_msg;\r\n                }\r\n                match msg {\r\n                    ThreadboundMessage::CursorPositionNone => {\r\n                        game_tx.send(GameboundMessage::GameHoverInfoNone).unwrap();\r\n                        continue;\r\n                    }\r\n                    ThreadboundMessage::CursorPosition(cursor_pos) => {\r\n                        if let Ok(root) = find_element_at(cursor_pos) {\r\n                            let info = gather_single_element_info(&root);\r\n                            match info {\r\n                                Ok(info) => {\r\n                                    game_tx.send(GameboundMessage::GameHoverInfo(info)).unwrap();\r\n                                }\r\n                                Err(_) => {\r\n                                    game_tx.send(GameboundMessage::GameHoverInfoNone).unwrap();\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                std::thread::sleep(std::time::Duration::from_millis(50));\r\n            }\r\n        })\r\n        .expect(\"Failed to spawn game element hover info thread\");\r\n}\r\n\r\nfn update_game_mouse_position(\r\n    bridge: ResMut<Bridge>,\r\n    camera_query: Query<(&Camera, &GlobalTransform), With<MainCamera>>,\r\n    window_query: Query<&Window, With<PrimaryWindow>>,\r\n    mut debounce: Local<Option<IVec2>>,\r\n    hover_info: Res<HoverInfo>,\r\n) {\r\n    if !hover_info.enabled {\r\n        return;\r\n    }\r\n    let (camera, camera_transform) = camera_query.single();\r\n    let window = window_query.single();\r\n    let value = window\r\n        .cursor_position()\r\n        .and_then(|cursor| camera.viewport_to_world(camera_transform, cursor))\r\n        .map(|ray| ray.origin.truncate())\r\n        .map(|world_position| IVec2::new(world_position.x as i32, -world_position.y as i32));\r\n    if *debounce != value {\r\n        *debounce = value;\r\n        match value {\r\n            Some(value) => bridge\r\n                .sender\r\n                .send(ThreadboundMessage::CursorPosition(value))\r\n                .unwrap(),\r\n            None => bridge\r\n                .sender\r\n                .send(ThreadboundMessage::CursorPositionNone)\r\n                .unwrap(),\r\n        }\r\n    }\r\n}\r\n\r\nfn update_hover_info(mut hovered: ResMut<HoverInfo>, bridge: Res<Bridge>) {\r\n    if !hovered.enabled {\r\n        bridge.receiver.try_iter().for_each(drop);\r\n        return;\r\n    }\r\n    if let Ok(msg) = bridge.receiver.try_recv() {\r\n        match msg {\r\n            GameboundMessage::ScreenHoverInfo(info) => {\r\n                hovered.screen_element = Some(info);\r\n            }\r\n            GameboundMessage::ScreenHoverInfoNone => {\r\n                hovered.screen_element = None;\r\n            }\r\n            GameboundMessage::GameHoverInfo(info) => {\r\n                hovered.game_element = Some(info);\r\n            }\r\n            GameboundMessage::GameHoverInfoNone => {\r\n                hovered.game_element = None;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n#[derive(Component, Reflect, Debug)]\r\nstruct ScreenHoveredIndicatorTag;\r\n#[derive(Component, Reflect, Debug)]\r\nstruct GameHoveredIndicatorTag;\r\n\r\n#[allow(clippy::type_complexity)]\r\nfn show_hovered_rect(\r\n    mut screen_indicator: Query<\r\n        (Entity, &mut Sprite, &mut Transform, &mut HoveredElement),\r\n        (\r\n            With<ScreenHoveredIndicatorTag>,\r\n            Without<GameHoveredIndicatorTag>,\r\n        ),\r\n    >,\r\n    mut game_indicator: Query<\r\n        (Entity, &mut Sprite, &mut Transform, &mut HoveredElement),\r\n        (\r\n            With<GameHoveredIndicatorTag>,\r\n            Without<ScreenHoveredIndicatorTag>,\r\n        ),\r\n    >,\r\n    hovered: Res<HoverInfo>,\r\n    mut commands: Commands,\r\n) {\r\n    if let Ok((entity, mut sprite, mut transform, mut element)) = screen_indicator.get_single_mut()\r\n    {\r\n        if let Some(info) = &hovered.screen_element {\r\n            let bounds = info.bounding_rect.as_rect();\r\n            sprite.custom_size = Some(Vec2::new(bounds.width(), bounds.height()));\r\n            transform.translation = Vec3::new(\r\n                bounds.min.x + bounds.width() / 2.,\r\n                -bounds.min.y - bounds.height() / 2.,\r\n                0.,\r\n            );\r\n            element.info = info.clone();\r\n        } else {\r\n            commands.entity(entity).despawn_recursive();\r\n        }\r\n    } else if let Some(info) = &hovered.screen_element {\r\n        let bounds = info.bounding_rect.as_rect();\r\n        commands.spawn((\r\n            SpriteBundle {\r\n                transform: Transform::from_xyz(\r\n                    bounds.min.x + bounds.width() / 2.,\r\n                    -bounds.min.y - bounds.height() / 2.,\r\n                    0.,\r\n                ),\r\n                sprite: Sprite {\r\n                    custom_size: Some(Vec2::new(bounds.width(), bounds.height())),\r\n                    color: Color::rgba(0.141, 0.675, 0.949, 0.05),\r\n                    ..default()\r\n                },\r\n                ..default()\r\n            },\r\n            Name::new(\"Screen Hovered Indicator\"),\r\n            ScreenHoveredIndicatorTag,\r\n            HoveredElement { info: info.clone() },\r\n        ));\r\n    }\r\n\r\n    if let Ok((entity, mut sprite, mut transform, mut element)) = game_indicator.get_single_mut() {\r\n        if let Some(info) = &hovered.game_element {\r\n            let bounds = info.bounding_rect.as_rect();\r\n            sprite.custom_size = Some(Vec2::new(bounds.width(), bounds.height()));\r\n            transform.translation = Vec3::new(\r\n                bounds.min.x + bounds.width() / 2.,\r\n                -bounds.min.y - bounds.height() / 2.,\r\n                0.,\r\n            );\r\n            element.info = info.clone();\r\n        } else {\r\n            commands.entity(entity).despawn_recursive();\r\n        }\r\n    } else if let Some(info) = &hovered.game_element {\r\n        let bounds = info.bounding_rect.as_rect();\r\n        commands.spawn((\r\n            SpriteBundle {\r\n                transform: Transform::from_xyz(\r\n                    bounds.min.x + bounds.width() / 2.,\r\n                    -bounds.min.y - bounds.height() / 2.,\r\n                    0.,\r\n                ),\r\n                sprite: Sprite {\r\n                    custom_size: Some(Vec2::new(bounds.width(), bounds.height())),\r\n                    color: Color::rgba(0.641, 0.275, 0.649, 0.05),\r\n                    ..default()\r\n                },\r\n                ..default()\r\n            },\r\n            Name::new(\"Game Hovered Indicator\"),\r\n            GameHoveredIndicatorTag,\r\n            HoveredElement { info: info.clone() },\r\n        ));\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\movement_tool\\src\\lib.rs\r\n\r\n````rust\r\npub mod movement_speed_plugin;\r\npub mod movement_sprint_plugin;\r\npub mod movement_target_plugin;\r\npub mod movement_tool_plugin;\r\npub mod movement_tool_populate_plugin;\r\npub mod movement_tool_tick_plugin;\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ollama\\src\\ollama_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n\r\nuse crate::ollama_button_plugin::OllamaButtonPlugin;\r\nuse crate::ollama_inference_plugin::OllamaInferencePlugin;\r\nuse crate::ollama_status_plugin::OllamaStatusPlugin;\r\nuse crate::ollama_status_worker_plugin::OllamaStatusWorkerPlugin;\r\n\r\npub struct OllamaPlugin;\r\n\r\nimpl Plugin for OllamaPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_plugins(OllamaInferencePlugin);\r\n        app.add_plugins(OllamaButtonPlugin);\r\n        app.add_plugins(OllamaStatusPlugin);\r\n        app.add_plugins(OllamaStatusWorkerPlugin);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\character_types\\src\\character_types_plugin.rs\r\n\r\n````rust\r\nuse crate::character_types::*;\r\nuse bevy::prelude::*;\r\npub struct CharacterTypesPlugin;\r\n\r\nimpl Plugin for CharacterTypesPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<Character>();\r\n        app.register_type::<MainCharacter>();\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\floaty_nametag\\src\\floaty_nametag_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse bevy::transform::TransformSystem;\r\nuse bevy_xpbd_2d::prelude::*;\r\nuse cursor_hero_floaty_nametag_types::prelude::*;\r\n\r\npub struct FloatyNametagPlugin;\r\n\r\nimpl Plugin for FloatyNametagPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Update, spawn_nametags);\r\n        app.add_systems(\r\n            PostUpdate,\r\n            update_nametags\r\n                .after(PhysicsSet::Sync)\r\n                .before(TransformSystem::TransformPropagate),\r\n        );\r\n    }\r\n}\r\n\r\nfn spawn_nametags(\r\n    mut commands: Commands,\r\n    query: Query<(Entity, &GlobalTransform, &FloatyName), Added<FloatyName>>,\r\n    asset_server: Res<AssetServer>,\r\n) {\r\n    for entry in query.iter() {\r\n        let (owner, transform, name) = entry;\r\n        debug!(\"Spawning nametag for {:?}\", name.text.clone());\r\n        let ratio = 2.0;\r\n        commands.spawn((\r\n            Name::new(format!(\"FloatyNametag: {}\", name.text.clone())),\r\n            FloatyNametag { owner },\r\n            Text2dBundle {\r\n                text: Text::from_section(\r\n                    name.text.clone(),\r\n                    TextStyle {\r\n                        font: asset_server.load(name.appearance.get_font_path()),\r\n                        font_size: 18.0 * ratio,\r\n                        color: name.appearance.get_text_color(),\r\n                    },\r\n                )\r\n                .with_alignment(TextAlignment::Center),\r\n                transform: Transform::from_translation(\r\n                    transform.translation() + Vec3::new(0.0, name.vertical_offset, 0.0),\r\n                )\r\n                .with_scale(Vec3::new(1.0 / ratio, 1.0 / ratio, 1.0)),\r\n                ..default()\r\n            },\r\n        ));\r\n    }\r\n}\r\n\r\nfn update_nametags(\r\n    mut commands: Commands,\r\n    owner_query: Query<(Ref<GlobalTransform>, Ref<FloatyName>), Without<FloatyNametag>>,\r\n    mut floaty_query: Query<\r\n        (Entity, &mut Text, &mut Transform, &FloatyNametag),\r\n        Without<FloatyName>,\r\n    >,\r\n) {\r\n    for floaty in floaty_query.iter_mut() {\r\n        let (entity, mut text, mut transform, nametag) = floaty;\r\n        let Ok(owner) = owner_query.get(nametag.owner) else {\r\n            debug!(\"Owner of nametag {:?} not found, despawning\", nametag.owner);\r\n            commands.entity(entity).despawn_recursive();\r\n            continue;\r\n        };\r\n        let (owner_transform, owner_floaty_name) = owner;\r\n        if !owner_transform.is_changed() && !owner_floaty_name.is_changed() {\r\n            continue;\r\n        }\r\n        text.sections[0].value = owner_floaty_name.text.clone();\r\n        transform.translation =\r\n            owner_transform.translation() + Vec3::new(0.0, owner_floaty_name.vertical_offset, 0.0);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\version\\src\\lib.rs\r\n\r\n````rust\r\npub mod version_plugin;\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\window_swap_tool_types\\src\\window_swap_tool_types_plugin.rs\r\n\r\n````rust\r\nuse crate::prelude::*;\r\nuse bevy::prelude::*;\r\n\r\npub struct WindowSwapToolTypesPlugin;\r\n\r\nimpl Plugin for WindowSwapToolTypesPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<WindowSwapTool>();\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\worker_types\\src\\worker_types_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n// use crate::prelude::*;\r\n\r\npub struct WorkerTypesPlugin;\r\n\r\nimpl Plugin for WorkerTypesPlugin {\r\n    fn build(&self, _app: &mut App) {\r\n        // app.register_type::<MyComponent>();\r\n        // app.add_event::<MyEvent>();\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\tools\\src\\cube_tool.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse bevy_xpbd_2d::prelude::*;\r\nuse leafwing_input_manager::prelude::*;\r\n\r\nuse cursor_hero_character_types::prelude::*;\r\nuse cursor_hero_physics::damping_plugin::MovementDamping;\r\nuse cursor_hero_pointer_types::prelude::*;\r\n\r\nuse cursor_hero_toolbelt_types::prelude::*;\r\n\r\nuse crate::prelude::*;\r\n\r\npub struct CubeToolPlugin;\r\n\r\nimpl Plugin for CubeToolPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<CubeTool>();\r\n        app.register_type::<CubeToolInteractable>();\r\n        app.add_plugins(InputManagerPlugin::<CubeToolAction>::default());\r\n        app.add_systems(Update, (toolbelt_events, handle_input));\r\n    }\r\n}\r\n\r\n#[derive(Component, Reflect, Default)]\r\nstruct CubeTool;\r\n\r\nfn toolbelt_events(\r\n    mut commands: Commands,\r\n    asset_server: Res<AssetServer>,\r\n    mut reader: EventReader<ToolbeltPopulateEvent>,\r\n) {\r\n    for event in reader.read() {\r\n        let ToolbeltLoadout::Inspector = event.loadout else {\r\n            continue;\r\n        };\r\n        ToolSpawnConfig::<CubeTool, CubeToolAction>::new(CubeTool, event.id, event)\r\n            .with_src_path(file!().into())\r\n            .guess_name(file!())\r\n            .guess_image(file!(), &asset_server, \"png\")\r\n            .with_description(\"Spawn and attract cubes\")\r\n            .spawn(&mut commands);\r\n    }\r\n}\r\n\r\n#[derive(Actionlike, PartialEq, Eq, Clone, Copy, Hash, Debug, Reflect)]\r\nenum CubeToolAction {\r\n    Spawn,\r\n    Remove,\r\n    Attract,\r\n    KillAll,\r\n}\r\n\r\nimpl CubeToolAction {\r\n    fn default_gamepad_binding(&self) -> UserInput {\r\n        match self {\r\n            Self::Spawn => GamepadButtonType::South.into(),\r\n            Self::Remove => GamepadButtonType::East.into(),\r\n            Self::Attract => GamepadButtonType::LeftTrigger.into(),\r\n            Self::KillAll => GamepadButtonType::West.into(),\r\n        }\r\n    }\r\n\r\n    fn default_mkb_binding(&self) -> UserInput {\r\n        match self {\r\n            Self::Spawn => KeyCode::Q.into(),\r\n            Self::Remove => KeyCode::R.into(),\r\n            Self::Attract => KeyCode::F.into(),\r\n            Self::KillAll => KeyCode::X.into(),\r\n        }\r\n    }\r\n}\r\nimpl ToolAction for CubeToolAction {\r\n    fn default_input_map(_event: &ToolbeltPopulateEvent) -> Option<InputMap<CubeToolAction>> {\r\n        let mut input_map = InputMap::default();\r\n\r\n        for variant in CubeToolAction::variants() {\r\n            input_map.insert(variant.default_mkb_binding(), variant);\r\n            input_map.insert(variant.default_gamepad_binding(), variant);\r\n        }\r\n        Some(input_map)\r\n    }\r\n}\r\n\r\n#[derive(Component, Reflect)]\r\npub struct CubeToolInteractable;\r\n\r\nfn handle_input(\r\n    mut commands: Commands,\r\n    tools: Query<(&ActionState<CubeToolAction>, &Parent), With<ActiveTool>>,\r\n    toolbelts: Query<&Parent, With<Toolbelt>>,\r\n    characters: Query<&Children, With<Character>>,\r\n    pointers: Query<&GlobalTransform, With<Pointer>>,\r\n    mut cubes: Query<(Entity, &GlobalTransform, &mut LinearVelocity), With<CubeToolInteractable>>,\r\n) {\r\n    for tool in tools.iter() {\r\n        let (tool_actions, tool_parent) = tool;\r\n\r\n        let Ok(toolbelt) = toolbelts.get(tool_parent.get()) else {\r\n            warn!(\"Tool not inside a toolbelt?\");\r\n            continue;\r\n        };\r\n        let toolbelt_parent = toolbelt;\r\n\r\n        let Ok(character) = characters.get(toolbelt_parent.get()) else {\r\n            warn!(\"Toolbelt parent not a character?\");\r\n            continue;\r\n        };\r\n        let character_children = character;\r\n\r\n        let Some(pointer) = character_children\r\n            .iter()\r\n            .filter_map(|x| pointers.get(*x).ok())\r\n            .next()\r\n        else {\r\n            //TODO: warn if more than one pointer found\r\n            warn!(\"Character {:?} missing a pointer?\", toolbelt_parent.get());\r\n            debug!(\"Character children: {:?}\", character_children);\r\n            continue;\r\n        };\r\n        let pointer_transform = pointer;\r\n\r\n        if tool_actions.just_pressed(CubeToolAction::Spawn) {\r\n            info!(\"Spawn Cube\");\r\n            commands.spawn((\r\n                CubeToolInteractable,\r\n                MovementDamping { factor: 0.98 },\r\n                SpriteBundle {\r\n                    sprite: Sprite {\r\n                        custom_size: Some(Vec2::new(15.0, 15.0)),\r\n                        ..default()\r\n                    },\r\n                    transform: Transform::from_translation(pointer_transform.translation()),\r\n                    ..default()\r\n                },\r\n                RigidBody::Dynamic,\r\n                Collider::cuboid(15.0, 15.0),\r\n                Name::new(\"Cube\"),\r\n            ));\r\n        }\r\n        if tool_actions.just_pressed(CubeToolAction::Remove) {\r\n            info!(\"Remove Cube\");\r\n            // remove the cube closest to the pointer\r\n            let mut closest_cube = None;\r\n            let mut closest_dist = f32::MAX;\r\n            for (c_e, c_t, _) in cubes.iter() {\r\n                let dist = c_t.translation().distance(pointer_transform.translation());\r\n                if dist < closest_dist {\r\n                    closest_cube = Some(c_e);\r\n                    closest_dist = dist;\r\n                }\r\n            }\r\n            if let Some(cube) = closest_cube {\r\n                commands.entity(cube).despawn_recursive();\r\n            }\r\n        }\r\n        if tool_actions.just_pressed(CubeToolAction::KillAll) {\r\n            info!(\"Kill All Cubes\");\r\n            // remove all cubes\r\n            for (c_e, _, _) in cubes.iter() {\r\n                commands.entity(c_e).despawn_recursive();\r\n            }\r\n        }\r\n        if tool_actions.pressed(CubeToolAction::Attract) {\r\n            if tool_actions.just_pressed(CubeToolAction::Attract) {\r\n                info!(\"Attract Cube\");\r\n            }\r\n            // add a force to all cubes towards the pointer\r\n            for (_, c_t, mut c_v) in cubes.iter_mut() {\r\n                let diff = pointer.translation() - c_t.translation();\r\n                let force = diff.normalize() * 100.0;\r\n                c_v.x += force.x;\r\n                c_v.y += force.y;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui_automation_types\\src\\ui_automation_error_types.rs\r\n\r\n````rust\r\nuse crate::prelude::VSCodeResolveError;\r\nuse crate::ui_automation_drill::DrillError;\r\nuse std::fmt;\r\n\r\n#[derive(Debug)]\r\npub enum AppResolveError {\r\n    UI(uiautomation::Error),\r\n    BadStructure(String),\r\n}\r\nimpl From<uiautomation::Error> for AppResolveError {\r\n    fn from(e: uiautomation::Error) -> Self {\r\n        AppResolveError::UI(e)\r\n    }\r\n}\r\nimpl From<DrillError> for AppResolveError {\r\n    fn from(e: DrillError) -> Self {\r\n        match e {\r\n            DrillError::UI(e) => AppResolveError::UI(e),\r\n            DrillError::EmptyPath => AppResolveError::BadStructure(\"Empty path\".to_string()),\r\n            DrillError::BadPath => AppResolveError::BadStructure(\"Bad path\".to_string()),\r\n            DrillError::OutOfBounds {\r\n                given,\r\n                max,\r\n                error: e,\r\n            } => AppResolveError::BadStructure(format!(\r\n                \"Out of bounds: given: {}, max: {}, error: {}\",\r\n                given, max, e\r\n            )),\r\n        }\r\n    }\r\n}\r\nimpl From<VSCodeResolveError> for AppResolveError {\r\n    fn from(e: VSCodeResolveError) -> Self {\r\n        match e {\r\n            VSCodeResolveError::UnknownSideTabKind(s) => {\r\n                AppResolveError::BadStructure(format!(\"Unknown VSCode side tab kind: {}\", s))\r\n            }\r\n            VSCodeResolveError::UnknownState { kids } => {\r\n                AppResolveError::BadStructure(format!(\"Unknown VSCode state, kids: {:?}\", kids))\r\n            }\r\n            VSCodeResolveError::UI(e) => AppResolveError::UI(e),\r\n        }\r\n    }\r\n}\r\n\r\nimpl fmt::Display for AppResolveError {\r\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\r\n        // Write a descriptive message for the error.\r\n        write!(f, \"{:?}\", self)\r\n    }\r\n}\r\nimpl std::error::Error for AppResolveError {}\r\n\r\n#[derive(Debug)]\r\npub enum GatherAppsError {\r\n    UI(uiautomation::Error),\r\n    NoneMatch,\r\n    ResolveFailed(Vec<anyhow::Error>),\r\n}\r\nimpl From<uiautomation::Error> for GatherAppsError {\r\n    fn from(e: uiautomation::Error) -> Self {\r\n        GatherAppsError::UI(e)\r\n    }\r\n}\r\n\r\nimpl fmt::Display for GatherAppsError {\r\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\r\n        // Write a descriptive message for the error.\r\n        write!(f, \"{:?}\", self)\r\n    }\r\n}\r\nimpl std::error::Error for GatherAppsError {}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\host_fs_types\\src\\host_fs_types_plugin.rs\r\n\r\n````rust\r\nuse crate::prelude::*;\r\nuse bevy::prelude::*;\r\n\r\npub struct HostFsTypesPlugin;\r\n\r\nimpl Plugin for HostFsTypesPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<HostPath>();\r\n        app.add_event::<HostPathAction>();\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\toolbelt\\src\\toolbelt_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse leafwing_input_manager::prelude::*;\r\n\r\nuse crate::hover_frame::insert_hover_frame;\r\nuse crate::hover_frame::remove_hover_frame;\r\nuse crate::tool_activation::tool_activation;\r\nuse crate::tool_color::tool_color;\r\nuse crate::tool_help_activate::tool_help_activation;\r\nuse crate::tool_help_cleanup::tool_help_cleanup;\r\nuse crate::tool_help_click::help_click_listener;\r\nuse crate::tool_help_populate::tool_help_lifecycle;\r\nuse crate::tool_visibility::tool_visibility;\r\nuse crate::toolbelt_circle_layout_plugin::ToolbeltCircleLayoutPlugin;\r\nuse crate::toolbelt_opening_plugin::ToolbeltOpeningPlugin;\r\nuse crate::toolbelt_properties_plugin::ToolbeltPropertiesPlugin;\r\nuse crate::toolbelt_taskbar_layout_plugin::ToolbeltTaskbarLayoutPlugin;\r\nuse crate::wheel_audio::wheel_audio;\r\nuse cursor_hero_toolbelt_types::toolbelt_types::*;\r\npub struct ToolbeltPlugin;\r\n\r\nimpl Plugin for ToolbeltPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_plugins(ToolbeltOpeningPlugin);\r\n        app.add_plugins(ToolbeltPropertiesPlugin);\r\n        app.add_plugins(ToolbeltCircleLayoutPlugin);\r\n        app.add_plugins(ToolbeltTaskbarLayoutPlugin);\r\n        app.add_plugins(InputManagerPlugin::<ToolbeltAction>::default());\r\n        app.add_systems(Update, help_click_listener);\r\n        app.add_systems(Update, insert_hover_frame);\r\n        app.add_systems(Update, remove_hover_frame);\r\n        app.add_systems(Update, tool_color);\r\n        app.add_systems(Update, tool_activation);\r\n        app.add_systems(Update, tool_help_cleanup);\r\n        app.add_systems(\r\n            Update,\r\n            (\r\n                wheel_audio,\r\n                tool_visibility,\r\n                tool_help_activation,\r\n                tool_help_lifecycle,\r\n            )\r\n                .chain(),\r\n        );\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui_automation\\src\\formatting.rs\r\n\r\n````rust\r\nuse uiautomation::UIAutomation;\r\nuse uiautomation::UIElement;\r\n\r\npub fn get_tree_string(element: &UIElement) -> Result<String, uiautomation::Error> {\r\n    let automation = UIAutomation::new()?;\r\n    format_tree_recursive(element, &automation, 0)\r\n}\r\nfn format_tree_recursive(\r\n    element: &UIElement,\r\n    automation: &UIAutomation,\r\n    depth: usize,\r\n) -> Result<String, uiautomation::Error> {\r\n    // Format the current element's label.\r\n    let mut result = format!(\r\n        \"{}{}\\n\",\r\n        \" \".repeat(depth * 2), // Increase indentation with depth.\r\n        format_tree_label(element)\r\n    );\r\n\r\n    // Use the TreeWalker to navigate the children.\r\n    let walker = automation.create_tree_walker()?;\r\n    if let Ok(child) = walker.get_first_child(element) {\r\n        // Recursively format the child and any siblings.\r\n        result.push_str(&format_tree_recursive(&child, automation, depth + 1)?);\r\n        let mut next_sibling = child;\r\n        while let Ok(sibling) = walker.get_next_sibling(&next_sibling) {\r\n            result.push_str(&format_tree_recursive(&sibling, automation, depth + 1)?);\r\n            next_sibling = sibling;\r\n        }\r\n    }\r\n    Ok(result)\r\n}\r\nfn format_tree_label(element: &UIElement) -> String {\r\n    format!(\r\n        \"name={} control_type={} class_name={} runtime_id={} rect={}\",\r\n        element\r\n            .get_name()\r\n            .map(|name| format!(\"{:?}\", name))\r\n            .unwrap_or_else(|_| \"(null)\".to_string()),\r\n        element\r\n            .get_control_type()\r\n            .map(|ct| format!(\"{:?}\", ct))\r\n            .unwrap_or_else(|_| \"unknown control type\".to_string()),\r\n        element\r\n            .get_classname()\r\n            .map(|name| format!(\"{:?}\", name))\r\n            .unwrap_or_else(|_| \"(null)\".to_string()),\r\n        element\r\n            .get_runtime_id()\r\n            .map(|id| format!(\"{:?}\", id))\r\n            .unwrap_or_else(|_| \"(null)\".to_string()),\r\n        element\r\n            .get_bounding_rectangle()\r\n            .map(|rect| format!(\"{:?}\", rect))\r\n            .unwrap_or_else(|_| \"(null)\".to_string()),\r\n    )\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\app_types\\src\\app_types_plugin.rs\r\n\r\n````rust\r\nuse crate::prelude::*;\r\nuse bevy::prelude::*;\r\n\r\npub struct AppTypesPlugin;\r\n\r\nimpl Plugin for AppTypesPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<MyComponent>();\r\n        app.add_event::<MyEvent>();\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\character\\src\\character_spawning_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n\r\nuse bevy_xpbd_2d::prelude::*;\r\n\r\nuse cursor_hero_bevy::prelude::NegativeYVec2;\r\nuse cursor_hero_camera::camera_plugin::CameraEvent;\r\nuse cursor_hero_character_types::prelude::*;\r\nuse cursor_hero_environment_types::prelude::*;\r\nuse cursor_hero_physics::damping_plugin::MovementDamping;\r\nuse cursor_hero_toolbelt_types::toolbelt_types::ToolbeltBundle;\r\nuse cursor_hero_toolbelt_types::toolbelt_types::ToolbeltLoadout;\r\nuse cursor_hero_toolbelt_types::toolbelt_types::ToolbeltPopulateEvent;\r\nuse cursor_hero_winutils::win_mouse::get_cursor_position;\r\npub struct CharacterSpawningPlugin;\r\n\r\nimpl Plugin for CharacterSpawningPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Startup, spawn_character);\r\n    }\r\n}\r\n\r\nfn spawn_character(\r\n    mut commands: Commands,\r\n    asset_server: Res<AssetServer>,\r\n    mut camera_events: EventWriter<CameraEvent>,\r\n    mut writer: EventWriter<ToolbeltPopulateEvent>,\r\n) {\r\n    let os_cursor_pos = match get_cursor_position() {\r\n        Ok(pos) => pos,\r\n        Err(e) => {\r\n            error!(\r\n                \"Failed to get cursor position, spawning character at (0,0): {}\",\r\n                e\r\n            );\r\n            IVec2::ZERO\r\n        }\r\n    };\r\n    let mut character = commands.spawn((\r\n        SpriteBundle {\r\n            texture: asset_server.load(CharacterAppearance::Focused.get_texture_path()),\r\n            sprite: Sprite {\r\n                custom_size: Some(Vec2::new(50.0, 50.0)),\r\n                ..default()\r\n            },\r\n            transform: Transform::from_translation(os_cursor_pos.as_vec2().neg_y().extend(100.0)),\r\n            ..default()\r\n        },\r\n        Character,\r\n        MainCharacter,\r\n        MovementDamping { factor: 0.90 },\r\n        Name::new(\"Character - (Human) Tume Eena\"),\r\n        // FloatyName {\r\n        //     text: \"Tume Eena\".to_string(),\r\n        //     vertical_offset: 40.0,\r\n        //     appearance: NametagAppearance::Character,\r\n        // },\r\n        RigidBody::Kinematic,\r\n        Collider::capsule(15.0, 12.5),\r\n        TrackEnvironmentTag,\r\n    ));\r\n    camera_events.send(CameraEvent::BeginFollowing {\r\n        target_id: character.id(),\r\n    });\r\n    let character_id = character.id();\r\n    character.with_children(|c_commands| {\r\n        let toolbelt = c_commands.spawn(ToolbeltBundle::default());\r\n        writer.send(ToolbeltPopulateEvent {\r\n            id: toolbelt.id(),\r\n            loadout: ToolbeltLoadout::default(),\r\n        });\r\n        info!(\r\n            \"Sent populate default toolbelt event to fresh main character {:?}\",\r\n            character_id\r\n        );\r\n    });\r\n\r\n    info!(\"Spawned character\");\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\icon\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_icon\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\nimage = { workspace = true }\r\nwinit = { workspace = true }\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ollama\\src\\ollama_button_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse bevy_xpbd_2d::prelude::*;\r\nuse cursor_hero_environment_types::prelude::*;\r\nuse cursor_hero_math::prelude::Lerp;\r\nuse cursor_hero_ollama_types::prelude::*;\r\nuse cursor_hero_pointer_types::prelude::*;\r\npub struct OllamaButtonPlugin;\r\n\r\nimpl Plugin for OllamaButtonPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Update, populate_new_host_environments);\r\n        app.add_systems(Update, update_visuals);\r\n        app.add_systems(Update, status_click_listener);\r\n        app.add_systems(Update, terminal_click_listener);\r\n        app.add_systems(Update, handle_terminal_events);\r\n    }\r\n}\r\n\r\nfn populate_new_host_environments(\r\n    mut commands: Commands,\r\n    mut environment_events: EventReader<PopulateEnvironmentEvent>,\r\n    environment_query: Query<(), With<HostEnvironment>>,\r\n    asset_server: Res<AssetServer>,\r\n) {\r\n    for event in environment_events.read() {\r\n        if !environment_query.contains(event.environment_id) {\r\n            continue;\r\n        };\r\n        let environment_id = event.environment_id;\r\n        info!(\r\n            \"Adding Ollama Server Control to new host environment {:?}\",\r\n            environment_id\r\n        );\r\n        commands.entity(environment_id).with_children(|parent| {\r\n            parent\r\n                .spawn((\r\n                    OllamaStatusButton::default(),\r\n                    Name::new(\"Ollama Server Control\"),\r\n                    SpriteBundle {\r\n                        sprite: Sprite {\r\n                            custom_size: Some(Vec2::new(200.0, 100.0)),\r\n                            color: Color::PURPLE,\r\n                            ..default()\r\n                        },\r\n                        transform: Transform::from_translation(Vec3::new(\r\n                            1920.0 / 2.0,\r\n                            -1080.0 - 200.0,\r\n                            0.0,\r\n                        )),\r\n                        ..default()\r\n                    },\r\n                    Clickable,\r\n                    Hoverable,\r\n                    RigidBody::Static,\r\n                    Sensor,\r\n                    Collider::cuboid(200.0, 100.0),\r\n                ))\r\n                .with_children(|parent| {\r\n                    parent.spawn((Text2dBundle {\r\n                        text: Text::from_section(\r\n                            \"Ollama Server Control\".to_string(),\r\n                            TextStyle {\r\n                                font: asset_server.load(\"fonts/FiraSans-Bold.ttf\"),\r\n                                font_size: 32.0,\r\n                                color: Color::WHITE,\r\n                            },\r\n                        )\r\n                        .with_alignment(TextAlignment::Center),\r\n                        transform: Transform::from_xyz(0.0, 70.0, 1.0),\r\n                        ..default()\r\n                    },));\r\n                });\r\n            parent\r\n                .spawn((\r\n                    OllamaTerminalButton::default(),\r\n                    Name::new(\"Ollama Terminal Button\"),\r\n                    SpriteBundle {\r\n                        sprite: Sprite {\r\n                            custom_size: Some(Vec2::new(200.0, 100.0)),\r\n                            color: Color::rgb(0.0, 0.6, 0.8),\r\n                            ..default()\r\n                        },\r\n                        transform: Transform::from_translation(Vec3::new(\r\n                            1920.0 / 2.0,\r\n                            -1080.0 - 350.0,\r\n                            0.0,\r\n                        )),\r\n                        ..default()\r\n                    },\r\n                    Clickable,\r\n                    Hoverable,\r\n                    RigidBody::Static,\r\n                    Sensor,\r\n                    Collider::cuboid(200.0, 100.0),\r\n                ))\r\n                .with_children(|parent| {\r\n                    parent.spawn((Text2dBundle {\r\n                        text: Text::from_section(\r\n                            \"open terminal\".to_string(),\r\n                            TextStyle {\r\n                                font: asset_server.load(\"fonts/FiraSans-Bold.ttf\"),\r\n                                font_size: 32.0,\r\n                                color: Color::WHITE,\r\n                            },\r\n                        )\r\n                        .with_alignment(TextAlignment::Center),\r\n                        transform: Transform::from_xyz(0.0, 0.0, 1.0),\r\n                        ..default()\r\n                    },));\r\n                });\r\n        });\r\n    }\r\n}\r\n\r\nfn update_visuals(\r\n    mut events: EventReader<OllamaStatusEvent>,\r\n    mut button_query: Query<(&mut Sprite, &Children, &mut OllamaStatusButton)>,\r\n    mut button_text_query: Query<&mut Text>,\r\n) {\r\n    for event in events.read() {\r\n        let OllamaStatusEvent::Changed { new_value: status } = event else {\r\n            continue;\r\n        };\r\n        debug!(\"Updating Ollama Server Control visuals to {:?}\", status);\r\n        for button in button_query.iter_mut() {\r\n            let (mut button_sprite, button_children, mut button) = button;\r\n            button.visual_state = match button.visual_state {\r\n                OllamaStatusButtonVisualState::Default { .. } => {\r\n                    OllamaStatusButtonVisualState::Default { status: *status }\r\n                }\r\n                OllamaStatusButtonVisualState::Hovered { .. } => {\r\n                    OllamaStatusButtonVisualState::Hovered { status: *status }\r\n                }\r\n                OllamaStatusButtonVisualState::Pressed { .. } => {\r\n                    OllamaStatusButtonVisualState::Pressed { status: *status }\r\n                }\r\n            };\r\n            match status {\r\n                OllamaStatus::Alive => {\r\n                    button_sprite.color = Color::GREEN;\r\n                }\r\n                OllamaStatus::Dead => {\r\n                    button_sprite.color = Color::RED;\r\n                }\r\n                OllamaStatus::Unknown => {\r\n                    button_sprite.color = Color::PURPLE;\r\n                }\r\n                OllamaStatus::Starting { instant, timeout } => {\r\n                    button_sprite.color = Color::YELLOW\r\n                        * (1.0, 0.1).lerp(instant.elapsed().as_secs_f32() / timeout.as_secs_f32());\r\n                }\r\n            }\r\n            for child in button_children.iter() {\r\n                if let Ok(mut text) = button_text_query.get_mut(*child) {\r\n                    match status {\r\n                        OllamaStatus::Alive => {\r\n                            text.sections[0].value = \"Ollama Server Control (Alive)\".to_string();\r\n                        }\r\n                        OllamaStatus::Dead => {\r\n                            text.sections[0].value = \"Ollama Server Control (Dead)\".to_string();\r\n                        }\r\n                        OllamaStatus::Unknown => {\r\n                            text.sections[0].value = \"Ollama Server Control (Unknown)\".to_string();\r\n                        }\r\n                        OllamaStatus::Starting { instant, .. } => {\r\n                            text.sections[0].value = format!(\r\n                                \"Ollama Server Control (Starting {}s ago)\",\r\n                                instant.elapsed().as_secs()\r\n                            );\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    for button in button_query.iter_mut() {\r\n        let (mut sprite, children, button) = button;\r\n        // if the visual state status is starting, update the text to show the time elapsed\r\n        let (OllamaStatusButtonVisualState::Default {\r\n            status: OllamaStatus::Starting { instant, timeout },\r\n        }\r\n        | OllamaStatusButtonVisualState::Hovered {\r\n            status: OllamaStatus::Starting { instant, timeout },\r\n        }\r\n        | OllamaStatusButtonVisualState::Pressed {\r\n            status: OllamaStatus::Starting { instant, timeout },\r\n        }) = button.visual_state\r\n        else {\r\n            continue;\r\n        };\r\n        sprite.color = Color::YELLOW\r\n            * (1.0, 0.1).lerp(instant.elapsed().as_secs_f32() / timeout.as_secs_f32());\r\n        for child in children.iter() {\r\n            if let Ok(mut text) = button_text_query.get_mut(*child) {\r\n                text.sections[0].value = format!(\r\n                    \"Ollama Server Control (Starting {}s ago)\",\r\n                    instant.elapsed().as_secs()\r\n                );\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfn status_click_listener(\r\n    mut click_events: EventReader<ClickEvent>,\r\n    button_query: Query<&OllamaStatusButton>,\r\n    mut status_events: EventWriter<OllamaStatusEvent>,\r\n) {\r\n    for event in click_events.read() {\r\n        let ClickEvent::Clicked {\r\n            target_id,\r\n            pointer_id: _,\r\n            way,\r\n        } = event\r\n        else {\r\n            continue;\r\n        };\r\n        if way != &Way::Left {\r\n            continue;\r\n        }\r\n        if let Ok(button) = button_query.get(*target_id) {\r\n            info!(\"Ollama Server Control clicked\");\r\n            // if the button visual status is alive, do nothing\r\n            match button.visual_state {\r\n                OllamaStatusButtonVisualState::Default {\r\n                    status: OllamaStatus::Alive,\r\n                }\r\n                | OllamaStatusButtonVisualState::Hovered {\r\n                    status: OllamaStatus::Alive,\r\n                }\r\n                | OllamaStatusButtonVisualState::Pressed {\r\n                    status: OllamaStatus::Alive,\r\n                } => {\r\n                    warn!(\"Ollama Server Control is already alive\");\r\n                    continue;\r\n                }\r\n                _ => {}\r\n            }\r\n            let event = OllamaStatusEvent::Startup;\r\n            debug!(\"Sending event {:?}\", event);\r\n            status_events.send(event);\r\n        }\r\n    }\r\n}\r\n\r\nfn terminal_click_listener(\r\n    mut click_events: EventReader<ClickEvent>,\r\n    button_query: Query<&OllamaTerminalButton>,\r\n    mut terminal_events: EventWriter<OllamaTerminalEvent>,\r\n) {\r\n    for event in click_events.read() {\r\n        let ClickEvent::Clicked {\r\n            target_id,\r\n            pointer_id: _,\r\n            way,\r\n        } = event\r\n        else {\r\n            continue;\r\n        };\r\n        if way != &Way::Left {\r\n            continue;\r\n        }\r\n        if button_query.get(*target_id).is_ok() {\r\n            info!(\"Ollama terminal clicked\");\r\n            let event = OllamaTerminalEvent::Startup;\r\n            debug!(\"Sending event {:?}\", event);\r\n            terminal_events.send(event);\r\n        }\r\n    }\r\n}\r\n\r\nfn handle_terminal_events(mut terminal_events: EventReader<OllamaTerminalEvent>) {\r\n    let should_start = terminal_events\r\n        .read()\r\n        .any(|event| matches!(event, OllamaTerminalEvent::Startup));\r\n    if should_start {\r\n        info!(\"Opening terminal\");\r\n        if let Err(e) = crate::ollama::start_terminal() {\r\n            error!(\"Failed to start terminal: {:?}\", e);\r\n        }\r\n    }\r\n    terminal_events.clear();\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\screen\\src\\screen_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse cursor_hero_bevy::prelude::IExpandable;\r\nuse cursor_hero_bevy::prelude::NegativeYIRect;\r\nuse cursor_hero_environment_types::prelude::*;\r\nuse cursor_hero_level_bounds::level_bounds_plugin::LevelBoundsEvent;\r\nuse cursor_hero_winutils::win_screen_capture::get_all_monitors;\r\nuse image::DynamicImage;\r\nuse screenshots::Screen as ScreenLib;\r\nuse std::collections::VecDeque;\r\n\r\nuse crate::ToBevyIRect;\r\n\r\npub struct ScreenPlugin;\r\nimpl Plugin for ScreenPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Update, spawn_screens_in_new_environments)\r\n            .register_type::<Screen>()\r\n            .register_type::<ScreenParent>();\r\n    }\r\n}\r\n\r\n#[derive(Component, Default, Reflect)]\r\n#[reflect(Component)]\r\npub struct Screen {\r\n    pub id: u32,\r\n    pub name: String,\r\n    pub refresh_rate: Option<Timer>,\r\n}\r\n#[derive(Component, Default, Reflect)]\r\npub struct GameScreen;\r\n#[derive(Component, Default, Reflect)]\r\npub struct HostScreen;\r\n\r\n#[derive(Component, Reflect)]\r\npub struct ScreenParent;\r\n\r\nfn spawn_screens_in_new_environments(\r\n    mut populate_events: EventReader<PopulateEnvironmentEvent>,\r\n    mut commands: Commands,\r\n    mut textures: ResMut<Assets<Image>>,\r\n    mut level_bounds_events: EventWriter<LevelBoundsEvent>,\r\n    environment_query: Query<(Option<&HostEnvironment>, Option<&GameEnvironment>)>,\r\n) {\r\n    for event in populate_events.read() {\r\n        let environment_id = event.environment_id;\r\n        let Ok((is_host, is_game)) = environment_query.get(event.environment_id) else {\r\n            continue;\r\n        };\r\n        match (is_host, is_game) {\r\n            (Some(_), _) => {\r\n                info!(\"Populating host environment with screens\");\r\n                commands.entity(environment_id).with_children(|parent| {\r\n                    let mut screen_parent_commands = parent.spawn((\r\n                        SpatialBundle::default(),\r\n                        ScreenParent,\r\n                        Name::new(\"Screens\"),\r\n                    ));\r\n\r\n                    // create a Screen component for each screen\r\n                    let mut screen_names = get_all_monitors()\r\n                        .unwrap()\r\n                        .iter()\r\n                        .map(|monitor| monitor.info.name.clone())\r\n                        .collect::<VecDeque<String>>();\r\n                    // todo: remove this and use win_screen_capture\r\n\r\n                    let mut level_bounds = vec![];\r\n\r\n                    screen_parent_commands.with_children(|screen_parent| {\r\n                        for screen in ScreenLib::all().unwrap().iter() {\r\n                            let image_buf = screen.capture().unwrap();\r\n                            let dynamic_image = DynamicImage::ImageRgba8(image_buf);\r\n                            let image = Image::from_dynamic(dynamic_image, true);\r\n                            let texture = textures.add(image);\r\n                            let name = screen_names.pop_front().unwrap();\r\n                            let region = screen.display_info.to_bevy_irect().neg_y();\r\n                            screen_parent.spawn((\r\n                                SpriteBundle {\r\n                                    texture,\r\n                                    transform: Transform::from_translation(\r\n                                        region.center().extend(-1).as_vec3(),\r\n                                    ),\r\n                                    sprite: Sprite {\r\n                                        custom_size: Some(region.size().as_vec2()),\r\n                                        ..default()\r\n                                    },\r\n                                    ..Default::default()\r\n                                },\r\n                                Screen {\r\n                                    name: name.clone(),\r\n                                    id: screen.display_info.id,\r\n                                    refresh_rate: Some(Timer::from_seconds(\r\n                                        0.1,\r\n                                        TimerMode::Repeating,\r\n                                    )),\r\n                                },\r\n                                HostScreen,\r\n                                Name::new(format!(\"Screen {}\", name)),\r\n                            ));\r\n\r\n                            level_bounds.push(region.expand((400, 400).into()));\r\n                        }\r\n                    });\r\n                    info!(\"Broadcasting {} level bounds events\", level_bounds.len());\r\n                    for area in level_bounds {\r\n                        level_bounds_events.send(LevelBoundsEvent::AddPlayArea {\r\n                            environment_id,\r\n                            area: area.as_rect(),\r\n                        });\r\n                    }\r\n                });\r\n            }\r\n            (_, Some(_)) => {\r\n                commands.entity(environment_id).with_children(|parent| {\r\n                    info!(\"Populating game environment with screens\");\r\n                    let mut screen_parent_commands = parent.spawn((\r\n                        SpatialBundle::default(),\r\n                        ScreenParent,\r\n                        Name::new(\"Screens\"),\r\n                    ));\r\n\r\n                    let mut level_bounds = vec![];\r\n\r\n                    screen_parent_commands.with_children(|screen_parent| {\r\n                        let region =\r\n                            IRect::from_corners(IVec2::new(0, 0), IVec2::new(1920, 1080)).neg_y();\r\n                        let name = \"Primary Screen\".to_string();\r\n                        screen_parent.spawn((\r\n                            SpriteBundle {\r\n                                sprite: Sprite {\r\n                                    custom_size: Some(region.size().as_vec2()),\r\n                                    ..default()\r\n                                },\r\n                                transform: Transform::from_translation(\r\n                                    region.center().extend(-1).as_vec3(),\r\n                                ),\r\n                                ..Default::default()\r\n                            },\r\n                            Screen {\r\n                                name: name.to_string(),\r\n                                id: 1,\r\n                                refresh_rate: None,\r\n                            },\r\n                            GameScreen,\r\n                            Name::new(name),\r\n                        ));\r\n\r\n                        level_bounds.push(region.expand((400, 400).into()));\r\n                    });\r\n                    info!(\"Broadcasting {} level bounds events\", level_bounds.len());\r\n                    for area in level_bounds {\r\n                        level_bounds_events.send(LevelBoundsEvent::AddPlayArea {\r\n                            environment_id,\r\n                            area: area.as_rect(),\r\n                        });\r\n                    }\r\n                });\r\n            }\r\n            (None, None) => {\r\n                error!(\r\n                    \"Environment {:?} is not a host or game environment\",\r\n                    environment_id\r\n                );\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\voice_to_text\\src\\voice_to_text_button_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse bevy_xpbd_2d::prelude::*;\r\nuse cursor_hero_environment_types::prelude::*;\r\nuse cursor_hero_math::prelude::Lerp;\r\nuse cursor_hero_pointer_types::prelude::*;\r\nuse cursor_hero_voice_to_text_types::prelude::*;\r\n\r\npub struct VoiceToTextButtonPlugin;\r\n\r\nimpl Plugin for VoiceToTextButtonPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Update, populate_new_host_environments);\r\n        app.add_systems(Update, update_visuals);\r\n        app.add_systems(Update, status_button_click);\r\n        app.add_systems(Update, vscode_button_click);\r\n        app.add_systems(Update, handle_vscode_events);\r\n    }\r\n}\r\n\r\nfn populate_new_host_environments(\r\n    mut commands: Commands,\r\n    mut environment_events: EventReader<PopulateEnvironmentEvent>,\r\n    environment_query: Query<(), With<HostEnvironment>>,\r\n    asset_server: Res<AssetServer>,\r\n) {\r\n    for event in environment_events.read() {\r\n        if !environment_query.contains(event.environment_id) {\r\n            continue;\r\n        }\r\n        let environment_id = event.environment_id;\r\n        info!(\"Adding button to new host environment {:?}\", environment_id);\r\n        commands.entity(environment_id).with_children(|parent| {\r\n            parent\r\n                .spawn((\r\n                    VoiceToTextStatusButton::default(),\r\n                    Name::new(\"Voice2Text Button\"),\r\n                    SpriteBundle {\r\n                        sprite: Sprite {\r\n                            custom_size: Some(Vec2::new(200.0, 100.0)),\r\n                            color: Color::PURPLE,\r\n                            ..default()\r\n                        },\r\n                        transform: Transform::from_translation(Vec3::new(\r\n                            1920.0 / 2.0 + 600.0,\r\n                            -1080.0 - 200.0,\r\n                            0.0,\r\n                        )),\r\n                        ..default()\r\n                    },\r\n                    Clickable,\r\n                    Hoverable,\r\n                    RigidBody::Static,\r\n                    Sensor,\r\n                    Collider::cuboid(200.0, 100.0),\r\n                ))\r\n                .with_children(|parent| {\r\n                    parent.spawn((Text2dBundle {\r\n                        text: Text::from_section(\r\n                            \"Voice2Text Server Control\".to_string(),\r\n                            TextStyle {\r\n                                font: asset_server.load(\"fonts/FiraSans-Bold.ttf\"),\r\n                                font_size: 32.0,\r\n                                color: Color::WHITE,\r\n                            },\r\n                        )\r\n                        .with_alignment(TextAlignment::Center),\r\n                        transform: Transform::from_xyz(0.0, 70.0, 1.0),\r\n                        ..default()\r\n                    },));\r\n                });\r\n            parent\r\n                .spawn((\r\n                    VoiceToTextVscodeButton::default(),\r\n                    Name::new(\"Voice2Text VSCode Button\"),\r\n                    SpriteBundle {\r\n                        sprite: Sprite {\r\n                            custom_size: Some(Vec2::new(200.0, 100.0)),\r\n                            color: Color::rgb(0.0, 0.6, 0.8),\r\n                            ..default()\r\n                        },\r\n                        transform: Transform::from_translation(Vec3::new(\r\n                            1920.0 / 2.0 + 600.0,\r\n                            -1080.0 - 350.0,\r\n                            0.0,\r\n                        )),\r\n                        ..default()\r\n                    },\r\n                    Clickable,\r\n                    Hoverable,\r\n                    RigidBody::Static,\r\n                    Sensor,\r\n                    Collider::cuboid(200.0, 100.0),\r\n                ))\r\n                .with_children(|parent| {\r\n                    parent.spawn((Text2dBundle {\r\n                        text: Text::from_section(\r\n                            \"open in vscode\".to_string(),\r\n                            TextStyle {\r\n                                font: asset_server.load(\"fonts/FiraSans-Bold.ttf\"),\r\n                                font_size: 32.0,\r\n                                color: Color::WHITE,\r\n                            },\r\n                        )\r\n                        .with_alignment(TextAlignment::Center),\r\n                        transform: Transform::from_xyz(0.0, 0.0, 1.0),\r\n                        ..default()\r\n                    },));\r\n                });\r\n        });\r\n    }\r\n}\r\n\r\nfn update_visuals(\r\n    mut events: EventReader<VoiceToTextStatusEvent>,\r\n    mut button_query: Query<(&mut Sprite, &Children, &mut VoiceToTextStatusButton)>,\r\n    mut button_text_query: Query<&mut Text>,\r\n) {\r\n    for event in events.read() {\r\n        let VoiceToTextStatusEvent::Changed {\r\n            new_status: status, ..\r\n        } = event;\r\n        debug!(\r\n            \"Updating VoiceToText Server Control visuals to {:?}\",\r\n            status\r\n        );\r\n        for button in button_query.iter_mut() {\r\n            let (mut button_sprite, button_children, mut button) = button;\r\n            button.visual_state = match button.visual_state {\r\n                VoiceToTextStatusButtonVisualState::Default { .. } => {\r\n                    VoiceToTextStatusButtonVisualState::Default {\r\n                        status: status.clone(),\r\n                    }\r\n                }\r\n                VoiceToTextStatusButtonVisualState::Hovered { .. } => {\r\n                    VoiceToTextStatusButtonVisualState::Hovered {\r\n                        status: status.clone(),\r\n                    }\r\n                }\r\n                VoiceToTextStatusButtonVisualState::Pressed { .. } => {\r\n                    VoiceToTextStatusButtonVisualState::Pressed {\r\n                        status: status.clone(),\r\n                    }\r\n                }\r\n            };\r\n            match status {\r\n                VoiceToTextStatus::Alive { .. } => {\r\n                    button_sprite.color = Color::GREEN;\r\n                }\r\n                VoiceToTextStatus::AliveButWeDontKnowTheApiKey => {\r\n                    button_sprite.color = Color::ORANGE_RED;\r\n                }\r\n                VoiceToTextStatus::Dead => {\r\n                    button_sprite.color = Color::RED;\r\n                }\r\n                VoiceToTextStatus::Unknown | VoiceToTextStatus::UnknownWithCachedApiKey { .. } => {\r\n                    button_sprite.color = Color::PURPLE;\r\n                }\r\n                VoiceToTextStatus::Starting {\r\n                    instant, timeout, ..\r\n                } => {\r\n                    button_sprite.color = Color::YELLOW\r\n                        * (1.0, 0.1).lerp(instant.elapsed().as_secs_f32() / timeout.as_secs_f32());\r\n                }\r\n            }\r\n            for child in button_children.iter() {\r\n                if let Ok(mut text) = button_text_query.get_mut(*child) {\r\n                    match status {\r\n                        VoiceToTextStatus::Alive { .. } => {\r\n                            text.sections[0].value =\r\n                                \"VoiceToText Server Control (Alive)\".to_string();\r\n                        }\r\n                        VoiceToTextStatus::AliveButWeDontKnowTheApiKey => {\r\n                            text.sections[0].value =\r\n                                \"VoiceToText Server Control (Alive, but we don't know the API key)\"\r\n                                    .to_string();\r\n                        }\r\n                        VoiceToTextStatus::Dead => {\r\n                            text.sections[0].value =\r\n                                \"VoiceToText Server Control (Dead)\".to_string();\r\n                        }\r\n                        VoiceToTextStatus::Unknown => {\r\n                            text.sections[0].value =\r\n                                \"VoiceToText Server Control (Unknown)\".to_string();\r\n                        }\r\n                        VoiceToTextStatus::UnknownWithCachedApiKey { .. } => {\r\n                            text.sections[0].value =\r\n                                \"VoiceToText Server Control (Unknown, api key present)\".to_string();\r\n                        }\r\n                        VoiceToTextStatus::Starting { instant, .. } => {\r\n                            text.sections[0].value = format!(\r\n                                \"VoiceToText Server Control (Starting {}s ago)\",\r\n                                instant.elapsed().as_secs()\r\n                            );\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    for button in button_query.iter_mut() {\r\n        let (mut sprite, children, button) = button;\r\n        // if the visual state status is starting, update the text to show the time elapsed\r\n        let (VoiceToTextStatusButtonVisualState::Default {\r\n            status: VoiceToTextStatus::Starting {\r\n                instant, timeout, ..\r\n            },\r\n        }\r\n        | VoiceToTextStatusButtonVisualState::Hovered {\r\n            status: VoiceToTextStatus::Starting {\r\n                instant, timeout, ..\r\n            },\r\n        }\r\n        | VoiceToTextStatusButtonVisualState::Pressed {\r\n            status: VoiceToTextStatus::Starting {\r\n                instant, timeout, ..\r\n            },\r\n        }) = button.visual_state\r\n        else {\r\n            continue;\r\n        };\r\n        sprite.color = Color::YELLOW\r\n            * (1.0, 0.1).lerp(instant.elapsed().as_secs_f32() / timeout.as_secs_f32());\r\n        for child in children.iter() {\r\n            if let Ok(mut text) = button_text_query.get_mut(*child) {\r\n                text.sections[0].value = format!(\r\n                    \"VoiceToText Server Control (Starting {}s ago)\",\r\n                    instant.elapsed().as_secs()\r\n                );\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfn status_button_click(\r\n    mut click_events: EventReader<ClickEvent>,\r\n    button_query: Query<&VoiceToTextStatusButton>,\r\n    mut command_events: EventWriter<VoiceToTextCommandEvent>,\r\n) {\r\n    for event in click_events.read() {\r\n        let ClickEvent::Clicked {\r\n            target_id,\r\n            pointer_id: _,\r\n            way,\r\n        } = event\r\n        else {\r\n            continue;\r\n        };\r\n        if way != &Way::Left {\r\n            continue;\r\n        }\r\n        if let Ok(button) = button_query.get(*target_id) {\r\n            info!(\"VoiceToText Server Control clicked\");\r\n            // if the button visual status is alive, do nothing\r\n            match button.visual_state {\r\n                VoiceToTextStatusButtonVisualState::Default {\r\n                    status: VoiceToTextStatus::Alive { .. },\r\n                }\r\n                | VoiceToTextStatusButtonVisualState::Hovered {\r\n                    status: VoiceToTextStatus::Alive { .. },\r\n                }\r\n                | VoiceToTextStatusButtonVisualState::Pressed {\r\n                    status: VoiceToTextStatus::Alive { .. },\r\n                } => {\r\n                    warn!(\"VoiceToText Server Control is already alive\");\r\n                    continue;\r\n                }\r\n                _ => {}\r\n            }\r\n            let event = VoiceToTextCommandEvent::Startup;\r\n            debug!(\"Sending event {:?}\", event);\r\n            command_events.send(event);\r\n        }\r\n    }\r\n}\r\n\r\nfn vscode_button_click(\r\n    mut click_events: EventReader<ClickEvent>,\r\n    button_query: Query<&VoiceToTextVscodeButton>,\r\n    mut vscode_events: EventWriter<VoiceToTextVscodeEvent>,\r\n) {\r\n    for event in click_events.read() {\r\n        let ClickEvent::Clicked {\r\n            target_id,\r\n            pointer_id: _,\r\n            way,\r\n        } = event\r\n        else {\r\n            continue;\r\n        };\r\n        if way != &Way::Left {\r\n            continue;\r\n        }\r\n        if button_query.get(*target_id).is_ok() {\r\n            info!(\"VoiceToText vscode clicked\");\r\n            let event = VoiceToTextVscodeEvent::Startup;\r\n            debug!(\"Sending event {:?}\", event);\r\n            vscode_events.send(event);\r\n        }\r\n    }\r\n}\r\n\r\nfn handle_vscode_events(mut vscode_events: EventReader<VoiceToTextVscodeEvent>) {\r\n    let should_start = vscode_events\r\n        .read()\r\n        .any(|event| matches!(event, VoiceToTextVscodeEvent::Startup));\r\n    if should_start {\r\n        info!(\"Opening vscode\");\r\n        if let Err(e) = crate::voice_to_text::start_vscode() {\r\n            error!(\"Failed to start vscode: {:?}\", e);\r\n        }\r\n    }\r\n    vscode_events.clear();\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\winutils\\examples\\app_icons_example.rs\r\n\r\n````rust\r\nuse std::rc::Rc;\r\n\r\nuse bevy::utils::HashSet;\r\nuse cursor_hero_winutils::win_errors::*;\r\nuse cursor_hero_winutils::win_icons::get_images_from_exe;\r\nuse cursor_hero_winutils::win_process::*;\r\nuse windows::core::PWSTR;\r\nuse windows::Win32::Foundation::E_ACCESSDENIED;\r\n\r\nfn main() -> Result<()> {\r\n    unsafe {\r\n        let process_iter = ProcessIterator::new()?;\r\n        let mut done = HashSet::new();\r\n        for mut process in process_iter {\r\n            let exe_name_pwstr = PWSTR(process.szExeFile.as_mut_ptr());\r\n            let exe_name = exe_name_pwstr.to_string()?;\r\n            let exe_path = match get_process_full_name(process.th32ProcessID) {\r\n                Ok(s) => s,\r\n                Err(e) => {\r\n                    if matches!(\r\n                        e,\r\n                        Error::Windows(ref e) if e.code() == E_ACCESSDENIED\r\n                    ) {\r\n                        continue;\r\n                    }\r\n                    eprintln!(\r\n                        \"Failed to get full process name for PID {:05} ({}): {:?}\",\r\n                        process.th32ProcessID, exe_name, e\r\n                    );\r\n                    continue;\r\n                }\r\n            };\r\n            if done.contains(&exe_path) {\r\n                continue;\r\n            }\r\n            done.insert(exe_path.clone());\r\n            let icons = get_images_from_exe(exe_path.as_str())?;\r\n            println!(\r\n                \"Process ID: {:05}, name: {}, icon count: {}\",\r\n                process.th32ProcessID,\r\n                exe_name,\r\n                icons.len()\r\n            );\r\n\r\n            if icons.is_empty() {\r\n                continue;\r\n            }\r\n\r\n            // write the image to target/app_icons/{exe_name}/{icon_index}.png\r\n            let mut path = std::path::PathBuf::from(\"target/app_icons\");\r\n            path.push(exe_name);\r\n            std::fs::create_dir_all(&path).map_err(|e| Error::Other(Rc::new(e)))?;\r\n            for (i, icon) in icons.iter().enumerate() {\r\n                let mut icon_path = path.clone();\r\n                icon_path.push(format!(\"{}.png\", i));\r\n                icon.save(icon_path).map_err(|e| Error::Other(Rc::new(e)))?;\r\n            }\r\n        }\r\n    }\r\n    Ok(())\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\agent\\src\\agent_spawning_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n\r\nuse bevy_xpbd_2d::components::Collider;\r\nuse bevy_xpbd_2d::components::RigidBody;\r\nuse cursor_hero_agent_types::prelude::*;\r\nuse cursor_hero_bevy::prelude::NegativeYVec2;\r\nuse cursor_hero_character_types::prelude::*;\r\nuse cursor_hero_environment_types::prelude::*;\r\nuse cursor_hero_floaty_nametag_types::prelude::*;\r\nuse cursor_hero_observation_types::prelude::*;\r\nuse cursor_hero_physics::damping_plugin::MovementDamping;\r\n\r\npub struct AgentSpawningPlugin;\r\n\r\nimpl Plugin for AgentSpawningPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Update, spawn_agent);\r\n    }\r\n}\r\n\r\nfn spawn_agent(\r\n    mut commands: Commands,\r\n    mut environment_events: EventReader<PopulateEnvironmentEvent>,\r\n    environment_query: Query<&GameEnvironment>,\r\n    asset_server: Res<AssetServer>,\r\n) {\r\n    for event in environment_events.read() {\r\n        if !environment_query.contains(event.environment_id) {\r\n            continue;\r\n        }\r\n        info!(\r\n            \"Spawning agent for game environment {:?}\",\r\n            event.environment_id\r\n        );\r\n        commands\r\n            .entity(event.environment_id)\r\n            .with_children(|parent| {\r\n                let spawn_position = Vec2::new(1920.0, 1080.0).neg_y() / 2.0;\r\n                parent.spawn((\r\n                    SpriteBundle {\r\n                        sprite: Sprite {\r\n                            custom_size: Some(Vec2::new(64.0, 64.0)),\r\n                            ..default()\r\n                        },\r\n                        texture: asset_server.load(AgentAppearance::Default.get_texture_path()),\r\n                        transform: Transform::from_translation(spawn_position.extend(80.0)),\r\n                        ..default()\r\n                    },\r\n                    Character,\r\n                    AgentCharacter,\r\n                    Name::new(\"Character - (Agent) Ithia Tig\"),\r\n                    FloatyName {\r\n                        text: \"Ithia Tig\".to_string(),\r\n                        vertical_offset: 40.0,\r\n                        appearance: NametagAppearance::Character,\r\n                    },\r\n                    Agent,\r\n                    RigidBody::Dynamic,\r\n                    ObservationBuffer {\r\n                        log_level: ObservationLogLevel::All,\r\n                        ..default()\r\n                    },\r\n                    Collider::capsule(25.0, 12.5),\r\n                    MovementDamping { factor: 0.90 },\r\n                ));\r\n            });\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\brick\\src\\brick_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n\r\npub struct BrickPlugin;\r\n\r\nimpl Plugin for BrickPlugin {\r\n    fn build(&self, _app: &mut App) {}\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\window_position\\src\\window_position_loadout_switcher_tool_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse cursor_hero_toolbelt_types::prelude::ToolbeltPopulateEvent;\r\nuse cursor_hero_toolbelt_types::toolbelt_types::ActiveTool;\r\nuse cursor_hero_toolbelt_types::toolbelt_types::ToolbeltLoadout;\r\nuse cursor_hero_tools::prelude::NoInputs;\r\nuse cursor_hero_tools::prelude::ToolSpawnConfig;\r\nuse cursor_hero_tools::tool_spawning::StartingState;\r\nuse cursor_hero_window_position_types::window_position_types::WindowPositionLoadoutSwitcherTool;\r\n\r\npub struct WindowPositionLoadoutSwitcherToolPlugin;\r\n\r\nimpl Plugin for WindowPositionLoadoutSwitcherToolPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Update, populate_toolbelts);\r\n        app.add_systems(Update, do_switch);\r\n    }\r\n}\r\n\r\nfn populate_toolbelts(\r\n    mut commands: Commands,\r\n    asset_server: Res<AssetServer>,\r\n    mut reader: EventReader<ToolbeltPopulateEvent>,\r\n) {\r\n    for event in reader.read() {\r\n        if event.loadout != ToolbeltLoadout::Default {\r\n            continue;\r\n        }\r\n        ToolSpawnConfig::<WindowPositionLoadoutSwitcherTool, NoInputs>::new(\r\n            WindowPositionLoadoutSwitcherTool,\r\n            event.id,\r\n            event,\r\n        )\r\n        .with_src_path(file!().into())\r\n        .guess_name(file!())\r\n        .with_image(asset_server.load(\"textures/tools/window_position.webp\"))\r\n        .with_description(\"Swaps to taskbar tools\")\r\n        .with_starting_state(StartingState::Inactive)\r\n        .spawn(&mut commands);\r\n    }\r\n}\r\n\r\nfn do_switch(\r\n    mut commands: Commands,\r\n    tool_query: Query<&Parent, (Added<ActiveTool>, With<WindowPositionLoadoutSwitcherTool>)>,\r\n    mut toolbelt_events: EventWriter<ToolbeltPopulateEvent>,\r\n) {\r\n    for toolbelt_id in tool_query.iter() {\r\n        let toolbelt_id = toolbelt_id.get();\r\n        commands.entity(toolbelt_id).despawn_descendants();\r\n        toolbelt_events.send(ToolbeltPopulateEvent {\r\n            id: toolbelt_id,\r\n            loadout: ToolbeltLoadout::WindowPosition,\r\n        });\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\fullscreen_tool_types\\src\\fullscreen_tool_types.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse bevy::window::WindowMode;\r\nuse bevy_inspector_egui::prelude::ReflectInspectorOptions;\r\nuse bevy_inspector_egui::InspectorOptions;\r\nuse cursor_hero_tools::tool_spawning::StartingState;\r\n\r\n#[derive(Component, Reflect, Debug, InspectorOptions, Default)]\r\n#[reflect(Component, InspectorOptions)]\r\npub struct FullscreenTool;\r\n\r\nimpl FullscreenTool {\r\n    pub fn state_for_mode(mode: WindowMode) -> StartingState {\r\n        match mode {\r\n            WindowMode::Windowed => StartingState::Inactive,\r\n            _ => StartingState::Active,\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\movement_tool\\src\\movement_speed_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse cursor_hero_character_types::prelude::*;\r\nuse cursor_hero_input::active_input_state_plugin::InputMethod;\r\nuse cursor_hero_movement_tool_types::prelude::*;\r\nuse cursor_hero_toolbelt_types::prelude::*;\r\n\r\npub struct MovementSpeedPlugin;\r\n\r\nimpl Plugin for MovementSpeedPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(OnEnter(InputMethod::MouseAndKeyboard), set_mnk_speed);\r\n        app.add_systems(OnEnter(InputMethod::Gamepad), set_gamepad_speed);\r\n    }\r\n}\r\n\r\nfn set_mnk_speed(\r\n    mut tool_query: Query<(&mut MovementTool, &Parent), With<MovementTool>>,\r\n    toolbelt_query: Query<&Parent, With<Toolbelt>>,\r\n    character_query: Query<(), With<MainCharacter>>,\r\n) {\r\n    for tool in tool_query.iter_mut() {\r\n        let (mut tool, tool_parent) = tool;\r\n        let Ok(toolbelt) = toolbelt_query.get(tool_parent.get()) else {\r\n            continue;\r\n        };\r\n        if character_query.get(toolbelt.get()).is_err() {\r\n            continue;\r\n        }\r\n        *tool = MovementTool {\r\n            target: tool.target,\r\n            ..MovementTool::default_mnk()\r\n        };\r\n    }\r\n}\r\n\r\nfn set_gamepad_speed(\r\n    mut tool_query: Query<(&mut MovementTool, &Parent), With<MovementTool>>,\r\n    toolbelt_query: Query<&Parent, With<Toolbelt>>,\r\n    character_query: Query<(), With<MainCharacter>>,\r\n) {\r\n    for tool in tool_query.iter_mut() {\r\n        let (mut tool, tool_parent) = tool;\r\n        let Ok(toolbelt) = toolbelt_query.get(tool_parent.get()) else {\r\n            continue;\r\n        };\r\n        if character_query.get(toolbelt.get()).is_err() {\r\n            continue;\r\n        }\r\n        *tool = MovementTool {\r\n            target: tool.target,\r\n            ..MovementTool::default_gamepad()\r\n        };\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui_watcher\\src\\ui_watcher_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse cursor_hero_character_types::prelude::MainCharacter;\r\nuse cursor_hero_environment_types::environment_types::EnvironmentTracker;\r\nuse cursor_hero_memory_types::prelude::get_persist_file;\r\nuse cursor_hero_memory_types::prelude::MemoryConfig;\r\nuse cursor_hero_memory_types::prelude::Usage;\r\nuse cursor_hero_observation_types::observation_types::SomethingObservableHappenedEvent;\r\nuse cursor_hero_ui_automation::prelude::take_snapshot;\r\nuse cursor_hero_ui_automation::prelude::UISnapshot;\r\nuse std::io::Write;\r\nuse std::thread;\r\n\r\nuse crossbeam_channel::bounded;\r\nuse crossbeam_channel::Receiver;\r\nuse crossbeam_channel::Sender;\r\npub struct UiWatcherPlugin;\r\n\r\nimpl Plugin for UiWatcherPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Startup, spawn_worker_thread);\r\n        app.add_systems(Update, handle_gamebound_messages);\r\n        app.add_systems(Update, trigger_gather_info);\r\n    }\r\n}\r\n\r\n#[derive(Debug)]\r\nenum ThreadboundMessage {\r\n    TakeSnapshot,\r\n}\r\n\r\n#[derive(Debug)]\r\nenum GameboundMessage {\r\n    Snapshot(UISnapshot),\r\n}\r\n\r\n#[derive(Resource)]\r\nstruct Bridge {\r\n    pub sender: Sender<ThreadboundMessage>,\r\n    pub receiver: Receiver<GameboundMessage>,\r\n}\r\n\r\nfn spawn_worker_thread(mut commands: Commands) {\r\n    let (tx, rx) = bounded::<_>(10);\r\n    let (reply_tx, reply_rx) = bounded::<_>(10); // New channel for replies\r\n\r\n    commands.insert_resource(Bridge {\r\n        sender: tx,\r\n        receiver: reply_rx,\r\n    });\r\n    thread::spawn(move || loop {\r\n        let action = match rx.recv() {\r\n            Ok(action) => action,\r\n            Err(e) => {\r\n                error!(\"Failed to receive thread message, exiting: {:?}\", e);\r\n                break;\r\n            }\r\n        };\r\n        if let Err(e) = handle_threadbound_messages(action, &reply_tx) {\r\n            error!(\"Failed to process thread message: {:?}\", e);\r\n        }\r\n    });\r\n}\r\n\r\nfn handle_threadbound_messages(\r\n    action: ThreadboundMessage,\r\n    reply_tx: &Sender<GameboundMessage>,\r\n) -> Result<(), Box<dyn std::error::Error>> {\r\n    match action {\r\n        ThreadboundMessage::TakeSnapshot => {\r\n            let snapshot = take_snapshot()?;\r\n            let msg = GameboundMessage::Snapshot(snapshot);\r\n            // println!(\"Sending {:?}\", msg);\r\n            reply_tx.send(msg)?;\r\n        }\r\n    }\r\n\r\n    Ok(())\r\n}\r\n\r\nfn handle_gamebound_messages(\r\n    memory_config: Res<MemoryConfig>,\r\n    bridge: Res<Bridge>,\r\n    mut observation_events: EventWriter<SomethingObservableHappenedEvent>,\r\n    character_query: Query<&EnvironmentTracker, With<MainCharacter>>,\r\n) {\r\n    if bridge.receiver.is_empty() {\r\n        return;\r\n    }\r\n    let environment_id = character_query.get_single().ok().map(|c| c.environment_id);\r\n    while let Ok(msg) = bridge.receiver.try_recv() {\r\n        let (msg_kind, GameboundMessage::Snapshot(snapshot)) = (\"Snapshot\", msg);\r\n        debug!(\"Received message {}:\\n{}\", msg_kind, snapshot);\r\n\r\n        observation_events.send(SomethingObservableHappenedEvent::UISnapshot {\r\n            snapshot: snapshot.clone(),\r\n            environment_id,\r\n        });\r\n\r\n        match get_persist_file(\r\n            memory_config.as_ref(),\r\n            \"results.txt\",\r\n            Usage::Persist,\r\n        ) {\r\n            Ok(mut file) => {\r\n                if let Err(e) = file.write_all(snapshot.to_string().as_bytes()) {\r\n                    error!(\"Failed to write to file: {:?}\", e);\r\n                }\r\n            }\r\n            Err(e) => {\r\n                error!(\"Failed to open file: {:?}\", e);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfn trigger_gather_info(\r\n    bridge: ResMut<Bridge>,\r\n    mut cooldown: Local<Option<Timer>>,\r\n    time: Res<Time>,\r\n) {\r\n    match *cooldown {\r\n        Some(ref mut timer) => {\r\n            if timer.tick(time.delta()).just_finished() {\r\n                *cooldown = None;\r\n            }\r\n        }\r\n        None => {\r\n            debug!(\"Triggering gather info\");\r\n            // if let Err(e) = bridge.sender.send(ThreadboundMessage::GatherFocusInfo) {\r\n            //     error!(\"Failed to send thread message: {:?}\", e);\r\n            // }\r\n            if let Err(e) = bridge.sender.send(ThreadboundMessage::TakeSnapshot) {\r\n                error!(\"Failed to send thread message: {:?}\", e);\r\n            }\r\n            *cooldown = Some(Timer::from_seconds(5.0, TimerMode::Once));\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\window_position_types\\src\\window_position_types.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse bevy::window::WindowMode;\r\nuse bevy::window::WindowResolution;\r\n\r\n#[derive(Debug, Reflect)]\r\npub enum HostWindowPosition {\r\n    Fullscreen {\r\n        monitor: u32,\r\n    },\r\n    Corner {\r\n        corner: cursor_hero_math::prelude::Corner,\r\n        monitor: u32,\r\n    },\r\n}\r\n\r\n#[derive(Component, Reflect, Default)]\r\npub struct WindowPositionLoadoutSwitcherTool;\r\n\r\n#[derive(Component, Reflect)]\r\npub struct WindowPositionTool {\r\n    pub window_position: HostWindowPosition,\r\n}\r\n\r\n#[derive(Event, Reflect, Debug, Clone)]\r\npub struct WindowPositionCommand {\r\n    pub window: Entity,\r\n    pub mode: Option<WindowMode>,\r\n    pub resolution: Option<WindowResolution>,\r\n    pub position: Option<WindowPosition>,\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\pointer_types\\src\\lib.rs\r\n\r\n````rust\r\npub mod pointer_action_types;\r\npub mod pointer_behaviour_types;\r\npub mod pointer_click_types;\r\npub mod pointer_hover_types;\r\npub mod pointer_reach_types;\r\npub mod pointer_types;\r\npub mod pointer_types_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::pointer_action_types::*;\r\n    pub use crate::pointer_click_types::*;\r\n    pub use crate::pointer_hover_types::*;\r\n    pub use crate::pointer_reach_types::*;\r\n    pub use crate::pointer_types::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\screen\\src\\lib.rs\r\n\r\n````rust\r\nuse bevy::math::IRect;\r\nuse bevy::math::IVec2;\r\nuse screenshots::display_info::DisplayInfo;\r\n\r\npub mod get_image;\r\npub mod screen_plugin;\r\npub mod screen_update_plugin;\r\n\r\npub trait ToBevyIRect {\r\n    fn to_bevy_irect(&self) -> IRect;\r\n}\r\nimpl ToBevyIRect for DisplayInfo {\r\n    fn to_bevy_irect(&self) -> IRect {\r\n        IRect {\r\n            min: IVec2::new(self.x, self.y),\r\n            max: IVec2::new(self.x + self.width as i32, self.y + self.height as i32),\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\tools\\src\\click_tool.rs\r\n\r\n````rust\r\nuse std::thread;\r\n\r\nuse bevy::audio::Volume;\r\nuse bevy::audio::VolumeLevel;\r\nuse bevy::prelude::*;\r\nuse bevy::window::PrimaryWindow;\r\nuse bevy_inspector_egui::bevy_egui::EguiContext;\r\nuse cursor_hero_pointer_types::prelude::*;\r\n\r\nuse leafwing_input_manager::prelude::*;\r\n\r\nuse crossbeam_channel::bounded;\r\nuse crossbeam_channel::Sender;\r\nuse cursor_hero_character_types::prelude::*;\r\n\r\nuse cursor_hero_winutils::win_mouse::left_mouse_down;\r\nuse cursor_hero_winutils::win_mouse::left_mouse_up;\r\nuse cursor_hero_winutils::win_mouse::right_mouse_down;\r\nuse cursor_hero_winutils::win_mouse::right_mouse_up;\r\n\r\nuse cursor_hero_toolbelt_types::prelude::*;\r\n\r\nuse crate::prelude::*;\r\n\r\npub struct ClickToolPlugin;\r\n\r\nimpl Plugin for ClickToolPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<ClickTool>();\r\n        app.add_plugins(InputManagerPlugin::<ClickToolAction>::default());\r\n        app.add_systems(Startup, spawn_worker_thread);\r\n        app.add_systems(Update, (toolbelt_events, handle_input));\r\n    }\r\n}\r\n\r\n#[derive(Component, Reflect, Default)]\r\nstruct ClickTool;\r\n\r\nfn toolbelt_events(\r\n    mut commands: Commands,\r\n    asset_server: Res<AssetServer>,\r\n    mut reader: EventReader<ToolbeltPopulateEvent>,\r\n) {\r\n    for event in reader.read() {\r\n        if let ToolbeltLoadout::Default | ToolbeltLoadout::Keyboard = event.loadout {\r\n            ToolSpawnConfig::<ClickTool, ClickToolAction>::new(ClickTool, event.id, event)\r\n                .with_src_path(file!().into())\r\n                .guess_name(file!())\r\n                .guess_image(file!(), &asset_server, \"png\")\r\n                .with_description(\"Send mouse clicks\")\r\n                .spawn(&mut commands);\r\n        }\r\n    }\r\n}\r\n\r\n#[derive(Actionlike, PartialEq, Eq, Clone, Copy, Hash, Debug, Reflect)]\r\nenum ClickToolAction {\r\n    LeftClick,\r\n    RightClick,\r\n}\r\nimpl ClickToolAction {\r\n    fn get_audio_path(&self, motion: Motion) -> &'static str {\r\n        match (self, motion) {\r\n            (Self::LeftClick, Motion::Down) => \"sounds/mouse1down.ogg\",\r\n            (Self::LeftClick, Motion::Up) => \"sounds/mouse1up.ogg\",\r\n            (Self::RightClick, Motion::Down) => \"sounds/mouse2down.ogg\",\r\n            (Self::RightClick, Motion::Up) => \"sounds/mouse2up.ogg\",\r\n        }\r\n    }\r\n    fn get_thread_message(&self, motion: Motion) -> ClickThreadMessage {\r\n        match (self, motion) {\r\n            (Self::LeftClick, Motion::Down) => ClickThreadMessage::LeftMouse(Motion::Down),\r\n            (Self::LeftClick, Motion::Up) => ClickThreadMessage::LeftMouse(Motion::Up),\r\n            (Self::RightClick, Motion::Down) => ClickThreadMessage::RightMouse(Motion::Down),\r\n            (Self::RightClick, Motion::Up) => ClickThreadMessage::RightMouse(Motion::Up),\r\n        }\r\n    }\r\n}\r\nimpl From<ClickToolAction> for Way {\r\n    fn from(action: ClickToolAction) -> Self {\r\n        match action {\r\n            ClickToolAction::LeftClick => Way::Left,\r\n            ClickToolAction::RightClick => Way::Right,\r\n        }\r\n    }\r\n}\r\n\r\n#[derive(Debug)]\r\nenum Motion {\r\n    Up,\r\n    Down,\r\n}\r\n\r\n#[derive(Debug)]\r\nenum ClickThreadMessage {\r\n    LeftMouse(Motion),\r\n    RightMouse(Motion),\r\n}\r\n\r\n#[derive(Resource)]\r\nstruct ClickBridge {\r\n    pub sender: Sender<(ClickThreadMessage, i32, i32)>,\r\n}\r\n\r\nimpl ClickToolAction {\r\n    fn default_wheel_gamepad_binding(&self) -> UserInput {\r\n        match self {\r\n            Self::LeftClick => GamepadButtonType::RightTrigger.into(),\r\n            Self::RightClick => GamepadButtonType::LeftTrigger.into(),\r\n        }\r\n    }\r\n\r\n    fn default_wheel_keyboard_binding(&self) -> UserInput {\r\n        match self {\r\n            Self::LeftClick => MouseButton::Left.into(),\r\n            Self::RightClick => MouseButton::Right.into(),\r\n        }\r\n    }\r\n    fn keyboard_wheel_gamepad_binding(&self) -> UserInput {\r\n        match self {\r\n            Self::LeftClick => GamepadButtonType::RightThumb.into(),\r\n            Self::RightClick => GamepadButtonType::LeftThumb.into(),\r\n        }\r\n    }\r\n\r\n    fn keyboard_wheel_keyboard_binding(&self) -> UserInput {\r\n        match self {\r\n            Self::LeftClick => MouseButton::Left.into(),\r\n            Self::RightClick => MouseButton::Right.into(),\r\n        }\r\n    }\r\n}\r\n\r\nimpl ToolAction for ClickToolAction {\r\n    fn default_input_map(event: &ToolbeltPopulateEvent) -> Option<InputMap<ClickToolAction>> {\r\n        match event.loadout {\r\n            ToolbeltLoadout::Default => Some(Self::with_defaults(\r\n                Self::default_wheel_gamepad_binding,\r\n                Self::default_wheel_keyboard_binding,\r\n            )),\r\n            ToolbeltLoadout::Keyboard => Some(Self::with_defaults(\r\n                Self::keyboard_wheel_gamepad_binding,\r\n                Self::keyboard_wheel_keyboard_binding,\r\n            )),\r\n            _ => None,\r\n        }\r\n    }\r\n}\r\n\r\nfn spawn_worker_thread(mut commands: Commands) {\r\n    let (tx, rx) = bounded::<_>(10);\r\n    commands.insert_resource(ClickBridge { sender: tx });\r\n    thread::spawn(move || loop {\r\n        let (action, x, y) = match rx.recv() {\r\n            Ok(v) => v,\r\n            Err(e) => {\r\n                error!(\"Failed to receive thread message, exiting: {:?}\", e);\r\n                break;\r\n            }\r\n        };\r\n        debug!(\"Worker received click: {:?} {} {}\", action, x, y);\r\n        match match action {\r\n            ClickThreadMessage::LeftMouse(Motion::Down) => left_mouse_down(),\r\n            ClickThreadMessage::LeftMouse(Motion::Up) => left_mouse_up(),\r\n            ClickThreadMessage::RightMouse(Motion::Down) => right_mouse_down(),\r\n            ClickThreadMessage::RightMouse(Motion::Up) => right_mouse_up(),\r\n        } {\r\n            Ok(_) => {}\r\n            Err(e) => {\r\n                error!(\"Failed to handle event {:?}: {:?}\", action, e);\r\n            }\r\n        }\r\n    });\r\n}\r\n\r\n#[allow(clippy::too_many_arguments)]\r\n#[allow(clippy::type_complexity)]\r\nfn handle_input(\r\n    mut commands: Commands,\r\n    tools: Query<(&ActionState<ClickToolAction>, &Parent), (With<ActiveTool>, With<ClickTool>)>,\r\n    toolbelts: Query<&Parent, With<Toolbelt>>,\r\n    characters: Query<&Children, With<Character>>,\r\n    pointers: Query<(Entity, &GlobalTransform), With<Pointer>>,\r\n    bridge: ResMut<ClickBridge>,\r\n    asset_server: Res<AssetServer>,\r\n    mut tool_click_event_writer: EventWriter<ToolClickEvent>,\r\n    window_query: Query<&Window, With<PrimaryWindow>>,\r\n    egui_context_query: Query<&EguiContext, With<PrimaryWindow>>,\r\n) {\r\n    for tool in tools.iter() {\r\n        let (tool_actions, tool_parent) = tool;\r\n\r\n        if !ClickToolAction::variants()\r\n            .any(|action| tool_actions.just_pressed(action) || tool_actions.just_released(action))\r\n        {\r\n            continue;\r\n        }\r\n\r\n        let Ok(toolbelt) = toolbelts.get(tool_parent.get()) else {\r\n            warn!(\"Tool not inside a toolbelt?\");\r\n            continue;\r\n        };\r\n        let toolbelt_parent = toolbelt;\r\n\r\n        let Ok(character) = characters.get(toolbelt_parent.get()) else {\r\n            warn!(\"Toolbelt parent not a character?\");\r\n            continue;\r\n        };\r\n        let character_children = character;\r\n\r\n        let Some(pointer) = character_children\r\n            .iter()\r\n            .filter_map(|x| pointers.get(*x).ok())\r\n            .next()\r\n        else {\r\n            //TODO: warn if more than one pointer found\r\n            warn!(\"Character {:?} missing a pointer?\", toolbelt_parent.get());\r\n            debug!(\"Character children: {:?}\", character_children);\r\n            continue;\r\n        };\r\n        let (pointer_id, pointer_transform) = pointer;\r\n        let pointer_pos = pointer_transform.translation();\r\n\r\n        let window = window_query.get_single().expect(\"Need a single window\");\r\n\r\n        let Ok(egui_context) = egui_context_query.get_single() else {\r\n            return;\r\n        };\r\n        let disable_sfx = egui_context.clone().get_mut().is_pointer_over_area();\r\n        if window.cursor_position().is_some() {\r\n            // The host cursor is over the window\r\n            // Perform virtual click instead of sending a message to the worker thread\r\n            // debug!(\"Performing virtual click\");\r\n            for action in ClickToolAction::variants() {\r\n                if tool_actions.just_pressed(action) {\r\n                    debug!(\"{:?} pressed\", action);\r\n                    if !disable_sfx {\r\n                        commands.spawn((\r\n                            SpatialBundle {\r\n                                transform: Transform::from_translation(pointer_pos),\r\n                                ..default()\r\n                            },\r\n                            Name::new(\"Click sound\"),\r\n                            AudioBundle {\r\n                                source: asset_server.load(action.get_audio_path(Motion::Down)),\r\n                                settings: PlaybackSettings::DESPAWN\r\n                                    .with_spatial(true)\r\n                                    .with_volume(Volume::Relative(VolumeLevel::new(0.5))),\r\n                            },\r\n                        ));\r\n                    }\r\n                    tool_click_event_writer.send(ToolClickEvent::Pressed {\r\n                        pointer_id,\r\n                        way: action.into(),\r\n                    });\r\n                }\r\n                if tool_actions.just_released(action) {\r\n                    debug!(\"{:?} released\", action);\r\n                    if !disable_sfx {\r\n                        commands.spawn((\r\n                            SpatialBundle {\r\n                                transform: Transform::from_translation(pointer_pos),\r\n                                ..default()\r\n                            },\r\n                            Name::new(\"Click sound\"),\r\n                            AudioBundle {\r\n                                source: asset_server.load(action.get_audio_path(Motion::Up)),\r\n                                settings: PlaybackSettings::DESPAWN\r\n                                    .with_spatial(true)\r\n                                    .with_volume(Volume::Relative(VolumeLevel::new(0.5))),\r\n                            },\r\n                        ));\r\n                    }\r\n                    tool_click_event_writer.send(ToolClickEvent::Released {\r\n                        pointer_id,\r\n                        way: action.into(),\r\n                    });\r\n                }\r\n            }\r\n        } else {\r\n            // The host cursor is outside the window\r\n            // Send a message to the worker thread\r\n            // debug!(\"Performing host click\");\r\n            for action in ClickToolAction::variants() {\r\n                if tool_actions.just_pressed(action) {\r\n                    debug!(\"{:?} pressed\", action);\r\n                    match bridge.sender.send((\r\n                        action.get_thread_message(Motion::Down),\r\n                        pointer_pos.x as i32,\r\n                        -pointer_pos.y as i32,\r\n                    )) {\r\n                        Ok(_) => {\r\n                            commands.spawn((\r\n                                SpatialBundle {\r\n                                    transform: Transform::from_translation(pointer_pos),\r\n                                    ..default()\r\n                                },\r\n                                Name::new(\"Click sound\"),\r\n                                AudioBundle {\r\n                                    source: asset_server.load(action.get_audio_path(Motion::Down)),\r\n                                    settings: PlaybackSettings::DESPAWN\r\n                                        .with_spatial(true)\r\n                                        .with_volume(Volume::Relative(VolumeLevel::new(0.5))),\r\n                                },\r\n                            ));\r\n                        }\r\n                        Err(e) => {\r\n                            error!(\"Failed to send click: {:?}\", e);\r\n                        }\r\n                    }\r\n                }\r\n                if tool_actions.just_released(action) {\r\n                    debug!(\"{:?} released\", action);\r\n                    match bridge.sender.send((\r\n                        action.get_thread_message(Motion::Up),\r\n                        pointer_pos.x as i32,\r\n                        -pointer_pos.y as i32,\r\n                    )) {\r\n                        Ok(_) => {\r\n                            commands.spawn((\r\n                                SpatialBundle {\r\n                                    transform: Transform::from_translation(pointer_pos),\r\n                                    ..default()\r\n                                },\r\n                                Name::new(\"Click sound\"),\r\n                                AudioBundle {\r\n                                    source: asset_server.load(action.get_audio_path(Motion::Up)),\r\n                                    settings: PlaybackSettings::DESPAWN\r\n                                        .with_spatial(true)\r\n                                        .with_volume(Volume::Relative(VolumeLevel::new(0.5))),\r\n                                },\r\n                            ));\r\n                        }\r\n\r\n                        Err(e) => {\r\n                            error!(\"Failed to send click: {:?}\", e);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui_automation_types\\src\\ui_automation_types.rs\r\n\r\n````rust\r\nuse crate::prelude::CalculatorState;\r\nuse crate::vscode_ui_types::*;\r\nuse bevy::prelude::*;\r\nuse serde::Deserialize;\r\nuse serde::Serialize;\r\nuse std::collections::VecDeque;\r\nuse std::fmt;\r\nuse std::fmt::Display;\r\nuse std::fmt::Formatter;\r\nuse uiautomation::core::UICondition;\r\nuse uiautomation::UIAutomation;\r\nuse uiautomation::UIElement;\r\n\r\npub trait HexList {\r\n    fn to_hex_list(&self) -> String;\r\n}\r\nimpl HexList for Vec<i32> {\r\n    fn to_hex_list(&self) -> String {\r\n        format!(\r\n            \"[{}]\",\r\n            self.iter()\r\n                .map(|x| format!(\"{:X}\", x).to_string())\r\n                .collect::<Vec<String>>()\r\n                .join(\",\")\r\n        )\r\n    }\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Reflect)]\r\npub struct UISnapshot {\r\n    pub app_windows: Vec<AppWindow>,\r\n}\r\n\r\nimpl Display for UISnapshot {\r\n    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {\r\n        writeln!(f, \"# UI Snapshot\\n\")?;\r\n        for window in self.app_windows.iter() {\r\n            writeln!(f, \"## {}\\n\\n{}\\n\", window.variant_name(), window)?;\r\n        }\r\n        fmt::Result::Ok(())\r\n    }\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Reflect)]\r\npub enum AppWindow {\r\n    VSCode(VSCodeWindow),\r\n    Calculator(CalculatorState),\r\n    Unknown,\r\n}\r\n\r\nimpl AppWindow {\r\n    pub fn variant_name(&self) -> String {\r\n        match self {\r\n            AppWindow::VSCode(_) => \"VSCode\".to_string(),\r\n            AppWindow::Calculator(_) => \"Calculator\".to_string(),\r\n            AppWindow::Unknown => \"Unknown\".to_string(),\r\n        }\r\n    }\r\n}\r\n\r\nimpl Display for AppWindow {\r\n    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {\r\n        match self {\r\n            AppWindow::VSCode(window) => write!(f, \"{}\", window),\r\n            AppWindow::Calculator(window) => write!(f, \"{}\", window),\r\n            AppWindow::Unknown => write!(f, \"Unknown\"),\r\n        }\r\n    }\r\n}\r\n\r\npub fn all_of(\r\n    automation: &UIAutomation,\r\n    conditions: Vec<UICondition>,\r\n) -> Result<UICondition, uiautomation::Error> {\r\n    let iter = conditions.into_iter();\r\n    let mut current = automation.create_true_condition()?;\r\n\r\n    for condition in iter {\r\n        current = automation.create_and_condition(current, condition)?;\r\n    }\r\n\r\n    Ok(current)\r\n}\r\n\r\npub trait ToBevyIRect {\r\n    fn to_bevy_irect(&self) -> IRect;\r\n}\r\nimpl ToBevyIRect for uiautomation::types::Rect {\r\n    fn to_bevy_irect(&self) -> IRect {\r\n        IRect {\r\n            min: IVec2::new(self.get_left(), self.get_top()),\r\n            max: IVec2::new(self.get_right(), self.get_bottom()),\r\n        }\r\n    }\r\n}\r\n\r\n/// Defines enum for `windows::Win32::UI::Accessibility::UIA_CONTROLTYPE_ID`.\r\n///\r\n/// Contains the named constants used to identify Microsoft UI Automation control types.\r\n#[repr(u32)]\r\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Reflect)]\r\npub enum ControlType {\r\n    /// Identifies the\u00a0Button\u00a0control type.\r\n    Button = 50000u32,\r\n    /// Identifies the\u00a0Calendar\u00a0control type.\r\n    Calendar = 50001u32,\r\n    /// Identifies the\u00a0CheckBox\u00a0control type.\r\n    CheckBox = 50002u32,\r\n    /// Identifies the\u00a0ComboBox\u00a0control type.\r\n    ComboBox = 50003u32,\r\n    /// Identifies the\u00a0Edit\u00a0control type.\r\n    Edit = 50004u32,\r\n    /// Identifies the\u00a0Hyperlink\u00a0control type.\r\n    Hyperlink = 50005u32,\r\n    /// Identifies the\u00a0Image\u00a0control type.\r\n    Image = 50006u32,\r\n    /// Identifies the\u00a0ListItem\u00a0control type.\r\n    ListItem = 50007u32,\r\n    /// Identifies the\u00a0List\u00a0control type.\r\n    List = 50008u32,\r\n    /// Identifies the\u00a0Menu\u00a0control type.\r\n    Menu = 50009u32,\r\n    /// Identifies the\u00a0MenuBar\u00a0control type.\r\n    MenuBar = 50010u32,\r\n    /// Identifies the\u00a0MenuItem\u00a0control type.\r\n    MenuItem = 50011u32,\r\n    /// Identifies the\u00a0ProgressBar\u00a0control type.\r\n    ProgressBar = 50012u32,\r\n    /// Identifies the\u00a0RadioButton\u00a0control type.\r\n    RadioButton = 50013u32,\r\n    /// Identifies the\u00a0ScrollBar\u00a0control type.\r\n    ScrollBar = 50014u32,\r\n    /// Identifies the\u00a0Slider\u00a0control type.\r\n    Slider = 50015u32,\r\n    /// Identifies the\u00a0Spinner\u00a0control type.\r\n    Spinner = 50016u32,\r\n    /// Identifies the\u00a0StatusBar\u00a0control type.\r\n    StatusBar = 50017u32,\r\n    /// Identifies the\u00a0Tab\u00a0control type.\r\n    Tab = 50018u32,\r\n    /// Identifies the\u00a0TabItem\u00a0control type.\r\n    TabItem = 50019u32,\r\n    /// Identifies the\u00a0Text\u00a0control type.\r\n    Text = 50020u32,\r\n    /// Identifies the\u00a0ToolBar\u00a0control type.\r\n    ToolBar = 50021u32,\r\n    /// Identifies the\u00a0ToolTip\u00a0control type.\r\n    ToolTip = 50022u32,\r\n    /// Identifies the\u00a0Tree\u00a0control type.\r\n    Tree = 50023u32,\r\n    /// Identifies the\u00a0TreeItem\u00a0control type.\r\n    TreeItem = 50024u32,\r\n    /// Identifies the Custom control type. For more information, see\u00a0Custom Properties, Events, and Control Patterns.\r\n    Custom = 50025u32,\r\n    /// Identifies the\u00a0Group\u00a0control type.\r\n    Group = 50026u32,\r\n    /// Identifies the\u00a0Thumb\u00a0control type.\r\n    Thumb = 50027u32,\r\n    /// Identifies the\u00a0DataGrid\u00a0control type.\r\n    DataGrid = 50028u32,\r\n    /// Identifies the\u00a0DataItem\u00a0control type.\r\n    DataItem = 50029u32,\r\n    /// Identifies the\u00a0Document\u00a0control type.\r\n    Document = 50030u32,\r\n    /// Identifies the\u00a0SplitButton\u00a0control type.\r\n    SplitButton = 50031u32,\r\n    /// Identifies the\u00a0Window\u00a0control type.\r\n    Window = 50032u32,\r\n    /// Identifies the\u00a0Pane\u00a0control type.\r\n    Pane = 50033u32,\r\n    /// Identifies the\u00a0Header\u00a0control type.\r\n    Header = 50034u32,\r\n    /// Identifies the\u00a0HeaderItem\u00a0control type.\r\n    HeaderItem = 50035u32,\r\n    /// Identifies the\u00a0Table\u00a0control type.\r\n    Table = 50036u32,\r\n    /// Identifies the\u00a0TitleBar\u00a0control type.\r\n    TitleBar = 50037u32,\r\n    /// Identifies the\u00a0Separator\u00a0control type.\r\n    Separator = 50038u32,\r\n    /// Identifies the\u00a0SemanticZoom\u00a0control type. Supported starting with Windows 8.\r\n    SemanticZoom = 50039u32,\r\n    /// Identifies the\u00a0AppBar\u00a0control type. Supported starting with Windows 8.1.\r\n    AppBar = 50040u32,\r\n}\r\nimpl From<uiautomation::controls::ControlType> for ControlType {\r\n    fn from(value: uiautomation::controls::ControlType) -> Self {\r\n        match value {\r\n            uiautomation::controls::ControlType::Button => ControlType::Button,\r\n            uiautomation::controls::ControlType::Calendar => ControlType::Calendar,\r\n            uiautomation::controls::ControlType::CheckBox => ControlType::CheckBox,\r\n            uiautomation::controls::ControlType::ComboBox => ControlType::ComboBox,\r\n            uiautomation::controls::ControlType::Edit => ControlType::Edit,\r\n            uiautomation::controls::ControlType::Hyperlink => ControlType::Hyperlink,\r\n            uiautomation::controls::ControlType::Image => ControlType::Image,\r\n            uiautomation::controls::ControlType::ListItem => ControlType::ListItem,\r\n            uiautomation::controls::ControlType::List => ControlType::List,\r\n            uiautomation::controls::ControlType::Menu => ControlType::Menu,\r\n            uiautomation::controls::ControlType::MenuBar => ControlType::MenuBar,\r\n            uiautomation::controls::ControlType::MenuItem => ControlType::MenuItem,\r\n            uiautomation::controls::ControlType::ProgressBar => ControlType::ProgressBar,\r\n            uiautomation::controls::ControlType::RadioButton => ControlType::RadioButton,\r\n            uiautomation::controls::ControlType::ScrollBar => ControlType::ScrollBar,\r\n            uiautomation::controls::ControlType::Slider => ControlType::Slider,\r\n            uiautomation::controls::ControlType::Spinner => ControlType::Spinner,\r\n            uiautomation::controls::ControlType::StatusBar => ControlType::StatusBar,\r\n            uiautomation::controls::ControlType::Tab => ControlType::Tab,\r\n            uiautomation::controls::ControlType::TabItem => ControlType::TabItem,\r\n            uiautomation::controls::ControlType::Text => ControlType::Text,\r\n            uiautomation::controls::ControlType::ToolBar => ControlType::ToolBar,\r\n            uiautomation::controls::ControlType::ToolTip => ControlType::ToolTip,\r\n            uiautomation::controls::ControlType::Tree => ControlType::Tree,\r\n            uiautomation::controls::ControlType::TreeItem => ControlType::TreeItem,\r\n            uiautomation::controls::ControlType::Custom => ControlType::Custom,\r\n            uiautomation::controls::ControlType::Group => ControlType::Group,\r\n            uiautomation::controls::ControlType::Thumb => ControlType::Thumb,\r\n            uiautomation::controls::ControlType::DataGrid => ControlType::DataGrid,\r\n            uiautomation::controls::ControlType::DataItem => ControlType::DataItem,\r\n            uiautomation::controls::ControlType::Document => ControlType::Document,\r\n            uiautomation::controls::ControlType::SplitButton => ControlType::SplitButton,\r\n            uiautomation::controls::ControlType::Window => ControlType::Window,\r\n            uiautomation::controls::ControlType::Pane => ControlType::Pane,\r\n            uiautomation::controls::ControlType::Header => ControlType::Header,\r\n            uiautomation::controls::ControlType::HeaderItem => ControlType::HeaderItem,\r\n            uiautomation::controls::ControlType::Table => ControlType::Table,\r\n            uiautomation::controls::ControlType::TitleBar => ControlType::TitleBar,\r\n            uiautomation::controls::ControlType::Separator => ControlType::Separator,\r\n            uiautomation::controls::ControlType::SemanticZoom => ControlType::SemanticZoom,\r\n            uiautomation::controls::ControlType::AppBar => ControlType::AppBar,\r\n        }\r\n    }\r\n}\r\n\r\n#[derive(Eq, PartialEq, Clone, Reflect, Hash, Default)]\r\npub struct RuntimeId(pub Vec<i32>);\r\nimpl std::fmt::Display for RuntimeId {\r\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\r\n        write!(\r\n            f,\r\n            \"{}\",\r\n            self.0\r\n                .iter()\r\n                .map(|x| format!(\"{:X}\", x).to_string())\r\n                .collect::<Vec<String>>()\r\n                .join(\",\")\r\n        )\r\n    }\r\n}\r\nimpl std::fmt::Debug for RuntimeId {\r\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\r\n        write!(f, \"{}\", self)\r\n    }\r\n}\r\n\r\n#[derive(Debug, Eq, PartialEq, Clone, Reflect, Default, Hash)]\r\npub enum DrillId {\r\n    Root,\r\n    Child(VecDeque<usize>),\r\n    #[default]\r\n    Unknown,\r\n}\r\nimpl From<Vec<usize>> for DrillId {\r\n    fn from(value: Vec<usize>) -> Self {\r\n        DrillId::Child(value.into())\r\n    }\r\n}\r\nimpl From<VecDeque<usize>> for DrillId {\r\n    fn from(value: VecDeque<usize>) -> Self {\r\n        DrillId::Child(value)\r\n    }\r\n}\r\nimpl From<Vec<i32>> for DrillId {\r\n    fn from(value: Vec<i32>) -> Self {\r\n        DrillId::Child(value.into_iter().map(|x| x as usize).collect())\r\n    }\r\n}\r\nimpl From<VecDeque<i32>> for DrillId {\r\n    fn from(value: VecDeque<i32>) -> Self {\r\n        DrillId::Child(value.into_iter().map(|x| x as usize).collect())\r\n    }\r\n}\r\nimpl std::fmt::Display for DrillId {\r\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\r\n        match self {\r\n            DrillId::Root => write!(f, \"Root\"),\r\n            DrillId::Child(drill_id) => write!(\r\n                f,\r\n                \"{}\",\r\n                drill_id\r\n                    .iter()\r\n                    .map(|x| x.to_string())\r\n                    .collect::<Vec<String>>()\r\n                    .join(\",\")\r\n            ),\r\n            DrillId::Unknown => write!(f, \"Unknown\"),\r\n        }\r\n    }\r\n}\r\n\r\n#[derive(Debug, Clone, Reflect, PartialEq)]\r\n// #[reflect(no_field_bounds)] //https://github.com/bevyengine/bevy/issues/8965\r\npub struct ElementInfo {\r\n    pub name: String,\r\n    pub bounding_rect: IRect,\r\n    pub control_type: ControlType,\r\n    pub localized_control_type: String,\r\n    pub class_name: String,\r\n    pub automation_id: String,\r\n    #[reflect(ignore)]\r\n    pub runtime_id: RuntimeId,\r\n    #[reflect(ignore)]\r\n    pub drill_id: DrillId,\r\n    #[reflect(ignore)]\r\n    pub children: Option<Vec<ElementInfo>>,\r\n}\r\nimpl Default for ElementInfo {\r\n    fn default() -> Self {\r\n        ElementInfo {\r\n            name: \"UNKNOWN ELEMENT INFO\".to_string(),\r\n            bounding_rect: IRect::new(0, 0, 0, 0),\r\n            control_type: ControlType::Pane,\r\n            localized_control_type: \"\".to_string(),\r\n            class_name: \"\".to_string(),\r\n            automation_id: \"\".to_string(),\r\n            runtime_id: RuntimeId::default(),\r\n            drill_id: DrillId::Unknown,\r\n            children: None,\r\n        }\r\n    }\r\n}\r\nimpl TryFrom<UIElement> for ElementInfo {\r\n    type Error = uiautomation::Error;\r\n    fn try_from(value: UIElement) -> Result<Self, Self::Error> {\r\n        let name = value.get_name()?;\r\n        let bounding_rect = value.get_bounding_rectangle()?.to_bevy_irect();\r\n        let control_type = value.get_control_type()?;\r\n        let localized_control_type = value.get_localized_control_type()?;\r\n        let class_name = value.get_classname()?;\r\n        let automation_id = value.get_automation_id()?;\r\n        let runtime_id = value.get_runtime_id()?;\r\n        Ok(ElementInfo {\r\n            name,\r\n            bounding_rect,\r\n            control_type: control_type.into(),\r\n            localized_control_type,\r\n            class_name,\r\n            automation_id,\r\n            runtime_id: RuntimeId(runtime_id),\r\n            drill_id: DrillId::Unknown,\r\n            children: None,\r\n        })\r\n    }\r\n}\r\nimpl ElementInfo {\r\n    pub fn lookup_drill_id(&self, drill_id: DrillId) -> Option<&ElementInfo> {\r\n        self.lookup_drill_id_inner(drill_id, 0)\r\n    }\r\n    fn lookup_drill_id_inner(&self, drill_id: DrillId, skip: usize) -> Option<&ElementInfo> {\r\n        // println!(\"Looking in {} for {:?} ({:?})\", self.name, drill_id.map(|x| x.iter().skip(skip).collect::<Vec<&usize>>()), drill_id);\r\n        if self.drill_id == drill_id {\r\n            return Some(self);\r\n        }\r\n        let DrillId::Child(drill_id) = drill_id else {\r\n            return None;\r\n        };\r\n        if drill_id.is_empty() {\r\n            return None;\r\n        }\r\n        // println!(\"found children {:?}\", children.children.iter().map(|x| x.drill_id.clone()).collect_vec());\r\n        for child in self.children.as_ref()? {\r\n            let DrillId::Child(child_drill_id) = &child.drill_id else {\r\n                continue;\r\n            };\r\n            if child_drill_id.back() == drill_id.get(skip + 1) {\r\n                if skip == drill_id.len() - 1 {\r\n                    return Some(child);\r\n                } else {\r\n                    return child.lookup_drill_id_inner(DrillId::Child(drill_id.clone()), skip + 1);\r\n                }\r\n            }\r\n        }\r\n        None\r\n    }\r\n    pub fn lookup_drill_id_mut(&mut self, drill_id: DrillId) -> Option<&mut ElementInfo> {\r\n        self.lookup_drill_id_mut_inner(drill_id, 0)\r\n    }\r\n\r\n    fn lookup_drill_id_mut_inner(\r\n        &mut self,\r\n        drill_id: DrillId,\r\n        skip: usize,\r\n    ) -> Option<&mut ElementInfo> {\r\n        // println!(\"Looking in {} for {:?} ({:?})\", self.name, drill_id.map(|x| x.iter().skip(skip).collect::<Vec<&usize>>()), drill_id);\r\n        if self.drill_id == drill_id {\r\n            return Some(self);\r\n        }\r\n        let DrillId::Child(drill_id) = drill_id else {\r\n            return None;\r\n        };\r\n        if drill_id.is_empty() {\r\n            return None;\r\n        }\r\n\r\n        for child in self.children.as_deref_mut()?.iter_mut() {\r\n            let DrillId::Child(child_drill_id) = &child.drill_id else {\r\n                continue;\r\n            };\r\n            if child_drill_id.back() == drill_id.get(skip + 1) {\r\n                if skip == drill_id.len() - 1 {\r\n                    return Some(child);\r\n                } else {\r\n                    return child\r\n                        .lookup_drill_id_mut_inner(DrillId::Child(drill_id.clone()), skip + 1);\r\n                }\r\n            }\r\n        }\r\n        None\r\n    }\r\n    pub fn get_descendents(&self) -> Vec<&ElementInfo> {\r\n        let mut descendents = vec![];\r\n        if let Some(children) = &self.children {\r\n            for child in children {\r\n                descendents.push(child);\r\n                descendents.extend(child.get_descendents());\r\n            }\r\n        }\r\n        descendents\r\n    }\r\n}\r\n// test lookup_drill_id\r\n#[cfg(test)]\r\nmod tests {\r\n    #[test]\r\n    fn test_lookup_drill_id() {\r\n        use super::*;\r\n        fn new_elem(name: &str, drill_id: Vec<usize>) -> ElementInfo {\r\n            ElementInfo {\r\n                name: name.to_string(),\r\n                bounding_rect: IRect::new(0, 0, 100, 100),\r\n                control_type: ControlType::Button,\r\n                localized_control_type: \"Button\".to_string(),\r\n                class_name: \"Button\".to_string(),\r\n                automation_id: \"Button\".to_string(),\r\n                runtime_id: RuntimeId::default(),\r\n                drill_id: match drill_id.is_empty() {\r\n                    true => DrillId::Root,\r\n                    false => DrillId::Child(drill_id.into()),\r\n                },\r\n                children: None,\r\n            }\r\n        }\r\n        let mut root = new_elem(\"root\", vec![]);\r\n\r\n        let mut a = new_elem(\"a\", vec![0]);\r\n        let a_a = new_elem(\"a_a\", vec![0, 0]);\r\n        let a_b = new_elem(\"a_b\", vec![0, 1]);\r\n        a.children = Some(vec![a_a.clone(), a_b.clone()]);\r\n\r\n        let mut b = new_elem(\"b\", vec![1]);\r\n        let mut b_a = new_elem(\"b_a\", vec![1, 0]);\r\n        let b_a_a = new_elem(\"b_a_a\", vec![1, 0, 0]);\r\n        let b_a_b = new_elem(\"b_a_b\", vec![1, 0, 1]);\r\n        b_a.children = Some(vec![b_a_a.clone(), b_a_b.clone()]);\r\n        let b_b = new_elem(\"b_b\", vec![1, 1]);\r\n        b.children = Some(vec![b_a.clone(), b_b.clone()]);\r\n\r\n        root.children = Some(vec![a.clone(), b.clone()]);\r\n\r\n        let items = vec![&root, &a, &a_a, &a_b, &b, &b_a, &b_a_a, &b_a_b, &b_b];\r\n        for item in items {\r\n            println!(\"Looking for {}\", item.name);\r\n            let found = root.lookup_drill_id(item.drill_id.clone());\r\n            assert_eq!(found, Some(item));\r\n            println!();\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\templates\\patterns\\new_plugin_with_types\\crates\\{{crate_name}}\\src\\lib.rs\r\n\r\n````rust\r\npub mod {{crate_name}}_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::{{crate_name}}_plugin::*;\r\n}\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\character_types\\src\\character_types.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n\r\n#[derive(Component, Reflect, Default)]\r\npub struct Character;\r\n\r\n#[derive(Component, Reflect, Default)]\r\npub struct MainCharacter;\r\n#[derive(Component, Reflect, Default)]\r\npub struct AgentCharacter;\r\n\r\n#[derive(Component, Reflect, Eq, PartialEq, Debug)]\r\npub enum CharacterAppearance {\r\n    Focused,\r\n    Unfocused,\r\n}\r\nimpl CharacterAppearance {\r\n    pub fn get_texture_path(&self) -> &'static str {\r\n        match self {\r\n            Self::Focused => \"textures/character/default_character_focused.png\",\r\n            Self::Unfocused => \"textures/character/default_character_unfocused.png\",\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\environment_nametag\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_environment_nametag\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\ncursor_hero_environment = { workspace = true}\r\ncursor_hero_bevy = { workspace = true}\r\ncursor_hero_screen = { workspace = true}\r\ncursor_hero_environment_types = { workspace = true}\r\nbevy = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\templates\\patterns\\new_tool\\Cargo.toml\r\n\r\n````toml\r\n{{before_first_workspace_dependency}}\r\ncursor_hero_{{crate_name}}_tool = { path = \"./crates/{{crate_name}}_tool\" }\r\ncursor_hero_{{crate_name}}_tool_types = { path = \"./crates/{{crate_name}}_tool_types\" }\r\n{{first_workspace_dependency_onwards}}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\glados_tts\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_glados_tts\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\ncursor_hero_inference_types = { workspace = true }\r\ncursor_hero_glados_tts_types = { workspace = true }\r\ntokio = {workspace = true}\r\nreqwest = {workspace = true}\r\nurlencoding = {workspace = true}\r\ncrossbeam-channel = { workspace = true }\r\ncursor_hero_environment_types = {workspace = true}\r\ncursor_hero_pointer_types = {workspace = true}\r\ncursor_hero_math = {workspace = true}\r\nbevy_xpbd_2d = { workspace = true }\r\nrodio = { workspace = true, features=[\"wav\"]}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\metrics\\src\\lib.rs\r\n\r\n````rust\r\nuse indexmap::IndexMap;\r\nuse std::time::Duration;\r\nuse std::time::Instant;\r\n\r\n#[derive(Debug, Clone)]\r\npub struct Metric {\r\n    pub name: String,\r\n    pub duration: Duration,\r\n}\r\n\r\n#[derive(Default, Debug)]\r\npub struct Metrics {\r\n    ongoing: IndexMap<String, Instant>,\r\n    completed: IndexMap<String, Duration>,\r\n}\r\n\r\nimpl Metrics {\r\n    pub fn begin(&mut self, name: &str) {\r\n        self.ongoing.insert(name.to_string(), Instant::now());\r\n    }\r\n\r\n    pub fn end(&mut self, name: &str) {\r\n        if let Some(start_time) = self.ongoing.remove(name) {\r\n            let duration = start_time.elapsed();\r\n            self.completed.insert(name.to_string(), duration);\r\n        }\r\n    }\r\n\r\n    #[allow(dead_code)]\r\n    pub fn report(&self) -> String {\r\n        format!(\r\n            \"{} | total {:?}\",\r\n            self.completed\r\n                .iter()\r\n                .map(|(name, duration)| format!(\"{} {:?}\", name, duration))\r\n                .collect::<Vec<_>>()\r\n                .join(\" | \"),\r\n            &self.total()\r\n        )\r\n    }\r\n\r\n    pub fn total(&self) -> Duration {\r\n        self.completed.values().sum()\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n\r\n    #[test]\r\n    fn test_metrics_tracking() {\r\n        let mut metrics = Metrics::default();\r\n\r\n        metrics.begin(\"z first\");\r\n        std::thread::sleep(Duration::from_millis(10));\r\n        metrics.end(\"z first\");\r\n\r\n        metrics.begin(\"a second\");\r\n        std::thread::sleep(Duration::from_millis(20));\r\n        metrics.end(\"a second\");\r\n\r\n        let report = metrics.report();\r\n        println!(\"{}\", report);\r\n        assert!(report.contains(\"z first\"));\r\n        assert!(report.contains(\"a second\"));\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\toolbelt\\src\\tool_help_activate.rs\r\n\r\n````rust\r\nuse cursor_hero_toolbelt_types::toolbelt_types::*;\r\n\r\nuse bevy::prelude::*;\r\nuse bevy_xpbd_2d::components::Collider;\r\nuse bevy_xpbd_2d::components::RigidBody;\r\nuse cursor_hero_pointer_types::prelude::*;\r\n\r\nuse cursor_hero_xelu_prompts::texture_path_for_input;\r\nuse leafwing_input_manager::prelude::*;\r\n\r\npub fn tool_help_activation(\r\n    mut commands: Commands,\r\n    toolbelt_query: Query<(&ActionState<ToolbeltAction>, &Children, &GlobalTransform)>,\r\n    tool_query: Query<(&Tool, &Children)>,\r\n    hovered_query: Query<&GlobalTransform, (With<Hovered>, With<ToolHelpTrigger>)>,\r\n    asset_server: Res<AssetServer>,\r\n) {\r\n    for (toolbelt_actions, toolbelt_children, toolbelt_transform) in toolbelt_query.iter() {\r\n        if toolbelt_actions.just_released(ToolbeltAction::Show) {\r\n            // check all the toolbelt children\r\n            for tool_id in toolbelt_children {\r\n                // if the child is a tool\r\n                if let Ok((tool, tool_children)) = tool_query.get(*tool_id) {\r\n                    // and the tool has children\r\n                    for tool_child_id in tool_children.iter() {\r\n                        // and the hovered child is a tool help trigger\r\n                        if let Ok(hovered_transform) = hovered_query.get(*tool_child_id) {\r\n                            let toolbelt_position = toolbelt_transform.translation();\r\n                            let hovered_position = hovered_transform.translation();\r\n                            let look = hovered_position - toolbelt_position;\r\n                            let position = hovered_position + look;\r\n                            spawn_help_for_tool(&mut commands, position, tool, &asset_server);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\npub fn spawn_help_for_tool(\r\n    commands: &mut Commands,\r\n    position: Vec3,\r\n    tool: &Tool,\r\n    asset_server: &Res<AssetServer>,\r\n) {\r\n    info!(\"Spawning help for tool: {:?}\", tool.name);\r\n    let mut parent_commands = commands.spawn((\r\n        Name::new(format!(\"Help for {}\", tool.name)),\r\n        SpriteBundle {\r\n            sprite: Sprite {\r\n                custom_size: Some(Vec2::new(100.0, 100.0)),\r\n                color: Color::rgba(0.5, 0.5, 1.0, 0.8),\r\n                ..default()\r\n            },\r\n            transform: Transform::from_translation(position),\r\n            ..default()\r\n        },\r\n        ToolHelp {\r\n            timer: Timer::from_seconds(25.0, TimerMode::Once),\r\n        },\r\n        RigidBody::Dynamic,\r\n        Collider::cuboid(100.0, 100.0),\r\n    ));\r\n    parent_commands.with_children(|parent| {\r\n        // image\r\n        parent.spawn(SpriteBundle {\r\n            sprite: Sprite {\r\n                custom_size: Some(Vec2::new(100.0, 100.0)),\r\n                ..default()\r\n            },\r\n            texture: tool.texture.clone(),\r\n            transform: Transform::from_xyz(0.0, 0.0, 1.0),\r\n            ..default()\r\n        });\r\n        // name\r\n        parent.spawn(Text2dBundle {\r\n            text: Text::from_section(\r\n                tool.name.clone(),\r\n                TextStyle {\r\n                    font_size: 20.0,\r\n                    color: Color::WHITE,\r\n                    ..default()\r\n                },\r\n            )\r\n            .with_alignment(TextAlignment::Center),\r\n            transform: Transform::from_xyz(0.0, 60.0, 1.0),\r\n            ..default()\r\n        });\r\n        // description\r\n        parent.spawn(Text2dBundle {\r\n            text: Text::from_section(\r\n                tool.description.clone(),\r\n                TextStyle {\r\n                    font_size: 20.0,\r\n                    color: Color::WHITE,\r\n                    ..default()\r\n                },\r\n            )\r\n            .with_alignment(TextAlignment::Center),\r\n            transform: Transform::from_xyz(0.0, -60.0, 1.0),\r\n            ..default()\r\n        });\r\n\r\n        // actions\r\n        let action_start_y = -100.0; // Starting y position for actions\r\n        let action_spacing_y = 40.0; // Space between each action\r\n        let action_name_x = -150.0;\r\n        let key_size = 50.0; // Size of each key\r\n        let key_spacing_x = key_size + 15.0; // Space between each key\r\n        for (i, (action_name, action_inputs)) in tool.actions.iter().enumerate() {\r\n            let action_y = action_start_y - (i as f32 * action_spacing_y);\r\n\r\n            // Action name text\r\n            parent.spawn(Text2dBundle {\r\n                text: Text::from_section(\r\n                    format!(\"{:?}\", action_name),\r\n                    TextStyle {\r\n                        font_size: 20.0,\r\n                        color: Color::WHITE,\r\n                        ..default()\r\n                    },\r\n                )\r\n                .with_alignment(TextAlignment::Center),\r\n                transform: Transform::from_xyz(action_name_x, action_y, 0.2), // Place text to the left\r\n                ..default()\r\n            });\r\n\r\n            // Keys for action\r\n            let mut key_x = 25.0; // Starting x position for keys\r\n            for action in action_inputs.iter() {\r\n                let key_position = Vec3::new(key_x, action_y, 0.2); // Calculate the position for the key\r\n                key_x += key_spacing_x; // Move the x position for the next key\r\n\r\n                match action {\r\n                    UserInput::Single(kind) => match texture_path_for_input(kind) {\r\n                        Some(path) => {\r\n                            parent.spawn(SpriteBundle {\r\n                                sprite: Sprite {\r\n                                    custom_size: Some(Vec2::new(key_size, key_size)),\r\n                                    ..default()\r\n                                },\r\n                                texture: asset_server.load(path),\r\n                                transform: Transform::from_translation(key_position),\r\n                                ..default()\r\n                            });\r\n                        }\r\n                        None => {\r\n                            warn!(\"No texture for input: {:?}\", kind);\r\n                        }\r\n                    },\r\n                    _ => {\r\n                        warn!(\r\n                            \"Only single inputs are supported for tool help, got {:?}\",\r\n                            action\r\n                        );\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    });\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\templates\\patterns\\new_plugin_with_types\\crates\\{{crate_name}}_types\\src\\{{crate_name}}_types_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse crate::prelude::*;\r\n\r\npub struct {{crate_name_pascal}}TypesPlugin;\r\n\r\nimpl Plugin for {{crate_name_pascal}}TypesPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<MyComponent>();\r\n        app.add_event::<MyEvent>();\r\n    }\r\n}\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\bevy\\src\\rect_extents.rs\r\n\r\n````rust\r\nuse bevy::math::IRect;\r\nuse bevy::math::IVec2;\r\nuse bevy::math::Rect;\r\nuse bevy::math::Vec2;\r\nuse cursor_hero_math::prelude::Corner;\r\n\r\npub trait CornerOfRect {\r\n    fn of(&self, rect: &Rect) -> Vec2;\r\n}\r\nimpl CornerOfRect for Corner {\r\n    fn of(&self, rect: &Rect) -> Vec2 {\r\n        match self {\r\n            Corner::TopLeft => rect.top_left(),\r\n            Corner::TopRight => rect.top_right(),\r\n            Corner::BottomLeft => rect.bottom_left(),\r\n            Corner::BottomRight => rect.bottom_right(),\r\n        }\r\n    }\r\n}\r\n\r\npub trait CornerOfIRect {\r\n    fn of(&self, rect: &IRect) -> IVec2;\r\n}\r\nimpl CornerOfIRect for Corner {\r\n    fn of(&self, rect: &IRect) -> IVec2 {\r\n        match self {\r\n            Corner::TopLeft => rect.top_left(),\r\n            Corner::TopRight => rect.top_right(),\r\n            Corner::BottomLeft => rect.bottom_left(),\r\n            Corner::BottomRight => rect.bottom_right(),\r\n        }\r\n    }\r\n}\r\n\r\npub trait TopRight {\r\n    fn top_right(&self) -> Vec2;\r\n}\r\nimpl TopRight for Rect {\r\n    fn top_right(&self) -> Vec2 {\r\n        Vec2::new(self.max.x, self.min.y)\r\n    }\r\n}\r\n\r\npub trait TopRightI {\r\n    fn top_right(&self) -> IVec2;\r\n}\r\nimpl TopRightI for IRect {\r\n    fn top_right(&self) -> IVec2 {\r\n        IVec2::new(self.max.x, self.min.y)\r\n    }\r\n}\r\n\r\npub trait BottomLeft {\r\n    fn bottom_left(&self) -> Vec2;\r\n}\r\nimpl BottomLeft for Rect {\r\n    fn bottom_left(&self) -> Vec2 {\r\n        Vec2::new(self.min.x, self.max.y)\r\n    }\r\n}\r\n\r\npub trait BottomLeftI {\r\n    fn bottom_left(&self) -> IVec2;\r\n}\r\nimpl BottomLeftI for IRect {\r\n    fn bottom_left(&self) -> IVec2 {\r\n        IVec2::new(self.min.x, self.max.y)\r\n    }\r\n}\r\n\r\npub trait BottomRight {\r\n    fn bottom_right(&self) -> Vec2;\r\n}\r\nimpl BottomRight for Rect {\r\n    fn bottom_right(&self) -> Vec2 {\r\n        self.max\r\n    }\r\n}\r\n\r\npub trait BottomRightI {\r\n    fn bottom_right(&self) -> IVec2;\r\n}\r\nimpl BottomRightI for IRect {\r\n    fn bottom_right(&self) -> IVec2 {\r\n        self.max\r\n    }\r\n}\r\n\r\npub trait TopLeft {\r\n    fn top_left(&self) -> Vec2;\r\n}\r\nimpl TopLeft for Rect {\r\n    fn top_left(&self) -> Vec2 {\r\n        self.min\r\n    }\r\n}\r\n\r\npub trait TopLeftI {\r\n    fn top_left(&self) -> IVec2;\r\n}\r\nimpl TopLeftI for IRect {\r\n    fn top_left(&self) -> IVec2 {\r\n        self.min\r\n    }\r\n}\r\n\r\npub trait Left {\r\n    fn left(&self) -> f32;\r\n}\r\nimpl Left for Rect {\r\n    fn left(&self) -> f32 {\r\n        self.min.x\r\n    }\r\n}\r\n\r\npub trait LeftI {\r\n    fn left(&self) -> i32;\r\n}\r\nimpl LeftI for IRect {\r\n    fn left(&self) -> i32 {\r\n        self.min.x\r\n    }\r\n}\r\n\r\npub trait Right {\r\n    fn right(&self) -> f32;\r\n}\r\nimpl Right for Rect {\r\n    fn right(&self) -> f32 {\r\n        self.max.x\r\n    }\r\n}\r\n\r\npub trait RightI {\r\n    fn right(&self) -> i32;\r\n}\r\nimpl RightI for IRect {\r\n    fn right(&self) -> i32 {\r\n        self.max.x\r\n    }\r\n}\r\n\r\npub trait Bottom {\r\n    fn bottom(&self) -> f32;\r\n}\r\nimpl Bottom for Rect {\r\n    fn bottom(&self) -> f32 {\r\n        self.min.y\r\n    }\r\n}\r\n\r\npub trait BottomI {\r\n    fn bottom(&self) -> i32;\r\n}\r\nimpl BottomI for IRect {\r\n    fn bottom(&self) -> i32 {\r\n        self.min.y\r\n    }\r\n}\r\n\r\npub trait Top {\r\n    fn top(&self) -> f32;\r\n}\r\nimpl Top for Rect {\r\n    fn top(&self) -> f32 {\r\n        self.max.y\r\n    }\r\n}\r\n\r\npub trait TopI {\r\n    fn top(&self) -> i32;\r\n}\r\nimpl TopI for IRect {\r\n    fn top(&self) -> i32 {\r\n        self.max.y\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\bevy\\src\\vec_into_rect.rs\r\n\r\n````rust\r\nuse bevy::math::Rect;\r\nuse bevy::math::Vec2;\r\n\r\npub trait Vec2ToRect {\r\n    fn as_size_of_rect_with_center(&self, center: &Vec2) -> Rect;\r\n}\r\nimpl Vec2ToRect for Vec2 {\r\n    fn as_size_of_rect_with_center(&self, center: &Vec2) -> Rect {\r\n        Rect::from_center_size(*center, *self)\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\window_swap_tool\\src\\window_swap_tool_plugin.rs\r\n\r\n````rust\r\nuse crate::window_swap_tool_populate_plugin::WindowSwapToolPopulatePlugin;\r\nuse bevy::prelude::*;\r\n\r\npub struct WindowSwapToolPlugin;\r\n\r\nimpl Plugin for WindowSwapToolPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_plugins(WindowSwapToolPopulatePlugin);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\templates\\patterns\\new_tool\\crates\\{{crate_name}}_tool\\src\\lib.rs\r\n\r\n````rust\r\npub mod {{crate_name}}_tool_plugin;\r\npub mod {{crate_name}}_tool_populate_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::{{crate_name}}_tool_plugin::*;\r\n}\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\templates\\patterns\\new_tool\\crates\\{{crate_name}}_tool\\src\\{{crate_name}}_tool_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse crate::{{crate_name}}_tool_populate_plugin::{{crate_name_pascal}}ToolPopulatePlugin;\r\n\r\npub struct {{crate_name_pascal}}ToolPlugin;\r\n\r\nimpl Plugin for {{crate_name_pascal}}ToolPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_plugins({{crate_name_pascal}}ToolPopulatePlugin);\r\n    }\r\n}\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\host_fs_types\\src\\lib.rs\r\n\r\n````rust\r\npub mod host_fs_types;\r\npub mod host_fs_types_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::host_fs_types::*;\r\n    pub use crate::host_fs_types_plugin::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\hover\\src\\hover_tool.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse cursor_hero_toolbelt_types::prelude::*;\r\nuse cursor_hero_tools::prelude::*;\r\n\r\nuse crate::hover_ui_automation_plugin::HoverInfo;\r\n\r\npub struct HoverToolPlugin;\r\n\r\nimpl Plugin for HoverToolPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<HoverTool>();\r\n        app.add_systems(Update, toolbelt_events);\r\n        app.add_systems(Update, tick);\r\n    }\r\n}\r\n\r\n#[derive(Component, Reflect, Default)]\r\nstruct HoverTool;\r\n\r\nfn toolbelt_events(\r\n    mut commands: Commands,\r\n    asset_server: Res<AssetServer>,\r\n    mut reader: EventReader<ToolbeltPopulateEvent>,\r\n) {\r\n    for event in reader.read() {\r\n        if event.loadout == ToolbeltLoadout::Inspector {\r\n            ToolSpawnConfig::<HoverTool, NoInputs>::new(HoverTool, event.id, event)\r\n                .with_src_path(file!().into())\r\n                .guess_name(file!())\r\n                .guess_image(file!(), &asset_server, \"png\")\r\n                .with_description(\"UI hover visuals\")\r\n                .spawn(&mut commands);\r\n        }\r\n    }\r\n}\r\n\r\nfn tick(\r\n    tool_query: Query<Entity, (With<ActiveTool>, With<HoverTool>)>,\r\n    mut hover_info: ResMut<HoverInfo>,\r\n) {\r\n    if tool_query.iter().next().is_some() {\r\n        if !hover_info.is_enabled() {\r\n            info!(\"Enabling hover info\");\r\n            hover_info.set_enabled(true);\r\n        }\r\n    } else if hover_info.is_enabled() {\r\n        info!(\"Disabling hover info\");\r\n        hover_info.set_enabled(false);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\worker\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_worker\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\ncursor_hero_worker_types = { workspace = true }\r\ncrossbeam-channel = { workspace = true }\r\ntokio = {workspace = true}\r\nwindows = { workspace = true, features = [\r\n    \"Win32_Foundation\",\r\n    \"Win32_System_Com\",\r\n] }\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\templates\\patterns\\new_tool\\__pattern__.py\r\n\r\n````py\r\ndef gather_global_variables() -> dict[str,str]:\r\n    crate_name = input(\"crate_name\")\r\n    assert crate_name, \"crate_name is required\"\r\n    crate_name_pascal = pascal(crate_name)\r\n    assert not crate_name.endswith(\"tool\")\r\n    return {\r\n        \"crate_name\": crate_name,\r\n        \"crate_name_pascal\": crate_name_pascal,\r\n    }\r\n\r\ndef pascal(snake_string: str) -> str:\r\n    return ''.join(word.capitalize() for word in snake_string.split('_'))\r\n\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\memory\\src\\main_character_memory_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse cursor_hero_character_types::prelude::*;\r\n\r\nuse cursor_hero_memory_types::prelude::*;\r\nuse cursor_hero_toolbelt_types::toolbelt_types::Toolbelt;\r\nuse cursor_hero_toolbelt_types::toolbelt_types::ToolbeltPopulateEvent;\r\nuse serde::Deserialize;\r\nuse serde::Serialize;\r\n\r\npub struct MainCharacterMemoryPlugin;\r\n\r\nimpl Plugin for MainCharacterMemoryPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.insert_resource(MainCharacterMemoryConfig::default());\r\n        app.add_systems(Update, persist.pipe(handle_persist_errors));\r\n        app.add_systems(\r\n            Update,\r\n            (apply_deferred, restore.pipe(handle_restore_errors)).chain(),\r\n        );\r\n    }\r\n}\r\nconst PERSIST_FILE_NAME: &str = \"main_character.json\";\r\n\r\n// not moved to lib to ensure log contains this module name\r\nfn handle_persist_errors(In(result): In<Result<PersistSuccess, PersistError>>) {\r\n    if let Err(e) = result {\r\n        error!(\"Persist error occurred: {:?}\", e);\r\n    } else if let Ok(PersistSuccess::WritePerformed) = result {\r\n        debug!(\"Persisted succeeded\");\r\n    }\r\n}\r\n\r\nfn handle_restore_errors(In(result): In<Result<RestoreSuccess, RestoreError>>) {\r\n    if let Err(e) = result {\r\n        error!(\"Restore error occurred: {:?}\", e);\r\n    } else if let Ok(RestoreSuccess::Performed) = result {\r\n        info!(\"Restore succeeded\");\r\n    }\r\n}\r\n\r\n#[derive(Debug, Resource, Reflect)]\r\n#[reflect(Resource)]\r\nstruct MainCharacterMemoryConfig {\r\n    pub debounce_timer: Timer,\r\n}\r\nimpl Default for MainCharacterMemoryConfig {\r\n    fn default() -> Self {\r\n        Self {\r\n            debounce_timer: Timer::from_seconds(10.0, TimerMode::Repeating),\r\n        }\r\n    }\r\n}\r\n\r\n#[derive(Debug, Serialize, Deserialize, PartialEq, Clone, Copy)]\r\nstruct DiskData {\r\n    character_position: Vec3,\r\n    toolbelt: Toolbelt,\r\n}\r\n\r\nfn persist(\r\n    mut config: ResMut<MainCharacterMemoryConfig>,\r\n    memory_config: Res<MemoryConfig>,\r\n    mut debounce: Local<Option<DiskData>>,\r\n    time: Res<Time>,\r\n    character_query: Query<(&Transform, &Children), With<MainCharacter>>,\r\n    toolbelt_query: Query<&Toolbelt>,\r\n) -> Result<PersistSuccess, PersistError> {\r\n    if !config.debounce_timer.tick(time.delta()).just_finished() {\r\n        return Ok(PersistSuccess::Cooldown);\r\n    }\r\n\r\n    let character = character_query\r\n        .get_single()\r\n        .map_err(|_| PersistError::Query)?;\r\n    let (character_transform, character_children) = character;\r\n    let character_position = character_transform.translation;\r\n\r\n    let mut found = None;\r\n    for child in character_children.iter() {\r\n        match (found, toolbelt_query.get(*child)) {\r\n            (None, Ok(toolbelt)) => {\r\n                found = Some(toolbelt);\r\n            }\r\n            (Some(_), Ok(_)) => {\r\n                return Err(PersistError::Query);\r\n            }\r\n            _ => {}\r\n        }\r\n    }\r\n    let toolbelt = *found.ok_or(PersistError::Query)?;\r\n\r\n    let data = DiskData {\r\n        character_position,\r\n        toolbelt,\r\n    };\r\n    if debounce.is_none() || debounce.as_ref().unwrap() != &data {\r\n        let file = get_persist_file(memory_config.as_ref(), PERSIST_FILE_NAME, Usage::Persist)\r\n            .map_err(PersistError::Io)?;\r\n        write_to_disk(file, data)?;\r\n        *debounce = Some(data);\r\n        Ok(PersistSuccess::WritePerformed)\r\n    } else {\r\n        Ok(PersistSuccess::Debounce)\r\n    }\r\n}\r\n\r\nfn restore(\r\n    memory_config: Res<MemoryConfig>,\r\n    mut character_query: Query<(&mut Transform, &Children), Added<MainCharacter>>,\r\n    mut toolbelt_query: Query<&mut Toolbelt>,\r\n    mut commands: Commands,\r\n    mut toolbelt_events: EventWriter<ToolbeltPopulateEvent>,\r\n) -> Result<RestoreSuccess, RestoreError> {\r\n    let Ok(character) = character_query.get_single_mut() else {\r\n        return Ok(RestoreSuccess::NoAction);\r\n    };\r\n    let (mut character_transform, character_children) = character;\r\n    let mut toolbelt_id = None;\r\n    for child in character_children.iter() {\r\n        match (toolbelt_id, toolbelt_query.contains(*child)) {\r\n            (None, true) => {\r\n                toolbelt_id = Some(child);\r\n            }\r\n            (Some(_), true) => {\r\n                return Err(RestoreError::Query);\r\n            }\r\n            _ => {}\r\n        }\r\n    }\r\n    let toolbelt_id = *toolbelt_id.ok_or(RestoreError::Query)?;\r\n    let mut toolbelt = toolbelt_query\r\n        .get_mut(toolbelt_id)\r\n        .map_err(|_| RestoreError::Query)?;\r\n\r\n    let file = get_persist_file(memory_config.as_ref(), PERSIST_FILE_NAME, Usage::Restore)\r\n        .map_err(RestoreError::Io)?;\r\n    let data: DiskData = read_from_disk(file)?;\r\n\r\n    info!(\r\n        \"Restoring main character position to {:?}\",\r\n        data.character_position\r\n    );\r\n    character_transform.translation = data.character_position;\r\n\r\n    info!(\"Restoring toolbelt to {:?}\", data.toolbelt);\r\n    *toolbelt = data.toolbelt;\r\n    commands.entity(toolbelt_id).despawn_descendants();\r\n    toolbelt_events.send(ToolbeltPopulateEvent {\r\n        id: toolbelt_id,\r\n        loadout: data.toolbelt.loadout,\r\n    });\r\n    // layout is going to get clobbered to defaults by toolbelt_properties_plugin\r\n    // this is fine for now since there are no scenarios where a loadout isn't using its default layout\r\n\r\n    Ok(RestoreSuccess::Performed)\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\toolbelt\\src\\toolbelt_opening_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse cursor_hero_toolbelt_types::toolbelt_types::*;\r\nuse leafwing_input_manager::action_state::ActionState;\r\n\r\npub struct ToolbeltOpeningPlugin;\r\n\r\nimpl Plugin for ToolbeltOpeningPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Update, opening);\r\n    }\r\n}\r\n\r\n#[allow(clippy::type_complexity)]\r\npub fn opening(\r\n    mut toolbelt_query: Query<(Entity, &mut Toolbelt, &ActionState<ToolbeltAction>), Without<Tool>>,\r\n    mut toolbelt_events: EventWriter<ToolbeltOpeningEvent>,\r\n) {\r\n    for toolbelt in toolbelt_query.iter_mut() {\r\n        let (toolbelt_id, mut toolbelt, toolbelt_actions) = toolbelt;\r\n        match (\r\n            toolbelt.open,\r\n            toolbelt_actions.pressed(ToolbeltAction::Show),\r\n        ) {\r\n            (false, true) => {\r\n                // Not open but we are holding the open button\r\n                toolbelt_events.send(ToolbeltOpeningEvent::Opened { toolbelt_id });\r\n                toolbelt.open = true;\r\n            }\r\n            (true, false) => {\r\n                // Open but we are not holding the open button\r\n                toolbelt_events.send(ToolbeltOpeningEvent::Closed { toolbelt_id });\r\n                toolbelt.open = false;\r\n            }\r\n            _ => {}\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\wallpaper\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_wallpaper\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\ncursor_hero_environment_types = { workspace = true }\r\ncursor_hero_winutils = { workspace = true }\r\nbevy = { workspace = true }\r\nwindows = { workspace = true, features = [\r\n    \"Win32_Foundation\",\r\n    \"Win32_UI_WindowsAndMessaging\",\r\n    \"Win32_UI_Input_KeyboardAndMouse\",\r\n] }\r\nimage = { workspace = true}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\research_notes.md\r\n\r\n````markdown\r\n# Research Notes\r\n\r\n## Inference\r\n\r\n- [LM Studio](https://lmstudio.ai/)\r\n\r\n## Fine Tuning\r\n\r\n- [allenai/OLMo: Modeling, training, eval, and inference code for OLMo (github.com)](https://github.com/allenai/OLMo)\r\n- [hiyouga/LLaMA-Factory: Unify Efficient Fine-tuning of 100+ LLMs (github.com)](https://github.com/hiyouga/LLaMA-Factory)\r\n- [OpenAccess-AI-Collective/axolotl: Go ahead and axolotl questions (github.com)](https://github.com/OpenAccess-AI-Collective/axolotl)\r\n- [LLaVA/docs/Finetune\\_Custom\\_Data.md at main - haotian-liu/LLaVA (github.com)](https://github.com/haotian-liu/LLaVA/blob/main/docs/Finetune_Custom_Data.md)\r\n\r\n\r\n## Vision\r\n\r\n- [PTA-Text: A Text Only Click Model - Prompt image, it tells you where it would click](https://huggingface.co/AskUI/pta-text-0.1) ([demo](https://huggingface.co/spaces/AskUI/pta-text-v0.1))\r\n- [Set-of-Mark Visual Prompting for GPT-4V](https://github.com/microsoft/SoM)\r\n- [LLaVA](https://llava.hliu.cc/)\r\n- [YOLOv9](https://github.com/WongKinYiu/yolov9)\r\n- [Ty on X: \"Open Interpreter 0.2.1 is out! -\u00a0 5X launch speed -\u00a0 Local OSS model for GUI control -\u00a0 Native control over Apple Mail, Calendar, Contacts, SMS -\u00a0 New LLM-first web browser (powered by @perplexity\\_ai) -\u00a0 Profiles, Docker, Jupyter export... \u2193 https://t.co/XU4gibTXWk\" / X (twitter.com)](https://twitter.com/FieroTy/status/1767328066290987470)\r\n\r\n## RPA\r\n\r\n- [OpenAdaptAI/OpenAdapt: AI-First Process Automation with Large Multimodal Models (LMMs)](https://github.com/OpenAdaptAI/OpenAdapt)\r\n- [askui/askui: \"What can be said can be solved-\"](https://docs.askui.com/docs/api/Element-Descriptions/text)\r\n- [ddupont808/GPT-4V-Act: AI agent using GPT-4V(ision) capable of using a mouse/keyboard to interact with web UI](https://www.reddit.com/r/MachineLearning/comments/17cy0j7/d_p_web_browsing_uibased_ai_agent_gpt4vact/?share_id=w5kHMEziP5LdHm_2NrlUc&rdt=49921)\r\n- [TobiasNorlund/UI-Act: An AI agent for interacting with a computer using the graphical user interface](https://www.reddit.com/r/MachineLearning/comments/1765v6i/d_p_uibased_ai_agents_uiact/)\r\n- [KillianLucas/open-interpreter: A natural language interface for computers](https://github.com/KillianLucas/open-interpreter)\r\n\r\n\r\n## Windows UI Automation\r\n\r\n- [Accessibility tools - AccEvent (Accessible Event Watcher) - Win32 apps | Microsoft Learn](https://learn.microsoft.com/en-us/windows/win32/winauto/accessible-event-watcher)\r\n- [Accessibility tools - Inspect - Win32 apps | Microsoft Learn](https://learn.microsoft.com/en-us/windows/win32/winauto/inspect-objects)\r\n- [Accessibility Insights](https://accessibilityinsights.io/)\r\n- [Navigation events for WebView2 apps - Microsoft Edge Developer documentation | Microsoft Learn](https://learn.microsoft.com/en-us/microsoft-edge/webview2/concepts/navigation-events)\r\n- [c# - UIAutomation won't retrieve children of an element - Stack Overflow](https://stackoverflow.com/questions/14187110/uiautomation-wont-retrieve-children-of-an-element)\r\n- [comEle = \\_AutomationClient.instance().dll.GetNextSiblingElement(self.Element) Hangs - Issue #30 - yinkaisheng/Python-UIAutomation-for-Windows (github.com)](https://github.com/yinkaisheng/Python-UIAutomation-for-Windows/issues/30)\r\n- [microsoft/WinAppDriver: Windows Application Driver (github.com)](https://github.com/microsoft/WinAppDriver)\r\n- [How to force UI automation tree refresh](https://stackoverflow.com/q/64120894/11141271)\r\n  - mostly interested in the screen reader flag mentioned\r\n    ```\r\n    SystemParametersInfo( SPI_SETSCREENREADER, TRUE, NULL, SPIF_UPDATEINIFILE | SPIF_SENDCHANGE);\r\n    PostMessage( HWND_BROADCAST, WM_WININICHANGE, SPI_SETSCREENREADER, 0);\r\n    ```\r\n- [UI Automation Fundamentals - .NET Framework | Microsoft Learn](https://learn.microsoft.com/en-us/dotnet/framework/ui-automation/ui-automation-fundamentals)\r\n- [Understanding Threading Issues - Win32 apps | Microsoft Learn](https://learn.microsoft.com/en-us/windows/win32/winauto/uiauto-threading)\r\n- [UI Automation Threading Issues - .NET Framework | Microsoft Learn](https://learn.microsoft.com/en-us/dotnet/framework/ui-automation/ui-automation-threading-issues)\r\n- [c# - System.Windows.Automation is extremely slow - Stack Overflow](https://stackoverflow.com/questions/41768046/system-windows-automation-is-extremely-slow)\r\n- [msdn-code-gallery-microsoft/Official Windows Platform Sample/UI Automation document content client sample at master - microsoftarchive/msdn-code-gallery-microsoft (github.com)](https://github.com/microsoftarchive/msdn-code-gallery-microsoft/tree/master/Official%20Windows%20Platform%20Sample/UI%20Automation%20document%20content%20client%20sample)\r\n  - [Browse code samples | Microsoft Learn](https://learn.microsoft.com/en-us/samples/browse/)\r\n- caching\r\n  - [UIAutomation not catching all elements - Microsoft Q&A](https://learn.microsoft.com/en-us/answers/questions/545180/uiautomation-not-catching-all-elements)\r\n  - [Caching UI Automation Properties and Control Patterns - Win32 apps | Microsoft Learn](https://learn.microsoft.com/en-us/windows/win32/winauto/uiauto-cachingforclients)\r\n  - [IUIAutomationElement::FindAllBuildCache (uiautomationclient.h) - Win32 apps | Microsoft Learn](https://learn.microsoft.com/en-us/windows/win32/api/uiautomationclient/nf-uiautomationclient-iuiautomationelement-findallbuildcache)\r\n\r\n## Win32\r\n\r\n- [How does Microsoft's \"inspect.exe\" application keep its window on top? - Microsoft Q&A === WS_EX_TOPMOST, UAC Bypass UI](https://learn.microsoft.com/en-us/answers/questions/1105704/how-does-microsofts-inspect-exe-application-keep-i)\r\n  - [\"Automatic dismissal of the start menu\" and other crazyness - Windows-classic-samples/Samples/DesktopAutomationDismiss at 27ffb0811ca761741502feaefdb591aebf592193 - microsoft/Windows-classic-samples (github.com)](https://github.com/microsoft/Windows-classic-samples/tree/27ffb0811ca761741502feaefdb591aebf592193/Samples/DesktopAutomationDismiss#build-the-sample)\r\n- `[Convert]::ToInt32(\"0x80070012\", 16)` then ctrl+F win32::Foundation to find the error code\r\n- [Process Hacker / Code / \\[r6350\\] /2.x/trunk (sourceforge.net)](https://sourceforge.net/p/processhacker/code/HEAD/tree/2.x/trunk/)\r\n- [Process Monitor - Sysinternals | Microsoft Learn](https://learn.microsoft.com/en-us/sysinternals/downloads/procmon)\r\n- [(1) Building 25+ years of SysInternals: Exploring ZoomIt | BRK200H - YouTube](https://www.youtube.com/watch?v=W2bNgFrj3Iw)\r\n- [c# - Getting icon of \"modern\" Windows app from a desktop application? - Stack Overflow](https://stackoverflow.com/questions/32122679/getting-icon-of-modern-windows-app-from-a-desktop-application)\r\n- [DLL Export Viewer - view exported functions list in Windows DLL (nirsoft.net)](https://www.nirsoft.net/utils/dll_export_viewer.html)\r\n\r\n## RL\r\n\r\n- [stillonearth/bevy_rl](https://github.com/stillonearth/bevy_rl/blob/main/src/render.rs)\r\n- [Saving RenderTarget image data to a file #5603](https://github.com/bevyengine/bevy/discussions/5603)\r\n- [paulkre/bevy_image_export: Bevy plugin for rendering image sequences](https://github.com/paulkre/bevy_image_export)\r\n\r\n\r\n## Prompting\r\n\r\n- [guidance-ai/guidance: A guidance language for controlling large language models.](https://github.com/guidance-ai/guidance)\r\n- [Eladlev/AutoPrompt: A framework for prompt tuning using Intent-based Prompt Calibration (github.com)](https://github.com/Eladlev/AutoPrompt)\r\n\r\n## RAG, Tools and Actions\r\n\r\n- [ACT-1: Transformer for Actions](https://www.adept.ai/blog/act-1)\r\n- [LlamaIndex \ud83e\udd99 v0.10.6](https://docs.llamaindex.ai/en/stable/)\r\n- [Supercharge Your RAG with Contextualized Late Interactions (youtube.com)](https://www.youtube.com/watch?v=xTzUn3G9YA0)\r\n  - [bclavie/RAGatouille](https://github.com/bclavie/RAGatouille)\r\n\r\n## Sandboxing\r\n\r\n- [copy/v86: x86 PC emulator and x86-to-wasm JIT, running in the browser](https://github.com/copy/v86) ([demo](https://copy.sh/v86/))\r\n\r\n## Speech to Text\r\n\r\n- [openai/whisper-large-v2: Hugging Face](https://huggingface.co/openai/whisper-large-v2)\r\n- [m-bain/whisperX: Automatic Speech Recognition with Word-level Timestamps (& Diarization)](https://github.com/m-bain/whisperX)\r\n- [SYSTRAN/faster-whisper: Faster Whisper transcription with CTranslate2](https://github.com/SYSTRAN/faster-whisper)\r\n- [collabora/WhisperLive: A nearly-live implementation of OpenAI's Whisper](https://github.com/collabora/WhisperLive)\r\n- [gaborvecsei/whisper-live-transcription: Live-Transcription (STT) with Whisper PoC (github.com)](https://github.com/gaborvecsei/whisper-live-transcription)\r\n- [FL33TW00D/whisper-turbo: Cross-Platform, GPU Accelerated Whisper \ud83c\udfce\ufe0f (github.com)](https://github.com/FL33TW00D/whisper-turbo)\r\n\r\n## Multiplayer\r\n\r\n- [Veilid: open-source, peer-to-peer, mobile-\ufb01rst, networked application framework.](https://veilid.com/)\r\n\r\n## Impl\r\n\r\n- [beartype](https://beartype.readthedocs.io/en/latest/)\r\n- [facebookresearch/torchdim: Named tensors with first-class dimensions for PyTorch](https://github.com/facebookresearch/torchdim)\r\n- [Are we learning yet? A work-in-progress to catalog the state of machine learning in Rust](https://www.arewelearningyet.com/)\r\n- [PyO3/pyo3: Rust bindings for the Python interpreter](https://github.com/PyO3/pyo3)\r\n\r\n## Assets\r\n\r\n- [Euphoric Heavy Regular](https://fontsgeek.com/fonts/Euphoric-Heavy-Regular)\r\n- [Kenney Fonts](https://kenney.nl/assets/kenney-fonts)\r\n- [Fira Mono - Google Fonts](https://fonts.google.com/specimen/Fira+Mono)\r\n- [Xelu's FREE Controller Prompts (thoseawesomeguys.com)](https://thoseawesomeguys.com/prompts/)\r\n\r\n## Bevy stuff\r\n\r\n- [janhohenheim/foxtrot: The all-in-one Bevy 3D game template for desktop. (github.com)](https://github.com/janhohenheim/foxtrot)\r\n- [StarArawn/bevy\\_ecs\\_tilemap: A tilemap rendering crate for bevy which is more ECS friendly. (github.com)](https://github.com/StarArawn/bevy_ecs_tilemap)\r\n- [djeedai/bevy\\_hanabi: \ud83c\udf86 Hanabi --- a GPU particle system plugin for the Bevy game engine. (github.com)](https://github.com/djeedai/bevy_hanabi)\r\n- [Added Audio Input Support by bushrat011899 - Pull Request #10072 - bevyengine/bevy (github.com)](https://github.com/bevyengine/bevy/pull/10072)\r\n\r\n## Game inspiration\r\n\r\n- [The Last Clockwinder](https://store.steampowered.com/app/1755100/The_Last_Clockwinder/)\r\n\r\n## Issues \ud83d\udc40\r\n\r\n- [Transparent example not working - Issue #2502 - rust-windowing/winit (github.com)](https://github.com/rust-windowing/winit/issues/2502)\r\n\r\n## SDF\r\n\r\n- [SDF arbitary 2D polygon (shadertoy.com)](https://www.shadertoy.com/view/WdSGRd)\r\n- [Arbitrary Polygons, Blur/Border (shadertoy.com)](https://www.shadertoy.com/view/ctBXDK)\r\n\r\n## Video making\r\n\r\n- [Quickstart | Motion Canvas](https://motioncanvas.io/docs/quickstart/)\r\n  - [examples/examples at master - motion-canvas/examples (github.com)](https://github.com/motion-canvas/examples/tree/master/examples)\r\n  - [reviewing your motion canvas animations ![](https://img.youtube.com/vi/lY6D9x9qCt4/0.jpg)](https://www.youtube.com/watch?v=lY6D9x9qCt4)\r\n\r\n## Art\r\n\r\n- [Aseprite - Animated sprite editor & pixel art tool](https://www.aseprite.org/)\r\n\r\n## UI\r\n\r\n- [linebender/vello: An experimental GPU compute-centric 2D renderer. (github.com)](https://github.com/linebender/vello)\r\n  - [loopystudios/bevy\\_vello: An integration to render with Vello in Bevy game engine. (github.com)](https://github.com/loopystudios/bevy_vello)\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\templates\\matchers\\new_tool\\crates\\plugins\\Cargo.toml.py\r\n\r\n````py\r\n# {{before_first_plugins_dependency}}\r\n# cursor_hero_{{crate_name}} = { workspace = true }\r\n# {{first_plugins_dependency_onwards}}\r\n\r\ndef gather_variables(text: str) -> dict[str,str]:\r\n    # before_first_plugins_dependency\r\n    find = \"[dependencies]\"\r\n    include = True\r\n    index = text.find(find)\r\n    assert index != -1, f\"Coult not find `{find}`\"\r\n    index = index + len(find) if include else index\r\n    before_first_plugins_dependency, remaining = text[:index],text[index:]\r\n\r\n    # first_plugins_dependency_onwards\r\n    first_plugins_dependency_onwards = remaining\r\n\r\n    return {\r\n        \"before_first_plugins_dependency\": before_first_plugins_dependency,\r\n        \"first_plugins_dependency_onwards\": first_plugins_dependency_onwards,\r\n    }\r\n\r\n#region OLD CONTENT OF THIS FILE\r\n\r\n# # {{before_first_plugins_dependency}}\r\n# # cursor_hero_{{crate_name}} = { workspace = true }\r\n# # {{first_plugins_dependency_onwards}\r\n# \r\n# from typing import Tuple\r\n# \r\n# def chunk(text: str) -> Tuple[str, str]:\r\n#     index = text.find(\"[dependencies]\")\r\n#     if index == -1:\r\n#         return text, \"# !!!SPLIT FAILED!!!\"\r\n#     return text[:index], text[index:]\r\n# \r\n#endregion\r\n\r\n#region WORKSPACE CONTENT\r\n#[package]\r\n#name = \"cursor_hero_plugins\"\r\n#version = \"0.1.0\"\r\n#edition = \"2021\"\r\n#\r\n## See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n#\r\n#\r\n#[dependencies]\r\n#cursor_hero_environment_types = { workspace = true }\r\n#cursor_hero_chat_types = { workspace = true }\r\n#cursor_hero_chat = { workspace = true }\r\n#cursor_hero_tts = { workspace = true }\r\n#cursor_hero_tts_types = { workspace = true }\r\n#cursor_hero_observation_types = { workspace = true }\r\n#cursor_hero_observation = { workspace = true }\r\n#cursor_hero_inference_types = { workspace = true }\r\n#cursor_hero_inference = { workspace = true }\r\n#cursor_hero_movement_tool_types = { workspace = true }\r\n#cursor_hero_movement_tool = { workspace = true }\r\n#cursor_hero_character_types = { workspace = true }\r\n#cursor_hero_agent_types = { workspace = true }\r\n#cursor_hero_physics_debug = { workspace = true }\r\n#cursor_hero_math = { workspace = true }\r\n#cursor_hero_version = { workspace = true }\r\n#cursor_hero_pointer_types = { workspace = true }\r\n#cursor_hero_toolbelt_types = { workspace = true }\r\n#cursor_hero_sprint_tool_types = { workspace = true }\r\n#cursor_hero_sprint_tool = { workspace = true }\r\n#cursor_hero_agent = { workspace = true }\r\n#cursor_hero_taskbar = { workspace = true }\r\n#cursor_hero_environment_nametag = { workspace = true }\r\n#cursor_hero_environment = { workspace = true }\r\n#cursor_hero_xelu_prompts = { workspace = true }\r\n#cursor_hero_pause_tool = { workspace = true }\r\n#cursor_hero_wallpaper = { workspace = true }\r\n#cursor_hero_cursor_mirror = {workspace = true}\r\n#cursor_hero_hover = {workspace = true}\r\n#cursor_hero_pressure_plate = {workspace = true}\r\n#cursor_hero_level_bounds = {workspace = true}\r\n#cursor_hero_input = {workspace = true}\r\n#cursor_hero_camera = {workspace = true}\r\n#cursor_hero_character = {workspace = true}\r\n#cursor_hero_data = {workspace = true}\r\n#cursor_hero_metrics = {workspace = true}\r\n#cursor_hero_click_drag_character_movement = {workspace = true}\r\n#cursor_hero_physics = {workspace = true}\r\n#cursor_hero_pointer = {workspace = true}\r\n#cursor_hero_screen = {workspace = true}\r\n#cursor_hero_toolbelt = {workspace = true}\r\n#cursor_hero_tools = {workspace = true}\r\n#cursor_hero_ui = {workspace = true}\r\n#cursor_hero_icon = {workspace = true}\r\n#cursor_hero_winutils = {workspace = true}\r\n#cursor_hero_restart_memory = {workspace = true}\r\n#bevy = {workspace = true}\r\n#bevy_embedded_assets = { workspace = true }\r\n#bevy-inspector-egui = { workspace = true }\r\n#\r\n#[dev-dependencies]\r\n#cursor_hero_restart_memory = {workspace = true}\r\n#\r\n#endregion\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\pointer\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_pointer\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\ncursor_hero_character_types = { workspace = true }\r\ncursor_hero_camera = { workspace = true }\r\ncursor_hero_level_bounds = { workspace = true }\r\ncursor_hero_math = { workspace = true }\r\ncursor_hero_bevy = { workspace = true }\r\ncursor_hero_environment_types = { workspace = true }\r\ncursor_hero_input = { workspace = true }\r\ncursor_hero_pointer_types = { workspace = true }\r\ncursor_hero_toolbelt_types = { workspace = true }\r\ncursor_hero_sprint_tool_types = { workspace = true }\r\ncursor_hero_winutils = { workspace = true }\r\nbevy = { workspace = true }\r\nleafwing-input-manager = { workspace = true }\r\nbevy_xpbd_2d = { workspace = true }\r\nbevy_egui = {workspace = true}\r\nbevy-inspector-egui = { workspace = true}\r\nraw-window-handle = {workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\text_asset_types\\src\\lib.rs\r\n\r\n````rust\r\npub mod text_asset_loader_types;\r\npub mod text_asset_types_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::text_asset_loader_types::*;\r\n    pub use crate::text_asset_types_plugin::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\toolbelt\\src\\toolbelt_taskbar_layout_plugin.rs\r\n\r\n````rust\r\nuse std::f32::consts::PI;\r\n\r\nuse bevy::prelude::*;\r\nuse bevy::transform::TransformSystem;\r\nuse bevy::utils::HashSet;\r\nuse bevy_xpbd_2d::components::Position;\r\nuse bevy_xpbd_2d::components::Rotation;\r\nuse bevy_xpbd_2d::PhysicsSet;\r\nuse cursor_hero_math::prelude::Corner;\r\nuse cursor_hero_toolbelt_types::toolbelt_types::Tool;\r\nuse cursor_hero_toolbelt_types::toolbelt_types::ToolHelpTrigger;\r\nuse cursor_hero_toolbelt_types::toolbelt_types::Toolbelt;\r\nuse cursor_hero_toolbelt_types::toolbelt_types::ToolbeltLayout;\r\nuse cursor_hero_window_position_types::prelude::WindowPositionTool;\r\nuse cursor_hero_window_position_types::window_position_types::HostWindowPosition;\r\nuse itertools::Itertools;\r\n\r\npub struct ToolbeltTaskbarLayoutPlugin;\r\n\r\nimpl Plugin for ToolbeltTaskbarLayoutPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(\r\n            PostUpdate,\r\n            position_tools\r\n                .after(PhysicsSet::Sync)\r\n                .after(TransformSystem::TransformPropagate),\r\n        );\r\n    }\r\n}\r\n\r\n#[allow(clippy::type_complexity)]\r\npub fn position_tools(\r\n    toolbelt_query: Query<(Ref<Toolbelt>, &Children, &Parent), Without<Tool>>,\r\n    character_query: Query<&GlobalTransform>,\r\n    mut tool_query: Query<\r\n        (\r\n            Entity,\r\n            Option<&WindowPositionTool>,\r\n            &mut Transform,\r\n            &mut Position,\r\n            &mut Rotation,\r\n            &Children,\r\n        ),\r\n        (With<Tool>, Without<ToolHelpTrigger>),\r\n    >,\r\n    mut tool_help_query: Query<\r\n        (&mut Transform, &mut Position, &mut Rotation),\r\n        (With<ToolHelpTrigger>, Without<Tool>),\r\n    >,\r\n) {\r\n    for toolbelt in toolbelt_query.iter() {\r\n        let (toolbelt, toolbelt_kids, toolbelt_parent) = toolbelt;\r\n        if !toolbelt.is_changed() {\r\n            continue;\r\n        }\r\n        let ToolbeltLayout::Taskbar { wheel, .. } = toolbelt.layout else {\r\n            continue;\r\n        };\r\n        if let Ok(character_position) = character_query.get(**toolbelt_parent) {\r\n            let sorted_window_tools = toolbelt_kids\r\n                .iter()\r\n                .filter(|e| tool_query.contains(**e))\r\n                .filter_map(|e| tool_query.get(*e).ok())\r\n                .filter_map(|(entity, window_position_tool, ..)| {\r\n                    window_position_tool.map(|window_position_tool| (entity, window_position_tool))\r\n                })\r\n                .sorted_by_key(|(_, window_position_tool)| {\r\n                    match window_position_tool.window_position {\r\n                        HostWindowPosition::Corner {\r\n                            ref corner,\r\n                            monitor,\r\n                        } => {\r\n                            monitor * 100\r\n                                + match corner {\r\n                                    Corner::TopLeft => 0,\r\n                                    Corner::TopRight => 1,\r\n                                    Corner::BottomLeft => 2,\r\n                                    Corner::BottomRight => 3,\r\n                                }\r\n                        }\r\n                        HostWindowPosition::Fullscreen { monitor } => 100000 + monitor,\r\n                    }\r\n                })\r\n                .map(|(entity, _)| entity)\r\n                .collect_vec();\r\n            let window_tools = sorted_window_tools.iter().collect::<HashSet<_>>();\r\n            let remaining_tools = toolbelt_kids\r\n                .iter()\r\n                .filter(|e| tool_query.contains(**e))\r\n                .filter(|e| !window_tools.contains(e))\r\n                .collect_vec();\r\n\r\n            let count = remaining_tools.len();\r\n            for (i, tool_id) in remaining_tools.iter().enumerate() {\r\n                let Ok(tool) = tool_query.get_mut(**tool_id) else {\r\n                    continue;\r\n                };\r\n\r\n                let (\r\n                    _tool_id,\r\n                    _position_tool,\r\n                    mut tool_transform,\r\n                    mut tool_position,\r\n                    mut tool_rotation,\r\n                    tool_children,\r\n                ) = tool;\r\n                let angle = 2.0 * PI / (count as f32) * i as f32;\r\n                let x = angle.cos();\r\n                let y = angle.sin();\r\n                tool_transform.scale = Vec2::splat(wheel.scale).extend(1.0);\r\n                let character_position = character_position.translation().xy();\r\n                tool_position.0 =\r\n                    character_position + Vec2::new(x * wheel.radius, y * wheel.radius);\r\n                *tool_rotation = Rotation::from_degrees(wheel.spin);\r\n                for tool_child in tool_children.iter() {\r\n                    if let Ok((\r\n                        mut tool_help_transform,\r\n                        mut tool_help_position,\r\n                        mut tool_help_rotation,\r\n                    )) = tool_help_query.get_mut(*tool_child)\r\n                    {\r\n                        tool_help_transform.scale = Vec2::splat(wheel.scale).extend(1.0);\r\n                        tool_help_position.0 = tool_position.xy()\r\n                            + Vec2::new(x * -wheel.radius * 0.5, y * -wheel.radius * 0.5);\r\n                        *tool_help_rotation = Rotation::from_degrees(wheel.spin);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\glados_tts\\src\\lib.rs\r\n\r\n````rust\r\npub mod glados_tts;\r\npub mod glados_tts_button_plugin;\r\npub mod glados_tts_inference_plugin;\r\npub mod glados_tts_plugin;\r\npub mod glados_tts_status_plugin;\r\npub mod glados_tts_status_worker_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::glados_tts_plugin::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\memory\\src\\primary_window_memory_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse bevy::window::PrimaryWindow;\r\nuse bevy::window::RawHandleWrapper;\r\nuse bevy::window::WindowMode;\r\nuse bevy::window::WindowResolution;\r\nuse bevy::winit::WinitWindows;\r\nuse cursor_hero_memory_types::prelude::*;\r\nuse cursor_hero_winutils::win_window::get_window_inner_bounds;\r\nuse serde::Deserialize;\r\nuse serde::Serialize;\r\n\r\npub struct PrimaryWindowMemoryPlugin;\r\n\r\n// TODO: remember maximized status\r\n\r\nimpl Plugin for PrimaryWindowMemoryPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.insert_resource(PrimaryWindowMemoryConfig::default());\r\n        app.add_systems(Update, persist.pipe(handle_persist_errors));\r\n        app.add_systems(Update, restore.pipe(handle_restore_errors));\r\n    }\r\n}\r\n\r\nconst PERSIST_FILE_NAME: &str = \"primary_window.json\";\r\n\r\n// not moved to lib to ensure log contains this module name\r\nfn handle_persist_errors(In(result): In<Result<PersistSuccess, PersistError>>) {\r\n    if let Err(e) = result {\r\n        error!(\"Persist error occurred: {:?}\", e);\r\n    } else if let Ok(PersistSuccess::WritePerformed) = result {\r\n        debug!(\"Persisted succeeded\");\r\n    }\r\n}\r\n\r\nfn handle_restore_errors(In(result): In<Result<RestoreSuccess, RestoreError>>) {\r\n    if let Err(e) = result {\r\n        error!(\"Restore error occurred: {:?}\", e);\r\n    } else if let Ok(RestoreSuccess::Performed) = result {\r\n        info!(\"Restore succeeded\");\r\n    }\r\n}\r\n\r\n#[derive(Debug, Resource, Reflect)]\r\n#[reflect(Resource)]\r\nstruct PrimaryWindowMemoryConfig {\r\n    pub debounce_timer: Timer,\r\n}\r\nimpl Default for PrimaryWindowMemoryConfig {\r\n    fn default() -> Self {\r\n        Self {\r\n            debounce_timer: Timer::from_seconds(10.0, TimerMode::Repeating),\r\n        }\r\n    }\r\n}\r\n\r\n#[derive(Debug, Serialize, Deserialize, PartialEq, Clone, Copy)]\r\nstruct DiskData {\r\n    resolution: Vec2,\r\n    position: IVec2,\r\n    mode: WindowMode,\r\n}\r\n\r\nfn persist(\r\n    mut config: ResMut<PrimaryWindowMemoryConfig>,\r\n    memory_config: Res<MemoryConfig>,\r\n    time: Res<Time>,\r\n    window_query: Query<(Entity, &RawHandleWrapper, &Window), With<PrimaryWindow>>,\r\n    winit_windows: NonSend<WinitWindows>,\r\n    mut debounce: Local<Option<DiskData>>,\r\n) -> Result<PersistSuccess, PersistError> {\r\n    if !config.debounce_timer.tick(time.delta()).just_finished() {\r\n        return Ok(PersistSuccess::Cooldown);\r\n    }\r\n\r\n    let (window_id, window_handle, window) =\r\n        window_query.get_single().map_err(|_| PersistError::Query)?;\r\n\r\n    let winit_window = winit_windows\r\n        .get_window(window_id)\r\n        .ok_or(PersistError::Query)?;\r\n\r\n    if winit_window.is_minimized().unwrap_or(false) {\r\n        return Ok(PersistSuccess::NoAction);\r\n    }\r\n    let resolution = Vec2::new(\r\n        window.resolution.physical_width() as f32,\r\n        window.resolution.physical_height() as f32,\r\n    );\r\n    let position = match window.position {\r\n        WindowPosition::At(position) => position,\r\n        _ => {\r\n            let hwnd = match window_handle.window_handle {\r\n                raw_window_handle::RawWindowHandle::Win32(handle) => handle.hwnd as isize,\r\n                _ => return Ok(PersistSuccess::NoAction),\r\n            };\r\n            get_window_inner_bounds(hwnd)\r\n                .map_err(PersistError::WindowBounds)?\r\n                .size()\r\n        }\r\n    };\r\n\r\n    let data = DiskData {\r\n        resolution,\r\n        position,\r\n        mode: window.mode,\r\n    };\r\n    if debounce.is_none() || debounce.as_ref().unwrap() != &data {\r\n        let minimized = position.x == -32000 || position.y == -32000;\r\n        if minimized {\r\n            return Ok(PersistSuccess::NoAction);\r\n        }\r\n        let file = get_persist_file(memory_config.as_ref(), PERSIST_FILE_NAME, Usage::Persist)\r\n            .map_err(PersistError::Io)?;\r\n        write_to_disk(file, data)?;\r\n        *debounce = Some(data);\r\n        Ok(PersistSuccess::WritePerformed)\r\n    } else {\r\n        Ok(PersistSuccess::Debounce)\r\n    }\r\n}\r\n\r\nfn restore(\r\n    memory_config: Res<MemoryConfig>,\r\n    mut window_query: Query<&mut Window, Added<PrimaryWindow>>,\r\n) -> Result<RestoreSuccess, RestoreError> {\r\n    let Ok(mut window) = window_query.get_single_mut() else {\r\n        return Ok(RestoreSuccess::NoAction);\r\n    };\r\n    restore_window(memory_config.as_ref(), &mut window)\r\n}\r\n\r\npub fn restore_window(\r\n    memory_config: &MemoryConfig,\r\n    window: &mut Window,\r\n) -> Result<RestoreSuccess, RestoreError> {\r\n    let file = get_persist_file(memory_config, PERSIST_FILE_NAME, Usage::Restore)\r\n        .map_err(RestoreError::Io)?;\r\n    let data: DiskData = read_from_disk(file)?;\r\n    window.resolution = WindowResolution::from(data.resolution);\r\n    window.position = WindowPosition::At(data.position);\r\n    window.mode = data.mode;\r\n    Ok(RestoreSuccess::Performed)\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\taskbar\\src\\taskbar_plugin.rs\r\n\r\n````rust\r\nuse crate::taskbar_spawn_plugin::TaskbarSpawnPlugin;\r\nuse bevy::prelude::*;\r\n\r\npub struct TaskbarPlugin;\r\n\r\nimpl Plugin for TaskbarPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_plugins(TaskbarSpawnPlugin);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\taskbar\\src\\taskbar_spawn_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse bevy::sprite::MaterialMesh2dBundle;\r\nuse cursor_hero_screen::screen_plugin::GameScreen;\r\nuse cursor_hero_taskbar_types::prelude::*;\r\nuse cursor_hero_winutils::win_colors::get_start_color;\r\n\r\npub struct TaskbarSpawnPlugin;\r\n\r\nimpl Plugin for TaskbarSpawnPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Update, spawn_taskbar);\r\n        app.add_systems(Update, populate_taskbar);\r\n    }\r\n}\r\n\r\nfn spawn_taskbar(\r\n    mut commands: Commands,\r\n    screen_query: Query<(Entity, &Sprite), Added<GameScreen>>,\r\n    mut materials: ResMut<Assets<TaskbarMaterial>>,\r\n    mut meshes: ResMut<Assets<Mesh>>,\r\n    asset_server: Res<AssetServer>,\r\n) {\r\n    for screen in screen_query.iter() {\r\n        let (screen_id, screen_sprite) = screen;\r\n        let Some(screen_size) = screen_sprite.custom_size else {\r\n            warn!(\"Screen {:?} has no custom size\", screen_id);\r\n            continue;\r\n        };\r\n        // let taskbar_size = Vec3::new(screen_size.x, 40.0, 1.0);\r\n        let taskbar_size = Vec3::new(screen_size.x, 40.0, 1.0);\r\n        let taskbar_translation = Vec3::new(0.0, -screen_size.y / 2.0 + taskbar_size.y / 2.0, 5.0);\r\n\r\n        let taskbar_color = match get_start_color() {\r\n            Ok(color) => color,\r\n            Err(err) => {\r\n                warn!(\"Couldn't get accent color: {:?}\", err);\r\n                Color::rgba(0.0, 0.0, 0.0, 1.0)\r\n            }\r\n        };\r\n        // color *= Vec3::new(1.0 / 2.5, 2.0, 0.5);\r\n        // color.set_a(0.9);\r\n        // let taskbar_blur_radius = 5;\r\n        // let taskbar_blur_total_samples = ((taskbar_blur_radius * 2 + 1) * (taskbar_blur_radius * 2 + 1));\r\n        commands.entity(screen_id).with_children(|parent| {\r\n            parent.spawn((\r\n                Taskbar {\r\n                    size: taskbar_size.xy(),\r\n                },\r\n                Name::new(\"Taskbar\"),\r\n                // SpriteBundle {\r\n                //     sprite: Sprite {\r\n                //         custom_size: Some(taskbar_size.xy()),\r\n                //         color,\r\n                //         ..default()\r\n                //     },\r\n                //     transform: Transform::from_translation(taskbar_translation),\r\n                //     ..default()\r\n                // },\r\n                MaterialMesh2dBundle {\r\n                    mesh: meshes.add(Mesh::from(shape::Cube::default())).into(),\r\n                    transform: Transform::from_translation(taskbar_translation)\r\n                        .with_scale(taskbar_size),\r\n                    material: materials.add(TaskbarMaterial {\r\n                        // taskbar_blur_radius,\r\n                        // taskbar_blur_total_samples,\r\n                        taskbar_height: taskbar_size.y,\r\n                        taskbar_color,\r\n                        wallpaper_size: screen_size.xy(),\r\n                        wallpaper_texture: Some(\r\n                            asset_server.load(\"textures/environment/game/wallpaper.png\"),\r\n                        ),\r\n                        alpha_mode: AlphaMode::Opaque,\r\n                    }),\r\n                    ..default()\r\n                },\r\n            ));\r\n        });\r\n    }\r\n}\r\n\r\nfn populate_taskbar(\r\n    taskbar_query: Query<Entity, Added<Taskbar>>,\r\n    mut taskbar_events: EventWriter<TaskbarEvent>,\r\n) {\r\n    for taskbar_id in taskbar_query.iter() {\r\n        let event = TaskbarEvent::Populate { taskbar_id };\r\n        debug!(\"Sending taskbar event: {:?}\", event);\r\n        taskbar_events.send(event);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\wallpaper\\src\\main.rs\r\n\r\n````rust\r\nuse cursor_hero_winutils::win_wallpaper::get_transcoded_wallpaper_path;\r\nuse cursor_hero_winutils::win_wallpaper::get_wallpaper_path;\r\nuse std::path::PathBuf;\r\n\r\n/// Will update the wallpaper used in the game environment\r\nfn main() {\r\n    let wallpaper_path = get_wallpaper_path();\r\n    if let Err(e) = wallpaper_path {\r\n        panic!(\"Error: {:?}\", e);\r\n    }\r\n    let mut wallpaper_path = PathBuf::from(wallpaper_path.unwrap());\r\n    println!(\"Wallpaper path: {:?}\", wallpaper_path);\r\n    // check it exists\r\n    if !wallpaper_path.exists() {\r\n        println!(\"Wallpaper path does not exist, attempting transcoded path\");\r\n        wallpaper_path = match get_transcoded_wallpaper_path() {\r\n            Ok(path) => {\r\n                println!(\"Wallpaper path: {:?}\", path);\r\n                // check it exists\r\n                if !path.exists() {\r\n                    panic!(\"Wallpaper path does not exist\");\r\n                }\r\n                path\r\n            }\r\n            Err(e) => panic!(\"Error: {:?}\", e),\r\n        };\r\n    }\r\n    // copy to assets/textures/environment/game/wallpaper.png\r\n    let dest = std::path::Path::new(\"assets/textures/environment/game/wallpaper.png\");\r\n    std::fs::copy(wallpaper_path, dest).unwrap();\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\character\\src\\character_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n\r\nuse crate::character_appearance_plugin::CharacterAppearancePlugin;\r\nuse crate::character_spawning_plugin::CharacterSpawningPlugin;\r\npub struct CharacterPlugin;\r\n\r\nimpl Plugin for CharacterPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_plugins(CharacterAppearancePlugin);\r\n        app.add_plugins(CharacterSpawningPlugin);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\character_types\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_character_types\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\nbevy-inspector-egui = { workspace = true}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\use cases\\structural tools.md\r\n\r\n````markdown\r\nspecify method signature of a system before having copilot build the body\r\n- verbal description of the intent of the system and any method signature suggestions\r\n- recommender system provide a list of parameters that sound relevant\r\n  - mut Commands\r\n  - event readers\r\n  - event writers\r\n  - tool query\r\n  - toolbelt query\r\n  - character query\r\n  - pointer query\r\n  - camera query\r\n  - local parameters\r\n  - resources\r\n  - properties\r\n    - Components\r\n      - Tool\r\n      - Transform\r\n    - Filters\r\n      - With, Without\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\templates\\patterns\\new_plugin_with_types\\crates\\plugins\\src\\lib.rs\r\n\r\n````rust\r\n{{use_statements}}\r\nuse cursor_hero_{{crate_name}}::prelude::*;\r\nuse cursor_hero_{{crate_name}}_types::prelude::*;\r\n{{plugin_start}}\r\n        app.add_plugins({{crate_name_pascal}}TypesPlugin);\r\n        app.add_plugins({{crate_name_pascal}}Plugin);\r\n        {{plugin_remaining}}\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\templates\\patterns\\new_tool\\crates\\{{crate_name}}_tool\\src\\{{crate_name}}_tool_populate_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse cursor_hero_{{crate_name}}_tool_types::prelude::*;\r\nuse cursor_hero_toolbelt_types::prelude::*;\r\nuse cursor_hero_tools::tool_spawning::ToolSpawnConfig;\r\n\r\npub struct {{crate_name_pascal}}ToolPopulatePlugin;\r\n\r\nimpl Plugin for {{crate_name_pascal}}ToolPopulatePlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Update, handle_toolbelt_events);\r\n    }\r\n}\r\n\r\nfn handle_toolbelt_events(\r\n    mut commands: Commands,\r\n    asset_server: Res<AssetServer>,\r\n    mut reader: EventReader<PopulateToolbeltEvent>,\r\n) {\r\n    for event in reader.read() {\r\n        let PopulateToolbeltEvent {\r\n            loadout: ToolbeltLoadout::WindowPosition,\r\n            ..\r\n        } = event\r\n        else {\r\n            continue;\r\n        };\r\n        ToolSpawnConfig::<_, {{crate_name_pascal}}ToolAction>::new(\r\n            {{crate_name_pascal}}Tool::default(),\r\n            event.id,\r\n            event,\r\n        )\r\n        .with_src_path(file!().into())\r\n        .guess_name(file!())\r\n        .guess_image(file!(), &asset_server, \"webp\")\r\n        .with_description(\"REPLACE THIS DESCRIPTION!!!\")\r\n        .spawn(&mut commands);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\input\\src\\lib.rs\r\n\r\n````rust\r\npub mod active_input_state_plugin;\r\npub mod input_plugin;\r\npub mod update_gamepad_settings;\r\n\r\npub use input_plugin::InputPlugin;\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\voice_to_text_types\\src\\lib.rs\r\n\r\n````rust\r\n#![feature(trivial_bounds)]\r\npub mod voice_to_text_types;\r\npub mod voice_to_text_types_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::voice_to_text_types::*;\r\n    pub use crate::voice_to_text_types_plugin::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\start_menu_types\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_start_menu_types\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\templates\\patterns\\new_tool\\crates\\{{crate_name}}_tool_types\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_{{crate_name}}_tool_types\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = { workspace = true }\r\nleafwing-input-manager = { workspace = true }\r\nbevy-inspector-egui = { workspace = true }\r\ncursor_hero_toolbelt_types = { workspace = true }\r\ncursor_hero_input = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\pressure_plate\\src\\lib.rs\r\n\r\n````rust\r\npub mod pressure_plate_plugin;\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\cursor_mirror\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_cursor_mirror\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\ncursor_hero_winutils = { workspace = true}\r\nbevy = { workspace = true }\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\pointer_types\\src\\pointer_types.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n\r\nuse bevy_inspector_egui::prelude::ReflectInspectorOptions;\r\nuse bevy_inspector_egui::InspectorOptions;\r\n\r\nuse crate::pointer_behaviour_types::PointerMovementBehaviour;\r\n\r\n#[derive(SystemSet, Clone, Hash, Debug, PartialEq, Eq)]\r\npub enum PointerSystemSet {\r\n    Position,\r\n}\r\n\r\n#[derive(Reflect, Debug, PartialEq, Eq, Clone)]\r\npub enum PointerLogBehaviour {\r\n    Errors,\r\n    ErrorsAndPositionUpdates,\r\n}\r\n\r\n#[derive(Component, Debug, Reflect)]\r\npub struct MainPointer;\r\n\r\n#[derive(Component, InspectorOptions, Debug, Reflect)]\r\n#[reflect(InspectorOptions)]\r\npub struct Pointer {\r\n    #[inspector(min = 0.0)]\r\n    pub reach: f32,\r\n    #[inspector(min = 0.0)]\r\n    pub default_reach: f32,\r\n    #[inspector(min = 0.0)]\r\n    pub sprint_reach: f32,\r\n    pub movement_behaviour: PointerMovementBehaviour,\r\n    pub log_behaviour: PointerLogBehaviour,\r\n}\r\nimpl Default for Pointer {\r\n    fn default() -> Self {\r\n        Pointer::new_unknown_pointer()\r\n    }\r\n}\r\nimpl Pointer {\r\n    pub fn new_host_pointer() -> Self {\r\n        Self {\r\n            reach: 50.0,\r\n            default_reach: 50.0,\r\n            sprint_reach: 2000.0,\r\n            movement_behaviour: PointerMovementBehaviour::None,\r\n            log_behaviour: PointerLogBehaviour::Errors,\r\n            // log_behaviour: PointerLogBehaviour::ErrorsAndPositionUpdates,\r\n        }\r\n    }\r\n    pub fn new_agent_pointer() -> Self {\r\n        Self {\r\n            reach: 50.0,\r\n            default_reach: 50.0,\r\n            sprint_reach: 2000.0,\r\n            movement_behaviour: PointerMovementBehaviour::None,\r\n            log_behaviour: PointerLogBehaviour::Errors,\r\n            // log_behaviour: PointerLogBehaviour::ErrorsAndPositionUpdates,\r\n        }\r\n    }\r\n    pub fn new_unknown_pointer() -> Self {\r\n        Self {\r\n            reach: 0.0,\r\n            default_reach: 0.0,\r\n            sprint_reach: 0.0,\r\n            movement_behaviour: PointerMovementBehaviour::None,\r\n            log_behaviour: PointerLogBehaviour::Errors,\r\n            // log_behaviour: PointerLogBehaviour::ErrorsAndPositionUpdates,\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui_automation_types\\src\\taskbar_ui_types.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\n\r\n#[derive(Debug, Reflect, Clone)]\r\npub struct Taskbar {\r\n    pub entries: Vec<TaskbarEntry>,\r\n}\r\n#[derive(Debug, Reflect, Clone)]\r\npub struct TaskbarEntry {\r\n    pub name: String,\r\n    pub bounds: IRect,\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\window_position\\src\\window_position_command_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse cursor_hero_window_position_types::window_position_types::WindowPositionCommand;\r\n\r\npub struct WindowPositionCommandPlugin;\r\n\r\nimpl Plugin for WindowPositionCommandPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Update, handle_commands);\r\n    }\r\n}\r\n\r\nfn handle_commands(\r\n    mut command_queue: EventReader<WindowPositionCommand>,\r\n    mut window_query: Query<&mut Window>,\r\n) {\r\n    for command in command_queue.read() {\r\n        let Ok(window) = window_query.get_mut(command.window) else {\r\n            warn!(\"Window {:?} not found\", command.window);\r\n            continue;\r\n        };\r\n        debug!(\"Handling command {:?}\", command);\r\n        let mut window = window;\r\n        if let Some(position) = command.position {\r\n            window.position = position;\r\n        }\r\n        if let Some(resolution) = &command.resolution {\r\n            window.resolution = resolution.clone();\r\n        }\r\n        if let Some(mode) = command.mode {\r\n            window.mode = mode;\r\n        }\r\n        // only handle one command a tick\r\n        break;\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\glados_tts\\src\\glados_tts.rs\r\n\r\n````rust\r\nuse cursor_hero_glados_tts_types::glados_tts_types::GladosTtsStatus;\r\nuse reqwest::Client;\r\nuse std::error::Error;\r\nuse std::process::Command;\r\n\r\npub async fn generate(prompt: &str) -> Result<Vec<u8>, Box<dyn Error>> {\r\n    // Construct the URL for the TTS endpoint\r\n    let url = \"http://localhost:8124/synthesize\";\r\n\r\n    // Create an instance of the reqwest client\r\n    let client = Client::new();\r\n\r\n    // Send a GET request to the server\r\n    let response = client.post(url).body(prompt.to_string()).send().await?;\r\n\r\n    // Ensure the request was successful and extract the bytes\r\n    let bytes = response.bytes().await?;\r\n\r\n    let wav = bytes.to_vec();\r\n\r\n    // Ensure the audio decoder won't crash the freaking game\r\n    rodio::Decoder::new(std::io::Cursor::new(wav.clone()))?;\r\n\r\n    Ok(wav)\r\n}\r\n\r\npub async fn get_status() -> Result<GladosTtsStatus, Box<dyn Error>> {\r\n    let client = Client::new();\r\n    match client.get(\"http://localhost:8124/\").send().await {\r\n        Ok(res) => match res.status().is_success() {\r\n            true => Ok(GladosTtsStatus::Alive),\r\n            false => Ok(GladosTtsStatus::Dead),\r\n        },\r\n        Err(_) => Ok(GladosTtsStatus::Dead),\r\n    }\r\n}\r\n\r\npub fn start() -> Result<(), Box<dyn Error>> {\r\n    // wt --window 0 --profile PowerShell -- pwsh -Command \"cd G:\\ml\\glados-tts-upstream && conda activate gladostts && python .\\engine.py\"\r\n    match std::process::Command::new(\"wt\")\r\n        .args([\r\n            \"--window\",\r\n            \"0\",\r\n            \"--profile\",\r\n            \"PowerShell\",\r\n            \"--title\",\r\n            \"GLaDOS TTS\",\r\n            \"--\",\r\n            \"pwsh\",\r\n            \"-Command\",\r\n            \"\\\"cd\",\r\n            \"G:\\\\ml\\\\glados-tts-upstream\",\r\n            \"&&\",\r\n            \"conda\",\r\n            \"activate\",\r\n            \"gladostts\",\r\n            \"&&\",\r\n            \"python\",\r\n            \".\\\\engine.py\\\"\",\r\n        ])\r\n        .spawn()\r\n    {\r\n        Ok(_) => Ok(()),\r\n        Err(e) => Err(Box::new(e)),\r\n    }\r\n}\r\n\r\npub fn start_vscode() -> Result<(), Box<dyn Error>> {\r\n    match Command::new(r\"C:\\Program Files\\Microsoft VS Code\\Code.exe\")\r\n        .args([\"G:\\\\ml\\\\glados-tts-upstream\"])\r\n        .spawn()\r\n    {\r\n        Ok(_) => Ok(()),\r\n        Err(e) => Err(Box::new(e)),\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\movement_tool_types\\src\\movement_tool_types_plugin.rs\r\n\r\n````rust\r\nuse crate::prelude::*;\r\nuse bevy::prelude::*;\r\n\r\npub struct MovementToolTypesPlugin;\r\n\r\nimpl Plugin for MovementToolTypesPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.register_type::<MovementTool>();\r\n        app.add_event::<MovementTargetEvent>();\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\glados_tts\\src\\glados_tts_status_worker_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse crossbeam_channel::bounded;\r\nuse crossbeam_channel::Receiver;\r\nuse crossbeam_channel::Sender;\r\nuse cursor_hero_glados_tts_types::prelude::*;\r\nuse std::thread;\r\n\r\npub struct GladosTtsStatusWorkerPlugin;\r\n\r\nimpl Plugin for GladosTtsStatusWorkerPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_systems(Startup, create_worker_thread);\r\n        app.add_systems(Update, events_to_bridge);\r\n        app.add_systems(Update, bridge_to_events);\r\n    }\r\n}\r\n\r\n#[derive(Debug)]\r\nenum GameboundMessage {\r\n    Pong { status: GladosTtsStatus },\r\n}\r\n\r\n#[derive(Debug)]\r\nenum ThreadboundMessage {\r\n    Ping,\r\n    Startup,\r\n}\r\n\r\n#[derive(Resource)]\r\nstruct Bridge {\r\n    pub sender: Sender<ThreadboundMessage>,\r\n    pub receiver: Receiver<GameboundMessage>,\r\n}\r\n\r\nfn create_worker_thread(mut commands: Commands) {\r\n    let (game_tx, game_rx) = bounded::<_>(10);\r\n    let (thread_tx, thread_rx) = bounded::<_>(10);\r\n    commands.insert_resource(Bridge {\r\n        sender: thread_tx,\r\n        receiver: game_rx,\r\n    });\r\n\r\n    let game_tx_clone = game_tx.clone();\r\n    thread::Builder::new()\r\n        .name(\"GLaDOS TTS status thread\".to_string())\r\n        .spawn(move || {\r\n            let rt = tokio::runtime::Runtime::new().unwrap();\r\n            rt.block_on(async {\r\n                let game_tx = game_tx_clone;\r\n                loop {\r\n                    let msg = match thread_rx.recv() {\r\n                        Ok(msg) => msg,\r\n                        Err(_) => {\r\n                            error!(\"Threadbound channel failure, exiting\");\r\n                            break;\r\n                        }\r\n                    };\r\n                    match msg {\r\n                        ThreadboundMessage::Ping => {\r\n                            debug!(\"Worker received ping request, pinging GladosTts API\");\r\n                            let status = match crate::glados_tts::get_status().await {\r\n                                Ok(status) => status,\r\n                                Err(e) => {\r\n                                    error!(\"Failed to get status: {:?}\", e);\r\n                                    GladosTtsStatus::Unknown\r\n                                }\r\n                            };\r\n                            if let Err(e) = game_tx.send(GameboundMessage::Pong { status }) {\r\n                                error!(\"Gamebound channel failure, exiting: {}\", e);\r\n                                break;\r\n                            }\r\n                        }\r\n                        ThreadboundMessage::Startup => {\r\n                            debug!(\"Worker received startup request, starting GladosTts API\");\r\n                            if let Err(e) = crate::glados_tts::start() {\r\n                                error!(\"Failed to start: {:?}\", e);\r\n                            };\r\n                        }\r\n                    }\r\n                    std::thread::sleep(std::time::Duration::from_millis(50));\r\n                }\r\n            });\r\n        })\r\n        .expect(\"Failed to spawn thread\");\r\n}\r\n\r\nfn events_to_bridge(\r\n    bridge: ResMut<Bridge>,\r\n    mut ping_events: EventReader<GladosTtsPingEvent>,\r\n    mut status_events: EventReader<GladosTtsStatusEvent>,\r\n) {\r\n    // Detect ping requests\r\n    for event in ping_events.read() {\r\n        let GladosTtsPingEvent::Ping = event else {\r\n            continue;\r\n        };\r\n        let msg = ThreadboundMessage::Ping;\r\n        debug!(\"Sending bridge message: {:?}\", msg);\r\n        if let Err(e) = bridge.sender.send(msg) {\r\n            error!(\"Threadbound channel failure: {}\", e);\r\n        }\r\n    }\r\n\r\n    // Detect startup requests\r\n    let starting = status_events\r\n        .read()\r\n        .any(|event| matches!(event, GladosTtsStatusEvent::Startup));\r\n    if starting {\r\n        status_events.clear();\r\n        let msg = ThreadboundMessage::Startup;\r\n        debug!(\"Sending bridge message: {:?}\", msg);\r\n        if let Err(e) = bridge.sender.send(msg) {\r\n            error!(\"Threadbound channel failure: {}\", e);\r\n        }\r\n    }\r\n}\r\n\r\nfn bridge_to_events(bridge: ResMut<Bridge>, mut events: EventWriter<GladosTtsPingEvent>) {\r\n    for msg in bridge.receiver.try_iter() {\r\n        match msg {\r\n            GameboundMessage::Pong { status } => {\r\n                let event = GladosTtsPingEvent::Pong { status };\r\n                debug!(\"Received bridge response, sending game event {:?}\", event);\r\n                events.send(event);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\memory\\src\\memory_plugin.rs\r\n\r\n````rust\r\nuse bevy::prelude::*;\r\nuse cursor_hero_memory_types::prelude::MemoryConfig;\r\nuse cursor_hero_memory_types::prelude::MemoryPluginBuildConfig;\r\n\r\nuse crate::agent_observation_memory_plugin::AgentObservationMemoryPlugin;\r\nuse crate::main_camera_memory_plugin::MainCameraMemoryPlugin;\r\nuse crate::main_character_memory_plugin::MainCharacterMemoryPlugin;\r\nuse crate::primary_window_memory_plugin::PrimaryWindowMemoryPlugin;\r\nuse crate::voice_to_text_memory_plugin::VoiceToTextMemoryPlugin;\r\n\r\npub struct MemoryPlugin {\r\n    pub config: MemoryConfig,\r\n    pub build_config: MemoryPluginBuildConfig,\r\n}\r\n\r\nimpl Plugin for MemoryPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.insert_resource(self.config.clone());\r\n        if self.build_config.main_character_memory_enabled {\r\n            app.add_plugins(MainCharacterMemoryPlugin);\r\n        }\r\n        if self.build_config.primary_window_memory_enabled {\r\n            app.add_plugins(PrimaryWindowMemoryPlugin);\r\n        }\r\n        if self.build_config.main_camera_memory_enabled {\r\n            app.add_plugins(MainCameraMemoryPlugin);\r\n        }\r\n        if self.build_config.voice_to_text_memory_enabled {\r\n            app.add_plugins(VoiceToTextMemoryPlugin);\r\n        }\r\n        if self.build_config.agent_observation_memory_enabled {\r\n            app.add_plugins(AgentObservationMemoryPlugin);\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\bevy\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"cursor_hero_bevy\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nbevy = {workspace = true}\r\ncursor_hero_math = {workspace = true}\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\chat\\src\\lib.rs\r\n\r\n````rust\r\npub mod chat_bubble_plugin;\r\npub mod chat_focus_exclusivity_plugin;\r\npub mod chat_input_buffer_plugin;\r\npub mod chat_plugin;\r\npub mod chat_sfx_plugin;\r\npub mod chat_tool_plugin;\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\use cases\\updating readme useful stuff links.md\r\n\r\n````markdown\r\nI have in the README.md a list of\r\n\r\n- github projects\r\n- reddit links\r\n- homepages\r\n- research papers\r\n\r\nregarding the recent progress into the genre of tech related to the future of Cursor Hero.\r\n\r\nThe goal is to automate the process of creating a survey paper.\r\n\r\nAnalyze the technology:\r\n\r\n- project name\r\n- what problem does it solve\r\n- core discovery / unique methodology\r\n- tagline according to github / homepage\r\n- integration opportunities (api, python lib, rust lib, container, service (local is better))\r\n\r\nMost importantly, index the info such that it will show up in results when I describe a task I want to accomplish.\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\ui_automation\\examples\\calculator_example.rs\r\n\r\n````rust\r\n#![feature(let_chains)]\r\nuse anyhow::Result;\r\nuse bevy::input::common_conditions::input_toggle_active;\r\nuse bevy::log::LogPlugin;\r\nuse bevy::prelude::*;\r\nuse bevy::window::PrimaryWindow;\r\nuse bevy_inspector_egui::quick::WorldInspectorPlugin;\r\nuse cursor_hero_memory::primary_window_memory_plugin::PrimaryWindowMemoryPlugin;\r\nuse cursor_hero_ui_automation::prelude::*;\r\nuse cursor_hero_worker::prelude::Message;\r\nuse cursor_hero_worker::prelude::Sender;\r\nuse cursor_hero_worker::prelude::WorkerConfig;\r\nuse cursor_hero_worker::prelude::WorkerPlugin;\r\nfn main() {\r\n    let mut app = App::new();\r\n    app.add_plugins(\r\n        DefaultPlugins\r\n            .set(LogPlugin {\r\n                level: bevy::log::Level::DEBUG,\r\n                filter: \"\r\ninfo,\r\nwgpu_core=warn,\r\nwgpu_hal=warn,\r\ncalculator_example=trace,\r\ncursor_hero_worker=debug,\r\n\"\r\n                .replace('\\n', \"\")\r\n                .trim()\r\n                .into(),\r\n            })\r\n            .build(),\r\n    );\r\n    app.add_plugins(WorkerPlugin {\r\n        config: WorkerConfig::<ThreadboundUISnapshotMessage, GameboundUISnapshotMessage> {\r\n            name: \"calculator\".to_string(),\r\n            is_ui_automation_thread: true,\r\n            handle_threadbound_message: handle_threadbound_message,\r\n            ..default()\r\n        },\r\n    });\r\n    app.add_plugins(\r\n        WorldInspectorPlugin::default().run_if(input_toggle_active(false, KeyCode::Grave)),\r\n    );\r\n    app.add_plugins(PrimaryWindowMemoryPlugin);\r\n    app.insert_resource(ClearColor(Color::rgb(0.992, 0.714, 0.69)));\r\n    app.add_systems(Startup, spawn_camera);\r\n    app.add_systems(\r\n        Update,\r\n        step_1_of_making_the_calculators_in_the_game_match_the_calculator_apps_running_in_the_host,\r\n    );\r\n    app.add_systems(\r\n        Update,\r\n        step_2_of_making_the_calculators_in_the_game_match_the_calculator_apps_running_in_the_host,\r\n    );\r\n    app.run();\r\n}\r\n\r\nfn spawn_camera(mut commands: Commands) {\r\n    commands.spawn(Camera2dBundle::default());\r\n}\r\n\r\n#[derive(Debug, Reflect, Clone, Event)]\r\nenum ThreadboundUISnapshotMessage {\r\n    RequestUISnapshot,\r\n}\r\nimpl Message for ThreadboundUISnapshotMessage {}\r\n\r\n#[derive(Debug, Reflect, Clone, Event)]\r\nenum GameboundUISnapshotMessage {\r\n    UISnapshot(UISnapshot),\r\n}\r\nimpl Message for GameboundUISnapshotMessage {}\r\n\r\nfn handle_threadbound_message(\r\n    msg: &ThreadboundUISnapshotMessage,\r\n    reply_tx: &Sender<GameboundUISnapshotMessage>,\r\n) -> Result<()> {\r\n    let ThreadboundUISnapshotMessage::RequestUISnapshot = msg;\r\n    debug!(\"getting state of host calculators\");\r\n    let snapshot = take_snapshot()?;\r\n    if let Err(e) = reply_tx.send(GameboundUISnapshotMessage::UISnapshot(snapshot)) {\r\n        error!(\"Failed to send snapshot: {:?}\", e);\r\n    }\r\n    Ok(())\r\n}\r\n\r\nfn step_1_of_making_the_calculators_in_the_game_match_the_calculator_apps_running_in_the_host(\r\n    // mut data: ResMut<UIData>,\r\n    mut cooldown: Local<Option<Timer>>,\r\n    time: Res<Time>,\r\n    mut events: EventWriter<ThreadboundUISnapshotMessage>,\r\n    window: Query<&Window, With<PrimaryWindow>>,\r\n) {\r\n    let Ok(window) = window.get_single() else {\r\n        return;\r\n    };\r\n    if window.cursor_position().is_some() {\r\n        return;\r\n    }\r\n    let cooldown_over = if let Some(cooldown) = cooldown.as_mut() {\r\n        if cooldown.tick(time.delta()).just_finished() {\r\n            cooldown.reset();\r\n            true\r\n        } else {\r\n            false\r\n        }\r\n    } else {\r\n        cooldown.replace(Timer::from_seconds(0.5, TimerMode::Repeating));\r\n        true\r\n    };\r\n    if !cooldown_over {\r\n        return;\r\n    }\r\n\r\n    // if data.in_flight {\r\n    //     warn!(\"Too fast!\");\r\n    //     return;\r\n    // }\r\n\r\n    events.send(ThreadboundUISnapshotMessage::RequestUISnapshot);\r\n    // data.in_flight = true;\r\n}\r\n\r\nfn step_2_of_making_the_calculators_in_the_game_match_the_calculator_apps_running_in_the_host(\r\n    mut snapshot: EventReader<GameboundUISnapshotMessage>,\r\n    calculator_query: Query<&Calculator>,\r\n    mut commands: Commands,\r\n) {\r\n    for msg in snapshot.read() {\r\n        let GameboundUISnapshotMessage::UISnapshot(snapshot) = msg;\r\n        // debug!(\"Received snapshot: {:?}\", snapshot);\r\n        for app in snapshot.app_windows.iter() {\r\n            let AppWindow::Calculator(calculator) = app else {\r\n                continue;\r\n            };\r\n            debug!(\"Received calculator: {:?}\", calculator);\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\Cursor-Hero\\crates\\worker\\src\\lib.rs\r\n\r\n````rust\r\nmod worker_plugin;\r\n\r\npub mod prelude {\r\n    pub use crate::worker_plugin::*;\r\n    pub use cursor_hero_worker_types::prelude::*;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n# Summary\r\n\r\n\r\n## D:\\Repos\\ml\\gemini-engine\\actions\\Upload images.ps1\r\n\r\n````powershell\r\n# Load cached data\r\nif (Test-Path -Path .\\files.json) {\r\n  $cachedFiles = Get-Content -Path \"files.json\" | ConvertFrom-Json -AsHashtable\r\n}\r\nelse {\r\n  $cachedFiles = @{}\r\n}\r\n\r\n# Find images to upload\r\n$options = Get-ChildItem -Path \".\\images\" `\r\n| Select-Object -ExpandProperty Name\r\n\r\n# Prompt user to select images\r\n$chosen = $options | fzf `\r\n  --multi `\r\n  --header \"Select images to upload\" `\r\n  --bind \"ctrl-a:select-all,ctrl-d:deselect-all,ctrl-t:toggle-all\"\r\nif (-not $chosen) {\r\n  Write-Host \"No file selected. Exiting...\"\r\n  return\r\n}\r\n\r\n# Prepare files\r\n$files = @()\r\nforeach ($file in $chosen) {\r\n  $filePath = \".\\images\\$file\"\r\n  $fileMimetype = \"image/\" + [System.IO.Path]::GetExtension($file).TrimStart(\".\")\r\n  $files += [PSCustomObject]@{\r\n    path        = $filePath\r\n    mimetype    = $fileMimetype\r\n    displayname = $file\r\n  }\r\n}\r\nWrite-Host \"Found $($files.Count) files.\"\r\n\r\n\r\n# Overwrite check\r\n$duplicates = $files | Where-Object { $cachedFiles.ContainsKey($_.path) }\r\nif ($duplicates) {\r\n  Write-Host \"The following files already exist in the cache:\"\r\n  foreach ($duplicate in $duplicates) {\r\n    Write-Host \"-  $($duplicate.displayname)\"\r\n  }\r\n\r\n  $overwrite = Read-Host \"Overwrite? (y/n)\"\r\n  if ($overwrite -ne \"y\") { return }\r\n}\r\n\r\n# Build payload\r\n$file = New-TemporaryFile\r\n[PSCustomObject]@{\r\n  files = $files\r\n} `\r\n| ConvertTo-Json -Compress `\r\n| Set-Content -Path $file.FullName\r\n\r\n# Upload frames using the Python script\r\ntry {\r\n  Write-Host \"Uploading files...\"\r\n  $responses = python '.\\tools\\upload file\\upload file.py' \"$($file.FullName)\"\r\n  $success = $?\r\n}\r\nfinally {\r\n  Remove-Item -Path $file.FullName\r\n}\r\nif ($success -eq $false) {\r\n  Write-Warning \"Failed to upload files.\"\r\n  return\r\n}\r\n\r\n# Update cached data\r\nforeach ($line in $responses) {\r\n  $response = $line | ConvertFrom-Json\r\n  $filePath = $response.path\r\n  $fileUrl = $response.url\r\n  $fileMimetype = $response.mimetype\r\n  $cachedFiles[$filePath] = [PSCustomObject]@{\r\n    path        = $filePath\r\n    url         = $fileUrl\r\n    mimetype    = $fileMimetype\r\n    displayname = \"$filePath\"\r\n  }\r\n}\r\n\r\n# Save updated cached data\r\n$cachedFiles | ConvertTo-Json | Set-Content -Path \"files.json\"\r\n\r\n# Inform the user\r\nWrite-Host \"Uploaded files and updated cache.\"\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\ml\\gemini-engine\\actions\\Upload video frames.ps1\r\n\r\n````powershell\r\n# Load cached data\r\nif (Test-Path -Path .\\files.json) {\r\n    $cachedFiles = Get-Content -Path \"files.json\" | ConvertFrom-Json -AsHashtable\r\n}\r\nelse {\r\n    $cachedFiles = @{}\r\n}\r\n  \r\n\r\n# Pick the video\r\n$video = Get-ChildItem -Directory '.\\video frames' `\r\n| Select-Object -ExpandProperty Name\r\n| fzf --header \"Select a video\"\r\n\r\nif (-not $video) {\r\n    Write-Host \"No video selected. Exiting...\"\r\n    return\r\n}\r\n\r\n\r\n# Prepare files\r\n$path = Join-Path -Path \".\\video frames\" -ChildPath $video\r\n$files = Get-ChildItem -LiteralPath $path `\r\n| ForEach-Object {\r\n    $path = $_.FullName\r\n    $mimetype = \"image/png\" # Assuming PNG format for frames\r\n    return [PSCustomObject]@{\r\n        path        = $path\r\n        mimetype    = $mimetype\r\n        displayname = \"$basename - 1 FPS - Frame $($_.BaseName)\"\r\n    }\r\n}\r\nWrite-Host \"Found $($files.Count) frames in $video.\"\r\n\r\n# Overwrite check\r\n$duplicates = $files | Where-Object { $cachedFiles.ContainsKey($_.path) }\r\nif ($duplicates) {\r\n  Write-Host \"The following files already exist in the cache:\"\r\n  foreach ($duplicate in $duplicates) {\r\n    Write-Host \"-  $($duplicate.displayname)\"\r\n  }\r\n\r\n  $overwrite = Read-Host \"Overwrite? (y/n)\"\r\n  if ($overwrite -ne \"y\") { return }\r\n}\r\n\r\n# Build payload\r\n$file = New-TemporaryFile\r\n[PSCustomObject]@{\r\n    files = $files\r\n} `\r\n| ConvertTo-Json -Compress `\r\n| Set-Content -Path $file.FullName\r\n\r\n# Upload frames using the Python script\r\ntry {\r\n    Write-Host \"Uploading files...\"\r\n    $responses = python '.\\tools\\upload file\\upload file.py' \"$($file.FullName)\"\r\n    $success = $?\r\n}\r\nfinally {\r\n    Remove-Item -Path $file.FullName\r\n}\r\nif ($success -eq $false) {\r\n    Write-Warning \"Failed to upload files.\"\r\n    return\r\n}\r\n\r\n# Update cached data\r\nforeach ($line in $responses) {\r\n    $response = $line | ConvertFrom-Json\r\n    $filePath = $response.path\r\n    $fileUrl = $response.url\r\n    $fileMimetype = $response.mimetype\r\n    $cachedFiles[$filePath] = [PSCustomObject]@{\r\n        path        = $filePath\r\n        url         = $fileUrl\r\n        mimetype    = $fileMimetype\r\n        displayname = \"$filePath\"\r\n    }\r\n}\r\n  \r\n# Save updated cached data\r\n$cachedFiles | ConvertTo-Json | Set-Content -Path \"files.json\"\r\n  \r\n# Inform the user\r\nWrite-Host \"Uploaded files and updated cache.\"\r\n  \r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\ml\\gemini-engine\\summarizable_patterns.txt\r\n\r\n````txt\r\n\\.txt$\r\n\\.md$\r\n\\.rs$\r\n\\.ps1$\r\n\\.meta$\r\n\\.ts$\r\n\\.tsx$\r\n\\.py$\r\n\\.svg$\r\nCargo.toml$\r\npackage.json\r\ntsconfig.json\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\ml\\gemini-engine\\actions\\Summarize directory to clipboard.ps1\r\n\r\n````powershell\r\n# Prompt user to enter the directory to summarize\r\n$starting_dir = Read-Host \"Enter the directory to summarize\"\r\nif ([string]::IsNullOrWhiteSpace($starting_dir) -or -not (Test-Path $starting_dir)) {\r\n    Write-Host \"Invalid or no directory specified. Exiting...\"\r\n    return\r\n}\r\n\r\n# Check if the specified directory is a Git repository\r\n$choices = cargo run --manifest-path \".\\tools\\list unignored files\\Cargo.toml\" -- $starting_dir\r\n\r\n# Load ignore patterns\r\n$ignore_patterns = Get-Content .\\ignore_patterns.txt\r\nif ($? -eq $false) {\r\n    Write-Warning \"No ignore patterns found. Continuing without any ignore patterns\"\r\n    Pause\r\n    $ignore_patterns = @()\r\n}\r\n\r\n# Apply ignore patterns\r\n$choices = $choices | Where-Object { \r\n    $file = $_\r\n    $ignore = $false\r\n    foreach ($pattern in $ignore_patterns) {\r\n        if ($file -match $pattern) {\r\n            $ignore = $true\r\n            break\r\n        }\r\n    }\r\n    -not $ignore\r\n}\r\n\r\n# There is opportunity for a submenu here to present the user the current extension list and allow them to modify it considering the extensions found in the directory\r\n$allowed_patterns = Get-Content .\\summarizable_patterns.txt\r\n\r\n# Ensure that the user is only presented files with allowed extensions\r\n$choices = $choices | Where-Object { \r\n    foreach ($pattern in $allowed_patterns) {\r\n        if ($_ -match $pattern) {\r\n            return $true\r\n        }\r\n    }\r\n    return $false\r\n}\r\n\r\n# Prompt the user to select files to summarize\r\n$files = @()\r\nwhile ($true) {\r\n    $chosen = $choices | fzf --multi --bind \"ctrl-a:select-all,ctrl-d:deselect-all,ctrl-t:toggle-all\" --header \"Selection will repeat until Ctrl+C received\"\r\n    if ($null -eq $chosen) {\r\n        break\r\n    }\r\n    $files += $chosen\r\n}\r\nif ($files.Count -eq 0) {\r\n    Write-Warning \"No files picked, no action taken\"\r\n    return\r\n}\r\n\r\n$lang_ext_lookup = Get-Content .\\extension_to_markdown_fence.ini -Raw | ConvertFrom-StringData\r\n\r\n$content = $files | ForEach-Object { \r\n    $path = $_\r\n    $content = Get-Content -LiteralPath \"$path\" -Raw\r\n    $extension = [System.IO.Path]::GetExtension($path)\r\n    $lang = $lang_ext_lookup[$extension] ?? $extension.TrimStart('.')\r\n    return \"\r\n## $path\r\n\r\n$('`'*4)$lang\r\n$content\r\n$('`'*4)\r\n\r\n\"\r\n}\r\n| Out-String\r\n$content = \"# Summary`n`n$content`n\"\r\n$content | Set-Clipboard\r\nWrite-Host \"Copied $($files.Count) files to clipboard\"\r\n\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\ml\\gemini-engine\\gemini.ps1\r\n\r\n````powershell\r\n# Action loop\r\nwhile ($true) {\r\n  # Prompt user to select an action\r\n  $action = Get-ChildItem -Path actions `\r\n    | Select-Object -ExpandProperty name `\r\n    | Sort-Object -Descending `\r\n    | fzf --prompt \"Action: \" --header \"Select an action to run\"\r\n  if ([string]::IsNullOrWhiteSpace($action)) {\r\n    break\r\n  }\r\n\r\n  # Run the selected action\r\n  . \".\\actions\\$action\"\r\n  \r\n  # Leave the action display on the screen for a moment\r\n  # (the action loop clears it with fzf)\r\n  pause\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\ml\\gemini-engine\\tools\\transcription\\requirements.txt\r\n\r\n````txt\r\ngit+https://github.com/SYSTRAN/faster-whisper.git@e0c3a9e#egg=faster-whisper\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\ml\\gemini-engine\\actions\\Edit prompts.ps1\r\n\r\n````powershell\r\n# Get prompt files\r\n$prompts = Get-ChildItem -Path \"prompts\"\r\n\r\n$file = $prompts | fzf --prompt \"Select prompt to edit: \" --header \"Cached Prompts\"\r\n& hx \"prompts\\$file\"\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\ml\\gemini-engine\\actions\\Install python dependencies.ps1\r\n\r\n````powershell\r\npip install -q google-api-python-client google-generativeai\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\ml\\gemini-engine\\actions\\Interactive mode.ps1\r\n\r\n````powershell\r\n# Load cached data\r\nif (Test-Path -Path .\\files.json) {\r\n    $cachedFiles = Get-Content -Path \"files.json\" | ConvertFrom-Json -AsHashtable\r\n  }\r\n  else {\r\n    $cachedFiles = @{}\r\n  }\r\n\r\n# Pick files to include\r\n$files = @()\r\n$chosen = $cachedFiles.Keys `\r\n| fzf `\r\n    --multi `\r\n    --header \"Select files to include in prompt\" `\r\n    --bind \"ctrl-a:select-all,ctrl-d:deselect-all,ctrl-t:toggle-all\"\r\nif (-not $chosen) {\r\n    Write-Host \"No files selected.\"\r\n} else {\r\n    foreach ($file in $chosen) {\r\n        $files += $cachedFiles[$file]\r\n        Write-Host \"Added $file\"\r\n    }\r\n}\r\n\r\n# Begin inference loop\r\nwhile ($true) {\r\n    Write-Host \"Including $($files.Count) files in prompt...\"\r\n    # Pick prompt\r\n    $prompt = Read-Host \"Prompt\"\r\n    if ([string]::IsNullOrWhiteSpace($prompt)) {\r\n        return\r\n    }\r\n\r\n    # Prepare payload\r\n    $payload = [pscustomobject]@{\r\n        prompt = $prompt\r\n        files = $files\r\n    }\r\n    foreach ($key in $chosen_file_keys) {\r\n        $payload.files += $uploaded_files[$key]\r\n    }\r\n    $file = New-TemporaryFile\r\n    $payload | ConvertTo-Json | Set-Content -Path $file.FullName\r\n\r\n\r\n    # Invoke model followed by cleanup\r\n    try {\r\n        python .\\tools\\inference\\inference.py \"$($file.FullName)\" | code -\r\n    } finally {\r\n        Remove-Item -Path $file.FullName\r\n    }\r\n    \r\n    # Leave the result on the screen for a moment\r\n    pause\r\n}\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\ml\\gemini-engine\\actions\\Manually set API key.ps1\r\n\r\n````powershell\r\n# Read the secure string\r\nWrite-Host -NoNewLine \"Enter the API key: \"\r\n$secureString = Read-Host -AsSecureString\r\n\r\n# Convert SecureString to BSTR (Basic String) and then to a plain text string\r\n$ptr = [Runtime.InteropServices.Marshal]::SecureStringToBSTR($secureString)\r\ntry {\r\n    $plainText = [Runtime.InteropServices.Marshal]::PtrToStringBSTR($ptr)\r\n} finally {\r\n    # Make sure to free the BSTR to prevent memory leaks\r\n    [Runtime.InteropServices.Marshal]::ZeroFreeBSTR($ptr)\r\n}\r\n\r\n# Now you can use $plainText as a regular string\r\n# For example, setting it as an environment variable\r\n$ENV:GEMINI_API_KEY = $plainText\r\n\r\n# Use the environment variable\r\nWrite-Host \"Set the API key as an environment variable.\"\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\ml\\gemini-engine\\actions\\Perform inference.ps1\r\n\r\n````powershell\r\n# Ensure API key is present\r\nif (-not (Test-Path Env:GEMINI_API_KEY)) {\r\n    Write-Warning \"GEMINI_API_KEY environment variable not set.\"\r\n    return\r\n}\r\n\r\n# Get list of uploaded files\r\nif (Test-Path -Path .\\files.json) {\r\n    $uploaded_files = Get-Content -Path \"files.json\" | ConvertFrom-Json -AsHashtable\r\n} else {\r\n    $uploaded_files = @{}\r\n}\r\n\r\n# Pick files\r\n$chosen_file_keys = $uploaded_files.Keys `\r\n| fzf `\r\n--multi `\r\n--prompt \"Select files: \" `\r\n--bind \"ctrl-a:select-all,ctrl-d:deselect-all,ctrl-t:toggle-all\"\r\n\r\n\r\n# Pick prompt\r\nPush-Location prompts\r\n$env:SHELL=\"pwsh\"\r\n$chosenPromptName = fzf `\r\n    --preview \"bat {}\" `\r\n    --prompt \"Select prompt: \" `\r\n    --header \"Available Prompts\"\r\nPop-Location\r\nif (-not $chosenPromptName) {\r\n    Write-Warning \"No prompt selected. Exiting...\"\r\n    return\r\n}\r\n$prompt = Get-Content -Raw \"prompts\\$chosenPromptName\"\r\n\r\n# Prepare payload\r\n$payload = [pscustomobject]@{\r\n    prompt = $prompt\r\n    files = @()\r\n}\r\nforeach ($key in $chosen_file_keys) {\r\n    $payload.files += $uploaded_files[$key]\r\n}\r\n$file = New-TemporaryFile\r\n$payload | ConvertTo-Json | Set-Content -Path $file.FullName\r\n\r\n# Invoke model followed by cleanup\r\ntry {\r\n    python .\\tools\\inference\\inference.py \"$($file.FullName)\" | code -\r\n} finally {\r\n    Remove-Item -Path $file.FullName\r\n}\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\ml\\gemini-engine\\actions\\Extract video frames.ps1\r\n\r\n````powershell\r\n# Pick the video\r\n$video = Get-ChildItem .\\videos\\ `\r\n| Select-Object -ExpandProperty Name\r\n| fzf --header \"Select a video\"\r\n\r\nif (-not $video) {\r\n    Write-Host \"No video selected. Exiting...\"\r\n    return\r\n}\r\n\r\nWrite-Host \"You chose $video\"\r\n\r\n# Calculate destination path\r\n$basename = [System.IO.Path]::ChangeExtension($video, \"\")\r\n$out_dir = \".\\video frames\\$basename\"\r\nNew-Item -ItemType Directory -Force -Path $out_dir -ErrorAction SilentlyContinue | Out-Null\r\n\r\n# Extract frames using ffmpeg\r\nffmpeg -i \".\\videos\\$video\" -vf \"fps=1\" \"$out_dir\\frame_%04d.png\"\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\ml\\gemini-engine\\Cargo.toml\r\n\r\n````toml\r\n[workspace]\r\nmembers = [\"tools/list unignored files\"]\r\nresolver = \"2\"\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\ml\\gemini-engine\\tools\\inference\\inference.py\r\n\r\n````py\r\n# gemini_invoke.py\r\nimport googleapiclient.discovery\r\nimport requests\r\nimport sys\r\nimport sys\r\nimport json\r\nfrom googleapiclient.discovery import build\r\nimport os\r\nfrom dataclasses import dataclass, asdict\r\nfrom dacite import from_dict\r\nimport httplib2\r\n\r\n@dataclass(frozen=True)\r\nclass PayloadFile:\r\n    url: str\r\n    mimetype: str\r\n\r\n\r\n@dataclass(frozen=True)\r\nclass Payload:\r\n    prompt: str\r\n    files: list[PayloadFile]\r\n\r\n\r\ndef info(*args):\r\n    for arg in args:\r\n        sys.stderr.write(f\"{arg} \")\r\n    sys.stderr.write(\"\\n\")\r\n\r\n\r\ndef build_service(api_key):\r\n    GENAI_DISCOVERY_URL = f\"https://generativelanguage.googleapis.com/$discovery/rest?version=v1beta&key={api_key}\"\r\n    discovery_docs = requests.get(GENAI_DISCOVERY_URL)\r\n    genai_service = googleapiclient.discovery.build_from_document(\r\n        discovery_docs.json(),\r\n        developerKey=api_key,\r\n        http=httplib2.Http(timeout=60 * 5),\r\n    )\r\n    return genai_service.models()\r\n\r\n\r\ndef invoke_gemini(models_api, payload: Payload):\r\n    # Prepare request body\r\n    params = {\r\n        \"model\": \"models/gemini-1.5-pro-latest\",\r\n        \"body\": {\r\n            \"contents\": [\r\n                {\r\n                    \"parts\": [\r\n                        {\"text\": payload.prompt},\r\n                    ]\r\n                }\r\n            ]\r\n        },\r\n    }\r\n\r\n    # Include files in request\r\n    if not payload.files:\r\n        info(\"No files detected in request\")\r\n    for file in payload.files:\r\n        print(f\"Including file {file.url} ({file.mimetype}) in request\")\r\n        params[\"body\"][\"contents\"][0][\"parts\"].append(\r\n            {\"file_data\": {\"file_uri\": file.url, \"mime_type\": file.mimetype}}\r\n        )\r\n\r\n    # Send request and print response\r\n    resp = models_api.generateContent(**params).execute()\r\n\r\n    # Save response\r\n    if not os.path.exists(\"responses\"):\r\n        os.makedirs(\"responses\")\r\n    history_file = f\"responses/{len(os.listdir('responses'))}.json\"\r\n    history_entry = {\r\n        \"payload\": asdict(payload),\r\n        \"response\": resp,\r\n    }\r\n    with open(history_file, \"w\", encoding=\"utf-8\") as f:\r\n        json.dump(history_entry, f, indent=4)\r\n\r\n    # Print response\r\n    print(resp[\"candidates\"][0][\"content\"][\"parts\"][0][\"text\"])\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    # Build API service\r\n    api_key = os.environ.get(\"GEMINI_API_KEY\")\r\n    if not api_key:\r\n        raise Exception(\"GEMINI_API_KEY environment variable is not set.\")\r\n    models_api = build_service(api_key)\r\n\r\n    # Parse payload\r\n    file = sys.argv[1]\r\n    with open(file, \"r\", encoding=\"utf-8\") as f:\r\n        payload = json.load(f)\r\n    payload = from_dict(data_class=Payload, data=payload)\r\n    # info(payload)\r\n\r\n    # Invoke Gemini\r\n    invoke_gemini(models_api, payload)\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\ml\\gemini-engine\\tools\\transcription\\assert_cuda_is_available.py\r\n\r\n````py\r\nimport torch\r\nassert torch.cuda.is_available()\r\nprint(\"CUDA is available!!!!\")\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\ml\\gemini-engine\\tools\\transcription\\transcribe.py\r\n\r\n````py\r\nfrom faster_whisper import WhisperModel\r\nimport sys\r\n\r\n# file path is first arg\r\nfile_path = sys.argv[1]\r\n# assert ends with mp3\r\nassert file_path.endswith(\".mp3\")\r\nprint(\"Transcribing file: \", file_path)\r\n\r\n# model_size = \"large-v3\"\r\nmodel_size = \"distil-large-v3\"\r\n\r\n# Run on GPU with FP16\r\nmodel = WhisperModel(model_size, device=\"cuda\", compute_type=\"float16\")\r\n\r\nsegments, info = model.transcribe(file_path, beam_size=5, language=\"en\", condition_on_previous_text=False)\r\n\r\nfor segment in segments:\r\n    print(\"[%.2fs -> %.2fs] %s\" % (segment.start, segment.end, segment.text))\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\ml\\gemini-engine\\actions\\Count prompt tokens.ps1\r\n\r\n````powershell\r\n# Ensure API key is present\r\nif (-not (Test-Path Env:GEMINI_API_KEY)) {\r\n    Write-Warning \"GEMINI_API_KEY environment variable not set.\"\r\n    return\r\n}\r\n\r\n# Get list of uploaded files\r\nif (Test-Path -Path .\\files.json) {\r\n    $uploaded_files = Get-Content -Path \"files.json\" | ConvertFrom-Json -AsHashtable\r\n} else {\r\n    $uploaded_files = @{}\r\n}\r\n\r\n# Pick files\r\n$chosen_file_keys = $uploaded_files.Keys `\r\n| fzf `\r\n--multi `\r\n--prompt \"Select files: \" `\r\n--bind \"ctrl-a:select-all,ctrl-d:deselect-all,ctrl-t:toggle-all\"\r\n\r\n# Pick prompt\r\nPush-Location prompts\r\n$env:SHELL=\"pwsh\"\r\n$chosenPromptName = fzf `\r\n    --preview \"bat {}\" `\r\n    --prompt \"Select prompt: \" `\r\n    --header \"Available Prompts\"\r\nPop-Location\r\nif (-not $chosenPromptName) {\r\n    Write-Warning \"No prompt selected. Exiting...\"\r\n    return\r\n}\r\n$prompt = Get-Content -Raw \"prompts\\$chosenPromptName\"\r\n\r\n# Prepare payload\r\n$payload = [pscustomobject]@{\r\n    prompt = $prompt\r\n    files = @()\r\n}\r\nforeach ($key in $chosen_file_keys) {\r\n    $payload.files += $uploaded_files[$key]\r\n}\r\n$file = New-TemporaryFile\r\n$payload | ConvertTo-Json | Set-Content -Path $file.FullName\r\n\r\n# Invoke model followed by cleanup\r\ntry {\r\n    python \".\\tools\\count tokens\\count tokens.py\" \"$($file.FullName)\"\r\n} finally {\r\n    Remove-Item -Path $file.FullName\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\ml\\gemini-engine\\actions\\Extract audio from video.ps1\r\n\r\n````powershell\r\n# Pick the video\r\n$video = Get-ChildItem .\\videos\\ `\r\n| Select-Object -ExpandProperty Name\r\n| fzf\r\n\r\nif (-not $video) {\r\n    Write-Host \"No video selected. Exiting...\"\r\n    return\r\n}\r\n\r\nWrite-Host \"You chose $video\"\r\n\r\n# Ensure output dir exists\r\nNew-Item -ItemType Directory -Path audio -ErrorAction SilentlyContinue | Out-Null\r\n\r\n# Calculate destination file path\r\n$destFileName = [System.IO.Path]::ChangeExtension($video, \".mp3\")\r\n$destPath = \".\\audio\\$destFileName\"\r\n\r\n# Perform audio extraction\r\nffmpeg -i \".\\videos\\$video\" -vn \"$destPath\"\r\nffmpeg -i input_video.mp4 -filter_complex \"[0:a]amerge=inputs=N[a]\" -map \"[a]\" -c:a aac -b:a 160k -ac 2 output_audio.aac\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\ml\\gemini-engine\\actions\\Create a new prompt.ps1\r\n\r\n````powershell\r\n$promptName = Read-Host \"Enter a name for the prompt (.txt gets appended)\"\r\n$promptName += \".txt\"\r\n# Open prompt file in editor\r\n& hx prompts/$promptName\r\n# Update cached data\r\n$cachedPrompts += $promptName\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\ml\\gemini-engine\\tools\\list unignored files\\src\\main.rs\r\n\r\n````rust\r\nuse ignore::WalkBuilder;\r\nuse std::path::PathBuf;\r\nuse std::env;\r\nuse std::process;\r\n\r\nfn main() {\r\n    // Get the first command line argument as a PathBuf\r\n    // defaulting to the current directory if none is provided\r\n    let args: Vec<String> = env::args().collect();\r\n    let path = args.get(1)\r\n        .map(PathBuf::from)\r\n        .unwrap_or_else(|| env::current_dir().unwrap_or_else(|err| {\r\n            eprintln!(\"Error getting current directory: {}\", err);\r\n            process::exit(1);\r\n        }));\r\n\r\n    for result in WalkBuilder::new(path.clone()).build() {\r\n        if let Ok(entry) = result {\r\n            if entry.file_type().map_or(false, |ft| ft.is_file())\r\n            {\r\n                // let relative_path = entry.path().strip_prefix(&path).unwrap_or(entry.path());\r\n                println!(\"{}\", entry.path().display());\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\ml\\gemini-engine\\README.md\r\n\r\n````markdown\r\n<div align=\"center\">\r\n\r\n# Gemini Engine\r\n\r\n<img height=400 src=\"https://cards.scryfall.io/large/front/2/e/2e03e05b-011b-4695-950b-98dd7643b8a0.jpg?1562636055\">\r\n\r\nMine\r\n[![Discord](https://img.shields.io/discord/967118679370264627.svg?colorB=7289DA&logo=data:image/png)](https://discord.gg/5mbUY3mu6m)\r\n\r\nGoogle Developer Community\r\n[![Discord](https://img.shields.io/discord/1009525727504384150.svg?colorB=7289DA&logo=data:image/png)](https://discord.gg/google-dev-community)\r\n\r\n</div>\r\n\r\nA collection of scripts I'm using to interact with the Gemini 1.5 Pro API.\r\n\r\n## Dependencies\r\n\r\nThis project expects the following commands to be available for full functionality:\r\n\r\n- `pwsh`\r\n- `fzf`\r\n- `hx`\r\n- `sqlite3`\r\n- `zoxide`\r\n- `rg`\r\n- `eza`\r\n- `yt-dlp`\r\n- `cargo`\r\n- `python`\r\n- `code`\r\n\r\n## Using Gemini\r\n\r\n[FAQ](https://docs.google.com/document/d/1WBVc5W6PZvgaHLV43UGSrtwHqUmofPT0K0oHuNd7GHA/edit#heading=h.j6pr32lsg1rf)\r\n\r\n[Docs](https://ai.google.dev/api/python/google/ai/generativelanguage/GenerativeServiceClient#generate_content)\r\n\r\n### Feedback\r\n\r\nVisit https://aistudio.google.com/app/prompts/new_chat and use the three dots in the top right to submit feedback to Google.\r\n\r\n### Examples\r\n\r\nhttps://github.com/google-gemini/gemini-api-cookbook/tree/main/quickstarts\r\n\r\nhttps://colab.research.google.com/github/google-gemini/gemini-api-cookbook/blob/main/preview/file-api/File_API.ipynb#scrollTo=IrPDYdQSKTg4\r\n\r\nhttps://colab.research.google.com/github/google-gemini/gemini-api-cookbook/blob/main/preview/file-api/File_API_Video.ipynb\r\n\r\n## Mimetypes\r\n\r\nSourced from https://www.iana.org/assignments/media-types/media-types.xhtml using\r\n\r\n```javascript\r\ncopy(Array.from(document.querySelectorAll(\"td:nth-child(2)\")).map(x => x.innerText).join(\"\\n\"))\r\n```\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\ml\\gemini-engine\\tools\\count tokens\\count tokens.py\r\n\r\n````py\r\nimport googleapiclient.discovery\r\nimport requests\r\nimport sys\r\nimport sys\r\nimport json\r\nfrom googleapiclient.discovery import build\r\nimport os\r\nfrom dataclasses import dataclass, asdict\r\nfrom dacite import from_dict\r\n\r\n\r\n@dataclass(frozen=True)\r\nclass PayloadFile:\r\n    url: str\r\n    mimetype: str\r\n\r\n\r\n@dataclass(frozen=True)\r\nclass Payload:\r\n    prompt: str\r\n    files: list[PayloadFile]\r\n\r\n\r\ndef build_service(api_key):\r\n    GENAI_DISCOVERY_URL = f\"https://generativelanguage.googleapis.com/$discovery/rest?version=v1beta&key={api_key}\"\r\n    discovery_docs = requests.get(GENAI_DISCOVERY_URL)\r\n    genai_service = googleapiclient.discovery.build_from_document(\r\n        discovery_docs.json(), developerKey=api_key\r\n    )\r\n    return genai_service.models()\r\n\r\n\r\ndef count_tokens(models_api, payload: Payload) -> int:\r\n    # Prepare request body\r\n    params = {\r\n        \"model\": \"models/gemini-1.5-pro-latest\",\r\n        \"body\": {\r\n            \"contents\": [\r\n                {\r\n                    \"parts\": [\r\n                        {\"text\": payload.prompt},\r\n                    ]\r\n                }\r\n            ]\r\n        },\r\n    }\r\n\r\n    # Include files in request\r\n    if not payload.files:\r\n        print(\"No files detected in request\")\r\n    for file in payload.files:\r\n        print(f\"Including file {file.url} ({file.mimetype}) in request\")\r\n        params[\"body\"][\"contents\"][0][\"parts\"].append(\r\n            {\"file_data\": {\"file_uri\": file.url, \"mime_type\": file.mimetype}}\r\n        )\r\n\r\n    # Send request\r\n    request = models_api.countTokens(**params)\r\n    response = request.execute()\r\n\r\n    # Return total tokens\r\n    return response[\"totalTokens\"]\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    # Load API key\r\n    api_key = os.environ.get(\"GEMINI_API_KEY\")\r\n    if not api_key:\r\n        raise Exception(\"GEMINI_API_KEY environment variable is not set.\")\r\n    models_api = build_service(api_key)\r\n\r\n    # Parse payload\r\n    file = sys.argv[1]\r\n    with open(file, \"r\", encoding=\"utf-8\") as f:\r\n        payload = json.load(f)\r\n    payload = from_dict(data_class=Payload, data=payload)\r\n    # info(payload)\r\n\r\n    # Perform count\r\n    print(\"Token count:\", count_tokens(models_api, payload))\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\ml\\gemini-engine\\actions\\Download a youtube video.ps1\r\n\r\n````powershell\r\n# Ensure the output dir exists\r\n$outdir = \".\\videos\\\"\r\nNew-Item -ItemType Directory -Path $outdir -ErrorAction SilentlyContinue | Out-Null\r\n\r\n# Get the URL from the user\r\n$url = Read-Host \"Enter a YouTube URL\"\r\n\r\n# Download the video\r\n$name = yt-dlp --encoding \"utf-8\" --print \"filename\" --windows-filenames $url\r\n$dest = Join-Path -Path $outdir -ChildPath $name\r\nyt-dlp --windows-filenames --output $dest $url\r\n\r\n# Add to the list of downloaded videos\r\n(\"{0,-50} {1}\" -f $url,$name) >> \".\\downloaded_videos.txt\"\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\ml\\gemini-engine\\actions\\Load api key from 1password vault.ps1\r\n\r\n````powershell\r\n$env:GEMINI_API_KEY = op read \"op://Private/Google AI Studio Gemini API key/credential\"\r\nWrite-Host \"API Key loaded into GEMINI_API_KEY environment variable.\"\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\ml\\gemini-engine\\actions\\Show prompt lengths.ps1\r\n\r\n````powershell\r\n$prompts = Get-ChildItem -Path \"prompts\" -Filter \"*.txt\"\r\n\r\n# Loop through each file and calculate length\r\n$summary = @()\r\nforeach ($file in $prompts) {\r\n  $content = Get-Content -Path $file.FullName -Raw\r\n  $length = $content.Length\r\n  $summary += [PSCustomObject]@{\r\n    Name   = $file.BaseName\r\n    Length = $length\r\n  }\r\n}\r\n\r\n$summary | Format-Table -AutoSize\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\ml\\gemini-engine\\actions\\Suggest directory path to clipboard.ps1\r\n\r\n````powershell\r\n$suggestions = @()\r\nif (Get-Command sqlite3) {\r\n    $suggestions += sqlite3 -json $Env:APPDATA\\Code\\User\\globalStorage\\state.vscdb \"SELECT * FROM ItemTable WHERE key = 'history.recentlyOpenedPathsList';\" .exit `\r\n        | ConvertFrom-Json `\r\n        | Select-Object -ExpandProperty value `\r\n        | ConvertFrom-Json `\r\n        | Select-Object -ExpandProperty entries `\r\n        | Where-Object { $_.folderUri?.StartsWith(\"file:///\") } `\r\n        | Select-Object -ExpandProperty folderUri `\r\n        | ForEach-Object { [System.Uri]::UnescapeDataString($_) } `\r\n        | ForEach-Object { $_ -replace '^file:///', '' } `\r\n        | ForEach-Object { $_.Substring(0,1).ToUpper() + $_.Substring(1)}\r\n} else {\r\n    Write-Warning \"sqlite3 wasn't detected\"\r\n}\r\n\r\nif (Get-Command zoxide) {\r\n    $suggestions += zoxide query -l\r\n} else {\r\n    Write-Warning \"zoxide wasn't detected\"\r\n}\r\n\r\n$psreadlinepath = \"$Env:APPDATA\\Microsoft\\Windows\\PowerShell\\PSReadLine\"\r\nif ((Test-Path $psreadlinepath) -and (Get-Command rg)) {\r\n    $suggestions += rg \"^cd [A-Za-z]:\\\\[^;]*\" $psreadlinepath --only-matching --no-line-number --no-heading --no-filename\r\n} else {\r\n    Write-Warning \"PSReadLine wasn't detected\"\r\n}\r\n$old = $env:SHELL\r\n$env:SHELL=\"pwsh\"\r\ntry {\r\n    $chosen = $suggestions `\r\n        | ForEach-Object { $_ -replace '/', '\\' } `\r\n        | Sort-Object -Unique `\r\n        | Where-Object { Test-Path $_ } `\r\n        | fzf --prompt \"Select a directory: \" --preview \"eza -1 --icons=always {}\"\r\n    $chosen | Set-Clipboard\r\n    Write-Host \"Directory copied to clipboard: $chosen\"\r\n} finally {\r\n    $env:SHELL = $old\r\n}\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\ml\\gemini-engine\\actions\\Transcribe audio.ps1\r\n\r\n````powershell\r\n$audio = Get-ChildItem .\\audio\\ `\r\n| Select-Object -ExpandProperty Name\r\n| fzf\r\n\r\nif (-not $audio) {\r\n    Write-Host \"No video selected. Exiting...\"\r\n    return\r\n}\r\n\r\nWrite-Host \"You chose $audio\"\r\n\r\nNew-Item -ItemType Directory -Path transcriptions -ErrorAction SilentlyContinue | Out-Null\r\n$destFileName = [System.IO.Path]::ChangeExtension($audio, \".txt\")\r\n\r\npython .\\tools\\transcription\\transcribe.py \".\\audio\\$audio\" > .\\transcriptions\\$destFileName\r\n\r\nWrite-Host \"Transcription saved to .\\transcriptions\\$destFileName\"\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\ml\\gemini-engine\\actions\\View a response in VSCode.ps1\r\n\r\n````powershell\r\n# Select response file\r\n$chosenResponseFile = Get-ChildItem -Path responses -Filter \"*.json\" `\r\n    | Select-Object -ExpandProperty Name `\r\n    | Sort-Object -Property { [int][regex]::Match($_, '(\\d+)\\.json').Groups[1].Value } -Descending `\r\n    | fzf --no-sort\r\n\r\n# Check if file was selected\r\nif ([string]::IsNullOrEmpty($chosenResponseFile)) {\r\n    Write-Host \"No response file selected.\"\r\n    return\r\n}\r\n\r\n# Read response data\r\n$responseData = Get-Content -Raw -Path \"responses/$chosenResponseFile\" `\r\n    | ConvertFrom-Json\r\n\r\n# Extract the \"good part\"\r\n# (Modify this logic based on the actual response structure)\r\n$extracted = $responseData.response.candidates.content.parts.text\r\n\r\n# Open the extracted content in VSCode\r\n$extracted | code -\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\ml\\gemini-engine\\ignore_patterns.txt\r\n\r\n````txt\r\n^D:\\\\repos\\\\ml\\\\gemini-engine\\\\prompts\\\\.*$\r\n^D:\\\\Repos\\\\Games\\\\Cursor-Hero\\\\other\\\\.*$\r\n^D:\\\\Repos\\\\ml\\\\gemini-engine\\\\feedback\\\\.*$\r\n^D:\\\\Repos\\\\ml\\\\gemini-engine\\\\transcriptions\\\\.*$\r\n^D:\\\\Repos\\\\ml\\\\gemini-engine\\\\downloaded_videos.txt$\r\n^D:\\\\Repos\\\\ml\\\\gemini-engine\\\\mimetypes.txt$\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\ml\\gemini-engine\\tools\\list unignored files\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"list_unignored_files\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nignore = \"0.4.22\"\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\ml\\gemini-engine\\tools\\upload file\\upload file.py\r\n\r\n````py\r\nimport json\r\nimport googleapiclient.discovery\r\nimport requests\r\nimport sys\r\nfrom googleapiclient.http import MediaFileUpload\r\nimport os\r\nfrom dataclasses import dataclass, asdict\r\nfrom dacite import from_dict\r\n\r\n@dataclass(frozen=True)\r\nclass PayloadFile:\r\n    path: str\r\n    mimetype: str\r\n    displayname: str\r\n\r\n@dataclass(frozen=True)\r\nclass Payload:\r\n    files: list[PayloadFile]\r\n\r\n@dataclass(frozen=True)\r\nclass OutputFile:\r\n    path: str\r\n    mimetype: str\r\n    displayname: str\r\n    url: str\r\n\r\ndef info(*args):\r\n    for arg in args:\r\n        sys.stderr.write(f\"{arg} \")\r\n    sys.stderr.write(\"\\n\")\r\n\r\ndef build_service(api_key):\r\n    GENAI_DISCOVERY_URL = f\"https://generativelanguage.googleapis.com/$discovery/rest?version=v1beta&key={api_key}\"\r\n    discovery_docs = requests.get(GENAI_DISCOVERY_URL)\r\n    genai_service = googleapiclient.discovery.build_from_document(\r\n        discovery_docs.json(), developerKey=api_key\r\n    )\r\n    return genai_service.media()\r\n\r\ndef upload_file(media_api, file: PayloadFile):\r\n    # Prepare file upload\r\n    media = MediaFileUpload(file.path, mimetype=file.mimetype)\r\n    body = {\"file\": {\"displayName\": file.displayname}}\r\n\r\n    # Upload file and get URL\r\n    info(\"Uploading\", file)\r\n    create_file_response = media_api.upload(media_body=media, body=body).execute()\r\n\r\n    # Print output\r\n    output = OutputFile(\r\n        path=file.path,\r\n        mimetype=file.mimetype,\r\n        displayname=file.displayname,\r\n        url=create_file_response[\"file\"][\"uri\"],\r\n    )\r\n    print(json.dumps(asdict(output)))\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    # Build API service\r\n    api_key = os.environ.get(\"GEMINI_API_KEY\")\r\n    if not api_key:\r\n        raise Exception(\"GEMINI_API_KEY environment variable is not set.\")\r\n    media_api = build_service(api_key)\r\n\r\n    # Parse payload\r\n    file = sys.argv[1]\r\n    with open(file, \"r\", encoding=\"utf-8\") as f:\r\n        payload = json.load(f)\r\n    # info(payload)\r\n    payload = from_dict(data_class=Payload, data=payload)\r\n\r\n    # Upload files\r\n    for file in payload.files:\r\n        upload_file(media_api, file)\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\ml\\gemini-engine\\actions\\Show remote file summary.ps1\r\n\r\n````powershell\r\n# Load cached data\r\nif (Test-Path -Path .\\files.json) {\r\n    $cachedFiles = Get-Content -Path \"files.json\" | ConvertFrom-Json -AsHashtable\r\n} else {\r\n    $cachedFiles = @{}\r\n}\r\n\r\n$cachedfiles.Keys `\r\n| ForEach-Object { \r\n    $entry = $cachedfiles[$_]\r\n    $name = $_\r\n    $mimetype = $entry.mimetype    \r\n    # format as %-20s %-20s %-20s\r\n    \"{0,-100} {1,20}\" -f $name, $mimetype\r\n} `\r\n| fzf\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\ml\\gemini-engine\\tools\\inference\\requirements.txt\r\n\r\n````txt\r\ndacite\r\ngoogle-api-python-client\r\ngoogle-generativeai\r\n````\r\n\r\n\r\nHere is the transcript of my video.\r\nNote that the transcription model says \"Thank you.\" when given silence.\r\n\r\n# Summary\r\n\r\n\r\n## .\\transcriptions\\2024-04-01 21-06-59 recording the process.txt\r\n\r\n````txt\r\nTranscribing file:  .\\audio\\2024-04-01 21-06-59 recording the process.mp3\r\n[0.00s -> 2.00s]  Thank you.\r\n[2.00s -> 4.00s]  Thank you.\r\n[4.00s -> 6.00s]  Thank you.\r\n[6.00s -> 8.00s]  Thank you.\r\n[8.00s -> 10.00s]  Thank you.\r\n[10.00s -> 12.00s]  Thank you.\r\n[12.00s -> 14.00s]  Thank you.\r\n[14.00s -> 16.00s]  Thank you.\r\n[16.00s -> 18.00s]  Thank you.\r\n[18.00s -> 20.00s]  Thank you.\r\n[20.00s -> 22.00s]  Thank you.\r\n[22.00s -> 24.00s]  Thank you.\r\n[24.00s -> 26.00s]  Thank you.\r\n[26.00s -> 28.00s]  Thank you.\r\n[28.00s -> 30.00s]  Thank you.\r\n[30.00s -> 32.00s]  Thank you.\r\n[32.00s -> 34.00s]  Thank you.\r\n[34.00s -> 36.00s]  Thank you.\r\n[36.00s -> 38.00s]  Thank you.\r\n[38.00s -> 40.00s]  Thank you.\r\n[40.00s -> 42.00s]  Thank you.\r\n[42.00s -> 44.00s]  Thank you.\r\n[44.00s -> 46.00s]  Thank you.\r\n[46.00s -> 48.00s]  Thank you.\r\n[48.00s -> 50.00s]  Thank you.\r\n[50.00s -> 52.00s]  Thank you.\r\n[52.00s -> 54.00s]  Thank you.\r\n[54.00s -> 56.00s]  Thank you.\r\n[56.00s -> 58.00s]  Thank you.\r\n[58.00s -> 60.00s]  Thank you.\r\n[60.00s -> 62.00s]  Thank you.\r\n[62.00s -> 64.00s]  Thank you.\r\n[64.00s -> 66.00s]  Thank you.\r\n[66.00s -> 68.00s]  Thank you.\r\n[68.00s -> 70.00s]  Thank you.\r\n[70.00s -> 72.00s]  Thank you.\r\n[72.00s -> 74.00s]  Thank you.\r\n[74.00s -> 76.00s]  Thank you.\r\n[76.00s -> 78.00s]  Thank you.\r\n[78.00s -> 80.00s]  Thank you.\r\n[80.00s -> 82.00s]  Thank you.\r\n[82.00s -> 84.00s]  Thank you.\r\n[84.00s -> 86.00s]  Thank you.\r\n[86.00s -> 88.00s]  Thank you.\r\n[88.00s -> 90.00s]  Thank you.\r\n[90.00s -> 92.00s]  Thank you.\r\n[92.00s -> 94.00s]  Thank you.\r\n[94.00s -> 96.00s]  Thank you.\r\n[96.00s -> 98.00s]  Thank you.\r\n[98.00s -> 100.00s]  Thank you.\r\n[100.00s -> 102.00s]  Thank you.\r\n[102.00s -> 104.00s]  Thank you.\r\n[104.00s -> 106.00s]  Thank you.\r\n[106.00s -> 108.00s]  Thank you.\r\n[108.00s -> 110.00s]  Thank you.\r\n[110.00s -> 112.00s]  Thank you.\r\n[112.00s -> 114.00s]  Thank you.\r\n[114.00s -> 116.00s]  Thank you.\r\n[116.00s -> 118.00s]  Thank you.\r\n[118.00s -> 120.00s]  Thank you.\r\n[120.00s -> 122.00s]  Thank you.\r\n[122.00s -> 124.00s]  Thank you.\r\n[124.00s -> 126.00s]  Thank you.\r\n[126.00s -> 128.00s]  Thank you.\r\n[128.00s -> 130.00s]  Thank you.\r\n[130.00s -> 132.00s]  Thank you.\r\n[132.00s -> 134.00s]  Thank you.\r\n[134.00s -> 136.00s]  Thank you.\r\n[136.00s -> 138.00s]  Thank you.\r\n[138.00s -> 140.00s]  Thank you.\r\n[140.00s -> 142.00s]  Thank you.\r\n[142.00s -> 144.00s]  Thank you.\r\n[144.00s -> 146.00s]  Thank you.\r\n[146.00s -> 148.00s]  Thank you.\r\n[148.00s -> 150.00s]  Thank you.\r\n[150.00s -> 152.00s]  Thank you.\r\n[152.00s -> 154.00s]  Thank you.\r\n[154.00s -> 156.00s]  Thank you.\r\n[156.00s -> 158.00s]  Thank you.\r\n[158.00s -> 160.00s]  Thank you.\r\n[160.00s -> 162.00s]  Thank you.\r\n[162.00s -> 164.00s]  Thank you.\r\n[164.00s -> 166.00s]  Thank you.\r\n[166.00s -> 168.00s]  Thank you.\r\n[168.00s -> 170.00s]  Thank you.\r\n[170.00s -> 172.00s]  Thank you.\r\n[172.00s -> 174.00s]  Thank you.\r\n[174.00s -> 176.00s]  Thank you.\r\n[176.00s -> 178.00s]  Thank you.\r\n[178.00s -> 180.00s]  Thank you.\r\n[180.00s -> 182.00s]  Thank you.\r\n[182.00s -> 184.00s]  Thank you.\r\n[184.00s -> 186.00s]  Thank you.\r\n[186.00s -> 188.00s]  Thank you.\r\n[188.00s -> 190.00s]  Thank you.\r\n[190.00s -> 192.00s]  Thank you.\r\n[192.00s -> 194.00s]  Thank you.\r\n[194.00s -> 196.00s]  Thank you.\r\n[196.00s -> 198.00s]  Thank you.\r\n[198.00s -> 200.00s]  Thank you.\r\n[200.00s -> 202.00s]  Thank you.\r\n[202.00s -> 204.00s]  Thank you.\r\n[204.00s -> 206.00s]  Thank you.\r\n[206.00s -> 208.00s]  Thank you.\r\n[208.00s -> 210.00s]  Thank you.\r\n[210.00s -> 212.00s]  Thank you.\r\n[212.00s -> 214.00s]  Thank you.\r\n[214.00s -> 216.00s]  Thank you.\r\n[216.00s -> 218.00s]  Thank you.\r\n[218.00s -> 220.00s]  Thank you.\r\n[220.00s -> 222.00s]  Thank you.\r\n[222.00s -> 224.00s]  Thank you.\r\n[224.00s -> 226.00s]  Thank you.\r\n[226.00s -> 228.00s]  Thank you.\r\n[228.00s -> 230.00s]  Thank you.\r\n[230.00s -> 232.00s]  Thank you.\r\n[232.00s -> 234.00s]  Thank you.\r\n[234.00s -> 236.00s]  Thank you.\r\n[236.00s -> 238.00s]  Thank you.\r\n[238.00s -> 240.00s]  Thank you.\r\n[240.00s -> 242.00s]  Thank you.\r\n[242.00s -> 244.00s]  Thank you.\r\n[244.00s -> 246.00s]  Thank you.\r\n[246.00s -> 248.00s]  Thank you.\r\n[248.00s -> 250.00s]  Thank you.\r\n[250.00s -> 252.00s]  Thank you.\r\n[252.00s -> 254.00s]  Thank you.\r\n[254.00s -> 256.00s]  Thank you.\r\n[256.00s -> 258.00s]  Thank you.\r\n[258.00s -> 260.00s]  Thank you.\r\n[260.00s -> 262.00s]  Thank you.\r\n[262.00s -> 264.00s]  Thank you.\r\n[264.00s -> 266.00s]  Thank you.\r\n[266.00s -> 268.00s]  Thank you.\r\n[268.00s -> 270.00s]  Thank you.\r\n[270.00s -> 272.00s]  Thank you.\r\n[272.00s -> 274.00s]  Thank you.\r\n[274.00s -> 276.00s]  Thank you.\r\n[276.00s -> 278.00s]  Thank you.\r\n[278.00s -> 280.00s]  Thank you.\r\n[280.00s -> 282.00s]  Thank you.\r\n[282.00s -> 284.00s]  Thank you.\r\n[284.00s -> 286.00s]  Thank you.\r\n[286.00s -> 288.00s]  Thank you.\r\n[288.00s -> 290.00s]  Thank you.\r\n[290.00s -> 292.00s]  Thank you.\r\n[292.00s -> 294.00s]  Thank you.\r\n[294.00s -> 296.00s]  Thank you.\r\n[296.00s -> 298.00s]  Thank you.\r\n[298.00s -> 300.00s]  Thank you.\r\n[300.00s -> 302.00s]  Thank you.\r\n[302.00s -> 304.00s]  Thank you.\r\n[304.00s -> 306.00s]  Thank you.\r\n[306.00s -> 308.00s]  Thank you.\r\n[308.00s -> 310.00s]  Thank you.\r\n[310.00s -> 312.00s]  Thank you.\r\n[312.00s -> 314.00s]  Thank you.\r\n[314.00s -> 316.00s]  Thank you.\r\n[316.00s -> 318.00s]  Thank you.\r\n[318.00s -> 320.00s]  Thank you.\r\n[320.00s -> 322.00s]  Thank you.\r\n[322.00s -> 324.00s]  Thank you.\r\n[324.00s -> 326.00s]  Thank you.\r\n[326.00s -> 328.00s]  Thank you.\r\n[328.00s -> 330.00s]  Thank you.\r\n[330.00s -> 332.00s]  Thank you.\r\n[332.00s -> 334.00s]  Thank you.\r\n[334.00s -> 336.00s]  Thank you.\r\n[336.00s -> 338.00s]  Thank you.\r\n[338.00s -> 340.00s]  Thank you.\r\n[340.00s -> 342.00s]  Thank you.\r\n[342.00s -> 344.00s]  Thank you.\r\n[344.00s -> 346.00s]  Thank you.\r\n[346.00s -> 348.00s]  Thank you.\r\n[348.00s -> 350.00s]  Thank you.\r\n[350.00s -> 352.00s]  Thank you.\r\n[352.00s -> 354.00s]  Thank you.\r\n[354.00s -> 356.00s]  Thank you.\r\n[356.00s -> 358.00s]  Thank you.\r\n[358.00s -> 360.00s]  Thank you.\r\n[360.00s -> 362.00s]  Thank you.\r\n[362.00s -> 364.00s]  Thank you.\r\n[364.00s -> 366.00s]  Thank you.\r\n[366.00s -> 368.00s]  Thank you.\r\n[368.00s -> 370.00s]  Thank you.\r\n[370.00s -> 372.00s]  Thank you.\r\n[372.00s -> 374.00s]  Thank you.\r\n[374.00s -> 376.00s]  Thank you.\r\n[376.00s -> 378.00s]  Thank you.\r\n[378.00s -> 380.00s]  Thank you.\r\n[380.00s -> 382.00s]  Thank you.\r\n[382.00s -> 384.00s]  Thank you.\r\n[384.00s -> 386.00s]  Thank you.\r\n[386.00s -> 388.00s]  Thank you.\r\n[388.00s -> 390.00s]  Thank you.\r\n[390.00s -> 392.00s]  Thank you.\r\n[392.00s -> 394.00s]  Thank you.\r\n[394.00s -> 396.00s]  Thank you.\r\n[396.00s -> 398.00s]  Thank you.\r\n[398.00s -> 400.00s]  Thank you.\r\n[400.00s -> 402.00s]  Thank you.\r\n[402.00s -> 404.00s]  Thank you.\r\n[404.00s -> 406.00s]  Thank you.\r\n[406.00s -> 408.00s]  Thank you.\r\n[408.00s -> 410.00s]  Thank you.\r\n[410.00s -> 412.00s]  Thank you.\r\n[412.00s -> 414.00s]  Thank you.\r\n[414.00s -> 416.00s]  Thank you.\r\n[416.00s -> 418.00s]  Thank you.\r\n[418.00s -> 420.00s]  Thank you.\r\n[420.00s -> 422.00s]  Thank you.\r\n[422.00s -> 424.00s]  Thank you.\r\n[424.00s -> 426.00s]  Thank you.\r\n[426.00s -> 428.00s]  Thank you.\r\n[428.00s -> 430.00s]  Thank you.\r\n[430.00s -> 432.00s]  Thank you.\r\n[432.00s -> 434.00s]  Thank you.\r\n[434.00s -> 436.00s]  Thank you.\r\n[436.00s -> 438.00s]  Thank you.\r\n[438.00s -> 440.00s]  Thank you.\r\n[440.00s -> 442.00s]  Thank you.\r\n[442.00s -> 444.00s]  Thank you.\r\n[444.00s -> 446.00s]  Thank you.\r\n[446.00s -> 448.00s]  Thank you.\r\n[448.00s -> 450.00s]  Thank you.\r\n[450.00s -> 452.00s]  Thank you.\r\n[452.00s -> 454.00s]  Thank you.\r\n[454.00s -> 456.00s]  Thank you.\r\n[456.00s -> 458.00s]  Thank you.\r\n[458.00s -> 460.00s]  Thank you.\r\n[460.00s -> 462.00s]  Thank you.\r\n[462.00s -> 464.00s]  Thank you.\r\n[464.00s -> 466.00s]  Thank you.\r\n[466.00s -> 468.00s]  Thank you.\r\n[468.00s -> 470.00s]  Thank you.\r\n[470.00s -> 472.00s]  Thank you.\r\n[472.00s -> 474.00s]  Thank you.\r\n[474.00s -> 476.00s]  Thank you.\r\n[476.00s -> 478.00s]  Thank you.\r\n[478.00s -> 480.00s]  Thank you.\r\n[480.00s -> 482.00s]  Thank you.\r\n[482.00s -> 484.00s]  Thank you.\r\n[484.00s -> 486.00s]  Thank you.\r\n[486.00s -> 488.00s]  Thank you.\r\n[488.00s -> 490.00s]  Thank you.\r\n[490.00s -> 492.00s]  Thank you.\r\n[492.00s -> 494.00s]  Thank you.\r\n[494.00s -> 496.00s]  Thank you.\r\n[496.00s -> 498.00s]  Thank you.\r\n[498.00s -> 500.00s]  Thank you.\r\n[500.00s -> 502.00s]  Thank you.\r\n[502.00s -> 504.00s]  Thank you.\r\n[504.00s -> 506.00s]  Thank you.\r\n[506.00s -> 508.00s]  Thank you.\r\n[508.00s -> 510.00s]  Thank you.\r\n[510.00s -> 512.00s]  Thank you.\r\n[512.00s -> 514.00s]  Thank you.\r\n[514.00s -> 516.00s]  Thank you.\r\n[516.00s -> 518.00s]  Thank you.\r\n[518.00s -> 520.00s]  Thank you.\r\n[520.00s -> 522.00s]  Thank you.\r\n[522.00s -> 524.00s]  Thank you.\r\n[524.00s -> 526.00s]  Thank you.\r\n[526.00s -> 528.00s]  Thank you.\r\n[528.00s -> 530.00s]  Thank you.\r\n[530.00s -> 532.00s]  Thank you.\r\n[532.00s -> 534.00s]  Thank you.\r\n[534.00s -> 536.00s]  Thank you.\r\n[536.00s -> 538.00s]  Thank you.\r\n[538.00s -> 540.00s]  Thank you.\r\n[540.00s -> 542.00s]  Thank you.\r\n[542.00s -> 544.00s]  Thank you.\r\n[544.00s -> 546.00s]  Thank you.\r\n[546.00s -> 548.00s]  Thank you.\r\n[548.00s -> 550.00s]  Thank you.\r\n[550.00s -> 552.00s]  Thank you.\r\n[552.00s -> 554.00s]  Thank you.\r\n[554.00s -> 556.00s]  Thank you.\r\n[556.00s -> 558.00s]  Thank you.\r\n[558.00s -> 560.00s]  Thank you.\r\n[560.00s -> 562.00s]  Thank you.\r\n[562.00s -> 564.00s]  Thank you.\r\n[564.00s -> 566.00s]  Thank you.\r\n[566.00s -> 568.00s]  Thank you.\r\n[568.00s -> 570.00s]  Thank you.\r\n[570.00s -> 572.00s]  Thank you.\r\n[572.00s -> 574.00s]  Thank you.\r\n[574.00s -> 576.00s]  Thank you.\r\n[576.00s -> 578.00s]  Thank you.\r\n[578.00s -> 580.00s]  Thank you.\r\n[580.00s -> 582.00s]  Thank you.\r\n[582.00s -> 584.00s]  Thank you.\r\n[612.00s -> 614.00s]  Thank you.\r\n[614.00s -> 616.00s]  Thank you.\r\n[616.00s -> 618.00s]  Thank you.\r\n[618.00s -> 620.00s]  Thank you.\r\n[620.00s -> 622.00s]  Thank you.\r\n[622.00s -> 624.00s]  Thank you.\r\n[624.00s -> 626.00s]  Thank you.\r\n[626.00s -> 628.00s]  Thank you.\r\n[628.00s -> 630.00s]  Thank you.\r\n[630.00s -> 632.00s]  Thank you.\r\n[632.00s -> 634.00s]  Thank you.\r\n[634.00s -> 636.00s]  Thank you.\r\n[636.00s -> 638.00s]  Thank you.\r\n[638.00s -> 640.00s]  Thank you.\r\n[640.00s -> 642.00s]  Thank you.\r\n[642.00s -> 644.00s]  Thank you.\r\n[644.00s -> 646.00s]  Thank you.\r\n[646.00s -> 648.00s]  Thank you.\r\n[648.00s -> 650.00s]  Thank you.\r\n[650.00s -> 652.00s]  Thank you.\r\n[652.00s -> 654.00s]  Thank you.\r\n[654.00s -> 656.00s]  Thank you.\r\n[656.00s -> 658.00s]  Thank you.\r\n[658.00s -> 660.00s]  Thank you.\r\n[660.00s -> 662.00s]  Thank you.\r\n[662.00s -> 664.00s]  Thank you.\r\n[664.00s -> 666.00s]  Thank you.\r\n[666.00s -> 668.00s]  Thank you.\r\n[668.00s -> 670.00s]  Thank you.\r\n[670.00s -> 672.00s]  Thank you.\r\n[672.00s -> 674.00s]  Thank you.\r\n[674.00s -> 676.00s]  Thank you.\r\n[676.00s -> 678.00s]  Thank you.\r\n[678.00s -> 680.00s]  Thank you.\r\n[680.00s -> 682.00s]  Thank you.\r\n[682.00s -> 684.00s]  Thank you.\r\n[684.00s -> 686.00s]  Thank you.\r\n[686.00s -> 688.00s]  Thank you.\r\n[688.00s -> 690.00s]  Thank you.\r\n[690.00s -> 692.00s]  Thank you.\r\n[692.00s -> 694.00s]  Thank you.\r\n[694.00s -> 696.00s]  Thank you.\r\n[696.00s -> 698.00s]  Thank you.\r\n[698.00s -> 700.00s]  Thank you.\r\n[700.00s -> 702.00s]  Thank you.\r\n[702.00s -> 704.00s]  Thank you.\r\n[704.00s -> 706.00s]  Thank you.\r\n[706.00s -> 708.00s]  Thank you.\r\n[708.00s -> 710.00s]  Thank you.\r\n[710.00s -> 712.00s]  Thank you.\r\n[712.00s -> 714.00s]  Thank you.\r\n[714.00s -> 716.00s]  Thank you.\r\n[716.00s -> 718.00s]  Thank you.\r\n[718.00s -> 720.00s]  Thank you.\r\n[720.00s -> 722.00s]  Thank you.\r\n[722.00s -> 724.00s]  Thank you.\r\n[724.00s -> 726.00s]  Thank you.\r\n[726.00s -> 728.00s]  Thank you.\r\n[728.00s -> 730.00s]  Thank you.\r\n[730.00s -> 732.00s]  Thank you.\r\n[732.00s -> 734.00s]  Thank you.\r\n[734.00s -> 736.00s]  Thank you.\r\n[736.00s -> 738.00s]  Thank you.\r\n[738.00s -> 740.00s]  Thank you.\r\n[740.00s -> 742.00s]  Thank you.\r\n[742.00s -> 744.00s]  Thank you.\r\n[744.00s -> 746.00s]  Thank you.\r\n[746.00s -> 748.00s]  Thank you.\r\n[748.00s -> 750.00s]  Thank you.\r\n[750.00s -> 752.00s]  Thank you.\r\n[752.00s -> 754.00s]  Thank you.\r\n[754.00s -> 756.00s]  Thank you.\r\n[756.00s -> 758.00s]  Thank you.\r\n[758.00s -> 760.00s]  Thank you.\r\n[760.00s -> 762.00s]  Thank you.\r\n[762.00s -> 764.00s]  Thank you.\r\n[764.00s -> 766.00s]  Thank you.\r\n[766.00s -> 768.00s]  Thank you.\r\n[768.00s -> 770.00s]  Thank you.\r\n[770.00s -> 772.00s]  Thank you.\r\n[772.00s -> 774.00s]  Thank you.\r\n[774.00s -> 776.00s]  Thank you.\r\n[776.00s -> 778.00s]  Thank you.\r\n[778.00s -> 780.00s]  Thank you.\r\n[780.00s -> 782.00s]  Thank you.\r\n[782.00s -> 784.00s]  Thank you.\r\n[784.00s -> 786.00s]  Thank you.\r\n[786.00s -> 788.00s]  Thank you.\r\n[788.00s -> 790.00s]  Thank you.\r\n[790.00s -> 792.00s]  Thank you.\r\n[792.00s -> 794.00s]  Thank you.\r\n[822.00s -> 824.00s]  Thank you.\r\n[824.00s -> 826.00s]  Thank you.\r\n[826.00s -> 828.00s]  Thank you.\r\n[828.00s -> 830.00s]  Thank you.\r\n[830.00s -> 832.00s]  Thank you.\r\n[832.00s -> 834.00s]  Thank you.\r\n[834.00s -> 836.00s]  Thank you.\r\n[836.00s -> 838.00s]  Thank you.\r\n[838.00s -> 840.00s]  Thank you.\r\n[840.00s -> 842.00s]  Thank you.\r\n[842.00s -> 844.00s]  Thank you.\r\n[844.00s -> 846.00s]  Thank you.\r\n[846.00s -> 848.00s]  Thank you.\r\n[848.00s -> 850.00s]  Thank you.\r\n[850.00s -> 852.00s]  Thank you.\r\n[852.00s -> 854.00s]  Thank you.\r\n[854.00s -> 856.00s]  Thank you.\r\n[856.00s -> 858.00s]  Thank you.\r\n[858.00s -> 860.00s]  Thank you.\r\n[860.00s -> 862.00s]  Thank you.\r\n[862.00s -> 864.00s]  Thank you.\r\n[864.00s -> 866.00s]  Thank you.\r\n[866.00s -> 868.00s]  Thank you.\r\n[868.00s -> 870.00s]  Thank you.\r\n[870.00s -> 872.00s]  Thank you.\r\n[872.00s -> 874.00s]  Thank you.\r\n[874.00s -> 876.00s]  Thank you.\r\n[876.00s -> 878.00s]  Thank you.\r\n[878.00s -> 880.00s]  Thank you.\r\n[880.00s -> 882.00s]  Thank you.\r\n[882.00s -> 884.00s]  Thank you.\r\n[884.00s -> 886.00s]  Thank you.\r\n[886.00s -> 888.00s]  Thank you.\r\n[888.00s -> 890.00s]  Thank you.\r\n[890.00s -> 892.00s]  Thank you.\r\n[892.00s -> 894.00s]  Thank you.\r\n[894.00s -> 896.00s]  Thank you.\r\n[896.00s -> 898.00s]  Thank you.\r\n[898.00s -> 900.00s]  Thank you.\r\n[900.00s -> 902.00s]  Thank you.\r\n[902.00s -> 904.00s]  Thank you.\r\n[904.00s -> 906.00s]  Thank you.\r\n[906.00s -> 908.00s]  Thank you.\r\n[908.00s -> 910.00s]  Thank you.\r\n[910.00s -> 912.00s]  Thank you.\r\n[912.00s -> 914.00s]  Thank you.\r\n[914.00s -> 916.00s]  Thank you.\r\n[916.00s -> 918.00s]  Thank you.\r\n[918.00s -> 920.00s]  Thank you.\r\n[920.00s -> 922.00s]  Thank you.\r\n[922.00s -> 924.00s]  Thank you.\r\n[924.00s -> 926.00s]  Thank you.\r\n[926.00s -> 928.00s]  Thank you.\r\n[928.00s -> 930.00s]  Thank you.\r\n[930.00s -> 932.00s]  Thank you.\r\n[932.00s -> 934.00s]  Thank you.\r\n[934.00s -> 936.00s]  Thank you.\r\n[936.00s -> 938.00s]  Thank you.\r\n[938.00s -> 940.00s]  Thank you.\r\n[940.00s -> 942.00s]  Thank you.\r\n[942.00s -> 944.00s]  Thank you.\r\n[944.00s -> 946.00s]  Thank you.\r\n[946.00s -> 948.00s]  Thank you.\r\n[948.00s -> 950.00s]  Thank you.\r\n[950.00s -> 952.00s]  Thank you.\r\n[952.00s -> 954.00s]  Thank you.\r\n[954.00s -> 956.00s]  Thank you.\r\n[956.00s -> 958.00s]  Thank you.\r\n[958.00s -> 960.00s]  Thank you.\r\n[960.00s -> 962.00s]  Thank you.\r\n[962.00s -> 964.00s]  Thank you.\r\n[964.00s -> 966.00s]  Thank you.\r\n[966.00s -> 968.00s]  Thank you.\r\n[968.00s -> 970.00s]  Thank you.\r\n[970.00s -> 972.00s]  Thank you.\r\n[972.00s -> 974.00s]  Thank you.\r\n[974.00s -> 976.00s]  Thank you.\r\n[976.00s -> 978.00s]  Thank you.\r\n[978.00s -> 980.00s]  Thank you.\r\n[980.00s -> 982.00s]  Thank you.\r\n[982.00s -> 984.00s]  Thank you.\r\n[984.00s -> 986.00s]  Thank you.\r\n[986.00s -> 988.00s]  Thank you.\r\n[988.00s -> 990.00s]  Thank you.\r\n[990.00s -> 992.00s]  Thank you.\r\n[992.00s -> 994.00s]  Thank you.\r\n[994.00s -> 996.00s]  Thank you.\r\n[996.00s -> 998.00s]  Thank you.\r\n[998.00s -> 1000.00s]  Thank you.\r\n[1000.00s -> 1002.00s]  Thank you.\r\n[1002.00s -> 1004.00s]  Thank you.\r\n[1004.00s -> 1006.00s]  Thank you.\r\n[1006.00s -> 1008.00s]  Thank you.\r\n[1008.00s -> 1010.00s]  Thank you.\r\n[1010.00s -> 1012.00s]  Thank you.\r\n[1012.00s -> 1014.00s]  Thank you.\r\n[1014.00s -> 1016.00s]  Thank you.\r\n[1016.00s -> 1018.00s]  Thank you.\r\n[1018.00s -> 1020.00s]  Thank you.\r\n[1020.00s -> 1022.00s]  Thank you.\r\n[1022.00s -> 1024.00s]  Thank you.\r\n[1024.00s -> 1026.00s]  Thank you.\r\n[1026.00s -> 1028.00s]  Thank you.\r\n[1028.00s -> 1030.00s]  Thank you.\r\n[1030.00s -> 1032.00s]  Thank you.\r\n[1032.00s -> 1034.00s]  Thank you.\r\n[1034.00s -> 1036.00s]  Thank you.\r\n[1036.00s -> 1038.00s]  Thank you.\r\n[1038.00s -> 1040.00s]  Thank you.\r\n[1040.00s -> 1042.00s]  Thank you.\r\n[1042.00s -> 1044.00s]  Thank you.\r\n[1044.00s -> 1046.00s]  Thank you.\r\n[1046.00s -> 1048.00s]  Thank you.\r\n[1048.00s -> 1050.00s]  Thank you.\r\n[1050.00s -> 1052.00s]  Thank you.\r\n[1052.00s -> 1054.00s]  Thank you.\r\n[1054.00s -> 1056.00s]  Thank you.\r\n[1056.00s -> 1058.00s]  Thank you.\r\n[1058.00s -> 1060.00s]  Thank you.\r\n[1060.00s -> 1062.00s]  Thank you.\r\n[1062.00s -> 1064.00s]  Thank you.\r\n[1064.00s -> 1066.00s]  Thank you.\r\n[1066.00s -> 1068.00s]  Thank you.\r\n[1068.00s -> 1070.00s]  Thank you.\r\n[1070.00s -> 1072.00s]  Thank you.\r\n[1072.00s -> 1074.00s]  Thank you.\r\n[1074.00s -> 1076.00s]  Thank you.\r\n[1076.00s -> 1078.00s]  Thank you.\r\n[1078.00s -> 1080.00s]  Thank you.\r\n[1080.00s -> 1082.00s]  Thank you.\r\n[1082.00s -> 1084.00s]  Thank you.\r\n[1084.00s -> 1086.00s]  Thank you.\r\n[1086.00s -> 1088.00s]  Thank you.\r\n[1088.00s -> 1090.00s]  Thank you.\r\n[1090.00s -> 1092.00s]  Thank you.\r\n[1092.00s -> 1094.00s]  Thank you.\r\n[1094.00s -> 1096.00s]  Thank you.\r\n[1096.00s -> 1098.00s]  Thank you.\r\n[1098.00s -> 1100.00s]  Thank you.\r\n[1100.00s -> 1102.00s]  Thank you.\r\n[1102.00s -> 1104.00s]  Thank you.\r\n[1104.00s -> 1106.00s]  Thank you.\r\n[1106.00s -> 1108.00s]  Thank you.\r\n[1108.00s -> 1110.00s]  Thank you.\r\n[1110.00s -> 1112.00s]  Thank you.\r\n[1112.00s -> 1114.00s]  Thank you.\r\n[1114.00s -> 1116.00s]  Thank you.\r\n[1116.00s -> 1118.00s]  Thank you.\r\n[1118.00s -> 1120.00s]  Thank you.\r\n[1120.00s -> 1122.00s]  Thank you.\r\n[1122.00s -> 1124.00s]  Thank you.\r\n[1124.00s -> 1126.00s]  Thank you.\r\n[1126.00s -> 1128.00s]  Thank you.\r\n[1128.00s -> 1130.00s]  Thank you.\r\n[1130.00s -> 1132.00s]  Thank you.\r\n[1132.00s -> 1134.00s]  Thank you.\r\n[1134.00s -> 1136.00s]  Thank you.\r\n[1136.00s -> 1138.00s]  Thank you.\r\n[1138.00s -> 1140.00s]  Thank you.\r\n[1140.00s -> 1142.00s]  Thank you.\r\n[1142.00s -> 1144.00s]  Thank you.\r\n[1144.00s -> 1146.00s]  Thank you.\r\n[1146.00s -> 1148.00s]  Thank you.\r\n[1148.00s -> 1150.00s]  Thank you.\r\n[1150.00s -> 1152.00s]  Thank you.\r\n[1152.00s -> 1154.00s]  Thank you.\r\n[1154.00s -> 1156.00s]  Thank you.\r\n[1156.00s -> 1158.00s]  Thank you.\r\n[1158.00s -> 1160.00s]  Thank you.\r\n[1160.00s -> 1162.00s]  Thank you.\r\n[1162.00s -> 1164.00s]  Thank you.\r\n[1164.00s -> 1166.00s]  Thank you.\r\n[1166.00s -> 1168.00s]  Thank you.\r\n[1168.00s -> 1170.00s]  Thank you.\r\n[1170.00s -> 1172.00s]  Thank you.\r\n[1172.00s -> 1174.00s]  Thank you.\r\n[1174.00s -> 1176.00s]  Thank you.\r\n[1176.00s -> 1178.00s]  Thank you.\r\n[1178.00s -> 1180.00s]  Thank you.\r\n[1180.00s -> 1182.00s]  Thank you.\r\n[1182.00s -> 1184.00s]  Thank you.\r\n[1184.00s -> 1186.00s]  Thank you.\r\n[1186.00s -> 1188.00s]  Thank you.\r\n[1188.00s -> 1190.00s]  Thank you.\r\n[1190.00s -> 1192.00s]  Thank you.\r\n[1192.00s -> 1194.00s]  Thank you.\r\n[1194.00s -> 1196.00s]  Thank you.\r\n[1196.00s -> 1198.00s]  Thank you.\r\n[1198.00s -> 1200.00s]  Thank you.\r\n[1200.00s -> 1202.00s]  Thank you.\r\n[1202.00s -> 1204.00s]  Thank you.\r\n[1204.00s -> 1206.00s]  Thank you.\r\n[1206.00s -> 1208.00s]  Thank you.\r\n[1208.00s -> 1210.00s]  Thank you.\r\n[1210.00s -> 1212.00s]  Thank you.\r\n[1212.00s -> 1214.00s]  Thank you.\r\n[1214.00s -> 1216.00s]  Thank you.\r\n[1216.00s -> 1218.00s]  Thank you.\r\n[1218.00s -> 1220.00s]  Thank you.\r\n[1220.00s -> 1222.00s]  Thank you.\r\n[1222.00s -> 1224.00s]  Thank you.\r\n[1224.00s -> 1226.00s]  Thank you.\r\n[1226.00s -> 1228.00s]  Thank you.\r\n[1228.00s -> 1230.00s]  Thank you.\r\n[1230.00s -> 1232.00s]  Thank you.\r\n[1232.00s -> 1234.00s]  Thank you.\r\n[1234.00s -> 1236.00s]  Thank you.\r\n[1236.00s -> 1238.00s]  Thank you.\r\n[1238.00s -> 1240.00s]  Thank you.\r\n[1240.00s -> 1242.00s]  Thank you.\r\n[1242.00s -> 1244.00s]  Thank you.\r\n[1244.00s -> 1246.00s]  Thank you.\r\n[1246.00s -> 1248.00s]  Thank you.\r\n[1248.00s -> 1250.00s]  Thank you.\r\n[1250.00s -> 1252.00s]  Thank you.\r\n[1252.00s -> 1254.00s]  Thank you.\r\n[1254.00s -> 1256.00s]  Thank you.\r\n[1256.00s -> 1258.00s]  Thank you.\r\n[1258.00s -> 1260.00s]  Thank you.\r\n[1260.00s -> 1262.00s]  Thank you.\r\n[1262.00s -> 1264.00s]  Thank you.\r\n[1264.00s -> 1266.00s]  Thank you.\r\n[1266.00s -> 1268.00s]  Thank you.\r\n[1268.00s -> 1270.00s]  Thank you.\r\n[1270.00s -> 1272.00s]  Thank you.\r\n[1272.00s -> 1274.00s]  Thank you.\r\n[1274.00s -> 1276.00s]  Thank you.\r\n[1276.00s -> 1278.00s]  Thank you.\r\n[1278.00s -> 1280.00s]  Thank you.\r\n[1280.00s -> 1282.00s]  Thank you.\r\n[1282.00s -> 1284.00s]  Thank you.\r\n[1284.00s -> 1286.00s]  Thank you.\r\n[1286.00s -> 1288.00s]  Thank you.\r\n[1288.00s -> 1290.00s]  Thank you.\r\n[1290.00s -> 1292.00s]  Thank you.\r\n[1292.00s -> 1294.00s]  Thank you.\r\n[1294.00s -> 1296.00s]  Thank you.\r\n[1296.00s -> 1298.00s]  Thank you.\r\n[1298.00s -> 1300.00s]  Thank you.\r\n[1300.00s -> 1302.00s]  Thank you.\r\n[1302.00s -> 1304.00s]  Thank you.\r\n[1304.00s -> 1306.00s]  Thank you.\r\n[1306.00s -> 1308.00s]  Thank you.\r\n[1308.00s -> 1310.00s]  Thank you.\r\n[1310.00s -> 1312.00s]  Thank you.\r\n[1312.00s -> 1314.00s]  Thank you.\r\n[1314.00s -> 1316.00s]  Thank you.\r\n[1316.00s -> 1318.00s]  Thank you.\r\n[1318.00s -> 1320.00s]  Thank you.\r\n[1320.00s -> 1322.00s]  Thank you.\r\n[1322.00s -> 1324.00s]  Thank you.\r\n[1324.00s -> 1326.00s]  Thank you.\r\n[1326.00s -> 1328.00s]  Thank you.\r\n[1328.00s -> 1330.00s]  Thank you.\r\n[1330.00s -> 1332.00s]  Thank you.\r\n[1332.00s -> 1334.00s]  Thank you.\r\n[1334.00s -> 1336.00s]  Thank you.\r\n[1336.00s -> 1338.00s]  Thank you.\r\n[1338.00s -> 1340.00s]  Thank you.\r\n[1340.00s -> 1342.00s]  Thank you.\r\n[1342.00s -> 1344.00s]  Thank you.\r\n[1344.00s -> 1346.00s]  Thank you.\r\n[1346.00s -> 1348.00s]  Thank you.\r\n[1348.00s -> 1350.00s]  Thank you.\r\n[1350.00s -> 1352.00s]  Thank you.\r\n[1352.00s -> 1354.00s]  Thank you.\r\n[1354.00s -> 1356.00s]  Thank you.\r\n[1356.00s -> 1358.00s]  Thank you.\r\n[1358.00s -> 1360.00s]  Thank you.\r\n[1360.00s -> 1362.00s]  Thank you.\r\n[1362.00s -> 1364.00s]  Thank you.\r\n[1364.00s -> 1366.00s]  Thank you.\r\n[1366.00s -> 1368.00s]  Thank you.\r\n[1368.00s -> 1370.00s]  Thank you.\r\n[1370.00s -> 1372.00s]  Thank you.\r\n[1372.00s -> 1374.00s]  Thank you.\r\n[1374.00s -> 1376.00s]  Thank you.\r\n[1376.00s -> 1378.00s]  Thank you.\r\n[1378.00s -> 1380.00s]  Thank you.\r\n[1380.00s -> 1382.00s]  Thank you.\r\n[1382.00s -> 1384.00s]  Thank you.\r\n[1384.00s -> 1386.00s]  Thank you.\r\n[1386.00s -> 1388.00s]  Thank you.\r\n[1388.00s -> 1390.00s]  Thank you.\r\n[1390.00s -> 1392.00s]  Thank you.\r\n[1392.00s -> 1394.00s]  Thank you.\r\n[1394.00s -> 1396.00s]  Thank you.\r\n[1396.00s -> 1398.00s]  Thank you.\r\n[1398.00s -> 1400.00s]  Thank you.\r\n[1400.00s -> 1402.00s]  Thank you.\r\n[1402.00s -> 1404.00s]  Thank you.\r\n[1404.00s -> 1406.00s]  Thank you.\r\n[1406.00s -> 1408.00s]  Thank you.\r\n[1408.00s -> 1410.00s]  Thank you.\r\n[1410.00s -> 1412.00s]  Thank you.\r\n[1412.00s -> 1414.00s]  Thank you.\r\n[1414.00s -> 1416.00s]  Thank you.\r\n[1416.00s -> 1418.00s]  Thank you.\r\n[1418.00s -> 1420.00s]  Thank you.\r\n[1420.00s -> 1422.00s]  Thank you.\r\n[1422.00s -> 1424.00s]  Thank you.\r\n[1424.00s -> 1426.00s]  Thank you.\r\n[1426.00s -> 1428.00s]  Thank you.\r\n[1428.00s -> 1430.00s]  Thank you.\r\n[1430.00s -> 1432.00s]  Thank you.\r\n[1432.00s -> 1434.00s]  Thank you.\r\n[1434.00s -> 1436.00s]  Thank you.\r\n[1436.00s -> 1438.00s]  Thank you.\r\n[1438.00s -> 1440.00s]  Thank you.\r\n[1440.00s -> 1442.00s]  Thank you.\r\n[1442.00s -> 1444.00s]  Thank you.\r\n[1444.00s -> 1446.00s]  Thank you.\r\n[1446.00s -> 1448.00s]  Thank you.\r\n[1448.00s -> 1450.00s]  Thank you.\r\n[1450.00s -> 1452.00s]  Thank you.\r\n[1452.00s -> 1454.00s]  Thank you.\r\n[1454.00s -> 1456.00s]  Thank you.\r\n[1456.00s -> 1458.00s]  Thank you.\r\n[1458.00s -> 1460.00s]  Thank you.\r\n[1460.00s -> 1462.00s]  Thank you.\r\n[1462.00s -> 1464.00s]  Thank you.\r\n[1464.00s -> 1466.00s]  Thank you.\r\n[1466.00s -> 1468.00s]  Thank you.\r\n[1468.00s -> 1470.00s]  Thank you.\r\n[1470.00s -> 1472.00s]  Thank you.\r\n[1472.00s -> 1474.00s]  Thank you.\r\n[1474.00s -> 1476.00s]  Thank you.\r\n[1476.00s -> 1478.00s]  Thank you.\r\n[1478.00s -> 1480.00s]  Thank you.\r\n[1480.00s -> 1482.00s]  Thank you.\r\n[1482.00s -> 1484.00s]  Thank you.\r\n[1484.00s -> 1486.00s]  Thank you.\r\n[1486.00s -> 1488.00s]  Thank you.\r\n[1488.00s -> 1490.00s]  Thank you.\r\n[1490.00s -> 1492.00s]  Thank you.\r\n[1492.00s -> 1494.00s]  Thank you.\r\n[1494.00s -> 1496.00s]  Thank you.\r\n[1496.00s -> 1498.00s]  Thank you.\r\n[1498.00s -> 1500.00s]  Thank you.\r\n[1500.00s -> 1502.00s]  Thank you.\r\n[1502.00s -> 1504.00s]  Thank you.\r\n[1504.00s -> 1506.00s]  Thank you.\r\n[1506.00s -> 1508.00s]  Thank you.\r\n[1508.00s -> 1510.00s]  Thank you.\r\n[1510.00s -> 1512.00s]  Thank you.\r\n[1512.00s -> 1514.00s]  Thank you.\r\n[1514.00s -> 1516.00s]  Thank you.\r\n[1516.00s -> 1518.00s]  Thank you.\r\n[1518.00s -> 1520.00s]  Thank you.\r\n[1520.00s -> 1522.00s]  Thank you.\r\n[1522.00s -> 1524.00s]  Thank you.\r\n[1524.00s -> 1526.00s]  Thank you.\r\n[1526.00s -> 1528.00s]  Thank you.\r\n[1528.00s -> 1530.00s]  Thank you.\r\n[1530.00s -> 1532.00s]  Thank you.\r\n[1532.00s -> 1534.00s]  Thank you.\r\n[1534.00s -> 1536.00s]  Thank you.\r\n[1536.00s -> 1538.00s]  Thank you.\r\n[1538.00s -> 1540.00s]  Thank you.\r\n[1540.00s -> 1542.00s]  Thank you.\r\n[1542.00s -> 1544.00s]  Thank you.\r\n[1544.00s -> 1546.00s]  Thank you.\r\n[1546.00s -> 1548.00s]  Thank you.\r\n[1548.00s -> 1550.00s]  Thank you.\r\n[1550.00s -> 1552.00s]  Thank you.\r\n[1552.00s -> 1554.00s]  Thank you.\r\n[1554.00s -> 1556.00s]  Thank you.\r\n[1556.00s -> 1558.00s]  Thank you.\r\n[1558.00s -> 1560.00s]  Thank you.\r\n[1560.00s -> 1562.00s]  Thank you.\r\n[1562.00s -> 1564.00s]  Thank you.\r\n[1564.00s -> 1566.00s]  Thank you.\r\n[1566.00s -> 1568.00s]  Thank you.\r\n[1568.00s -> 1570.00s]  Thank you.\r\n[1570.00s -> 1572.00s]  Thank you.\r\n[1572.00s -> 1574.00s]  Thank you.\r\n[1574.00s -> 1576.00s]  Thank you.\r\n[1576.00s -> 1578.00s]  Thank you.\r\n[1578.00s -> 1580.00s]  Thank you.\r\n[1580.00s -> 1582.00s]  Thank you.\r\n[1582.00s -> 1584.00s]  Thank you.\r\n[1584.00s -> 1586.00s]  Thank you.\r\n[1586.00s -> 1588.00s]  Thank you.\r\n[1588.00s -> 1590.00s]  Thank you.\r\n[1590.00s -> 1592.00s]  Thank you.\r\n[1592.00s -> 1594.00s]  Thank you.\r\n[1594.00s -> 1596.00s]  Thank you.\r\n[1596.00s -> 1598.00s]  Thank you.\r\n[1598.00s -> 1600.00s]  Thank you.\r\n[1600.00s -> 1602.00s]  Thank you.\r\n[1602.00s -> 1604.00s]  Thank you.\r\n[1604.00s -> 1606.00s]  Thank you.\r\n[1606.00s -> 1608.00s]  Thank you.\r\n[1608.00s -> 1610.00s]  Thank you.\r\n[1610.00s -> 1612.00s]  Thank you.\r\n[1612.00s -> 1614.00s]  Thank you.\r\n[1614.00s -> 1616.00s]  Thank you.\r\n[1616.00s -> 1618.00s]  Thank you.\r\n[1618.00s -> 1620.00s]  Thank you.\r\n[1620.00s -> 1622.00s]  Thank you.\r\n[1622.00s -> 1624.00s]  Thank you.\r\n[1624.00s -> 1626.00s]  Thank you.\r\n[1626.00s -> 1628.00s]  Thank you.\r\n[1628.00s -> 1630.00s]  Thank you.\r\n[1630.00s -> 1632.00s]  Thank you.\r\n[1632.00s -> 1634.00s]  Thank you.\r\n[1634.00s -> 1636.00s]  Thank you.\r\n[1636.00s -> 1638.00s]  Thank you.\r\n[1638.00s -> 1640.00s]  Thank you.\r\n[1640.00s -> 1642.00s]  Thank you.\r\n[1642.00s -> 1644.00s]  Thank you.\r\n[1644.00s -> 1646.00s]  Thank you.\r\n[1646.00s -> 1648.00s]  Thank you.\r\n[1648.00s -> 1650.00s]  Thank you.\r\n[1650.00s -> 1652.00s]  Thank you.\r\n[1652.00s -> 1654.00s]  Thank you.\r\n[1654.00s -> 1656.00s]  Thank you.\r\n[1656.00s -> 1658.00s]  Thank you.\r\n[1658.00s -> 1660.00s]  Thank you.\r\n[1660.00s -> 1662.00s]  Thank you.\r\n[1662.00s -> 1664.00s]  Thank you.\r\n[1664.00s -> 1666.00s]  Thank you.\r\n[1666.00s -> 1668.00s]  Thank you.\r\n[1668.00s -> 1670.00s]  Thank you.\r\n[1670.00s -> 1672.00s]  Thank you.\r\n[1672.00s -> 1674.00s]  Thank you.\r\n[1674.00s -> 1676.00s]  Thank you.\r\n[1676.00s -> 1678.00s]  Thank you.\r\n[1678.00s -> 1680.00s]  Thank you.\r\n[1680.00s -> 1682.00s]  Thank you.\r\n[1682.00s -> 1684.00s]  Thank you.\r\n[1684.00s -> 1686.00s]  Thank you.\r\n[1686.00s -> 1688.00s]  Thank you.\r\n[1688.00s -> 1690.00s]  Thank you.\r\n[1690.00s -> 1692.00s]  Thank you.\r\n[1692.00s -> 1694.00s]  Thank you.\r\n[1694.00s -> 1696.00s]  Thank you.\r\n[1696.00s -> 1698.00s]  Thank you.\r\n[1698.00s -> 1700.00s]  Thank you.\r\n[1700.00s -> 1702.00s]  Thank you.\r\n[1702.00s -> 1704.00s]  Thank you.\r\n[1704.00s -> 1706.00s]  Thank you.\r\n[1706.00s -> 1708.00s]  Thank you.\r\n[1708.00s -> 1710.00s]  Thank you.\r\n[1710.00s -> 1712.00s]  Thank you.\r\n[1712.00s -> 1714.00s]  Thank you.\r\n[1714.00s -> 1716.00s]  Thank you.\r\n[1716.00s -> 1718.00s]  Thank you.\r\n[1718.00s -> 1720.00s]  Thank you.\r\n[1720.00s -> 1722.00s]  Thank you.\r\n[1722.00s -> 1724.00s]  Thank you.\r\n[1724.00s -> 1726.00s]  Thank you.\r\n[1726.00s -> 1728.00s]  Thank you.\r\n[1728.00s -> 1730.00s]  Thank you.\r\n[1730.00s -> 1732.00s]  Thank you.\r\n[1732.00s -> 1734.00s]  Thank you.\r\n[1734.00s -> 1736.00s]  Thank you.\r\n[1736.00s -> 1738.00s]  Thank you.\r\n[1738.00s -> 1740.00s]  Thank you.\r\n[1740.00s -> 1742.00s]  Thank you.\r\n[1742.00s -> 1744.00s]  Thank you.\r\n[1744.00s -> 1746.00s]  Thank you.\r\n[1746.00s -> 1748.00s]  Thank you.\r\n[1748.00s -> 1750.00s]  Thank you.\r\n[1750.00s -> 1752.00s]  Thank you.\r\n[1752.00s -> 1754.00s]  Thank you.\r\n[1754.00s -> 1756.00s]  Thank you.\r\n[1756.00s -> 1758.00s]  Thank you.\r\n[1758.00s -> 1760.00s]  Thank you.\r\n[1760.00s -> 1762.00s]  Thank you.\r\n[1762.00s -> 1764.00s]  Thank you.\r\n[1764.00s -> 1766.00s]  Thank you.\r\n[1766.00s -> 1768.00s]  Thank you.\r\n[1768.00s -> 1770.00s]  Thank you.\r\n[1770.00s -> 1772.00s]  Thank you.\r\n[1772.00s -> 1774.00s]  Thank you.\r\n[1774.00s -> 1776.00s]  Thank you.\r\n[1776.00s -> 1778.00s]  Thank you.\r\n[1778.00s -> 1780.00s]  Thank you.\r\n[1780.00s -> 1782.00s]  Thank you.\r\n[1782.00s -> 1784.00s]  Thank you.\r\n[1784.00s -> 1786.00s]  Thank you.\r\n[1786.00s -> 1788.00s]  Thank you.\r\n[1788.00s -> 1790.00s]  Thank you.\r\n[1790.00s -> 1792.00s]  Thank you.\r\n[1792.00s -> 1794.00s]  Thank you.\r\n[1794.00s -> 1796.00s]  Thank you.\r\n[1796.00s -> 1798.00s]  Thank you.\r\n[1798.00s -> 1800.00s]  Thank you.\r\n[1800.00s -> 1802.00s]  Thank you.\r\n[1802.00s -> 1804.00s]  Thank you.\r\n[1804.00s -> 1806.00s]  Thank you.\r\n[1806.00s -> 1808.00s]  Thank you.\r\n[1808.00s -> 1810.00s]  Thank you.\r\n[1810.00s -> 1812.00s]  Thank you.\r\n[1812.00s -> 1814.00s]  Thank you.\r\n[1814.00s -> 1816.00s]  Thank you.\r\n[1816.00s -> 1818.00s]  Thank you.\r\n[1818.00s -> 1820.00s]  Thank you.\r\n[1820.00s -> 1822.00s]  Thank you.\r\n[1822.00s -> 1824.00s]  Thank you.\r\n[1824.00s -> 1826.00s]  Thank you.\r\n[1826.00s -> 1828.00s]  Thank you.\r\n[1828.00s -> 1830.00s]  Thank you.\r\n[1830.00s -> 1832.00s]  Thank you.\r\n[1832.00s -> 1834.00s]  Thank you.\r\n[1834.00s -> 1836.00s]  Thank you.\r\n[1836.00s -> 1838.00s]  Thank you.\r\n[1838.00s -> 1840.00s]  Thank you.\r\n[1840.00s -> 1842.00s]  Thank you.\r\n[1842.00s -> 1844.00s]  Thank you.\r\n[1844.00s -> 1846.00s]  Thank you.\r\n[1846.00s -> 1848.00s]  Thank you.\r\n[1848.00s -> 1850.00s]  Thank you.\r\n[1850.00s -> 1852.00s]  Thank you.\r\n[1852.00s -> 1854.00s]  Thank you.\r\n[1854.00s -> 1856.00s]  Thank you.\r\n[1856.00s -> 1858.00s]  Thank you.\r\n[1858.00s -> 1860.00s]  Thank you.\r\n[1860.00s -> 1862.00s]  Thank you.\r\n[1862.00s -> 1864.00s]  Thank you.\r\n[1864.00s -> 1866.00s]  Thank you.\r\n[1866.00s -> 1868.00s]  Thank you.\r\n[1868.00s -> 1870.00s]  Thank you.\r\n[1870.00s -> 1872.00s]  Thank you.\r\n[1872.00s -> 1874.00s]  Thank you.\r\n[1874.00s -> 1876.00s]  Thank you.\r\n[1876.00s -> 1878.00s]  Thank you.\r\n[1878.00s -> 1880.00s]  Thank you.\r\n[1880.00s -> 1882.00s]  Thank you.\r\n[1882.00s -> 1884.00s]  Thank you.\r\n[1884.00s -> 1886.00s]  Thank you.\r\n[1886.00s -> 1888.00s]  Thank you.\r\n[1888.00s -> 1890.00s]  Thank you.\r\n[1890.00s -> 1892.00s]  Thank you.\r\n[1892.00s -> 1894.00s]  Thank you.\r\n[1894.00s -> 1896.00s]  Thank you.\r\n[1896.00s -> 1898.00s]  Thank you.\r\n[1898.00s -> 1900.00s]  Thank you.\r\n[1900.00s -> 1902.00s]  Thank you.\r\n[1902.00s -> 1904.00s]  Thank you.\r\n[1904.00s -> 1906.00s]  Thank you.\r\n[1906.00s -> 1908.00s]  Thank you.\r\n[1908.00s -> 1910.00s]  Thank you.\r\n[1910.00s -> 1912.00s]  Thank you.\r\n[1912.00s -> 1914.00s]  Thank you.\r\n[1914.00s -> 1916.00s]  Thank you.\r\n[1916.00s -> 1918.00s]  Thank you.\r\n[1918.00s -> 1920.00s]  Thank you.\r\n[1920.00s -> 1922.00s]  Thank you.\r\n[1922.00s -> 1924.00s]  Thank you.\r\n[1924.00s -> 1926.00s]  Thank you.\r\n[1926.00s -> 1928.00s]  Thank you.\r\n[1928.00s -> 1930.00s]  Thank you.\r\n[1930.00s -> 1932.00s]  Thank you.\r\n[1932.00s -> 1934.00s]  Thank you.\r\n[1934.00s -> 1936.00s]  Thank you.\r\n[1936.00s -> 1938.00s]  Thank you.\r\n[1938.00s -> 1940.00s]  Thank you.\r\n[1940.00s -> 1942.00s]  Thank you.\r\n[1942.00s -> 1944.00s]  Thank you.\r\n[1944.00s -> 1946.00s]  Thank you.\r\n[1946.00s -> 1948.00s]  Thank you.\r\n[1948.00s -> 1950.00s]  Thank you.\r\n[1950.00s -> 1952.00s]  Thank you.\r\n[1952.00s -> 1954.00s]  Thank you.\r\n[1954.00s -> 1956.00s]  Thank you.\r\n[1956.00s -> 1958.00s]  Thank you.\r\n[1958.00s -> 1960.00s]  Thank you.\r\n[1960.00s -> 1962.00s]  Thank you.\r\n[1962.00s -> 1964.00s]  Thank you.\r\n[1964.00s -> 1966.00s]  Thank you.\r\n[1966.00s -> 1968.00s]  Thank you.\r\n[1968.00s -> 1970.00s]  Thank you.\r\n[1970.00s -> 1972.00s]  Thank you.\r\n[1972.00s -> 1974.00s]  Thank you.\r\n[1974.00s -> 1976.00s]  Thank you.\r\n[1976.00s -> 1978.00s]  Thank you.\r\n[1978.00s -> 1980.00s]  Thank you.\r\n[1980.00s -> 1982.00s]  Thank you.\r\n[1982.00s -> 1984.00s]  Thank you.\r\n[1984.00s -> 1986.00s]  Thank you.\r\n[1986.00s -> 1988.00s]  Thank you.\r\n[1988.00s -> 1990.00s]  Thank you.\r\n[1990.00s -> 1992.00s]  Thank you.\r\n[1992.00s -> 1994.00s]  Thank you.\r\n[1994.00s -> 1996.00s]  Thank you.\r\n[1996.00s -> 1998.00s]  Thank you.\r\n[1998.00s -> 2000.00s]  Thank you.\r\n[2000.00s -> 2002.00s]  Thank you.\r\n[2002.00s -> 2004.00s]  Thank you.\r\n[2004.00s -> 2006.00s]  Thank you.\r\n[2006.00s -> 2008.00s]  Thank you.\r\n[2008.00s -> 2010.00s]  Thank you.\r\n[2010.00s -> 2012.00s]  Thank you.\r\n[2012.00s -> 2014.00s]  Thank you.\r\n[2014.00s -> 2016.00s]  Thank you.\r\n[2016.00s -> 2018.00s]  Thank you.\r\n[2018.00s -> 2020.00s]  Thank you.\r\n[2020.00s -> 2022.00s]  Thank you.\r\n[2022.00s -> 2024.00s]  Thank you.\r\n[2024.00s -> 2026.00s]  Thank you.\r\n[2026.00s -> 2028.00s]  Thank you.\r\n[2028.00s -> 2030.00s]  Thank you.\r\n[2030.00s -> 2032.00s]  Thank you.\r\n[2032.00s -> 2034.00s]  Thank you.\r\n[2034.00s -> 2036.00s]  Thank you.\r\n[2036.00s -> 2038.00s]  Thank you.\r\n[2038.00s -> 2040.00s]  Thank you.\r\n[2040.00s -> 2042.00s]  Thank you.\r\n[2042.00s -> 2044.00s]  Thank you.\r\n[2044.00s -> 2046.00s]  Thank you.\r\n[2046.00s -> 2048.00s]  Thank you.\r\n[2048.00s -> 2050.00s]  Thank you.\r\n[2050.00s -> 2052.00s]  Thank you.\r\n[2052.00s -> 2054.00s]  Thank you.\r\n[2054.00s -> 2056.00s]  Thank you.\r\n[2056.00s -> 2058.00s]  Thank you.\r\n[2058.00s -> 2060.00s]  Thank you.\r\n[2060.00s -> 2062.00s]  Thank you.\r\n[2062.00s -> 2064.00s]  Thank you.\r\n[2064.00s -> 2066.00s]  Thank you.\r\n[2066.00s -> 2068.00s]  Thank you.\r\n[2068.00s -> 2070.00s]  Thank you.\r\n[2070.00s -> 2072.00s]  Thank you.\r\n[2072.00s -> 2074.00s]  Thank you.\r\n[2074.00s -> 2076.00s]  Thank you.\r\n[2076.00s -> 2078.00s]  Thank you.\r\n[2078.00s -> 2080.00s]  Thank you.\r\n[2080.00s -> 2082.00s]  Thank you.\r\n[2082.00s -> 2084.00s]  Thank you.\r\n[2084.00s -> 2086.00s]  Thank you.\r\n[2086.00s -> 2088.00s]  Thank you.\r\n[2088.00s -> 2090.00s]  Thank you.\r\n[2090.00s -> 2092.00s]  Thank you.\r\n[2092.00s -> 2094.00s]  Thank you.\r\n[2094.00s -> 2096.00s]  Thank you.\r\n[2096.00s -> 2098.00s]  Thank you.\r\n[2098.00s -> 2100.00s]  Thank you.\r\n[2100.00s -> 2102.00s]  Thank you.\r\n[2102.00s -> 2104.00s]  Thank you.\r\n[2104.00s -> 2106.00s]  Thank you.\r\n[2106.00s -> 2108.00s]  Thank you.\r\n[2108.00s -> 2110.00s]  Thank you.\r\n[2110.00s -> 2112.00s]  Thank you.\r\n[2112.00s -> 2114.00s]  Thank you.\r\n[2114.00s -> 2116.00s]  Thank you.\r\n[2116.00s -> 2118.00s]  Thank you.\r\n[2118.00s -> 2120.00s]  Thank you.\r\n[2120.00s -> 2122.00s]  Thank you.\r\n[2122.00s -> 2124.00s]  Thank you.\r\n[2124.00s -> 2126.00s]  Thank you.\r\n[2126.00s -> 2128.00s]  Thank you.\r\n[2128.00s -> 2130.00s]  Thank you.\r\n[2130.00s -> 2132.00s]  Thank you.\r\n[2132.00s -> 2134.00s]  Thank you.\r\n[2134.00s -> 2136.00s]  Thank you.\r\n[2136.00s -> 2138.00s]  Thank you.\r\n[2138.00s -> 2140.00s]  Thank you.\r\n[2140.00s -> 2142.00s]  Thank you.\r\n[2142.00s -> 2144.00s]  Thank you.\r\n[2144.00s -> 2146.00s]  Thank you.\r\n[2146.00s -> 2148.00s]  Thank you.\r\n[2148.00s -> 2150.00s]  Thank you.\r\n[2150.00s -> 2152.00s]  Thank you.\r\n[2152.00s -> 2154.00s]  Thank you.\r\n[2154.00s -> 2156.00s]  Thank you.\r\n[2156.00s -> 2158.00s]  Thank you.\r\n[2158.00s -> 2160.00s]  Thank you.\r\n[2160.00s -> 2162.00s]  Thank you.\r\n[2162.00s -> 2164.00s]  Thank you.\r\n[2164.00s -> 2166.00s]  Thank you.\r\n[2166.00s -> 2168.00s]  Thank you.\r\n[2168.00s -> 2170.00s]  Thank you.\r\n[2170.00s -> 2172.00s]  Thank you.\r\n[2172.00s -> 2174.00s]  Thank you.\r\n[2174.00s -> 2176.00s]  Thank you.\r\n[2176.00s -> 2178.00s]  Thank you.\r\n[2178.00s -> 2180.00s]  Thank you.\r\n[2180.00s -> 2182.00s]  Thank you.\r\n[2182.00s -> 2184.00s]  Thank you.\r\n[2184.00s -> 2186.00s]  Thank you.\r\n[2186.00s -> 2188.00s]  Thank you.\r\n[2188.00s -> 2190.00s]  Thank you.\r\n[2190.00s -> 2192.00s]  Thank you.\r\n[2192.00s -> 2194.00s]  Thank you.\r\n[2194.00s -> 2196.00s]  Thank you.\r\n[2196.00s -> 2198.00s]  Thank you.\r\n[2198.00s -> 2200.00s]  Thank you.\r\n[2200.00s -> 2202.00s]  Thank you.\r\n[2202.00s -> 2204.00s]  Thank you.\r\n[2204.00s -> 2206.00s]  Thank you.\r\n[2206.00s -> 2208.00s]  Thank you.\r\n[2208.00s -> 2210.00s]  Thank you.\r\n[2210.00s -> 2212.00s]  Thank you.\r\n[2212.00s -> 2214.00s]  Thank you.\r\n[2214.00s -> 2216.00s]  Thank you.\r\n[2216.00s -> 2218.00s]  Thank you.\r\n[2218.00s -> 2220.00s]  Thank you.\r\n[2220.00s -> 2222.00s]  Thank you.\r\n[2222.00s -> 2224.00s]  Thank you.\r\n[2224.00s -> 2226.00s]  Thank you.\r\n[2226.00s -> 2228.00s]  Thank you.\r\n[2228.00s -> 2230.00s]  Thank you.\r\n[2230.00s -> 2232.00s]  Thank you.\r\n[2232.00s -> 2234.00s]  Thank you.\r\n[2234.00s -> 2236.00s]  Thank you.\r\n[2236.00s -> 2238.00s]  Thank you.\r\n[2238.00s -> 2240.00s]  Thank you.\r\n[2240.00s -> 2242.00s]  Thank you.\r\n[2242.00s -> 2244.00s]  Thank you.\r\n[2244.00s -> 2246.00s]  Thank you.\r\n[2246.00s -> 2248.00s]  Thank you.\r\n[2248.00s -> 2250.00s]  Thank you.\r\n[2250.00s -> 2252.00s]  Thank you.\r\n[2252.00s -> 2254.00s]  Thank you.\r\n[2254.00s -> 2256.00s]  Thank you.\r\n[2256.00s -> 2258.00s]  Thank you.\r\n[2258.00s -> 2260.00s]  Thank you.\r\n[2260.00s -> 2262.00s]  Thank you.\r\n[2262.00s -> 2264.00s]  Thank you.\r\n[2264.00s -> 2266.00s]  Thank you.\r\n[2266.00s -> 2268.00s]  Thank you.\r\n[2268.00s -> 2270.00s]  Thank you.\r\n[2270.00s -> 2272.00s]  Thank you.\r\n[2272.00s -> 2274.00s]  Thank you.\r\n[2274.00s -> 2276.00s]  Thank you.\r\n[2276.00s -> 2278.00s]  Thank you.\r\n[2278.00s -> 2280.00s]  Thank you.\r\n[2280.00s -> 2282.00s]  Thank you.\r\n[2282.00s -> 2284.00s]  Thank you.\r\n[2284.00s -> 2286.00s]  Thank you.\r\n[2286.00s -> 2288.00s]  Thank you.\r\n[2288.00s -> 2290.00s]  Thank you.\r\n[2290.00s -> 2292.00s]  Thank you.\r\n[2292.00s -> 2294.00s]  Thank you.\r\n[2294.00s -> 2296.00s]  Thank you.\r\n[2296.00s -> 2298.00s]  Thank you.\r\n[2298.00s -> 2300.00s]  Thank you.\r\n[2300.00s -> 2302.00s]  Thank you.\r\n[2302.00s -> 2304.00s]  Thank you.\r\n[2304.00s -> 2306.00s]  Thank you.\r\n[2306.00s -> 2308.00s]  Thank you.\r\n[2308.00s -> 2310.00s]  Thank you.\r\n[2310.00s -> 2312.00s]  Thank you.\r\n[2312.00s -> 2314.00s]  Thank you.\r\n[2314.00s -> 2316.00s]  Thank you.\r\n[2316.00s -> 2318.00s]  Thank you.\r\n[2318.00s -> 2320.00s]  Thank you.\r\n[2320.00s -> 2322.00s]  Thank you.\r\n[2322.00s -> 2324.00s]  Thank you.\r\n[2324.00s -> 2326.00s]  Thank you.\r\n[2326.00s -> 2328.00s]  Thank you.\r\n[2328.00s -> 2330.00s]  Thank you.\r\n[2330.00s -> 2332.00s]  Thank you.\r\n[2332.00s -> 2334.00s]  Thank you.\r\n[2334.00s -> 2336.00s]  Thank you.\r\n[2336.00s -> 2338.00s]  Thank you.\r\n[2338.00s -> 2340.00s]  Thank you.\r\n[2340.00s -> 2342.00s]  Thank you.\r\n[2342.00s -> 2344.00s]  Thank you.\r\n[2344.00s -> 2346.00s]  Thank you.\r\n[2346.00s -> 2348.00s]  Thank you.\r\n[2348.00s -> 2350.00s]  Thank you.\r\n[2350.00s -> 2352.00s]  Thank you.\r\n[2352.00s -> 2354.00s]  Thank you.\r\n[2354.00s -> 2356.00s]  Thank you.\r\n[2356.00s -> 2358.00s]  Thank you.\r\n[2358.00s -> 2360.00s]  Thank you.\r\n[2360.00s -> 2362.00s]  Thank you.\r\n[2362.00s -> 2364.00s]  Thank you.\r\n[2364.00s -> 2366.00s]  Thank you.\r\n[2366.00s -> 2368.00s]  Thank you.\r\n[2368.00s -> 2370.00s]  Thank you.\r\n[2370.00s -> 2372.00s]  Thank you.\r\n[2372.00s -> 2374.00s]  Thank you.\r\n[2374.00s -> 2376.00s]  Thank you.\r\n[2376.00s -> 2378.00s]  Thank you.\r\n[2378.00s -> 2380.00s]  Thank you.\r\n[2380.00s -> 2382.00s]  Thank you.\r\n[2382.00s -> 2384.00s]  Thank you.\r\n[2384.00s -> 2386.00s]  Thank you.\r\n[2386.00s -> 2388.00s]  Thank you.\r\n[2388.00s -> 2390.00s]  Thank you.\r\n[2390.00s -> 2392.00s]  Thank you.\r\n[2392.00s -> 2394.00s]  Thank you.\r\n[2394.00s -> 2396.00s]  Thank you.\r\n[2396.00s -> 2398.00s]  Thank you.\r\n[2398.00s -> 2400.00s]  Thank you.\r\n[2400.00s -> 2402.00s]  Thank you.\r\n[2402.00s -> 2404.00s]  Thank you.\r\n[2404.00s -> 2406.00s]  Thank you.\r\n[2406.00s -> 2408.00s]  Thank you.\r\n[2408.00s -> 2410.00s]  Thank you.\r\n[2410.00s -> 2412.00s]  Thank you.\r\n[2412.00s -> 2414.00s]  Thank you.\r\n[2414.00s -> 2416.00s]  Thank you.\r\n[2416.00s -> 2418.00s]  Thank you.\r\n[2418.00s -> 2420.00s]  Thank you.\r\n[2420.00s -> 2422.00s]  Thank you.\r\n[2422.00s -> 2424.00s]  Thank you.\r\n[2424.00s -> 2426.00s]  Thank you.\r\n[2426.00s -> 2428.00s]  Thank you.\r\n[2456.00s -> 2482.00s]  So, this is the project.\r\n[2486.00s -> 2491.00s]  this, which gives me a representation of my monitors.\r\n[2491.00s -> 2495.00s]  I have buttons that start other processes.\r\n[2495.00s -> 2503.00s]  And I have an environment for an agent to make observations and decide on courses of action.\r\n[2503.00s -> 2511.00s]  So we will be creating a representation of a calculator, which means I should open from it.\r\n[2511.00s -> 2515.00s]  And on my keyboard, I just hit...\r\n[2515.00s -> 2523.24s]  function f11 to try and spawn a calculator and I was hitting the wrong button or\r\n[2523.24s -> 2532.94s]  OBS was taking the input because F11 is a full-screen key and my game is also\r\n[2532.94s -> 2543.36s]  full screen right now and it has a key bind to toggle an always listening mode\r\n[2545.00s -> 2556.00s]  toggle always on as a non-displaying keyboard key which is unfortunate\r\n[2556.00s -> 2562.76s]  if we look at the logs does it mention that no texture for input scroll\r\n[2562.76s -> 2569.80s]  I bound that to scroll wheel what did I mean this tool the\r\n[2575.00s -> 2600.00s]  So by hitting control, I can bring up a file by name, and inside the talk tool, we see default wheel, talk wheel.\r\n[2600.00s -> 2604.00s]  Push to talk toggle always on.\r\n[2604.00s -> 2618.24s]  that's the scroll lock key not a mouse scroll which is what this mentioned keyboard scroll\r\n[2618.24s -> 2633.36s]  not mouse scroll and so when we say no texture for input\r\n[2634.00s -> 2646.00s]  that shows up in things I've previously sent to the LLM, but now not in this VS code window,\r\n[2646.00s -> 2657.00s]  despite having both my thing and the Gemini thing open.\r\n[2657.00s -> 2661.00s]  So...\r\n[2664.00s -> 2673.76s]  The objective was to hit this so that I didn't have to fold it to type in the document,\r\n[2673.76s -> 2676.24s]  but right now OBS is recording this.\r\n[2676.24s -> 2681.00s]  So it's not necessary for me to make sure that I'm typing into that document because we're going to derive that information.\r\n[2681.00s -> 2693.94s]  And to do that, I'm saying that we want a list of inputs that we could save a collection of directories that we will\r\n[2694.00s -> 2695.32s]  commonly be interacting with.\r\n[2699.24s -> 2699.72s]  Or\r\n[2699.72s -> 2702.74s]  we just do it every time.\r\n[2703.20s -> 2703.42s]  So,\r\n[2704.24s -> 2706.46s]  you've seen the game, I'll close the game.\r\n[2706.60s -> 2707.64s]  I'll try and simplify this,\r\n[2707.90s -> 2709.94s]  because I don't need this open,\r\n[2710.14s -> 2710.82s]  and I don't need\r\n[2710.82s -> 2712.80s]  this open.\r\n[2717.12s -> 2718.08s]  Let's...\r\n[2718.08s -> 2719.04s]  I'll need that calculator.\r\n[2719.34s -> 2721.50s]  Now my game is crashed\r\n[2721.50s -> 2722.92s]  because I closed the Visc code window.\r\n[2724.00s -> 2728.30s]  Don't need you open, but I want.\r\n[2733.88s -> 2735.38s]  What the hell is that?\r\n[2748.38s -> 2749.84s]  I have no idea what that means.\r\n[2752.40s -> 2753.78s]  Let's very strange.\r\n[2754.00s -> 2756.00s]  stuff we don't need open.\r\n[2768.00s -> 2772.00s]  And let's begin creating a list of files to feed into it.\r\n[2775.00s -> 2779.00s]  You are my Google Keep Notes, which I will close.\r\n[2780.00s -> 2783.00s]  This window is my notes folder, which I will close.\r\n[2783.00s -> 2784.56s]  I will close\r\n[2784.56s -> 2788.20s]  this window is the code for the game\r\n[2788.20s -> 2790.80s]  and the code for\r\n[2790.80s -> 2793.90s]  my interacting tool\r\n[2793.90s -> 2796.10s]  so I want\r\n[2796.10s -> 2799.90s]  a\r\n[2799.90s -> 2802.80s]  folder\r\n[2802.80s -> 2807.30s]  but inside the root of this\r\n[2807.30s -> 2817.70s]  It's called them location sets.\r\n[2817.70s -> 2819.70s]  Hmm.\r\n[2847.70s -> 2872.70s]  So this is the initial one, and this will contain a list of Git directories.\r\n[2877.70s -> 2882.70s]  other files to be included that describe this.\r\n[2886.70s -> 2889.70s]  Gamal, not the greatest.\r\n[2893.70s -> 2897.70s]  Let's just explore for now.\r\n[2897.70s -> 2905.20s]  And I'm going to turn there.\r\n[2927.70s -> 2936.70s]  Not problems, but actions.\r\n[2936.70s -> 2945.70s]  Summarize a directory, no, suggest a directory to the clipboard.\r\n[2945.70s -> 2956.70s]  So currently we...\r\n[2956.70s -> 2977.70s]  Suggest the directory of the clipboard, create or edit a prompt, and then update the prompt with the clipboard.\r\n[2977.70s -> 2992.70s]  Form in prints select the images and the files.\r\n[2992.70s -> 2996.70s]  Let's select the images and.\r\n[3007.70s -> 3009.70s]  Thank you.\r\n[3009.70s -> 3011.70s]  Thank you.\r\n[3039.70s -> 3041.70s]  Thank you.\r\n[3041.70s -> 3043.70s]  Thank you.\r\n[3071.70s -> 3073.70s]  Thank you.\r\n[3101.70s -> 3103.70s]  Thank you.\r\n[3103.70s -> 3105.70s]  Thank you.\r\n[3105.70s -> 3107.70s]  Thank you.\r\n[3107.70s -> 3109.70s]  Thank you.\r\n[3109.70s -> 3111.70s]  Thank you.\r\n[3111.70s -> 3113.70s]  Thank you.\r\n[3113.70s -> 3115.70s]  Thank you.\r\n[3115.70s -> 3117.70s]  Thank you.\r\n[3117.70s -> 3119.70s]  Thank you.\r\n[3119.70s -> 3121.70s]  Thank you.\r\n[3121.70s -> 3123.70s]  Thank you.\r\n[3123.70s -> 3125.70s]  Thank you.\r\n[3125.70s -> 3127.70s]  Thank you.\r\n[3127.70s -> 3129.70s]  Thank you.\r\n[3129.70s -> 3131.70s]  Thank you.\r\n[3131.70s -> 3133.70s]  Thank you.\r\n[3133.70s -> 3135.70s]  Thank you.\r\n[3135.70s -> 3137.70s]  Thank you.\r\n[3137.70s -> 3139.70s]  Thank you.\r\n[3139.70s -> 3141.70s]  Thank you.\r\n[3141.70s -> 3143.70s]  Thank you.\r\n[3143.70s -> 3145.70s]  Thank you.\r\n[3145.70s -> 3147.70s]  Thank you.\r\n[3147.70s -> 3149.70s]  Thank you.\r\n[3149.70s -> 3151.70s]  Thank you.\r\n[3151.70s -> 3153.70s]  Thank you.\r\n[3153.70s -> 3155.70s]  Thank you.\r\n[3155.70s -> 3157.70s]  Thank you.\r\n[3157.70s -> 3159.70s]  Thank you.\r\n[3159.70s -> 3161.70s]  Thank you.\r\n[3161.70s -> 3163.70s]  Thank you.\r\n[3163.70s -> 3165.70s]  Thank you.\r\n[3165.70s -> 3167.70s]  Thank you.\r\n[3167.70s -> 3169.70s]  Thank you.\r\n[3169.70s -> 3171.70s]  Thank you.\r\n[3171.70s -> 3173.70s]  Thank you.\r\n[3173.70s -> 3175.70s]  Thank you.\r\n[3175.70s -> 3177.70s]  Thank you.\r\n[3177.70s -> 3179.70s]  Thank you.\r\n[3179.70s -> 3181.70s]  Thank you.\r\n[3181.70s -> 3183.70s]  Thank you.\r\n[3183.70s -> 3185.70s]  Thank you.\r\n[3185.70s -> 3187.70s]  Thank you.\r\n[3187.70s -> 3189.70s]  Thank you.\r\n[3189.70s -> 3191.70s]  Thank you.\r\n[3191.70s -> 3193.70s]  Thank you.\r\n[3193.70s -> 3195.70s]  Thank you.\r\n[3195.70s -> 3197.70s]  Thank you.\r\n[3197.70s -> 3198.70s]  Thank you.\r\n[3198.70s -> 3200.70s]  Thank you.\r\n[3200.70s -> 3202.70s]  Thank you.\r\n[3230.70s -> 3240.46s]  Listen.\r\n[3240.46s -> 3244.38s]  I have to listen or it doesn't work.\r\n[3244.38s -> 3248.70s]  So in here, the calculator is being observed by\r\n[3248.70s -> 3274.06s]  let's see here we can run the app in inspect mode and that will continuously do a capture and save it in here\r\n[3278.70s -> 3280.70s]  That is not what we want.\r\n[3280.70s -> 3284.70s]  Because it's failing to parse the thread message.\r\n[3284.70s -> 3291.70s]  So in the UI Watcher plugin, as indicated in the mirror message,\r\n[3291.70s -> 3297.70s]  we need to find out to why.\r\n[3297.70s -> 3300.70s]  It's a resolving footer of VS code.\r\n[3300.70s -> 3303.70s]  So that happens in\r\n[3303.70s -> 3307.70s]  where.\r\n[3307.70s -> 3309.92s]  we handle the message\r\n[3309.92s -> 3311.68s]  oh sorry not the\r\n[3311.68s -> 3312.72s]  UI watcher\r\n[3312.72s -> 3312.74s]  the UI watcher\r\n[3312.74s -> 3318.60s]  the UI\r\n[3318.60s -> 3319.64s]  yeah\r\n[3319.64s -> 3321.36s]  it's in here\r\n[3321.36s -> 3323.10s]  let me take a snapshot\r\n[3323.10s -> 3327.74s]  that is where this is occurring\r\n[3327.74s -> 3330.50s]  which means\r\n[3330.50s -> 3333.50s]  that information wasn't captured in the air message\r\n[3333.50s -> 3334.36s]  which is not good\r\n[3334.36s -> 3337.96s]  despite\r\n[3337.96s -> 3344.94s]  this should be in anyhow error\r\n[3344.94s -> 3347.72s]  not a standard error boxed\r\n[3347.72s -> 3350.86s]  and I think that is causing it to lose accuracy\r\n[3350.86s -> 3355.12s]  especially because\r\n[3355.12s -> 3356.90s]  oh you see\r\n[3356.90s -> 3360.20s]  it's because I've created a new watcher\r\n[3360.20s -> 3363.18s]  or a background worker system\r\n[3363.18s -> 3364.78s]  that this is not using it.\r\n[3366.86s -> 3367.42s]  I think.\r\n[3371.34s -> 3373.26s]  Yeah, so this is spawning a thread,\r\n[3374.06s -> 3377.82s]  which means I need this to be converted into the new syntax,\r\n[3377.82s -> 3380.30s]  and that is a good problem.\r\n[3381.58s -> 3383.10s]  So to describe the problem,\r\n[3383.10s -> 3389.50s]  I want this UI watcher plugin to be converted\r\n[3389.50s -> 3391.18s]  to the new worker model\r\n[3391.18s -> 3393.98s]  and where is the worker model being used?\r\n[3393.98s -> 3401.58s]  We can find that by going to the definition of it.\r\n[3403.58s -> 3405.02s]  Control and worker plugin.\r\n[3408.62s -> 3413.98s]  And this comes from a thing, which exports types,\r\n[3413.98s -> 3415.58s]  so we can find the worker types plugin.\r\n[3417.18s -> 3421.10s]  I don't know this one itself is generic and used by the other.\r\n[3421.18s -> 3424.34s]  so Alt F7 will show us where it's used.\r\n[3426.14s -> 3428.80s]  Which is not showing us everything\r\n[3428.80s -> 3430.48s]  because it's only built in the spot,\r\n[3430.60s -> 3434.60s]  but the name itself is referenced by the UI Snapshot example,\r\n[3435.18s -> 3436.84s]  which is outside the game,\r\n[3437.50s -> 3438.88s]  and we had just transitioned the game\r\n[3438.88s -> 3440.70s]  to be something that runs modally.\r\n[3443.34s -> 3446.32s]  And so the accurate description of the problem is\r\n[3446.32s -> 3449.08s]  take the UiS snapshot example as reference\r\n[3449.08s -> 3450.86s]  and convert the Ui Watcher plugin\r\n[3450.86s -> 3460.68s]  to perform its duties using the new abstraction that we've created in the worker stuff,\r\n[3460.98s -> 3462.82s]  including the worker plugin and the work config.\r\n[3467.82s -> 3472.00s]  So the next step is this is going to produce an output video.\r\n\r\n````\r\n\r\n\r\n\r\nI look forward to hearing your thoughts.",
        "files": []
    },
    "response": {
        "candidates": [
            {
                "content": {
                    "parts": [
                        {
                            "text": "## Summary of your notes and transcript:\n\n**C:\\Users\\TeamD\\OneDrive\\Documents\\Ideas\\2024-04-01.md:**\n\nThis note discusses various topics related to software development and user experience, including:\n\n* **Vulcan ecosystem:** The note argues that learning new ecosystems can be daunting and suggests that mapping existing knowledge onto available tools is more efficient.\n* **Quality of life in Rust:** The note praises Rust's error handling and compiler guarantees, contributing to developer quality of life.\n* **Linguistic expression in games and decision making:** The note explores the use of linguistic expressions in games like Helldivers 2 and Magicka 2 and proposes a decision-making engine with ECS and LLM integration.\n* **Screenshot sequence and data redundancy:** The note reflects on a sequence of screenshots and discusses the importance of data redundancy and intelligent storage management.\n* **Risk and data loss prevention:** The note connects the concepts of risk and data loss prevention, highlighting the importance of encryption for sensitive data.\n* **Planning and delegation:** The note discusses the process of planning development tasks and delegating work to an AI agent.\n* **Mapping game world to OS and UI automation:** The note describes the ongoing effort to map game world calculations to OS calculations and the use of UI automation tools.\n* **Sharing information with LLMs:** The note addresses the challenge of selecting and preparing information to be shared with external LLMs with larger context windows.\n* **Improving workflow with PowerShell scripts:** The note outlines the desire to improve the workflow for interacting with LLMs using PowerShell scripts.\n* **Delegation and efficiency:** The note considers the trade-off between manual effort and knowledge transfer when delegating tasks to an AI agent.\n\n**D:\\Repos\\Games\\Cursor-Hero:**\n\nThis section contains code snippets from various Rust files related to the Cursor Hero game project. These snippets showcase different functionalities within the game, such as:\n\n* **Observation buffering:** Storing observations in buffers for entities that can observe them.\n* **Screen capture and update:** Capturing and updating the game world representation of the user's screens.\n* **Agent movement:** Implementing movement logic for the virtual agent within the game environment.\n* **Tool functionality:** Defining and handling actions for various tools within the game, such as clicking, scrolling, and interacting with cubes.\n* **Pointer behavior:** Managing the pointer's movement and interaction with both the game world and the host OS.\n\n**D:\\Repos\\ml\\gemini-engine:**\n\nThis section includes PowerShell scripts used to interact with the Gemini 1.5 Pro API. These scripts provide functionalities like:\n\n* **Uploading images and video frames:** Uploading image and video frame data to be used in prompts for the Gemini model.\n* **Summarizing directories:** Creating summaries of directories and copying them to the clipboard.\n* **Interactive mode:** Entering an interactive loop to send prompts and files to the Gemini model and receive responses.\n* **Managing API keys:** Setting and loading API keys for accessing the Gemini API.\n* **Prompt management:** Creating and editing prompts for the Gemini model.\n* **Extracting audio from video:** Extracting audio data from video files.\n* **Viewing responses in VSCode:** Opening Gemini model responses in VSCode for further analysis.\n\n**Use cases:**\n\nThis section outlines various use cases for the tools and functionalities being developed, such as:\n\n* **Flipping comments in Rust code:** Implementing a context action to easily swap commented and uncommented lines in Rust code.\n* **Creating music mixes:** Extracting specific tracks from longer mixes downloaded from YouTube.\n* **Managing multiple monitors and file transfer:** Enabling interaction and file transfer between different monitor sets within the game world.\n* **Creating a \"wrapped\" carousel of the year:** Building a visual representation of the year using screenshots or files from each day.\n* **Privacy guards:** Implementing features like disabling the microphone when entering passwords to prevent potential security risks.\n* **Toolbelt configuration and rebinding:** Designing and implementing different toolbelt configurations and allowing users to rebind hotkeys.\n* **Window management:** Providing tools for managing windows within the game world, including swapping positions, focusing, and maximizing.\n* **Media controls:** Implementing controls for pausing, playing, adjusting volume, and skipping media within the game environment.\n* **Boundary and zone tools:** Creating and managing boundaries and zones within the game world.\n* **Intellisense and suggestion:** Utilizing language server integration to provide suggestions and autocompletion for code within the game.\n* **Copilot integration:** Recognizing and handling Copilot suggestions to avoid conflicts with multiple cursors.\n* **Asset picking and sound editing:** Building an environment for browsing and previewing sound effects and integrating with sound editing tools.\n* **Running tests in Rust:** Adding a keyboard shortcut to run the test closest to the cursor in a Rust file.\n* **Monologuing and capturing information:** Exploring ways to capture information beyond speech transcription, such as mouse selection and tab changes.\n* **Summarizing and managing information:** Implementing tools to summarize information from various sources and manage the agent's context window.\n* **Teleportation and camera tools:** Providing tools for teleporting objects and managing camera focus within the game world.\n* **Creating new tools and files:** Implementing tools to streamline the creation of new tools and files within the game environment.\n* **Slider hub for volume control:** Creating a central hub for managing volume levels across different applications and media players.\n\n**Research notes:**\n\nThis section contains links to various resources related to the technologies and functionalities being explored in the project, including:\n\n* **Inference and fine-tuning LLMs:** Resources on different LLM models, training techniques, and inference methods.\n* **Vision and UI automation:** Tools and research papers related to computer vision, UI automation, and interaction with graphical user interfaces.\n* **RPA and tools for actions:** Projects and frameworks for robotic process automation and using LLMs to perform actions within a computer environment.\n* **Windows UI Automation:** Documentation and resources on the Windows UI Automation API and its functionalities.\n* **Win32 and system tools:** Information on Win32 API functions and system tools like Process Hacker and Process Monitor.\n* **Reinforcement learning and Bevy integration:** Resources on reinforcement learning and its potential integration with the Bevy game engine.\n* **Prompting and guidance languages:** Tools and frameworks for improving LLM prompting and providing guidance for specific tasks.\n* **Retrieval-Augmented Generation (RAG):** Research and tools related to RAG and its potential for enhancing LLM capabilities.\n* **Sandboxing and emulation:** Tools like v86 for emulating computer environments within the browser.\n* **Speech to text:** Resources on different speech-to-text models and libraries, including Whisper and WhisperX.\n* **Multiplayer and networking:** Frameworks like Veilid for building multiplayer and networked applications.\n* **Implementation tools and libraries:** Libraries like beartype and torchdim for improving development efficiency and code clarity.\n* **Assets and inspiration:** Resources for fonts, textures, and game inspiration for the project.\n\nThis summary provides a comprehensive overview of the various ideas, code snippets, use cases, and research notes documented in your files. It highlights the ambitious scope of the project and the diverse range of technologies being explored to achieve its goals.\n"
                        }
                    ],
                    "role": "model"
                },
                "finishReason": "STOP",
                "index": 0,
                "safetyRatings": [
                    {
                        "category": "HARM_CATEGORY_SEXUALLY_EXPLICIT",
                        "probability": "NEGLIGIBLE"
                    },
                    {
                        "category": "HARM_CATEGORY_HATE_SPEECH",
                        "probability": "NEGLIGIBLE"
                    },
                    {
                        "category": "HARM_CATEGORY_HARASSMENT",
                        "probability": "NEGLIGIBLE"
                    },
                    {
                        "category": "HARM_CATEGORY_DANGEROUS_CONTENT",
                        "probability": "NEGLIGIBLE"
                    }
                ]
            }
        ]
    }
}