{
    "payload": {
        "prompt": "# Summary\r\n\r\n\r\n## D:\\Repos\\Games\\bevy\\crates\\bevy_window\\src\\cursor.rs\r\n\r\n````rust\r\n// This file contains a portion of the CSS Basic User Interface Module Level 3\r\n// specification. In particular, the names for the cursor from the #cursor\r\n// section and documentation for some of the variants were taken.\r\n//\r\n// The original document is https://www.w3.org/TR/css-ui-3/#cursor.\r\n// Copyright \u00a9 2018 W3C\u00ae (MIT, ERCIM, Keio, Beihang)\r\n//\r\n// These documents were used under the terms of the following license. This W3C\r\n// license as well as the W3C short notice apply to the `CursorIcon` enum's\r\n// variants and documentation attached to them.\r\n\r\n// --------- BEGINNING OF W3C LICENSE\r\n// --------------------------------------------------------------\r\n//\r\n// License\r\n//\r\n// By obtaining and/or copying this work, you (the licensee) agree that you have\r\n// read, understood, and will comply with the following terms and conditions.\r\n//\r\n// Permission to copy, modify, and distribute this work, with or without\r\n// modification, for any purpose and without fee or royalty is hereby granted,\r\n// provided that you include the following on ALL copies of the work or portions\r\n// thereof, including modifications:\r\n//\r\n// - The full text of this NOTICE in a location viewable to users of the\r\n//   redistributed or derivative work.\r\n// - Any pre-existing intellectual property disclaimers, notices, or terms and\r\n//   conditions. If none exist, the W3C Software and Document Short Notice\r\n//   should be included.\r\n// - Notice of any changes or modifications, through a copyright statement on\r\n//   the new code or document such as \"This software or document includes\r\n//   material copied from or derived from [title and URI of the W3C document].\r\n//   Copyright \u00a9 [YEAR] W3C\u00ae (MIT, ERCIM, Keio, Beihang).\"\r\n//\r\n// Disclaimers\r\n//\r\n// THIS WORK IS PROVIDED \"AS IS,\" AND COPYRIGHT HOLDERS MAKE NO REPRESENTATIONS\r\n// OR WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO, WARRANTIES\r\n// OF MERCHANTABILITY OR FITNESS FOR ANY PARTICULAR PURPOSE OR THAT THE USE OF\r\n// THE SOFTWARE OR DOCUMENT WILL NOT INFRINGE ANY THIRD PARTY PATENTS,\r\n// COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS.\r\n//\r\n// COPYRIGHT HOLDERS WILL NOT BE LIABLE FOR ANY DIRECT, INDIRECT, SPECIAL OR\r\n// CONSEQUENTIAL DAMAGES ARISING OUT OF ANY USE OF THE SOFTWARE OR DOCUMENT.\r\n//\r\n// The name and trademarks of copyright holders may NOT be used in advertising\r\n// or publicity pertaining to the work without specific, written prior\r\n// permission. Title to copyright in this work will at all times remain with\r\n// copyright holders.\r\n//\r\n// --------- END OF W3C LICENSE\r\n// --------------------------------------------------------------------\r\n\r\n// --------- BEGINNING OF W3C SHORT NOTICE\r\n// ---------------------------------------------------------\r\n//\r\n// winit: https://github.com/rust-windowing/cursor-icon\r\n//\r\n// Copyright \u00a9 2023 World Wide Web Consortium, (Massachusetts Institute of\r\n// Technology, European Research Consortium for Informatics and Mathematics,\r\n// Keio University, Beihang). All Rights Reserved. This work is distributed\r\n// under the W3C\u00ae Software License [1] in the hope that it will be useful, but\r\n// WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\r\n// FITNESS FOR A PARTICULAR PURPOSE.\r\n//\r\n// [1] http://www.w3.org/Consortium/Legal/copyright-software\r\n//\r\n// --------- END OF W3C SHORT NOTICE\r\n// --------------------------------------------------------------\r\n\r\nuse bevy_reflect::{prelude::ReflectDefault, Reflect};\r\n\r\n#[cfg(feature = \"serialize\")]\r\nuse bevy_reflect::{ReflectDeserialize, ReflectSerialize};\r\n\r\n/// The icon to display for a [`Window`](crate::window::Window)'s [`Cursor`](crate::window::Cursor).\r\n///\r\n/// Examples of all of these cursors can be found [here](https://www.w3schools.com/cssref/playit.php?filename=playcss_cursor&preval=crosshair).\r\n/// This `enum` is simply a copy of a similar `enum` found in [`winit`](https://docs.rs/winit/latest/winit/window/enum.CursorIcon.html).\r\n/// `winit`, in turn, is based upon the [CSS3 UI spec](https://www.w3.org/TR/css-ui-3/#cursor).\r\n///\r\n/// See the [`window_settings`] example for usage.\r\n///\r\n/// [`window_settings`]: https://github.com/bevyengine/bevy/blob/latest/examples/window/window_settings.rs\r\n#[derive(Default, Debug, Hash, PartialEq, Eq, Clone, Copy, Reflect)]\r\n#[cfg_attr(\r\n    feature = \"serialize\",\r\n    derive(serde::Serialize, serde::Deserialize),\r\n    reflect(Serialize, Deserialize)\r\n)]\r\n#[reflect(Debug, PartialEq, Default)]\r\npub enum CursorIcon {\r\n    /// The platform-dependent default cursor. Often rendered as arrow.\r\n    #[default]\r\n    Default,\r\n\r\n    /// A context menu is available for the object under the cursor. Often\r\n    /// rendered as an arrow with a small menu-like graphic next to it.\r\n    ContextMenu,\r\n\r\n    /// Help is available for the object under the cursor. Often rendered as a\r\n    /// question mark or a balloon.\r\n    Help,\r\n\r\n    /// The cursor is a pointer that indicates a link. Often rendered as the\r\n    /// backside of a hand with the index finger extended.\r\n    Pointer,\r\n\r\n    /// A progress indicator. The program is performing some processing, but is\r\n    /// different from [`CursorIcon::Wait`] in that the user may still interact\r\n    /// with the program.\r\n    Progress,\r\n\r\n    /// Indicates that the program is busy and the user should wait. Often\r\n    /// rendered as a watch or hourglass.\r\n    Wait,\r\n\r\n    /// Indicates that a cell or set of cells may be selected. Often rendered as\r\n    /// a thick plus-sign with a dot in the middle.\r\n    Cell,\r\n\r\n    /// A simple crosshair (e.g., short line segments resembling a \"+\" sign).\r\n    /// Often used to indicate a two dimensional bitmap selection mode.\r\n    Crosshair,\r\n\r\n    /// Indicates text that may be selected. Often rendered as an I-beam.\r\n    Text,\r\n\r\n    /// Indicates vertical-text that may be selected. Often rendered as a\r\n    /// horizontal I-beam.\r\n    VerticalText,\r\n\r\n    /// Indicates an alias of/shortcut to something is to be created. Often\r\n    /// rendered as an arrow with a small curved arrow next to it.\r\n    Alias,\r\n\r\n    /// Indicates something is to be copied. Often rendered as an arrow with a\r\n    /// small plus sign next to it.\r\n    Copy,\r\n\r\n    /// Indicates something is to be moved.\r\n    Move,\r\n\r\n    /// Indicates that the dragged item cannot be dropped at the current cursor\r\n    /// location. Often rendered as a hand or pointer with a small circle with a\r\n    /// line through it.\r\n    NoDrop,\r\n\r\n    /// Indicates that the requested action will not be carried out. Often\r\n    /// rendered as a circle with a line through it.\r\n    NotAllowed,\r\n\r\n    /// Indicates that something can be grabbed (dragged to be moved). Often\r\n    /// rendered as the backside of an open hand.\r\n    Grab,\r\n\r\n    /// Indicates that something is being grabbed (dragged to be moved). Often\r\n    /// rendered as the backside of a hand with fingers closed mostly out of\r\n    /// view.\r\n    Grabbing,\r\n\r\n    /// The east border to be moved.\r\n    EResize,\r\n\r\n    /// The north border to be moved.\r\n    NResize,\r\n\r\n    /// The north-east corner to be moved.\r\n    NeResize,\r\n\r\n    /// The north-west corner to be moved.\r\n    NwResize,\r\n\r\n    /// The south border to be moved.\r\n    SResize,\r\n\r\n    /// The south-east corner to be moved.\r\n    SeResize,\r\n\r\n    /// The south-west corner to be moved.\r\n    SwResize,\r\n\r\n    /// The west border to be moved.\r\n    WResize,\r\n\r\n    /// The east and west borders to be moved.\r\n    EwResize,\r\n\r\n    /// The south and north borders to be moved.\r\n    NsResize,\r\n\r\n    /// The north-east and south-west corners to be moved.\r\n    NeswResize,\r\n\r\n    /// The north-west and south-east corners to be moved.\r\n    NwseResize,\r\n\r\n    /// Indicates that the item/column can be resized horizontally. Often\r\n    /// rendered as arrows pointing left and right with a vertical bar\r\n    /// separating them.\r\n    ColResize,\r\n\r\n    /// Indicates that the item/row can be resized vertically. Often rendered as\r\n    /// arrows pointing up and down with a horizontal bar separating them.\r\n    RowResize,\r\n\r\n    /// Indicates that the something can be scrolled in any direction. Often\r\n    /// rendered as arrows pointing up, down, left, and right with a dot in the\r\n    /// middle.\r\n    AllScroll,\r\n\r\n    /// Indicates that something can be zoomed in. Often rendered as a\r\n    /// magnifying glass with a \"+\" in the center of the glass.\r\n    ZoomIn,\r\n\r\n    /// Indicates that something can be zoomed in. Often rendered as a\r\n    /// magnifying glass with a \"-\" in the center of the glass.\r\n    ZoomOut,\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\bevy\\crates\\bevy_winit\\src\\winit_event.rs\r\n\r\n````rust\r\n#![allow(missing_docs)]\r\n\r\nuse bevy_app::App;\r\nuse bevy_ecs::prelude::*;\r\nuse bevy_input::keyboard::KeyboardInput;\r\nuse bevy_input::touch::TouchInput;\r\nuse bevy_input::{\r\n    mouse::{MouseButtonInput, MouseMotion, MouseWheel},\r\n    touchpad::{TouchpadMagnify, TouchpadRotate},\r\n};\r\nuse bevy_reflect::Reflect;\r\n#[cfg(feature = \"serialize\")]\r\nuse bevy_reflect::{ReflectDeserialize, ReflectSerialize};\r\nuse bevy_window::{\r\n    ApplicationLifetime, CursorEntered, CursorLeft, CursorMoved, FileDragAndDrop, Ime,\r\n    ReceivedCharacter, RequestRedraw, WindowBackendScaleFactorChanged, WindowCloseRequested,\r\n    WindowCreated, WindowDestroyed, WindowFocused, WindowMoved, WindowOccluded, WindowResized,\r\n    WindowScaleFactorChanged, WindowThemeChanged,\r\n};\r\n\r\n/// Wraps all `bevy_window` events in a common enum.\r\n///\r\n/// Read these events with `EventReader<WinitEvent>` if you need to\r\n/// access window events in the order they were received from `winit`.\r\n/// Otherwise, the event types are individually readable with\r\n/// `EventReader<E>` (e.g. `EventReader<KeyboardInput>`).\r\n#[derive(Event, Debug, Clone, PartialEq, Reflect)]\r\n#[reflect(Debug, PartialEq)]\r\n#[cfg_attr(\r\n    feature = \"serialize\",\r\n    derive(serde::Serialize, serde::Deserialize),\r\n    reflect(Serialize, Deserialize)\r\n)]\r\npub enum WinitEvent {\r\n    ApplicationLifetime(ApplicationLifetime),\r\n    CursorEntered(CursorEntered),\r\n    CursorLeft(CursorLeft),\r\n    CursorMoved(CursorMoved),\r\n    FileDragAndDrop(FileDragAndDrop),\r\n    Ime(Ime),\r\n    ReceivedCharacter(ReceivedCharacter),\r\n    RequestRedraw(RequestRedraw),\r\n    WindowBackendScaleFactorChanged(WindowBackendScaleFactorChanged),\r\n    WindowCloseRequested(WindowCloseRequested),\r\n    WindowCreated(WindowCreated),\r\n    WindowDestroyed(WindowDestroyed),\r\n    WindowFocused(WindowFocused),\r\n    WindowMoved(WindowMoved),\r\n    WindowOccluded(WindowOccluded),\r\n    WindowResized(WindowResized),\r\n    WindowScaleFactorChanged(WindowScaleFactorChanged),\r\n    WindowThemeChanged(WindowThemeChanged),\r\n\r\n    MouseButtonInput(MouseButtonInput),\r\n    MouseMotion(MouseMotion),\r\n    MouseWheel(MouseWheel),\r\n\r\n    TouchpadMagnify(TouchpadMagnify),\r\n    TouchpadRotate(TouchpadRotate),\r\n\r\n    TouchInput(TouchInput),\r\n\r\n    KeyboardInput(KeyboardInput),\r\n}\r\n\r\nimpl From<ApplicationLifetime> for WinitEvent {\r\n    fn from(e: ApplicationLifetime) -> Self {\r\n        Self::ApplicationLifetime(e)\r\n    }\r\n}\r\nimpl From<CursorEntered> for WinitEvent {\r\n    fn from(e: CursorEntered) -> Self {\r\n        Self::CursorEntered(e)\r\n    }\r\n}\r\nimpl From<CursorLeft> for WinitEvent {\r\n    fn from(e: CursorLeft) -> Self {\r\n        Self::CursorLeft(e)\r\n    }\r\n}\r\nimpl From<CursorMoved> for WinitEvent {\r\n    fn from(e: CursorMoved) -> Self {\r\n        Self::CursorMoved(e)\r\n    }\r\n}\r\nimpl From<FileDragAndDrop> for WinitEvent {\r\n    fn from(e: FileDragAndDrop) -> Self {\r\n        Self::FileDragAndDrop(e)\r\n    }\r\n}\r\nimpl From<Ime> for WinitEvent {\r\n    fn from(e: Ime) -> Self {\r\n        Self::Ime(e)\r\n    }\r\n}\r\nimpl From<ReceivedCharacter> for WinitEvent {\r\n    fn from(e: ReceivedCharacter) -> Self {\r\n        Self::ReceivedCharacter(e)\r\n    }\r\n}\r\nimpl From<RequestRedraw> for WinitEvent {\r\n    fn from(e: RequestRedraw) -> Self {\r\n        Self::RequestRedraw(e)\r\n    }\r\n}\r\nimpl From<WindowBackendScaleFactorChanged> for WinitEvent {\r\n    fn from(e: WindowBackendScaleFactorChanged) -> Self {\r\n        Self::WindowBackendScaleFactorChanged(e)\r\n    }\r\n}\r\nimpl From<WindowCloseRequested> for WinitEvent {\r\n    fn from(e: WindowCloseRequested) -> Self {\r\n        Self::WindowCloseRequested(e)\r\n    }\r\n}\r\nimpl From<WindowCreated> for WinitEvent {\r\n    fn from(e: WindowCreated) -> Self {\r\n        Self::WindowCreated(e)\r\n    }\r\n}\r\nimpl From<WindowDestroyed> for WinitEvent {\r\n    fn from(e: WindowDestroyed) -> Self {\r\n        Self::WindowDestroyed(e)\r\n    }\r\n}\r\nimpl From<WindowFocused> for WinitEvent {\r\n    fn from(e: WindowFocused) -> Self {\r\n        Self::WindowFocused(e)\r\n    }\r\n}\r\nimpl From<WindowMoved> for WinitEvent {\r\n    fn from(e: WindowMoved) -> Self {\r\n        Self::WindowMoved(e)\r\n    }\r\n}\r\nimpl From<WindowOccluded> for WinitEvent {\r\n    fn from(e: WindowOccluded) -> Self {\r\n        Self::WindowOccluded(e)\r\n    }\r\n}\r\nimpl From<WindowResized> for WinitEvent {\r\n    fn from(e: WindowResized) -> Self {\r\n        Self::WindowResized(e)\r\n    }\r\n}\r\nimpl From<WindowScaleFactorChanged> for WinitEvent {\r\n    fn from(e: WindowScaleFactorChanged) -> Self {\r\n        Self::WindowScaleFactorChanged(e)\r\n    }\r\n}\r\nimpl From<WindowThemeChanged> for WinitEvent {\r\n    fn from(e: WindowThemeChanged) -> Self {\r\n        Self::WindowThemeChanged(e)\r\n    }\r\n}\r\nimpl From<MouseButtonInput> for WinitEvent {\r\n    fn from(e: MouseButtonInput) -> Self {\r\n        Self::MouseButtonInput(e)\r\n    }\r\n}\r\nimpl From<MouseMotion> for WinitEvent {\r\n    fn from(e: MouseMotion) -> Self {\r\n        Self::MouseMotion(e)\r\n    }\r\n}\r\nimpl From<MouseWheel> for WinitEvent {\r\n    fn from(e: MouseWheel) -> Self {\r\n        Self::MouseWheel(e)\r\n    }\r\n}\r\nimpl From<TouchpadMagnify> for WinitEvent {\r\n    fn from(e: TouchpadMagnify) -> Self {\r\n        Self::TouchpadMagnify(e)\r\n    }\r\n}\r\nimpl From<TouchpadRotate> for WinitEvent {\r\n    fn from(e: TouchpadRotate) -> Self {\r\n        Self::TouchpadRotate(e)\r\n    }\r\n}\r\nimpl From<TouchInput> for WinitEvent {\r\n    fn from(e: TouchInput) -> Self {\r\n        Self::TouchInput(e)\r\n    }\r\n}\r\nimpl From<KeyboardInput> for WinitEvent {\r\n    fn from(e: KeyboardInput) -> Self {\r\n        Self::KeyboardInput(e)\r\n    }\r\n}\r\n\r\n/// Forwards buffered [`WinitEvent`] events to the app.\r\npub(crate) fn forward_winit_events(buffered_events: &mut Vec<WinitEvent>, app: &mut App) {\r\n    if buffered_events.is_empty() {\r\n        return;\r\n    }\r\n    for winit_event in buffered_events.iter() {\r\n        match winit_event.clone() {\r\n            WinitEvent::ApplicationLifetime(e) => {\r\n                app.world.send_event(e);\r\n            }\r\n            WinitEvent::CursorEntered(e) => {\r\n                app.world.send_event(e);\r\n            }\r\n            WinitEvent::CursorLeft(e) => {\r\n                app.world.send_event(e);\r\n            }\r\n            WinitEvent::CursorMoved(e) => {\r\n                app.world.send_event(e);\r\n            }\r\n            WinitEvent::FileDragAndDrop(e) => {\r\n                app.world.send_event(e);\r\n            }\r\n            WinitEvent::Ime(e) => {\r\n                app.world.send_event(e);\r\n            }\r\n            WinitEvent::ReceivedCharacter(e) => {\r\n                app.world.send_event(e);\r\n            }\r\n            WinitEvent::RequestRedraw(e) => {\r\n                app.world.send_event(e);\r\n            }\r\n            WinitEvent::WindowBackendScaleFactorChanged(e) => {\r\n                app.world.send_event(e);\r\n            }\r\n            WinitEvent::WindowCloseRequested(e) => {\r\n                app.world.send_event(e);\r\n            }\r\n            WinitEvent::WindowCreated(e) => {\r\n                app.world.send_event(e);\r\n            }\r\n            WinitEvent::WindowDestroyed(e) => {\r\n                app.world.send_event(e);\r\n            }\r\n            WinitEvent::WindowFocused(e) => {\r\n                app.world.send_event(e);\r\n            }\r\n            WinitEvent::WindowMoved(e) => {\r\n                app.world.send_event(e);\r\n            }\r\n            WinitEvent::WindowOccluded(e) => {\r\n                app.world.send_event(e);\r\n            }\r\n            WinitEvent::WindowResized(e) => {\r\n                app.world.send_event(e);\r\n            }\r\n            WinitEvent::WindowScaleFactorChanged(e) => {\r\n                app.world.send_event(e);\r\n            }\r\n            WinitEvent::WindowThemeChanged(e) => {\r\n                app.world.send_event(e);\r\n            }\r\n            WinitEvent::MouseButtonInput(e) => {\r\n                app.world.send_event(e);\r\n            }\r\n            WinitEvent::MouseMotion(e) => {\r\n                app.world.send_event(e);\r\n            }\r\n            WinitEvent::MouseWheel(e) => {\r\n                app.world.send_event(e);\r\n            }\r\n            WinitEvent::TouchpadMagnify(e) => {\r\n                app.world.send_event(e);\r\n            }\r\n            WinitEvent::TouchpadRotate(e) => {\r\n                app.world.send_event(e);\r\n            }\r\n            WinitEvent::TouchInput(e) => {\r\n                app.world.send_event(e);\r\n            }\r\n            WinitEvent::KeyboardInput(e) => {\r\n                app.world.send_event(e);\r\n            }\r\n        }\r\n    }\r\n    app.world\r\n        .resource_mut::<Events<WinitEvent>>()\r\n        .send_batch(buffered_events.drain(..));\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\bevy\\crates\\bevy_ecs\\src\\world\\entity_ref.rs\r\n\r\n````rust\r\nuse crate::{\r\n    archetype::{Archetype, ArchetypeId, Archetypes},\r\n    bundle::{Bundle, BundleId, BundleInfo, BundleInserter, DynamicBundle},\r\n    change_detection::MutUntyped,\r\n    component::{Component, ComponentId, ComponentTicks, Components, StorageType},\r\n    entity::{Entities, Entity, EntityLocation},\r\n    query::{Access, DebugCheckedUnwrap},\r\n    removal_detection::RemovedComponentEvents,\r\n    storage::Storages,\r\n    world::{Mut, World},\r\n};\r\nuse bevy_ptr::{OwningPtr, Ptr};\r\nuse std::{any::TypeId, marker::PhantomData};\r\nuse thiserror::Error;\r\n\r\nuse super::{unsafe_world_cell::UnsafeEntityCell, Ref};\r\n\r\n/// A read-only reference to a particular [`Entity`] and all of its components.\r\n///\r\n/// # Examples\r\n///\r\n/// Read-only access disjoint with mutable access.\r\n///\r\n/// ```\r\n/// # use bevy_ecs::prelude::*;\r\n/// # #[derive(Component)] pub struct A;\r\n/// # #[derive(Component)] pub struct B;\r\n/// fn disjoint_system(\r\n///     query1: Query<&mut A>,\r\n///     query2: Query<EntityRef, Without<A>>,\r\n/// ) {\r\n///     // ...\r\n/// }\r\n/// # bevy_ecs::system::assert_is_system(disjoint_system);\r\n/// ```\r\n#[derive(Copy, Clone)]\r\npub struct EntityRef<'w>(UnsafeEntityCell<'w>);\r\n\r\nimpl<'w> EntityRef<'w> {\r\n    /// # Safety\r\n    /// - `cell` must have permission to read every component of the entity.\r\n    /// - No mutable accesses to any of the entity's components may exist\r\n    ///   at the same time as the returned [`EntityRef`].\r\n    #[inline]\r\n    pub(crate) unsafe fn new(cell: UnsafeEntityCell<'w>) -> Self {\r\n        Self(cell)\r\n    }\r\n\r\n    /// Returns the [ID](Entity) of the current entity.\r\n    #[inline]\r\n    #[must_use = \"Omit the .id() call if you do not need to store the `Entity` identifier.\"]\r\n    pub fn id(&self) -> Entity {\r\n        self.0.id()\r\n    }\r\n\r\n    /// Gets metadata indicating the location where the current entity is stored.\r\n    #[inline]\r\n    pub fn location(&self) -> EntityLocation {\r\n        self.0.location()\r\n    }\r\n\r\n    /// Returns the archetype that the current entity belongs to.\r\n    #[inline]\r\n    pub fn archetype(&self) -> &Archetype {\r\n        self.0.archetype()\r\n    }\r\n\r\n    /// Returns `true` if the current entity has a component of type `T`.\r\n    /// Otherwise, this returns `false`.\r\n    ///\r\n    /// ## Notes\r\n    ///\r\n    /// If you do not know the concrete type of a component, consider using\r\n    /// [`Self::contains_id`] or [`Self::contains_type_id`].\r\n    #[inline]\r\n    pub fn contains<T: Component>(&self) -> bool {\r\n        self.contains_type_id(TypeId::of::<T>())\r\n    }\r\n\r\n    /// Returns `true` if the current entity has a component identified by `component_id`.\r\n    /// Otherwise, this returns false.\r\n    ///\r\n    /// ## Notes\r\n    ///\r\n    /// - If you know the concrete type of the component, you should prefer [`Self::contains`].\r\n    /// - If you know the component's [`TypeId`] but not its [`ComponentId`], consider using\r\n    /// [`Self::contains_type_id`].\r\n    #[inline]\r\n    pub fn contains_id(&self, component_id: ComponentId) -> bool {\r\n        self.0.contains_id(component_id)\r\n    }\r\n\r\n    /// Returns `true` if the current entity has a component with the type identified by `type_id`.\r\n    /// Otherwise, this returns false.\r\n    ///\r\n    /// ## Notes\r\n    ///\r\n    /// - If you know the concrete type of the component, you should prefer [`Self::contains`].\r\n    /// - If you have a [`ComponentId`] instead of a [`TypeId`], consider using [`Self::contains_id`].\r\n    #[inline]\r\n    pub fn contains_type_id(&self, type_id: TypeId) -> bool {\r\n        self.0.contains_type_id(type_id)\r\n    }\r\n\r\n    /// Gets access to the component of type `T` for the current entity.\r\n    /// Returns `None` if the entity does not have a component of type `T`.\r\n    #[inline]\r\n    pub fn get<T: Component>(&self) -> Option<&'w T> {\r\n        // SAFETY: We have read-only access to all components of this entity.\r\n        unsafe { self.0.get::<T>() }\r\n    }\r\n\r\n    /// Gets access to the component of type `T` for the current entity,\r\n    /// including change detection information as a [`Ref`].\r\n    ///\r\n    /// Returns `None` if the entity does not have a component of type `T`.\r\n    #[inline]\r\n    pub fn get_ref<T: Component>(&self) -> Option<Ref<'w, T>> {\r\n        // SAFETY: We have read-only access to all components of this entity.\r\n        unsafe { self.0.get_ref::<T>() }\r\n    }\r\n\r\n    /// Retrieves the change ticks for the given component. This can be useful for implementing change\r\n    /// detection in custom runtimes.\r\n    #[inline]\r\n    pub fn get_change_ticks<T: Component>(&self) -> Option<ComponentTicks> {\r\n        // SAFETY: We have read-only access to all components of this entity.\r\n        unsafe { self.0.get_change_ticks::<T>() }\r\n    }\r\n\r\n    /// Retrieves the change ticks for the given [`ComponentId`]. This can be useful for implementing change\r\n    /// detection in custom runtimes.\r\n    ///\r\n    /// **You should prefer to use the typed API [`EntityRef::get_change_ticks`] where possible and only\r\n    /// use this in cases where the actual component types are not known at\r\n    /// compile time.**\r\n    #[inline]\r\n    pub fn get_change_ticks_by_id(&self, component_id: ComponentId) -> Option<ComponentTicks> {\r\n        // SAFETY: We have read-only access to all components of this entity.\r\n        unsafe { self.0.get_change_ticks_by_id(component_id) }\r\n    }\r\n\r\n    /// Gets the component of the given [`ComponentId`] from the entity.\r\n    ///\r\n    /// **You should prefer to use the typed API where possible and only\r\n    /// use this in cases where the actual component types are not known at\r\n    /// compile time.**\r\n    ///\r\n    /// Unlike [`EntityRef::get`], this returns a raw pointer to the component,\r\n    /// which is only valid while the `'w` borrow of the lifetime is active.\r\n    #[inline]\r\n    pub fn get_by_id(&self, component_id: ComponentId) -> Option<Ptr<'w>> {\r\n        // SAFETY: We have read-only access to all components of this entity.\r\n        unsafe { self.0.get_by_id(component_id) }\r\n    }\r\n}\r\n\r\nimpl<'w> From<EntityWorldMut<'w>> for EntityRef<'w> {\r\n    fn from(entity_mut: EntityWorldMut<'w>) -> EntityRef<'w> {\r\n        // SAFETY:\r\n        // - `EntityWorldMut` guarantees exclusive access to the entire world.\r\n        unsafe { EntityRef::new(entity_mut.into_unsafe_entity_cell()) }\r\n    }\r\n}\r\n\r\nimpl<'a> From<&'a EntityWorldMut<'_>> for EntityRef<'a> {\r\n    fn from(value: &'a EntityWorldMut<'_>) -> Self {\r\n        // SAFETY:\r\n        // - `EntityWorldMut` guarantees exclusive access to the entire world.\r\n        // - `&value` ensures no mutable accesses are active.\r\n        unsafe { EntityRef::new(value.as_unsafe_entity_cell_readonly()) }\r\n    }\r\n}\r\n\r\nimpl<'w> From<EntityMut<'w>> for EntityRef<'w> {\r\n    fn from(value: EntityMut<'w>) -> Self {\r\n        // SAFETY:\r\n        // - `EntityMut` guarantees exclusive access to all of the entity's components.\r\n        unsafe { EntityRef::new(value.0) }\r\n    }\r\n}\r\n\r\nimpl<'a> From<&'a EntityMut<'_>> for EntityRef<'a> {\r\n    fn from(value: &'a EntityMut<'_>) -> Self {\r\n        // SAFETY:\r\n        // - `EntityMut` guarantees exclusive access to all of the entity's components.\r\n        // - `&value` ensures there are no mutable accesses.\r\n        unsafe { EntityRef::new(value.0) }\r\n    }\r\n}\r\n\r\nimpl<'a> TryFrom<FilteredEntityRef<'a>> for EntityRef<'a> {\r\n    type Error = TryFromFilteredError;\r\n\r\n    fn try_from(value: FilteredEntityRef<'a>) -> Result<Self, Self::Error> {\r\n        if !value.access.has_read_all() {\r\n            Err(TryFromFilteredError::MissingReadAllAccess)\r\n        } else {\r\n            // SAFETY: check above guarantees read-only access to all components of the entity.\r\n            Ok(unsafe { EntityRef::new(value.entity) })\r\n        }\r\n    }\r\n}\r\n\r\nimpl<'a> TryFrom<&'a FilteredEntityRef<'_>> for EntityRef<'a> {\r\n    type Error = TryFromFilteredError;\r\n\r\n    fn try_from(value: &'a FilteredEntityRef<'_>) -> Result<Self, Self::Error> {\r\n        if !value.access.has_read_all() {\r\n            Err(TryFromFilteredError::MissingReadAllAccess)\r\n        } else {\r\n            // SAFETY: check above guarantees read-only access to all components of the entity.\r\n            Ok(unsafe { EntityRef::new(value.entity) })\r\n        }\r\n    }\r\n}\r\n\r\nimpl<'a> TryFrom<FilteredEntityMut<'a>> for EntityRef<'a> {\r\n    type Error = TryFromFilteredError;\r\n\r\n    fn try_from(value: FilteredEntityMut<'a>) -> Result<Self, Self::Error> {\r\n        if !value.access.has_read_all() {\r\n            Err(TryFromFilteredError::MissingReadAllAccess)\r\n        } else {\r\n            // SAFETY: check above guarantees read-only access to all components of the entity.\r\n            Ok(unsafe { EntityRef::new(value.entity) })\r\n        }\r\n    }\r\n}\r\n\r\nimpl<'a> TryFrom<&'a FilteredEntityMut<'_>> for EntityRef<'a> {\r\n    type Error = TryFromFilteredError;\r\n\r\n    fn try_from(value: &'a FilteredEntityMut<'_>) -> Result<Self, Self::Error> {\r\n        if !value.access.has_read_all() {\r\n            Err(TryFromFilteredError::MissingReadAllAccess)\r\n        } else {\r\n            // SAFETY: check above guarantees read-only access to all components of the entity.\r\n            Ok(unsafe { EntityRef::new(value.entity) })\r\n        }\r\n    }\r\n}\r\n\r\n/// Provides mutable access to a single entity and all of its components.\r\n///\r\n/// Contrast with [`EntityWorldMut`], which allows adding and removing components,\r\n/// despawning the entity, and provides mutable access to the entire world.\r\n/// Because of this, `EntityWorldMut` cannot coexist with any other world accesses.\r\n///\r\n/// # Examples\r\n///\r\n/// Disjoint mutable access.\r\n///\r\n/// ```\r\n/// # use bevy_ecs::prelude::*;\r\n/// # #[derive(Component)] pub struct A;\r\n/// fn disjoint_system(\r\n///     query1: Query<EntityMut, With<A>>,\r\n///     query2: Query<EntityMut, Without<A>>,\r\n/// ) {\r\n///     // ...\r\n/// }\r\n/// # bevy_ecs::system::assert_is_system(disjoint_system);\r\n/// ```\r\npub struct EntityMut<'w>(UnsafeEntityCell<'w>);\r\n\r\nimpl<'w> EntityMut<'w> {\r\n    /// # Safety\r\n    /// - `cell` must have permission to mutate every component of the entity.\r\n    /// - No accesses to any of the entity's components may exist\r\n    ///   at the same time as the returned [`EntityMut`].\r\n    pub(crate) unsafe fn new(cell: UnsafeEntityCell<'w>) -> Self {\r\n        Self(cell)\r\n    }\r\n\r\n    /// Returns a new instance with a shorter lifetime.\r\n    /// This is useful if you have `&mut EntityMut`, but you need `EntityMut`.\r\n    pub fn reborrow(&mut self) -> EntityMut<'_> {\r\n        // SAFETY: We have exclusive access to the entire entity and its components.\r\n        unsafe { Self::new(self.0) }\r\n    }\r\n\r\n    /// Gets read-only access to all of the entity's components.\r\n    pub fn as_readonly(&self) -> EntityRef<'_> {\r\n        EntityRef::from(self)\r\n    }\r\n\r\n    /// Returns the [ID](Entity) of the current entity.\r\n    #[inline]\r\n    #[must_use = \"Omit the .id() call if you do not need to store the `Entity` identifier.\"]\r\n    pub fn id(&self) -> Entity {\r\n        self.0.id()\r\n    }\r\n\r\n    /// Gets metadata indicating the location where the current entity is stored.\r\n    #[inline]\r\n    pub fn location(&self) -> EntityLocation {\r\n        self.0.location()\r\n    }\r\n\r\n    /// Returns the archetype that the current entity belongs to.\r\n    #[inline]\r\n    pub fn archetype(&self) -> &Archetype {\r\n        self.0.archetype()\r\n    }\r\n\r\n    /// Returns `true` if the current entity has a component of type `T`.\r\n    /// Otherwise, this returns `false`.\r\n    ///\r\n    /// ## Notes\r\n    ///\r\n    /// If you do not know the concrete type of a component, consider using\r\n    /// [`Self::contains_id`] or [`Self::contains_type_id`].\r\n    #[inline]\r\n    pub fn contains<T: Component>(&self) -> bool {\r\n        self.contains_type_id(TypeId::of::<T>())\r\n    }\r\n\r\n    /// Returns `true` if the current entity has a component identified by `component_id`.\r\n    /// Otherwise, this returns false.\r\n    ///\r\n    /// ## Notes\r\n    ///\r\n    /// - If you know the concrete type of the component, you should prefer [`Self::contains`].\r\n    /// - If you know the component's [`TypeId`] but not its [`ComponentId`], consider using\r\n    /// [`Self::contains_type_id`].\r\n    #[inline]\r\n    pub fn contains_id(&self, component_id: ComponentId) -> bool {\r\n        self.0.contains_id(component_id)\r\n    }\r\n\r\n    /// Returns `true` if the current entity has a component with the type identified by `type_id`.\r\n    /// Otherwise, this returns false.\r\n    ///\r\n    /// ## Notes\r\n    ///\r\n    /// - If you know the concrete type of the component, you should prefer [`Self::contains`].\r\n    /// - If you have a [`ComponentId`] instead of a [`TypeId`], consider using [`Self::contains_id`].\r\n    #[inline]\r\n    pub fn contains_type_id(&self, type_id: TypeId) -> bool {\r\n        self.0.contains_type_id(type_id)\r\n    }\r\n\r\n    /// Gets access to the component of type `T` for the current entity.\r\n    /// Returns `None` if the entity does not have a component of type `T`.\r\n    #[inline]\r\n    pub fn get<T: Component>(&self) -> Option<&'_ T> {\r\n        self.as_readonly().get()\r\n    }\r\n\r\n    /// Gets access to the component of type `T` for the current entity,\r\n    /// including change detection information as a [`Ref`].\r\n    ///\r\n    /// Returns `None` if the entity does not have a component of type `T`.\r\n    #[inline]\r\n    pub fn get_ref<T: Component>(&self) -> Option<Ref<'_, T>> {\r\n        self.as_readonly().get_ref()\r\n    }\r\n\r\n    /// Gets mutable access to the component of type `T` for the current entity.\r\n    /// Returns `None` if the entity does not have a component of type `T`.\r\n    #[inline]\r\n    pub fn get_mut<T: Component>(&mut self) -> Option<Mut<'_, T>> {\r\n        // SAFETY: &mut self implies exclusive access for duration of returned value\r\n        unsafe { self.0.get_mut() }\r\n    }\r\n\r\n    /// Retrieves the change ticks for the given component. This can be useful for implementing change\r\n    /// detection in custom runtimes.\r\n    #[inline]\r\n    pub fn get_change_ticks<T: Component>(&self) -> Option<ComponentTicks> {\r\n        self.as_readonly().get_change_ticks::<T>()\r\n    }\r\n\r\n    /// Retrieves the change ticks for the given [`ComponentId`]. This can be useful for implementing change\r\n    /// detection in custom runtimes.\r\n    ///\r\n    /// **You should prefer to use the typed API [`EntityWorldMut::get_change_ticks`] where possible and only\r\n    /// use this in cases where the actual component types are not known at\r\n    /// compile time.**\r\n    #[inline]\r\n    pub fn get_change_ticks_by_id(&self, component_id: ComponentId) -> Option<ComponentTicks> {\r\n        self.as_readonly().get_change_ticks_by_id(component_id)\r\n    }\r\n\r\n    /// Gets the component of the given [`ComponentId`] from the entity.\r\n    ///\r\n    /// **You should prefer to use the typed API [`EntityWorldMut::get`] where possible and only\r\n    /// use this in cases where the actual component types are not known at\r\n    /// compile time.**\r\n    ///\r\n    /// Unlike [`EntityMut::get`], this returns a raw pointer to the component,\r\n    /// which is only valid while the [`EntityMut`] is alive.\r\n    #[inline]\r\n    pub fn get_by_id(&self, component_id: ComponentId) -> Option<Ptr<'_>> {\r\n        self.as_readonly().get_by_id(component_id)\r\n    }\r\n\r\n    /// Gets a [`MutUntyped`] of the component of the given [`ComponentId`] from the entity.\r\n    ///\r\n    /// **You should prefer to use the typed API [`EntityMut::get_mut`] where possible and only\r\n    /// use this in cases where the actual component types are not known at\r\n    /// compile time.**\r\n    ///\r\n    /// Unlike [`EntityMut::get_mut`], this returns a raw pointer to the component,\r\n    /// which is only valid while the [`EntityMut`] is alive.\r\n    #[inline]\r\n    pub fn get_mut_by_id(&mut self, component_id: ComponentId) -> Option<MutUntyped<'_>> {\r\n        // SAFETY:\r\n        // - `&mut self` ensures that no references exist to this entity's components.\r\n        // - `as_unsafe_world_cell` gives mutable permission for all components on this entity\r\n        unsafe { self.0.get_mut_by_id(component_id) }\r\n    }\r\n}\r\n\r\nimpl<'w> From<EntityWorldMut<'w>> for EntityMut<'w> {\r\n    fn from(value: EntityWorldMut<'w>) -> Self {\r\n        // SAFETY: `EntityWorldMut` guarantees exclusive access to the entire world.\r\n        unsafe { EntityMut::new(value.into_unsafe_entity_cell()) }\r\n    }\r\n}\r\n\r\nimpl<'a> From<&'a mut EntityWorldMut<'_>> for EntityMut<'a> {\r\n    fn from(value: &'a mut EntityWorldMut<'_>) -> Self {\r\n        // SAFETY: `EntityWorldMut` guarantees exclusive access to the entire world.\r\n        unsafe { EntityMut::new(value.as_unsafe_entity_cell()) }\r\n    }\r\n}\r\n\r\nimpl<'a> TryFrom<FilteredEntityMut<'a>> for EntityMut<'a> {\r\n    type Error = TryFromFilteredError;\r\n\r\n    fn try_from(value: FilteredEntityMut<'a>) -> Result<Self, Self::Error> {\r\n        if !value.access.has_read_all() {\r\n            Err(TryFromFilteredError::MissingReadAllAccess)\r\n        } else if !value.access.has_write_all() {\r\n            Err(TryFromFilteredError::MissingWriteAllAccess)\r\n        } else {\r\n            // SAFETY: check above guarantees exclusive access to all components of the entity.\r\n            Ok(unsafe { EntityMut::new(value.entity) })\r\n        }\r\n    }\r\n}\r\n\r\nimpl<'a> TryFrom<&'a mut FilteredEntityMut<'_>> for EntityMut<'a> {\r\n    type Error = TryFromFilteredError;\r\n\r\n    fn try_from(value: &'a mut FilteredEntityMut<'_>) -> Result<Self, Self::Error> {\r\n        if !value.access.has_read_all() {\r\n            Err(TryFromFilteredError::MissingReadAllAccess)\r\n        } else if !value.access.has_write_all() {\r\n            Err(TryFromFilteredError::MissingWriteAllAccess)\r\n        } else {\r\n            // SAFETY: check above guarantees exclusive access to all components of the entity.\r\n            Ok(unsafe { EntityMut::new(value.entity) })\r\n        }\r\n    }\r\n}\r\n\r\n/// A mutable reference to a particular [`Entity`], and the entire world.\r\n/// This is essentially a performance-optimized `(Entity, &mut World)` tuple,\r\n/// which caches the [`EntityLocation`] to reduce duplicate lookups.\r\n///\r\n/// Since this type provides mutable access to the entire world, only one\r\n/// [`EntityWorldMut`] can exist at a time for a given world.\r\n///\r\n/// See also [`EntityMut`], which allows disjoint mutable access to multiple\r\n/// entities at once.  Unlike `EntityMut`, this type allows adding and\r\n/// removing components, and despawning the entity.\r\npub struct EntityWorldMut<'w> {\r\n    world: &'w mut World,\r\n    entity: Entity,\r\n    location: EntityLocation,\r\n}\r\n\r\nimpl<'w> EntityWorldMut<'w> {\r\n    fn as_unsafe_entity_cell_readonly(&self) -> UnsafeEntityCell<'_> {\r\n        UnsafeEntityCell::new(\r\n            self.world.as_unsafe_world_cell_readonly(),\r\n            self.entity,\r\n            self.location,\r\n        )\r\n    }\r\n    fn as_unsafe_entity_cell(&mut self) -> UnsafeEntityCell<'_> {\r\n        UnsafeEntityCell::new(\r\n            self.world.as_unsafe_world_cell(),\r\n            self.entity,\r\n            self.location,\r\n        )\r\n    }\r\n    fn into_unsafe_entity_cell(self) -> UnsafeEntityCell<'w> {\r\n        UnsafeEntityCell::new(\r\n            self.world.as_unsafe_world_cell(),\r\n            self.entity,\r\n            self.location,\r\n        )\r\n    }\r\n\r\n    /// # Safety\r\n    ///\r\n    ///  - `entity` must be valid for `world`: the generation should match that of the entity at the same index.\r\n    ///  - `location` must be sourced from `world`'s `Entities` and must exactly match the location for `entity`\r\n    ///\r\n    ///  The above is trivially satisfied if `location` was sourced from `world.entities().get(entity)`.\r\n    #[inline]\r\n    pub(crate) unsafe fn new(\r\n        world: &'w mut World,\r\n        entity: Entity,\r\n        location: EntityLocation,\r\n    ) -> Self {\r\n        debug_assert!(world.entities().contains(entity));\r\n        debug_assert_eq!(world.entities().get(entity), Some(location));\r\n\r\n        EntityWorldMut {\r\n            world,\r\n            entity,\r\n            location,\r\n        }\r\n    }\r\n\r\n    /// Returns the [ID](Entity) of the current entity.\r\n    #[inline]\r\n    #[must_use = \"Omit the .id() call if you do not need to store the `Entity` identifier.\"]\r\n    pub fn id(&self) -> Entity {\r\n        self.entity\r\n    }\r\n\r\n    /// Gets metadata indicating the location where the current entity is stored.\r\n    #[inline]\r\n    pub fn location(&self) -> EntityLocation {\r\n        self.location\r\n    }\r\n\r\n    /// Returns the archetype that the current entity belongs to.\r\n    #[inline]\r\n    pub fn archetype(&self) -> &Archetype {\r\n        &self.world.archetypes[self.location.archetype_id]\r\n    }\r\n\r\n    /// Returns `true` if the current entity has a component of type `T`.\r\n    /// Otherwise, this returns `false`.\r\n    ///\r\n    /// ## Notes\r\n    ///\r\n    /// If you do not know the concrete type of a component, consider using\r\n    /// [`Self::contains_id`] or [`Self::contains_type_id`].\r\n    #[inline]\r\n    pub fn contains<T: Component>(&self) -> bool {\r\n        self.contains_type_id(TypeId::of::<T>())\r\n    }\r\n\r\n    /// Returns `true` if the current entity has a component identified by `component_id`.\r\n    /// Otherwise, this returns false.\r\n    ///\r\n    /// ## Notes\r\n    ///\r\n    /// - If you know the concrete type of the component, you should prefer [`Self::contains`].\r\n    /// - If you know the component's [`TypeId`] but not its [`ComponentId`], consider using\r\n    /// [`Self::contains_type_id`].\r\n    #[inline]\r\n    pub fn contains_id(&self, component_id: ComponentId) -> bool {\r\n        self.as_unsafe_entity_cell_readonly()\r\n            .contains_id(component_id)\r\n    }\r\n\r\n    /// Returns `true` if the current entity has a component with the type identified by `type_id`.\r\n    /// Otherwise, this returns false.\r\n    ///\r\n    /// ## Notes\r\n    ///\r\n    /// - If you know the concrete type of the component, you should prefer [`Self::contains`].\r\n    /// - If you have a [`ComponentId`] instead of a [`TypeId`], consider using [`Self::contains_id`].\r\n    #[inline]\r\n    pub fn contains_type_id(&self, type_id: TypeId) -> bool {\r\n        self.as_unsafe_entity_cell_readonly()\r\n            .contains_type_id(type_id)\r\n    }\r\n\r\n    /// Gets access to the component of type `T` for the current entity.\r\n    /// Returns `None` if the entity does not have a component of type `T`.\r\n    #[inline]\r\n    pub fn get<T: Component>(&self) -> Option<&'_ T> {\r\n        EntityRef::from(self).get()\r\n    }\r\n\r\n    /// Gets access to the component of type `T` for the current entity,\r\n    /// including change detection information as a [`Ref`].\r\n    ///\r\n    /// Returns `None` if the entity does not have a component of type `T`.\r\n    #[inline]\r\n    pub fn get_ref<T: Component>(&self) -> Option<Ref<'_, T>> {\r\n        EntityRef::from(self).get_ref()\r\n    }\r\n\r\n    /// Gets mutable access to the component of type `T` for the current entity.\r\n    /// Returns `None` if the entity does not have a component of type `T`.\r\n    #[inline]\r\n    pub fn get_mut<T: Component>(&mut self) -> Option<Mut<'_, T>> {\r\n        // SAFETY: &mut self implies exclusive access for duration of returned value\r\n        unsafe { self.as_unsafe_entity_cell().get_mut() }\r\n    }\r\n\r\n    /// Retrieves the change ticks for the given component. This can be useful for implementing change\r\n    /// detection in custom runtimes.\r\n    #[inline]\r\n    pub fn get_change_ticks<T: Component>(&self) -> Option<ComponentTicks> {\r\n        EntityRef::from(self).get_change_ticks::<T>()\r\n    }\r\n\r\n    /// Retrieves the change ticks for the given [`ComponentId`]. This can be useful for implementing change\r\n    /// detection in custom runtimes.\r\n    ///\r\n    /// **You should prefer to use the typed API [`EntityWorldMut::get_change_ticks`] where possible and only\r\n    /// use this in cases where the actual component types are not known at\r\n    /// compile time.**\r\n    #[inline]\r\n    pub fn get_change_ticks_by_id(&self, component_id: ComponentId) -> Option<ComponentTicks> {\r\n        EntityRef::from(self).get_change_ticks_by_id(component_id)\r\n    }\r\n\r\n    /// Gets the component of the given [`ComponentId`] from the entity.\r\n    ///\r\n    /// **You should prefer to use the typed API [`EntityWorldMut::get`] where possible and only\r\n    /// use this in cases where the actual component types are not known at\r\n    /// compile time.**\r\n    ///\r\n    /// Unlike [`EntityWorldMut::get`], this returns a raw pointer to the component,\r\n    /// which is only valid while the [`EntityWorldMut`] is alive.\r\n    #[inline]\r\n    pub fn get_by_id(&self, component_id: ComponentId) -> Option<Ptr<'_>> {\r\n        EntityRef::from(self).get_by_id(component_id)\r\n    }\r\n\r\n    /// Gets a [`MutUntyped`] of the component of the given [`ComponentId`] from the entity.\r\n    ///\r\n    /// **You should prefer to use the typed API [`EntityWorldMut::get_mut`] where possible and only\r\n    /// use this in cases where the actual component types are not known at\r\n    /// compile time.**\r\n    ///\r\n    /// Unlike [`EntityWorldMut::get_mut`], this returns a raw pointer to the component,\r\n    /// which is only valid while the [`EntityWorldMut`] is alive.\r\n    #[inline]\r\n    pub fn get_mut_by_id(&mut self, component_id: ComponentId) -> Option<MutUntyped<'_>> {\r\n        // SAFETY:\r\n        // - `&mut self` ensures that no references exist to this entity's components.\r\n        // - `as_unsafe_world_cell` gives mutable permission for all components on this entity\r\n        unsafe { self.as_unsafe_entity_cell().get_mut_by_id(component_id) }\r\n    }\r\n\r\n    /// Adds a [`Bundle`] of components to the entity.\r\n    ///\r\n    /// This will overwrite any previous value(s) of the same component type.\r\n    pub fn insert<T: Bundle>(&mut self, bundle: T) -> &mut Self {\r\n        let change_tick = self.world.change_tick();\r\n        let mut bundle_inserter =\r\n            BundleInserter::new::<T>(self.world, self.location.archetype_id, change_tick);\r\n        // SAFETY: location matches current entity. `T` matches `bundle_info`\r\n        self.location = unsafe { bundle_inserter.insert(self.entity, self.location, bundle) };\r\n        self\r\n    }\r\n\r\n    /// Inserts a dynamic [`Component`] into the entity.\r\n    ///\r\n    /// This will overwrite any previous value(s) of the same component type.\r\n    ///\r\n    /// You should prefer to use the typed API [`EntityWorldMut::insert`] where possible.\r\n    ///\r\n    /// # Safety\r\n    ///\r\n    /// - [`ComponentId`] must be from the same world as [`EntityWorldMut`]\r\n    /// - [`OwningPtr`] must be a valid reference to the type represented by [`ComponentId`]\r\n    pub unsafe fn insert_by_id(\r\n        &mut self,\r\n        component_id: ComponentId,\r\n        component: OwningPtr<'_>,\r\n    ) -> &mut Self {\r\n        let change_tick = self.world.change_tick();\r\n        let bundle_id = self\r\n            .world\r\n            .bundles\r\n            .init_component_info(&self.world.components, component_id);\r\n        let storage_type = self.world.bundles.get_storage_unchecked(bundle_id);\r\n\r\n        let bundle_inserter = BundleInserter::new_with_id(\r\n            self.world,\r\n            self.location.archetype_id,\r\n            bundle_id,\r\n            change_tick,\r\n        );\r\n\r\n        self.location = insert_dynamic_bundle(\r\n            bundle_inserter,\r\n            self.entity,\r\n            self.location,\r\n            Some(component).into_iter(),\r\n            Some(storage_type).iter().cloned(),\r\n        );\r\n        self\r\n    }\r\n\r\n    /// Inserts a dynamic [`Bundle`] into the entity.\r\n    ///\r\n    /// This will overwrite any previous value(s) of the same component type.\r\n    ///\r\n    /// You should prefer to use the typed API [`EntityWorldMut::insert`] where possible.\r\n    /// If your [`Bundle`] only has one component, use the cached API [`EntityWorldMut::insert_by_id`].\r\n    ///\r\n    /// If possible, pass a sorted slice of `ComponentId` to maximize caching potential.\r\n    ///\r\n    /// # Safety\r\n    /// - Each [`ComponentId`] must be from the same world as [`EntityWorldMut`]\r\n    /// - Each [`OwningPtr`] must be a valid reference to the type represented by [`ComponentId`]\r\n    pub unsafe fn insert_by_ids<'a, I: Iterator<Item = OwningPtr<'a>>>(\r\n        &mut self,\r\n        component_ids: &[ComponentId],\r\n        iter_components: I,\r\n    ) -> &mut Self {\r\n        let change_tick = self.world.change_tick();\r\n        let bundle_id = self\r\n            .world\r\n            .bundles\r\n            .init_dynamic_info(&self.world.components, component_ids);\r\n        let mut storage_types =\r\n            std::mem::take(self.world.bundles.get_storages_unchecked(bundle_id));\r\n        let bundle_inserter = BundleInserter::new_with_id(\r\n            self.world,\r\n            self.location.archetype_id,\r\n            bundle_id,\r\n            change_tick,\r\n        );\r\n\r\n        self.location = insert_dynamic_bundle(\r\n            bundle_inserter,\r\n            self.entity,\r\n            self.location,\r\n            iter_components,\r\n            (*storage_types).iter().cloned(),\r\n        );\r\n        *self.world.bundles.get_storages_unchecked(bundle_id) = std::mem::take(&mut storage_types);\r\n        self\r\n    }\r\n\r\n    /// Removes all components in the [`Bundle`] from the entity and returns their previous values.\r\n    ///\r\n    /// **Note:** If the entity does not have every component in the bundle, this method will not\r\n    /// remove any of them.\r\n    // TODO: BundleRemover?\r\n    #[must_use]\r\n    pub fn take<T: Bundle>(&mut self) -> Option<T> {\r\n        let world = &mut self.world;\r\n        let storages = &mut world.storages;\r\n        let components = &mut world.components;\r\n        let bundle_id = world.bundles.init_info::<T>(components, storages);\r\n        // SAFETY: We just ensured this bundle exists\r\n        let bundle_info = unsafe { world.bundles.get_unchecked(bundle_id) };\r\n        let old_location = self.location;\r\n        // SAFETY: `archetype_id` exists because it is referenced in the old `EntityLocation` which is valid,\r\n        // components exist in `bundle_info` because `Bundles::init_info` initializes a `BundleInfo` containing all components of the bundle type `T`\r\n        let new_archetype_id = unsafe {\r\n            remove_bundle_from_archetype(\r\n                &mut world.archetypes,\r\n                storages,\r\n                components,\r\n                old_location.archetype_id,\r\n                bundle_info,\r\n                false,\r\n            )?\r\n        };\r\n\r\n        if new_archetype_id == old_location.archetype_id {\r\n            return None;\r\n        }\r\n\r\n        let entity = self.entity;\r\n        // SAFETY: Archetypes and Bundles cannot be mutably aliased through DeferredWorld\r\n        let (old_archetype, bundle_info, mut deferred_world) = unsafe {\r\n            let bundle_info: *const BundleInfo = bundle_info;\r\n            let world = world.as_unsafe_world_cell();\r\n            (\r\n                &world.archetypes()[old_location.archetype_id],\r\n                &*bundle_info,\r\n                world.into_deferred(),\r\n            )\r\n        };\r\n\r\n        if old_archetype.has_on_remove() {\r\n            // SAFETY: All components in the archetype exist in world\r\n            unsafe {\r\n                deferred_world.trigger_on_remove(entity, bundle_info.iter_components());\r\n            }\r\n        }\r\n\r\n        let archetypes = &mut world.archetypes;\r\n        let storages = &mut world.storages;\r\n        let components = &mut world.components;\r\n        let entities = &mut world.entities;\r\n        let removed_components = &mut world.removed_components;\r\n\r\n        let entity = self.entity;\r\n        let mut bundle_components = bundle_info.iter_components();\r\n        // SAFETY: bundle components are iterated in order, which guarantees that the component type\r\n        // matches\r\n        let result = unsafe {\r\n            T::from_components(storages, &mut |storages| {\r\n                let component_id = bundle_components.next().unwrap();\r\n                // SAFETY:\r\n                // - entity location is valid\r\n                // - table row is removed below, without dropping the contents\r\n                // - `components` comes from the same world as `storages`\r\n                take_component(\r\n                    storages,\r\n                    components,\r\n                    removed_components,\r\n                    component_id,\r\n                    entity,\r\n                    old_location,\r\n                )\r\n            })\r\n        };\r\n\r\n        #[allow(clippy::undocumented_unsafe_blocks)] // TODO: document why this is safe\r\n        unsafe {\r\n            Self::move_entity_from_remove::<false>(\r\n                entity,\r\n                &mut self.location,\r\n                old_location.archetype_id,\r\n                old_location,\r\n                entities,\r\n                archetypes,\r\n                storages,\r\n                new_archetype_id,\r\n            );\r\n        }\r\n        Some(result)\r\n    }\r\n\r\n    /// # Safety\r\n    ///\r\n    /// `new_archetype_id` must have the same or a subset of the components\r\n    /// in `old_archetype_id`. Probably more safety stuff too, audit a call to\r\n    /// this fn as if the code here was written inline\r\n    ///\r\n    /// when DROP is true removed components will be dropped otherwise they will be forgotten\r\n    ///\r\n    // We use a const generic here so that we are less reliant on\r\n    // inlining for rustc to optimize out the `match DROP`\r\n    #[allow(clippy::too_many_arguments)]\r\n    unsafe fn move_entity_from_remove<const DROP: bool>(\r\n        entity: Entity,\r\n        self_location: &mut EntityLocation,\r\n        old_archetype_id: ArchetypeId,\r\n        old_location: EntityLocation,\r\n        entities: &mut Entities,\r\n        archetypes: &mut Archetypes,\r\n        storages: &mut Storages,\r\n        new_archetype_id: ArchetypeId,\r\n    ) {\r\n        let old_archetype = &mut archetypes[old_archetype_id];\r\n        let remove_result = old_archetype.swap_remove(old_location.archetype_row);\r\n        // if an entity was moved into this entity's archetype row, update its archetype row\r\n        if let Some(swapped_entity) = remove_result.swapped_entity {\r\n            let swapped_location = entities.get(swapped_entity).unwrap();\r\n\r\n            entities.set(\r\n                swapped_entity.index(),\r\n                EntityLocation {\r\n                    archetype_id: swapped_location.archetype_id,\r\n                    archetype_row: old_location.archetype_row,\r\n                    table_id: swapped_location.table_id,\r\n                    table_row: swapped_location.table_row,\r\n                },\r\n            );\r\n        }\r\n        let old_table_row = remove_result.table_row;\r\n        let old_table_id = old_archetype.table_id();\r\n        let new_archetype = &mut archetypes[new_archetype_id];\r\n\r\n        let new_location = if old_table_id == new_archetype.table_id() {\r\n            new_archetype.allocate(entity, old_table_row)\r\n        } else {\r\n            let (old_table, new_table) = storages\r\n                .tables\r\n                .get_2_mut(old_table_id, new_archetype.table_id());\r\n\r\n            let move_result = if DROP {\r\n                // SAFETY: old_table_row exists\r\n                unsafe { old_table.move_to_and_drop_missing_unchecked(old_table_row, new_table) }\r\n            } else {\r\n                // SAFETY: old_table_row exists\r\n                unsafe { old_table.move_to_and_forget_missing_unchecked(old_table_row, new_table) }\r\n            };\r\n\r\n            // SAFETY: move_result.new_row is a valid position in new_archetype's table\r\n            let new_location = unsafe { new_archetype.allocate(entity, move_result.new_row) };\r\n\r\n            // if an entity was moved into this entity's table row, update its table row\r\n            if let Some(swapped_entity) = move_result.swapped_entity {\r\n                let swapped_location = entities.get(swapped_entity).unwrap();\r\n\r\n                entities.set(\r\n                    swapped_entity.index(),\r\n                    EntityLocation {\r\n                        archetype_id: swapped_location.archetype_id,\r\n                        archetype_row: swapped_location.archetype_row,\r\n                        table_id: swapped_location.table_id,\r\n                        table_row: old_location.table_row,\r\n                    },\r\n                );\r\n                archetypes[swapped_location.archetype_id]\r\n                    .set_entity_table_row(swapped_location.archetype_row, old_table_row);\r\n            }\r\n\r\n            new_location\r\n        };\r\n\r\n        *self_location = new_location;\r\n        // SAFETY: The entity is valid and has been moved to the new location already.\r\n        unsafe {\r\n            entities.set(entity.index(), new_location);\r\n        }\r\n    }\r\n\r\n    /// Remove the components of `bundle` from `entity`.\r\n    ///\r\n    /// SAFETY: The components in `bundle_info` must exist.\r\n    #[allow(clippy::too_many_arguments)]\r\n    unsafe fn remove_bundle(&mut self, bundle: BundleId) -> EntityLocation {\r\n        let entity = self.entity;\r\n        let world = &mut self.world;\r\n        let location = self.location;\r\n        let bundle_info = world.bundles.get_unchecked(bundle);\r\n\r\n        // SAFETY: `archetype_id` exists because it is referenced in `location` which is valid\r\n        // and components in `bundle_info` must exist due to this functions safety invariants.\r\n        let new_archetype_id = remove_bundle_from_archetype(\r\n            &mut world.archetypes,\r\n            &mut world.storages,\r\n            &world.components,\r\n            location.archetype_id,\r\n            bundle_info,\r\n            true,\r\n        )\r\n        .expect(\"intersections should always return a result\");\r\n\r\n        if new_archetype_id == location.archetype_id {\r\n            return location;\r\n        }\r\n\r\n        // SAFETY: Archetypes and Bundles cannot be mutably aliased through DeferredWorld\r\n        let (old_archetype, bundle_info, mut deferred_world) = unsafe {\r\n            let bundle_info: *const BundleInfo = bundle_info;\r\n            let world = world.as_unsafe_world_cell();\r\n            (\r\n                &world.archetypes()[location.archetype_id],\r\n                &*bundle_info,\r\n                world.into_deferred(),\r\n            )\r\n        };\r\n\r\n        if old_archetype.has_on_remove() {\r\n            // SAFETY: All components in the archetype exist in world\r\n            unsafe {\r\n                deferred_world.trigger_on_remove(entity, bundle_info.iter_components());\r\n            }\r\n        }\r\n\r\n        let old_archetype = &world.archetypes[location.archetype_id];\r\n        for component_id in bundle_info.iter_components() {\r\n            if old_archetype.contains(component_id) {\r\n                world.removed_components.send(component_id, entity);\r\n\r\n                // Make sure to drop components stored in sparse sets.\r\n                // Dense components are dropped later in `move_to_and_drop_missing_unchecked`.\r\n                if let Some(StorageType::SparseSet) = old_archetype.get_storage_type(component_id) {\r\n                    world\r\n                        .storages\r\n                        .sparse_sets\r\n                        .get_mut(component_id)\r\n                        .unwrap()\r\n                        .remove(entity);\r\n                }\r\n            }\r\n        }\r\n\r\n        // SAFETY: `new_archetype_id` is a subset of the components in `old_location.archetype_id`\r\n        // because it is created by removing a bundle from these components.\r\n        let mut new_location = location;\r\n        Self::move_entity_from_remove::<true>(\r\n            entity,\r\n            &mut new_location,\r\n            location.archetype_id,\r\n            location,\r\n            &mut world.entities,\r\n            &mut world.archetypes,\r\n            &mut world.storages,\r\n            new_archetype_id,\r\n        );\r\n\r\n        new_location\r\n    }\r\n\r\n    /// Removes any components in the [`Bundle`] from the entity.\r\n    ///\r\n    /// See [`EntityCommands::remove`](crate::system::EntityCommands::remove) for more details.\r\n    // TODO: BundleRemover?\r\n    pub fn remove<T: Bundle>(&mut self) -> &mut Self {\r\n        let storages = &mut self.world.storages;\r\n        let components = &mut self.world.components;\r\n        let bundle_info = self.world.bundles.init_info::<T>(components, storages);\r\n\r\n        // SAFETY: Components exist in `bundle_info` because `Bundles::init_info`\r\n        // initializes a: EntityLocation `BundleInfo` containing all components of the bundle type `T`.\r\n        self.location = unsafe { self.remove_bundle(bundle_info) };\r\n\r\n        self\r\n    }\r\n\r\n    /// Removes any components except those in the [`Bundle`] from the entity.\r\n    ///\r\n    /// See [`EntityCommands::retain`](crate::system::EntityCommands::retain) for more details.\r\n    pub fn retain<T: Bundle>(&mut self) -> &mut Self {\r\n        let archetypes = &mut self.world.archetypes;\r\n        let storages = &mut self.world.storages;\r\n        let components = &mut self.world.components;\r\n\r\n        let retained_bundle = self.world.bundles.init_info::<T>(components, storages);\r\n        // SAFETY: `retained_bundle` exists as we just initialized it.\r\n        let retained_bundle_info = unsafe { self.world.bundles.get_unchecked(retained_bundle) };\r\n        let old_location = self.location;\r\n        let old_archetype = &mut archetypes[old_location.archetype_id];\r\n\r\n        let to_remove = &old_archetype\r\n            .components()\r\n            .filter(|c| !retained_bundle_info.components().contains(c))\r\n            .collect::<Vec<_>>();\r\n        let remove_bundle = self.world.bundles.init_dynamic_info(components, to_remove);\r\n\r\n        // SAFETY: Components exist in `remove_bundle` because `Bundles::init_dynamic_info`\r\n        // initializes a `BundleInfo` containing all components in the to_remove Bundle.\r\n        self.location = unsafe { self.remove_bundle(remove_bundle) };\r\n        self\r\n    }\r\n\r\n    /// Despawns the current entity.\r\n    ///\r\n    /// See [`World::despawn`] for more details.\r\n    pub fn despawn(self) {\r\n        let world = self.world;\r\n        world.flush_entities();\r\n        let archetype = &world.archetypes[self.location.archetype_id];\r\n\r\n        // SAFETY: Archetype cannot be mutably aliased by DeferredWorld\r\n        let (archetype, mut deferred_world) = unsafe {\r\n            let archetype: *const Archetype = archetype;\r\n            let world = world.as_unsafe_world_cell();\r\n            (&*archetype, world.into_deferred())\r\n        };\r\n\r\n        if archetype.has_on_remove() {\r\n            // SAFETY: All components in the archetype exist in world\r\n            unsafe {\r\n                deferred_world.trigger_on_remove(self.entity, archetype.components());\r\n            }\r\n        }\r\n\r\n        for component_id in archetype.components() {\r\n            world.removed_components.send(component_id, self.entity);\r\n        }\r\n\r\n        let location = world\r\n            .entities\r\n            .free(self.entity)\r\n            .expect(\"entity should exist at this point.\");\r\n        let table_row;\r\n        let moved_entity;\r\n\r\n        {\r\n            let archetype = &mut world.archetypes[self.location.archetype_id];\r\n            let remove_result = archetype.swap_remove(location.archetype_row);\r\n            if let Some(swapped_entity) = remove_result.swapped_entity {\r\n                let swapped_location = world.entities.get(swapped_entity).unwrap();\r\n                // SAFETY: swapped_entity is valid and the swapped entity's components are\r\n                // moved to the new location immediately after.\r\n                unsafe {\r\n                    world.entities.set(\r\n                        swapped_entity.index(),\r\n                        EntityLocation {\r\n                            archetype_id: swapped_location.archetype_id,\r\n                            archetype_row: location.archetype_row,\r\n                            table_id: swapped_location.table_id,\r\n                            table_row: swapped_location.table_row,\r\n                        },\r\n                    );\r\n                }\r\n            }\r\n            table_row = remove_result.table_row;\r\n\r\n            for component_id in archetype.sparse_set_components() {\r\n                let sparse_set = world.storages.sparse_sets.get_mut(component_id).unwrap();\r\n                sparse_set.remove(self.entity);\r\n            }\r\n            // SAFETY: table rows stored in archetypes always exist\r\n            moved_entity = unsafe {\r\n                world.storages.tables[archetype.table_id()].swap_remove_unchecked(table_row)\r\n            };\r\n        };\r\n\r\n        if let Some(moved_entity) = moved_entity {\r\n            let moved_location = world.entities.get(moved_entity).unwrap();\r\n            // SAFETY: `moved_entity` is valid and the provided `EntityLocation` accurately reflects\r\n            //         the current location of the entity and its component data.\r\n            unsafe {\r\n                world.entities.set(\r\n                    moved_entity.index(),\r\n                    EntityLocation {\r\n                        archetype_id: moved_location.archetype_id,\r\n                        archetype_row: moved_location.archetype_row,\r\n                        table_id: moved_location.table_id,\r\n                        table_row,\r\n                    },\r\n                );\r\n            }\r\n            world.archetypes[moved_location.archetype_id]\r\n                .set_entity_table_row(moved_location.archetype_row, table_row);\r\n        }\r\n        world.flush_commands();\r\n    }\r\n\r\n    /// Ensures any commands triggered by the actions of Self are applied, equivalent to [`World::flush_commands`]\r\n    pub fn flush(self) -> Entity {\r\n        self.world.flush_commands();\r\n        self.entity\r\n    }\r\n\r\n    /// Gets read-only access to the world that the current entity belongs to.\r\n    #[inline]\r\n    pub fn world(&self) -> &World {\r\n        self.world\r\n    }\r\n\r\n    /// Returns this entity's world.\r\n    ///\r\n    /// See [`EntityWorldMut::world_scope`] or [`EntityWorldMut::into_world_mut`] for a safe alternative.\r\n    ///\r\n    /// # Safety\r\n    /// Caller must not modify the world in a way that changes the current entity's location\r\n    /// If the caller _does_ do something that could change the location, `self.update_location()`\r\n    /// must be called before using any other methods on this [`EntityWorldMut`].\r\n    #[inline]\r\n    pub unsafe fn world_mut(&mut self) -> &mut World {\r\n        self.world\r\n    }\r\n\r\n    /// Returns this entity's [`World`], consuming itself.\r\n    #[inline]\r\n    pub fn into_world_mut(self) -> &'w mut World {\r\n        self.world\r\n    }\r\n\r\n    /// Gives mutable access to this entity's [`World`] in a temporary scope.\r\n    /// This is a safe alternative to using [`EntityWorldMut::world_mut`].\r\n    ///\r\n    /// # Examples\r\n    ///\r\n    /// ```\r\n    /// # use bevy_ecs::prelude::*;\r\n    /// #[derive(Resource, Default, Clone, Copy)]\r\n    /// struct R(u32);\r\n    ///\r\n    /// # let mut world = World::new();\r\n    /// # world.init_resource::<R>();\r\n    /// # let mut entity = world.spawn_empty();\r\n    /// // This closure gives us temporary access to the world.\r\n    /// let new_r = entity.world_scope(|world: &mut World| {\r\n    ///     // Mutate the world while we have access to it.\r\n    ///     let mut r = world.resource_mut::<R>();\r\n    ///     r.0 += 1;\r\n    ///\r\n    ///     // Return a value from the world before giving it back to the `EntityWorldMut`.\r\n    ///     *r\r\n    /// });\r\n    /// # assert_eq!(new_r.0, 1);\r\n    /// ```\r\n    pub fn world_scope<U>(&mut self, f: impl FnOnce(&mut World) -> U) -> U {\r\n        struct Guard<'w, 'a> {\r\n            entity_mut: &'a mut EntityWorldMut<'w>,\r\n        }\r\n\r\n        impl Drop for Guard<'_, '_> {\r\n            #[inline]\r\n            fn drop(&mut self) {\r\n                self.entity_mut.update_location();\r\n            }\r\n        }\r\n\r\n        // When `guard` is dropped at the end of this scope,\r\n        // it will update the cached `EntityLocation` for this instance.\r\n        // This will run even in case the closure `f` unwinds.\r\n        let guard = Guard { entity_mut: self };\r\n        f(guard.entity_mut.world)\r\n    }\r\n\r\n    /// Updates the internal entity location to match the current location in the internal\r\n    /// [`World`].\r\n    ///\r\n    /// This is *only* required when using the unsafe function [`EntityWorldMut::world_mut`],\r\n    /// which enables the location to change.\r\n    pub fn update_location(&mut self) {\r\n        self.location = self.world.entities().get(self.entity).unwrap();\r\n    }\r\n\r\n    /// Gets an Entry into the world for this entity and component for in-place manipulation.\r\n    ///\r\n    /// The type parameter specifies which component to get.\r\n    ///\r\n    /// # Examples\r\n    ///\r\n    /// ```\r\n    /// # use bevy_ecs::prelude::*;\r\n    /// #[derive(Component, Default, Clone, Copy, Debug, PartialEq)]\r\n    /// struct Comp(u32);\r\n    ///\r\n    /// # let mut world = World::new();\r\n    /// let mut entity = world.spawn_empty();\r\n    /// entity.entry().or_insert_with(|| Comp(4));\r\n    /// # let entity_id = entity.id();\r\n    /// assert_eq!(world.query::<&Comp>().single(&world).0, 4);\r\n    ///\r\n    /// # let mut entity = world.get_entity_mut(entity_id).unwrap();\r\n    /// entity.entry::<Comp>().and_modify(|mut c| c.0 += 1);\r\n    /// assert_eq!(world.query::<&Comp>().single(&world).0, 5);\r\n    ///\r\n    /// ```\r\n    pub fn entry<'a, T: Component>(&'a mut self) -> Entry<'w, 'a, T> {\r\n        if self.contains::<T>() {\r\n            Entry::Occupied(OccupiedEntry {\r\n                entity_world: self,\r\n                _marker: PhantomData,\r\n            })\r\n        } else {\r\n            Entry::Vacant(VacantEntry {\r\n                entity_world: self,\r\n                _marker: PhantomData,\r\n            })\r\n        }\r\n    }\r\n}\r\n\r\n/// A view into a single entity and component in a world, which may either be vacant or occupied.\r\n///\r\n/// This `enum` can only be constructed from the [`entry`] method on [`EntityWorldMut`].\r\n///\r\n/// [`entry`]: EntityWorldMut::entry\r\npub enum Entry<'w, 'a, T: Component> {\r\n    /// An occupied entry.\r\n    Occupied(OccupiedEntry<'w, 'a, T>),\r\n    /// A vacant entry.\r\n    Vacant(VacantEntry<'w, 'a, T>),\r\n}\r\n\r\nimpl<'w, 'a, T: Component> Entry<'w, 'a, T> {\r\n    /// Provides in-place mutable access to an occupied entry.\r\n    ///\r\n    /// # Examples\r\n    ///\r\n    /// ```\r\n    /// # use bevy_ecs::prelude::*;\r\n    /// #[derive(Component, Default, Clone, Copy, Debug, PartialEq)]\r\n    /// struct Comp(u32);\r\n    ///\r\n    /// # let mut world = World::new();\r\n    /// let mut entity = world.spawn(Comp(0));\r\n    ///\r\n    /// entity.entry::<Comp>().and_modify(|mut c| c.0 += 1);\r\n    /// assert_eq!(world.query::<&Comp>().single(&world).0, 1);\r\n    /// ```\r\n    #[inline]\r\n    pub fn and_modify<F: FnOnce(Mut<'_, T>)>(self, f: F) -> Self {\r\n        match self {\r\n            Entry::Occupied(mut entry) => {\r\n                f(entry.get_mut());\r\n                Entry::Occupied(entry)\r\n            }\r\n            Entry::Vacant(entry) => Entry::Vacant(entry),\r\n        }\r\n    }\r\n\r\n    /// Replaces the component of the entry, and returns an [`OccupiedEntry`].\r\n    ///\r\n    /// # Examples\r\n    ///\r\n    /// ```\r\n    /// # use bevy_ecs::prelude::*;\r\n    /// #[derive(Component, Default, Clone, Copy, Debug, PartialEq)]\r\n    /// struct Comp(u32);\r\n    ///\r\n    /// # let mut world = World::new();\r\n    /// let mut entity = world.spawn_empty();\r\n    ///\r\n    /// let entry = entity.entry().insert_entry(Comp(4));\r\n    /// assert_eq!(entry.get(), &Comp(4));\r\n    ///\r\n    /// let entry = entity.entry().insert_entry(Comp(2));\r\n    /// assert_eq!(entry.get(), &Comp(2));\r\n    /// ```\r\n    #[inline]\r\n    pub fn insert_entry(self, component: T) -> OccupiedEntry<'w, 'a, T> {\r\n        match self {\r\n            Entry::Occupied(mut entry) => {\r\n                entry.insert(component);\r\n                entry\r\n            }\r\n            Entry::Vacant(entry) => entry.insert_entry(component),\r\n        }\r\n    }\r\n\r\n    /// Ensures the entry has this component by inserting the given default if empty, and\r\n    /// returns a mutable reference to this component in the entry.\r\n    ///\r\n    /// # Examples\r\n    ///\r\n    /// ```\r\n    /// # use bevy_ecs::prelude::*;\r\n    /// #[derive(Component, Default, Clone, Copy, Debug, PartialEq)]\r\n    /// struct Comp(u32);\r\n    ///\r\n    /// # let mut world = World::new();\r\n    /// let mut entity = world.spawn_empty();\r\n    ///\r\n    /// entity.entry().or_insert(Comp(4));\r\n    /// # let entity_id = entity.id();\r\n    /// assert_eq!(world.query::<&Comp>().single(&world).0, 4);\r\n    ///\r\n    /// # let mut entity = world.get_entity_mut(entity_id).unwrap();\r\n    /// entity.entry().or_insert(Comp(15)).0 *= 2;\r\n    /// assert_eq!(world.query::<&Comp>().single(&world).0, 8);\r\n    /// ```\r\n    #[inline]\r\n    pub fn or_insert(self, default: T) -> Mut<'a, T> {\r\n        match self {\r\n            Entry::Occupied(entry) => entry.into_mut(),\r\n            Entry::Vacant(entry) => entry.insert(default),\r\n        }\r\n    }\r\n\r\n    /// Ensures the entry has this component by inserting the result of the default function if\r\n    /// empty, and returns a mutable reference to this component in the entry.\r\n    ///\r\n    /// # Examples\r\n    ///\r\n    /// ```\r\n    /// # use bevy_ecs::prelude::*;\r\n    /// #[derive(Component, Default, Clone, Copy, Debug, PartialEq)]\r\n    /// struct Comp(u32);\r\n    ///\r\n    /// # let mut world = World::new();\r\n    /// let mut entity = world.spawn_empty();\r\n    ///\r\n    /// entity.entry().or_insert_with(|| Comp(4));\r\n    /// assert_eq!(world.query::<&Comp>().single(&world).0, 4);\r\n    /// ```\r\n    #[inline]\r\n    pub fn or_insert_with<F: FnOnce() -> T>(self, default: F) -> Mut<'a, T> {\r\n        match self {\r\n            Entry::Occupied(entry) => entry.into_mut(),\r\n            Entry::Vacant(entry) => entry.insert(default()),\r\n        }\r\n    }\r\n}\r\n\r\nimpl<'w, 'a, T: Component + Default> Entry<'w, 'a, T> {\r\n    /// Ensures the entry has this component by inserting the default value if empty, and\r\n    /// returns a mutable reference to this component in the entry.\r\n    ///\r\n    /// # Examples\r\n    ///\r\n    /// ```\r\n    /// # use bevy_ecs::prelude::*;\r\n    /// #[derive(Component, Default, Clone, Copy, Debug, PartialEq)]\r\n    /// struct Comp(u32);\r\n    ///\r\n    /// # let mut world = World::new();\r\n    /// let mut entity = world.spawn_empty();\r\n    ///\r\n    /// entity.entry::<Comp>().or_default();\r\n    /// assert_eq!(world.query::<&Comp>().single(&world).0, 0);\r\n    /// ```\r\n    #[inline]\r\n    pub fn or_default(self) -> Mut<'a, T> {\r\n        match self {\r\n            Entry::Occupied(entry) => entry.into_mut(),\r\n            Entry::Vacant(entry) => entry.insert(Default::default()),\r\n        }\r\n    }\r\n}\r\n\r\n/// A view into an occupied entry in a [`EntityWorldMut`]. It is part of the [`Entry`] enum.\r\n///\r\n/// The contained entity must have the component type parameter if we have this struct.\r\npub struct OccupiedEntry<'w, 'a, T: Component> {\r\n    entity_world: &'a mut EntityWorldMut<'w>,\r\n    _marker: PhantomData<T>,\r\n}\r\n\r\nimpl<'w, 'a, T: Component> OccupiedEntry<'w, 'a, T> {\r\n    /// Gets a reference to the component in the entry.\r\n    ///\r\n    /// # Examples\r\n    ///\r\n    /// ```\r\n    /// # use bevy_ecs::{prelude::*, world::Entry};\r\n    /// #[derive(Component, Default, Clone, Copy, Debug, PartialEq)]\r\n    /// struct Comp(u32);\r\n    ///\r\n    /// # let mut world = World::new();\r\n    /// let mut entity = world.spawn(Comp(5));\r\n    ///\r\n    /// if let Entry::Occupied(o) = entity.entry::<Comp>() {\r\n    ///     assert_eq!(o.get().0, 5);\r\n    /// }\r\n    /// ```\r\n    #[inline]\r\n    pub fn get(&self) -> &T {\r\n        // This shouldn't panic because if we have an OccupiedEntry the component must exist.\r\n        self.entity_world.get::<T>().unwrap()\r\n    }\r\n\r\n    /// Gets a mutable reference to the component in the entry.\r\n    ///\r\n    /// If you need a reference to the `OccupiedEntry` which may outlive the destruction of\r\n    /// the `Entry` value, see [`into_mut`].\r\n    ///\r\n    /// [`into_mut`]: Self::into_mut\r\n    ///\r\n    /// # Examples\r\n    ///\r\n    /// ```\r\n    /// # use bevy_ecs::{prelude::*, world::Entry};\r\n    /// #[derive(Component, Default, Clone, Copy, Debug, PartialEq)]\r\n    /// struct Comp(u32);\r\n    ///\r\n    /// # let mut world = World::new();\r\n    /// let mut entity = world.spawn(Comp(5));\r\n    ///\r\n    /// if let Entry::Occupied(mut o) = entity.entry::<Comp>() {\r\n    ///     o.get_mut().0 += 10;\r\n    ///     assert_eq!(o.get().0, 15);\r\n    ///\r\n    ///     // We can use the same Entry multiple times.\r\n    ///     o.get_mut().0 += 2\r\n    /// }\r\n    ///\r\n    /// assert_eq!(world.query::<&Comp>().single(&world).0, 17);\r\n    /// ```\r\n    #[inline]\r\n    pub fn get_mut(&mut self) -> Mut<'_, T> {\r\n        // This shouldn't panic because if we have an OccupiedEntry the component must exist.\r\n        self.entity_world.get_mut::<T>().unwrap()\r\n    }\r\n\r\n    /// Converts the `OccupiedEntry` into a mutable reference to the value in the entry with\r\n    /// a lifetime bound to the `EntityWorldMut`.\r\n    ///\r\n    /// If you need multiple references to the `OccupiedEntry`, see [`get_mut`].\r\n    ///\r\n    /// [`get_mut`]: Self::get_mut\r\n    ///\r\n    /// # Examples\r\n    ///\r\n    /// ```\r\n    /// # use bevy_ecs::{prelude::*, world::Entry};\r\n    /// #[derive(Component, Default, Clone, Copy, Debug, PartialEq)]\r\n    /// struct Comp(u32);\r\n    ///\r\n    /// # let mut world = World::new();\r\n    /// let mut entity = world.spawn(Comp(5));\r\n    ///\r\n    /// if let Entry::Occupied(o) = entity.entry::<Comp>() {\r\n    ///     o.into_mut().0 += 10;\r\n    /// }\r\n    ///\r\n    /// assert_eq!(world.query::<&Comp>().single(&world).0, 15);\r\n    /// ```\r\n    #[inline]\r\n    pub fn into_mut(self) -> Mut<'a, T> {\r\n        // This shouldn't panic because if we have an OccupiedEntry the component must exist.\r\n        self.entity_world.get_mut().unwrap()\r\n    }\r\n\r\n    /// Replaces the component of the entry.\r\n    ///\r\n    /// # Examples\r\n    ///\r\n    /// ```\r\n    /// # use bevy_ecs::{prelude::*, world::Entry};\r\n    /// #[derive(Component, Default, Clone, Copy, Debug, PartialEq)]\r\n    /// struct Comp(u32);\r\n    ///\r\n    /// # let mut world = World::new();\r\n    /// let mut entity = world.spawn(Comp(5));\r\n    ///\r\n    /// if let Entry::Occupied(mut o) = entity.entry::<Comp>() {\r\n    ///     o.insert(Comp(10));\r\n    /// }\r\n    ///\r\n    /// assert_eq!(world.query::<&Comp>().single(&world).0, 10);\r\n    /// ```\r\n    #[inline]\r\n    pub fn insert(&mut self, component: T) {\r\n        self.entity_world.insert(component);\r\n    }\r\n\r\n    /// Removes the component from the entry and returns it.\r\n    ///\r\n    /// # Examples\r\n    ///\r\n    /// ```\r\n    /// # use bevy_ecs::{prelude::*, world::Entry};\r\n    /// #[derive(Component, Default, Clone, Copy, Debug, PartialEq)]\r\n    /// struct Comp(u32);\r\n    ///\r\n    /// # let mut world = World::new();\r\n    /// let mut entity = world.spawn(Comp(5));\r\n    ///\r\n    /// if let Entry::Occupied(o) = entity.entry::<Comp>() {\r\n    ///     assert_eq!(o.take(), Comp(5));\r\n    /// }\r\n    ///\r\n    /// assert_eq!(world.query::<&Comp>().iter(&world).len(), 0);\r\n    /// ```\r\n    #[inline]\r\n    pub fn take(self) -> T {\r\n        // This shouldn't panic because if we have an OccupiedEntry the component must exist.\r\n        self.entity_world.take().unwrap()\r\n    }\r\n}\r\n\r\n/// A view into a vacant entry in a [`EntityWorldMut`]. It is part of the [`Entry`] enum.\r\npub struct VacantEntry<'w, 'a, T: Component> {\r\n    entity_world: &'a mut EntityWorldMut<'w>,\r\n    _marker: PhantomData<T>,\r\n}\r\n\r\nimpl<'w, 'a, T: Component> VacantEntry<'w, 'a, T> {\r\n    /// Inserts the component into the `VacantEntry` and returns a mutable reference to it.\r\n    ///\r\n    /// # Examples\r\n    ///\r\n    /// ```\r\n    /// # use bevy_ecs::{prelude::*, world::Entry};\r\n    /// #[derive(Component, Default, Clone, Copy, Debug, PartialEq)]\r\n    /// struct Comp(u32);\r\n    ///\r\n    /// # let mut world = World::new();\r\n    /// let mut entity = world.spawn_empty();\r\n    ///\r\n    /// if let Entry::Vacant(v) = entity.entry::<Comp>() {\r\n    ///     v.insert(Comp(10));\r\n    /// }\r\n    ///\r\n    /// assert_eq!(world.query::<&Comp>().single(&world).0, 10);\r\n    /// ```\r\n    #[inline]\r\n    pub fn insert(self, component: T) -> Mut<'a, T> {\r\n        self.entity_world.insert(component);\r\n        // This shouldn't panic because we just added this component\r\n        self.entity_world.get_mut::<T>().unwrap()\r\n    }\r\n\r\n    /// Inserts the component into the `VacantEntry` and returns an `OccupiedEntry`.\r\n    ///\r\n    /// # Examples\r\n    ///\r\n    /// ```\r\n    /// # use bevy_ecs::{prelude::*, world::Entry};\r\n    /// #[derive(Component, Default, Clone, Copy, Debug, PartialEq)]\r\n    /// struct Comp(u32);\r\n    ///\r\n    /// # let mut world = World::new();\r\n    /// let mut entity = world.spawn_empty();\r\n    ///\r\n    /// if let Entry::Vacant(v) = entity.entry::<Comp>() {\r\n    ///     v.insert_entry(Comp(10));\r\n    /// }\r\n    ///\r\n    /// assert_eq!(world.query::<&Comp>().single(&world).0, 10);\r\n    /// ```\r\n    #[inline]\r\n    pub fn insert_entry(self, component: T) -> OccupiedEntry<'w, 'a, T> {\r\n        self.entity_world.insert(component);\r\n        OccupiedEntry {\r\n            entity_world: self.entity_world,\r\n            _marker: PhantomData,\r\n        }\r\n    }\r\n}\r\n\r\n/// Provides read-only access to a single entity and some of its components defined by the contained [`Access`].\r\n#[derive(Clone)]\r\npub struct FilteredEntityRef<'w> {\r\n    entity: UnsafeEntityCell<'w>,\r\n    access: Access<ComponentId>,\r\n}\r\n\r\nimpl<'w> FilteredEntityRef<'w> {\r\n    /// # Safety\r\n    /// - No `&mut World` can exist from the underlying `UnsafeWorldCell`\r\n    /// - If `access` takes read access to a component no mutable reference to that\r\n    /// component can exist at the same time as the returned [`FilteredEntityMut`]\r\n    /// - If `access` takes any access for a component `entity` must have that component.\r\n    pub(crate) unsafe fn new(entity: UnsafeEntityCell<'w>, access: Access<ComponentId>) -> Self {\r\n        Self { entity, access }\r\n    }\r\n\r\n    /// Returns the [ID](Entity) of the current entity.\r\n    #[inline]\r\n    #[must_use = \"Omit the .id() call if you do not need to store the `Entity` identifier.\"]\r\n    pub fn id(&self) -> Entity {\r\n        self.entity.id()\r\n    }\r\n\r\n    /// Gets metadata indicating the location where the current entity is stored.\r\n    #[inline]\r\n    pub fn location(&self) -> EntityLocation {\r\n        self.entity.location()\r\n    }\r\n\r\n    /// Returns the archetype that the current entity belongs to.\r\n    #[inline]\r\n    pub fn archetype(&self) -> &Archetype {\r\n        self.entity.archetype()\r\n    }\r\n\r\n    /// Returns an iterator over the component ids that are accessed by self.\r\n    #[inline]\r\n    pub fn components(&self) -> impl Iterator<Item = ComponentId> + '_ {\r\n        self.access.reads_and_writes()\r\n    }\r\n\r\n    /// Returns a reference to the underlying [`Access`].\r\n    #[inline]\r\n    pub fn access(&self) -> &Access<ComponentId> {\r\n        &self.access\r\n    }\r\n\r\n    /// Returns `true` if the current entity has a component of type `T`.\r\n    /// Otherwise, this returns `false`.\r\n    ///\r\n    /// ## Notes\r\n    ///\r\n    /// If you do not know the concrete type of a component, consider using\r\n    /// [`Self::contains_id`] or [`Self::contains_type_id`].\r\n    #[inline]\r\n    pub fn contains<T: Component>(&self) -> bool {\r\n        self.contains_type_id(TypeId::of::<T>())\r\n    }\r\n\r\n    /// Returns `true` if the current entity has a component identified by `component_id`.\r\n    /// Otherwise, this returns false.\r\n    ///\r\n    /// ## Notes\r\n    ///\r\n    /// - If you know the concrete type of the component, you should prefer [`Self::contains`].\r\n    /// - If you know the component's [`TypeId`] but not its [`ComponentId`], consider using\r\n    /// [`Self::contains_type_id`].\r\n    #[inline]\r\n    pub fn contains_id(&self, component_id: ComponentId) -> bool {\r\n        self.entity.contains_id(component_id)\r\n    }\r\n\r\n    /// Returns `true` if the current entity has a component with the type identified by `type_id`.\r\n    /// Otherwise, this returns false.\r\n    ///\r\n    /// ## Notes\r\n    ///\r\n    /// - If you know the concrete type of the component, you should prefer [`Self::contains`].\r\n    /// - If you have a [`ComponentId`] instead of a [`TypeId`], consider using [`Self::contains_id`].\r\n    #[inline]\r\n    pub fn contains_type_id(&self, type_id: TypeId) -> bool {\r\n        self.entity.contains_type_id(type_id)\r\n    }\r\n\r\n    /// Gets access to the component of type `T` for the current entity.\r\n    /// Returns `None` if the entity does not have a component of type `T`.\r\n    #[inline]\r\n    pub fn get<T: Component>(&self) -> Option<&'w T> {\r\n        let id = self.entity.world().components().get_id(TypeId::of::<T>())?;\r\n        self.access\r\n            .has_read(id)\r\n            // SAFETY: We have read access so we must have the component\r\n            .then(|| unsafe { self.entity.get().debug_checked_unwrap() })\r\n    }\r\n\r\n    /// Gets access to the component of type `T` for the current entity,\r\n    /// including change detection information as a [`Ref`].\r\n    ///\r\n    /// Returns `None` if the entity does not have a component of type `T`.\r\n    #[inline]\r\n    pub fn get_ref<T: Component>(&self) -> Option<Ref<'w, T>> {\r\n        let id = self.entity.world().components().get_id(TypeId::of::<T>())?;\r\n        self.access\r\n            .has_read(id)\r\n            // SAFETY: We have read access so we must have the component\r\n            .then(|| unsafe { self.entity.get_ref().debug_checked_unwrap() })\r\n    }\r\n\r\n    /// Retrieves the change ticks for the given component. This can be useful for implementing change\r\n    /// detection in custom runtimes.\r\n    #[inline]\r\n    pub fn get_change_ticks<T: Component>(&self) -> Option<ComponentTicks> {\r\n        let id = self.entity.world().components().get_id(TypeId::of::<T>())?;\r\n        self.access\r\n            .has_read(id)\r\n            // SAFETY: We have read access so we must have the component\r\n            .then(|| unsafe { self.entity.get_change_ticks::<T>().debug_checked_unwrap() })\r\n    }\r\n\r\n    /// Retrieves the change ticks for the given [`ComponentId`]. This can be useful for implementing change\r\n    /// detection in custom runtimes.\r\n    ///\r\n    /// **You should prefer to use the typed API [`Self::get_change_ticks`] where possible and only\r\n    /// use this in cases where the actual component types are not known at\r\n    /// compile time.**\r\n    #[inline]\r\n    pub fn get_change_ticks_by_id(&self, component_id: ComponentId) -> Option<ComponentTicks> {\r\n        // SAFETY: We have read access so we must have the component\r\n        self.access.has_read(component_id).then(|| unsafe {\r\n            self.entity\r\n                .get_change_ticks_by_id(component_id)\r\n                .debug_checked_unwrap()\r\n        })\r\n    }\r\n\r\n    /// Gets the component of the given [`ComponentId`] from the entity.\r\n    ///\r\n    /// **You should prefer to use the typed API [`Self::get`] where possible and only\r\n    /// use this in cases where the actual component types are not known at\r\n    /// compile time.**\r\n    ///\r\n    /// Unlike [`FilteredEntityRef::get`], this returns a raw pointer to the component,\r\n    /// which is only valid while the [`FilteredEntityRef`] is alive.\r\n    #[inline]\r\n    pub fn get_by_id(&self, component_id: ComponentId) -> Option<Ptr<'w>> {\r\n        self.access\r\n            .has_read(component_id)\r\n            // SAFETY: We have read access so we must have the component\r\n            .then(|| unsafe { self.entity.get_by_id(component_id).debug_checked_unwrap() })\r\n    }\r\n}\r\n\r\nimpl<'w> From<FilteredEntityMut<'w>> for FilteredEntityRef<'w> {\r\n    fn from(entity_mut: FilteredEntityMut<'w>) -> Self {\r\n        // SAFETY:\r\n        // - `FilteredEntityMut` guarantees exclusive access to all components in the new `FilteredEntityRef`.\r\n        unsafe { FilteredEntityRef::new(entity_mut.entity, entity_mut.access) }\r\n    }\r\n}\r\n\r\nimpl<'a> From<&'a FilteredEntityMut<'_>> for FilteredEntityRef<'a> {\r\n    fn from(entity_mut: &'a FilteredEntityMut<'_>) -> Self {\r\n        // SAFETY:\r\n        // - `FilteredEntityMut` guarantees exclusive access to all components in the new `FilteredEntityRef`.\r\n        unsafe { FilteredEntityRef::new(entity_mut.entity, entity_mut.access.clone()) }\r\n    }\r\n}\r\n\r\nimpl<'a> From<EntityRef<'a>> for FilteredEntityRef<'a> {\r\n    fn from(entity: EntityRef<'a>) -> Self {\r\n        // SAFETY:\r\n        // - `EntityRef` guarantees exclusive access to all components in the new `FilteredEntityRef`.\r\n        unsafe {\r\n            let mut access = Access::default();\r\n            access.read_all();\r\n            FilteredEntityRef::new(entity.0, access)\r\n        }\r\n    }\r\n}\r\n\r\nimpl<'a> From<&'a EntityRef<'_>> for FilteredEntityRef<'a> {\r\n    fn from(entity: &'a EntityRef<'_>) -> Self {\r\n        // SAFETY:\r\n        // - `EntityRef` guarantees exclusive access to all components in the new `FilteredEntityRef`.\r\n        unsafe {\r\n            let mut access = Access::default();\r\n            access.read_all();\r\n            FilteredEntityRef::new(entity.0, access)\r\n        }\r\n    }\r\n}\r\n\r\nimpl<'a> From<EntityMut<'a>> for FilteredEntityRef<'a> {\r\n    fn from(entity: EntityMut<'a>) -> Self {\r\n        // SAFETY:\r\n        // - `EntityMut` guarantees exclusive access to all components in the new `FilteredEntityRef`.\r\n        unsafe {\r\n            let mut access = Access::default();\r\n            access.read_all();\r\n            FilteredEntityRef::new(entity.0, access)\r\n        }\r\n    }\r\n}\r\n\r\nimpl<'a> From<&'a EntityMut<'_>> for FilteredEntityRef<'a> {\r\n    fn from(entity: &'a EntityMut<'_>) -> Self {\r\n        // SAFETY:\r\n        // - `EntityMut` guarantees exclusive access to all components in the new `FilteredEntityRef`.\r\n        unsafe {\r\n            let mut access = Access::default();\r\n            access.read_all();\r\n            FilteredEntityRef::new(entity.0, access)\r\n        }\r\n    }\r\n}\r\n\r\nimpl<'a> From<EntityWorldMut<'a>> for FilteredEntityRef<'a> {\r\n    fn from(entity: EntityWorldMut<'a>) -> Self {\r\n        // SAFETY:\r\n        // - `EntityWorldMut` guarantees exclusive access to the entire world.\r\n        unsafe {\r\n            let mut access = Access::default();\r\n            access.read_all();\r\n            FilteredEntityRef::new(entity.into_unsafe_entity_cell(), access)\r\n        }\r\n    }\r\n}\r\n\r\nimpl<'a> From<&'a EntityWorldMut<'_>> for FilteredEntityRef<'a> {\r\n    fn from(entity: &'a EntityWorldMut<'_>) -> Self {\r\n        // SAFETY:\r\n        // - `EntityWorldMut` guarantees exclusive access to the entire world.\r\n        unsafe {\r\n            let mut access = Access::default();\r\n            access.read_all();\r\n            FilteredEntityRef::new(entity.as_unsafe_entity_cell_readonly(), access)\r\n        }\r\n    }\r\n}\r\n\r\n/// Provides mutable access to a single entity and some of its components defined by the contained [`Access`].\r\npub struct FilteredEntityMut<'w> {\r\n    entity: UnsafeEntityCell<'w>,\r\n    access: Access<ComponentId>,\r\n}\r\n\r\nimpl<'w> FilteredEntityMut<'w> {\r\n    /// # Safety\r\n    /// - No `&mut World` can exist from the underlying `UnsafeWorldCell`\r\n    /// - If `access` takes read access to a component no mutable reference to that\r\n    /// component can exist at the same time as the returned [`FilteredEntityMut`]\r\n    /// - If `access` takes write access to a component, no reference to that component\r\n    /// may exist at the same time as the returned [`FilteredEntityMut`]\r\n    /// - If `access` takes any access for a component `entity` must have that component.\r\n    pub(crate) unsafe fn new(entity: UnsafeEntityCell<'w>, access: Access<ComponentId>) -> Self {\r\n        Self { entity, access }\r\n    }\r\n\r\n    /// Returns a new instance with a shorter lifetime.\r\n    /// This is useful if you have `&mut FilteredEntityMut`, but you need `FilteredEntityMut`.\r\n    pub fn reborrow(&mut self) -> FilteredEntityMut<'_> {\r\n        // SAFETY: We have exclusive access to the entire entity and its components.\r\n        unsafe { Self::new(self.entity, self.access.clone()) }\r\n    }\r\n\r\n    /// Gets read-only access to all of the entity's components.\r\n    pub fn as_readonly(&self) -> FilteredEntityRef<'_> {\r\n        FilteredEntityRef::from(self)\r\n    }\r\n\r\n    /// Returns the [ID](Entity) of the current entity.\r\n    #[inline]\r\n    #[must_use = \"Omit the .id() call if you do not need to store the `Entity` identifier.\"]\r\n    pub fn id(&self) -> Entity {\r\n        self.entity.id()\r\n    }\r\n\r\n    /// Gets metadata indicating the location where the current entity is stored.\r\n    #[inline]\r\n    pub fn location(&self) -> EntityLocation {\r\n        self.entity.location()\r\n    }\r\n\r\n    /// Returns the archetype that the current entity belongs to.\r\n    #[inline]\r\n    pub fn archetype(&self) -> &Archetype {\r\n        self.entity.archetype()\r\n    }\r\n\r\n    /// Returns an iterator over the component ids that are accessed by self.\r\n    #[inline]\r\n    pub fn components(&self) -> impl Iterator<Item = ComponentId> + '_ {\r\n        self.access.reads_and_writes()\r\n    }\r\n\r\n    /// Returns a reference to the underlying [`Access`].\r\n    #[inline]\r\n    pub fn access(&self) -> &Access<ComponentId> {\r\n        &self.access\r\n    }\r\n\r\n    /// Returns `true` if the current entity has a component of type `T`.\r\n    /// Otherwise, this returns `false`.\r\n    ///\r\n    /// ## Notes\r\n    ///\r\n    /// If you do not know the concrete type of a component, consider using\r\n    /// [`Self::contains_id`] or [`Self::contains_type_id`].\r\n    #[inline]\r\n    pub fn contains<T: Component>(&self) -> bool {\r\n        self.contains_type_id(TypeId::of::<T>())\r\n    }\r\n\r\n    /// Returns `true` if the current entity has a component identified by `component_id`.\r\n    /// Otherwise, this returns false.\r\n    ///\r\n    /// ## Notes\r\n    ///\r\n    /// - If you know the concrete type of the component, you should prefer [`Self::contains`].\r\n    /// - If you know the component's [`TypeId`] but not its [`ComponentId`], consider using\r\n    /// [`Self::contains_type_id`].\r\n    #[inline]\r\n    pub fn contains_id(&self, component_id: ComponentId) -> bool {\r\n        self.entity.contains_id(component_id)\r\n    }\r\n\r\n    /// Returns `true` if the current entity has a component with the type identified by `type_id`.\r\n    /// Otherwise, this returns false.\r\n    ///\r\n    /// ## Notes\r\n    ///\r\n    /// - If you know the concrete type of the component, you should prefer [`Self::contains`].\r\n    /// - If you have a [`ComponentId`] instead of a [`TypeId`], consider using [`Self::contains_id`].\r\n    #[inline]\r\n    pub fn contains_type_id(&self, type_id: TypeId) -> bool {\r\n        self.entity.contains_type_id(type_id)\r\n    }\r\n\r\n    /// Gets access to the component of type `T` for the current entity.\r\n    /// Returns `None` if the entity does not have a component of type `T`.\r\n    #[inline]\r\n    pub fn get<T: Component>(&self) -> Option<&'_ T> {\r\n        self.as_readonly().get()\r\n    }\r\n\r\n    /// Gets access to the component of type `T` for the current entity,\r\n    /// including change detection information as a [`Ref`].\r\n    ///\r\n    /// Returns `None` if the entity does not have a component of type `T`.\r\n    #[inline]\r\n    pub fn get_ref<T: Component>(&self) -> Option<Ref<'_, T>> {\r\n        self.as_readonly().get_ref()\r\n    }\r\n\r\n    /// Gets mutable access to the component of type `T` for the current entity.\r\n    /// Returns `None` if the entity does not have a component of type `T`.\r\n    #[inline]\r\n    pub fn get_mut<T: Component>(&mut self) -> Option<Mut<'_, T>> {\r\n        let id = self.entity.world().components().get_id(TypeId::of::<T>())?;\r\n        self.access\r\n            .has_write(id)\r\n            // SAFETY: We have write access so we must have the component\r\n            .then(|| unsafe { self.entity.get_mut().debug_checked_unwrap() })\r\n    }\r\n\r\n    /// Retrieves the change ticks for the given component. This can be useful for implementing change\r\n    /// detection in custom runtimes.\r\n    #[inline]\r\n    pub fn get_change_ticks<T: Component>(&self) -> Option<ComponentTicks> {\r\n        self.as_readonly().get_change_ticks::<T>()\r\n    }\r\n\r\n    /// Retrieves the change ticks for the given [`ComponentId`]. This can be useful for implementing change\r\n    /// detection in custom runtimes.\r\n    ///\r\n    /// **You should prefer to use the typed API [`Self::get_change_ticks`] where possible and only\r\n    /// use this in cases where the actual component types are not known at\r\n    /// compile time.**\r\n    #[inline]\r\n    pub fn get_change_ticks_by_id(&self, component_id: ComponentId) -> Option<ComponentTicks> {\r\n        self.as_readonly().get_change_ticks_by_id(component_id)\r\n    }\r\n\r\n    /// Gets the component of the given [`ComponentId`] from the entity.\r\n    ///\r\n    /// **You should prefer to use the typed API [`Self::get`] where possible and only\r\n    /// use this in cases where the actual component types are not known at\r\n    /// compile time.**\r\n    ///\r\n    /// Unlike [`FilteredEntityMut::get`], this returns a raw pointer to the component,\r\n    /// which is only valid while the [`FilteredEntityMut`] is alive.\r\n    #[inline]\r\n    pub fn get_by_id(&self, component_id: ComponentId) -> Option<Ptr<'_>> {\r\n        self.as_readonly().get_by_id(component_id)\r\n    }\r\n\r\n    /// Gets a [`MutUntyped`] of the component of the given [`ComponentId`] from the entity.\r\n    ///\r\n    /// **You should prefer to use the typed API [`Self::get_mut`] where possible and only\r\n    /// use this in cases where the actual component types are not known at\r\n    /// compile time.**\r\n    ///\r\n    /// Unlike [`FilteredEntityMut::get_mut`], this returns a raw pointer to the component,\r\n    /// which is only valid while the [`FilteredEntityMut`] is alive.\r\n    #[inline]\r\n    pub fn get_mut_by_id(&mut self, component_id: ComponentId) -> Option<MutUntyped<'_>> {\r\n        // SAFETY: We have write access so we must have the component\r\n        self.access.has_write(component_id).then(|| unsafe {\r\n            self.entity\r\n                .get_mut_by_id(component_id)\r\n                .debug_checked_unwrap()\r\n        })\r\n    }\r\n}\r\n\r\nimpl<'a> From<EntityMut<'a>> for FilteredEntityMut<'a> {\r\n    fn from(entity: EntityMut<'a>) -> Self {\r\n        // SAFETY:\r\n        // - `EntityMut` guarantees exclusive access to all components in the new `FilteredEntityMut`.\r\n        unsafe {\r\n            let mut access = Access::default();\r\n            access.read_all();\r\n            access.write_all();\r\n            FilteredEntityMut::new(entity.0, access)\r\n        }\r\n    }\r\n}\r\n\r\nimpl<'a> From<&'a mut EntityMut<'_>> for FilteredEntityMut<'a> {\r\n    fn from(entity: &'a mut EntityMut<'_>) -> Self {\r\n        // SAFETY:\r\n        // - `EntityMut` guarantees exclusive access to all components in the new `FilteredEntityMut`.\r\n        unsafe {\r\n            let mut access = Access::default();\r\n            access.read_all();\r\n            access.write_all();\r\n            FilteredEntityMut::new(entity.0, access)\r\n        }\r\n    }\r\n}\r\n\r\nimpl<'a> From<EntityWorldMut<'a>> for FilteredEntityMut<'a> {\r\n    fn from(entity: EntityWorldMut<'a>) -> Self {\r\n        // SAFETY:\r\n        // - `EntityWorldMut` guarantees exclusive access to the entire world.\r\n        unsafe {\r\n            let mut access = Access::default();\r\n            access.read_all();\r\n            access.write_all();\r\n            FilteredEntityMut::new(entity.into_unsafe_entity_cell(), access)\r\n        }\r\n    }\r\n}\r\n\r\nimpl<'a> From<&'a mut EntityWorldMut<'_>> for FilteredEntityMut<'a> {\r\n    fn from(entity: &'a mut EntityWorldMut<'_>) -> Self {\r\n        // SAFETY:\r\n        // - `EntityWorldMut` guarantees exclusive access to the entire world.\r\n        unsafe {\r\n            let mut access = Access::default();\r\n            access.read_all();\r\n            access.write_all();\r\n            FilteredEntityMut::new(entity.as_unsafe_entity_cell(), access)\r\n        }\r\n    }\r\n}\r\n\r\n#[derive(Error, Debug)]\r\npub enum TryFromFilteredError {\r\n    #[error(\"Conversion failed, filtered entity ref does not have read access to all components\")]\r\n    MissingReadAllAccess,\r\n\r\n    #[error(\"Conversion failed, filtered entity ref does not have write access to all components\")]\r\n    MissingWriteAllAccess,\r\n}\r\n\r\n/// Inserts a dynamic [`Bundle`] into the entity.\r\n///\r\n/// # Safety\r\n///\r\n/// - [`OwningPtr`] and [`StorageType`] iterators must correspond to the\r\n/// [`BundleInfo`] used to construct [`BundleInserter`]\r\n/// - [`Entity`] must correspond to [`EntityLocation`]\r\nunsafe fn insert_dynamic_bundle<\r\n    'a,\r\n    I: Iterator<Item = OwningPtr<'a>>,\r\n    S: Iterator<Item = StorageType>,\r\n>(\r\n    mut bundle_inserter: BundleInserter<'_>,\r\n    entity: Entity,\r\n    location: EntityLocation,\r\n    components: I,\r\n    storage_types: S,\r\n) -> EntityLocation {\r\n    struct DynamicInsertBundle<'a, I: Iterator<Item = (StorageType, OwningPtr<'a>)>> {\r\n        components: I,\r\n    }\r\n\r\n    impl<'a, I: Iterator<Item = (StorageType, OwningPtr<'a>)>> DynamicBundle\r\n        for DynamicInsertBundle<'a, I>\r\n    {\r\n        fn get_components(self, func: &mut impl FnMut(StorageType, OwningPtr<'_>)) {\r\n            self.components.for_each(|(t, ptr)| func(t, ptr));\r\n        }\r\n    }\r\n\r\n    let bundle = DynamicInsertBundle {\r\n        components: storage_types.zip(components),\r\n    };\r\n\r\n    // SAFETY: location matches current entity.\r\n    unsafe { bundle_inserter.insert(entity, location, bundle) }\r\n}\r\n\r\n/// Removes a bundle from the given archetype and returns the resulting archetype (or None if the\r\n/// removal was invalid). in the event that adding the given bundle does not result in an Archetype\r\n/// change. Results are cached in the Archetype Graph to avoid redundant work.\r\n/// if `intersection` is false, attempting to remove a bundle with components _not_ contained in the\r\n/// current archetype will fail, returning None. if `intersection` is true, components in the bundle\r\n/// but not in the current archetype will be ignored\r\n///\r\n/// # Safety\r\n/// `archetype_id` must exist and components in `bundle_info` must exist\r\nunsafe fn remove_bundle_from_archetype(\r\n    archetypes: &mut Archetypes,\r\n    storages: &mut Storages,\r\n    components: &Components,\r\n    archetype_id: ArchetypeId,\r\n    bundle_info: &BundleInfo,\r\n    intersection: bool,\r\n) -> Option<ArchetypeId> {\r\n    // check the archetype graph to see if the Bundle has been removed from this archetype in the\r\n    // past\r\n    let remove_bundle_result = {\r\n        let edges = archetypes[archetype_id].edges();\r\n        if intersection {\r\n            edges.get_remove_bundle(bundle_info.id())\r\n        } else {\r\n            edges.get_take_bundle(bundle_info.id())\r\n        }\r\n    };\r\n    let result = if let Some(result) = remove_bundle_result {\r\n        // this Bundle removal result is cached. just return that!\r\n        result\r\n    } else {\r\n        let mut next_table_components;\r\n        let mut next_sparse_set_components;\r\n        let next_table_id;\r\n        {\r\n            let current_archetype = &mut archetypes[archetype_id];\r\n            let mut removed_table_components = Vec::new();\r\n            let mut removed_sparse_set_components = Vec::new();\r\n            for component_id in bundle_info.components().iter().cloned() {\r\n                if current_archetype.contains(component_id) {\r\n                    // SAFETY: bundle components were already initialized by bundles.get_info\r\n                    let component_info = unsafe { components.get_info_unchecked(component_id) };\r\n                    match component_info.storage_type() {\r\n                        StorageType::Table => removed_table_components.push(component_id),\r\n                        StorageType::SparseSet => removed_sparse_set_components.push(component_id),\r\n                    }\r\n                } else if !intersection {\r\n                    // a component in the bundle was not present in the entity's archetype, so this\r\n                    // removal is invalid cache the result in the archetype\r\n                    // graph\r\n                    current_archetype\r\n                        .edges_mut()\r\n                        .insert_take_bundle(bundle_info.id(), None);\r\n                    return None;\r\n                }\r\n            }\r\n\r\n            // sort removed components so we can do an efficient \"sorted remove\". archetype\r\n            // components are already sorted\r\n            removed_table_components.sort();\r\n            removed_sparse_set_components.sort();\r\n            next_table_components = current_archetype.table_components().collect();\r\n            next_sparse_set_components = current_archetype.sparse_set_components().collect();\r\n            sorted_remove(&mut next_table_components, &removed_table_components);\r\n            sorted_remove(\r\n                &mut next_sparse_set_components,\r\n                &removed_sparse_set_components,\r\n            );\r\n\r\n            next_table_id = if removed_table_components.is_empty() {\r\n                current_archetype.table_id()\r\n            } else {\r\n                // SAFETY: all components in next_table_components exist\r\n                unsafe {\r\n                    storages\r\n                        .tables\r\n                        .get_id_or_insert(&next_table_components, components)\r\n                }\r\n            };\r\n        }\r\n\r\n        let new_archetype_id = archetypes.get_id_or_insert(\r\n            components,\r\n            next_table_id,\r\n            next_table_components,\r\n            next_sparse_set_components,\r\n        );\r\n        Some(new_archetype_id)\r\n    };\r\n    let current_archetype = &mut archetypes[archetype_id];\r\n    // cache the result in an edge\r\n    if intersection {\r\n        current_archetype\r\n            .edges_mut()\r\n            .insert_remove_bundle(bundle_info.id(), result);\r\n    } else {\r\n        current_archetype\r\n            .edges_mut()\r\n            .insert_take_bundle(bundle_info.id(), result);\r\n    }\r\n    result\r\n}\r\n\r\nfn sorted_remove<T: Eq + Ord + Copy>(source: &mut Vec<T>, remove: &[T]) {\r\n    let mut remove_index = 0;\r\n    source.retain(|value| {\r\n        while remove_index < remove.len() && *value > remove[remove_index] {\r\n            remove_index += 1;\r\n        }\r\n\r\n        if remove_index < remove.len() {\r\n            *value != remove[remove_index]\r\n        } else {\r\n            true\r\n        }\r\n    });\r\n}\r\n\r\n/// Moves component data out of storage.\r\n///\r\n/// This function leaves the underlying memory unchanged, but the component behind\r\n/// returned pointer is semantically owned by the caller and will not be dropped in its original location.\r\n/// Caller is responsible to drop component data behind returned pointer.\r\n///\r\n/// # Safety\r\n/// - `location.table_row` must be in bounds of column of component id `component_id`\r\n/// - `component_id` must be valid\r\n/// - `components` must come from the same world as `self`\r\n/// - The relevant table row **must be removed** by the caller once all components are taken, without dropping the value\r\n#[inline]\r\npub(crate) unsafe fn take_component<'a>(\r\n    storages: &'a mut Storages,\r\n    components: &Components,\r\n    removed_components: &mut RemovedComponentEvents,\r\n    component_id: ComponentId,\r\n    entity: Entity,\r\n    location: EntityLocation,\r\n) -> OwningPtr<'a> {\r\n    // SAFETY: caller promises component_id to be valid\r\n    let component_info = unsafe { components.get_info_unchecked(component_id) };\r\n    removed_components.send(component_id, entity);\r\n    match component_info.storage_type() {\r\n        StorageType::Table => {\r\n            let table = &mut storages.tables[location.table_id];\r\n            let components = table.get_column_mut(component_id).unwrap();\r\n            // SAFETY:\r\n            // - archetypes only store valid table_rows\r\n            // - index is in bounds as promised by caller\r\n            // - promote is safe because the caller promises to remove the table row without dropping it immediately afterwards\r\n            unsafe {\r\n                components\r\n                    .get_data_unchecked_mut(location.table_row)\r\n                    .promote()\r\n            }\r\n        }\r\n        StorageType::SparseSet => storages\r\n            .sparse_sets\r\n            .get_mut(component_id)\r\n            .unwrap()\r\n            .remove_and_forget(entity)\r\n            .unwrap(),\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use bevy_ptr::OwningPtr;\r\n    use std::panic::AssertUnwindSafe;\r\n\r\n    use crate::{self as bevy_ecs, component::ComponentId, prelude::*, system::assert_is_system};\r\n\r\n    #[test]\r\n    fn sorted_remove() {\r\n        let mut a = vec![1, 2, 3, 4, 5, 6, 7];\r\n        let b = vec![1, 2, 3, 5, 7];\r\n        super::sorted_remove(&mut a, &b);\r\n\r\n        assert_eq!(a, vec![4, 6]);\r\n\r\n        let mut a = vec![1];\r\n        let b = vec![1];\r\n        super::sorted_remove(&mut a, &b);\r\n\r\n        assert_eq!(a, vec![]);\r\n\r\n        let mut a = vec![1];\r\n        let b = vec![2];\r\n        super::sorted_remove(&mut a, &b);\r\n\r\n        assert_eq!(a, vec![1]);\r\n    }\r\n\r\n    #[derive(Component, Clone, Copy, Debug, PartialEq)]\r\n    struct TestComponent(u32);\r\n\r\n    #[derive(Component, Clone, Copy, Debug, PartialEq)]\r\n    #[component(storage = \"SparseSet\")]\r\n    struct TestComponent2(u32);\r\n\r\n    #[test]\r\n    fn entity_ref_get_by_id() {\r\n        let mut world = World::new();\r\n        let entity = world.spawn(TestComponent(42)).id();\r\n        let component_id = world\r\n            .components()\r\n            .get_id(std::any::TypeId::of::<TestComponent>())\r\n            .unwrap();\r\n\r\n        let entity = world.entity(entity);\r\n        let test_component = entity.get_by_id(component_id).unwrap();\r\n        // SAFETY: points to a valid `TestComponent`\r\n        let test_component = unsafe { test_component.deref::<TestComponent>() };\r\n\r\n        assert_eq!(test_component.0, 42);\r\n    }\r\n\r\n    #[test]\r\n    fn entity_mut_get_by_id() {\r\n        let mut world = World::new();\r\n        let entity = world.spawn(TestComponent(42)).id();\r\n        let component_id = world\r\n            .components()\r\n            .get_id(std::any::TypeId::of::<TestComponent>())\r\n            .unwrap();\r\n\r\n        let mut entity_mut = world.entity_mut(entity);\r\n        let mut test_component = entity_mut.get_mut_by_id(component_id).unwrap();\r\n        {\r\n            test_component.set_changed();\r\n            let test_component =\r\n                // SAFETY: `test_component` has unique access of the `EntityWorldMut` and is not used afterwards\r\n                unsafe { test_component.into_inner().deref_mut::<TestComponent>() };\r\n            test_component.0 = 43;\r\n        }\r\n\r\n        let entity = world.entity(entity);\r\n        let test_component = entity.get_by_id(component_id).unwrap();\r\n        // SAFETY: `TestComponent` is the correct component type\r\n        let test_component = unsafe { test_component.deref::<TestComponent>() };\r\n\r\n        assert_eq!(test_component.0, 43);\r\n    }\r\n\r\n    #[test]\r\n    fn entity_ref_get_by_id_invalid_component_id() {\r\n        let invalid_component_id = ComponentId::new(usize::MAX);\r\n\r\n        let mut world = World::new();\r\n        let entity = world.spawn_empty().id();\r\n        let entity = world.entity(entity);\r\n        assert!(entity.get_by_id(invalid_component_id).is_none());\r\n    }\r\n\r\n    #[test]\r\n    fn entity_mut_get_by_id_invalid_component_id() {\r\n        let invalid_component_id = ComponentId::new(usize::MAX);\r\n\r\n        let mut world = World::new();\r\n        let mut entity = world.spawn_empty();\r\n        assert!(entity.get_by_id(invalid_component_id).is_none());\r\n        assert!(entity.get_mut_by_id(invalid_component_id).is_none());\r\n    }\r\n\r\n    // regression test for https://github.com/bevyengine/bevy/pull/7387\r\n    #[test]\r\n    fn entity_mut_world_scope_panic() {\r\n        let mut world = World::new();\r\n\r\n        let mut entity = world.spawn_empty();\r\n        let old_location = entity.location();\r\n        let id = entity.id();\r\n        let res = std::panic::catch_unwind(AssertUnwindSafe(|| {\r\n            entity.world_scope(|w| {\r\n                // Change the entity's `EntityLocation`, which invalidates the original `EntityWorldMut`.\r\n                // This will get updated at the end of the scope.\r\n                w.entity_mut(id).insert(TestComponent(0));\r\n\r\n                // Ensure that the entity location still gets updated even in case of a panic.\r\n                panic!(\"this should get caught by the outer scope\")\r\n            });\r\n        }));\r\n        assert!(res.is_err());\r\n\r\n        // Ensure that the location has been properly updated.\r\n        assert_ne!(entity.location(), old_location);\r\n    }\r\n\r\n    // regression test for https://github.com/bevyengine/bevy/pull/7805\r\n    #[test]\r\n    fn removing_sparse_updates_archetype_row() {\r\n        #[derive(Component, PartialEq, Debug)]\r\n        struct Dense(u8);\r\n\r\n        #[derive(Component)]\r\n        #[component(storage = \"SparseSet\")]\r\n        struct Sparse;\r\n\r\n        let mut world = World::new();\r\n        let e1 = world.spawn((Dense(0), Sparse)).id();\r\n        let e2 = world.spawn((Dense(1), Sparse)).id();\r\n\r\n        world.entity_mut(e1).remove::<Sparse>();\r\n        assert_eq!(world.entity(e2).get::<Dense>().unwrap(), &Dense(1));\r\n    }\r\n\r\n    // regression test for https://github.com/bevyengine/bevy/pull/7805\r\n    #[test]\r\n    fn removing_dense_updates_table_row() {\r\n        #[derive(Component, PartialEq, Debug)]\r\n        struct Dense(u8);\r\n\r\n        #[derive(Component)]\r\n        #[component(storage = \"SparseSet\")]\r\n        struct Sparse;\r\n\r\n        let mut world = World::new();\r\n        let e1 = world.spawn((Dense(0), Sparse)).id();\r\n        let e2 = world.spawn((Dense(1), Sparse)).id();\r\n\r\n        world.entity_mut(e1).remove::<Dense>();\r\n        assert_eq!(world.entity(e2).get::<Dense>().unwrap(), &Dense(1));\r\n    }\r\n\r\n    // Test that calling retain with `()` removes all components.\r\n    #[test]\r\n    fn retain_nothing() {\r\n        #[derive(Component)]\r\n        struct Marker<const N: usize>;\r\n\r\n        let mut world = World::new();\r\n        let ent = world.spawn((Marker::<1>, Marker::<2>, Marker::<3>)).id();\r\n\r\n        world.entity_mut(ent).retain::<()>();\r\n        assert_eq!(world.entity(ent).archetype().components().next(), None);\r\n    }\r\n\r\n    // Test removing some components with `retain`, including components not on the entity.\r\n    #[test]\r\n    fn retain_some_components() {\r\n        #[derive(Component)]\r\n        struct Marker<const N: usize>;\r\n\r\n        let mut world = World::new();\r\n        let ent = world.spawn((Marker::<1>, Marker::<2>, Marker::<3>)).id();\r\n\r\n        world.entity_mut(ent).retain::<(Marker<2>, Marker<4>)>();\r\n        // Check that marker 2 was retained.\r\n        assert!(world.entity(ent).get::<Marker<2>>().is_some());\r\n        // Check that only marker 2 was retained.\r\n        assert_eq!(\r\n            world\r\n                .entity(ent)\r\n                .archetype()\r\n                .components()\r\n                .collect::<Vec<_>>()\r\n                .len(),\r\n            1\r\n        );\r\n    }\r\n\r\n    // regression test for https://github.com/bevyengine/bevy/pull/7805\r\n    #[test]\r\n    fn inserting_sparse_updates_archetype_row() {\r\n        #[derive(Component, PartialEq, Debug)]\r\n        struct Dense(u8);\r\n\r\n        #[derive(Component)]\r\n        #[component(storage = \"SparseSet\")]\r\n        struct Sparse;\r\n\r\n        let mut world = World::new();\r\n        let e1 = world.spawn(Dense(0)).id();\r\n        let e2 = world.spawn(Dense(1)).id();\r\n\r\n        world.entity_mut(e1).insert(Sparse);\r\n        assert_eq!(world.entity(e2).get::<Dense>().unwrap(), &Dense(1));\r\n    }\r\n\r\n    // regression test for https://github.com/bevyengine/bevy/pull/7805\r\n    #[test]\r\n    fn inserting_dense_updates_archetype_row() {\r\n        #[derive(Component, PartialEq, Debug)]\r\n        struct Dense(u8);\r\n\r\n        #[derive(Component)]\r\n        struct Dense2;\r\n\r\n        #[derive(Component)]\r\n        #[component(storage = \"SparseSet\")]\r\n        struct Sparse;\r\n\r\n        let mut world = World::new();\r\n        let e1 = world.spawn(Dense(0)).id();\r\n        let e2 = world.spawn(Dense(1)).id();\r\n\r\n        world.entity_mut(e1).insert(Sparse).remove::<Sparse>();\r\n\r\n        // archetype with [e2, e1]\r\n        // table with [e1, e2]\r\n\r\n        world.entity_mut(e2).insert(Dense2);\r\n\r\n        assert_eq!(world.entity(e1).get::<Dense>().unwrap(), &Dense(0));\r\n    }\r\n\r\n    #[test]\r\n    fn inserting_dense_updates_table_row() {\r\n        #[derive(Component, PartialEq, Debug)]\r\n        struct Dense(u8);\r\n\r\n        #[derive(Component)]\r\n        struct Dense2;\r\n\r\n        #[derive(Component)]\r\n        #[component(storage = \"SparseSet\")]\r\n        struct Sparse;\r\n\r\n        let mut world = World::new();\r\n        let e1 = world.spawn(Dense(0)).id();\r\n        let e2 = world.spawn(Dense(1)).id();\r\n\r\n        world.entity_mut(e1).insert(Sparse).remove::<Sparse>();\r\n\r\n        // archetype with [e2, e1]\r\n        // table with [e1, e2]\r\n\r\n        world.entity_mut(e1).insert(Dense2);\r\n\r\n        assert_eq!(world.entity(e2).get::<Dense>().unwrap(), &Dense(1));\r\n    }\r\n\r\n    // regression test for https://github.com/bevyengine/bevy/pull/7805\r\n    #[test]\r\n    fn despawning_entity_updates_archetype_row() {\r\n        #[derive(Component, PartialEq, Debug)]\r\n        struct Dense(u8);\r\n\r\n        #[derive(Component)]\r\n        #[component(storage = \"SparseSet\")]\r\n        struct Sparse;\r\n\r\n        let mut world = World::new();\r\n        let e1 = world.spawn(Dense(0)).id();\r\n        let e2 = world.spawn(Dense(1)).id();\r\n\r\n        world.entity_mut(e1).insert(Sparse).remove::<Sparse>();\r\n\r\n        // archetype with [e2, e1]\r\n        // table with [e1, e2]\r\n\r\n        world.entity_mut(e2).despawn();\r\n\r\n        assert_eq!(world.entity(e1).get::<Dense>().unwrap(), &Dense(0));\r\n    }\r\n\r\n    // regression test for https://github.com/bevyengine/bevy/pull/7805\r\n    #[test]\r\n    fn despawning_entity_updates_table_row() {\r\n        #[derive(Component, PartialEq, Debug)]\r\n        struct Dense(u8);\r\n\r\n        #[derive(Component)]\r\n        #[component(storage = \"SparseSet\")]\r\n        struct Sparse;\r\n\r\n        let mut world = World::new();\r\n        let e1 = world.spawn(Dense(0)).id();\r\n        let e2 = world.spawn(Dense(1)).id();\r\n\r\n        world.entity_mut(e1).insert(Sparse).remove::<Sparse>();\r\n\r\n        // archetype with [e2, e1]\r\n        // table with [e1, e2]\r\n\r\n        world.entity_mut(e1).despawn();\r\n\r\n        assert_eq!(world.entity(e2).get::<Dense>().unwrap(), &Dense(1));\r\n    }\r\n\r\n    #[test]\r\n    fn entity_mut_insert_by_id() {\r\n        let mut world = World::new();\r\n        let test_component_id = world.init_component::<TestComponent>();\r\n\r\n        let mut entity = world.spawn_empty();\r\n        OwningPtr::make(TestComponent(42), |ptr| {\r\n            // SAFETY: `ptr` matches the component id\r\n            unsafe { entity.insert_by_id(test_component_id, ptr) };\r\n        });\r\n\r\n        let components: Vec<_> = world.query::<&TestComponent>().iter(&world).collect();\r\n\r\n        assert_eq!(components, vec![&TestComponent(42)]);\r\n\r\n        // Compare with `insert_bundle_by_id`\r\n\r\n        let mut entity = world.spawn_empty();\r\n        OwningPtr::make(TestComponent(84), |ptr| {\r\n            // SAFETY: `ptr` matches the component id\r\n            unsafe { entity.insert_by_ids(&[test_component_id], vec![ptr].into_iter()) };\r\n        });\r\n\r\n        let components: Vec<_> = world.query::<&TestComponent>().iter(&world).collect();\r\n\r\n        assert_eq!(components, vec![&TestComponent(42), &TestComponent(84)]);\r\n    }\r\n\r\n    #[test]\r\n    fn entity_mut_insert_bundle_by_id() {\r\n        let mut world = World::new();\r\n        let test_component_id = world.init_component::<TestComponent>();\r\n        let test_component_2_id = world.init_component::<TestComponent2>();\r\n\r\n        let component_ids = [test_component_id, test_component_2_id];\r\n        let test_component_value = TestComponent(42);\r\n        let test_component_2_value = TestComponent2(84);\r\n\r\n        let mut entity = world.spawn_empty();\r\n        OwningPtr::make(test_component_value, |ptr1| {\r\n            OwningPtr::make(test_component_2_value, |ptr2| {\r\n                // SAFETY: `ptr1` and `ptr2` match the component ids\r\n                unsafe { entity.insert_by_ids(&component_ids, vec![ptr1, ptr2].into_iter()) };\r\n            });\r\n        });\r\n\r\n        let dynamic_components: Vec<_> = world\r\n            .query::<(&TestComponent, &TestComponent2)>()\r\n            .iter(&world)\r\n            .collect();\r\n\r\n        assert_eq!(\r\n            dynamic_components,\r\n            vec![(&TestComponent(42), &TestComponent2(84))]\r\n        );\r\n\r\n        // Compare with `World` generated using static type equivalents\r\n        let mut static_world = World::new();\r\n\r\n        static_world.spawn((test_component_value, test_component_2_value));\r\n        let static_components: Vec<_> = static_world\r\n            .query::<(&TestComponent, &TestComponent2)>()\r\n            .iter(&static_world)\r\n            .collect();\r\n\r\n        assert_eq!(dynamic_components, static_components);\r\n    }\r\n\r\n    #[derive(Component)]\r\n    struct A;\r\n\r\n    #[derive(Resource)]\r\n    struct R;\r\n\r\n    #[test]\r\n    fn disjoint_access() {\r\n        fn disjoint_readonly(_: Query<EntityMut, With<A>>, _: Query<EntityRef, Without<A>>) {}\r\n\r\n        fn disjoint_mutable(_: Query<EntityMut, With<A>>, _: Query<EntityMut, Without<A>>) {}\r\n\r\n        assert_is_system(disjoint_readonly);\r\n        assert_is_system(disjoint_mutable);\r\n    }\r\n\r\n    #[test]\r\n    fn ref_compatible() {\r\n        fn borrow_system(_: Query<(EntityRef, &A)>, _: Query<&A>) {}\r\n\r\n        assert_is_system(borrow_system);\r\n    }\r\n\r\n    #[test]\r\n    fn ref_compatible_with_resource() {\r\n        fn borrow_system(_: Query<EntityRef>, _: Res<R>) {}\r\n\r\n        assert_is_system(borrow_system);\r\n    }\r\n\r\n    #[test]\r\n    #[ignore] // This should pass, but it currently fails due to limitations in our access model.\r\n    fn ref_compatible_with_resource_mut() {\r\n        fn borrow_system(_: Query<EntityRef>, _: ResMut<R>) {}\r\n\r\n        assert_is_system(borrow_system);\r\n    }\r\n\r\n    #[test]\r\n    #[should_panic]\r\n    fn ref_incompatible_with_mutable_component() {\r\n        fn incompatible_system(_: Query<(EntityRef, &mut A)>) {}\r\n\r\n        assert_is_system(incompatible_system);\r\n    }\r\n\r\n    #[test]\r\n    #[should_panic]\r\n    fn ref_incompatible_with_mutable_query() {\r\n        fn incompatible_system(_: Query<EntityRef>, _: Query<&mut A>) {}\r\n\r\n        assert_is_system(incompatible_system);\r\n    }\r\n\r\n    #[test]\r\n    fn mut_compatible_with_entity() {\r\n        fn borrow_mut_system(_: Query<(Entity, EntityMut)>) {}\r\n\r\n        assert_is_system(borrow_mut_system);\r\n    }\r\n\r\n    #[test]\r\n    #[ignore] // This should pass, but it currently fails due to limitations in our access model.\r\n    fn mut_compatible_with_resource() {\r\n        fn borrow_mut_system(_: Res<R>, _: Query<EntityMut>) {}\r\n\r\n        assert_is_system(borrow_mut_system);\r\n    }\r\n\r\n    #[test]\r\n    #[ignore] // This should pass, but it currently fails due to limitations in our access model.\r\n    fn mut_compatible_with_resource_mut() {\r\n        fn borrow_mut_system(_: ResMut<R>, _: Query<EntityMut>) {}\r\n\r\n        assert_is_system(borrow_mut_system);\r\n    }\r\n\r\n    #[test]\r\n    #[should_panic]\r\n    fn mut_incompatible_with_read_only_component() {\r\n        fn incompatible_system(_: Query<(EntityMut, &A)>) {}\r\n\r\n        assert_is_system(incompatible_system);\r\n    }\r\n\r\n    #[test]\r\n    #[should_panic]\r\n    fn mut_incompatible_with_mutable_component() {\r\n        fn incompatible_system(_: Query<(EntityMut, &mut A)>) {}\r\n\r\n        assert_is_system(incompatible_system);\r\n    }\r\n\r\n    #[test]\r\n    #[should_panic]\r\n    fn mut_incompatible_with_read_only_query() {\r\n        fn incompatible_system(_: Query<EntityMut>, _: Query<&A>) {}\r\n\r\n        assert_is_system(incompatible_system);\r\n    }\r\n\r\n    #[test]\r\n    #[should_panic]\r\n    fn mut_incompatible_with_mutable_query() {\r\n        fn incompatible_system(_: Query<EntityMut>, _: Query<&mut A>) {}\r\n\r\n        assert_is_system(incompatible_system);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\bevy\\crates\\bevy_winit\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"bevy_winit\"\r\nversion = \"0.14.0-dev\"\r\nedition = \"2021\"\r\ndescription = \"A winit window and input backend for Bevy Engine\"\r\nhomepage = \"https://bevyengine.org\"\r\nrepository = \"https://github.com/bevyengine/bevy\"\r\nlicense = \"MIT OR Apache-2.0\"\r\nkeywords = [\"bevy\"]\r\n\r\n[features]\r\ntrace = []\r\nwayland = [\"winit/wayland\", \"winit/wayland-csd-adwaita\"]\r\nx11 = [\"winit/x11\"]\r\naccesskit_unix = [\"accesskit_winit/accesskit_unix\", \"accesskit_winit/async-io\"]\r\nserialize = [\"serde\"]\r\n\r\n[dependencies]\r\n# bevy\r\nbevy_a11y = { path = \"../bevy_a11y\", version = \"0.14.0-dev\" }\r\nbevy_app = { path = \"../bevy_app\", version = \"0.14.0-dev\" }\r\nbevy_derive = { path = \"../bevy_derive\", version = \"0.14.0-dev\" }\r\nbevy_ecs = { path = \"../bevy_ecs\", version = \"0.14.0-dev\" }\r\nbevy_hierarchy = { path = \"../bevy_hierarchy\", version = \"0.14.0-dev\" }\r\nbevy_input = { path = \"../bevy_input\", version = \"0.14.0-dev\" }\r\nbevy_math = { path = \"../bevy_math\", version = \"0.14.0-dev\" }\r\nbevy_reflect = { path = \"../bevy_reflect\", version = \"0.14.0-dev\" }\r\nbevy_window = { path = \"../bevy_window\", version = \"0.14.0-dev\" }\r\nbevy_utils = { path = \"../bevy_utils\", version = \"0.14.0-dev\" }\r\nbevy_tasks = { path = \"../bevy_tasks\", version = \"0.14.0-dev\" }\r\n\r\n# other\r\n# feature rwh_06 refers to window_raw_handle@v0.6\r\nwinit = { version = \"0.29\", default-features = false, features = [\"rwh_06\"] }\r\naccesskit_winit = { version = \"0.17\", default-features = false, features = [\r\n  \"rwh_06\",\r\n] }\r\napprox = { version = \"0.5\", default-features = false }\r\nraw-window-handle = \"0.6\"\r\nserde = { version = \"1.0\", features = [\"derive\"], optional = true }\r\n\r\n[target.'cfg(target_os = \"android\")'.dependencies]\r\nwinit = { version = \"0.29\", default-features = false, features = [\r\n  \"android-native-activity\",\r\n  \"rwh_06\",\r\n] }\r\n\r\n[target.'cfg(target_arch = \"wasm32\")'.dependencies]\r\nwasm-bindgen = { version = \"0.2\" }\r\nweb-sys = \"0.3\"\r\ncrossbeam-channel = \"0.5\"\r\n\r\n[package.metadata.docs.rs]\r\nall-features = true\r\n\r\n[lints]\r\nworkspace = true\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\bevy\\crates\\bevy_ui\\src\\widget\\label.rs\r\n\r\n````rust\r\nuse bevy_ecs::prelude::Component;\r\nuse bevy_ecs::reflect::ReflectComponent;\r\nuse bevy_reflect::std_traits::ReflectDefault;\r\nuse bevy_reflect::Reflect;\r\n\r\n/// Marker struct for labels\r\n#[derive(Component, Debug, Default, Clone, Copy, Reflect)]\r\n#[reflect(Component, Default)]\r\npub struct Label;\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\bevy\\crates\\bevy_core_pipeline\\src\\msaa_writeback.rs\r\n\r\n````rust\r\nuse crate::{\r\n    blit::{BlitPipeline, BlitPipelineKey},\r\n    core_2d::graph::{Core2d, Node2d},\r\n    core_3d::graph::{Core3d, Node3d},\r\n};\r\nuse bevy_app::{App, Plugin};\r\nuse bevy_color::LinearRgba;\r\nuse bevy_ecs::prelude::*;\r\nuse bevy_render::{\r\n    camera::ExtractedCamera,\r\n    render_graph::{Node, NodeRunError, RenderGraphApp, RenderGraphContext},\r\n    renderer::RenderContext,\r\n    view::{Msaa, ViewTarget},\r\n    Render, RenderSet,\r\n};\r\nuse bevy_render::{render_resource::*, RenderApp};\r\n\r\n/// This enables \"msaa writeback\" support for the `core_2d` and `core_3d` pipelines, which can be enabled on cameras\r\n/// using [`bevy_render::camera::Camera::msaa_writeback`]. See the docs on that field for more information.\r\npub struct MsaaWritebackPlugin;\r\n\r\nimpl Plugin for MsaaWritebackPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        let Ok(render_app) = app.get_sub_app_mut(RenderApp) else {\r\n            return;\r\n        };\r\n\r\n        render_app.add_systems(\r\n            Render,\r\n            prepare_msaa_writeback_pipelines.in_set(RenderSet::Prepare),\r\n        );\r\n        {\r\n            render_app\r\n                .add_render_graph_node::<MsaaWritebackNode>(Core2d, Node2d::MsaaWriteback)\r\n                .add_render_graph_edge(Core2d, Node2d::MsaaWriteback, Node2d::MainPass);\r\n        }\r\n        {\r\n            render_app\r\n                .add_render_graph_node::<MsaaWritebackNode>(Core3d, Node3d::MsaaWriteback)\r\n                .add_render_graph_edge(Core3d, Node3d::MsaaWriteback, Node3d::StartMainPass);\r\n        }\r\n    }\r\n}\r\n\r\npub struct MsaaWritebackNode {\r\n    cameras: QueryState<(&'static ViewTarget, &'static MsaaWritebackBlitPipeline)>,\r\n}\r\n\r\nimpl FromWorld for MsaaWritebackNode {\r\n    fn from_world(world: &mut World) -> Self {\r\n        Self {\r\n            cameras: world.query(),\r\n        }\r\n    }\r\n}\r\n\r\nimpl Node for MsaaWritebackNode {\r\n    fn update(&mut self, world: &mut World) {\r\n        self.cameras.update_archetypes(world);\r\n    }\r\n\r\n    fn run(\r\n        &self,\r\n        graph: &mut RenderGraphContext,\r\n        render_context: &mut RenderContext,\r\n        world: &World,\r\n    ) -> Result<(), NodeRunError> {\r\n        if *world.resource::<Msaa>() == Msaa::Off {\r\n            return Ok(());\r\n        }\r\n\r\n        let view_entity = graph.view_entity();\r\n        if let Ok((target, blit_pipeline_id)) = self.cameras.get_manual(world, view_entity) {\r\n            let blit_pipeline = world.resource::<BlitPipeline>();\r\n            let pipeline_cache = world.resource::<PipelineCache>();\r\n            let Some(pipeline) = pipeline_cache.get_render_pipeline(blit_pipeline_id.0) else {\r\n                return Ok(());\r\n            };\r\n\r\n            // The current \"main texture\" needs to be bound as an input resource, and we need the \"other\"\r\n            // unused target to be the \"resolve target\" for the MSAA write. Therefore this is the same\r\n            // as a post process write!\r\n            let post_process = target.post_process_write();\r\n\r\n            let pass_descriptor = RenderPassDescriptor {\r\n                label: Some(\"msaa_writeback\"),\r\n                // The target's \"resolve target\" is the \"destination\" in post_process.\r\n                // We will indirectly write the results to the \"destination\" using\r\n                // the MSAA resolve step.\r\n                color_attachments: &[Some(RenderPassColorAttachment {\r\n                    // If MSAA is enabled, then the sampled texture will always exist\r\n                    view: target.sampled_main_texture_view().unwrap(),\r\n                    resolve_target: Some(post_process.destination),\r\n                    ops: Operations {\r\n                        load: LoadOp::Clear(LinearRgba::BLACK.into()),\r\n                        store: StoreOp::Store,\r\n                    },\r\n                })],\r\n                depth_stencil_attachment: None,\r\n                timestamp_writes: None,\r\n                occlusion_query_set: None,\r\n            };\r\n\r\n            let bind_group = render_context.render_device().create_bind_group(\r\n                None,\r\n                &blit_pipeline.texture_bind_group,\r\n                &BindGroupEntries::sequential((post_process.source, &blit_pipeline.sampler)),\r\n            );\r\n\r\n            let mut render_pass = render_context\r\n                .command_encoder()\r\n                .begin_render_pass(&pass_descriptor);\r\n\r\n            render_pass.set_pipeline(pipeline);\r\n            render_pass.set_bind_group(0, &bind_group, &[]);\r\n            render_pass.draw(0..3, 0..1);\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n}\r\n\r\n#[derive(Component)]\r\npub struct MsaaWritebackBlitPipeline(CachedRenderPipelineId);\r\n\r\nfn prepare_msaa_writeback_pipelines(\r\n    mut commands: Commands,\r\n    pipeline_cache: Res<PipelineCache>,\r\n    mut pipelines: ResMut<SpecializedRenderPipelines<BlitPipeline>>,\r\n    blit_pipeline: Res<BlitPipeline>,\r\n    view_targets: Query<(Entity, &ViewTarget, &ExtractedCamera)>,\r\n    msaa: Res<Msaa>,\r\n) {\r\n    for (entity, view_target, camera) in view_targets.iter() {\r\n        // only do writeback if writeback is enabled for the camera and this isn't the first camera in the target,\r\n        // as there is nothing to write back for the first camera.\r\n        if msaa.samples() > 1 && camera.msaa_writeback && camera.sorted_camera_index_for_target > 0\r\n        {\r\n            let key = BlitPipelineKey {\r\n                texture_format: view_target.main_texture_format(),\r\n                samples: msaa.samples(),\r\n                blend_state: None,\r\n            };\r\n\r\n            let pipeline = pipelines.specialize(&pipeline_cache, &blit_pipeline, key);\r\n            commands\r\n                .entity(entity)\r\n                .insert(MsaaWritebackBlitPipeline(pipeline));\r\n        } else {\r\n            // This isn't strictly necessary now, but if we move to retained render entity state I don't\r\n            // want this to silently break\r\n            commands\r\n                .entity(entity)\r\n                .remove::<MsaaWritebackBlitPipeline>();\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\bevy\\crates\\bevy_core_pipeline\\src\\bloom\\downsampling_pipeline.rs\r\n\r\n````rust\r\nuse super::{BloomSettings, BLOOM_SHADER_HANDLE, BLOOM_TEXTURE_FORMAT};\r\nuse crate::fullscreen_vertex_shader::fullscreen_shader_vertex_state;\r\nuse bevy_ecs::{\r\n    prelude::{Component, Entity},\r\n    system::{Commands, Query, Res, ResMut, Resource},\r\n    world::{FromWorld, World},\r\n};\r\nuse bevy_math::Vec4;\r\nuse bevy_render::{\r\n    render_resource::{\r\n        binding_types::{sampler, texture_2d, uniform_buffer},\r\n        *,\r\n    },\r\n    renderer::RenderDevice,\r\n};\r\n\r\n#[derive(Component)]\r\npub struct BloomDownsamplingPipelineIds {\r\n    pub main: CachedRenderPipelineId,\r\n    pub first: CachedRenderPipelineId,\r\n}\r\n\r\n#[derive(Resource)]\r\npub struct BloomDownsamplingPipeline {\r\n    /// Layout with a texture, a sampler, and uniforms\r\n    pub bind_group_layout: BindGroupLayout,\r\n    pub sampler: Sampler,\r\n}\r\n\r\n#[derive(PartialEq, Eq, Hash, Clone)]\r\npub struct BloomDownsamplingPipelineKeys {\r\n    prefilter: bool,\r\n    first_downsample: bool,\r\n}\r\n\r\n/// The uniform struct extracted from [`BloomSettings`] attached to a Camera.\r\n/// Will be available for use in the Bloom shader.\r\n#[derive(Component, ShaderType, Clone)]\r\npub struct BloomUniforms {\r\n    // Precomputed values used when thresholding, see https://catlikecoding.com/unity/tutorials/advanced-rendering/bloom/#3.4\r\n    pub threshold_precomputations: Vec4,\r\n    pub viewport: Vec4,\r\n    pub aspect: f32,\r\n}\r\n\r\nimpl FromWorld for BloomDownsamplingPipeline {\r\n    fn from_world(world: &mut World) -> Self {\r\n        let render_device = world.resource::<RenderDevice>();\r\n\r\n        // Bind group layout\r\n        let bind_group_layout = render_device.create_bind_group_layout(\r\n            \"bloom_downsampling_bind_group_layout_with_settings\",\r\n            &BindGroupLayoutEntries::sequential(\r\n                ShaderStages::FRAGMENT,\r\n                (\r\n                    // Input texture binding\r\n                    texture_2d(TextureSampleType::Float { filterable: true }),\r\n                    // Sampler binding\r\n                    sampler(SamplerBindingType::Filtering),\r\n                    // Downsampling settings binding\r\n                    uniform_buffer::<BloomUniforms>(true),\r\n                ),\r\n            ),\r\n        );\r\n\r\n        // Sampler\r\n        let sampler = render_device.create_sampler(&SamplerDescriptor {\r\n            min_filter: FilterMode::Linear,\r\n            mag_filter: FilterMode::Linear,\r\n            address_mode_u: AddressMode::ClampToEdge,\r\n            address_mode_v: AddressMode::ClampToEdge,\r\n            ..Default::default()\r\n        });\r\n\r\n        BloomDownsamplingPipeline {\r\n            bind_group_layout,\r\n            sampler,\r\n        }\r\n    }\r\n}\r\n\r\nimpl SpecializedRenderPipeline for BloomDownsamplingPipeline {\r\n    type Key = BloomDownsamplingPipelineKeys;\r\n\r\n    fn specialize(&self, key: Self::Key) -> RenderPipelineDescriptor {\r\n        let layout = vec![self.bind_group_layout.clone()];\r\n\r\n        let entry_point = if key.first_downsample {\r\n            \"downsample_first\".into()\r\n        } else {\r\n            \"downsample\".into()\r\n        };\r\n\r\n        let mut shader_defs = vec![];\r\n\r\n        if key.first_downsample {\r\n            shader_defs.push(\"FIRST_DOWNSAMPLE\".into());\r\n        }\r\n\r\n        if key.prefilter {\r\n            shader_defs.push(\"USE_THRESHOLD\".into());\r\n        }\r\n\r\n        RenderPipelineDescriptor {\r\n            label: Some(\r\n                if key.first_downsample {\r\n                    \"bloom_downsampling_pipeline_first\"\r\n                } else {\r\n                    \"bloom_downsampling_pipeline\"\r\n                }\r\n                .into(),\r\n            ),\r\n            layout,\r\n            vertex: fullscreen_shader_vertex_state(),\r\n            fragment: Some(FragmentState {\r\n                shader: BLOOM_SHADER_HANDLE,\r\n                shader_defs,\r\n                entry_point,\r\n                targets: vec![Some(ColorTargetState {\r\n                    format: BLOOM_TEXTURE_FORMAT,\r\n                    blend: None,\r\n                    write_mask: ColorWrites::ALL,\r\n                })],\r\n            }),\r\n            primitive: PrimitiveState::default(),\r\n            depth_stencil: None,\r\n            multisample: MultisampleState::default(),\r\n            push_constant_ranges: Vec::new(),\r\n        }\r\n    }\r\n}\r\n\r\npub fn prepare_downsampling_pipeline(\r\n    mut commands: Commands,\r\n    pipeline_cache: Res<PipelineCache>,\r\n    mut pipelines: ResMut<SpecializedRenderPipelines<BloomDownsamplingPipeline>>,\r\n    pipeline: Res<BloomDownsamplingPipeline>,\r\n    views: Query<(Entity, &BloomSettings)>,\r\n) {\r\n    for (entity, settings) in &views {\r\n        let prefilter = settings.prefilter_settings.threshold > 0.0;\r\n\r\n        let pipeline_id = pipelines.specialize(\r\n            &pipeline_cache,\r\n            &pipeline,\r\n            BloomDownsamplingPipelineKeys {\r\n                prefilter,\r\n                first_downsample: false,\r\n            },\r\n        );\r\n\r\n        let pipeline_first_id = pipelines.specialize(\r\n            &pipeline_cache,\r\n            &pipeline,\r\n            BloomDownsamplingPipelineKeys {\r\n                prefilter,\r\n                first_downsample: true,\r\n            },\r\n        );\r\n\r\n        commands\r\n            .entity(entity)\r\n            .insert(BloomDownsamplingPipelineIds {\r\n                first: pipeline_first_id,\r\n                main: pipeline_id,\r\n            });\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\bevy\\crates\\bevy_ui\\src\\widget\\text.rs\r\n\r\n````rust\r\nuse crate::{ContentSize, FixedMeasure, Measure, Node, UiScale};\r\nuse bevy_asset::Assets;\r\nuse bevy_ecs::{\r\n    prelude::{Component, DetectChanges},\r\n    query::With,\r\n    reflect::ReflectComponent,\r\n    system::{Local, Query, Res, ResMut},\r\n    world::{Mut, Ref},\r\n};\r\nuse bevy_math::Vec2;\r\nuse bevy_reflect::{std_traits::ReflectDefault, Reflect};\r\nuse bevy_render::texture::Image;\r\nuse bevy_sprite::TextureAtlasLayout;\r\nuse bevy_text::{\r\n    scale_value, BreakLineOn, Font, FontAtlasSets, Text, TextError, TextLayoutInfo,\r\n    TextMeasureInfo, TextPipeline, TextSettings, YAxisOrientation,\r\n};\r\nuse bevy_window::{PrimaryWindow, Window};\r\nuse taffy::style::AvailableSpace;\r\n\r\n/// Text system flags\r\n///\r\n/// Used internally by [`measure_text_system`] and [`text_system`] to schedule text for processing.\r\n#[derive(Component, Debug, Clone, Reflect)]\r\n#[reflect(Component, Default)]\r\npub struct TextFlags {\r\n    /// If set a new measure function for the text node will be created\r\n    needs_new_measure_func: bool,\r\n    /// If set the text will be recomputed\r\n    needs_recompute: bool,\r\n}\r\n\r\nimpl Default for TextFlags {\r\n    fn default() -> Self {\r\n        Self {\r\n            needs_new_measure_func: true,\r\n            needs_recompute: true,\r\n        }\r\n    }\r\n}\r\n\r\n#[derive(Clone)]\r\npub struct TextMeasure {\r\n    pub info: TextMeasureInfo,\r\n}\r\n\r\nimpl Measure for TextMeasure {\r\n    fn measure(\r\n        &self,\r\n        width: Option<f32>,\r\n        height: Option<f32>,\r\n        available_width: AvailableSpace,\r\n        _available_height: AvailableSpace,\r\n    ) -> Vec2 {\r\n        let x = width.unwrap_or_else(|| match available_width {\r\n            AvailableSpace::Definite(x) => {\r\n                // It is possible for the \"min content width\" to be larger than\r\n                // the \"max content width\" when soft-wrapping right-aligned text\r\n                // and possibly other situations.\r\n\r\n                x.max(self.info.min.x).min(self.info.max.x)\r\n            }\r\n            AvailableSpace::MinContent => self.info.min.x,\r\n            AvailableSpace::MaxContent => self.info.max.x,\r\n        });\r\n\r\n        height\r\n            .map_or_else(\r\n                || match available_width {\r\n                    AvailableSpace::Definite(_) => self.info.compute_size(Vec2::new(x, f32::MAX)),\r\n                    AvailableSpace::MinContent => Vec2::new(x, self.info.min.y),\r\n                    AvailableSpace::MaxContent => Vec2::new(x, self.info.max.y),\r\n                },\r\n                |y| Vec2::new(x, y),\r\n            )\r\n            .ceil()\r\n    }\r\n}\r\n\r\n#[inline]\r\nfn create_text_measure(\r\n    fonts: &Assets<Font>,\r\n    scale_factor: f32,\r\n    text: Ref<Text>,\r\n    mut content_size: Mut<ContentSize>,\r\n    mut text_flags: Mut<TextFlags>,\r\n) {\r\n    match TextMeasureInfo::from_text(&text, fonts, scale_factor) {\r\n        Ok(measure) => {\r\n            if text.linebreak_behavior == BreakLineOn::NoWrap {\r\n                content_size.set(FixedMeasure { size: measure.max });\r\n            } else {\r\n                content_size.set(TextMeasure { info: measure });\r\n            }\r\n\r\n            // Text measure func created successfully, so set `TextFlags` to schedule a recompute\r\n            text_flags.needs_new_measure_func = false;\r\n            text_flags.needs_recompute = true;\r\n        }\r\n        Err(TextError::NoSuchFont) => {\r\n            // Try again next frame\r\n            text_flags.needs_new_measure_func = true;\r\n        }\r\n        Err(e @ TextError::FailedToAddGlyph(_)) => {\r\n            panic!(\"Fatal error when processing text: {e}.\");\r\n        }\r\n    };\r\n}\r\n\r\n/// Generates a new [`Measure`] for a text node on changes to its [`Text`] component.\r\n/// A `Measure` is used by the UI's layout algorithm to determine the appropriate amount of space\r\n/// to provide for the text given the fonts, the text itself and the constraints of the layout.\r\n///\r\n/// * All measures are regenerated if the primary window's scale factor or [`UiScale`] is changed.\r\n/// * Changes that only modify the colors of a `Text` do not require a new `Measure`. This system\r\n/// is only able to detect that a `Text` component has changed and will regenerate the `Measure` on\r\n/// color changes. This can be expensive, particularly for large blocks of text, and the [`bypass_change_detection`](bevy_ecs::change_detection::DetectChangesMut::bypass_change_detection)\r\n/// method should be called when only changing the `Text`'s colors.\r\npub fn measure_text_system(\r\n    mut last_scale_factor: Local<f32>,\r\n    fonts: Res<Assets<Font>>,\r\n    windows: Query<&Window, With<PrimaryWindow>>,\r\n    ui_scale: Res<UiScale>,\r\n    mut text_query: Query<(Ref<Text>, &mut ContentSize, &mut TextFlags), With<Node>>,\r\n) {\r\n    let window_scale_factor = windows\r\n        .get_single()\r\n        .map(|window| window.resolution.scale_factor())\r\n        .unwrap_or(1.);\r\n\r\n    let scale_factor = ui_scale.0 * window_scale_factor;\r\n\r\n    #[allow(clippy::float_cmp)]\r\n    if *last_scale_factor == scale_factor {\r\n        // scale factor unchanged, only create new measure funcs for modified text\r\n        for (text, content_size, text_flags) in &mut text_query {\r\n            if text.is_changed() || text_flags.needs_new_measure_func || content_size.is_added() {\r\n                create_text_measure(&fonts, scale_factor, text, content_size, text_flags);\r\n            }\r\n        }\r\n    } else {\r\n        // scale factor changed, create new measure funcs for all text\r\n        *last_scale_factor = scale_factor;\r\n\r\n        for (text, content_size, text_flags) in &mut text_query {\r\n            create_text_measure(&fonts, scale_factor, text, content_size, text_flags);\r\n        }\r\n    }\r\n}\r\n\r\n#[allow(clippy::too_many_arguments)]\r\n#[inline]\r\nfn queue_text(\r\n    fonts: &Assets<Font>,\r\n    text_pipeline: &mut TextPipeline,\r\n    font_atlas_sets: &mut FontAtlasSets,\r\n    texture_atlases: &mut Assets<TextureAtlasLayout>,\r\n    textures: &mut Assets<Image>,\r\n    text_settings: &TextSettings,\r\n    scale_factor: f32,\r\n    inverse_scale_factor: f32,\r\n    text: &Text,\r\n    node: Ref<Node>,\r\n    mut text_flags: Mut<TextFlags>,\r\n    mut text_layout_info: Mut<TextLayoutInfo>,\r\n) {\r\n    // Skip the text node if it is waiting for a new measure func\r\n    if !text_flags.needs_new_measure_func {\r\n        let physical_node_size = if text.linebreak_behavior == BreakLineOn::NoWrap {\r\n            // With `NoWrap` set, no constraints are placed on the width of the text.\r\n            Vec2::splat(f32::INFINITY)\r\n        } else {\r\n            // `scale_factor` is already multiplied by `UiScale`\r\n            Vec2::new(\r\n                node.unrounded_size.x * scale_factor,\r\n                node.unrounded_size.y * scale_factor,\r\n            )\r\n        };\r\n\r\n        match text_pipeline.queue_text(\r\n            fonts,\r\n            &text.sections,\r\n            scale_factor,\r\n            text.justify,\r\n            text.linebreak_behavior,\r\n            physical_node_size,\r\n            font_atlas_sets,\r\n            texture_atlases,\r\n            textures,\r\n            text_settings,\r\n            YAxisOrientation::TopToBottom,\r\n        ) {\r\n            Err(TextError::NoSuchFont) => {\r\n                // There was an error processing the text layout, try again next frame\r\n                text_flags.needs_recompute = true;\r\n            }\r\n            Err(e @ TextError::FailedToAddGlyph(_)) => {\r\n                panic!(\"Fatal error when processing text: {e}.\");\r\n            }\r\n            Ok(mut info) => {\r\n                info.logical_size.x = scale_value(info.logical_size.x, inverse_scale_factor);\r\n                info.logical_size.y = scale_value(info.logical_size.y, inverse_scale_factor);\r\n                *text_layout_info = info;\r\n                text_flags.needs_recompute = false;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/// Updates the layout and size information for a UI text node on changes to the size value of its [`Node`] component,\r\n/// or when the `needs_recompute` field of [`TextFlags`] is set to true.\r\n/// This information is computed by the [`TextPipeline`] and then stored in [`TextLayoutInfo`].\r\n///\r\n/// ## World Resources\r\n///\r\n/// [`ResMut<Assets<Image>>`](Assets<Image>) -- This system only adds new [`Image`] assets.\r\n/// It does not modify or observe existing ones. The exception is when adding new glyphs to a [`bevy_text::FontAtlas`].\r\n#[allow(clippy::too_many_arguments)]\r\npub fn text_system(\r\n    mut textures: ResMut<Assets<Image>>,\r\n    mut last_scale_factor: Local<f32>,\r\n    fonts: Res<Assets<Font>>,\r\n    windows: Query<&Window, With<PrimaryWindow>>,\r\n    text_settings: Res<TextSettings>,\r\n    ui_scale: Res<UiScale>,\r\n    mut texture_atlases: ResMut<Assets<TextureAtlasLayout>>,\r\n    mut font_atlas_sets: ResMut<FontAtlasSets>,\r\n    mut text_pipeline: ResMut<TextPipeline>,\r\n    mut text_query: Query<(Ref<Node>, &Text, &mut TextLayoutInfo, &mut TextFlags)>,\r\n) {\r\n    // TODO: Support window-independent scaling: https://github.com/bevyengine/bevy/issues/5621\r\n    let window_scale_factor = windows\r\n        .get_single()\r\n        .map(|window| window.resolution.scale_factor())\r\n        .unwrap_or(1.);\r\n\r\n    let scale_factor = ui_scale.0 * window_scale_factor;\r\n    let inverse_scale_factor = scale_factor.recip();\r\n    if *last_scale_factor == scale_factor {\r\n        // Scale factor unchanged, only recompute text for modified text nodes\r\n        for (node, text, text_layout_info, text_flags) in &mut text_query {\r\n            if node.is_changed() || text_flags.needs_recompute {\r\n                queue_text(\r\n                    &fonts,\r\n                    &mut text_pipeline,\r\n                    &mut font_atlas_sets,\r\n                    &mut texture_atlases,\r\n                    &mut textures,\r\n                    &text_settings,\r\n                    scale_factor,\r\n                    inverse_scale_factor,\r\n                    text,\r\n                    node,\r\n                    text_flags,\r\n                    text_layout_info,\r\n                );\r\n            }\r\n        }\r\n    } else {\r\n        // Scale factor changed, recompute text for all text nodes\r\n        *last_scale_factor = scale_factor;\r\n\r\n        for (node, text, text_layout_info, text_flags) in &mut text_query {\r\n            queue_text(\r\n                &fonts,\r\n                &mut text_pipeline,\r\n                &mut font_atlas_sets,\r\n                &mut texture_atlases,\r\n                &mut textures,\r\n                &text_settings,\r\n                scale_factor,\r\n                inverse_scale_factor,\r\n                text,\r\n                node,\r\n                text_flags,\r\n                text_layout_info,\r\n            );\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\bevy\\crates\\bevy_pbr\\src\\wireframe.rs\r\n\r\n````rust\r\nuse crate::{Material, MaterialPipeline, MaterialPipelineKey, MaterialPlugin};\r\nuse bevy_app::{Plugin, Startup, Update};\r\nuse bevy_asset::{load_internal_asset, Asset, Assets, Handle};\r\nuse bevy_color::{Color, LinearRgba};\r\nuse bevy_ecs::prelude::*;\r\nuse bevy_reflect::{std_traits::ReflectDefault, Reflect, TypePath};\r\nuse bevy_render::{\r\n    extract_resource::ExtractResource, mesh::MeshVertexBufferLayoutRef, prelude::*,\r\n    render_resource::*,\r\n};\r\n\r\npub const WIREFRAME_SHADER_HANDLE: Handle<Shader> = Handle::weak_from_u128(192598014480025766);\r\n\r\n/// A [`Plugin`] that draws wireframes.\r\n///\r\n/// Wireframes currently do not work when using webgl or webgpu.\r\n/// Supported rendering backends:\r\n/// - DX12\r\n/// - Vulkan\r\n/// - Metal\r\n///\r\n/// This is a native only feature.\r\n#[derive(Debug, Default)]\r\npub struct WireframePlugin;\r\nimpl Plugin for WireframePlugin {\r\n    fn build(&self, app: &mut bevy_app::App) {\r\n        load_internal_asset!(\r\n            app,\r\n            WIREFRAME_SHADER_HANDLE,\r\n            \"render/wireframe.wgsl\",\r\n            Shader::from_wgsl\r\n        );\r\n\r\n        app.register_type::<Wireframe>()\r\n            .register_type::<NoWireframe>()\r\n            .register_type::<WireframeConfig>()\r\n            .register_type::<WireframeColor>()\r\n            .init_resource::<WireframeConfig>()\r\n            .add_plugins(MaterialPlugin::<WireframeMaterial>::default())\r\n            .add_systems(Startup, setup_global_wireframe_material)\r\n            .add_systems(\r\n                Update,\r\n                (\r\n                    global_color_changed.run_if(resource_changed::<WireframeConfig>),\r\n                    wireframe_color_changed,\r\n                    // Run `apply_global_wireframe_material` after `apply_wireframe_material` so that the global\r\n                    // wireframe setting is applied to a mesh on the same frame its wireframe marker component is removed.\r\n                    (apply_wireframe_material, apply_global_wireframe_material).chain(),\r\n                ),\r\n            );\r\n    }\r\n}\r\n\r\n/// Enables wireframe rendering for any entity it is attached to.\r\n/// It will ignore the [`WireframeConfig`] global setting.\r\n///\r\n/// This requires the [`WireframePlugin`] to be enabled.\r\n#[derive(Component, Debug, Clone, Default, Reflect, Eq, PartialEq)]\r\n#[reflect(Component, Default)]\r\npub struct Wireframe;\r\n\r\n/// Sets the color of the [`Wireframe`] of the entity it is attached to.\r\n/// If this component is present but there's no [`Wireframe`] component,\r\n/// it will still affect the color of the wireframe when [`WireframeConfig::global`] is set to true.\r\n///\r\n/// This overrides the [`WireframeConfig::default_color`].\r\n#[derive(Component, Debug, Clone, Default, Reflect)]\r\n#[reflect(Component, Default)]\r\npub struct WireframeColor {\r\n    pub color: Color,\r\n}\r\n\r\n/// Disables wireframe rendering for any entity it is attached to.\r\n/// It will ignore the [`WireframeConfig`] global setting.\r\n///\r\n/// This requires the [`WireframePlugin`] to be enabled.\r\n#[derive(Component, Debug, Clone, Default, Reflect, Eq, PartialEq)]\r\n#[reflect(Component, Default)]\r\npub struct NoWireframe;\r\n\r\n#[derive(Resource, Debug, Clone, Default, ExtractResource, Reflect)]\r\n#[reflect(Resource)]\r\npub struct WireframeConfig {\r\n    /// Whether to show wireframes for all meshes.\r\n    /// Can be overridden for individual meshes by adding a [`Wireframe`] or [`NoWireframe`] component.\r\n    pub global: bool,\r\n    /// If [`Self::global`] is set, any [`Entity`] that does not have a [`Wireframe`] component attached to it will have\r\n    /// wireframes using this color. Otherwise, this will be the fallback color for any entity that has a [`Wireframe`],\r\n    /// but no [`WireframeColor`].\r\n    pub default_color: Color,\r\n}\r\n\r\n#[derive(Resource)]\r\nstruct GlobalWireframeMaterial {\r\n    // This handle will be reused when the global config is enabled\r\n    handle: Handle<WireframeMaterial>,\r\n}\r\n\r\nfn setup_global_wireframe_material(\r\n    mut commands: Commands,\r\n    mut materials: ResMut<Assets<WireframeMaterial>>,\r\n    config: Res<WireframeConfig>,\r\n) {\r\n    // Create the handle used for the global material\r\n    commands.insert_resource(GlobalWireframeMaterial {\r\n        handle: materials.add(WireframeMaterial {\r\n            color: config.default_color.into(),\r\n        }),\r\n    });\r\n}\r\n\r\n/// Updates the wireframe material of all entities without a [`WireframeColor`] or without a [`Wireframe`] component\r\nfn global_color_changed(\r\n    config: Res<WireframeConfig>,\r\n    mut materials: ResMut<Assets<WireframeMaterial>>,\r\n    global_material: Res<GlobalWireframeMaterial>,\r\n) {\r\n    if let Some(global_material) = materials.get_mut(&global_material.handle) {\r\n        global_material.color = config.default_color.into();\r\n    }\r\n}\r\n\r\n/// Updates the wireframe material when the color in [`WireframeColor`] changes\r\n#[allow(clippy::type_complexity)]\r\nfn wireframe_color_changed(\r\n    mut materials: ResMut<Assets<WireframeMaterial>>,\r\n    mut colors_changed: Query<\r\n        (&mut Handle<WireframeMaterial>, &WireframeColor),\r\n        (With<Wireframe>, Changed<WireframeColor>),\r\n    >,\r\n) {\r\n    for (mut handle, wireframe_color) in &mut colors_changed {\r\n        *handle = materials.add(WireframeMaterial {\r\n            color: wireframe_color.color.into(),\r\n        });\r\n    }\r\n}\r\n\r\n/// Applies or remove the wireframe material to any mesh with a [`Wireframe`] component, and removes it\r\n/// for any mesh with a [`NoWireframe`] component.\r\nfn apply_wireframe_material(\r\n    mut commands: Commands,\r\n    mut materials: ResMut<Assets<WireframeMaterial>>,\r\n    wireframes: Query<\r\n        (Entity, Option<&WireframeColor>),\r\n        (With<Wireframe>, Without<Handle<WireframeMaterial>>),\r\n    >,\r\n    no_wireframes: Query<Entity, (With<NoWireframe>, With<Handle<WireframeMaterial>>)>,\r\n    mut removed_wireframes: RemovedComponents<Wireframe>,\r\n    global_material: Res<GlobalWireframeMaterial>,\r\n) {\r\n    for e in removed_wireframes.read().chain(no_wireframes.iter()) {\r\n        if let Some(mut commands) = commands.get_entity(e) {\r\n            commands.remove::<Handle<WireframeMaterial>>();\r\n        }\r\n    }\r\n\r\n    let mut wireframes_to_spawn = vec![];\r\n    for (e, wireframe_color) in &wireframes {\r\n        let material = if let Some(wireframe_color) = wireframe_color {\r\n            materials.add(WireframeMaterial {\r\n                color: wireframe_color.color.into(),\r\n            })\r\n        } else {\r\n            // If there's no color specified we can use the global material since it's already set to use the default_color\r\n            global_material.handle.clone()\r\n        };\r\n        wireframes_to_spawn.push((e, material));\r\n    }\r\n    commands.insert_or_spawn_batch(wireframes_to_spawn);\r\n}\r\n\r\ntype WireframeFilter = (With<Handle<Mesh>>, Without<Wireframe>, Without<NoWireframe>);\r\n\r\n/// Applies or removes a wireframe material on any mesh without a [`Wireframe`] or [`NoWireframe`] component.\r\nfn apply_global_wireframe_material(\r\n    mut commands: Commands,\r\n    config: Res<WireframeConfig>,\r\n    meshes_without_material: Query<Entity, (WireframeFilter, Without<Handle<WireframeMaterial>>)>,\r\n    meshes_with_global_material: Query<Entity, (WireframeFilter, With<Handle<WireframeMaterial>>)>,\r\n    global_material: Res<GlobalWireframeMaterial>,\r\n) {\r\n    if config.global {\r\n        let mut material_to_spawn = vec![];\r\n        for e in &meshes_without_material {\r\n            // We only add the material handle but not the Wireframe component\r\n            // This makes it easy to detect which mesh is using the global material and which ones are user specified\r\n            material_to_spawn.push((e, global_material.handle.clone()));\r\n        }\r\n        commands.insert_or_spawn_batch(material_to_spawn);\r\n    } else {\r\n        for e in &meshes_with_global_material {\r\n            commands.entity(e).remove::<Handle<WireframeMaterial>>();\r\n        }\r\n    }\r\n}\r\n\r\n#[derive(Default, AsBindGroup, TypePath, Debug, Clone, Asset)]\r\npub struct WireframeMaterial {\r\n    #[uniform(0)]\r\n    pub color: LinearRgba,\r\n}\r\n\r\nimpl Material for WireframeMaterial {\r\n    fn fragment_shader() -> ShaderRef {\r\n        WIREFRAME_SHADER_HANDLE.into()\r\n    }\r\n\r\n    fn specialize(\r\n        _pipeline: &MaterialPipeline<Self>,\r\n        descriptor: &mut RenderPipelineDescriptor,\r\n        _layout: &MeshVertexBufferLayoutRef,\r\n        _key: MaterialPipelineKey<Self>,\r\n    ) -> Result<(), SpecializedMeshPipelineError> {\r\n        descriptor.primitive.polygon_mode = PolygonMode::Line;\r\n        descriptor.depth_stencil.as_mut().unwrap().bias.slope_scale = 1.0;\r\n        Ok(())\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\bevy\\crates\\bevy_render\\src\\view\\window\\screenshot.rs\r\n\r\n````rust\r\nuse std::{borrow::Cow, path::Path, sync::PoisonError};\r\n\r\nuse bevy_app::Plugin;\r\nuse bevy_asset::{load_internal_asset, Handle};\r\nuse bevy_ecs::{entity::EntityHashMap, prelude::*};\r\nuse bevy_tasks::AsyncComputeTaskPool;\r\nuse bevy_utils::tracing::{error, info, info_span};\r\nuse std::sync::Mutex;\r\nuse thiserror::Error;\r\nuse wgpu::{\r\n    CommandEncoder, Extent3d, ImageDataLayout, TextureFormat, COPY_BYTES_PER_ROW_ALIGNMENT,\r\n};\r\n\r\nuse crate::{\r\n    prelude::{Image, Shader},\r\n    render_asset::RenderAssetUsages,\r\n    render_resource::{\r\n        binding_types::texture_2d, BindGroup, BindGroupLayout, BindGroupLayoutEntries, Buffer,\r\n        CachedRenderPipelineId, FragmentState, PipelineCache, RenderPipelineDescriptor,\r\n        SpecializedRenderPipeline, SpecializedRenderPipelines, Texture, VertexState,\r\n    },\r\n    renderer::RenderDevice,\r\n    texture::TextureFormatPixelInfo,\r\n    RenderApp,\r\n};\r\n\r\nuse super::ExtractedWindows;\r\n\r\npub type ScreenshotFn = Box<dyn FnOnce(Image) + Send + Sync>;\r\n\r\n/// A resource which allows for taking screenshots of the window.\r\n#[derive(Resource, Default)]\r\npub struct ScreenshotManager {\r\n    // this is in a mutex to enable extraction with only an immutable reference\r\n    pub(crate) callbacks: Mutex<EntityHashMap<ScreenshotFn>>,\r\n}\r\n\r\n#[derive(Error, Debug)]\r\n#[error(\"A screenshot for this window has already been requested.\")]\r\npub struct ScreenshotAlreadyRequestedError;\r\n\r\nimpl ScreenshotManager {\r\n    /// Signals the renderer to take a screenshot of this frame.\r\n    ///\r\n    /// The given callback will eventually be called on one of the [`AsyncComputeTaskPool`]s threads.\r\n    pub fn take_screenshot(\r\n        &mut self,\r\n        window: Entity,\r\n        callback: impl FnOnce(Image) + Send + Sync + 'static,\r\n    ) -> Result<(), ScreenshotAlreadyRequestedError> {\r\n        self.callbacks\r\n            .get_mut()\r\n            .unwrap_or_else(PoisonError::into_inner)\r\n            .try_insert(window, Box::new(callback))\r\n            .map(|_| ())\r\n            .map_err(|_| ScreenshotAlreadyRequestedError)\r\n    }\r\n\r\n    /// Signals the renderer to take a screenshot of this frame.\r\n    ///\r\n    /// The screenshot will eventually be saved to the given path, and the format will be derived from the extension.\r\n    pub fn save_screenshot_to_disk(\r\n        &mut self,\r\n        window: Entity,\r\n        path: impl AsRef<Path>,\r\n    ) -> Result<(), ScreenshotAlreadyRequestedError> {\r\n        let path = path.as_ref().to_owned();\r\n        self.take_screenshot(window, move |img| match img.try_into_dynamic() {\r\n            Ok(dyn_img) => match image::ImageFormat::from_path(&path) {\r\n                Ok(format) => {\r\n                    // discard the alpha channel which stores brightness values when HDR is enabled to make sure\r\n                    // the screenshot looks right\r\n                    let img = dyn_img.to_rgb8();\r\n                    #[cfg(not(target_arch = \"wasm32\"))]\r\n                    match img.save_with_format(&path, format) {\r\n                        Ok(_) => info!(\"Screenshot saved to {}\", path.display()),\r\n                        Err(e) => error!(\"Cannot save screenshot, IO error: {e}\"),\r\n                    }\r\n\r\n                    #[cfg(target_arch = \"wasm32\")]\r\n                    {\r\n                        match (|| {\r\n                            use image::EncodableLayout;\r\n                            use wasm_bindgen::{JsCast, JsValue};\r\n\r\n                            let mut image_buffer = std::io::Cursor::new(Vec::new());\r\n                            img.write_to(&mut image_buffer, format)\r\n                                .map_err(|e| JsValue::from_str(&format!(\"{e}\")))?;\r\n                            // SAFETY: `image_buffer` only exist in this closure, and is not used after this line\r\n                            let parts = js_sys::Array::of1(&unsafe {\r\n                                js_sys::Uint8Array::view(image_buffer.into_inner().as_bytes())\r\n                                    .into()\r\n                            });\r\n                            let blob = web_sys::Blob::new_with_u8_array_sequence(&parts)?;\r\n                            let url = web_sys::Url::create_object_url_with_blob(&blob)?;\r\n                            let window = web_sys::window().unwrap();\r\n                            let document = window.document().unwrap();\r\n                            let link = document.create_element(\"a\")?;\r\n                            link.set_attribute(\"href\", &url)?;\r\n                            link.set_attribute(\r\n                                \"download\",\r\n                                path.file_name()\r\n                                    .and_then(|filename| filename.to_str())\r\n                                    .ok_or_else(|| JsValue::from_str(\"Invalid filename\"))?,\r\n                            )?;\r\n                            let html_element = link.dyn_into::<web_sys::HtmlElement>()?;\r\n                            html_element.click();\r\n                            web_sys::Url::revoke_object_url(&url)?;\r\n                            Ok::<(), JsValue>(())\r\n                        })() {\r\n                            Ok(_) => info!(\"Screenshot saved to {}\", path.display()),\r\n                            Err(e) => error!(\"Cannot save screenshot, error: {e:?}\"),\r\n                        };\r\n                    }\r\n                }\r\n                Err(e) => error!(\"Cannot save screenshot, requested format not recognized: {e}\"),\r\n            },\r\n            Err(e) => error!(\"Cannot save screenshot, screen format cannot be understood: {e}\"),\r\n        })\r\n    }\r\n}\r\n\r\npub struct ScreenshotPlugin;\r\n\r\nconst SCREENSHOT_SHADER_HANDLE: Handle<Shader> = Handle::weak_from_u128(11918575842344596158);\r\n\r\nimpl Plugin for ScreenshotPlugin {\r\n    fn build(&self, app: &mut bevy_app::App) {\r\n        app.init_resource::<ScreenshotManager>();\r\n\r\n        load_internal_asset!(\r\n            app,\r\n            SCREENSHOT_SHADER_HANDLE,\r\n            \"screenshot.wgsl\",\r\n            Shader::from_wgsl\r\n        );\r\n    }\r\n\r\n    fn finish(&self, app: &mut bevy_app::App) {\r\n        if let Ok(render_app) = app.get_sub_app_mut(RenderApp) {\r\n            render_app.init_resource::<SpecializedRenderPipelines<ScreenshotToScreenPipeline>>();\r\n        }\r\n    }\r\n}\r\n\r\npub(crate) fn align_byte_size(value: u32) -> u32 {\r\n    value + (COPY_BYTES_PER_ROW_ALIGNMENT - (value % COPY_BYTES_PER_ROW_ALIGNMENT))\r\n}\r\n\r\npub(crate) fn get_aligned_size(width: u32, height: u32, pixel_size: u32) -> u32 {\r\n    height * align_byte_size(width * pixel_size)\r\n}\r\n\r\npub(crate) fn layout_data(width: u32, height: u32, format: TextureFormat) -> ImageDataLayout {\r\n    ImageDataLayout {\r\n        bytes_per_row: if height > 1 {\r\n            // 1 = 1 row\r\n            Some(get_aligned_size(width, 1, format.pixel_size() as u32))\r\n        } else {\r\n            None\r\n        },\r\n        rows_per_image: None,\r\n        ..Default::default()\r\n    }\r\n}\r\n\r\n#[derive(Resource)]\r\npub struct ScreenshotToScreenPipeline {\r\n    pub bind_group_layout: BindGroupLayout,\r\n}\r\n\r\nimpl FromWorld for ScreenshotToScreenPipeline {\r\n    fn from_world(render_world: &mut World) -> Self {\r\n        let device = render_world.resource::<RenderDevice>();\r\n\r\n        let bind_group_layout = device.create_bind_group_layout(\r\n            \"screenshot-to-screen-bgl\",\r\n            &BindGroupLayoutEntries::single(\r\n                wgpu::ShaderStages::FRAGMENT,\r\n                texture_2d(wgpu::TextureSampleType::Float { filterable: false }),\r\n            ),\r\n        );\r\n\r\n        Self { bind_group_layout }\r\n    }\r\n}\r\n\r\nimpl SpecializedRenderPipeline for ScreenshotToScreenPipeline {\r\n    type Key = TextureFormat;\r\n\r\n    fn specialize(&self, key: Self::Key) -> RenderPipelineDescriptor {\r\n        RenderPipelineDescriptor {\r\n            label: Some(Cow::Borrowed(\"screenshot-to-screen\")),\r\n            layout: vec![self.bind_group_layout.clone()],\r\n            vertex: VertexState {\r\n                buffers: vec![],\r\n                shader_defs: vec![],\r\n                entry_point: Cow::Borrowed(\"vs_main\"),\r\n                shader: SCREENSHOT_SHADER_HANDLE,\r\n            },\r\n            primitive: wgpu::PrimitiveState {\r\n                cull_mode: Some(wgpu::Face::Back),\r\n                ..Default::default()\r\n            },\r\n            depth_stencil: None,\r\n            multisample: Default::default(),\r\n            fragment: Some(FragmentState {\r\n                shader: SCREENSHOT_SHADER_HANDLE,\r\n                entry_point: Cow::Borrowed(\"fs_main\"),\r\n                shader_defs: vec![],\r\n                targets: vec![Some(wgpu::ColorTargetState {\r\n                    format: key,\r\n                    blend: None,\r\n                    write_mask: wgpu::ColorWrites::ALL,\r\n                })],\r\n            }),\r\n            push_constant_ranges: Vec::new(),\r\n        }\r\n    }\r\n}\r\n\r\npub struct ScreenshotPreparedState {\r\n    pub texture: Texture,\r\n    pub buffer: Buffer,\r\n    pub bind_group: BindGroup,\r\n    pub pipeline_id: CachedRenderPipelineId,\r\n}\r\n\r\npub(crate) fn submit_screenshot_commands(world: &World, encoder: &mut CommandEncoder) {\r\n    let windows = world.resource::<ExtractedWindows>();\r\n    let pipelines = world.resource::<PipelineCache>();\r\n\r\n    for window in windows.values() {\r\n        if let Some(memory) = &window.screenshot_memory {\r\n            let width = window.physical_width;\r\n            let height = window.physical_height;\r\n            let texture_format = window.swap_chain_texture_format.unwrap();\r\n\r\n            encoder.copy_texture_to_buffer(\r\n                memory.texture.as_image_copy(),\r\n                wgpu::ImageCopyBuffer {\r\n                    buffer: &memory.buffer,\r\n                    layout: layout_data(width, height, texture_format),\r\n                },\r\n                Extent3d {\r\n                    width,\r\n                    height,\r\n                    ..Default::default()\r\n                },\r\n            );\r\n            if let Some(pipeline) = pipelines.get_render_pipeline(memory.pipeline_id) {\r\n                let true_swapchain_texture_view = window\r\n                    .swap_chain_texture\r\n                    .as_ref()\r\n                    .unwrap()\r\n                    .texture\r\n                    .create_view(&Default::default());\r\n                let mut pass = encoder.begin_render_pass(&wgpu::RenderPassDescriptor {\r\n                    label: Some(\"screenshot_to_screen_pass\"),\r\n                    color_attachments: &[Some(wgpu::RenderPassColorAttachment {\r\n                        view: &true_swapchain_texture_view,\r\n                        resolve_target: None,\r\n                        ops: wgpu::Operations {\r\n                            load: wgpu::LoadOp::Load,\r\n                            store: wgpu::StoreOp::Store,\r\n                        },\r\n                    })],\r\n                    depth_stencil_attachment: None,\r\n                    timestamp_writes: None,\r\n                    occlusion_query_set: None,\r\n                });\r\n                pass.set_pipeline(pipeline);\r\n                pass.set_bind_group(0, &memory.bind_group, &[]);\r\n                pass.draw(0..3, 0..1);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\npub(crate) fn collect_screenshots(world: &mut World) {\r\n    let _span = info_span!(\"collect_screenshots\");\r\n\r\n    let mut windows = world.resource_mut::<ExtractedWindows>();\r\n    for window in windows.values_mut() {\r\n        if let Some(screenshot_func) = window.screenshot_func.take() {\r\n            let width = window.physical_width;\r\n            let height = window.physical_height;\r\n            let texture_format = window.swap_chain_texture_format.unwrap();\r\n            let pixel_size = texture_format.pixel_size();\r\n            let ScreenshotPreparedState { buffer, .. } = window.screenshot_memory.take().unwrap();\r\n\r\n            let finish = async move {\r\n                let (tx, rx) = async_channel::bounded(1);\r\n                let buffer_slice = buffer.slice(..);\r\n                // The polling for this map call is done every frame when the command queue is submitted.\r\n                buffer_slice.map_async(wgpu::MapMode::Read, move |result| {\r\n                    let err = result.err();\r\n                    if err.is_some() {\r\n                        panic!(\"{}\", err.unwrap().to_string());\r\n                    }\r\n                    tx.try_send(()).unwrap();\r\n                });\r\n                rx.recv().await.unwrap();\r\n                let data = buffer_slice.get_mapped_range();\r\n                // we immediately move the data to CPU memory to avoid holding the mapped view for long\r\n                let mut result = Vec::from(&*data);\r\n                drop(data);\r\n                drop(buffer);\r\n\r\n                if result.len() != ((width * height) as usize * pixel_size) {\r\n                    // Our buffer has been padded because we needed to align to a multiple of 256.\r\n                    // We remove this padding here\r\n                    let initial_row_bytes = width as usize * pixel_size;\r\n                    let buffered_row_bytes = align_byte_size(width * pixel_size as u32) as usize;\r\n\r\n                    let mut take_offset = buffered_row_bytes;\r\n                    let mut place_offset = initial_row_bytes;\r\n                    for _ in 1..height {\r\n                        result.copy_within(\r\n                            take_offset..take_offset + buffered_row_bytes,\r\n                            place_offset,\r\n                        );\r\n                        take_offset += buffered_row_bytes;\r\n                        place_offset += initial_row_bytes;\r\n                    }\r\n                    result.truncate(initial_row_bytes * height as usize);\r\n                }\r\n\r\n                screenshot_func(Image::new(\r\n                    Extent3d {\r\n                        width,\r\n                        height,\r\n                        depth_or_array_layers: 1,\r\n                    },\r\n                    wgpu::TextureDimension::D2,\r\n                    result,\r\n                    texture_format,\r\n                    RenderAssetUsages::RENDER_WORLD,\r\n                ));\r\n            };\r\n\r\n            AsyncComputeTaskPool::get().spawn(finish).detach();\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\bevy\\crates\\bevy_winit\\src\\accessibility.rs\r\n\r\n````rust\r\n//! Helpers for mapping window entities to accessibility types\r\n\r\nuse std::{\r\n    collections::VecDeque,\r\n    sync::{Arc, Mutex},\r\n};\r\n\r\nuse accesskit_winit::Adapter;\r\nuse bevy_a11y::{\r\n    accesskit::{\r\n        ActionHandler, ActionRequest, NodeBuilder, NodeClassSet, NodeId, Role, TreeUpdate,\r\n    },\r\n    AccessibilityNode, AccessibilityRequested, AccessibilitySystem, Focus,\r\n};\r\nuse bevy_a11y::{ActionRequest as ActionRequestWrapper, ManageAccessibilityUpdates};\r\nuse bevy_app::{App, Plugin, PostUpdate};\r\nuse bevy_derive::{Deref, DerefMut};\r\nuse bevy_ecs::entity::EntityHashMap;\r\nuse bevy_ecs::{\r\n    prelude::{DetectChanges, Entity, EventReader, EventWriter},\r\n    query::With,\r\n    schedule::IntoSystemConfigs,\r\n    system::{NonSend, NonSendMut, Query, Res, ResMut, Resource},\r\n};\r\nuse bevy_hierarchy::{Children, Parent};\r\nuse bevy_window::{PrimaryWindow, Window, WindowClosed};\r\n\r\n/// Maps window entities to their `AccessKit` [`Adapter`]s.\r\n#[derive(Default, Deref, DerefMut)]\r\npub struct AccessKitAdapters(pub EntityHashMap<Adapter>);\r\n\r\n/// Maps window entities to their respective [`WinitActionHandler`]s.\r\n#[derive(Resource, Default, Deref, DerefMut)]\r\npub struct WinitActionHandlers(pub EntityHashMap<WinitActionHandler>);\r\n\r\n/// Forwards `AccessKit` [`ActionRequest`]s from winit to an event channel.\r\n#[derive(Clone, Default, Deref, DerefMut)]\r\npub struct WinitActionHandler(pub Arc<Mutex<VecDeque<ActionRequest>>>);\r\n\r\nimpl ActionHandler for WinitActionHandler {\r\n    fn do_action(&mut self, request: ActionRequest) {\r\n        let mut requests = self.0.lock().unwrap();\r\n        requests.push_back(request);\r\n    }\r\n}\r\n\r\nfn window_closed(\r\n    mut adapters: NonSendMut<AccessKitAdapters>,\r\n    mut receivers: ResMut<WinitActionHandlers>,\r\n    mut events: EventReader<WindowClosed>,\r\n) {\r\n    for WindowClosed { window, .. } in events.read() {\r\n        adapters.remove(window);\r\n        receivers.remove(window);\r\n    }\r\n}\r\n\r\nfn poll_receivers(\r\n    handlers: Res<WinitActionHandlers>,\r\n    mut actions: EventWriter<ActionRequestWrapper>,\r\n) {\r\n    for (_id, handler) in handlers.iter() {\r\n        let mut handler = handler.lock().unwrap();\r\n        while let Some(event) = handler.pop_front() {\r\n            actions.send(ActionRequestWrapper(event));\r\n        }\r\n    }\r\n}\r\n\r\nfn should_update_accessibility_nodes(\r\n    accessibility_requested: Res<AccessibilityRequested>,\r\n    manage_accessibility_updates: Res<ManageAccessibilityUpdates>,\r\n) -> bool {\r\n    accessibility_requested.get() && manage_accessibility_updates.get()\r\n}\r\n\r\nfn update_accessibility_nodes(\r\n    adapters: NonSend<AccessKitAdapters>,\r\n    focus: Res<Focus>,\r\n    primary_window: Query<(Entity, &Window), With<PrimaryWindow>>,\r\n    nodes: Query<(\r\n        Entity,\r\n        &AccessibilityNode,\r\n        Option<&Children>,\r\n        Option<&Parent>,\r\n    )>,\r\n    node_entities: Query<Entity, With<AccessibilityNode>>,\r\n) {\r\n    let Ok((primary_window_id, primary_window)) = primary_window.get_single() else {\r\n        return;\r\n    };\r\n    let Some(adapter) = adapters.get(&primary_window_id) else {\r\n        return;\r\n    };\r\n    if focus.is_changed() || !nodes.is_empty() {\r\n        adapter.update_if_active(|| {\r\n            update_adapter(\r\n                nodes,\r\n                node_entities,\r\n                primary_window,\r\n                primary_window_id,\r\n                focus,\r\n            )\r\n        });\r\n    }\r\n}\r\n\r\nfn update_adapter(\r\n    nodes: Query<(\r\n        Entity,\r\n        &AccessibilityNode,\r\n        Option<&Children>,\r\n        Option<&Parent>,\r\n    )>,\r\n    node_entities: Query<Entity, With<AccessibilityNode>>,\r\n    primary_window: &Window,\r\n    primary_window_id: Entity,\r\n    focus: Res<Focus>,\r\n) -> TreeUpdate {\r\n    let mut to_update = vec![];\r\n    let mut window_children = vec![];\r\n    for (entity, node, children, parent) in &nodes {\r\n        let mut node = (**node).clone();\r\n        queue_node_for_update(entity, parent, &node_entities, &mut window_children);\r\n        add_children_nodes(children, &node_entities, &mut node);\r\n        let node_id = NodeId(entity.to_bits());\r\n        let node = node.build(&mut NodeClassSet::lock_global());\r\n        to_update.push((node_id, node));\r\n    }\r\n    let mut window_node = NodeBuilder::new(Role::Window);\r\n    if primary_window.focused {\r\n        let title = primary_window.title.clone();\r\n        window_node.set_name(title.into_boxed_str());\r\n    }\r\n    window_node.set_children(window_children);\r\n    let window_node = window_node.build(&mut NodeClassSet::lock_global());\r\n    let node_id = NodeId(primary_window_id.to_bits());\r\n    let window_update = (node_id, window_node);\r\n    to_update.insert(0, window_update);\r\n    TreeUpdate {\r\n        nodes: to_update,\r\n        tree: None,\r\n        focus: NodeId(focus.unwrap_or(primary_window_id).to_bits()),\r\n    }\r\n}\r\n\r\n#[inline]\r\nfn queue_node_for_update(\r\n    node_entity: Entity,\r\n    parent: Option<&Parent>,\r\n    node_entities: &Query<Entity, With<AccessibilityNode>>,\r\n    window_children: &mut Vec<NodeId>,\r\n) {\r\n    let should_push = if let Some(parent) = parent {\r\n        !node_entities.contains(parent.get())\r\n    } else {\r\n        true\r\n    };\r\n    if should_push {\r\n        window_children.push(NodeId(node_entity.to_bits()));\r\n    }\r\n}\r\n\r\n#[inline]\r\nfn add_children_nodes(\r\n    children: Option<&Children>,\r\n    node_entities: &Query<Entity, With<AccessibilityNode>>,\r\n    node: &mut NodeBuilder,\r\n) {\r\n    let Some(children) = children else {\r\n        return;\r\n    };\r\n    for child in children {\r\n        if node_entities.contains(*child) {\r\n            node.push_child(NodeId(child.to_bits()));\r\n        }\r\n    }\r\n}\r\n\r\n/// Implements winit-specific `AccessKit` functionality.\r\npub struct AccessKitPlugin;\r\n\r\nimpl Plugin for AccessKitPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.init_non_send_resource::<AccessKitAdapters>()\r\n            .init_resource::<WinitActionHandlers>()\r\n            .add_event::<ActionRequestWrapper>()\r\n            .add_systems(\r\n                PostUpdate,\r\n                (\r\n                    poll_receivers,\r\n                    update_accessibility_nodes.run_if(should_update_accessibility_nodes),\r\n                    window_closed\r\n                        .before(poll_receivers)\r\n                        .before(update_accessibility_nodes),\r\n                )\r\n                    .in_set(AccessibilitySystem::Update),\r\n            );\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\bevy\\crates\\bevy_window\\src\\system.rs\r\n\r\n````rust\r\nuse crate::{PrimaryWindow, Window, WindowCloseRequested};\r\n\r\nuse bevy_app::AppExit;\r\nuse bevy_ecs::prelude::*;\r\nuse bevy_input::{keyboard::KeyCode, ButtonInput};\r\n\r\n/// Exit the application when there are no open windows.\r\n///\r\n/// This system is added by the [`WindowPlugin`] in the default configuration.\r\n/// To disable this behavior, set `close_when_requested` (on the [`WindowPlugin`]) to `false`.\r\n/// Ensure that you read the caveats documented on that field if doing so.\r\n///\r\n/// [`WindowPlugin`]: crate::WindowPlugin\r\npub fn exit_on_all_closed(mut app_exit_events: EventWriter<AppExit>, windows: Query<&Window>) {\r\n    if windows.is_empty() {\r\n        bevy_utils::tracing::info!(\"No windows are open, exiting\");\r\n        app_exit_events.send(AppExit);\r\n    }\r\n}\r\n\r\n/// Exit the application when the primary window has been closed\r\n///\r\n/// This system is added by the [`WindowPlugin`]\r\n///\r\n/// [`WindowPlugin`]: crate::WindowPlugin\r\npub fn exit_on_primary_closed(\r\n    mut app_exit_events: EventWriter<AppExit>,\r\n    windows: Query<(), (With<Window>, With<PrimaryWindow>)>,\r\n) {\r\n    if windows.is_empty() {\r\n        bevy_utils::tracing::info!(\"Primary window was closed, exiting\");\r\n        app_exit_events.send(AppExit);\r\n    }\r\n}\r\n\r\n/// Close windows in response to [`WindowCloseRequested`] (e.g.  when the close button is pressed).\r\n///\r\n/// This system is added by the [`WindowPlugin`] in the default configuration.\r\n/// To disable this behavior, set `close_when_requested` (on the [`WindowPlugin`]) to `false`.\r\n/// Ensure that you read the caveats documented on that field if doing so.\r\n///\r\n/// [`WindowPlugin`]: crate::WindowPlugin\r\npub fn close_when_requested(mut commands: Commands, mut closed: EventReader<WindowCloseRequested>) {\r\n    for event in closed.read() {\r\n        commands.entity(event.window).despawn();\r\n    }\r\n}\r\n\r\n/// Close the focused window whenever the escape key (<kbd>Esc</kbd>) is pressed\r\n///\r\n/// This is useful for examples or prototyping.\r\npub fn close_on_esc(\r\n    mut commands: Commands,\r\n    focused_windows: Query<(Entity, &Window)>,\r\n    input: Res<ButtonInput<KeyCode>>,\r\n) {\r\n    for (window, focus) in focused_windows.iter() {\r\n        if !focus.focused {\r\n            continue;\r\n        }\r\n\r\n        if input.just_pressed(KeyCode::Escape) {\r\n            commands.entity(window).despawn();\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\bevy\\crates\\bevy_window\\src\\window.rs\r\n\r\n````rust\r\nuse bevy_ecs::{\r\n    entity::{Entity, EntityMapper, MapEntities},\r\n    prelude::{Component, ReflectComponent},\r\n};\r\nuse bevy_math::{DVec2, IVec2, UVec2, Vec2};\r\nuse bevy_reflect::{std_traits::ReflectDefault, Reflect};\r\n\r\n#[cfg(feature = \"serialize\")]\r\nuse bevy_reflect::{ReflectDeserialize, ReflectSerialize};\r\n\r\nuse bevy_utils::tracing::warn;\r\n\r\nuse crate::CursorIcon;\r\n\r\n/// Marker [`Component`] for the window considered the primary window.\r\n///\r\n/// Currently this is assumed to only exist on 1 entity at a time.\r\n///\r\n/// [`WindowPlugin`](crate::WindowPlugin) will spawn a [`Window`] entity\r\n/// with this component if [`primary_window`](crate::WindowPlugin::primary_window)\r\n/// is `Some`.\r\n#[derive(Default, Debug, Component, PartialEq, Eq, PartialOrd, Ord, Copy, Clone, Reflect)]\r\n#[reflect(Component)]\r\npub struct PrimaryWindow;\r\n\r\n/// Reference to a [`Window`], whether it be a direct link to a specific entity or\r\n/// a more vague defaulting choice.\r\n#[repr(C)]\r\n#[derive(Default, Copy, Clone, Debug, Reflect)]\r\n#[cfg_attr(\r\n    feature = \"serialize\",\r\n    derive(serde::Serialize, serde::Deserialize),\r\n    reflect(Serialize, Deserialize)\r\n)]\r\npub enum WindowRef {\r\n    /// This will be linked to the primary window that is created by default\r\n    /// in the [`WindowPlugin`](crate::WindowPlugin::primary_window).\r\n    #[default]\r\n    Primary,\r\n    /// A more direct link to a window entity.\r\n    ///\r\n    /// Use this if you want to reference a secondary/tertiary/... window.\r\n    ///\r\n    /// To create a new window you can spawn an entity with a [`Window`],\r\n    /// then you can use that entity here for usage in cameras.\r\n    Entity(Entity),\r\n}\r\n\r\nimpl WindowRef {\r\n    /// Normalize the window reference so that it can be compared to other window references.\r\n    pub fn normalize(&self, primary_window: Option<Entity>) -> Option<NormalizedWindowRef> {\r\n        let entity = match self {\r\n            Self::Primary => primary_window,\r\n            Self::Entity(entity) => Some(*entity),\r\n        };\r\n\r\n        entity.map(NormalizedWindowRef)\r\n    }\r\n}\r\n\r\nimpl MapEntities for WindowRef {\r\n    fn map_entities<M: EntityMapper>(&mut self, entity_mapper: &mut M) {\r\n        match self {\r\n            Self::Entity(entity) => {\r\n                *entity = entity_mapper.map_entity(*entity);\r\n            }\r\n            Self::Primary => {}\r\n        };\r\n    }\r\n}\r\n\r\n/// A flattened representation of a window reference for equality/hashing purposes.\r\n///\r\n/// For most purposes you probably want to use the unnormalized version [`WindowRef`].\r\n#[repr(C)]\r\n#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Reflect)]\r\n#[cfg_attr(\r\n    feature = \"serialize\",\r\n    derive(serde::Serialize, serde::Deserialize),\r\n    reflect(Serialize, Deserialize)\r\n)]\r\npub struct NormalizedWindowRef(Entity);\r\n\r\nimpl NormalizedWindowRef {\r\n    /// Fetch the entity of this window reference\r\n    pub fn entity(&self) -> Entity {\r\n        self.0\r\n    }\r\n}\r\n\r\n/// The defining [`Component`] for window entities,\r\n/// storing information about how it should appear and behave.\r\n///\r\n/// Each window corresponds to an entity, and is uniquely identified by the value of their [`Entity`].\r\n/// When the [`Window`] component is added to an entity, a new window will be opened.\r\n/// When it is removed or the entity is despawned, the window will close.\r\n///\r\n/// The primary window entity (and the corresponding window) is spawned by default\r\n/// by [`WindowPlugin`](crate::WindowPlugin) and is marked with the [`PrimaryWindow`] component.\r\n///\r\n/// This component is synchronized with `winit` through `bevy_winit`:\r\n/// it will reflect the current state of the window and can be modified to change this state.\r\n///\r\n/// # Example\r\n///\r\n/// Because this component is synchronized with `winit`, it can be used to perform\r\n/// OS-integrated windowing operations. For example, here's a simple system\r\n/// to change the cursor type:\r\n///\r\n/// ```\r\n/// # use bevy_ecs::query::With;\r\n/// # use bevy_ecs::system::Query;\r\n/// # use bevy_window::{CursorIcon, PrimaryWindow, Window};\r\n/// fn change_cursor(mut windows: Query<&mut Window, With<PrimaryWindow>>) {\r\n///     // Query returns one window typically.\r\n///     for mut window in windows.iter_mut() {\r\n///         window.cursor.icon = CursorIcon::Wait;\r\n///     }\r\n/// }\r\n/// ```\r\n#[derive(Component, Debug, Clone, Reflect)]\r\n#[cfg_attr(\r\n    feature = \"serialize\",\r\n    derive(serde::Serialize, serde::Deserialize),\r\n    reflect(Serialize, Deserialize)\r\n)]\r\n#[reflect(Component, Default)]\r\npub struct Window {\r\n    /// The cursor of this window.\r\n    pub cursor: Cursor,\r\n    /// What presentation mode to give the window.\r\n    pub present_mode: PresentMode,\r\n    /// Which fullscreen or windowing mode should be used.\r\n    pub mode: WindowMode,\r\n    /// Where the window should be placed.\r\n    pub position: WindowPosition,\r\n    /// What resolution the window should have.\r\n    pub resolution: WindowResolution,\r\n    /// Stores the title of the window.\r\n    pub title: String,\r\n    /// Stores the application ID (on **`Wayland`**), `WM_CLASS` (on **`X11`**) or window class name (on **`Windows`**) of the window.\r\n    ///\r\n    /// For details about application ID conventions, see the [Desktop Entry Spec](https://specifications.freedesktop.org/desktop-entry-spec/desktop-entry-spec-latest.html#desktop-file-id).\r\n    /// For details about `WM_CLASS`, see the [X11 Manual Pages](https://www.x.org/releases/current/doc/man/man3/XAllocClassHint.3.xhtml).\r\n    /// For details about **`Windows`**'s window class names, see [About Window Classes](https://learn.microsoft.com/en-us/windows/win32/winmsg/about-window-classes).\r\n    ///\r\n    /// ## Platform-specific\r\n    ///\r\n    /// - **`Windows`**: Can only be set while building the window, setting the window's window class name.\r\n    /// - **`Wayland`**: Can only be set while building the window, setting the window's application ID.\r\n    /// - **`X11`**: Can only be set while building the window, setting the window's `WM_CLASS`.\r\n    /// - **`macOS`**, **`iOS`**, **`Android`**, and **`Web`**: not applicable.\r\n    ///\r\n    /// Notes: Changing this field during runtime will have no effect for now.\r\n    pub name: Option<String>,\r\n    /// How the alpha channel of textures should be handled while compositing.\r\n    pub composite_alpha_mode: CompositeAlphaMode,\r\n    /// The limits of the window's logical size\r\n    /// (found in its [`resolution`](WindowResolution)) when resizing.\r\n    pub resize_constraints: WindowResizeConstraints,\r\n    /// Should the window be resizable?\r\n    ///\r\n    /// Note: This does not stop the program from fullscreening/setting\r\n    /// the size programmatically.\r\n    pub resizable: bool,\r\n    /// Specifies which window control buttons should be enabled.\r\n    ///\r\n    /// ## Platform-specific\r\n    ///\r\n    /// **`iOS`**, **`Android`**, and the **`Web`** do not have window control buttons.\r\n    ///\r\n    /// On some **`Linux`** environments these values have no effect.\r\n    pub enabled_buttons: EnabledButtons,\r\n    /// Should the window have decorations enabled?\r\n    ///\r\n    /// (Decorations are the minimize, maximize, and close buttons on desktop apps)\r\n    ///\r\n    /// ## Platform-specific\r\n    ///\r\n    /// **`iOS`**, **`Android`**, and the **`Web`** do not have decorations.\r\n    pub decorations: bool,\r\n    /// Should the window be transparent?\r\n    ///\r\n    /// Defines whether the background of the window should be transparent.\r\n    ///\r\n    /// ## Platform-specific\r\n    /// - iOS / Android / Web: Unsupported.\r\n    /// - macOS: Not working as expected.\r\n    ///\r\n    /// macOS transparent works with winit out of the box, so this issue might be related to: <https://github.com/gfx-rs/wgpu/issues/687>.\r\n    /// You should also set the window `composite_alpha_mode` to `CompositeAlphaMode::PostMultiplied`.\r\n    pub transparent: bool,\r\n    /// Get/set whether the window is focused.\r\n    pub focused: bool,\r\n    /// Where should the window appear relative to other overlapping window.\r\n    ///\r\n    /// ## Platform-specific\r\n    ///\r\n    /// - iOS / Android / Web / Wayland: Unsupported.\r\n    pub window_level: WindowLevel,\r\n    /// The \"html canvas\" element selector.\r\n    ///\r\n    /// If set, this selector will be used to find a matching html canvas element,\r\n    /// rather than creating a new one.\r\n    /// Uses the [CSS selector format](https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelector).\r\n    ///\r\n    /// This value has no effect on non-web platforms.\r\n    pub canvas: Option<String>,\r\n    /// Whether or not to fit the canvas element's size to its parent element's size.\r\n    ///\r\n    /// **Warning**: this will not behave as expected for parents that set their size according to the size of their\r\n    /// children. This creates a \"feedback loop\" that will result in the canvas growing on each resize. When using this\r\n    /// feature, ensure the parent's size is not affected by its children.\r\n    ///\r\n    /// This value has no effect on non-web platforms.\r\n    pub fit_canvas_to_parent: bool,\r\n    /// Whether or not to stop events from propagating out of the canvas element\r\n    ///\r\n    ///  When `true`, this will prevent common browser hotkeys like F5, F12, Ctrl+R, tab, etc.\r\n    /// from performing their default behavior while the bevy app has focus.\r\n    ///\r\n    /// This value has no effect on non-web platforms.\r\n    pub prevent_default_event_handling: bool,\r\n    /// Stores internal state that isn't directly accessible.\r\n    pub internal: InternalWindowState,\r\n    /// Should the window use Input Method Editor?\r\n    ///\r\n    /// If enabled, the window will receive [`Ime`](crate::Ime) events instead of\r\n    /// [`ReceivedCharacter`](crate::ReceivedCharacter) or\r\n    /// [`KeyboardInput`](bevy_input::keyboard::KeyboardInput).\r\n    ///\r\n    /// IME should be enabled during text input, but not when you expect to get the exact key pressed.\r\n    ///\r\n    ///  ## Platform-specific\r\n    ///\r\n    /// - iOS / Android / Web: Unsupported.\r\n    pub ime_enabled: bool,\r\n    /// Sets location of IME candidate box in client area coordinates relative to the top left.\r\n    ///\r\n    ///  ## Platform-specific\r\n    ///\r\n    /// - iOS / Android / Web: Unsupported.\r\n    pub ime_position: Vec2,\r\n    /// Sets a specific theme for the window.\r\n    ///\r\n    /// If `None` is provided, the window will use the system theme.\r\n    ///\r\n    /// ## Platform-specific\r\n    ///\r\n    /// - iOS / Android / Web: Unsupported.\r\n    pub window_theme: Option<WindowTheme>,\r\n    /// Sets the window's visibility.\r\n    ///\r\n    /// If `false`, this will hide the window completely, it won't appear on the screen or in the task bar.\r\n    /// If `true`, this will show the window.\r\n    /// Note that this doesn't change its focused or minimized state.\r\n    ///\r\n    /// ## Platform-specific\r\n    ///\r\n    /// - **Android / Wayland / Web:** Unsupported.\r\n    pub visible: bool,\r\n}\r\n\r\nimpl Default for Window {\r\n    fn default() -> Self {\r\n        Self {\r\n            title: \"App\".to_owned(),\r\n            name: None,\r\n            cursor: Default::default(),\r\n            present_mode: Default::default(),\r\n            mode: Default::default(),\r\n            position: Default::default(),\r\n            resolution: Default::default(),\r\n            internal: Default::default(),\r\n            composite_alpha_mode: Default::default(),\r\n            resize_constraints: Default::default(),\r\n            ime_enabled: Default::default(),\r\n            ime_position: Default::default(),\r\n            resizable: true,\r\n            enabled_buttons: Default::default(),\r\n            decorations: true,\r\n            transparent: false,\r\n            focused: true,\r\n            window_level: Default::default(),\r\n            fit_canvas_to_parent: false,\r\n            prevent_default_event_handling: true,\r\n            canvas: None,\r\n            window_theme: None,\r\n            visible: true,\r\n        }\r\n    }\r\n}\r\n\r\nimpl Window {\r\n    /// Setting to true will attempt to maximize the window.\r\n    ///\r\n    /// Setting to false will attempt to un-maximize the window.\r\n    pub fn set_maximized(&mut self, maximized: bool) {\r\n        self.internal.maximize_request = Some(maximized);\r\n    }\r\n\r\n    /// Setting to true will attempt to minimize the window.\r\n    ///\r\n    /// Setting to false will attempt to un-minimize the window.\r\n    pub fn set_minimized(&mut self, minimized: bool) {\r\n        self.internal.minimize_request = Some(minimized);\r\n    }\r\n\r\n    /// The window's client area width in logical pixels.\r\n    ///\r\n    /// See [`WindowResolution`] for an explanation about logical/physical sizes.\r\n    #[inline]\r\n    pub fn width(&self) -> f32 {\r\n        self.resolution.width()\r\n    }\r\n\r\n    /// The window's client area height in logical pixels.\r\n    ///\r\n    /// See [`WindowResolution`] for an explanation about logical/physical sizes.\r\n    #[inline]\r\n    pub fn height(&self) -> f32 {\r\n        self.resolution.height()\r\n    }\r\n\r\n    /// The window's client size in logical pixels\r\n    ///\r\n    /// See [`WindowResolution`] for an explanation about logical/physical sizes.\r\n    #[inline]\r\n    pub fn size(&self) -> Vec2 {\r\n        self.resolution.size()\r\n    }\r\n\r\n    /// The window's client area width in physical pixels.\r\n    ///\r\n    /// See [`WindowResolution`] for an explanation about logical/physical sizes.\r\n    #[inline]\r\n    pub fn physical_width(&self) -> u32 {\r\n        self.resolution.physical_width()\r\n    }\r\n\r\n    /// The window's client area height in physical pixels.\r\n    ///\r\n    /// See [`WindowResolution`] for an explanation about logical/physical sizes.\r\n    #[inline]\r\n    pub fn physical_height(&self) -> u32 {\r\n        self.resolution.physical_height()\r\n    }\r\n\r\n    /// The window's client size in physical pixels\r\n    ///\r\n    /// See [`WindowResolution`] for an explanation about logical/physical sizes.\r\n    #[inline]\r\n    pub fn physical_size(&self) -> bevy_math::UVec2 {\r\n        self.resolution.physical_size()\r\n    }\r\n\r\n    /// The window's scale factor.\r\n    ///\r\n    /// Ratio of physical size to logical size, see [`WindowResolution`].\r\n    #[inline]\r\n    pub fn scale_factor(&self) -> f32 {\r\n        self.resolution.scale_factor()\r\n    }\r\n\r\n    /// The cursor position in this window in logical pixels.\r\n    ///\r\n    /// Returns `None` if the cursor is outside the window area.\r\n    ///\r\n    /// See [`WindowResolution`] for an explanation about logical/physical sizes.\r\n    #[inline]\r\n    pub fn cursor_position(&self) -> Option<Vec2> {\r\n        self.physical_cursor_position()\r\n            .map(|position| (position.as_dvec2() / self.scale_factor() as f64).as_vec2())\r\n    }\r\n\r\n    /// The cursor position in this window in physical pixels.\r\n    ///\r\n    /// Returns `None` if the cursor is outside the window area.\r\n    ///\r\n    /// See [`WindowResolution`] for an explanation about logical/physical sizes.\r\n    #[inline]\r\n    pub fn physical_cursor_position(&self) -> Option<Vec2> {\r\n        match self.internal.physical_cursor_position {\r\n            Some(position) => {\r\n                if position.x >= 0.\r\n                    && position.y >= 0.\r\n                    && position.x < self.physical_width() as f64\r\n                    && position.y < self.physical_height() as f64\r\n                {\r\n                    Some(position.as_vec2())\r\n                } else {\r\n                    None\r\n                }\r\n            }\r\n            None => None,\r\n        }\r\n    }\r\n\r\n    /// Set the cursor position in this window in logical pixels.\r\n    ///\r\n    /// See [`WindowResolution`] for an explanation about logical/physical sizes.\r\n    pub fn set_cursor_position(&mut self, position: Option<Vec2>) {\r\n        self.internal.physical_cursor_position =\r\n            position.map(|p| p.as_dvec2() * self.scale_factor() as f64);\r\n    }\r\n\r\n    /// Set the cursor position in this window in physical pixels.\r\n    ///\r\n    /// See [`WindowResolution`] for an explanation about logical/physical sizes.\r\n    pub fn set_physical_cursor_position(&mut self, position: Option<DVec2>) {\r\n        self.internal.physical_cursor_position = position;\r\n    }\r\n}\r\n\r\n/// The size limits on a [`Window`].\r\n///\r\n/// These values are measured in logical pixels (see [`WindowResolution`]), so the user's\r\n/// scale factor does affect the size limits on the window.\r\n///\r\n/// Please note that if the window is resizable, then when the window is\r\n/// maximized it may have a size outside of these limits. The functionality\r\n/// required to disable maximizing is not yet exposed by winit.\r\n#[derive(Debug, Clone, Copy, PartialEq, Reflect)]\r\n#[cfg_attr(\r\n    feature = \"serialize\",\r\n    derive(serde::Serialize, serde::Deserialize),\r\n    reflect(Serialize, Deserialize)\r\n)]\r\n#[reflect(Debug, PartialEq, Default)]\r\npub struct WindowResizeConstraints {\r\n    /// The minimum width the window can have.\r\n    pub min_width: f32,\r\n    /// The minimum height the window can have.\r\n    pub min_height: f32,\r\n    /// The maximum width the window can have.\r\n    pub max_width: f32,\r\n    /// The maximum height the window can have.\r\n    pub max_height: f32,\r\n}\r\n\r\nimpl Default for WindowResizeConstraints {\r\n    fn default() -> Self {\r\n        Self {\r\n            min_width: 180.,\r\n            min_height: 120.,\r\n            max_width: f32::INFINITY,\r\n            max_height: f32::INFINITY,\r\n        }\r\n    }\r\n}\r\n\r\nimpl WindowResizeConstraints {\r\n    /// Checks if the constraints are valid.\r\n    ///\r\n    /// Will output warnings if it isn't.\r\n    #[must_use]\r\n    pub fn check_constraints(&self) -> Self {\r\n        let WindowResizeConstraints {\r\n            mut min_width,\r\n            mut min_height,\r\n            mut max_width,\r\n            mut max_height,\r\n        } = self;\r\n        min_width = min_width.max(1.);\r\n        min_height = min_height.max(1.);\r\n        if max_width < min_width {\r\n            warn!(\r\n                \"The given maximum width {} is smaller than the minimum width {}\",\r\n                max_width, min_width\r\n            );\r\n            max_width = min_width;\r\n        }\r\n        if max_height < min_height {\r\n            warn!(\r\n                \"The given maximum height {} is smaller than the minimum height {}\",\r\n                max_height, min_height\r\n            );\r\n            max_height = min_height;\r\n        }\r\n        WindowResizeConstraints {\r\n            min_width,\r\n            min_height,\r\n            max_width,\r\n            max_height,\r\n        }\r\n    }\r\n}\r\n\r\n/// Cursor data for a [`Window`].\r\n#[derive(Debug, Copy, Clone, Reflect)]\r\n#[cfg_attr(\r\n    feature = \"serialize\",\r\n    derive(serde::Serialize, serde::Deserialize),\r\n    reflect(Serialize, Deserialize)\r\n)]\r\n#[reflect(Debug, Default)]\r\npub struct Cursor {\r\n    /// What the cursor should look like while inside the window.\r\n    pub icon: CursorIcon,\r\n\r\n    /// Whether the cursor is visible or not.\r\n    ///\r\n    /// ## Platform-specific\r\n    ///\r\n    /// - **`Windows`**, **`X11`**, and **`Wayland`**: The cursor is hidden only when inside the window.\r\n    /// To stop the cursor from leaving the window, change [`Cursor::grab_mode`] to [`CursorGrabMode::Locked`] or [`CursorGrabMode::Confined`]\r\n    /// - **`macOS`**: The cursor is hidden only when the window is focused.\r\n    /// - **`iOS`** and **`Android`** do not have cursors\r\n    pub visible: bool,\r\n\r\n    /// Whether or not the cursor is locked by or confined within the window.\r\n    ///\r\n    /// ## Platform-specific\r\n    ///\r\n    /// - **`Windows`** doesn't support [`CursorGrabMode::Locked`]\r\n    /// - **`macOS`** doesn't support [`CursorGrabMode::Confined`]\r\n    /// - **`iOS/Android`** don't have cursors.\r\n    ///\r\n    /// Since `Windows` and `macOS` have different [`CursorGrabMode`] support, we first try to set the grab mode that was asked for. If it doesn't work then use the alternate grab mode.\r\n    pub grab_mode: CursorGrabMode,\r\n\r\n    /// Set whether or not mouse events within *this* window are captured or fall through to the Window below.\r\n    ///\r\n    /// ## Platform-specific\r\n    ///\r\n    /// - iOS / Android / Web / X11: Unsupported.\r\n    pub hit_test: bool,\r\n}\r\n\r\nimpl Default for Cursor {\r\n    fn default() -> Self {\r\n        Cursor {\r\n            icon: CursorIcon::Default,\r\n            visible: true,\r\n            grab_mode: CursorGrabMode::None,\r\n            hit_test: true,\r\n        }\r\n    }\r\n}\r\n\r\n/// Defines where a [`Window`] should be placed on the screen.\r\n#[derive(Default, Debug, Clone, Copy, PartialEq, Reflect)]\r\n#[cfg_attr(\r\n    feature = \"serialize\",\r\n    derive(serde::Serialize, serde::Deserialize),\r\n    reflect(Serialize, Deserialize)\r\n)]\r\n#[reflect(Debug, PartialEq)]\r\npub enum WindowPosition {\r\n    /// Position will be set by the window manager.\r\n    /// Bevy will delegate this decision to the window manager and no guarantees can be made about where the window will be placed.\r\n    ///\r\n    /// Used at creation but will be changed to [`At`](WindowPosition::At).\r\n    #[default]\r\n    Automatic,\r\n    /// Window will be centered on the selected monitor.\r\n    ///\r\n    /// Note that this does not account for window decorations.\r\n    ///\r\n    /// Used at creation or for update but will be changed to [`At`](WindowPosition::At)\r\n    Centered(MonitorSelection),\r\n    /// The window's top-left corner should be placed at the specified position (in physical pixels).\r\n    ///\r\n    /// (0,0) represents top-left corner of screen space.\r\n    At(IVec2),\r\n}\r\n\r\nimpl WindowPosition {\r\n    /// Creates a new [`WindowPosition`] at a position.\r\n    pub fn new(position: IVec2) -> Self {\r\n        Self::At(position)\r\n    }\r\n\r\n    /// Set the position to a specific point.\r\n    pub fn set(&mut self, position: IVec2) {\r\n        *self = WindowPosition::At(position);\r\n    }\r\n\r\n    /// Set the window to a specific monitor.\r\n    pub fn center(&mut self, monitor: MonitorSelection) {\r\n        *self = WindowPosition::Centered(monitor);\r\n    }\r\n}\r\n\r\n/// Controls the size of a [`Window`]\r\n///\r\n/// ## Physical, logical and requested sizes\r\n///\r\n/// There are three sizes associated with a window:\r\n/// - the physical size,\r\n/// which represents the actual height and width in physical pixels\r\n/// the window occupies on the monitor,\r\n/// - the logical size,\r\n/// which represents the size that should be used to scale elements\r\n/// inside the window, measured in logical pixels,\r\n/// - the requested size,\r\n/// measured in logical pixels, which is the value submitted\r\n/// to the API when creating the window, or requesting that it be resized.\r\n///\r\n/// ## Scale factor\r\n///\r\n/// The reason logical size and physical size are separated and can be different\r\n/// is to account for the cases where:\r\n/// - several monitors have different pixel densities,\r\n/// - the user has set up a pixel density preference in its operating system,\r\n/// - the Bevy `App` has specified a specific scale factor between both.\r\n///\r\n/// The factor between physical size and logical size can be retrieved with\r\n/// [`WindowResolution::scale_factor`].\r\n///\r\n/// For the first two cases, a scale factor is set automatically by the operating\r\n/// system through the window backend. You can get it with\r\n/// [`WindowResolution::base_scale_factor`].\r\n///\r\n/// For the third case, you can override this automatic scale factor with\r\n/// [`WindowResolution::set_scale_factor_override`].\r\n///\r\n/// ## Requested and obtained sizes\r\n///\r\n/// The logical size should be equal to the requested size after creating/resizing,\r\n/// when possible.\r\n/// The reason the requested size and logical size might be different\r\n/// is because the corresponding physical size might exceed limits (either the\r\n/// size limits of the monitor, or limits defined in [`WindowResizeConstraints`]).\r\n///\r\n/// Note: The requested size is not kept in memory, for example requesting a size\r\n/// too big for the screen, making the logical size different from the requested size,\r\n/// and then setting a scale factor that makes the previous requested size within\r\n/// the limits of the screen will not get back that previous requested size.\r\n\r\n#[derive(Debug, Clone, PartialEq, Reflect)]\r\n#[cfg_attr(\r\n    feature = \"serialize\",\r\n    derive(serde::Serialize, serde::Deserialize),\r\n    reflect(Serialize, Deserialize)\r\n)]\r\n#[reflect(Debug, PartialEq, Default)]\r\npub struct WindowResolution {\r\n    /// Width of the window in physical pixels.\r\n    physical_width: u32,\r\n    /// Height of the window in physical pixels.\r\n    physical_height: u32,\r\n    /// Code-provided ratio of physical size to logical size.\r\n    ///\r\n    /// Should be used instead of `scale_factor` when set.\r\n    scale_factor_override: Option<f32>,\r\n    /// OS-provided ratio of physical size to logical size.\r\n    ///\r\n    /// Set automatically depending on the pixel density of the screen.\r\n    scale_factor: f32,\r\n}\r\n\r\nimpl Default for WindowResolution {\r\n    fn default() -> Self {\r\n        WindowResolution {\r\n            physical_width: 1280,\r\n            physical_height: 720,\r\n            scale_factor_override: None,\r\n            scale_factor: 1.0,\r\n        }\r\n    }\r\n}\r\n\r\nimpl WindowResolution {\r\n    /// Creates a new [`WindowResolution`].\r\n    pub fn new(logical_width: f32, logical_height: f32) -> Self {\r\n        Self {\r\n            physical_width: logical_width as u32,\r\n            physical_height: logical_height as u32,\r\n            ..Default::default()\r\n        }\r\n    }\r\n\r\n    /// Builder method for adding a scale factor override to the resolution.\r\n    pub fn with_scale_factor_override(mut self, scale_factor_override: f32) -> Self {\r\n        self.set_scale_factor_override(Some(scale_factor_override));\r\n        self\r\n    }\r\n\r\n    /// The window's client area width in logical pixels.\r\n    #[inline]\r\n    pub fn width(&self) -> f32 {\r\n        self.physical_width() as f32 / self.scale_factor()\r\n    }\r\n\r\n    /// The window's client area height in logical pixels.\r\n    #[inline]\r\n    pub fn height(&self) -> f32 {\r\n        self.physical_height() as f32 / self.scale_factor()\r\n    }\r\n\r\n    /// The window's client size in logical pixels\r\n    #[inline]\r\n    pub fn size(&self) -> Vec2 {\r\n        Vec2::new(self.width(), self.height())\r\n    }\r\n\r\n    /// The window's client area width in physical pixels.\r\n    #[inline]\r\n    pub fn physical_width(&self) -> u32 {\r\n        self.physical_width\r\n    }\r\n\r\n    /// The window's client area height in physical pixels.\r\n    #[inline]\r\n    pub fn physical_height(&self) -> u32 {\r\n        self.physical_height\r\n    }\r\n\r\n    /// The window's client size in physical pixels\r\n    #[inline]\r\n    pub fn physical_size(&self) -> UVec2 {\r\n        UVec2::new(self.physical_width, self.physical_height)\r\n    }\r\n\r\n    /// The ratio of physical pixels to logical pixels.\r\n    ///\r\n    /// `physical_pixels = logical_pixels * scale_factor`\r\n    pub fn scale_factor(&self) -> f32 {\r\n        self.scale_factor_override\r\n            .unwrap_or_else(|| self.base_scale_factor())\r\n    }\r\n\r\n    /// The window scale factor as reported by the window backend.\r\n    ///\r\n    /// This value is unaffected by [`WindowResolution::scale_factor_override`].\r\n    #[inline]\r\n    pub fn base_scale_factor(&self) -> f32 {\r\n        self.scale_factor\r\n    }\r\n\r\n    /// The scale factor set with [`WindowResolution::set_scale_factor_override`].\r\n    ///\r\n    /// This value may be different from the scale factor reported by the window backend.\r\n    #[inline]\r\n    pub fn scale_factor_override(&self) -> Option<f32> {\r\n        self.scale_factor_override\r\n    }\r\n\r\n    /// Set the window's logical resolution.\r\n    #[inline]\r\n    pub fn set(&mut self, width: f32, height: f32) {\r\n        self.set_physical_resolution(\r\n            (width * self.scale_factor()) as u32,\r\n            (height * self.scale_factor()) as u32,\r\n        );\r\n    }\r\n\r\n    /// Set the window's physical resolution.\r\n    ///\r\n    /// This will ignore the scale factor setting, so most of the time you should\r\n    /// prefer to use [`WindowResolution::set`].\r\n    #[inline]\r\n    pub fn set_physical_resolution(&mut self, width: u32, height: u32) {\r\n        self.physical_width = width;\r\n        self.physical_height = height;\r\n    }\r\n\r\n    /// Set the window's scale factor, this may get overridden by the backend.\r\n    #[inline]\r\n    pub fn set_scale_factor(&mut self, scale_factor: f32) {\r\n        let (width, height) = (self.width(), self.height());\r\n        self.scale_factor = scale_factor;\r\n        self.set(width, height);\r\n    }\r\n\r\n    /// Set the window's scale factor, this will be used over what the backend decides.\r\n    ///\r\n    /// This can change the logical and physical sizes if the resulting physical\r\n    /// size is not within the limits.\r\n    #[inline]\r\n    pub fn set_scale_factor_override(&mut self, scale_factor_override: Option<f32>) {\r\n        let (width, height) = (self.width(), self.height());\r\n        self.scale_factor_override = scale_factor_override;\r\n        self.set(width, height);\r\n    }\r\n}\r\n\r\nimpl<I> From<(I, I)> for WindowResolution\r\nwhere\r\n    I: Into<f32>,\r\n{\r\n    fn from((width, height): (I, I)) -> WindowResolution {\r\n        WindowResolution::new(width.into(), height.into())\r\n    }\r\n}\r\n\r\nimpl<I> From<[I; 2]> for WindowResolution\r\nwhere\r\n    I: Into<f32>,\r\n{\r\n    fn from([width, height]: [I; 2]) -> WindowResolution {\r\n        WindowResolution::new(width.into(), height.into())\r\n    }\r\n}\r\n\r\nimpl From<Vec2> for WindowResolution {\r\n    fn from(res: Vec2) -> WindowResolution {\r\n        WindowResolution::new(res.x, res.y)\r\n    }\r\n}\r\n\r\nimpl From<DVec2> for WindowResolution {\r\n    fn from(res: DVec2) -> WindowResolution {\r\n        WindowResolution::new(res.x as f32, res.y as f32)\r\n    }\r\n}\r\n\r\n/// Defines if and how the [`Cursor`] is grabbed by a [`Window`].\r\n///\r\n/// ## Platform-specific\r\n///\r\n/// - **`Windows`** doesn't support [`CursorGrabMode::Locked`]\r\n/// - **`macOS`** doesn't support [`CursorGrabMode::Confined`]\r\n/// - **`iOS/Android`** don't have cursors.\r\n///\r\n/// Since `Windows` and `macOS` have different [`CursorGrabMode`] support, we first try to set the grab mode that was asked for. If it doesn't work then use the alternate grab mode.\r\n#[derive(Default, Debug, Clone, Copy, PartialEq, Eq, Reflect)]\r\n#[cfg_attr(\r\n    feature = \"serialize\",\r\n    derive(serde::Serialize, serde::Deserialize),\r\n    reflect(Serialize, Deserialize)\r\n)]\r\n#[reflect(Debug, PartialEq, Default)]\r\npub enum CursorGrabMode {\r\n    /// The cursor can freely leave the window.\r\n    #[default]\r\n    None,\r\n    /// The cursor is confined to the window area.\r\n    Confined,\r\n    /// The cursor is locked inside the window area to a certain position.\r\n    Locked,\r\n}\r\n\r\n/// Stores internal [`Window`] state that isn't directly accessible.\r\n#[derive(Default, Debug, Copy, Clone, PartialEq, Reflect)]\r\n#[cfg_attr(\r\n    feature = \"serialize\",\r\n    derive(serde::Serialize, serde::Deserialize),\r\n    reflect(Serialize, Deserialize)\r\n)]\r\n#[reflect(Debug, PartialEq, Default)]\r\npub struct InternalWindowState {\r\n    /// If this is true then next frame we will ask to minimize the window.\r\n    minimize_request: Option<bool>,\r\n    /// If this is true then next frame we will ask to maximize/un-maximize the window depending on `maximized`.\r\n    maximize_request: Option<bool>,\r\n    /// Unscaled cursor position.\r\n    physical_cursor_position: Option<DVec2>,\r\n}\r\n\r\nimpl InternalWindowState {\r\n    /// Consumes the current maximize request, if it exists. This should only be called by window backends.\r\n    pub fn take_maximize_request(&mut self) -> Option<bool> {\r\n        self.maximize_request.take()\r\n    }\r\n\r\n    /// Consumes the current minimize request, if it exists. This should only be called by window backends.\r\n    pub fn take_minimize_request(&mut self) -> Option<bool> {\r\n        self.minimize_request.take()\r\n    }\r\n}\r\n\r\n/// References a screen monitor.\r\n///\r\n/// Used when centering a [`Window`] on a monitor.\r\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Reflect)]\r\n#[cfg_attr(\r\n    feature = \"serialize\",\r\n    derive(serde::Serialize, serde::Deserialize),\r\n    reflect(Serialize, Deserialize)\r\n)]\r\n#[reflect(Debug, PartialEq)]\r\npub enum MonitorSelection {\r\n    /// Uses the current monitor of the window.\r\n    ///\r\n    /// If [`WindowPosition::Centered(MonitorSelection::Current)`](WindowPosition::Centered) is used when creating a window,\r\n    /// the window doesn't have a monitor yet, this will fall back to [`WindowPosition::Automatic`].\r\n    Current,\r\n    /// Uses the primary monitor of the system.\r\n    Primary,\r\n    /// Uses the monitor with the specified index.\r\n    Index(usize),\r\n}\r\n\r\n/// Presentation mode for a [`Window`].\r\n///\r\n/// The presentation mode specifies when a frame is presented to the window. The [`Fifo`]\r\n/// option corresponds to a traditional `VSync`, where the framerate is capped by the\r\n/// display refresh rate. Both [`Immediate`] and [`Mailbox`] are low-latency and are not\r\n/// capped by the refresh rate, but may not be available on all platforms. Tearing\r\n/// may be observed with [`Immediate`] mode, but will not be observed with [`Mailbox`] or\r\n/// [`Fifo`].\r\n///\r\n/// [`AutoVsync`] or [`AutoNoVsync`] will gracefully fallback to [`Fifo`] when unavailable.\r\n///\r\n/// [`Immediate`] or [`Mailbox`] will panic if not supported by the platform.\r\n///\r\n/// [`Fifo`]: PresentMode::Fifo\r\n/// [`FifoRelaxed`]: PresentMode::FifoRelaxed\r\n/// [`Immediate`]: PresentMode::Immediate\r\n/// [`Mailbox`]: PresentMode::Mailbox\r\n/// [`AutoVsync`]: PresentMode::AutoVsync\r\n/// [`AutoNoVsync`]: PresentMode::AutoNoVsync\r\n///\r\n#[repr(C)]\r\n#[derive(Default, Copy, Clone, Debug, PartialEq, Eq, Hash, Reflect)]\r\n#[cfg_attr(\r\n    feature = \"serialize\",\r\n    derive(serde::Serialize, serde::Deserialize),\r\n    reflect(Serialize, Deserialize)\r\n)]\r\n#[reflect(Debug, PartialEq, Hash)]\r\n#[doc(alias = \"vsync\")]\r\npub enum PresentMode {\r\n    /// Chooses FifoRelaxed -> Fifo based on availability.\r\n    ///\r\n    /// Because of the fallback behavior, it is supported everywhere.\r\n    AutoVsync = 0, // NOTE: The explicit ordinal values mirror wgpu.\r\n    /// Chooses Immediate -> Mailbox -> Fifo (on web) based on availability.\r\n    ///\r\n    /// Because of the fallback behavior, it is supported everywhere.\r\n    AutoNoVsync = 1,\r\n    /// Presentation frames are kept in a First-In-First-Out queue approximately 3 frames\r\n    /// long. Every vertical blanking period, the presentation engine will pop a frame\r\n    /// off the queue to display. If there is no frame to display, it will present the same\r\n    /// frame again until the next vblank.\r\n    ///\r\n    /// When a present command is executed on the gpu, the presented image is added on the queue.\r\n    ///\r\n    /// No tearing will be observed.\r\n    ///\r\n    /// Calls to get_current_texture will block until there is a spot in the queue.\r\n    ///\r\n    /// Supported on all platforms.\r\n    ///\r\n    /// If you don't know what mode to choose, choose this mode. This is traditionally called \"Vsync On\".\r\n    #[default]\r\n    Fifo = 2,\r\n    /// Presentation frames are kept in a First-In-First-Out queue approximately 3 frames\r\n    /// long. Every vertical blanking period, the presentation engine will pop a frame\r\n    /// off the queue to display. If there is no frame to display, it will present the\r\n    /// same frame until there is a frame in the queue. The moment there is a frame in the\r\n    /// queue, it will immediately pop the frame off the queue.\r\n    ///\r\n    /// When a present command is executed on the gpu, the presented image is added on the queue.\r\n    ///\r\n    /// Tearing will be observed if frames last more than one vblank as the front buffer.\r\n    ///\r\n    /// Calls to get_current_texture will block until there is a spot in the queue.\r\n    ///\r\n    /// Supported on AMD on Vulkan.\r\n    ///\r\n    /// This is traditionally called \"Adaptive Vsync\"\r\n    FifoRelaxed = 3,\r\n    /// Presentation frames are not queued at all. The moment a present command\r\n    /// is executed on the GPU, the presented image is swapped onto the front buffer\r\n    /// immediately.\r\n    ///\r\n    /// Tearing can be observed.\r\n    ///\r\n    /// Supported on most platforms except older DX12 and Wayland.\r\n    ///\r\n    /// This is traditionally called \"Vsync Off\".\r\n    Immediate = 4,\r\n    /// Presentation frames are kept in a single-frame queue. Every vertical blanking period,\r\n    /// the presentation engine will pop a frame from the queue. If there is no frame to display,\r\n    /// it will present the same frame again until the next vblank.\r\n    ///\r\n    /// When a present command is executed on the gpu, the frame will be put into the queue.\r\n    /// If there was already a frame in the queue, the new frame will _replace_ the old frame\r\n    /// on the queue.\r\n    ///\r\n    /// No tearing will be observed.\r\n    ///\r\n    /// Supported on DX11/12 on Windows 10, NVidia on Vulkan and Wayland on Vulkan.\r\n    ///\r\n    /// This is traditionally called \"Fast Vsync\"\r\n    Mailbox = 5,\r\n}\r\n\r\n/// Specifies how the alpha channel of the textures should be handled during compositing, for a [`Window`].\r\n#[repr(C)]\r\n#[derive(Default, Debug, Clone, Copy, PartialEq, Eq, Hash, Reflect)]\r\n#[cfg_attr(\r\n    feature = \"serialize\",\r\n    derive(serde::Serialize, serde::Deserialize),\r\n    reflect(Serialize, Deserialize)\r\n)]\r\n#[reflect(Debug, PartialEq, Hash)]\r\npub enum CompositeAlphaMode {\r\n    /// Chooses either [`Opaque`](CompositeAlphaMode::Opaque) or [`Inherit`](CompositeAlphaMode::Inherit)\r\n    /// automatically, depending on the `alpha_mode` that the current surface can support.\r\n    #[default]\r\n    Auto = 0,\r\n    /// The alpha channel, if it exists, of the textures is ignored in the\r\n    /// compositing process. Instead, the textures is treated as if it has a\r\n    /// constant alpha of 1.0.\r\n    Opaque = 1,\r\n    /// The alpha channel, if it exists, of the textures is respected in the\r\n    /// compositing process. The non-alpha channels of the textures are\r\n    /// expected to already be multiplied by the alpha channel by the\r\n    /// application.\r\n    PreMultiplied = 2,\r\n    /// The alpha channel, if it exists, of the textures is respected in the\r\n    /// compositing process. The non-alpha channels of the textures are not\r\n    /// expected to already be multiplied by the alpha channel by the\r\n    /// application; instead, the compositor will multiply the non-alpha\r\n    /// channels of the texture by the alpha channel during compositing.\r\n    PostMultiplied = 3,\r\n    /// The alpha channel, if it exists, of the textures is unknown for processing\r\n    /// during compositing. Instead, the application is responsible for setting\r\n    /// the composite alpha blending mode using native WSI command. If not set,\r\n    /// then a platform-specific default will be used.\r\n    Inherit = 4,\r\n}\r\n\r\n/// Defines the way a [`Window`] is displayed.\r\n#[derive(Default, Debug, Clone, Copy, PartialEq, Eq, Reflect)]\r\n#[cfg_attr(\r\n    feature = \"serialize\",\r\n    derive(serde::Serialize, serde::Deserialize),\r\n    reflect(Serialize, Deserialize)\r\n)]\r\n#[reflect(Debug, PartialEq)]\r\npub enum WindowMode {\r\n    /// The window should take a portion of the screen, using the window resolution size.\r\n    #[default]\r\n    Windowed,\r\n    /// The window should appear fullscreen by being borderless and using the full\r\n    /// size of the screen.\r\n    ///\r\n    /// When setting this, the window's physical size will be modified to match the size\r\n    /// of the current monitor resolution, and the logical size will follow based\r\n    /// on the scale factor, see [`WindowResolution`].\r\n    ///\r\n    /// Note: As this mode respects the scale factor provided by the operating system,\r\n    /// the window's logical size may be different from its physical size.\r\n    /// If you want to avoid that behavior, you can use the [`WindowResolution::set_scale_factor_override`] function\r\n    /// or the [`WindowResolution::with_scale_factor_override`] builder method to set the scale factor to 1.0.\r\n    BorderlessFullscreen,\r\n    /// The window should be in \"true\"/\"legacy\" Fullscreen mode.\r\n    ///\r\n    /// When setting this, the operating system will be requested to use the\r\n    /// **closest** resolution available for the current monitor to match as\r\n    /// closely as possible the window's physical size.\r\n    /// After that, the window's physical size will be modified to match\r\n    /// that monitor resolution, and the logical size will follow based on the\r\n    /// scale factor, see [`WindowResolution`].\r\n    SizedFullscreen,\r\n    /// The window should be in \"true\"/\"legacy\" Fullscreen mode.\r\n    ///\r\n    /// When setting this, the operating system will be requested to use the\r\n    /// **biggest** resolution available for the current monitor.\r\n    /// After that, the window's physical size will be modified to match\r\n    /// that monitor resolution, and the logical size will follow based on the\r\n    /// scale factor, see [`WindowResolution`].\r\n    ///\r\n    /// Note: As this mode respects the scale factor provided by the operating system,\r\n    /// the window's logical size may be different from its physical size.\r\n    /// If you want to avoid that behavior, you can use the [`WindowResolution::set_scale_factor_override`] function\r\n    /// or the [`WindowResolution::with_scale_factor_override`] builder method to set the scale factor to 1.0.\r\n    Fullscreen,\r\n}\r\n\r\n/// Specifies where a [`Window`] should appear relative to other overlapping windows (on top or under) .\r\n///\r\n/// Levels are groups of windows with respect to their z-position.\r\n///\r\n/// The relative ordering between windows in different window levels is fixed.\r\n/// The z-order of windows within the same window level may change dynamically on user interaction.\r\n///\r\n/// ## Platform-specific\r\n///\r\n/// - **iOS / Android / Web / Wayland:** Unsupported.\r\n#[derive(Default, Debug, Clone, Copy, PartialEq, Eq, Reflect)]\r\n#[cfg_attr(\r\n    feature = \"serialize\",\r\n    derive(serde::Serialize, serde::Deserialize),\r\n    reflect(Serialize, Deserialize)\r\n)]\r\n#[reflect(Debug, PartialEq)]\r\npub enum WindowLevel {\r\n    /// The window will always be below [`WindowLevel::Normal`] and [`WindowLevel::AlwaysOnTop`] windows.\r\n    ///\r\n    /// This is useful for a widget-based app.\r\n    AlwaysOnBottom,\r\n    /// The default group.\r\n    #[default]\r\n    Normal,\r\n    /// The window will always be on top of [`WindowLevel::Normal`] and [`WindowLevel::AlwaysOnBottom`] windows.\r\n    AlwaysOnTop,\r\n}\r\n\r\n/// The [`Window`] theme variant to use.\r\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Reflect)]\r\n#[cfg_attr(\r\n    feature = \"serialize\",\r\n    derive(serde::Serialize, serde::Deserialize),\r\n    reflect(Serialize, Deserialize)\r\n)]\r\n#[reflect(Debug, PartialEq)]\r\npub enum WindowTheme {\r\n    /// Use the light variant.\r\n    Light,\r\n\r\n    /// Use the dark variant.\r\n    Dark,\r\n}\r\n\r\n/// Specifies which [`Window`] control buttons should be enabled.\r\n///\r\n/// ## Platform-specific\r\n///\r\n/// **`iOS`**, **`Android`**, and the **`Web`** do not have window control buttons.\r\n///\r\n/// On some **`Linux`** environments these values have no effect.\r\n#[derive(Debug, Copy, Clone, PartialEq, Reflect)]\r\n#[cfg_attr(\r\n    feature = \"serialize\",\r\n    derive(serde::Serialize, serde::Deserialize),\r\n    reflect(Serialize, Deserialize)\r\n)]\r\n#[reflect(Debug, PartialEq, Default)]\r\npub struct EnabledButtons {\r\n    /// Enables the functionality of the minimize button.\r\n    pub minimize: bool,\r\n    /// Enables the functionality of the maximize button.\r\n    ///\r\n    /// macOS note: When [`Window`] `resizable` member is set to `false`\r\n    /// the maximize button will be disabled regardless of this value.\r\n    /// Additionally, when `resizable` is set to `true` the window will\r\n    /// be maximized when its bar is double-clicked regardless of whether\r\n    /// the maximize button is enabled or not.\r\n    pub maximize: bool,\r\n    /// Enables the functionality of the close button.\r\n    pub close: bool,\r\n}\r\n\r\nimpl Default for EnabledButtons {\r\n    fn default() -> Self {\r\n        Self {\r\n            minimize: true,\r\n            maximize: true,\r\n            close: true,\r\n        }\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n\r\n    // Checks that `Window::physical_cursor_position` returns the cursor position if it is within\r\n    // the bounds of the window.\r\n    #[test]\r\n    fn cursor_position_within_window_bounds() {\r\n        let mut window = Window {\r\n            resolution: WindowResolution::new(800., 600.),\r\n            ..Default::default()\r\n        };\r\n\r\n        window.set_physical_cursor_position(Some(DVec2::new(0., 300.)));\r\n        assert_eq!(window.physical_cursor_position(), Some(Vec2::new(0., 300.)));\r\n\r\n        window.set_physical_cursor_position(Some(DVec2::new(400., 0.)));\r\n        assert_eq!(window.physical_cursor_position(), Some(Vec2::new(400., 0.)));\r\n\r\n        window.set_physical_cursor_position(Some(DVec2::new(799.999, 300.)));\r\n        assert_eq!(\r\n            window.physical_cursor_position(),\r\n            Some(Vec2::new(799.999, 300.)),\r\n        );\r\n\r\n        window.set_physical_cursor_position(Some(DVec2::new(400., 599.999)));\r\n        assert_eq!(\r\n            window.physical_cursor_position(),\r\n            Some(Vec2::new(400., 599.999))\r\n        );\r\n    }\r\n\r\n    // Checks that `Window::physical_cursor_position` returns `None` if the cursor position is not\r\n    // within the bounds of the window.\r\n    #[test]\r\n    fn cursor_position_not_within_window_bounds() {\r\n        let mut window = Window {\r\n            resolution: WindowResolution::new(800., 600.),\r\n            ..Default::default()\r\n        };\r\n\r\n        window.set_physical_cursor_position(Some(DVec2::new(-0.001, 300.)));\r\n        assert!(window.physical_cursor_position().is_none());\r\n\r\n        window.set_physical_cursor_position(Some(DVec2::new(400., -0.001)));\r\n        assert!(window.physical_cursor_position().is_none());\r\n\r\n        window.set_physical_cursor_position(Some(DVec2::new(800., 300.)));\r\n        assert!(window.physical_cursor_position().is_none());\r\n\r\n        window.set_physical_cursor_position(Some(DVec2::new(400., 600.)));\r\n        assert!(window.physical_cursor_position().is_none());\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\bevy\\crates\\bevy_window\\src\\raw_handle.rs\r\n\r\n````rust\r\nuse bevy_ecs::prelude::Component;\r\nuse raw_window_handle::{\r\n    DisplayHandle, HandleError, HasDisplayHandle, HasWindowHandle, RawDisplayHandle,\r\n    RawWindowHandle, WindowHandle,\r\n};\r\n\r\n/// A wrapper over [`RawWindowHandle`] and [`RawDisplayHandle`] that allows us to safely pass it across threads.\r\n///\r\n/// Depending on the platform, the underlying pointer-containing handle cannot be used on all threads,\r\n/// and so we cannot simply make it (or any type that has a safe operation to get a [`RawWindowHandle`] or [`RawDisplayHandle`])\r\n/// thread-safe.\r\n#[derive(Debug, Clone, Component)]\r\npub struct RawHandleWrapper {\r\n    /// Raw handle to a window.\r\n    pub window_handle: RawWindowHandle,\r\n    /// Raw handle to the display server.\r\n    pub display_handle: RawDisplayHandle,\r\n}\r\n\r\nimpl RawHandleWrapper {\r\n    /// Returns a [`HasWindowHandle`] + [`HasDisplayHandle`] impl, which exposes [`WindowHandle`] and [`DisplayHandle`].\r\n    ///\r\n    /// # Safety\r\n    ///\r\n    /// Some platforms have constraints on where/how this handle can be used. For example, some platforms don't support doing window\r\n    /// operations off of the main thread. The caller must ensure the [`RawHandleWrapper`] is only used in valid contexts.\r\n    pub unsafe fn get_handle(&self) -> ThreadLockedRawWindowHandleWrapper {\r\n        ThreadLockedRawWindowHandleWrapper(self.clone())\r\n    }\r\n}\r\n\r\n// SAFETY: [`RawHandleWrapper`] is just a normal \"raw pointer\", which doesn't impl Send/Sync. However the pointer is only\r\n// exposed via an unsafe method that forces the user to make a call for a given platform. (ex: some platforms don't\r\n// support doing window operations off of the main thread).\r\n// A recommendation for this pattern (and more context) is available here:\r\n// https://github.com/rust-windowing/raw-window-handle/issues/59\r\nunsafe impl Send for RawHandleWrapper {}\r\n// SAFETY: This is safe for the same reasons as the Send impl above.\r\nunsafe impl Sync for RawHandleWrapper {}\r\n\r\n/// A [`RawHandleWrapper`] that cannot be sent across threads.\r\n///\r\n/// This safely exposes [`RawWindowHandle`] and [`RawDisplayHandle`], but care must be taken to ensure that the construction itself is correct.\r\n///\r\n/// This can only be constructed via the [`RawHandleWrapper::get_handle()`] method;\r\n/// be sure to read the safety docs there about platform-specific limitations.\r\n/// In many cases, this should only be constructed on the main thread.\r\npub struct ThreadLockedRawWindowHandleWrapper(RawHandleWrapper);\r\n\r\nimpl HasWindowHandle for ThreadLockedRawWindowHandleWrapper {\r\n    fn window_handle(&self) -> Result<WindowHandle, HandleError> {\r\n        // SAFETY: the caller has validated that this is a valid context to get [`RawHandleWrapper`]\r\n        // as otherwise an instance of this type could not have been constructed\r\n        // NOTE: we cannot simply impl HasRawWindowHandle for RawHandleWrapper,\r\n        // as the `raw_window_handle` method is safe. We cannot guarantee that all calls\r\n        // of this method are correct (as it may be off the main thread on an incompatible platform),\r\n        // and so exposing a safe method to get a [`RawWindowHandle`] directly would be UB.\r\n        Ok(unsafe { WindowHandle::borrow_raw(self.0.window_handle) })\r\n    }\r\n}\r\n\r\nimpl HasDisplayHandle for ThreadLockedRawWindowHandleWrapper {\r\n    fn display_handle(&self) -> Result<DisplayHandle, HandleError> {\r\n        // SAFETY: the caller has validated that this is a valid context to get [`RawDisplayHandle`]\r\n        // as otherwise an instance of this type could not have been constructed\r\n        // NOTE: we cannot simply impl HasRawDisplayHandle for RawHandleWrapper,\r\n        // as the `raw_display_handle` method is safe. We cannot guarantee that all calls\r\n        // of this method are correct (as it may be off the main thread on an incompatible platform),\r\n        // and so exposing a safe method to get a [`RawDisplayHandle`] directly would be UB.\r\n        Ok(unsafe { DisplayHandle::borrow_raw(self.0.display_handle) })\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\bevy\\crates\\bevy_ui\\src\\widget\\button.rs\r\n\r\n````rust\r\nuse bevy_ecs::prelude::Component;\r\nuse bevy_ecs::reflect::ReflectComponent;\r\nuse bevy_reflect::std_traits::ReflectDefault;\r\nuse bevy_reflect::Reflect;\r\n\r\n/// Marker struct for buttons\r\n#[derive(Component, Debug, Default, Clone, Copy, Reflect)]\r\n#[reflect(Component, Default)]\r\npub struct Button;\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\bevy\\crates\\bevy_ecs\\src\\world\\identifier.rs\r\n\r\n````rust\r\nuse crate::system::{ExclusiveSystemParam, SystemMeta};\r\nuse crate::{\r\n    component::Tick,\r\n    storage::SparseSetIndex,\r\n    system::{ReadOnlySystemParam, SystemParam},\r\n    world::{FromWorld, World},\r\n};\r\nuse std::sync::atomic::{AtomicUsize, Ordering};\r\n\r\nuse super::unsafe_world_cell::UnsafeWorldCell;\r\n\r\n#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash)]\r\n// We use usize here because that is the largest `Atomic` we want to require\r\n/// A unique identifier for a [`World`].\r\n///\r\n/// The trait [`FromWorld`] is implemented for this type, which returns the\r\n/// ID of the world passed to [`FromWorld::from_world`].\r\n// Note that this *is* used by external crates as well as for internal safety checks\r\npub struct WorldId(usize);\r\n\r\n/// The next [`WorldId`].\r\nstatic MAX_WORLD_ID: AtomicUsize = AtomicUsize::new(0);\r\n\r\nimpl WorldId {\r\n    /// Create a new, unique [`WorldId`]. Returns [`None`] if the supply of unique\r\n    /// [`WorldId`]s has been exhausted\r\n    ///\r\n    /// Please note that the [`WorldId`]s created from this method are unique across\r\n    /// time - if a given [`WorldId`] is [`Drop`]ped its value still cannot be reused\r\n    pub fn new() -> Option<Self> {\r\n        MAX_WORLD_ID\r\n            // We use `Relaxed` here since this atomic only needs to be consistent with itself\r\n            .fetch_update(Ordering::Relaxed, Ordering::Relaxed, |val| {\r\n                val.checked_add(1)\r\n            })\r\n            .map(WorldId)\r\n            .ok()\r\n    }\r\n}\r\n\r\nimpl FromWorld for WorldId {\r\n    #[inline]\r\n    fn from_world(world: &mut World) -> Self {\r\n        world.id()\r\n    }\r\n}\r\n\r\n// SAFETY: No world data is accessed.\r\nunsafe impl ReadOnlySystemParam for WorldId {}\r\n\r\n// SAFETY: No world data is accessed.\r\nunsafe impl SystemParam for WorldId {\r\n    type State = ();\r\n\r\n    type Item<'world, 'state> = WorldId;\r\n\r\n    fn init_state(_: &mut World, _: &mut crate::system::SystemMeta) -> Self::State {}\r\n\r\n    unsafe fn get_param<'world, 'state>(\r\n        _: &'state mut Self::State,\r\n        _: &crate::system::SystemMeta,\r\n        world: UnsafeWorldCell<'world>,\r\n        _: Tick,\r\n    ) -> Self::Item<'world, 'state> {\r\n        world.id()\r\n    }\r\n}\r\n\r\nimpl ExclusiveSystemParam for WorldId {\r\n    type State = WorldId;\r\n    type Item<'s> = WorldId;\r\n\r\n    fn init(world: &mut World, _system_meta: &mut SystemMeta) -> Self::State {\r\n        world.id()\r\n    }\r\n\r\n    fn get_param<'s>(state: &'s mut Self::State, _system_meta: &SystemMeta) -> Self::Item<'s> {\r\n        *state\r\n    }\r\n}\r\n\r\nimpl SparseSetIndex for WorldId {\r\n    #[inline]\r\n    fn sparse_set_index(&self) -> usize {\r\n        self.0\r\n    }\r\n\r\n    #[inline]\r\n    fn get_sparse_set_index(value: usize) -> Self {\r\n        Self(value)\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n\r\n    #[test]\r\n    fn world_ids_unique() {\r\n        let ids = std::iter::repeat_with(WorldId::new)\r\n            .take(50)\r\n            .map(Option::unwrap)\r\n            .collect::<Vec<_>>();\r\n        for (i, &id1) in ids.iter().enumerate() {\r\n            // For the first element, i is 0 - so skip 1\r\n            for &id2 in ids.iter().skip(i + 1) {\r\n                assert_ne!(id1, id2, \"WorldIds should not repeat\");\r\n            }\r\n        }\r\n    }\r\n\r\n    #[test]\r\n    fn world_id_system_param() {\r\n        fn test_system(world_id: WorldId) -> WorldId {\r\n            world_id\r\n        }\r\n\r\n        let mut world = World::default();\r\n        let system_id = world.register_system(test_system);\r\n        let world_id = world.run_system(system_id).unwrap();\r\n        assert_eq!(world.id(), world_id);\r\n    }\r\n\r\n    #[test]\r\n    fn world_id_exclusive_system_param() {\r\n        fn test_system(_world: &mut World, world_id: WorldId) -> WorldId {\r\n            world_id\r\n        }\r\n\r\n        let mut world = World::default();\r\n        let system_id = world.register_system(test_system);\r\n        let world_id = world.run_system(system_id).unwrap();\r\n        assert_eq!(world.id(), world_id);\r\n    }\r\n\r\n    // We cannot use this test as-is, as it causes other tests to panic due to using the same atomic variable.\r\n    // #[test]\r\n    // #[should_panic]\r\n    // fn panic_on_overflow() {\r\n    //     MAX_WORLD_ID.store(usize::MAX - 50, Ordering::Relaxed);\r\n    //     std::iter::repeat_with(WorldId::new)\r\n    //         .take(500)\r\n    //         .for_each(|_| ());\r\n    // }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\bevy\\crates\\bevy_render\\src\\view\\window\\mod.rs\r\n\r\n````rust\r\nuse crate::{\r\n    render_resource::{\r\n        BindGroupEntries, PipelineCache, SpecializedRenderPipelines, SurfaceTexture, TextureView,\r\n    },\r\n    renderer::{RenderAdapter, RenderDevice, RenderInstance},\r\n    texture::TextureFormatPixelInfo,\r\n    Extract, ExtractSchedule, Render, RenderApp, RenderSet,\r\n};\r\nuse bevy_app::{App, Plugin};\r\nuse bevy_ecs::{entity::EntityHashMap, prelude::*};\r\nuse bevy_utils::{default, tracing::debug, HashSet};\r\nuse bevy_window::{\r\n    CompositeAlphaMode, PresentMode, PrimaryWindow, RawHandleWrapper, Window, WindowClosed,\r\n};\r\nuse std::{\r\n    ops::{Deref, DerefMut},\r\n    sync::PoisonError,\r\n};\r\nuse wgpu::{\r\n    BufferUsages, SurfaceConfiguration, SurfaceTargetUnsafe, TextureFormat, TextureUsages,\r\n    TextureViewDescriptor,\r\n};\r\n\r\npub mod screenshot;\r\n\r\nuse screenshot::{\r\n    ScreenshotManager, ScreenshotPlugin, ScreenshotPreparedState, ScreenshotToScreenPipeline,\r\n};\r\n\r\nuse super::Msaa;\r\n\r\npub struct WindowRenderPlugin;\r\n\r\nimpl Plugin for WindowRenderPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        app.add_plugins(ScreenshotPlugin);\r\n\r\n        if let Ok(render_app) = app.get_sub_app_mut(RenderApp) {\r\n            render_app\r\n                .init_resource::<ExtractedWindows>()\r\n                .init_resource::<WindowSurfaces>()\r\n                .add_systems(ExtractSchedule, extract_windows)\r\n                .add_systems(\r\n                    Render,\r\n                    create_surfaces\r\n                        .run_if(need_surface_configuration)\r\n                        .before(prepare_windows),\r\n                )\r\n                .add_systems(Render, prepare_windows.in_set(RenderSet::ManageViews));\r\n        }\r\n    }\r\n\r\n    fn finish(&self, app: &mut App) {\r\n        if let Ok(render_app) = app.get_sub_app_mut(RenderApp) {\r\n            render_app.init_resource::<ScreenshotToScreenPipeline>();\r\n        }\r\n    }\r\n}\r\n\r\npub struct ExtractedWindow {\r\n    /// An entity that contains the components in [`Window`].\r\n    pub entity: Entity,\r\n    pub handle: RawHandleWrapper,\r\n    pub physical_width: u32,\r\n    pub physical_height: u32,\r\n    pub present_mode: PresentMode,\r\n    /// Note: this will not always be the swap chain texture view. When taking a screenshot,\r\n    /// this will point to an alternative texture instead to allow for copying the render result\r\n    /// to CPU memory.\r\n    pub swap_chain_texture_view: Option<TextureView>,\r\n    pub swap_chain_texture: Option<SurfaceTexture>,\r\n    pub swap_chain_texture_format: Option<TextureFormat>,\r\n    pub screenshot_memory: Option<ScreenshotPreparedState>,\r\n    pub size_changed: bool,\r\n    pub present_mode_changed: bool,\r\n    pub alpha_mode: CompositeAlphaMode,\r\n    pub screenshot_func: Option<screenshot::ScreenshotFn>,\r\n}\r\n\r\nimpl ExtractedWindow {\r\n    fn set_swapchain_texture(&mut self, frame: wgpu::SurfaceTexture) {\r\n        let texture_view_descriptor = TextureViewDescriptor {\r\n            format: Some(frame.texture.format().add_srgb_suffix()),\r\n            ..default()\r\n        };\r\n        self.swap_chain_texture_view = Some(TextureView::from(\r\n            frame.texture.create_view(&texture_view_descriptor),\r\n        ));\r\n        self.swap_chain_texture = Some(SurfaceTexture::from(frame));\r\n    }\r\n}\r\n\r\n#[derive(Default, Resource)]\r\npub struct ExtractedWindows {\r\n    pub primary: Option<Entity>,\r\n    pub windows: EntityHashMap<ExtractedWindow>,\r\n}\r\n\r\nimpl Deref for ExtractedWindows {\r\n    type Target = EntityHashMap<ExtractedWindow>;\r\n\r\n    fn deref(&self) -> &Self::Target {\r\n        &self.windows\r\n    }\r\n}\r\n\r\nimpl DerefMut for ExtractedWindows {\r\n    fn deref_mut(&mut self) -> &mut Self::Target {\r\n        &mut self.windows\r\n    }\r\n}\r\n\r\nfn extract_windows(\r\n    mut extracted_windows: ResMut<ExtractedWindows>,\r\n    screenshot_manager: Extract<Res<ScreenshotManager>>,\r\n    mut closed: Extract<EventReader<WindowClosed>>,\r\n    windows: Extract<Query<(Entity, &Window, &RawHandleWrapper, Option<&PrimaryWindow>)>>,\r\n    mut removed: Extract<RemovedComponents<RawHandleWrapper>>,\r\n    mut window_surfaces: ResMut<WindowSurfaces>,\r\n) {\r\n    for (entity, window, handle, primary) in windows.iter() {\r\n        if primary.is_some() {\r\n            extracted_windows.primary = Some(entity);\r\n        }\r\n\r\n        let (new_width, new_height) = (\r\n            window.resolution.physical_width().max(1),\r\n            window.resolution.physical_height().max(1),\r\n        );\r\n\r\n        let extracted_window = extracted_windows.entry(entity).or_insert(ExtractedWindow {\r\n            entity,\r\n            handle: handle.clone(),\r\n            physical_width: new_width,\r\n            physical_height: new_height,\r\n            present_mode: window.present_mode,\r\n            swap_chain_texture: None,\r\n            swap_chain_texture_view: None,\r\n            size_changed: false,\r\n            swap_chain_texture_format: None,\r\n            present_mode_changed: false,\r\n            alpha_mode: window.composite_alpha_mode,\r\n            screenshot_func: None,\r\n            screenshot_memory: None,\r\n        });\r\n\r\n        // NOTE: Drop the swap chain frame here\r\n        extracted_window.swap_chain_texture_view = None;\r\n        extracted_window.size_changed = new_width != extracted_window.physical_width\r\n            || new_height != extracted_window.physical_height;\r\n        extracted_window.present_mode_changed =\r\n            window.present_mode != extracted_window.present_mode;\r\n\r\n        if extracted_window.size_changed {\r\n            debug!(\r\n                \"Window size changed from {}x{} to {}x{}\",\r\n                extracted_window.physical_width,\r\n                extracted_window.physical_height,\r\n                new_width,\r\n                new_height\r\n            );\r\n            extracted_window.physical_width = new_width;\r\n            extracted_window.physical_height = new_height;\r\n        }\r\n\r\n        if extracted_window.present_mode_changed {\r\n            debug!(\r\n                \"Window Present Mode changed from {:?} to {:?}\",\r\n                extracted_window.present_mode, window.present_mode\r\n            );\r\n            extracted_window.present_mode = window.present_mode;\r\n        }\r\n    }\r\n\r\n    for closed_window in closed.read() {\r\n        extracted_windows.remove(&closed_window.window);\r\n        window_surfaces.remove(&closed_window.window);\r\n    }\r\n    for removed_window in removed.read() {\r\n        extracted_windows.remove(&removed_window);\r\n        window_surfaces.remove(&removed_window);\r\n    }\r\n    // This lock will never block because `callbacks` is `pub(crate)` and this is the singular callsite where it's locked.\r\n    // Even if a user had multiple copies of this system, since the system has a mutable resource access the two systems would never run\r\n    // at the same time\r\n    // TODO: since this is guaranteed, should the lock be replaced with an UnsafeCell to remove the overhead, or is it minor enough to be ignored?\r\n    for (window, screenshot_func) in screenshot_manager\r\n        .callbacks\r\n        .lock()\r\n        .unwrap_or_else(PoisonError::into_inner)\r\n        .drain()\r\n    {\r\n        if let Some(window) = extracted_windows.get_mut(&window) {\r\n            window.screenshot_func = Some(screenshot_func);\r\n        }\r\n    }\r\n}\r\n\r\nstruct SurfaceData {\r\n    // TODO: what lifetime should this be?\r\n    surface: wgpu::Surface<'static>,\r\n    configuration: SurfaceConfiguration,\r\n}\r\n\r\n#[derive(Resource, Default)]\r\npub struct WindowSurfaces {\r\n    surfaces: EntityHashMap<SurfaceData>,\r\n    /// List of windows that we have already called the initial `configure_surface` for\r\n    configured_windows: HashSet<Entity>,\r\n}\r\n\r\nimpl WindowSurfaces {\r\n    fn remove(&mut self, window: &Entity) {\r\n        self.surfaces.remove(window);\r\n        self.configured_windows.remove(window);\r\n    }\r\n}\r\n\r\n/// (re)configures window surfaces, and obtains a swapchain texture for rendering.\r\n///\r\n/// NOTE: `get_current_texture` in `prepare_windows` can take a long time if the GPU workload is\r\n/// the performance bottleneck. This can be seen in profiles as multiple prepare-set systems all\r\n/// taking an unusually long time to complete, and all finishing at about the same time as the\r\n/// `prepare_windows` system. Improvements in bevy are planned to avoid this happening when it\r\n/// should not but it will still happen as it is easy for a user to create a large GPU workload\r\n/// relative to the GPU performance and/or CPU workload.\r\n/// This can be caused by many reasons, but several of them are:\r\n/// - GPU workload is more than your current GPU can manage\r\n/// - Error / performance bug in your custom shaders\r\n/// - wgpu was unable to detect a proper GPU hardware-accelerated device given the chosen\r\n///   [`Backends`](crate::settings::Backends), [`WgpuLimits`](crate::settings::WgpuLimits),\r\n///   and/or [`WgpuFeatures`](crate::settings::WgpuFeatures). For example, on Windows currently\r\n///   `DirectX 11` is not supported by wgpu 0.12 and so if your GPU/drivers do not support Vulkan,\r\n///   it may be that a software renderer called \"Microsoft Basic Render Driver\" using `DirectX 12`\r\n///   will be chosen and performance will be very poor. This is visible in a log message that is\r\n///   output during renderer initialization. Future versions of wgpu will support `DirectX 11`, but\r\n///   another alternative is to try to use [`ANGLE`](https://github.com/gfx-rs/wgpu#angle) and\r\n///   [`Backends::GL`](crate::settings::Backends::GL) if your GPU/drivers support `OpenGL 4.3` / `OpenGL ES 3.0` or\r\n///   later.\r\n#[allow(clippy::too_many_arguments)]\r\npub fn prepare_windows(\r\n    mut windows: ResMut<ExtractedWindows>,\r\n    mut window_surfaces: ResMut<WindowSurfaces>,\r\n    render_device: Res<RenderDevice>,\r\n    render_adapter: Res<RenderAdapter>,\r\n    screenshot_pipeline: Res<ScreenshotToScreenPipeline>,\r\n    pipeline_cache: Res<PipelineCache>,\r\n    mut pipelines: ResMut<SpecializedRenderPipelines<ScreenshotToScreenPipeline>>,\r\n    mut msaa: ResMut<Msaa>,\r\n    #[cfg(target_os = \"linux\")] render_instance: Res<RenderInstance>,\r\n) {\r\n    for window in windows.windows.values_mut() {\r\n        let window_surfaces = window_surfaces.deref_mut();\r\n        let Some(surface_data) = window_surfaces.surfaces.get(&window.entity) else {\r\n            continue;\r\n        };\r\n\r\n        // This is an ugly hack to work around drivers that don't support MSAA.\r\n        // This should be removed once https://github.com/bevyengine/bevy/issues/7194 lands and we're doing proper\r\n        // feature detection for MSAA.\r\n        // When removed, we can also remove the `.after(prepare_windows)` of `prepare_core_3d_depth_textures` and `prepare_prepass_textures`\r\n        let sample_flags = render_adapter\r\n            .get_texture_format_features(surface_data.configuration.format)\r\n            .flags;\r\n\r\n        if !sample_flags.sample_count_supported(msaa.samples()) {\r\n            let fallback = if sample_flags.sample_count_supported(Msaa::default().samples()) {\r\n                Msaa::default()\r\n            } else {\r\n                Msaa::Off\r\n            };\r\n\r\n            let fallback_str = if fallback == Msaa::Off {\r\n                \"disabling MSAA\".to_owned()\r\n            } else {\r\n                format!(\"MSAA {}x\", fallback.samples())\r\n            };\r\n\r\n            bevy_utils::tracing::warn!(\r\n                \"MSAA {}x is not supported on this device. Falling back to {}.\",\r\n                msaa.samples(),\r\n                fallback_str,\r\n            );\r\n            *msaa = fallback;\r\n        }\r\n\r\n        // A recurring issue is hitting `wgpu::SurfaceError::Timeout` on certain Linux\r\n        // mesa driver implementations. This seems to be a quirk of some drivers.\r\n        // We'd rather keep panicking when not on Linux mesa, because in those case,\r\n        // the `Timeout` is still probably the symptom of a degraded unrecoverable\r\n        // application state.\r\n        // see https://github.com/bevyengine/bevy/pull/5957\r\n        // and https://github.com/gfx-rs/wgpu/issues/1218\r\n        #[cfg(target_os = \"linux\")]\r\n        let may_erroneously_timeout = || {\r\n            render_instance\r\n                .enumerate_adapters(wgpu::Backends::VULKAN)\r\n                .iter()\r\n                .any(|adapter| {\r\n                    let name = adapter.get_info().name;\r\n                    name.starts_with(\"Radeon\")\r\n                        || name.starts_with(\"AMD\")\r\n                        || name.starts_with(\"Intel\")\r\n                })\r\n        };\r\n\r\n        let not_already_configured = window_surfaces.configured_windows.insert(window.entity);\r\n\r\n        let surface = &surface_data.surface;\r\n        if not_already_configured || window.size_changed || window.present_mode_changed {\r\n            let frame = surface\r\n                .get_current_texture()\r\n                .expect(\"Error configuring surface\");\r\n            window.set_swapchain_texture(frame);\r\n        } else {\r\n            match surface.get_current_texture() {\r\n                Ok(frame) => {\r\n                    window.set_swapchain_texture(frame);\r\n                }\r\n                Err(wgpu::SurfaceError::Outdated) => {\r\n                    render_device.configure_surface(surface, &surface_data.configuration);\r\n                    let frame = surface\r\n                        .get_current_texture()\r\n                        .expect(\"Error reconfiguring surface\");\r\n                    window.set_swapchain_texture(frame);\r\n                }\r\n                #[cfg(target_os = \"linux\")]\r\n                Err(wgpu::SurfaceError::Timeout) if may_erroneously_timeout() => {\r\n                    bevy_utils::tracing::trace!(\r\n                        \"Couldn't get swap chain texture. This is probably a quirk \\\r\n                        of your Linux GPU driver, so it can be safely ignored.\"\r\n                    );\r\n                }\r\n                Err(err) => {\r\n                    panic!(\"Couldn't get swap chain texture, operation unrecoverable: {err}\");\r\n                }\r\n            }\r\n        };\r\n        window.swap_chain_texture_format = Some(surface_data.configuration.format);\r\n\r\n        if window.screenshot_func.is_some() {\r\n            let texture = render_device.create_texture(&wgpu::TextureDescriptor {\r\n                label: Some(\"screenshot-capture-rendertarget\"),\r\n                size: wgpu::Extent3d {\r\n                    width: surface_data.configuration.width,\r\n                    height: surface_data.configuration.height,\r\n                    depth_or_array_layers: 1,\r\n                },\r\n                mip_level_count: 1,\r\n                sample_count: 1,\r\n                dimension: wgpu::TextureDimension::D2,\r\n                format: surface_data.configuration.format.add_srgb_suffix(),\r\n                usage: TextureUsages::RENDER_ATTACHMENT\r\n                    | TextureUsages::COPY_SRC\r\n                    | TextureUsages::TEXTURE_BINDING,\r\n                view_formats: &[],\r\n            });\r\n            let texture_view = texture.create_view(&Default::default());\r\n            let buffer = render_device.create_buffer(&wgpu::BufferDescriptor {\r\n                label: Some(\"screenshot-transfer-buffer\"),\r\n                size: screenshot::get_aligned_size(\r\n                    window.physical_width,\r\n                    window.physical_height,\r\n                    surface_data.configuration.format.pixel_size() as u32,\r\n                ) as u64,\r\n                usage: BufferUsages::MAP_READ | BufferUsages::COPY_DST,\r\n                mapped_at_creation: false,\r\n            });\r\n            let bind_group = render_device.create_bind_group(\r\n                \"screenshot-to-screen-bind-group\",\r\n                &screenshot_pipeline.bind_group_layout,\r\n                &BindGroupEntries::single(&texture_view),\r\n            );\r\n            let pipeline_id = pipelines.specialize(\r\n                &pipeline_cache,\r\n                &screenshot_pipeline,\r\n                surface_data.configuration.format,\r\n            );\r\n            window.swap_chain_texture_view = Some(texture_view);\r\n            window.screenshot_memory = Some(ScreenshotPreparedState {\r\n                texture,\r\n                buffer,\r\n                bind_group,\r\n                pipeline_id,\r\n            });\r\n        }\r\n    }\r\n}\r\n\r\npub fn need_surface_configuration(\r\n    windows: Res<ExtractedWindows>,\r\n    window_surfaces: Res<WindowSurfaces>,\r\n) -> bool {\r\n    for window in windows.windows.values() {\r\n        if !window_surfaces.configured_windows.contains(&window.entity)\r\n            || window.size_changed\r\n            || window.present_mode_changed\r\n        {\r\n            return true;\r\n        }\r\n    }\r\n    false\r\n}\r\n\r\n/// Creates window surfaces.\r\npub fn create_surfaces(\r\n    // By accessing a NonSend resource, we tell the scheduler to put this system on the main thread,\r\n    // which is necessary for some OS's\r\n    #[cfg(any(target_os = \"macos\", target_os = \"ios\"))] _marker: Option<\r\n        NonSend<bevy_core::NonSendMarker>,\r\n    >,\r\n    windows: Res<ExtractedWindows>,\r\n    mut window_surfaces: ResMut<WindowSurfaces>,\r\n    render_instance: Res<RenderInstance>,\r\n    render_adapter: Res<RenderAdapter>,\r\n    render_device: Res<RenderDevice>,\r\n) {\r\n    for window in windows.windows.values() {\r\n        let data = window_surfaces\r\n            .surfaces\r\n            .entry(window.entity)\r\n            .or_insert_with(|| {\r\n                let surface_target = SurfaceTargetUnsafe::RawHandle {\r\n                    raw_display_handle: window.handle.display_handle,\r\n                    raw_window_handle: window.handle.window_handle,\r\n                };\r\n                // SAFETY: The window handles in ExtractedWindows will always be valid objects to create surfaces on\r\n                let surface = unsafe {\r\n                    // NOTE: On some OSes this MUST be called from the main thread.\r\n                    // As of wgpu 0.15, only fallible if the given window is a HTML canvas and obtaining a WebGPU or WebGL2 context fails.\r\n                    render_instance\r\n                        .create_surface_unsafe(surface_target)\r\n                        .expect(\"Failed to create wgpu surface\")\r\n                };\r\n                let caps = surface.get_capabilities(&render_adapter);\r\n                let formats = caps.formats;\r\n                // For future HDR output support, we'll need to request a format that supports HDR,\r\n                // but as of wgpu 0.15 that is not yet supported.\r\n                // Prefer sRGB formats for surfaces, but fall back to first available format if no sRGB formats are available.\r\n                let mut format = *formats.first().expect(\"No supported formats for surface\");\r\n                for available_format in formats {\r\n                    // Rgba8UnormSrgb and Bgra8UnormSrgb and the only sRGB formats wgpu exposes that we can use for surfaces.\r\n                    if available_format == TextureFormat::Rgba8UnormSrgb\r\n                        || available_format == TextureFormat::Bgra8UnormSrgb\r\n                    {\r\n                        format = available_format;\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                let configuration = wgpu::SurfaceConfiguration {\r\n                    format,\r\n                    width: window.physical_width,\r\n                    height: window.physical_height,\r\n                    usage: TextureUsages::RENDER_ATTACHMENT,\r\n                    present_mode: match window.present_mode {\r\n                        PresentMode::Fifo => wgpu::PresentMode::Fifo,\r\n                        PresentMode::FifoRelaxed => wgpu::PresentMode::FifoRelaxed,\r\n                        PresentMode::Mailbox => wgpu::PresentMode::Mailbox,\r\n                        PresentMode::Immediate => wgpu::PresentMode::Immediate,\r\n                        PresentMode::AutoVsync => wgpu::PresentMode::AutoVsync,\r\n                        PresentMode::AutoNoVsync => wgpu::PresentMode::AutoNoVsync,\r\n                    },\r\n                    // TODO: Expose this as a setting somewhere\r\n                    // 2 is wgpu's default/what we've been using so far.\r\n                    // 1 is the minimum, but may cause lower framerates due to the cpu waiting for the gpu to finish\r\n                    // all work for the previous frame before starting work on the next frame, which then means the gpu\r\n                    // has to wait for the cpu to finish to start on the next frame.\r\n                    desired_maximum_frame_latency: 2,\r\n                    alpha_mode: match window.alpha_mode {\r\n                        CompositeAlphaMode::Auto => wgpu::CompositeAlphaMode::Auto,\r\n                        CompositeAlphaMode::Opaque => wgpu::CompositeAlphaMode::Opaque,\r\n                        CompositeAlphaMode::PreMultiplied => {\r\n                            wgpu::CompositeAlphaMode::PreMultiplied\r\n                        }\r\n                        CompositeAlphaMode::PostMultiplied => {\r\n                            wgpu::CompositeAlphaMode::PostMultiplied\r\n                        }\r\n                        CompositeAlphaMode::Inherit => wgpu::CompositeAlphaMode::Inherit,\r\n                    },\r\n                    view_formats: if !format.is_srgb() {\r\n                        vec![format.add_srgb_suffix()]\r\n                    } else {\r\n                        vec![]\r\n                    },\r\n                };\r\n\r\n                render_device.configure_surface(&surface, &configuration);\r\n\r\n                SurfaceData {\r\n                    surface,\r\n                    configuration,\r\n                }\r\n            });\r\n\r\n        if window.size_changed || window.present_mode_changed {\r\n            data.configuration.width = window.physical_width;\r\n            data.configuration.height = window.physical_height;\r\n            data.configuration.present_mode = match window.present_mode {\r\n                PresentMode::Fifo => wgpu::PresentMode::Fifo,\r\n                PresentMode::FifoRelaxed => wgpu::PresentMode::FifoRelaxed,\r\n                PresentMode::Mailbox => wgpu::PresentMode::Mailbox,\r\n                PresentMode::Immediate => wgpu::PresentMode::Immediate,\r\n                PresentMode::AutoVsync => wgpu::PresentMode::AutoVsync,\r\n                PresentMode::AutoNoVsync => wgpu::PresentMode::AutoNoVsync,\r\n            };\r\n            render_device.configure_surface(&data.surface, &data.configuration);\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\bevy\\crates\\bevy_reflect_compile_fail_tests\\tests\\reflect_derive\\custom_where.fail.rs\r\n\r\n````rust\r\nuse bevy_reflect::{FromType, Reflect};\r\nuse std::marker::PhantomData;\r\n\r\n#[derive(Clone)]\r\nstruct ReflectMyTrait;\r\n\r\nimpl<T> FromType<T> for ReflectMyTrait {\r\n    fn from_type() -> Self {\r\n        Self\r\n    }\r\n}\r\n\r\n// Reason: populated `where` clause must be last with #[reflect(MyTrait)]\r\n#[derive(Reflect)]\r\n#[reflect(where T: std::fmt::Debug, MyTrait)]\r\npub struct Foo<T> {\r\n    value: String,\r\n    #[reflect(ignore)]\r\n    _marker: PhantomData<T>,\r\n}\r\n\r\nfn main() {}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\bevy\\crates\\bevy_window\\src\\event.rs\r\n\r\n````rust\r\nuse std::path::PathBuf;\r\n\r\nuse bevy_ecs::entity::Entity;\r\nuse bevy_ecs::event::Event;\r\nuse bevy_math::{IVec2, Vec2};\r\nuse bevy_reflect::Reflect;\r\nuse smol_str::SmolStr;\r\n\r\n#[cfg(feature = \"serialize\")]\r\nuse bevy_reflect::{ReflectDeserialize, ReflectSerialize};\r\n\r\nuse crate::WindowTheme;\r\n\r\n/// A window event that is sent whenever a window's logical size has changed.\r\n#[derive(Event, Debug, Clone, PartialEq, Reflect)]\r\n#[reflect(Debug, PartialEq)]\r\n#[cfg_attr(\r\n    feature = \"serialize\",\r\n    derive(serde::Serialize, serde::Deserialize),\r\n    reflect(Serialize, Deserialize)\r\n)]\r\npub struct WindowResized {\r\n    /// Window that has changed.\r\n    pub window: Entity,\r\n    /// The new logical width of the window.\r\n    pub width: f32,\r\n    /// The new logical height of the window.\r\n    pub height: f32,\r\n}\r\n\r\n/// An event that indicates all of the application's windows should be redrawn,\r\n/// even if their control flow is set to `Wait` and there have been no window events.\r\n#[derive(Event, Debug, Clone, PartialEq, Eq, Reflect)]\r\n#[reflect(Debug, PartialEq)]\r\n#[cfg_attr(\r\n    feature = \"serialize\",\r\n    derive(serde::Serialize, serde::Deserialize),\r\n    reflect(Serialize, Deserialize)\r\n)]\r\npub struct RequestRedraw;\r\n\r\n/// An event that is sent whenever a new window is created.\r\n///\r\n/// To create a new window, spawn an entity with a [`crate::Window`] on it.\r\n#[derive(Event, Debug, Clone, PartialEq, Eq, Reflect)]\r\n#[reflect(Debug, PartialEq)]\r\n#[cfg_attr(\r\n    feature = \"serialize\",\r\n    derive(serde::Serialize, serde::Deserialize),\r\n    reflect(Serialize, Deserialize)\r\n)]\r\npub struct WindowCreated {\r\n    /// Window that has been created.\r\n    pub window: Entity,\r\n}\r\n\r\n/// An event that is sent whenever the operating systems requests that a window\r\n/// be closed. This will be sent when the close button of the window is pressed.\r\n///\r\n/// If the default [`WindowPlugin`] is used, these events are handled\r\n/// by closing the corresponding [`Window`].\r\n/// To disable this behavior, set `close_when_requested` on the [`WindowPlugin`]\r\n/// to `false`.\r\n///\r\n/// [`WindowPlugin`]: crate::WindowPlugin\r\n/// [`Window`]: crate::Window\r\n#[derive(Event, Debug, Clone, PartialEq, Eq, Reflect)]\r\n#[reflect(Debug, PartialEq)]\r\n#[cfg_attr(\r\n    feature = \"serialize\",\r\n    derive(serde::Serialize, serde::Deserialize),\r\n    reflect(Serialize, Deserialize)\r\n)]\r\npub struct WindowCloseRequested {\r\n    /// Window to close.\r\n    pub window: Entity,\r\n}\r\n\r\n/// An event that is sent whenever a window is closed. This will be sent when\r\n/// the window entity loses its [`Window`](crate::window::Window) component or is despawned.\r\n#[derive(Event, Debug, Clone, PartialEq, Eq, Reflect)]\r\n#[reflect(Debug, PartialEq)]\r\n#[cfg_attr(\r\n    feature = \"serialize\",\r\n    derive(serde::Serialize, serde::Deserialize),\r\n    reflect(Serialize, Deserialize)\r\n)]\r\npub struct WindowClosed {\r\n    /// Window that has been closed.\r\n    ///\r\n    /// Note that this entity probably no longer exists\r\n    /// by the time this event is received.\r\n    pub window: Entity,\r\n}\r\n\r\n/// An event that is sent whenever a window is destroyed by the underlying window system.\r\n///\r\n/// Note that if your application only has a single window, this event may be your last chance to\r\n/// persist state before the application terminates.\r\n#[derive(Event, Debug, Clone, PartialEq, Eq, Reflect)]\r\n#[reflect(Debug, PartialEq)]\r\n#[cfg_attr(\r\n    feature = \"serialize\",\r\n    derive(serde::Serialize, serde::Deserialize),\r\n    reflect(Serialize, Deserialize)\r\n)]\r\npub struct WindowDestroyed {\r\n    /// Window that has been destroyed.\r\n    ///\r\n    /// Note that this entity probably no longer exists\r\n    /// by the time this event is received.\r\n    pub window: Entity,\r\n}\r\n\r\n/// An event reporting that the mouse cursor has moved inside a window.\r\n///\r\n/// The event is sent only if the cursor is over one of the application's windows.\r\n/// It is the translated version of [`WindowEvent::CursorMoved`] from the `winit` crate with the addition of `delta`.\r\n///\r\n/// Not to be confused with the [`MouseMotion`] event from `bevy_input`.\r\n///\r\n/// Because the range of data is limited by the window area and it may have been transformed by the OS to implement certain effects like acceleration,\r\n/// you should not use it for non-cursor-like behaviour such as 3D camera control. Please see [`MouseMotion`] instead.\r\n///\r\n/// [`WindowEvent::CursorMoved`]: https://docs.rs/winit/latest/winit/event/enum.WindowEvent.html#variant.CursorMoved\r\n/// [`MouseMotion`]: bevy_input::mouse::MouseMotion\r\n#[derive(Event, Debug, Clone, PartialEq, Reflect)]\r\n#[reflect(Debug, PartialEq)]\r\n#[cfg_attr(\r\n    feature = \"serialize\",\r\n    derive(serde::Serialize, serde::Deserialize),\r\n    reflect(Serialize, Deserialize)\r\n)]\r\npub struct CursorMoved {\r\n    /// Window that the cursor moved inside.\r\n    pub window: Entity,\r\n    /// The cursor position in logical pixels.\r\n    pub position: Vec2,\r\n    /// The change in the position of the cursor since the last event was sent.\r\n    /// This value is `None` if the cursor was outside the window area during the last frame.\r\n    //\r\n    // Because the range of this data is limited by the display area and it may have been\r\n    //  transformed by the OS to implement effects such as cursor acceleration, it should\r\n    // not be used to implement non-cursor-like interactions such as 3D camera control.\r\n    pub delta: Option<Vec2>,\r\n}\r\n\r\n/// An event that is sent whenever the user's cursor enters a window.\r\n#[derive(Event, Debug, Clone, PartialEq, Eq, Reflect)]\r\n#[reflect(Debug, PartialEq)]\r\n#[cfg_attr(\r\n    feature = \"serialize\",\r\n    derive(serde::Serialize, serde::Deserialize),\r\n    reflect(Serialize, Deserialize)\r\n)]\r\npub struct CursorEntered {\r\n    /// Window that the cursor entered.\r\n    pub window: Entity,\r\n}\r\n\r\n/// An event that is sent whenever the user's cursor leaves a window.\r\n#[derive(Event, Debug, Clone, PartialEq, Eq, Reflect)]\r\n#[reflect(Debug, PartialEq)]\r\n#[cfg_attr(\r\n    feature = \"serialize\",\r\n    derive(serde::Serialize, serde::Deserialize),\r\n    reflect(Serialize, Deserialize)\r\n)]\r\npub struct CursorLeft {\r\n    /// Window that the cursor left.\r\n    pub window: Entity,\r\n}\r\n\r\n/// An event that is sent whenever a window receives a character from the OS or underlying system.\r\n#[derive(Event, Debug, Clone, PartialEq, Eq, Reflect)]\r\n#[reflect(Debug, PartialEq)]\r\n#[cfg_attr(\r\n    feature = \"serialize\",\r\n    derive(serde::Serialize, serde::Deserialize),\r\n    reflect(Serialize, Deserialize)\r\n)]\r\npub struct ReceivedCharacter {\r\n    /// Window that received the character.\r\n    pub window: Entity,\r\n    /// Received character.\r\n    pub char: SmolStr,\r\n}\r\n\r\n/// A Input Method Editor event.\r\n///\r\n/// This event is the translated version of the `WindowEvent::Ime` from the `winit` crate.\r\n///\r\n/// It is only sent if IME was enabled on the window with [`Window::ime_enabled`](crate::window::Window::ime_enabled).\r\n#[derive(Event, Debug, Clone, PartialEq, Eq, Reflect)]\r\n#[reflect(Debug, PartialEq)]\r\n#[cfg_attr(\r\n    feature = \"serialize\",\r\n    derive(serde::Serialize, serde::Deserialize),\r\n    reflect(Serialize, Deserialize)\r\n)]\r\npub enum Ime {\r\n    /// Notifies when a new composing text should be set at the cursor position.\r\n    Preedit {\r\n        /// Window that received the event.\r\n        window: Entity,\r\n        /// Current value.\r\n        value: String,\r\n        /// Cursor begin and end position.\r\n        ///\r\n        /// `None` indicated the cursor should be hidden\r\n        cursor: Option<(usize, usize)>,\r\n    },\r\n    /// Notifies when text should be inserted into the editor widget.\r\n    Commit {\r\n        /// Window that received the event.\r\n        window: Entity,\r\n        /// Input string\r\n        value: String,\r\n    },\r\n    /// Notifies when the IME was enabled.\r\n    ///\r\n    /// After this event, you will receive events `Ime::Preedit` and `Ime::Commit`,\r\n    /// and stop receiving events [`ReceivedCharacter`].\r\n    Enabled {\r\n        /// Window that received the event.\r\n        window: Entity,\r\n    },\r\n    /// Notifies when the IME was disabled.\r\n    Disabled {\r\n        /// Window that received the event.\r\n        window: Entity,\r\n    },\r\n}\r\n\r\n/// An event that indicates a window has received or lost focus.\r\n#[derive(Event, Debug, Clone, PartialEq, Eq, Reflect)]\r\n#[reflect(Debug, PartialEq)]\r\n#[cfg_attr(\r\n    feature = \"serialize\",\r\n    derive(serde::Serialize, serde::Deserialize),\r\n    reflect(Serialize, Deserialize)\r\n)]\r\npub struct WindowFocused {\r\n    /// Window that changed focus.\r\n    pub window: Entity,\r\n    /// Whether it was focused (true) or lost focused (false).\r\n    pub focused: bool,\r\n}\r\n\r\n/// The window has been occluded (completely hidden from view).\r\n///\r\n/// This is different to window visibility as it depends on\r\n/// whether the window is closed, minimised, set invisible,\r\n/// or fully occluded by another window.\r\n///\r\n/// It is the translated version of [`WindowEvent::Occluded`] from the `winit` crate.\r\n///\r\n/// [`WindowEvent::Occluded`]: https://docs.rs/winit/latest/winit/event/enum.WindowEvent.html#variant.Occluded\r\n#[derive(Event, Debug, Clone, PartialEq, Eq, Reflect)]\r\n#[reflect(Debug, PartialEq)]\r\n#[cfg_attr(\r\n    feature = \"serialize\",\r\n    derive(serde::Serialize, serde::Deserialize),\r\n    reflect(Serialize, Deserialize)\r\n)]\r\npub struct WindowOccluded {\r\n    /// Window that changed occluded state.\r\n    pub window: Entity,\r\n    /// Whether it was occluded (true) or not occluded (false).\r\n    pub occluded: bool,\r\n}\r\n\r\n/// An event that indicates a window's scale factor has changed.\r\n#[derive(Event, Debug, Clone, PartialEq, Reflect)]\r\n#[reflect(Debug, PartialEq)]\r\n#[cfg_attr(\r\n    feature = \"serialize\",\r\n    derive(serde::Serialize, serde::Deserialize),\r\n    reflect(Serialize, Deserialize)\r\n)]\r\npub struct WindowScaleFactorChanged {\r\n    /// Window that had it's scale factor changed.\r\n    pub window: Entity,\r\n    /// The new scale factor.\r\n    pub scale_factor: f64,\r\n}\r\n\r\n/// An event that indicates a window's OS-reported scale factor has changed.\r\n#[derive(Event, Debug, Clone, PartialEq, Reflect)]\r\n#[reflect(Debug, PartialEq)]\r\n#[cfg_attr(\r\n    feature = \"serialize\",\r\n    derive(serde::Serialize, serde::Deserialize),\r\n    reflect(Serialize, Deserialize)\r\n)]\r\npub struct WindowBackendScaleFactorChanged {\r\n    /// Window that had it's scale factor changed by the backend.\r\n    pub window: Entity,\r\n    /// The new scale factor.\r\n    pub scale_factor: f64,\r\n}\r\n\r\n/// Events related to files being dragged and dropped on a window.\r\n#[derive(Event, Debug, Clone, PartialEq, Eq, Reflect)]\r\n#[reflect(Debug, PartialEq)]\r\n#[cfg_attr(\r\n    feature = \"serialize\",\r\n    derive(serde::Serialize, serde::Deserialize),\r\n    reflect(Serialize, Deserialize)\r\n)]\r\npub enum FileDragAndDrop {\r\n    /// File is being dropped into a window.\r\n    DroppedFile {\r\n        /// Window the file was dropped into.\r\n        window: Entity,\r\n        /// Path to the file that was dropped in.\r\n        path_buf: PathBuf,\r\n    },\r\n\r\n    /// File is currently being hovered over a window.\r\n    HoveredFile {\r\n        /// Window a file is possibly going to be dropped into.\r\n        window: Entity,\r\n        /// Path to the file that might be dropped in.\r\n        path_buf: PathBuf,\r\n    },\r\n\r\n    /// File hovering was canceled.\r\n    HoveredFileCanceled {\r\n        /// Window that had a canceled file drop.\r\n        window: Entity,\r\n    },\r\n}\r\n\r\n/// An event that is sent when a window is repositioned in physical pixels.\r\n#[derive(Event, Debug, Clone, PartialEq, Eq, Reflect)]\r\n#[reflect(Debug, PartialEq)]\r\n#[cfg_attr(\r\n    feature = \"serialize\",\r\n    derive(serde::Serialize, serde::Deserialize),\r\n    reflect(Serialize, Deserialize)\r\n)]\r\npub struct WindowMoved {\r\n    /// Window that moved.\r\n    pub window: Entity,\r\n    /// Where the window moved to in physical pixels.\r\n    pub position: IVec2,\r\n}\r\n\r\n/// An event sent when the system theme changes for a window.\r\n///\r\n/// This event is only sent when the window is relying on the system theme to control its appearance.\r\n/// i.e. It is only sent when [`Window::window_theme`](crate::window::Window::window_theme) is `None` and the system theme changes.\r\n#[derive(Event, Debug, Clone, PartialEq, Eq, Reflect)]\r\n#[reflect(Debug, PartialEq)]\r\n#[cfg_attr(\r\n    feature = \"serialize\",\r\n    derive(serde::Serialize, serde::Deserialize),\r\n    reflect(Serialize, Deserialize)\r\n)]\r\npub struct WindowThemeChanged {\r\n    /// Window for which the system theme has changed.\r\n    pub window: Entity,\r\n    /// The new system theme.\r\n    pub theme: WindowTheme,\r\n}\r\n\r\n/// Application lifetime events\r\n#[derive(Event, Debug, Clone, Copy, PartialEq, Eq, Reflect)]\r\n#[reflect(Debug, PartialEq)]\r\n#[cfg_attr(\r\n    feature = \"serialize\",\r\n    derive(serde::Serialize, serde::Deserialize),\r\n    reflect(Serialize, Deserialize)\r\n)]\r\npub enum ApplicationLifetime {\r\n    /// The application just started.\r\n    Started,\r\n    /// The application was suspended.\r\n    ///\r\n    /// On Android, applications have one frame to react to this event before being paused in the background.\r\n    Suspended,\r\n    /// The application was resumed.\r\n    Resumed,\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\bevy\\crates\\bevy_ui\\src\\widget\\mod.rs\r\n\r\n````rust\r\n//! This module contains the basic building blocks of Bevy's UI\r\n\r\nmod button;\r\nmod image;\r\nmod label;\r\n#[cfg(feature = \"bevy_text\")]\r\nmod text;\r\n\r\npub use button::*;\r\npub use image::*;\r\npub use label::*;\r\n#[cfg(feature = \"bevy_text\")]\r\npub use text::*;\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\bevy\\crates\\bevy_ui\\src\\widget\\image.rs\r\n\r\n````rust\r\nuse crate::{measurement::AvailableSpace, ContentSize, Measure, Node, UiImage, UiScale};\r\nuse bevy_asset::Assets;\r\nuse bevy_ecs::prelude::*;\r\nuse bevy_math::{UVec2, Vec2};\r\nuse bevy_reflect::{std_traits::ReflectDefault, Reflect};\r\nuse bevy_render::texture::Image;\r\nuse bevy_sprite::{TextureAtlas, TextureAtlasLayout};\r\nuse bevy_window::{PrimaryWindow, Window};\r\n\r\n/// The size of the image's texture\r\n///\r\n/// This component is updated automatically by [`update_image_content_size_system`]\r\n#[derive(Component, Debug, Copy, Clone, Default, Reflect)]\r\n#[reflect(Component, Default)]\r\npub struct UiImageSize {\r\n    /// The size of the image's texture\r\n    ///\r\n    /// This field is updated automatically by [`update_image_content_size_system`]\r\n    size: UVec2,\r\n}\r\n\r\nimpl UiImageSize {\r\n    /// The size of the image's texture\r\n    pub fn size(&self) -> UVec2 {\r\n        self.size\r\n    }\r\n}\r\n\r\n#[derive(Clone)]\r\n/// Used to calculate the size of UI image nodes\r\npub struct ImageMeasure {\r\n    /// The size of the image's texture\r\n    pub size: Vec2,\r\n}\r\n\r\nimpl Measure for ImageMeasure {\r\n    fn measure(\r\n        &self,\r\n        width: Option<f32>,\r\n        height: Option<f32>,\r\n        _: AvailableSpace,\r\n        _: AvailableSpace,\r\n    ) -> Vec2 {\r\n        let mut size = self.size;\r\n        match (width, height) {\r\n            (None, None) => {}\r\n            (Some(width), None) => {\r\n                size.y = width * size.y / size.x;\r\n                size.x = width;\r\n            }\r\n            (None, Some(height)) => {\r\n                size.x = height * size.x / size.y;\r\n                size.y = height;\r\n            }\r\n            (Some(width), Some(height)) => {\r\n                size.x = width;\r\n                size.y = height;\r\n            }\r\n        }\r\n        size\r\n    }\r\n}\r\n\r\n#[cfg(feature = \"bevy_text\")]\r\ntype UpdateImageFilter = (With<Node>, Without<bevy_text::Text>);\r\n#[cfg(not(feature = \"bevy_text\"))]\r\ntype UpdateImageFilter = With<Node>;\r\n\r\n/// Updates content size of the node based on the image provided\r\npub fn update_image_content_size_system(\r\n    mut previous_combined_scale_factor: Local<f32>,\r\n    windows: Query<&Window, With<PrimaryWindow>>,\r\n    ui_scale: Res<UiScale>,\r\n    textures: Res<Assets<Image>>,\r\n    atlases: Res<Assets<TextureAtlasLayout>>,\r\n    mut query: Query<\r\n        (\r\n            &mut ContentSize,\r\n            &UiImage,\r\n            &mut UiImageSize,\r\n            Option<&TextureAtlas>,\r\n        ),\r\n        UpdateImageFilter,\r\n    >,\r\n) {\r\n    let combined_scale_factor = windows\r\n        .get_single()\r\n        .map(|window| window.resolution.scale_factor())\r\n        .unwrap_or(1.)\r\n        * ui_scale.0;\r\n\r\n    for (mut content_size, image, mut image_size, atlas_image) in &mut query {\r\n        if let Some(size) = match atlas_image {\r\n            Some(atlas) => atlas.texture_rect(&atlases).map(|t| t.size()),\r\n            None => textures.get(&image.texture).map(|t| t.size()),\r\n        } {\r\n            // Update only if size or scale factor has changed to avoid needless layout calculations\r\n            if size != image_size.size\r\n                || combined_scale_factor != *previous_combined_scale_factor\r\n                || content_size.is_added()\r\n            {\r\n                image_size.size = size;\r\n                content_size.set(ImageMeasure {\r\n                    // multiply the image size by the scale factor to get the physical size\r\n                    size: size.as_vec2() * combined_scale_factor,\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    *previous_combined_scale_factor = combined_scale_factor;\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\bevy\\crates\\bevy_render\\src\\view\\visibility\\mod.rs\r\n\r\n````rust\r\nmod render_layers;\r\n\r\nuse bevy_derive::Deref;\r\npub use render_layers::*;\r\n\r\nuse bevy_app::{Plugin, PostUpdate};\r\nuse bevy_asset::{Assets, Handle};\r\nuse bevy_ecs::prelude::*;\r\nuse bevy_hierarchy::{Children, Parent};\r\nuse bevy_reflect::{std_traits::ReflectDefault, Reflect};\r\nuse bevy_transform::{components::GlobalTransform, TransformSystem};\r\nuse bevy_utils::Parallel;\r\n\r\nuse crate::deterministic::DeterministicRenderingConfig;\r\nuse crate::{\r\n    camera::{\r\n        camera_system, Camera, CameraProjection, OrthographicProjection, PerspectiveProjection,\r\n        Projection,\r\n    },\r\n    mesh::Mesh,\r\n    primitives::{Aabb, Frustum, Sphere},\r\n};\r\n\r\n/// User indication of whether an entity is visible. Propagates down the entity hierarchy.\r\n///\r\n/// If an entity is hidden in this way, all [`Children`] (and all of their children and so on) who\r\n/// are set to [`Inherited`](Self::Inherited) will also be hidden.\r\n///\r\n/// This is done by the `visibility_propagate_system` which uses the entity hierarchy and\r\n/// `Visibility` to set the values of each entity's [`InheritedVisibility`] component.\r\n#[derive(Component, Clone, Copy, Reflect, Debug, PartialEq, Eq, Default)]\r\n#[reflect(Component, Default)]\r\npub enum Visibility {\r\n    /// An entity with `Visibility::Inherited` will inherit the Visibility of its [`Parent`].\r\n    ///\r\n    /// A root-level entity that is set to `Inherited` will be visible.\r\n    #[default]\r\n    Inherited,\r\n    /// An entity with `Visibility::Hidden` will be unconditionally hidden.\r\n    Hidden,\r\n    /// An entity with `Visibility::Visible` will be unconditionally visible.\r\n    ///\r\n    /// Note that an entity with `Visibility::Visible` will be visible regardless of whether the\r\n    /// [`Parent`] entity is hidden.\r\n    Visible,\r\n}\r\n\r\n// Allows `&Visibility == Visibility`\r\nimpl PartialEq<Visibility> for &Visibility {\r\n    #[inline]\r\n    fn eq(&self, other: &Visibility) -> bool {\r\n        // Use the base Visibility == Visibility implementation.\r\n        <Visibility as PartialEq<Visibility>>::eq(*self, other)\r\n    }\r\n}\r\n\r\n// Allows `Visibility == &Visibility`\r\nimpl PartialEq<&Visibility> for Visibility {\r\n    #[inline]\r\n    fn eq(&self, other: &&Visibility) -> bool {\r\n        // Use the base Visibility == Visibility implementation.\r\n        <Visibility as PartialEq<Visibility>>::eq(self, *other)\r\n    }\r\n}\r\n\r\n/// Whether or not an entity is visible in the hierarchy.\r\n/// This will not be accurate until [`VisibilityPropagate`] runs in the [`PostUpdate`] schedule.\r\n///\r\n/// If this is false, then [`ViewVisibility`] should also be false.\r\n///\r\n/// [`VisibilityPropagate`]: VisibilitySystems::VisibilityPropagate\r\n#[derive(Component, Deref, Debug, Default, Clone, Copy, Reflect, PartialEq, Eq)]\r\n#[reflect(Component, Default)]\r\npub struct InheritedVisibility(bool);\r\n\r\nimpl InheritedVisibility {\r\n    /// An entity that is invisible in the hierarchy.\r\n    pub const HIDDEN: Self = Self(false);\r\n    /// An entity that is visible in the hierarchy.\r\n    pub const VISIBLE: Self = Self(true);\r\n\r\n    /// Returns `true` if the entity is visible in the hierarchy.\r\n    /// Otherwise, returns `false`.\r\n    #[inline]\r\n    pub fn get(self) -> bool {\r\n        self.0\r\n    }\r\n}\r\n\r\n/// Algorithmically-computed indication of whether an entity is visible and should be extracted for rendering.\r\n///\r\n/// Each frame, this will be reset to `false` during [`VisibilityPropagate`] systems in [`PostUpdate`].\r\n/// Later in the frame, systems in [`CheckVisibility`] will mark any visible entities using [`ViewVisibility::set`].\r\n/// Because of this, values of this type will be marked as changed every frame, even when they do not change.\r\n///\r\n/// If you wish to add custom visibility system that sets this value, make sure you add it to the [`CheckVisibility`] set.\r\n///\r\n/// [`VisibilityPropagate`]: VisibilitySystems::VisibilityPropagate\r\n/// [`CheckVisibility`]: VisibilitySystems::CheckVisibility\r\n#[derive(Component, Deref, Debug, Default, Clone, Copy, Reflect, PartialEq, Eq)]\r\n#[reflect(Component, Default)]\r\npub struct ViewVisibility(bool);\r\n\r\nimpl ViewVisibility {\r\n    /// An entity that cannot be seen from any views.\r\n    pub const HIDDEN: Self = Self(false);\r\n\r\n    /// Returns `true` if the entity is visible in any view.\r\n    /// Otherwise, returns `false`.\r\n    #[inline]\r\n    pub fn get(self) -> bool {\r\n        self.0\r\n    }\r\n\r\n    /// Sets the visibility to `true`. This should not be considered reversible for a given frame,\r\n    /// as this component tracks whether or not the entity visible in _any_ view.\r\n    ///\r\n    /// This will be automatically reset to `false` every frame in [`VisibilityPropagate`] and then set\r\n    /// to the proper value in [`CheckVisibility`].\r\n    ///\r\n    /// You should only manually set this if you are defining a custom visibility system,\r\n    /// in which case the system should be placed in the [`CheckVisibility`] set.\r\n    /// For normal user-defined entity visibility, see [`Visibility`].\r\n    ///\r\n    /// [`VisibilityPropagate`]: VisibilitySystems::VisibilityPropagate\r\n    /// [`CheckVisibility`]: VisibilitySystems::CheckVisibility\r\n    #[inline]\r\n    pub fn set(&mut self) {\r\n        self.0 = true;\r\n    }\r\n}\r\n\r\n/// A [`Bundle`] of the [`Visibility`], [`InheritedVisibility`], and [`ViewVisibility`]\r\n/// [`Component`]s, which describe the visibility of an entity.\r\n///\r\n/// * To show or hide an entity, you should set its [`Visibility`].\r\n/// * To get the inherited visibility of an entity, you should get its [`InheritedVisibility`].\r\n/// * For visibility hierarchies to work correctly, you must have both all of [`Visibility`], [`InheritedVisibility`], and [`ViewVisibility`].\r\n///   * You may use the [`VisibilityBundle`] to guarantee this.\r\n#[derive(Bundle, Debug, Clone, Default)]\r\npub struct VisibilityBundle {\r\n    /// The visibility of the entity.\r\n    pub visibility: Visibility,\r\n    // The inherited visibility of the entity.\r\n    pub inherited_visibility: InheritedVisibility,\r\n    // The computed visibility of the entity.\r\n    pub view_visibility: ViewVisibility,\r\n}\r\n\r\n/// Use this component to opt-out of built-in frustum culling for entities, see\r\n/// [`Frustum`].\r\n///\r\n/// It can be used for example:\r\n/// - when a [`Mesh`] is updated but its [`Aabb`] is not, which might happen with animations,\r\n/// - when using some light effects, like wanting a [`Mesh`] out of the [`Frustum`]\r\n/// to appear in the reflection of a [`Mesh`] within.\r\n#[derive(Component, Default, Reflect)]\r\n#[reflect(Component, Default)]\r\npub struct NoFrustumCulling;\r\n\r\n/// Collection of entities visible from the current view.\r\n///\r\n/// This component contains all entities which are visible from the currently\r\n/// rendered view. The collection is updated automatically by the [`VisibilitySystems::CheckVisibility`]\r\n/// system set, and renderers can use it to optimize rendering of a particular view, to\r\n/// prevent drawing items not visible from that view.\r\n///\r\n/// This component is intended to be attached to the same entity as the [`Camera`] and\r\n/// the [`Frustum`] defining the view.\r\n#[derive(Clone, Component, Default, Debug, Reflect)]\r\n#[reflect(Component)]\r\npub struct VisibleEntities {\r\n    #[reflect(ignore)]\r\n    pub entities: Vec<Entity>,\r\n}\r\n\r\nimpl VisibleEntities {\r\n    pub fn iter(&self) -> impl DoubleEndedIterator<Item = &Entity> {\r\n        self.entities.iter()\r\n    }\r\n\r\n    pub fn len(&self) -> usize {\r\n        self.entities.len()\r\n    }\r\n\r\n    pub fn is_empty(&self) -> bool {\r\n        self.entities.is_empty()\r\n    }\r\n}\r\n\r\n#[derive(Debug, Hash, PartialEq, Eq, Clone, SystemSet)]\r\npub enum VisibilitySystems {\r\n    /// Label for the [`calculate_bounds`], `calculate_bounds_2d` and `calculate_bounds_text2d` systems,\r\n    /// calculating and inserting an [`Aabb`] to relevant entities.\r\n    CalculateBounds,\r\n    /// Label for the [`update_frusta<OrthographicProjection>`] system.\r\n    UpdateOrthographicFrusta,\r\n    /// Label for the [`update_frusta<PerspectiveProjection>`] system.\r\n    UpdatePerspectiveFrusta,\r\n    /// Label for the [`update_frusta<Projection>`] system.\r\n    UpdateProjectionFrusta,\r\n    /// Label for the system propagating the [`InheritedVisibility`] in a\r\n    /// [`hierarchy`](bevy_hierarchy).\r\n    VisibilityPropagate,\r\n    /// Label for the [`check_visibility`] system updating [`ViewVisibility`]\r\n    /// of each entity and the [`VisibleEntities`] of each view.\r\n    CheckVisibility,\r\n}\r\n\r\npub struct VisibilityPlugin;\r\n\r\nimpl Plugin for VisibilityPlugin {\r\n    fn build(&self, app: &mut bevy_app::App) {\r\n        use VisibilitySystems::*;\r\n\r\n        app.add_systems(\r\n            PostUpdate,\r\n            (\r\n                calculate_bounds.in_set(CalculateBounds),\r\n                update_frusta::<OrthographicProjection>\r\n                    .in_set(UpdateOrthographicFrusta)\r\n                    .after(camera_system::<OrthographicProjection>)\r\n                    .after(TransformSystem::TransformPropagate)\r\n                    // We assume that no camera will have more than one projection component,\r\n                    // so these systems will run independently of one another.\r\n                    // FIXME: Add an archetype invariant for this https://github.com/bevyengine/bevy/issues/1481.\r\n                    .ambiguous_with(update_frusta::<PerspectiveProjection>)\r\n                    .ambiguous_with(update_frusta::<Projection>),\r\n                update_frusta::<PerspectiveProjection>\r\n                    .in_set(UpdatePerspectiveFrusta)\r\n                    .after(camera_system::<PerspectiveProjection>)\r\n                    .after(TransformSystem::TransformPropagate)\r\n                    // We assume that no camera will have more than one projection component,\r\n                    // so these systems will run independently of one another.\r\n                    // FIXME: Add an archetype invariant for this https://github.com/bevyengine/bevy/issues/1481.\r\n                    .ambiguous_with(update_frusta::<Projection>),\r\n                update_frusta::<Projection>\r\n                    .in_set(UpdateProjectionFrusta)\r\n                    .after(camera_system::<Projection>)\r\n                    .after(TransformSystem::TransformPropagate),\r\n                (visibility_propagate_system, reset_view_visibility).in_set(VisibilityPropagate),\r\n                check_visibility\r\n                    .in_set(CheckVisibility)\r\n                    .after(CalculateBounds)\r\n                    .after(UpdateOrthographicFrusta)\r\n                    .after(UpdatePerspectiveFrusta)\r\n                    .after(UpdateProjectionFrusta)\r\n                    .after(VisibilityPropagate)\r\n                    .after(TransformSystem::TransformPropagate),\r\n            ),\r\n        );\r\n    }\r\n}\r\n\r\n/// Computes and adds an [`Aabb`] component to entities with a\r\n/// [`Handle<Mesh>`](Mesh) component and without a [`NoFrustumCulling`] component.\r\n///\r\n/// This system is used in system set [`VisibilitySystems::CalculateBounds`].\r\npub fn calculate_bounds(\r\n    mut commands: Commands,\r\n    meshes: Res<Assets<Mesh>>,\r\n    without_aabb: Query<(Entity, &Handle<Mesh>), (Without<Aabb>, Without<NoFrustumCulling>)>,\r\n) {\r\n    for (entity, mesh_handle) in &without_aabb {\r\n        if let Some(mesh) = meshes.get(mesh_handle) {\r\n            if let Some(aabb) = mesh.compute_aabb() {\r\n                commands.entity(entity).try_insert(aabb);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/// Updates [`Frustum`].\r\n///\r\n/// This system is used in system sets [`VisibilitySystems::UpdateProjectionFrusta`],\r\n/// [`VisibilitySystems::UpdatePerspectiveFrusta`], and\r\n/// [`VisibilitySystems::UpdateOrthographicFrusta`].\r\npub fn update_frusta<T: Component + CameraProjection + Send + Sync + 'static>(\r\n    mut views: Query<\r\n        (&GlobalTransform, &T, &mut Frustum),\r\n        Or<(Changed<GlobalTransform>, Changed<T>)>,\r\n    >,\r\n) {\r\n    for (transform, projection, mut frustum) in &mut views {\r\n        *frustum = projection.compute_frustum(transform);\r\n    }\r\n}\r\n\r\nfn visibility_propagate_system(\r\n    changed: Query<\r\n        (Entity, &Visibility, Option<&Parent>, Option<&Children>),\r\n        (With<InheritedVisibility>, Changed<Visibility>),\r\n    >,\r\n    mut visibility_query: Query<(&Visibility, &mut InheritedVisibility)>,\r\n    children_query: Query<&Children, (With<Visibility>, With<InheritedVisibility>)>,\r\n) {\r\n    for (entity, visibility, parent, children) in &changed {\r\n        let is_visible = match visibility {\r\n            Visibility::Visible => true,\r\n            Visibility::Hidden => false,\r\n            // fall back to true if no parent is found or parent lacks components\r\n            Visibility::Inherited => parent\r\n                .and_then(|p| visibility_query.get(p.get()).ok())\r\n                .map_or(true, |(_, x)| x.get()),\r\n        };\r\n        let (_, mut inherited_visibility) = visibility_query\r\n            .get_mut(entity)\r\n            .expect(\"With<InheritedVisibility> ensures this query will return a value\");\r\n\r\n        // Only update the visibility if it has changed.\r\n        // This will also prevent the visibility from propagating multiple times in the same frame\r\n        // if this entity's visibility has been updated recursively by its parent.\r\n        if inherited_visibility.get() != is_visible {\r\n            inherited_visibility.0 = is_visible;\r\n\r\n            // Recursively update the visibility of each child.\r\n            for &child in children.into_iter().flatten() {\r\n                let _ =\r\n                    propagate_recursive(is_visible, child, &mut visibility_query, &children_query);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfn propagate_recursive(\r\n    parent_is_visible: bool,\r\n    entity: Entity,\r\n    visibility_query: &mut Query<(&Visibility, &mut InheritedVisibility)>,\r\n    children_query: &Query<&Children, (With<Visibility>, With<InheritedVisibility>)>,\r\n    // BLOCKED: https://github.com/rust-lang/rust/issues/31436\r\n    // We use a result here to use the `?` operator. Ideally we'd use a try block instead\r\n) -> Result<(), ()> {\r\n    // Get the visibility components for the current entity.\r\n    // If the entity does not have the required components, just return early.\r\n    let (visibility, mut inherited_visibility) = visibility_query.get_mut(entity).map_err(drop)?;\r\n\r\n    let is_visible = match visibility {\r\n        Visibility::Visible => true,\r\n        Visibility::Hidden => false,\r\n        Visibility::Inherited => parent_is_visible,\r\n    };\r\n\r\n    // Only update the visibility if it has changed.\r\n    if inherited_visibility.get() != is_visible {\r\n        inherited_visibility.0 = is_visible;\r\n\r\n        // Recursively update the visibility of each child.\r\n        for &child in children_query.get(entity).ok().into_iter().flatten() {\r\n            let _ = propagate_recursive(is_visible, child, visibility_query, children_query);\r\n        }\r\n    }\r\n\r\n    Ok(())\r\n}\r\n\r\n/// Resets the view visibility of every entity.\r\n/// Entities that are visible will be marked as such later this frame\r\n/// by a [`VisibilitySystems::CheckVisibility`] system.\r\nfn reset_view_visibility(mut query: Query<&mut ViewVisibility>) {\r\n    for mut view_visibility in &mut query {\r\n        // NOTE: We do not use `set_if_neq` here, as we don't care about\r\n        // change detection for view visibility, and adding a branch to every\r\n        // loop iteration would pessimize performance.\r\n        *view_visibility = ViewVisibility::HIDDEN;\r\n    }\r\n}\r\n\r\n/// System updating the visibility of entities each frame.\r\n///\r\n/// The system is part of the [`VisibilitySystems::CheckVisibility`] set. Each frame, it updates the\r\n/// [`ViewVisibility`] of all entities, and for each view also compute the [`VisibleEntities`]\r\n/// for that view.\r\npub fn check_visibility(\r\n    mut thread_queues: Local<Parallel<Vec<Entity>>>,\r\n    mut view_query: Query<(\r\n        &mut VisibleEntities,\r\n        &Frustum,\r\n        Option<&RenderLayers>,\r\n        &Camera,\r\n    )>,\r\n    mut visible_aabb_query: Query<(\r\n        Entity,\r\n        &InheritedVisibility,\r\n        &mut ViewVisibility,\r\n        Option<&RenderLayers>,\r\n        Option<&Aabb>,\r\n        &GlobalTransform,\r\n        Has<NoFrustumCulling>,\r\n    )>,\r\n    deterministic_rendering_config: Res<DeterministicRenderingConfig>,\r\n) {\r\n    for (mut visible_entities, frustum, maybe_view_mask, camera) in &mut view_query {\r\n        if !camera.is_active {\r\n            continue;\r\n        }\r\n\r\n        let view_mask = maybe_view_mask.copied().unwrap_or_default();\r\n\r\n        visible_entities.entities.clear();\r\n        visible_aabb_query.par_iter_mut().for_each(|query_item| {\r\n            let (\r\n                entity,\r\n                inherited_visibility,\r\n                mut view_visibility,\r\n                maybe_entity_mask,\r\n                maybe_model_aabb,\r\n                transform,\r\n                no_frustum_culling,\r\n            ) = query_item;\r\n\r\n            // Skip computing visibility for entities that are configured to be hidden.\r\n            // ViewVisibility has already been reset in `reset_view_visibility`.\r\n            if !inherited_visibility.get() {\r\n                return;\r\n            }\r\n\r\n            let entity_mask = maybe_entity_mask.copied().unwrap_or_default();\r\n            if !view_mask.intersects(&entity_mask) {\r\n                return;\r\n            }\r\n\r\n            // If we have an aabb, do frustum culling\r\n            if !no_frustum_culling {\r\n                if let Some(model_aabb) = maybe_model_aabb {\r\n                    let model = transform.affine();\r\n                    let model_sphere = Sphere {\r\n                        center: model.transform_point3a(model_aabb.center),\r\n                        radius: transform.radius_vec3a(model_aabb.half_extents),\r\n                    };\r\n                    // Do quick sphere-based frustum culling\r\n                    if !frustum.intersects_sphere(&model_sphere, false) {\r\n                        return;\r\n                    }\r\n                    // Do aabb-based frustum culling\r\n                    if !frustum.intersects_obb(model_aabb, &model, true, false) {\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n\r\n            view_visibility.set();\r\n            thread_queues.scope(|queue| {\r\n                queue.push(entity);\r\n            });\r\n        });\r\n\r\n        visible_entities.entities.clear();\r\n        thread_queues.drain_into(&mut visible_entities.entities);\r\n        if deterministic_rendering_config.stable_sort_z_fighting {\r\n            // We can use the faster unstable sort here because\r\n            // the values (`Entity`) are guaranteed to be unique.\r\n            visible_entities.entities.sort_unstable();\r\n        }\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod test {\r\n    use bevy_app::prelude::*;\r\n    use bevy_ecs::prelude::*;\r\n\r\n    use super::*;\r\n\r\n    use bevy_hierarchy::BuildWorldChildren;\r\n\r\n    fn visibility_bundle(visibility: Visibility) -> VisibilityBundle {\r\n        VisibilityBundle {\r\n            visibility,\r\n            ..Default::default()\r\n        }\r\n    }\r\n\r\n    #[test]\r\n    fn visibility_propagation() {\r\n        let mut app = App::new();\r\n        app.add_systems(Update, visibility_propagate_system);\r\n\r\n        let root1 = app.world.spawn(visibility_bundle(Visibility::Hidden)).id();\r\n        let root1_child1 = app.world.spawn(VisibilityBundle::default()).id();\r\n        let root1_child2 = app.world.spawn(visibility_bundle(Visibility::Hidden)).id();\r\n        let root1_child1_grandchild1 = app.world.spawn(VisibilityBundle::default()).id();\r\n        let root1_child2_grandchild1 = app.world.spawn(VisibilityBundle::default()).id();\r\n\r\n        app.world\r\n            .entity_mut(root1)\r\n            .push_children(&[root1_child1, root1_child2]);\r\n        app.world\r\n            .entity_mut(root1_child1)\r\n            .push_children(&[root1_child1_grandchild1]);\r\n        app.world\r\n            .entity_mut(root1_child2)\r\n            .push_children(&[root1_child2_grandchild1]);\r\n\r\n        let root2 = app.world.spawn(VisibilityBundle::default()).id();\r\n        let root2_child1 = app.world.spawn(VisibilityBundle::default()).id();\r\n        let root2_child2 = app.world.spawn(visibility_bundle(Visibility::Hidden)).id();\r\n        let root2_child1_grandchild1 = app.world.spawn(VisibilityBundle::default()).id();\r\n        let root2_child2_grandchild1 = app.world.spawn(VisibilityBundle::default()).id();\r\n\r\n        app.world\r\n            .entity_mut(root2)\r\n            .push_children(&[root2_child1, root2_child2]);\r\n        app.world\r\n            .entity_mut(root2_child1)\r\n            .push_children(&[root2_child1_grandchild1]);\r\n        app.world\r\n            .entity_mut(root2_child2)\r\n            .push_children(&[root2_child2_grandchild1]);\r\n\r\n        app.update();\r\n\r\n        let is_visible = |e: Entity| {\r\n            app.world\r\n                .entity(e)\r\n                .get::<InheritedVisibility>()\r\n                .unwrap()\r\n                .get()\r\n        };\r\n        assert!(\r\n            !is_visible(root1),\r\n            \"invisibility propagates down tree from root\"\r\n        );\r\n        assert!(\r\n            !is_visible(root1_child1),\r\n            \"invisibility propagates down tree from root\"\r\n        );\r\n        assert!(\r\n            !is_visible(root1_child2),\r\n            \"invisibility propagates down tree from root\"\r\n        );\r\n        assert!(\r\n            !is_visible(root1_child1_grandchild1),\r\n            \"invisibility propagates down tree from root\"\r\n        );\r\n        assert!(\r\n            !is_visible(root1_child2_grandchild1),\r\n            \"invisibility propagates down tree from root\"\r\n        );\r\n\r\n        assert!(\r\n            is_visible(root2),\r\n            \"visibility propagates down tree from root\"\r\n        );\r\n        assert!(\r\n            is_visible(root2_child1),\r\n            \"visibility propagates down tree from root\"\r\n        );\r\n        assert!(\r\n            !is_visible(root2_child2),\r\n            \"visibility propagates down tree from root, but local invisibility is preserved\"\r\n        );\r\n        assert!(\r\n            is_visible(root2_child1_grandchild1),\r\n            \"visibility propagates down tree from root\"\r\n        );\r\n        assert!(\r\n            !is_visible(root2_child2_grandchild1),\r\n            \"child's invisibility propagates down to grandchild\"\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    fn visibility_propagation_unconditional_visible() {\r\n        use Visibility::{Hidden, Inherited, Visible};\r\n\r\n        let mut app = App::new();\r\n        app.add_systems(Update, visibility_propagate_system);\r\n\r\n        let root1 = app.world.spawn(visibility_bundle(Visible)).id();\r\n        let root1_child1 = app.world.spawn(visibility_bundle(Inherited)).id();\r\n        let root1_child2 = app.world.spawn(visibility_bundle(Hidden)).id();\r\n        let root1_child1_grandchild1 = app.world.spawn(visibility_bundle(Visible)).id();\r\n        let root1_child2_grandchild1 = app.world.spawn(visibility_bundle(Visible)).id();\r\n\r\n        let root2 = app.world.spawn(visibility_bundle(Inherited)).id();\r\n        let root3 = app.world.spawn(visibility_bundle(Hidden)).id();\r\n\r\n        app.world\r\n            .entity_mut(root1)\r\n            .push_children(&[root1_child1, root1_child2]);\r\n        app.world\r\n            .entity_mut(root1_child1)\r\n            .push_children(&[root1_child1_grandchild1]);\r\n        app.world\r\n            .entity_mut(root1_child2)\r\n            .push_children(&[root1_child2_grandchild1]);\r\n\r\n        app.update();\r\n\r\n        let is_visible = |e: Entity| {\r\n            app.world\r\n                .entity(e)\r\n                .get::<InheritedVisibility>()\r\n                .unwrap()\r\n                .get()\r\n        };\r\n        assert!(\r\n            is_visible(root1),\r\n            \"an unconditionally visible root is visible\"\r\n        );\r\n        assert!(\r\n            is_visible(root1_child1),\r\n            \"an inheriting child of an unconditionally visible parent is visible\"\r\n        );\r\n        assert!(\r\n            !is_visible(root1_child2),\r\n            \"a hidden child on an unconditionally visible parent is hidden\"\r\n        );\r\n        assert!(\r\n            is_visible(root1_child1_grandchild1),\r\n            \"an unconditionally visible child of an inheriting parent is visible\"\r\n        );\r\n        assert!(\r\n            is_visible(root1_child2_grandchild1),\r\n            \"an unconditionally visible child of a hidden parent is visible\"\r\n        );\r\n        assert!(is_visible(root2), \"an inheriting root is visible\");\r\n        assert!(!is_visible(root3), \"a hidden root is hidden\");\r\n    }\r\n\r\n    #[test]\r\n    fn visibility_propagation_change_detection() {\r\n        let mut world = World::new();\r\n        let mut schedule = Schedule::default();\r\n        schedule.add_systems(visibility_propagate_system);\r\n\r\n        // Set up an entity hierarchy.\r\n\r\n        let id1 = world.spawn(VisibilityBundle::default()).id();\r\n\r\n        let id2 = world.spawn(VisibilityBundle::default()).id();\r\n        world.entity_mut(id1).push_children(&[id2]);\r\n\r\n        let id3 = world.spawn(visibility_bundle(Visibility::Hidden)).id();\r\n        world.entity_mut(id2).push_children(&[id3]);\r\n\r\n        let id4 = world.spawn(VisibilityBundle::default()).id();\r\n        world.entity_mut(id3).push_children(&[id4]);\r\n\r\n        // Test the hierarchy.\r\n\r\n        // Make sure the hierarchy is up-to-date.\r\n        schedule.run(&mut world);\r\n        world.clear_trackers();\r\n\r\n        let mut q = world.query::<Ref<InheritedVisibility>>();\r\n\r\n        assert!(!q.get(&world, id1).unwrap().is_changed());\r\n        assert!(!q.get(&world, id2).unwrap().is_changed());\r\n        assert!(!q.get(&world, id3).unwrap().is_changed());\r\n        assert!(!q.get(&world, id4).unwrap().is_changed());\r\n\r\n        world.clear_trackers();\r\n        world.entity_mut(id1).insert(Visibility::Hidden);\r\n        schedule.run(&mut world);\r\n\r\n        assert!(q.get(&world, id1).unwrap().is_changed());\r\n        assert!(q.get(&world, id2).unwrap().is_changed());\r\n        assert!(!q.get(&world, id3).unwrap().is_changed());\r\n        assert!(!q.get(&world, id4).unwrap().is_changed());\r\n\r\n        world.clear_trackers();\r\n        schedule.run(&mut world);\r\n\r\n        assert!(!q.get(&world, id1).unwrap().is_changed());\r\n        assert!(!q.get(&world, id2).unwrap().is_changed());\r\n        assert!(!q.get(&world, id3).unwrap().is_changed());\r\n        assert!(!q.get(&world, id4).unwrap().is_changed());\r\n\r\n        world.clear_trackers();\r\n        world.entity_mut(id3).insert(Visibility::Inherited);\r\n        schedule.run(&mut world);\r\n\r\n        assert!(!q.get(&world, id1).unwrap().is_changed());\r\n        assert!(!q.get(&world, id2).unwrap().is_changed());\r\n        assert!(!q.get(&world, id3).unwrap().is_changed());\r\n        assert!(!q.get(&world, id4).unwrap().is_changed());\r\n\r\n        world.clear_trackers();\r\n        world.entity_mut(id2).insert(Visibility::Visible);\r\n        schedule.run(&mut world);\r\n\r\n        assert!(!q.get(&world, id1).unwrap().is_changed());\r\n        assert!(q.get(&world, id2).unwrap().is_changed());\r\n        assert!(q.get(&world, id3).unwrap().is_changed());\r\n        assert!(q.get(&world, id4).unwrap().is_changed());\r\n\r\n        world.clear_trackers();\r\n        schedule.run(&mut world);\r\n\r\n        assert!(!q.get(&world, id1).unwrap().is_changed());\r\n        assert!(!q.get(&world, id2).unwrap().is_changed());\r\n        assert!(!q.get(&world, id3).unwrap().is_changed());\r\n        assert!(!q.get(&world, id4).unwrap().is_changed());\r\n    }\r\n\r\n    #[test]\r\n    fn visibility_propagation_with_invalid_parent() {\r\n        let mut world = World::new();\r\n        let mut schedule = Schedule::default();\r\n        schedule.add_systems(visibility_propagate_system);\r\n\r\n        let parent = world.spawn(()).id();\r\n        let child = world.spawn(VisibilityBundle::default()).id();\r\n        world.entity_mut(parent).push_children(&[child]);\r\n\r\n        schedule.run(&mut world);\r\n        world.clear_trackers();\r\n\r\n        let child_visible = world.entity(child).get::<InheritedVisibility>().unwrap().0;\r\n        // defaults to same behavior of parent not found: visible = true\r\n        assert!(child_visible);\r\n    }\r\n\r\n    #[test]\r\n    fn ensure_visibility_enum_size() {\r\n        use std::mem;\r\n        assert_eq!(1, mem::size_of::<Visibility>());\r\n        assert_eq!(1, mem::size_of::<Option<Visibility>>());\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\bevy\\crates\\bevy_winit\\src\\winit_windows.rs\r\n\r\n````rust\r\nuse accesskit_winit::Adapter;\r\nuse bevy_a11y::{\r\n    accesskit::{NodeBuilder, NodeClassSet, NodeId, Role, Tree, TreeUpdate},\r\n    AccessibilityRequested,\r\n};\r\nuse bevy_ecs::entity::Entity;\r\n\r\nuse bevy_ecs::entity::EntityHashMap;\r\nuse bevy_utils::{tracing::warn, HashMap};\r\nuse bevy_window::{CursorGrabMode, Window, WindowMode, WindowPosition, WindowResolution};\r\n\r\nuse winit::{\r\n    dpi::{LogicalSize, PhysicalPosition},\r\n    monitor::MonitorHandle,\r\n};\r\n\r\nuse crate::{\r\n    accessibility::{AccessKitAdapters, WinitActionHandler, WinitActionHandlers},\r\n    converters::{convert_enabled_buttons, convert_window_level, convert_window_theme},\r\n};\r\n\r\n/// A resource mapping window entities to their `winit`-backend [`Window`](winit::window::Window)\r\n/// states.\r\n#[derive(Debug, Default)]\r\npub struct WinitWindows {\r\n    /// Stores [`winit`] windows by window identifier.\r\n    pub windows: HashMap<winit::window::WindowId, winit::window::Window>,\r\n    /// Maps entities to `winit` window identifiers.\r\n    pub entity_to_winit: EntityHashMap<winit::window::WindowId>,\r\n    /// Maps `winit` window identifiers to entities.\r\n    pub winit_to_entity: HashMap<winit::window::WindowId, Entity>,\r\n    // Many `winit` window functions (e.g. `set_window_icon`) can only be called on the main thread.\r\n    // If they're called on other threads, the program might hang. This marker indicates that this\r\n    // type is not thread-safe and will be `!Send` and `!Sync`.\r\n    _not_send_sync: core::marker::PhantomData<*const ()>,\r\n}\r\n\r\nimpl WinitWindows {\r\n    /// Creates a `winit` window and associates it with our entity.\r\n    pub fn create_window(\r\n        &mut self,\r\n        event_loop: &winit::event_loop::EventLoopWindowTarget<crate::UserEvent>,\r\n        entity: Entity,\r\n        window: &Window,\r\n        adapters: &mut AccessKitAdapters,\r\n        handlers: &mut WinitActionHandlers,\r\n        accessibility_requested: &AccessibilityRequested,\r\n    ) -> &winit::window::Window {\r\n        let mut winit_window_builder = winit::window::WindowBuilder::new();\r\n\r\n        // Due to a UIA limitation, winit windows need to be invisible for the\r\n        // AccessKit adapter is initialized.\r\n        winit_window_builder = winit_window_builder.with_visible(false);\r\n\r\n        winit_window_builder = match window.mode {\r\n            WindowMode::BorderlessFullscreen => winit_window_builder.with_fullscreen(Some(\r\n                winit::window::Fullscreen::Borderless(event_loop.primary_monitor()),\r\n            )),\r\n            mode @ (WindowMode::Fullscreen | WindowMode::SizedFullscreen) => {\r\n                if let Some(primary_monitor) = event_loop.primary_monitor() {\r\n                    let videomode = match mode {\r\n                        WindowMode::Fullscreen => get_best_videomode(&primary_monitor),\r\n                        WindowMode::SizedFullscreen => get_fitting_videomode(\r\n                            &primary_monitor,\r\n                            window.width() as u32,\r\n                            window.height() as u32,\r\n                        ),\r\n                        _ => unreachable!(),\r\n                    };\r\n\r\n                    winit_window_builder\r\n                        .with_fullscreen(Some(winit::window::Fullscreen::Exclusive(videomode)))\r\n                } else {\r\n                    warn!(\"Could not determine primary monitor, ignoring exclusive fullscreen request for window {:?}\", window.title);\r\n                    winit_window_builder\r\n                }\r\n            }\r\n            WindowMode::Windowed => {\r\n                if let Some(position) = winit_window_position(\r\n                    &window.position,\r\n                    &window.resolution,\r\n                    event_loop.available_monitors(),\r\n                    event_loop.primary_monitor(),\r\n                    None,\r\n                ) {\r\n                    winit_window_builder = winit_window_builder.with_position(position);\r\n                }\r\n\r\n                let logical_size = LogicalSize::new(window.width(), window.height());\r\n                if let Some(sf) = window.resolution.scale_factor_override() {\r\n                    winit_window_builder.with_inner_size(logical_size.to_physical::<f64>(sf.into()))\r\n                } else {\r\n                    winit_window_builder.with_inner_size(logical_size)\r\n                }\r\n            }\r\n        };\r\n\r\n        winit_window_builder = winit_window_builder\r\n            .with_window_level(convert_window_level(window.window_level))\r\n            .with_theme(window.window_theme.map(convert_window_theme))\r\n            .with_resizable(window.resizable)\r\n            .with_enabled_buttons(convert_enabled_buttons(window.enabled_buttons))\r\n            .with_decorations(window.decorations)\r\n            .with_transparent(window.transparent)\r\n            .with_visible(window.visible);\r\n\r\n        #[cfg(any(\r\n            target_os = \"linux\",\r\n            target_os = \"dragonfly\",\r\n            target_os = \"freebsd\",\r\n            target_os = \"netbsd\",\r\n            target_os = \"openbsd\",\r\n            target_os = \"windows\"\r\n        ))]\r\n        if let Some(name) = &window.name {\r\n            #[cfg(all(\r\n                feature = \"wayland\",\r\n                any(\r\n                    target_os = \"linux\",\r\n                    target_os = \"dragonfly\",\r\n                    target_os = \"freebsd\",\r\n                    target_os = \"netbsd\",\r\n                    target_os = \"openbsd\"\r\n                )\r\n            ))]\r\n            {\r\n                winit_window_builder = winit::platform::wayland::WindowBuilderExtWayland::with_name(\r\n                    winit_window_builder,\r\n                    name.clone(),\r\n                    \"\",\r\n                );\r\n            }\r\n\r\n            #[cfg(all(\r\n                feature = \"x11\",\r\n                any(\r\n                    target_os = \"linux\",\r\n                    target_os = \"dragonfly\",\r\n                    target_os = \"freebsd\",\r\n                    target_os = \"netbsd\",\r\n                    target_os = \"openbsd\"\r\n                )\r\n            ))]\r\n            {\r\n                winit_window_builder = winit::platform::x11::WindowBuilderExtX11::with_name(\r\n                    winit_window_builder,\r\n                    name.clone(),\r\n                    \"\",\r\n                );\r\n            }\r\n            #[cfg(target_os = \"windows\")]\r\n            {\r\n                winit_window_builder =\r\n                    winit::platform::windows::WindowBuilderExtWindows::with_class_name(\r\n                        winit_window_builder,\r\n                        name.clone(),\r\n                    );\r\n            }\r\n        }\r\n\r\n        let constraints = window.resize_constraints.check_constraints();\r\n        let min_inner_size = LogicalSize {\r\n            width: constraints.min_width,\r\n            height: constraints.min_height,\r\n        };\r\n        let max_inner_size = LogicalSize {\r\n            width: constraints.max_width,\r\n            height: constraints.max_height,\r\n        };\r\n\r\n        let winit_window_builder =\r\n            if constraints.max_width.is_finite() && constraints.max_height.is_finite() {\r\n                winit_window_builder\r\n                    .with_min_inner_size(min_inner_size)\r\n                    .with_max_inner_size(max_inner_size)\r\n            } else {\r\n                winit_window_builder.with_min_inner_size(min_inner_size)\r\n            };\r\n\r\n        #[allow(unused_mut)]\r\n        let mut winit_window_builder = winit_window_builder.with_title(window.title.as_str());\r\n\r\n        #[cfg(target_arch = \"wasm32\")]\r\n        {\r\n            use wasm_bindgen::JsCast;\r\n            use winit::platform::web::WindowBuilderExtWebSys;\r\n\r\n            if let Some(selector) = &window.canvas {\r\n                let window = web_sys::window().unwrap();\r\n                let document = window.document().unwrap();\r\n                let canvas = document\r\n                    .query_selector(&selector)\r\n                    .expect(\"Cannot query for canvas element.\");\r\n                if let Some(canvas) = canvas {\r\n                    let canvas = canvas.dyn_into::<web_sys::HtmlCanvasElement>().ok();\r\n                    winit_window_builder = winit_window_builder.with_canvas(canvas);\r\n                } else {\r\n                    panic!(\"Cannot find element: {}.\", selector);\r\n                }\r\n            }\r\n\r\n            winit_window_builder =\r\n                winit_window_builder.with_prevent_default(window.prevent_default_event_handling);\r\n            winit_window_builder = winit_window_builder.with_append(true);\r\n        }\r\n\r\n        let winit_window = winit_window_builder.build(event_loop).unwrap();\r\n        let name = window.title.clone();\r\n\r\n        let mut root_builder = NodeBuilder::new(Role::Window);\r\n        root_builder.set_name(name.into_boxed_str());\r\n        let root = root_builder.build(&mut NodeClassSet::lock_global());\r\n\r\n        let accesskit_window_id = NodeId(entity.to_bits());\r\n        let handler = WinitActionHandler::default();\r\n        let accessibility_requested = accessibility_requested.clone();\r\n        let adapter = Adapter::with_action_handler(\r\n            &winit_window,\r\n            move || {\r\n                accessibility_requested.set(true);\r\n                TreeUpdate {\r\n                    nodes: vec![(accesskit_window_id, root)],\r\n                    tree: Some(Tree::new(accesskit_window_id)),\r\n                    focus: accesskit_window_id,\r\n                }\r\n            },\r\n            Box::new(handler.clone()),\r\n        );\r\n        adapters.insert(entity, adapter);\r\n        handlers.insert(entity, handler);\r\n\r\n        // Do not set the grab mode on window creation if it's none. It can fail on mobile.\r\n        if window.cursor.grab_mode != CursorGrabMode::None {\r\n            attempt_grab(&winit_window, window.cursor.grab_mode);\r\n        }\r\n\r\n        winit_window.set_cursor_visible(window.cursor.visible);\r\n\r\n        // Do not set the cursor hittest on window creation if it's false, as it will always fail on\r\n        // some platforms and log an unfixable warning.\r\n        if !window.cursor.hit_test {\r\n            if let Err(err) = winit_window.set_cursor_hittest(window.cursor.hit_test) {\r\n                warn!(\r\n                    \"Could not set cursor hit test for window {:?}: {:?}\",\r\n                    window.title, err\r\n                );\r\n            }\r\n        }\r\n\r\n        self.entity_to_winit.insert(entity, winit_window.id());\r\n        self.winit_to_entity.insert(winit_window.id(), entity);\r\n\r\n        self.windows\r\n            .entry(winit_window.id())\r\n            .insert(winit_window)\r\n            .into_mut()\r\n    }\r\n\r\n    /// Get the winit window that is associated with our entity.\r\n    pub fn get_window(&self, entity: Entity) -> Option<&winit::window::Window> {\r\n        self.entity_to_winit\r\n            .get(&entity)\r\n            .and_then(|winit_id| self.windows.get(winit_id))\r\n    }\r\n\r\n    /// Get the entity associated with the winit window id.\r\n    ///\r\n    /// This is mostly just an intermediary step between us and winit.\r\n    pub fn get_window_entity(&self, winit_id: winit::window::WindowId) -> Option<Entity> {\r\n        self.winit_to_entity.get(&winit_id).cloned()\r\n    }\r\n\r\n    /// Remove a window from winit.\r\n    ///\r\n    /// This should mostly just be called when the window is closing.\r\n    pub fn remove_window(&mut self, entity: Entity) -> Option<winit::window::Window> {\r\n        let winit_id = self.entity_to_winit.remove(&entity)?;\r\n        // Don't remove from `winit_to_window_id` so we know the window used to exist.\r\n        self.windows.remove(&winit_id)\r\n    }\r\n}\r\n\r\n/// Gets the \"best\" video mode which fits the given dimensions.\r\n///\r\n/// The heuristic for \"best\" prioritizes width, height, and refresh rate in that order.\r\npub fn get_fitting_videomode(\r\n    monitor: &MonitorHandle,\r\n    width: u32,\r\n    height: u32,\r\n) -> winit::monitor::VideoMode {\r\n    let mut modes = monitor.video_modes().collect::<Vec<_>>();\r\n\r\n    fn abs_diff(a: u32, b: u32) -> u32 {\r\n        if a > b {\r\n            return a - b;\r\n        }\r\n        b - a\r\n    }\r\n\r\n    modes.sort_by(|a, b| {\r\n        use std::cmp::Ordering::*;\r\n        match abs_diff(a.size().width, width).cmp(&abs_diff(b.size().width, width)) {\r\n            Equal => {\r\n                match abs_diff(a.size().height, height).cmp(&abs_diff(b.size().height, height)) {\r\n                    Equal => b\r\n                        .refresh_rate_millihertz()\r\n                        .cmp(&a.refresh_rate_millihertz()),\r\n                    default => default,\r\n                }\r\n            }\r\n            default => default,\r\n        }\r\n    });\r\n\r\n    modes.first().unwrap().clone()\r\n}\r\n\r\n/// Gets the \"best\" videomode from a monitor.\r\n///\r\n/// The heuristic for \"best\" prioritizes width, height, and refresh rate in that order.\r\npub fn get_best_videomode(monitor: &MonitorHandle) -> winit::monitor::VideoMode {\r\n    let mut modes = monitor.video_modes().collect::<Vec<_>>();\r\n    modes.sort_by(|a, b| {\r\n        use std::cmp::Ordering::*;\r\n        match b.size().width.cmp(&a.size().width) {\r\n            Equal => match b.size().height.cmp(&a.size().height) {\r\n                Equal => b\r\n                    .refresh_rate_millihertz()\r\n                    .cmp(&a.refresh_rate_millihertz()),\r\n                default => default,\r\n            },\r\n            default => default,\r\n        }\r\n    });\r\n\r\n    modes.first().unwrap().clone()\r\n}\r\n\r\npub(crate) fn attempt_grab(winit_window: &winit::window::Window, grab_mode: CursorGrabMode) {\r\n    let grab_result = match grab_mode {\r\n        CursorGrabMode::None => winit_window.set_cursor_grab(winit::window::CursorGrabMode::None),\r\n        CursorGrabMode::Confined => winit_window\r\n            .set_cursor_grab(winit::window::CursorGrabMode::Confined)\r\n            .or_else(|_e| winit_window.set_cursor_grab(winit::window::CursorGrabMode::Locked)),\r\n        CursorGrabMode::Locked => winit_window\r\n            .set_cursor_grab(winit::window::CursorGrabMode::Locked)\r\n            .or_else(|_e| winit_window.set_cursor_grab(winit::window::CursorGrabMode::Confined)),\r\n    };\r\n\r\n    if let Err(err) = grab_result {\r\n        let err_desc = match grab_mode {\r\n            CursorGrabMode::Confined | CursorGrabMode::Locked => \"grab\",\r\n            CursorGrabMode::None => \"ungrab\",\r\n        };\r\n\r\n        bevy_utils::tracing::error!(\"Unable to {} cursor: {}\", err_desc, err);\r\n    }\r\n}\r\n\r\n/// Compute the physical window position for a given [`WindowPosition`].\r\n// Ideally we could generify this across window backends, but we only really have winit atm\r\n// so whatever.\r\npub fn winit_window_position(\r\n    position: &WindowPosition,\r\n    resolution: &WindowResolution,\r\n    mut available_monitors: impl Iterator<Item = MonitorHandle>,\r\n    primary_monitor: Option<MonitorHandle>,\r\n    current_monitor: Option<MonitorHandle>,\r\n) -> Option<PhysicalPosition<i32>> {\r\n    match position {\r\n        WindowPosition::Automatic => {\r\n            /* Window manager will handle position */\r\n            None\r\n        }\r\n        WindowPosition::Centered(monitor_selection) => {\r\n            use bevy_window::MonitorSelection::*;\r\n            let maybe_monitor = match monitor_selection {\r\n                Current => {\r\n                    if current_monitor.is_none() {\r\n                        warn!(\"Can't select current monitor on window creation or cannot find current monitor!\");\r\n                    }\r\n                    current_monitor\r\n                }\r\n                Primary => primary_monitor,\r\n                Index(n) => available_monitors.nth(*n),\r\n            };\r\n\r\n            if let Some(monitor) = maybe_monitor {\r\n                let screen_size = monitor.size();\r\n\r\n                // We use the monitors scale factor here since `WindowResolution.scale_factor` is\r\n                // not yet populated when windows are created during plugin setup.\r\n                let scale_factor = monitor.scale_factor();\r\n\r\n                // Logical to physical window size\r\n                let (width, height): (u32, u32) =\r\n                    LogicalSize::new(resolution.width(), resolution.height())\r\n                        .to_physical::<u32>(scale_factor)\r\n                        .into();\r\n\r\n                let position = PhysicalPosition {\r\n                    x: screen_size.width.saturating_sub(width) as f64 / 2.\r\n                        + monitor.position().x as f64,\r\n                    y: screen_size.height.saturating_sub(height) as f64 / 2.\r\n                        + monitor.position().y as f64,\r\n                };\r\n\r\n                Some(position.cast::<i32>())\r\n            } else {\r\n                warn!(\"Couldn't get monitor selected with: {monitor_selection:?}\");\r\n                None\r\n            }\r\n        }\r\n        WindowPosition::At(position) => {\r\n            Some(PhysicalPosition::new(position[0] as f64, position[1] as f64).cast::<i32>())\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\bevy\\crates\\bevy_window\\Cargo.toml\r\n\r\n````toml\r\n[package]\r\nname = \"bevy_window\"\r\nversion = \"0.14.0-dev\"\r\nedition = \"2021\"\r\ndescription = \"Provides windowing functionality for Bevy Engine\"\r\nhomepage = \"https://bevyengine.org\"\r\nrepository = \"https://github.com/bevyengine/bevy\"\r\nlicense = \"MIT OR Apache-2.0\"\r\nkeywords = [\"bevy\"]\r\n\r\n[features]\r\ndefault = []\r\nserialize = [\"serde\", \"smol_str/serde\"]\r\n\r\n[dependencies]\r\n# bevy\r\nbevy_a11y = { path = \"../bevy_a11y\", version = \"0.14.0-dev\" }\r\nbevy_app = { path = \"../bevy_app\", version = \"0.14.0-dev\" }\r\nbevy_ecs = { path = \"../bevy_ecs\", version = \"0.14.0-dev\" }\r\nbevy_math = { path = \"../bevy_math\", version = \"0.14.0-dev\" }\r\nbevy_reflect = { path = \"../bevy_reflect\", version = \"0.14.0-dev\", features = [\r\n  \"glam\",\r\n] }\r\nbevy_utils = { path = \"../bevy_utils\", version = \"0.14.0-dev\" }\r\n# Used for close_on_esc\r\nbevy_input = { path = \"../bevy_input\", version = \"0.14.0-dev\" }\r\n\r\n# other\r\nserde = { version = \"1.0\", features = [\"derive\"], optional = true }\r\nraw-window-handle = \"0.6\"\r\nsmol_str = \"0.2\"\r\n\r\n[lints]\r\nworkspace = true\r\n\r\n[package.metadata.docs.rs]\r\nall-features = true\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\bevy\\crates\\bevy_window\\src\\lib.rs\r\n\r\n````rust\r\n//! `bevy_window` provides a platform-agnostic interface for windowing in Bevy.\r\n//!\r\n//! This crate contains types for window management and events,\r\n//! used by windowing implementors such as `bevy_winit`.\r\n//! The [`WindowPlugin`] sets up some global window-related parameters and\r\n//! is part of the [`DefaultPlugins`](https://docs.rs/bevy/latest/bevy/struct.DefaultPlugins.html).\r\n#![cfg_attr(docsrs, feature(doc_auto_cfg))]\r\n\r\nuse bevy_a11y::Focus;\r\n\r\nmod cursor;\r\nmod event;\r\nmod raw_handle;\r\nmod system;\r\nmod window;\r\n\r\npub use crate::raw_handle::*;\r\n\r\npub use cursor::*;\r\npub use event::*;\r\npub use system::*;\r\npub use window::*;\r\n\r\n#[allow(missing_docs)]\r\npub mod prelude {\r\n    #[doc(hidden)]\r\n    pub use crate::{\r\n        CursorEntered, CursorIcon, CursorLeft, CursorMoved, FileDragAndDrop, Ime, MonitorSelection,\r\n        ReceivedCharacter, Window, WindowMoved, WindowPlugin, WindowPosition,\r\n        WindowResizeConstraints,\r\n    };\r\n}\r\n\r\nuse bevy_app::prelude::*;\r\n\r\nimpl Default for WindowPlugin {\r\n    fn default() -> Self {\r\n        WindowPlugin {\r\n            primary_window: Some(Window::default()),\r\n            exit_condition: ExitCondition::OnAllClosed,\r\n            close_when_requested: true,\r\n        }\r\n    }\r\n}\r\n\r\n/// A [`Plugin`] that defines an interface for windowing support in Bevy.\r\npub struct WindowPlugin {\r\n    /// Settings for the primary window.\r\n    ///\r\n    /// `Some(custom_window)` will spawn an entity with `custom_window` and [`PrimaryWindow`] as components.\r\n    /// `None` will not spawn a primary window.\r\n    ///\r\n    /// Defaults to `Some(Window::default())`.\r\n    ///\r\n    /// Note that if there are no windows the App will exit (by default) due to\r\n    /// [`exit_on_all_closed`].\r\n    pub primary_window: Option<Window>,\r\n\r\n    /// Whether to exit the app when there are no open windows.\r\n    ///\r\n    /// If disabling this, ensure that you send the [`bevy_app::AppExit`]\r\n    /// event when the app should exit. If this does not occur, you will\r\n    /// create 'headless' processes (processes without windows), which may\r\n    /// surprise your users. It is recommended to leave this setting to\r\n    /// either [`ExitCondition::OnAllClosed`] or [`ExitCondition::OnPrimaryClosed`].\r\n    ///\r\n    /// [`ExitCondition::OnAllClosed`] will add [`exit_on_all_closed`] to [`Update`].\r\n    /// [`ExitCondition::OnPrimaryClosed`] will add [`exit_on_primary_closed`] to [`Update`].\r\n    pub exit_condition: ExitCondition,\r\n\r\n    /// Whether to close windows when they are requested to be closed (i.e.\r\n    /// when the close button is pressed).\r\n    ///\r\n    /// If true, this plugin will add [`close_when_requested`] to [`Update`].\r\n    /// If this system (or a replacement) is not running, the close button will have no effect.\r\n    /// This may surprise your users. It is recommended to leave this setting as `true`.\r\n    pub close_when_requested: bool,\r\n}\r\n\r\nimpl Plugin for WindowPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        // User convenience events\r\n        app.add_event::<WindowResized>()\r\n            .add_event::<WindowCreated>()\r\n            .add_event::<WindowClosed>()\r\n            .add_event::<WindowCloseRequested>()\r\n            .add_event::<WindowDestroyed>()\r\n            .add_event::<RequestRedraw>()\r\n            .add_event::<CursorMoved>()\r\n            .add_event::<CursorEntered>()\r\n            .add_event::<CursorLeft>()\r\n            .add_event::<ReceivedCharacter>()\r\n            .add_event::<Ime>()\r\n            .add_event::<WindowFocused>()\r\n            .add_event::<WindowOccluded>()\r\n            .add_event::<WindowScaleFactorChanged>()\r\n            .add_event::<WindowBackendScaleFactorChanged>()\r\n            .add_event::<FileDragAndDrop>()\r\n            .add_event::<WindowMoved>()\r\n            .add_event::<WindowThemeChanged>()\r\n            .add_event::<ApplicationLifetime>();\r\n\r\n        if let Some(primary_window) = &self.primary_window {\r\n            let initial_focus = app\r\n                .world\r\n                .spawn(primary_window.clone())\r\n                .insert(PrimaryWindow)\r\n                .id();\r\n            if let Some(mut focus) = app.world.get_resource_mut::<Focus>() {\r\n                **focus = Some(initial_focus);\r\n            }\r\n        }\r\n\r\n        match self.exit_condition {\r\n            ExitCondition::OnPrimaryClosed => {\r\n                app.add_systems(PostUpdate, exit_on_primary_closed);\r\n            }\r\n            ExitCondition::OnAllClosed => {\r\n                app.add_systems(PostUpdate, exit_on_all_closed);\r\n            }\r\n            ExitCondition::DontExit => {}\r\n        }\r\n\r\n        if self.close_when_requested {\r\n            // Need to run before `exit_on_*` systems\r\n            app.add_systems(Update, close_when_requested);\r\n        }\r\n\r\n        // Register event types\r\n        app.register_type::<WindowResized>()\r\n            .register_type::<RequestRedraw>()\r\n            .register_type::<WindowCreated>()\r\n            .register_type::<WindowCloseRequested>()\r\n            .register_type::<WindowClosed>()\r\n            .register_type::<CursorMoved>()\r\n            .register_type::<CursorEntered>()\r\n            .register_type::<CursorLeft>()\r\n            .register_type::<ReceivedCharacter>()\r\n            .register_type::<WindowFocused>()\r\n            .register_type::<WindowOccluded>()\r\n            .register_type::<WindowScaleFactorChanged>()\r\n            .register_type::<WindowBackendScaleFactorChanged>()\r\n            .register_type::<FileDragAndDrop>()\r\n            .register_type::<WindowMoved>()\r\n            .register_type::<WindowThemeChanged>()\r\n            .register_type::<ApplicationLifetime>();\r\n\r\n        // Register window descriptor and related types\r\n        app.register_type::<Window>()\r\n            .register_type::<PrimaryWindow>();\r\n    }\r\n}\r\n\r\n/// Defines the specific conditions the application should exit on\r\n#[derive(Clone)]\r\npub enum ExitCondition {\r\n    /// Close application when the primary window is closed\r\n    ///\r\n    /// The plugin will add [`exit_on_primary_closed`] to [`Update`].\r\n    OnPrimaryClosed,\r\n    /// Close application when all windows are closed\r\n    ///\r\n    /// The plugin will add [`exit_on_all_closed`] to [`Update`].\r\n    OnAllClosed,\r\n    /// Keep application running headless even after closing all windows\r\n    ///\r\n    /// If selecting this, ensure that you send the [`bevy_app::AppExit`]\r\n    /// event when the app should exit. If this does not occur, you will\r\n    /// create 'headless' processes (processes without windows), which may\r\n    /// surprise your users.\r\n    DontExit,\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\bevy\\crates\\bevy_winit\\src\\converters.rs\r\n\r\n````rust\r\nuse bevy_ecs::entity::Entity;\r\nuse bevy_input::{\r\n    keyboard::{KeyCode, KeyboardInput, NativeKeyCode},\r\n    mouse::MouseButton,\r\n    touch::{ForceTouch, TouchInput, TouchPhase},\r\n    ButtonState,\r\n};\r\nuse bevy_math::Vec2;\r\nuse bevy_window::{CursorIcon, EnabledButtons, WindowLevel, WindowTheme};\r\nuse winit::keyboard::{Key, NamedKey, NativeKey};\r\n\r\npub fn convert_keyboard_input(\r\n    keyboard_input: &winit::event::KeyEvent,\r\n    window: Entity,\r\n) -> KeyboardInput {\r\n    KeyboardInput {\r\n        state: convert_element_state(keyboard_input.state),\r\n        key_code: convert_physical_key_code(keyboard_input.physical_key),\r\n        logical_key: convert_logical_key(&keyboard_input.logical_key),\r\n        window,\r\n    }\r\n}\r\n\r\npub fn convert_element_state(element_state: winit::event::ElementState) -> ButtonState {\r\n    match element_state {\r\n        winit::event::ElementState::Pressed => ButtonState::Pressed,\r\n        winit::event::ElementState::Released => ButtonState::Released,\r\n    }\r\n}\r\n\r\npub fn convert_mouse_button(mouse_button: winit::event::MouseButton) -> MouseButton {\r\n    match mouse_button {\r\n        winit::event::MouseButton::Left => MouseButton::Left,\r\n        winit::event::MouseButton::Right => MouseButton::Right,\r\n        winit::event::MouseButton::Middle => MouseButton::Middle,\r\n        winit::event::MouseButton::Back => MouseButton::Back,\r\n        winit::event::MouseButton::Forward => MouseButton::Forward,\r\n        winit::event::MouseButton::Other(val) => MouseButton::Other(val),\r\n    }\r\n}\r\n\r\npub fn convert_touch_input(\r\n    touch_input: winit::event::Touch,\r\n    location: winit::dpi::LogicalPosition<f64>,\r\n    window_entity: Entity,\r\n) -> TouchInput {\r\n    TouchInput {\r\n        phase: match touch_input.phase {\r\n            winit::event::TouchPhase::Started => TouchPhase::Started,\r\n            winit::event::TouchPhase::Moved => TouchPhase::Moved,\r\n            winit::event::TouchPhase::Ended => TouchPhase::Ended,\r\n            winit::event::TouchPhase::Cancelled => TouchPhase::Canceled,\r\n        },\r\n        position: Vec2::new(location.x as f32, location.y as f32),\r\n        window: window_entity,\r\n        force: touch_input.force.map(|f| match f {\r\n            winit::event::Force::Calibrated {\r\n                force,\r\n                max_possible_force,\r\n                altitude_angle,\r\n            } => ForceTouch::Calibrated {\r\n                force,\r\n                max_possible_force,\r\n                altitude_angle,\r\n            },\r\n            winit::event::Force::Normalized(x) => ForceTouch::Normalized(x),\r\n        }),\r\n        id: touch_input.id,\r\n    }\r\n}\r\n\r\npub fn convert_physical_native_key_code(\r\n    native_key_code: winit::keyboard::NativeKeyCode,\r\n) -> NativeKeyCode {\r\n    match native_key_code {\r\n        winit::keyboard::NativeKeyCode::Unidentified => NativeKeyCode::Unidentified,\r\n        winit::keyboard::NativeKeyCode::Android(scan_code) => NativeKeyCode::Android(scan_code),\r\n        winit::keyboard::NativeKeyCode::MacOS(scan_code) => NativeKeyCode::MacOS(scan_code),\r\n        winit::keyboard::NativeKeyCode::Windows(scan_code) => NativeKeyCode::Windows(scan_code),\r\n        winit::keyboard::NativeKeyCode::Xkb(key_code) => NativeKeyCode::Xkb(key_code),\r\n    }\r\n}\r\npub fn convert_physical_key_code(virtual_key_code: winit::keyboard::PhysicalKey) -> KeyCode {\r\n    match virtual_key_code {\r\n        winit::keyboard::PhysicalKey::Unidentified(native_key_code) => {\r\n            KeyCode::Unidentified(convert_physical_native_key_code(native_key_code))\r\n        }\r\n        winit::keyboard::PhysicalKey::Code(code) => match code {\r\n            winit::keyboard::KeyCode::Backquote => KeyCode::Backquote,\r\n            winit::keyboard::KeyCode::Backslash => KeyCode::Backslash,\r\n            winit::keyboard::KeyCode::BracketLeft => KeyCode::BracketLeft,\r\n            winit::keyboard::KeyCode::BracketRight => KeyCode::BracketRight,\r\n            winit::keyboard::KeyCode::Comma => KeyCode::Comma,\r\n            winit::keyboard::KeyCode::Digit0 => KeyCode::Digit0,\r\n            winit::keyboard::KeyCode::Digit1 => KeyCode::Digit1,\r\n            winit::keyboard::KeyCode::Digit2 => KeyCode::Digit2,\r\n            winit::keyboard::KeyCode::Digit3 => KeyCode::Digit3,\r\n            winit::keyboard::KeyCode::Digit4 => KeyCode::Digit4,\r\n            winit::keyboard::KeyCode::Digit5 => KeyCode::Digit5,\r\n            winit::keyboard::KeyCode::Digit6 => KeyCode::Digit6,\r\n            winit::keyboard::KeyCode::Digit7 => KeyCode::Digit7,\r\n            winit::keyboard::KeyCode::Digit8 => KeyCode::Digit8,\r\n            winit::keyboard::KeyCode::Digit9 => KeyCode::Digit9,\r\n            winit::keyboard::KeyCode::Equal => KeyCode::Equal,\r\n            winit::keyboard::KeyCode::IntlBackslash => KeyCode::IntlBackslash,\r\n            winit::keyboard::KeyCode::IntlRo => KeyCode::IntlRo,\r\n            winit::keyboard::KeyCode::IntlYen => KeyCode::IntlYen,\r\n            winit::keyboard::KeyCode::KeyA => KeyCode::KeyA,\r\n            winit::keyboard::KeyCode::KeyB => KeyCode::KeyB,\r\n            winit::keyboard::KeyCode::KeyC => KeyCode::KeyC,\r\n            winit::keyboard::KeyCode::KeyD => KeyCode::KeyD,\r\n            winit::keyboard::KeyCode::KeyE => KeyCode::KeyE,\r\n            winit::keyboard::KeyCode::KeyF => KeyCode::KeyF,\r\n            winit::keyboard::KeyCode::KeyG => KeyCode::KeyG,\r\n            winit::keyboard::KeyCode::KeyH => KeyCode::KeyH,\r\n            winit::keyboard::KeyCode::KeyI => KeyCode::KeyI,\r\n            winit::keyboard::KeyCode::KeyJ => KeyCode::KeyJ,\r\n            winit::keyboard::KeyCode::KeyK => KeyCode::KeyK,\r\n            winit::keyboard::KeyCode::KeyL => KeyCode::KeyL,\r\n            winit::keyboard::KeyCode::KeyM => KeyCode::KeyM,\r\n            winit::keyboard::KeyCode::KeyN => KeyCode::KeyN,\r\n            winit::keyboard::KeyCode::KeyO => KeyCode::KeyO,\r\n            winit::keyboard::KeyCode::KeyP => KeyCode::KeyP,\r\n            winit::keyboard::KeyCode::KeyQ => KeyCode::KeyQ,\r\n            winit::keyboard::KeyCode::KeyR => KeyCode::KeyR,\r\n            winit::keyboard::KeyCode::KeyS => KeyCode::KeyS,\r\n            winit::keyboard::KeyCode::KeyT => KeyCode::KeyT,\r\n            winit::keyboard::KeyCode::KeyU => KeyCode::KeyU,\r\n            winit::keyboard::KeyCode::KeyV => KeyCode::KeyV,\r\n            winit::keyboard::KeyCode::KeyW => KeyCode::KeyW,\r\n            winit::keyboard::KeyCode::KeyX => KeyCode::KeyX,\r\n            winit::keyboard::KeyCode::KeyY => KeyCode::KeyY,\r\n            winit::keyboard::KeyCode::KeyZ => KeyCode::KeyZ,\r\n            winit::keyboard::KeyCode::Minus => KeyCode::Minus,\r\n            winit::keyboard::KeyCode::Period => KeyCode::Period,\r\n            winit::keyboard::KeyCode::Quote => KeyCode::Quote,\r\n            winit::keyboard::KeyCode::Semicolon => KeyCode::Semicolon,\r\n            winit::keyboard::KeyCode::Slash => KeyCode::Slash,\r\n            winit::keyboard::KeyCode::AltLeft => KeyCode::AltLeft,\r\n            winit::keyboard::KeyCode::AltRight => KeyCode::AltRight,\r\n            winit::keyboard::KeyCode::Backspace => KeyCode::Backspace,\r\n            winit::keyboard::KeyCode::CapsLock => KeyCode::CapsLock,\r\n            winit::keyboard::KeyCode::ContextMenu => KeyCode::ContextMenu,\r\n            winit::keyboard::KeyCode::ControlLeft => KeyCode::ControlLeft,\r\n            winit::keyboard::KeyCode::ControlRight => KeyCode::ControlRight,\r\n            winit::keyboard::KeyCode::Enter => KeyCode::Enter,\r\n            winit::keyboard::KeyCode::SuperLeft => KeyCode::SuperLeft,\r\n            winit::keyboard::KeyCode::SuperRight => KeyCode::SuperRight,\r\n            winit::keyboard::KeyCode::ShiftLeft => KeyCode::ShiftLeft,\r\n            winit::keyboard::KeyCode::ShiftRight => KeyCode::ShiftRight,\r\n            winit::keyboard::KeyCode::Space => KeyCode::Space,\r\n            winit::keyboard::KeyCode::Tab => KeyCode::Tab,\r\n            winit::keyboard::KeyCode::Convert => KeyCode::Convert,\r\n            winit::keyboard::KeyCode::KanaMode => KeyCode::KanaMode,\r\n            winit::keyboard::KeyCode::Lang1 => KeyCode::Lang1,\r\n            winit::keyboard::KeyCode::Lang2 => KeyCode::Lang2,\r\n            winit::keyboard::KeyCode::Lang3 => KeyCode::Lang3,\r\n            winit::keyboard::KeyCode::Lang4 => KeyCode::Lang4,\r\n            winit::keyboard::KeyCode::Lang5 => KeyCode::Lang5,\r\n            winit::keyboard::KeyCode::NonConvert => KeyCode::NonConvert,\r\n            winit::keyboard::KeyCode::Delete => KeyCode::Delete,\r\n            winit::keyboard::KeyCode::End => KeyCode::End,\r\n            winit::keyboard::KeyCode::Help => KeyCode::Help,\r\n            winit::keyboard::KeyCode::Home => KeyCode::Home,\r\n            winit::keyboard::KeyCode::Insert => KeyCode::Insert,\r\n            winit::keyboard::KeyCode::PageDown => KeyCode::PageDown,\r\n            winit::keyboard::KeyCode::PageUp => KeyCode::PageUp,\r\n            winit::keyboard::KeyCode::ArrowDown => KeyCode::ArrowDown,\r\n            winit::keyboard::KeyCode::ArrowLeft => KeyCode::ArrowLeft,\r\n            winit::keyboard::KeyCode::ArrowRight => KeyCode::ArrowRight,\r\n            winit::keyboard::KeyCode::ArrowUp => KeyCode::ArrowUp,\r\n            winit::keyboard::KeyCode::NumLock => KeyCode::NumLock,\r\n            winit::keyboard::KeyCode::Numpad0 => KeyCode::Numpad0,\r\n            winit::keyboard::KeyCode::Numpad1 => KeyCode::Numpad1,\r\n            winit::keyboard::KeyCode::Numpad2 => KeyCode::Numpad2,\r\n            winit::keyboard::KeyCode::Numpad3 => KeyCode::Numpad3,\r\n            winit::keyboard::KeyCode::Numpad4 => KeyCode::Numpad4,\r\n            winit::keyboard::KeyCode::Numpad5 => KeyCode::Numpad5,\r\n            winit::keyboard::KeyCode::Numpad6 => KeyCode::Numpad6,\r\n            winit::keyboard::KeyCode::Numpad7 => KeyCode::Numpad7,\r\n            winit::keyboard::KeyCode::Numpad8 => KeyCode::Numpad8,\r\n            winit::keyboard::KeyCode::Numpad9 => KeyCode::Numpad9,\r\n            winit::keyboard::KeyCode::NumpadAdd => KeyCode::NumpadAdd,\r\n            winit::keyboard::KeyCode::NumpadBackspace => KeyCode::NumpadBackspace,\r\n            winit::keyboard::KeyCode::NumpadClear => KeyCode::NumpadClear,\r\n            winit::keyboard::KeyCode::NumpadClearEntry => KeyCode::NumpadClearEntry,\r\n            winit::keyboard::KeyCode::NumpadComma => KeyCode::NumpadComma,\r\n            winit::keyboard::KeyCode::NumpadDecimal => KeyCode::NumpadDecimal,\r\n            winit::keyboard::KeyCode::NumpadDivide => KeyCode::NumpadDivide,\r\n            winit::keyboard::KeyCode::NumpadEnter => KeyCode::NumpadEnter,\r\n            winit::keyboard::KeyCode::NumpadEqual => KeyCode::NumpadEqual,\r\n            winit::keyboard::KeyCode::NumpadHash => KeyCode::NumpadHash,\r\n            winit::keyboard::KeyCode::NumpadMemoryAdd => KeyCode::NumpadMemoryAdd,\r\n            winit::keyboard::KeyCode::NumpadMemoryClear => KeyCode::NumpadMemoryClear,\r\n            winit::keyboard::KeyCode::NumpadMemoryRecall => KeyCode::NumpadMemoryRecall,\r\n            winit::keyboard::KeyCode::NumpadMemoryStore => KeyCode::NumpadMemoryStore,\r\n            winit::keyboard::KeyCode::NumpadMemorySubtract => KeyCode::NumpadMemorySubtract,\r\n            winit::keyboard::KeyCode::NumpadMultiply => KeyCode::NumpadMultiply,\r\n            winit::keyboard::KeyCode::NumpadParenLeft => KeyCode::NumpadParenLeft,\r\n            winit::keyboard::KeyCode::NumpadParenRight => KeyCode::NumpadParenRight,\r\n            winit::keyboard::KeyCode::NumpadStar => KeyCode::NumpadStar,\r\n            winit::keyboard::KeyCode::NumpadSubtract => KeyCode::NumpadSubtract,\r\n            winit::keyboard::KeyCode::Escape => KeyCode::Escape,\r\n            winit::keyboard::KeyCode::Fn => KeyCode::Fn,\r\n            winit::keyboard::KeyCode::FnLock => KeyCode::FnLock,\r\n            winit::keyboard::KeyCode::PrintScreen => KeyCode::PrintScreen,\r\n            winit::keyboard::KeyCode::ScrollLock => KeyCode::ScrollLock,\r\n            winit::keyboard::KeyCode::Pause => KeyCode::Pause,\r\n            winit::keyboard::KeyCode::BrowserBack => KeyCode::BrowserBack,\r\n            winit::keyboard::KeyCode::BrowserFavorites => KeyCode::BrowserFavorites,\r\n            winit::keyboard::KeyCode::BrowserForward => KeyCode::BrowserForward,\r\n            winit::keyboard::KeyCode::BrowserHome => KeyCode::BrowserHome,\r\n            winit::keyboard::KeyCode::BrowserRefresh => KeyCode::BrowserRefresh,\r\n            winit::keyboard::KeyCode::BrowserSearch => KeyCode::BrowserSearch,\r\n            winit::keyboard::KeyCode::BrowserStop => KeyCode::BrowserStop,\r\n            winit::keyboard::KeyCode::Eject => KeyCode::Eject,\r\n            winit::keyboard::KeyCode::LaunchApp1 => KeyCode::LaunchApp1,\r\n            winit::keyboard::KeyCode::LaunchApp2 => KeyCode::LaunchApp2,\r\n            winit::keyboard::KeyCode::LaunchMail => KeyCode::LaunchMail,\r\n            winit::keyboard::KeyCode::MediaPlayPause => KeyCode::MediaPlayPause,\r\n            winit::keyboard::KeyCode::MediaSelect => KeyCode::MediaSelect,\r\n            winit::keyboard::KeyCode::MediaStop => KeyCode::MediaStop,\r\n            winit::keyboard::KeyCode::MediaTrackNext => KeyCode::MediaTrackNext,\r\n            winit::keyboard::KeyCode::MediaTrackPrevious => KeyCode::MediaTrackPrevious,\r\n            winit::keyboard::KeyCode::Power => KeyCode::Power,\r\n            winit::keyboard::KeyCode::Sleep => KeyCode::Sleep,\r\n            winit::keyboard::KeyCode::AudioVolumeDown => KeyCode::AudioVolumeDown,\r\n            winit::keyboard::KeyCode::AudioVolumeMute => KeyCode::AudioVolumeMute,\r\n            winit::keyboard::KeyCode::AudioVolumeUp => KeyCode::AudioVolumeUp,\r\n            winit::keyboard::KeyCode::WakeUp => KeyCode::WakeUp,\r\n            winit::keyboard::KeyCode::Meta => KeyCode::Meta,\r\n            winit::keyboard::KeyCode::Hyper => KeyCode::Hyper,\r\n            winit::keyboard::KeyCode::Turbo => KeyCode::Turbo,\r\n            winit::keyboard::KeyCode::Abort => KeyCode::Abort,\r\n            winit::keyboard::KeyCode::Resume => KeyCode::Resume,\r\n            winit::keyboard::KeyCode::Suspend => KeyCode::Suspend,\r\n            winit::keyboard::KeyCode::Again => KeyCode::Again,\r\n            winit::keyboard::KeyCode::Copy => KeyCode::Copy,\r\n            winit::keyboard::KeyCode::Cut => KeyCode::Cut,\r\n            winit::keyboard::KeyCode::Find => KeyCode::Find,\r\n            winit::keyboard::KeyCode::Open => KeyCode::Open,\r\n            winit::keyboard::KeyCode::Paste => KeyCode::Paste,\r\n            winit::keyboard::KeyCode::Props => KeyCode::Props,\r\n            winit::keyboard::KeyCode::Select => KeyCode::Select,\r\n            winit::keyboard::KeyCode::Undo => KeyCode::Undo,\r\n            winit::keyboard::KeyCode::Hiragana => KeyCode::Hiragana,\r\n            winit::keyboard::KeyCode::Katakana => KeyCode::Katakana,\r\n            winit::keyboard::KeyCode::F1 => KeyCode::F1,\r\n            winit::keyboard::KeyCode::F2 => KeyCode::F2,\r\n            winit::keyboard::KeyCode::F3 => KeyCode::F3,\r\n            winit::keyboard::KeyCode::F4 => KeyCode::F4,\r\n            winit::keyboard::KeyCode::F5 => KeyCode::F5,\r\n            winit::keyboard::KeyCode::F6 => KeyCode::F6,\r\n            winit::keyboard::KeyCode::F7 => KeyCode::F7,\r\n            winit::keyboard::KeyCode::F8 => KeyCode::F8,\r\n            winit::keyboard::KeyCode::F9 => KeyCode::F9,\r\n            winit::keyboard::KeyCode::F10 => KeyCode::F10,\r\n            winit::keyboard::KeyCode::F11 => KeyCode::F11,\r\n            winit::keyboard::KeyCode::F12 => KeyCode::F12,\r\n            winit::keyboard::KeyCode::F13 => KeyCode::F13,\r\n            winit::keyboard::KeyCode::F14 => KeyCode::F14,\r\n            winit::keyboard::KeyCode::F15 => KeyCode::F15,\r\n            winit::keyboard::KeyCode::F16 => KeyCode::F16,\r\n            winit::keyboard::KeyCode::F17 => KeyCode::F17,\r\n            winit::keyboard::KeyCode::F18 => KeyCode::F18,\r\n            winit::keyboard::KeyCode::F19 => KeyCode::F19,\r\n            winit::keyboard::KeyCode::F20 => KeyCode::F20,\r\n            winit::keyboard::KeyCode::F21 => KeyCode::F21,\r\n            winit::keyboard::KeyCode::F22 => KeyCode::F22,\r\n            winit::keyboard::KeyCode::F23 => KeyCode::F23,\r\n            winit::keyboard::KeyCode::F24 => KeyCode::F24,\r\n            winit::keyboard::KeyCode::F25 => KeyCode::F25,\r\n            winit::keyboard::KeyCode::F26 => KeyCode::F26,\r\n            winit::keyboard::KeyCode::F27 => KeyCode::F27,\r\n            winit::keyboard::KeyCode::F28 => KeyCode::F28,\r\n            winit::keyboard::KeyCode::F29 => KeyCode::F29,\r\n            winit::keyboard::KeyCode::F30 => KeyCode::F30,\r\n            winit::keyboard::KeyCode::F31 => KeyCode::F31,\r\n            winit::keyboard::KeyCode::F32 => KeyCode::F32,\r\n            winit::keyboard::KeyCode::F33 => KeyCode::F33,\r\n            winit::keyboard::KeyCode::F34 => KeyCode::F34,\r\n            winit::keyboard::KeyCode::F35 => KeyCode::F35,\r\n            _ => KeyCode::Unidentified(NativeKeyCode::Unidentified),\r\n        },\r\n    }\r\n}\r\n\r\npub fn convert_logical_key(logical_key_code: &winit::keyboard::Key) -> bevy_input::keyboard::Key {\r\n    match logical_key_code {\r\n        Key::Character(s) => bevy_input::keyboard::Key::Character(s.clone()),\r\n        Key::Unidentified(nk) => bevy_input::keyboard::Key::Unidentified(convert_native_key(nk)),\r\n        Key::Dead(c) => bevy_input::keyboard::Key::Dead(c.to_owned()),\r\n        Key::Named(NamedKey::Alt) => bevy_input::keyboard::Key::Alt,\r\n        Key::Named(NamedKey::AltGraph) => bevy_input::keyboard::Key::AltGraph,\r\n        Key::Named(NamedKey::CapsLock) => bevy_input::keyboard::Key::CapsLock,\r\n        Key::Named(NamedKey::Control) => bevy_input::keyboard::Key::Control,\r\n        Key::Named(NamedKey::Fn) => bevy_input::keyboard::Key::Fn,\r\n        Key::Named(NamedKey::FnLock) => bevy_input::keyboard::Key::FnLock,\r\n        Key::Named(NamedKey::NumLock) => bevy_input::keyboard::Key::NumLock,\r\n        Key::Named(NamedKey::ScrollLock) => bevy_input::keyboard::Key::ScrollLock,\r\n        Key::Named(NamedKey::Shift) => bevy_input::keyboard::Key::Shift,\r\n        Key::Named(NamedKey::Symbol) => bevy_input::keyboard::Key::Symbol,\r\n        Key::Named(NamedKey::SymbolLock) => bevy_input::keyboard::Key::SymbolLock,\r\n        Key::Named(NamedKey::Meta) => bevy_input::keyboard::Key::Meta,\r\n        Key::Named(NamedKey::Hyper) => bevy_input::keyboard::Key::Hyper,\r\n        Key::Named(NamedKey::Super) => bevy_input::keyboard::Key::Super,\r\n        Key::Named(NamedKey::Enter) => bevy_input::keyboard::Key::Enter,\r\n        Key::Named(NamedKey::Tab) => bevy_input::keyboard::Key::Tab,\r\n        Key::Named(NamedKey::Space) => bevy_input::keyboard::Key::Space,\r\n        Key::Named(NamedKey::ArrowDown) => bevy_input::keyboard::Key::ArrowDown,\r\n        Key::Named(NamedKey::ArrowLeft) => bevy_input::keyboard::Key::ArrowLeft,\r\n        Key::Named(NamedKey::ArrowRight) => bevy_input::keyboard::Key::ArrowRight,\r\n        Key::Named(NamedKey::ArrowUp) => bevy_input::keyboard::Key::ArrowUp,\r\n        Key::Named(NamedKey::End) => bevy_input::keyboard::Key::End,\r\n        Key::Named(NamedKey::Home) => bevy_input::keyboard::Key::Home,\r\n        Key::Named(NamedKey::PageDown) => bevy_input::keyboard::Key::PageDown,\r\n        Key::Named(NamedKey::PageUp) => bevy_input::keyboard::Key::PageUp,\r\n        Key::Named(NamedKey::Backspace) => bevy_input::keyboard::Key::Backspace,\r\n        Key::Named(NamedKey::Clear) => bevy_input::keyboard::Key::Clear,\r\n        Key::Named(NamedKey::Copy) => bevy_input::keyboard::Key::Copy,\r\n        Key::Named(NamedKey::CrSel) => bevy_input::keyboard::Key::CrSel,\r\n        Key::Named(NamedKey::Cut) => bevy_input::keyboard::Key::Cut,\r\n        Key::Named(NamedKey::Delete) => bevy_input::keyboard::Key::Delete,\r\n        Key::Named(NamedKey::EraseEof) => bevy_input::keyboard::Key::EraseEof,\r\n        Key::Named(NamedKey::ExSel) => bevy_input::keyboard::Key::ExSel,\r\n        Key::Named(NamedKey::Insert) => bevy_input::keyboard::Key::Insert,\r\n        Key::Named(NamedKey::Paste) => bevy_input::keyboard::Key::Paste,\r\n        Key::Named(NamedKey::Redo) => bevy_input::keyboard::Key::Redo,\r\n        Key::Named(NamedKey::Undo) => bevy_input::keyboard::Key::Undo,\r\n        Key::Named(NamedKey::Accept) => bevy_input::keyboard::Key::Accept,\r\n        Key::Named(NamedKey::Again) => bevy_input::keyboard::Key::Again,\r\n        Key::Named(NamedKey::Attn) => bevy_input::keyboard::Key::Attn,\r\n        Key::Named(NamedKey::Cancel) => bevy_input::keyboard::Key::Cancel,\r\n        Key::Named(NamedKey::ContextMenu) => bevy_input::keyboard::Key::ContextMenu,\r\n        Key::Named(NamedKey::Escape) => bevy_input::keyboard::Key::Escape,\r\n        Key::Named(NamedKey::Execute) => bevy_input::keyboard::Key::Execute,\r\n        Key::Named(NamedKey::Find) => bevy_input::keyboard::Key::Find,\r\n        Key::Named(NamedKey::Help) => bevy_input::keyboard::Key::Help,\r\n        Key::Named(NamedKey::Pause) => bevy_input::keyboard::Key::Pause,\r\n        Key::Named(NamedKey::Play) => bevy_input::keyboard::Key::Play,\r\n        Key::Named(NamedKey::Props) => bevy_input::keyboard::Key::Props,\r\n        Key::Named(NamedKey::Select) => bevy_input::keyboard::Key::Select,\r\n        Key::Named(NamedKey::ZoomIn) => bevy_input::keyboard::Key::ZoomIn,\r\n        Key::Named(NamedKey::ZoomOut) => bevy_input::keyboard::Key::ZoomOut,\r\n        Key::Named(NamedKey::BrightnessDown) => bevy_input::keyboard::Key::BrightnessDown,\r\n        Key::Named(NamedKey::BrightnessUp) => bevy_input::keyboard::Key::BrightnessUp,\r\n        Key::Named(NamedKey::Eject) => bevy_input::keyboard::Key::Eject,\r\n        Key::Named(NamedKey::LogOff) => bevy_input::keyboard::Key::LogOff,\r\n        Key::Named(NamedKey::Power) => bevy_input::keyboard::Key::Power,\r\n        Key::Named(NamedKey::PowerOff) => bevy_input::keyboard::Key::PowerOff,\r\n        Key::Named(NamedKey::PrintScreen) => bevy_input::keyboard::Key::PrintScreen,\r\n        Key::Named(NamedKey::Hibernate) => bevy_input::keyboard::Key::Hibernate,\r\n        Key::Named(NamedKey::Standby) => bevy_input::keyboard::Key::Standby,\r\n        Key::Named(NamedKey::WakeUp) => bevy_input::keyboard::Key::WakeUp,\r\n        Key::Named(NamedKey::AllCandidates) => bevy_input::keyboard::Key::AllCandidates,\r\n        Key::Named(NamedKey::Alphanumeric) => bevy_input::keyboard::Key::Alphanumeric,\r\n        Key::Named(NamedKey::CodeInput) => bevy_input::keyboard::Key::CodeInput,\r\n        Key::Named(NamedKey::Compose) => bevy_input::keyboard::Key::Compose,\r\n        Key::Named(NamedKey::Convert) => bevy_input::keyboard::Key::Convert,\r\n        Key::Named(NamedKey::FinalMode) => bevy_input::keyboard::Key::FinalMode,\r\n        Key::Named(NamedKey::GroupFirst) => bevy_input::keyboard::Key::GroupFirst,\r\n        Key::Named(NamedKey::GroupLast) => bevy_input::keyboard::Key::GroupLast,\r\n        Key::Named(NamedKey::GroupNext) => bevy_input::keyboard::Key::GroupNext,\r\n        Key::Named(NamedKey::GroupPrevious) => bevy_input::keyboard::Key::GroupPrevious,\r\n        Key::Named(NamedKey::ModeChange) => bevy_input::keyboard::Key::ModeChange,\r\n        Key::Named(NamedKey::NextCandidate) => bevy_input::keyboard::Key::NextCandidate,\r\n        Key::Named(NamedKey::NonConvert) => bevy_input::keyboard::Key::NonConvert,\r\n        Key::Named(NamedKey::PreviousCandidate) => bevy_input::keyboard::Key::PreviousCandidate,\r\n        Key::Named(NamedKey::Process) => bevy_input::keyboard::Key::Process,\r\n        Key::Named(NamedKey::SingleCandidate) => bevy_input::keyboard::Key::SingleCandidate,\r\n        Key::Named(NamedKey::HangulMode) => bevy_input::keyboard::Key::HangulMode,\r\n        Key::Named(NamedKey::HanjaMode) => bevy_input::keyboard::Key::HanjaMode,\r\n        Key::Named(NamedKey::JunjaMode) => bevy_input::keyboard::Key::JunjaMode,\r\n        Key::Named(NamedKey::Eisu) => bevy_input::keyboard::Key::Eisu,\r\n        Key::Named(NamedKey::Hankaku) => bevy_input::keyboard::Key::Hankaku,\r\n        Key::Named(NamedKey::Hiragana) => bevy_input::keyboard::Key::Hiragana,\r\n        Key::Named(NamedKey::HiraganaKatakana) => bevy_input::keyboard::Key::HiraganaKatakana,\r\n        Key::Named(NamedKey::KanaMode) => bevy_input::keyboard::Key::KanaMode,\r\n        Key::Named(NamedKey::KanjiMode) => bevy_input::keyboard::Key::KanjiMode,\r\n        Key::Named(NamedKey::Katakana) => bevy_input::keyboard::Key::Katakana,\r\n        Key::Named(NamedKey::Romaji) => bevy_input::keyboard::Key::Romaji,\r\n        Key::Named(NamedKey::Zenkaku) => bevy_input::keyboard::Key::Zenkaku,\r\n        Key::Named(NamedKey::ZenkakuHankaku) => bevy_input::keyboard::Key::ZenkakuHankaku,\r\n        Key::Named(NamedKey::Soft1) => bevy_input::keyboard::Key::Soft1,\r\n        Key::Named(NamedKey::Soft2) => bevy_input::keyboard::Key::Soft2,\r\n        Key::Named(NamedKey::Soft3) => bevy_input::keyboard::Key::Soft3,\r\n        Key::Named(NamedKey::Soft4) => bevy_input::keyboard::Key::Soft4,\r\n        Key::Named(NamedKey::ChannelDown) => bevy_input::keyboard::Key::ChannelDown,\r\n        Key::Named(NamedKey::ChannelUp) => bevy_input::keyboard::Key::ChannelUp,\r\n        Key::Named(NamedKey::Close) => bevy_input::keyboard::Key::Close,\r\n        Key::Named(NamedKey::MailForward) => bevy_input::keyboard::Key::MailForward,\r\n        Key::Named(NamedKey::MailReply) => bevy_input::keyboard::Key::MailReply,\r\n        Key::Named(NamedKey::MailSend) => bevy_input::keyboard::Key::MailSend,\r\n        Key::Named(NamedKey::MediaClose) => bevy_input::keyboard::Key::MediaClose,\r\n        Key::Named(NamedKey::MediaFastForward) => bevy_input::keyboard::Key::MediaFastForward,\r\n        Key::Named(NamedKey::MediaPause) => bevy_input::keyboard::Key::MediaPause,\r\n        Key::Named(NamedKey::MediaPlay) => bevy_input::keyboard::Key::MediaPlay,\r\n        Key::Named(NamedKey::MediaPlayPause) => bevy_input::keyboard::Key::MediaPlayPause,\r\n        Key::Named(NamedKey::MediaRecord) => bevy_input::keyboard::Key::MediaRecord,\r\n        Key::Named(NamedKey::MediaRewind) => bevy_input::keyboard::Key::MediaRewind,\r\n        Key::Named(NamedKey::MediaStop) => bevy_input::keyboard::Key::MediaStop,\r\n        Key::Named(NamedKey::MediaTrackNext) => bevy_input::keyboard::Key::MediaTrackNext,\r\n        Key::Named(NamedKey::MediaTrackPrevious) => bevy_input::keyboard::Key::MediaTrackPrevious,\r\n        Key::Named(NamedKey::New) => bevy_input::keyboard::Key::New,\r\n        Key::Named(NamedKey::Open) => bevy_input::keyboard::Key::Open,\r\n        Key::Named(NamedKey::Print) => bevy_input::keyboard::Key::Print,\r\n        Key::Named(NamedKey::Save) => bevy_input::keyboard::Key::Save,\r\n        Key::Named(NamedKey::SpellCheck) => bevy_input::keyboard::Key::SpellCheck,\r\n        Key::Named(NamedKey::Key11) => bevy_input::keyboard::Key::Key11,\r\n        Key::Named(NamedKey::Key12) => bevy_input::keyboard::Key::Key12,\r\n        Key::Named(NamedKey::AudioBalanceLeft) => bevy_input::keyboard::Key::AudioBalanceLeft,\r\n        Key::Named(NamedKey::AudioBalanceRight) => bevy_input::keyboard::Key::AudioBalanceRight,\r\n        Key::Named(NamedKey::AudioBassBoostDown) => bevy_input::keyboard::Key::AudioBassBoostDown,\r\n        Key::Named(NamedKey::AudioBassBoostToggle) => {\r\n            bevy_input::keyboard::Key::AudioBassBoostToggle\r\n        }\r\n        Key::Named(NamedKey::AudioBassBoostUp) => bevy_input::keyboard::Key::AudioBassBoostUp,\r\n        Key::Named(NamedKey::AudioFaderFront) => bevy_input::keyboard::Key::AudioFaderFront,\r\n        Key::Named(NamedKey::AudioFaderRear) => bevy_input::keyboard::Key::AudioFaderRear,\r\n        Key::Named(NamedKey::AudioSurroundModeNext) => {\r\n            bevy_input::keyboard::Key::AudioSurroundModeNext\r\n        }\r\n        Key::Named(NamedKey::AudioTrebleDown) => bevy_input::keyboard::Key::AudioTrebleDown,\r\n        Key::Named(NamedKey::AudioTrebleUp) => bevy_input::keyboard::Key::AudioTrebleUp,\r\n        Key::Named(NamedKey::AudioVolumeDown) => bevy_input::keyboard::Key::AudioVolumeDown,\r\n        Key::Named(NamedKey::AudioVolumeUp) => bevy_input::keyboard::Key::AudioVolumeUp,\r\n        Key::Named(NamedKey::AudioVolumeMute) => bevy_input::keyboard::Key::AudioVolumeMute,\r\n        Key::Named(NamedKey::MicrophoneToggle) => bevy_input::keyboard::Key::MicrophoneToggle,\r\n        Key::Named(NamedKey::MicrophoneVolumeDown) => {\r\n            bevy_input::keyboard::Key::MicrophoneVolumeDown\r\n        }\r\n        Key::Named(NamedKey::MicrophoneVolumeUp) => bevy_input::keyboard::Key::MicrophoneVolumeUp,\r\n        Key::Named(NamedKey::MicrophoneVolumeMute) => {\r\n            bevy_input::keyboard::Key::MicrophoneVolumeMute\r\n        }\r\n        Key::Named(NamedKey::SpeechCorrectionList) => {\r\n            bevy_input::keyboard::Key::SpeechCorrectionList\r\n        }\r\n        Key::Named(NamedKey::SpeechInputToggle) => bevy_input::keyboard::Key::SpeechInputToggle,\r\n        Key::Named(NamedKey::LaunchApplication1) => bevy_input::keyboard::Key::LaunchApplication1,\r\n        Key::Named(NamedKey::LaunchApplication2) => bevy_input::keyboard::Key::LaunchApplication2,\r\n        Key::Named(NamedKey::LaunchCalendar) => bevy_input::keyboard::Key::LaunchCalendar,\r\n        Key::Named(NamedKey::LaunchContacts) => bevy_input::keyboard::Key::LaunchContacts,\r\n        Key::Named(NamedKey::LaunchMail) => bevy_input::keyboard::Key::LaunchMail,\r\n        Key::Named(NamedKey::LaunchMediaPlayer) => bevy_input::keyboard::Key::LaunchMediaPlayer,\r\n        Key::Named(NamedKey::LaunchMusicPlayer) => bevy_input::keyboard::Key::LaunchMusicPlayer,\r\n        Key::Named(NamedKey::LaunchPhone) => bevy_input::keyboard::Key::LaunchPhone,\r\n        Key::Named(NamedKey::LaunchScreenSaver) => bevy_input::keyboard::Key::LaunchScreenSaver,\r\n        Key::Named(NamedKey::LaunchSpreadsheet) => bevy_input::keyboard::Key::LaunchSpreadsheet,\r\n        Key::Named(NamedKey::LaunchWebBrowser) => bevy_input::keyboard::Key::LaunchWebBrowser,\r\n        Key::Named(NamedKey::LaunchWebCam) => bevy_input::keyboard::Key::LaunchWebCam,\r\n        Key::Named(NamedKey::LaunchWordProcessor) => bevy_input::keyboard::Key::LaunchWordProcessor,\r\n        Key::Named(NamedKey::BrowserBack) => bevy_input::keyboard::Key::BrowserBack,\r\n        Key::Named(NamedKey::BrowserFavorites) => bevy_input::keyboard::Key::BrowserFavorites,\r\n        Key::Named(NamedKey::BrowserForward) => bevy_input::keyboard::Key::BrowserForward,\r\n        Key::Named(NamedKey::BrowserHome) => bevy_input::keyboard::Key::BrowserHome,\r\n        Key::Named(NamedKey::BrowserRefresh) => bevy_input::keyboard::Key::BrowserRefresh,\r\n        Key::Named(NamedKey::BrowserSearch) => bevy_input::keyboard::Key::BrowserSearch,\r\n        Key::Named(NamedKey::BrowserStop) => bevy_input::keyboard::Key::BrowserStop,\r\n        Key::Named(NamedKey::AppSwitch) => bevy_input::keyboard::Key::AppSwitch,\r\n        Key::Named(NamedKey::Call) => bevy_input::keyboard::Key::Call,\r\n        Key::Named(NamedKey::Camera) => bevy_input::keyboard::Key::Camera,\r\n        Key::Named(NamedKey::CameraFocus) => bevy_input::keyboard::Key::CameraFocus,\r\n        Key::Named(NamedKey::EndCall) => bevy_input::keyboard::Key::EndCall,\r\n        Key::Named(NamedKey::GoBack) => bevy_input::keyboard::Key::GoBack,\r\n        Key::Named(NamedKey::GoHome) => bevy_input::keyboard::Key::GoHome,\r\n        Key::Named(NamedKey::HeadsetHook) => bevy_input::keyboard::Key::HeadsetHook,\r\n        Key::Named(NamedKey::LastNumberRedial) => bevy_input::keyboard::Key::LastNumberRedial,\r\n        Key::Named(NamedKey::Notification) => bevy_input::keyboard::Key::Notification,\r\n        Key::Named(NamedKey::MannerMode) => bevy_input::keyboard::Key::MannerMode,\r\n        Key::Named(NamedKey::VoiceDial) => bevy_input::keyboard::Key::VoiceDial,\r\n        Key::Named(NamedKey::TV) => bevy_input::keyboard::Key::TV,\r\n        Key::Named(NamedKey::TV3DMode) => bevy_input::keyboard::Key::TV3DMode,\r\n        Key::Named(NamedKey::TVAntennaCable) => bevy_input::keyboard::Key::TVAntennaCable,\r\n        Key::Named(NamedKey::TVAudioDescription) => bevy_input::keyboard::Key::TVAudioDescription,\r\n        Key::Named(NamedKey::TVAudioDescriptionMixDown) => {\r\n            bevy_input::keyboard::Key::TVAudioDescriptionMixDown\r\n        }\r\n        Key::Named(NamedKey::TVAudioDescriptionMixUp) => {\r\n            bevy_input::keyboard::Key::TVAudioDescriptionMixUp\r\n        }\r\n        Key::Named(NamedKey::TVContentsMenu) => bevy_input::keyboard::Key::TVContentsMenu,\r\n        Key::Named(NamedKey::TVDataService) => bevy_input::keyboard::Key::TVDataService,\r\n        Key::Named(NamedKey::TVInput) => bevy_input::keyboard::Key::TVInput,\r\n        Key::Named(NamedKey::TVInputComponent1) => bevy_input::keyboard::Key::TVInputComponent1,\r\n        Key::Named(NamedKey::TVInputComponent2) => bevy_input::keyboard::Key::TVInputComponent2,\r\n        Key::Named(NamedKey::TVInputComposite1) => bevy_input::keyboard::Key::TVInputComposite1,\r\n        Key::Named(NamedKey::TVInputComposite2) => bevy_input::keyboard::Key::TVInputComposite2,\r\n        Key::Named(NamedKey::TVInputHDMI1) => bevy_input::keyboard::Key::TVInputHDMI1,\r\n        Key::Named(NamedKey::TVInputHDMI2) => bevy_input::keyboard::Key::TVInputHDMI2,\r\n        Key::Named(NamedKey::TVInputHDMI3) => bevy_input::keyboard::Key::TVInputHDMI3,\r\n        Key::Named(NamedKey::TVInputHDMI4) => bevy_input::keyboard::Key::TVInputHDMI4,\r\n        Key::Named(NamedKey::TVInputVGA1) => bevy_input::keyboard::Key::TVInputVGA1,\r\n        Key::Named(NamedKey::TVMediaContext) => bevy_input::keyboard::Key::TVMediaContext,\r\n        Key::Named(NamedKey::TVNetwork) => bevy_input::keyboard::Key::TVNetwork,\r\n        Key::Named(NamedKey::TVNumberEntry) => bevy_input::keyboard::Key::TVNumberEntry,\r\n        Key::Named(NamedKey::TVPower) => bevy_input::keyboard::Key::TVPower,\r\n        Key::Named(NamedKey::TVRadioService) => bevy_input::keyboard::Key::TVRadioService,\r\n        Key::Named(NamedKey::TVSatellite) => bevy_input::keyboard::Key::TVSatellite,\r\n        Key::Named(NamedKey::TVSatelliteBS) => bevy_input::keyboard::Key::TVSatelliteBS,\r\n        Key::Named(NamedKey::TVSatelliteCS) => bevy_input::keyboard::Key::TVSatelliteCS,\r\n        Key::Named(NamedKey::TVSatelliteToggle) => bevy_input::keyboard::Key::TVSatelliteToggle,\r\n        Key::Named(NamedKey::TVTerrestrialAnalog) => bevy_input::keyboard::Key::TVTerrestrialAnalog,\r\n        Key::Named(NamedKey::TVTerrestrialDigital) => {\r\n            bevy_input::keyboard::Key::TVTerrestrialDigital\r\n        }\r\n        Key::Named(NamedKey::TVTimer) => bevy_input::keyboard::Key::TVTimer,\r\n        Key::Named(NamedKey::AVRInput) => bevy_input::keyboard::Key::AVRInput,\r\n        Key::Named(NamedKey::AVRPower) => bevy_input::keyboard::Key::AVRPower,\r\n        Key::Named(NamedKey::ColorF0Red) => bevy_input::keyboard::Key::ColorF0Red,\r\n        Key::Named(NamedKey::ColorF1Green) => bevy_input::keyboard::Key::ColorF1Green,\r\n        Key::Named(NamedKey::ColorF2Yellow) => bevy_input::keyboard::Key::ColorF2Yellow,\r\n        Key::Named(NamedKey::ColorF3Blue) => bevy_input::keyboard::Key::ColorF3Blue,\r\n        Key::Named(NamedKey::ColorF4Grey) => bevy_input::keyboard::Key::ColorF4Grey,\r\n        Key::Named(NamedKey::ColorF5Brown) => bevy_input::keyboard::Key::ColorF5Brown,\r\n        Key::Named(NamedKey::ClosedCaptionToggle) => bevy_input::keyboard::Key::ClosedCaptionToggle,\r\n        Key::Named(NamedKey::Dimmer) => bevy_input::keyboard::Key::Dimmer,\r\n        Key::Named(NamedKey::DisplaySwap) => bevy_input::keyboard::Key::DisplaySwap,\r\n        Key::Named(NamedKey::DVR) => bevy_input::keyboard::Key::DVR,\r\n        Key::Named(NamedKey::Exit) => bevy_input::keyboard::Key::Exit,\r\n        Key::Named(NamedKey::FavoriteClear0) => bevy_input::keyboard::Key::FavoriteClear0,\r\n        Key::Named(NamedKey::FavoriteClear1) => bevy_input::keyboard::Key::FavoriteClear1,\r\n        Key::Named(NamedKey::FavoriteClear2) => bevy_input::keyboard::Key::FavoriteClear2,\r\n        Key::Named(NamedKey::FavoriteClear3) => bevy_input::keyboard::Key::FavoriteClear3,\r\n        Key::Named(NamedKey::FavoriteRecall0) => bevy_input::keyboard::Key::FavoriteRecall0,\r\n        Key::Named(NamedKey::FavoriteRecall1) => bevy_input::keyboard::Key::FavoriteRecall1,\r\n        Key::Named(NamedKey::FavoriteRecall2) => bevy_input::keyboard::Key::FavoriteRecall2,\r\n        Key::Named(NamedKey::FavoriteRecall3) => bevy_input::keyboard::Key::FavoriteRecall3,\r\n        Key::Named(NamedKey::FavoriteStore0) => bevy_input::keyboard::Key::FavoriteStore0,\r\n        Key::Named(NamedKey::FavoriteStore1) => bevy_input::keyboard::Key::FavoriteStore1,\r\n        Key::Named(NamedKey::FavoriteStore2) => bevy_input::keyboard::Key::FavoriteStore2,\r\n        Key::Named(NamedKey::FavoriteStore3) => bevy_input::keyboard::Key::FavoriteStore3,\r\n        Key::Named(NamedKey::Guide) => bevy_input::keyboard::Key::Guide,\r\n        Key::Named(NamedKey::GuideNextDay) => bevy_input::keyboard::Key::GuideNextDay,\r\n        Key::Named(NamedKey::GuidePreviousDay) => bevy_input::keyboard::Key::GuidePreviousDay,\r\n        Key::Named(NamedKey::Info) => bevy_input::keyboard::Key::Info,\r\n        Key::Named(NamedKey::InstantReplay) => bevy_input::keyboard::Key::InstantReplay,\r\n        Key::Named(NamedKey::Link) => bevy_input::keyboard::Key::Link,\r\n        Key::Named(NamedKey::ListProgram) => bevy_input::keyboard::Key::ListProgram,\r\n        Key::Named(NamedKey::LiveContent) => bevy_input::keyboard::Key::LiveContent,\r\n        Key::Named(NamedKey::Lock) => bevy_input::keyboard::Key::Lock,\r\n        Key::Named(NamedKey::MediaApps) => bevy_input::keyboard::Key::MediaApps,\r\n        Key::Named(NamedKey::MediaAudioTrack) => bevy_input::keyboard::Key::MediaAudioTrack,\r\n        Key::Named(NamedKey::MediaLast) => bevy_input::keyboard::Key::MediaLast,\r\n        Key::Named(NamedKey::MediaSkipBackward) => bevy_input::keyboard::Key::MediaSkipBackward,\r\n        Key::Named(NamedKey::MediaSkipForward) => bevy_input::keyboard::Key::MediaSkipForward,\r\n        Key::Named(NamedKey::MediaStepBackward) => bevy_input::keyboard::Key::MediaStepBackward,\r\n        Key::Named(NamedKey::MediaStepForward) => bevy_input::keyboard::Key::MediaStepForward,\r\n        Key::Named(NamedKey::MediaTopMenu) => bevy_input::keyboard::Key::MediaTopMenu,\r\n        Key::Named(NamedKey::NavigateIn) => bevy_input::keyboard::Key::NavigateIn,\r\n        Key::Named(NamedKey::NavigateNext) => bevy_input::keyboard::Key::NavigateNext,\r\n        Key::Named(NamedKey::NavigateOut) => bevy_input::keyboard::Key::NavigateOut,\r\n        Key::Named(NamedKey::NavigatePrevious) => bevy_input::keyboard::Key::NavigatePrevious,\r\n        Key::Named(NamedKey::NextFavoriteChannel) => bevy_input::keyboard::Key::NextFavoriteChannel,\r\n        Key::Named(NamedKey::NextUserProfile) => bevy_input::keyboard::Key::NextUserProfile,\r\n        Key::Named(NamedKey::OnDemand) => bevy_input::keyboard::Key::OnDemand,\r\n        Key::Named(NamedKey::Pairing) => bevy_input::keyboard::Key::Pairing,\r\n        Key::Named(NamedKey::PinPDown) => bevy_input::keyboard::Key::PinPDown,\r\n        Key::Named(NamedKey::PinPMove) => bevy_input::keyboard::Key::PinPMove,\r\n        Key::Named(NamedKey::PinPToggle) => bevy_input::keyboard::Key::PinPToggle,\r\n        Key::Named(NamedKey::PinPUp) => bevy_input::keyboard::Key::PinPUp,\r\n        Key::Named(NamedKey::PlaySpeedDown) => bevy_input::keyboard::Key::PlaySpeedDown,\r\n        Key::Named(NamedKey::PlaySpeedReset) => bevy_input::keyboard::Key::PlaySpeedReset,\r\n        Key::Named(NamedKey::PlaySpeedUp) => bevy_input::keyboard::Key::PlaySpeedUp,\r\n        Key::Named(NamedKey::RandomToggle) => bevy_input::keyboard::Key::RandomToggle,\r\n        Key::Named(NamedKey::RcLowBattery) => bevy_input::keyboard::Key::RcLowBattery,\r\n        Key::Named(NamedKey::RecordSpeedNext) => bevy_input::keyboard::Key::RecordSpeedNext,\r\n        Key::Named(NamedKey::RfBypass) => bevy_input::keyboard::Key::RfBypass,\r\n        Key::Named(NamedKey::ScanChannelsToggle) => bevy_input::keyboard::Key::ScanChannelsToggle,\r\n        Key::Named(NamedKey::ScreenModeNext) => bevy_input::keyboard::Key::ScreenModeNext,\r\n        Key::Named(NamedKey::Settings) => bevy_input::keyboard::Key::Settings,\r\n        Key::Named(NamedKey::SplitScreenToggle) => bevy_input::keyboard::Key::SplitScreenToggle,\r\n        Key::Named(NamedKey::STBInput) => bevy_input::keyboard::Key::STBInput,\r\n        Key::Named(NamedKey::STBPower) => bevy_input::keyboard::Key::STBPower,\r\n        Key::Named(NamedKey::Subtitle) => bevy_input::keyboard::Key::Subtitle,\r\n        Key::Named(NamedKey::Teletext) => bevy_input::keyboard::Key::Teletext,\r\n        Key::Named(NamedKey::VideoModeNext) => bevy_input::keyboard::Key::VideoModeNext,\r\n        Key::Named(NamedKey::Wink) => bevy_input::keyboard::Key::Wink,\r\n        Key::Named(NamedKey::ZoomToggle) => bevy_input::keyboard::Key::ZoomToggle,\r\n        Key::Named(NamedKey::F1) => bevy_input::keyboard::Key::F1,\r\n        Key::Named(NamedKey::F2) => bevy_input::keyboard::Key::F2,\r\n        Key::Named(NamedKey::F3) => bevy_input::keyboard::Key::F3,\r\n        Key::Named(NamedKey::F4) => bevy_input::keyboard::Key::F4,\r\n        Key::Named(NamedKey::F5) => bevy_input::keyboard::Key::F5,\r\n        Key::Named(NamedKey::F6) => bevy_input::keyboard::Key::F6,\r\n        Key::Named(NamedKey::F7) => bevy_input::keyboard::Key::F7,\r\n        Key::Named(NamedKey::F8) => bevy_input::keyboard::Key::F8,\r\n        Key::Named(NamedKey::F9) => bevy_input::keyboard::Key::F9,\r\n        Key::Named(NamedKey::F10) => bevy_input::keyboard::Key::F10,\r\n        Key::Named(NamedKey::F11) => bevy_input::keyboard::Key::F11,\r\n        Key::Named(NamedKey::F12) => bevy_input::keyboard::Key::F12,\r\n        Key::Named(NamedKey::F13) => bevy_input::keyboard::Key::F13,\r\n        Key::Named(NamedKey::F14) => bevy_input::keyboard::Key::F14,\r\n        Key::Named(NamedKey::F15) => bevy_input::keyboard::Key::F15,\r\n        Key::Named(NamedKey::F16) => bevy_input::keyboard::Key::F16,\r\n        Key::Named(NamedKey::F17) => bevy_input::keyboard::Key::F17,\r\n        Key::Named(NamedKey::F18) => bevy_input::keyboard::Key::F18,\r\n        Key::Named(NamedKey::F19) => bevy_input::keyboard::Key::F19,\r\n        Key::Named(NamedKey::F20) => bevy_input::keyboard::Key::F20,\r\n        Key::Named(NamedKey::F21) => bevy_input::keyboard::Key::F21,\r\n        Key::Named(NamedKey::F22) => bevy_input::keyboard::Key::F22,\r\n        Key::Named(NamedKey::F23) => bevy_input::keyboard::Key::F23,\r\n        Key::Named(NamedKey::F24) => bevy_input::keyboard::Key::F24,\r\n        Key::Named(NamedKey::F25) => bevy_input::keyboard::Key::F25,\r\n        Key::Named(NamedKey::F26) => bevy_input::keyboard::Key::F26,\r\n        Key::Named(NamedKey::F27) => bevy_input::keyboard::Key::F27,\r\n        Key::Named(NamedKey::F28) => bevy_input::keyboard::Key::F28,\r\n        Key::Named(NamedKey::F29) => bevy_input::keyboard::Key::F29,\r\n        Key::Named(NamedKey::F30) => bevy_input::keyboard::Key::F30,\r\n        Key::Named(NamedKey::F31) => bevy_input::keyboard::Key::F31,\r\n        Key::Named(NamedKey::F32) => bevy_input::keyboard::Key::F32,\r\n        Key::Named(NamedKey::F33) => bevy_input::keyboard::Key::F33,\r\n        Key::Named(NamedKey::F34) => bevy_input::keyboard::Key::F34,\r\n        Key::Named(NamedKey::F35) => bevy_input::keyboard::Key::F35,\r\n        _ => todo!(),\r\n    }\r\n}\r\n\r\npub fn convert_native_key(native_key: &NativeKey) -> bevy_input::keyboard::NativeKey {\r\n    match native_key {\r\n        NativeKey::Unidentified => bevy_input::keyboard::NativeKey::Unidentified,\r\n        NativeKey::Android(v) => bevy_input::keyboard::NativeKey::Android(*v),\r\n        NativeKey::MacOS(v) => bevy_input::keyboard::NativeKey::MacOS(*v),\r\n        NativeKey::Windows(v) => bevy_input::keyboard::NativeKey::Windows(*v),\r\n        NativeKey::Xkb(v) => bevy_input::keyboard::NativeKey::Xkb(*v),\r\n        NativeKey::Web(v) => bevy_input::keyboard::NativeKey::Web(v.clone()),\r\n    }\r\n}\r\n\r\npub fn convert_cursor_icon(cursor_icon: CursorIcon) -> winit::window::CursorIcon {\r\n    match cursor_icon {\r\n        CursorIcon::Crosshair => winit::window::CursorIcon::Crosshair,\r\n        CursorIcon::Pointer => winit::window::CursorIcon::Pointer,\r\n        CursorIcon::Move => winit::window::CursorIcon::Move,\r\n        CursorIcon::Text => winit::window::CursorIcon::Text,\r\n        CursorIcon::Wait => winit::window::CursorIcon::Wait,\r\n        CursorIcon::Help => winit::window::CursorIcon::Help,\r\n        CursorIcon::Progress => winit::window::CursorIcon::Progress,\r\n        CursorIcon::NotAllowed => winit::window::CursorIcon::NotAllowed,\r\n        CursorIcon::ContextMenu => winit::window::CursorIcon::ContextMenu,\r\n        CursorIcon::Cell => winit::window::CursorIcon::Cell,\r\n        CursorIcon::VerticalText => winit::window::CursorIcon::VerticalText,\r\n        CursorIcon::Alias => winit::window::CursorIcon::Alias,\r\n        CursorIcon::Copy => winit::window::CursorIcon::Copy,\r\n        CursorIcon::NoDrop => winit::window::CursorIcon::NoDrop,\r\n        CursorIcon::Grab => winit::window::CursorIcon::Grab,\r\n        CursorIcon::Grabbing => winit::window::CursorIcon::Grabbing,\r\n        CursorIcon::AllScroll => winit::window::CursorIcon::AllScroll,\r\n        CursorIcon::ZoomIn => winit::window::CursorIcon::ZoomIn,\r\n        CursorIcon::ZoomOut => winit::window::CursorIcon::ZoomOut,\r\n        CursorIcon::EResize => winit::window::CursorIcon::EResize,\r\n        CursorIcon::NResize => winit::window::CursorIcon::NResize,\r\n        CursorIcon::NeResize => winit::window::CursorIcon::NeResize,\r\n        CursorIcon::NwResize => winit::window::CursorIcon::NwResize,\r\n        CursorIcon::SResize => winit::window::CursorIcon::SResize,\r\n        CursorIcon::SeResize => winit::window::CursorIcon::SeResize,\r\n        CursorIcon::SwResize => winit::window::CursorIcon::SwResize,\r\n        CursorIcon::WResize => winit::window::CursorIcon::WResize,\r\n        CursorIcon::EwResize => winit::window::CursorIcon::EwResize,\r\n        CursorIcon::NsResize => winit::window::CursorIcon::NsResize,\r\n        CursorIcon::NeswResize => winit::window::CursorIcon::NeswResize,\r\n        CursorIcon::NwseResize => winit::window::CursorIcon::NwseResize,\r\n        CursorIcon::ColResize => winit::window::CursorIcon::ColResize,\r\n        CursorIcon::RowResize => winit::window::CursorIcon::RowResize,\r\n        _ => winit::window::CursorIcon::Default,\r\n    }\r\n}\r\n\r\npub fn convert_window_level(window_level: WindowLevel) -> winit::window::WindowLevel {\r\n    match window_level {\r\n        WindowLevel::AlwaysOnBottom => winit::window::WindowLevel::AlwaysOnBottom,\r\n        WindowLevel::Normal => winit::window::WindowLevel::Normal,\r\n        WindowLevel::AlwaysOnTop => winit::window::WindowLevel::AlwaysOnTop,\r\n    }\r\n}\r\n\r\npub fn convert_winit_theme(theme: winit::window::Theme) -> WindowTheme {\r\n    match theme {\r\n        winit::window::Theme::Light => WindowTheme::Light,\r\n        winit::window::Theme::Dark => WindowTheme::Dark,\r\n    }\r\n}\r\n\r\npub fn convert_window_theme(theme: WindowTheme) -> winit::window::Theme {\r\n    match theme {\r\n        WindowTheme::Light => winit::window::Theme::Light,\r\n        WindowTheme::Dark => winit::window::Theme::Dark,\r\n    }\r\n}\r\n\r\npub fn convert_enabled_buttons(enabled_buttons: EnabledButtons) -> winit::window::WindowButtons {\r\n    let mut window_buttons = winit::window::WindowButtons::empty();\r\n    if enabled_buttons.minimize {\r\n        window_buttons.insert(winit::window::WindowButtons::MINIMIZE);\r\n    }\r\n    if enabled_buttons.maximize {\r\n        window_buttons.insert(winit::window::WindowButtons::MAXIMIZE);\r\n    }\r\n    if enabled_buttons.close {\r\n        window_buttons.insert(winit::window::WindowButtons::CLOSE);\r\n    }\r\n    window_buttons\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\bevy\\crates\\bevy_render\\src\\view\\visibility\\render_layers.rs\r\n\r\n````rust\r\nuse bevy_ecs::prelude::{Component, ReflectComponent};\r\nuse bevy_reflect::std_traits::ReflectDefault;\r\nuse bevy_reflect::Reflect;\r\n\r\ntype LayerMask = u32;\r\n\r\n/// An identifier for a rendering layer.\r\npub type Layer = u8;\r\n\r\n/// Describes which rendering layers an entity belongs to.\r\n///\r\n/// Cameras with this component will only render entities with intersecting\r\n/// layers.\r\n///\r\n/// There are 32 layers numbered `0` - [`TOTAL_LAYERS`](RenderLayers::TOTAL_LAYERS). Entities may\r\n/// belong to one or more layers, or no layer at all.\r\n///\r\n/// The [`Default`] instance of `RenderLayers` contains layer `0`, the first layer.\r\n///\r\n/// An entity with this component without any layers is invisible.\r\n///\r\n/// Entities without this component belong to layer `0`.\r\n#[derive(Component, Copy, Clone, Reflect, PartialEq, Eq, PartialOrd, Ord)]\r\n#[reflect(Component, Default, PartialEq)]\r\npub struct RenderLayers(LayerMask);\r\n\r\nimpl std::fmt::Debug for RenderLayers {\r\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\r\n        f.debug_tuple(\"RenderLayers\")\r\n            .field(&self.iter().collect::<Vec<_>>())\r\n            .finish()\r\n    }\r\n}\r\n\r\nimpl FromIterator<Layer> for RenderLayers {\r\n    fn from_iter<T: IntoIterator<Item = Layer>>(i: T) -> Self {\r\n        i.into_iter().fold(Self::none(), |mask, g| mask.with(g))\r\n    }\r\n}\r\n\r\nimpl Default for RenderLayers {\r\n    /// By default, this structure includes layer `0`, which represents the first layer.\r\n    fn default() -> Self {\r\n        RenderLayers::layer(0)\r\n    }\r\n}\r\n\r\nimpl RenderLayers {\r\n    /// The total number of layers supported.\r\n    pub const TOTAL_LAYERS: usize = std::mem::size_of::<LayerMask>() * 8;\r\n\r\n    /// Create a new `RenderLayers` belonging to the given layer.\r\n    pub const fn layer(n: Layer) -> Self {\r\n        RenderLayers(0).with(n)\r\n    }\r\n\r\n    /// Create a new `RenderLayers` that belongs to all layers.\r\n    pub const fn all() -> Self {\r\n        RenderLayers(u32::MAX)\r\n    }\r\n\r\n    /// Create a new `RenderLayers` that belongs to no layers.\r\n    pub const fn none() -> Self {\r\n        RenderLayers(0)\r\n    }\r\n\r\n    /// Create a `RenderLayers` from a list of layers.\r\n    pub fn from_layers(layers: &[Layer]) -> Self {\r\n        layers.iter().copied().collect()\r\n    }\r\n\r\n    /// Add the given layer.\r\n    ///\r\n    /// This may be called multiple times to allow an entity to belong\r\n    /// to multiple rendering layers. The maximum layer is `TOTAL_LAYERS - 1`.\r\n    ///\r\n    /// # Panics\r\n    /// Panics when called with a layer greater than `TOTAL_LAYERS - 1`.\r\n    #[must_use]\r\n    pub const fn with(mut self, layer: Layer) -> Self {\r\n        assert!((layer as usize) < Self::TOTAL_LAYERS);\r\n        self.0 |= 1 << layer;\r\n        self\r\n    }\r\n\r\n    /// Removes the given rendering layer.\r\n    ///\r\n    /// # Panics\r\n    /// Panics when called with a layer greater than `TOTAL_LAYERS - 1`.\r\n    #[must_use]\r\n    pub const fn without(mut self, layer: Layer) -> Self {\r\n        assert!((layer as usize) < Self::TOTAL_LAYERS);\r\n        self.0 &= !(1 << layer);\r\n        self\r\n    }\r\n\r\n    /// Get an iterator of the layers.\r\n    pub fn iter(&self) -> impl Iterator<Item = Layer> {\r\n        let total: Layer = std::convert::TryInto::try_into(Self::TOTAL_LAYERS).unwrap();\r\n        let mask = *self;\r\n        (0..total).filter(move |g| RenderLayers::layer(*g).intersects(&mask))\r\n    }\r\n\r\n    /// Determine if a `RenderLayers` intersects another.\r\n    ///\r\n    /// `RenderLayers`s intersect if they share any common layers.\r\n    ///\r\n    /// A `RenderLayers` with no layers will not match any other\r\n    /// `RenderLayers`, even another with no layers.\r\n    pub fn intersects(&self, other: &RenderLayers) -> bool {\r\n        (self.0 & other.0) > 0\r\n    }\r\n\r\n    /// get the bitmask representation of the contained layers\r\n    pub fn bits(&self) -> u32 {\r\n        self.0\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod rendering_mask_tests {\r\n    use super::{Layer, RenderLayers};\r\n\r\n    #[test]\r\n    fn rendering_mask_sanity() {\r\n        assert_eq!(\r\n            RenderLayers::TOTAL_LAYERS,\r\n            32,\r\n            \"total layers is what we think it is\"\r\n        );\r\n        assert_eq!(RenderLayers::layer(0).0, 1, \"layer 0 is mask 1\");\r\n        assert_eq!(RenderLayers::layer(1).0, 2, \"layer 1 is mask 2\");\r\n        assert_eq!(RenderLayers::layer(0).with(1).0, 3, \"layer 0 + 1 is mask 3\");\r\n        assert_eq!(\r\n            RenderLayers::layer(0).with(1).without(0).0,\r\n            2,\r\n            \"layer 0 + 1 - 0 is mask 2\"\r\n        );\r\n        assert!(\r\n            RenderLayers::layer(1).intersects(&RenderLayers::layer(1)),\r\n            \"layers match like layers\"\r\n        );\r\n        assert!(\r\n            RenderLayers::layer(0).intersects(&RenderLayers(1)),\r\n            \"a layer of 0 means the mask is just 1 bit\"\r\n        );\r\n\r\n        assert!(\r\n            RenderLayers::layer(0)\r\n                .with(3)\r\n                .intersects(&RenderLayers::layer(3)),\r\n            \"a mask will match another mask containing any similar layers\"\r\n        );\r\n\r\n        assert!(\r\n            RenderLayers::default().intersects(&RenderLayers::default()),\r\n            \"default masks match each other\"\r\n        );\r\n\r\n        assert!(\r\n            !RenderLayers::layer(0).intersects(&RenderLayers::layer(1)),\r\n            \"masks with differing layers do not match\"\r\n        );\r\n        assert!(\r\n            !RenderLayers(0).intersects(&RenderLayers(0)),\r\n            \"empty masks don't match\"\r\n        );\r\n        assert_eq!(\r\n            RenderLayers::from_layers(&[0, 2, 16, 30])\r\n                .iter()\r\n                .collect::<Vec<_>>(),\r\n            vec![0, 2, 16, 30],\r\n            \"from_layers and get_layers should roundtrip\"\r\n        );\r\n        assert_eq!(\r\n            format!(\"{:?}\", RenderLayers::from_layers(&[0, 1, 2, 3])).as_str(),\r\n            \"RenderLayers([0, 1, 2, 3])\",\r\n            \"Debug instance shows layers\"\r\n        );\r\n        assert_eq!(\r\n            RenderLayers::from_layers(&[0, 1, 2]),\r\n            <RenderLayers as FromIterator<Layer>>::from_iter(vec![0, 1, 2]),\r\n            \"from_layers and from_iter are equivalent\"\r\n        );\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\bevy\\crates\\bevy_winit\\src\\lib.rs\r\n\r\n````rust\r\n//! `bevy_winit` provides utilities to handle window creation and the eventloop through [`winit`]\r\n//!\r\n//! Most commonly, the [`WinitPlugin`] is used as part of\r\n//! [`DefaultPlugins`](https://docs.rs/bevy/latest/bevy/struct.DefaultPlugins.html).\r\n//! The app's [runner](bevy_app::App::runner) is set by `WinitPlugin` and handles the `winit` [`EventLoop`].\r\n//! See `winit_runner` for details.\r\n#![cfg_attr(docsrs, feature(doc_auto_cfg))]\r\n\r\npub mod accessibility;\r\nmod converters;\r\nmod system;\r\nmod winit_config;\r\npub mod winit_event;\r\nmod winit_windows;\r\n\r\nuse approx::relative_eq;\r\nuse bevy_a11y::AccessibilityRequested;\r\nuse bevy_utils::Instant;\r\npub use system::create_windows;\r\nuse system::{changed_windows, despawn_windows, CachedWindow};\r\nuse winit::dpi::{LogicalSize, PhysicalSize};\r\npub use winit_config::*;\r\npub use winit_event::*;\r\npub use winit_windows::*;\r\n\r\nuse bevy_app::{App, AppExit, Last, Plugin, PluginsState};\r\nuse bevy_ecs::event::ManualEventReader;\r\nuse bevy_ecs::prelude::*;\r\nuse bevy_ecs::system::SystemState;\r\nuse bevy_input::{\r\n    mouse::{MouseButtonInput, MouseMotion, MouseScrollUnit, MouseWheel},\r\n    touchpad::{TouchpadMagnify, TouchpadRotate},\r\n};\r\nuse bevy_math::{ivec2, DVec2, Vec2};\r\n#[cfg(not(target_arch = \"wasm32\"))]\r\nuse bevy_tasks::tick_global_task_pools_on_main_thread;\r\nuse bevy_utils::tracing::{error, trace, warn};\r\nuse bevy_window::{\r\n    exit_on_all_closed, ApplicationLifetime, CursorEntered, CursorLeft, CursorMoved,\r\n    FileDragAndDrop, Ime, ReceivedCharacter, RequestRedraw, Window,\r\n    WindowBackendScaleFactorChanged, WindowCloseRequested, WindowCreated, WindowDestroyed,\r\n    WindowFocused, WindowMoved, WindowOccluded, WindowResized, WindowScaleFactorChanged,\r\n    WindowThemeChanged,\r\n};\r\n#[cfg(target_os = \"android\")]\r\nuse bevy_window::{PrimaryWindow, RawHandleWrapper};\r\n\r\n#[cfg(target_os = \"android\")]\r\npub use winit::platform::android::activity as android_activity;\r\n\r\nuse winit::event::StartCause;\r\nuse winit::{\r\n    event::{self, DeviceEvent, Event, WindowEvent},\r\n    event_loop::{ControlFlow, EventLoop, EventLoopBuilder, EventLoopWindowTarget},\r\n};\r\n\r\nuse crate::accessibility::{AccessKitAdapters, AccessKitPlugin, WinitActionHandlers};\r\n\r\nuse crate::converters::convert_winit_theme;\r\n\r\n/// [`AndroidApp`] provides an interface to query the application state as well as monitor events\r\n/// (for example lifecycle and input events).\r\n#[cfg(target_os = \"android\")]\r\npub static ANDROID_APP: std::sync::OnceLock<android_activity::AndroidApp> =\r\n    std::sync::OnceLock::new();\r\n\r\n/// A [`Plugin`] that uses `winit` to create and manage windows, and receive window and input\r\n/// events.\r\n///\r\n/// This plugin will add systems and resources that sync with the `winit` backend and also\r\n/// replace the existing [`App`] runner with one that constructs an [event loop](EventLoop) to\r\n/// receive window and input events from the OS.\r\n#[derive(Default)]\r\npub struct WinitPlugin {\r\n    /// Allows the window (and the event loop) to be created on any thread\r\n    /// instead of only the main thread.\r\n    ///\r\n    /// See [`EventLoopBuilder::build`] for more information on this.\r\n    ///\r\n    /// # Supported platforms\r\n    ///\r\n    /// Only works on Linux (X11/Wayland) and Windows.\r\n    /// This field is ignored on other platforms.\r\n    pub run_on_any_thread: bool,\r\n}\r\n\r\nimpl Plugin for WinitPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        let mut event_loop_builder = EventLoopBuilder::<UserEvent>::with_user_event();\r\n\r\n        // linux check is needed because x11 might be enabled on other platforms.\r\n        #[cfg(all(target_os = \"linux\", feature = \"x11\"))]\r\n        {\r\n            use winit::platform::x11::EventLoopBuilderExtX11;\r\n\r\n            // This allows a Bevy app to be started and ran outside of the main thread.\r\n            // A use case for this is to allow external applications to spawn a thread\r\n            // which runs a Bevy app without requiring the Bevy app to need to reside on\r\n            // the main thread, which can be problematic.\r\n            event_loop_builder.with_any_thread(self.run_on_any_thread);\r\n        }\r\n\r\n        // linux check is needed because wayland might be enabled on other platforms.\r\n        #[cfg(all(target_os = \"linux\", feature = \"wayland\"))]\r\n        {\r\n            use winit::platform::wayland::EventLoopBuilderExtWayland;\r\n            event_loop_builder.with_any_thread(self.run_on_any_thread);\r\n        }\r\n\r\n        #[cfg(target_os = \"windows\")]\r\n        {\r\n            use winit::platform::windows::EventLoopBuilderExtWindows;\r\n            event_loop_builder.with_any_thread(self.run_on_any_thread);\r\n        }\r\n\r\n        #[cfg(target_os = \"android\")]\r\n        {\r\n            use winit::platform::android::EventLoopBuilderExtAndroid;\r\n            let msg = \"Bevy must be setup with the #[bevy_main] macro on Android\";\r\n            event_loop_builder.with_android_app(ANDROID_APP.get().expect(msg).clone());\r\n        }\r\n\r\n        app.init_non_send_resource::<WinitWindows>()\r\n            .init_resource::<WinitSettings>()\r\n            .add_event::<WinitEvent>()\r\n            .set_runner(winit_runner)\r\n            .add_systems(\r\n                Last,\r\n                (\r\n                    // `exit_on_all_closed` only checks if windows exist but doesn't access data,\r\n                    // so we don't need to care about its ordering relative to `changed_windows`\r\n                    changed_windows.ambiguous_with(exit_on_all_closed),\r\n                    despawn_windows,\r\n                )\r\n                    .chain(),\r\n            );\r\n\r\n        app.add_plugins(AccessKitPlugin);\r\n\r\n        let event_loop = event_loop_builder\r\n            .build()\r\n            .expect(\"Failed to build event loop\");\r\n\r\n        // iOS, macOS, and Android don't like it if you create windows before the event loop is\r\n        // initialized.\r\n        //\r\n        // See:\r\n        // - https://github.com/rust-windowing/winit/blob/master/README.md#macos\r\n        // - https://github.com/rust-windowing/winit/blob/master/README.md#ios\r\n        #[cfg(not(any(target_os = \"android\", target_os = \"ios\", target_os = \"macos\")))]\r\n        {\r\n            // Otherwise, we want to create a window before `bevy_render` initializes the renderer\r\n            // so that we have a surface to use as a hint. This improves compatibility with `wgpu`\r\n            // backends, especially WASM/WebGL2.\r\n            let mut create_window = SystemState::<CreateWindowParams>::from_world(&mut app.world);\r\n            create_windows(&event_loop, create_window.get_mut(&mut app.world));\r\n            create_window.apply(&mut app.world);\r\n        }\r\n\r\n        // `winit`'s windows are bound to the event loop that created them, so the event loop must\r\n        // be inserted as a resource here to pass it onto the runner.\r\n        app.insert_non_send_resource(event_loop);\r\n    }\r\n}\r\n\r\ntrait AppSendEvent {\r\n    fn send(&mut self, event: impl Into<WinitEvent>);\r\n}\r\nimpl AppSendEvent for Vec<WinitEvent> {\r\n    fn send(&mut self, event: impl Into<WinitEvent>) {\r\n        self.push(Into::<WinitEvent>::into(event));\r\n    }\r\n}\r\n\r\n/// Persistent state that is used to run the [`App`] according to the current\r\n/// [`UpdateMode`].\r\nstruct WinitAppRunnerState {\r\n    /// Current active state of the app.\r\n    active: ActiveState,\r\n    /// Is `true` if a new [`WindowEvent`] has been received since the last update.\r\n    window_event_received: bool,\r\n    /// Is `true` if a new [`DeviceEvent`] has been received since the last update.\r\n    device_event_received: bool,\r\n    /// Is `true` if the app has requested a redraw since the last update.\r\n    redraw_requested: bool,\r\n    /// Is `true` if enough time has elapsed since `last_update` to run another update.\r\n    wait_elapsed: bool,\r\n    /// The time the last update started.\r\n    last_update: Instant,\r\n    /// Number of \"forced\" updates to trigger on application start\r\n    startup_forced_updates: u32,\r\n}\r\n\r\nimpl WinitAppRunnerState {\r\n    fn reset_on_update(&mut self) {\r\n        self.redraw_requested = false;\r\n        self.window_event_received = false;\r\n        self.device_event_received = false;\r\n        self.wait_elapsed = false;\r\n    }\r\n}\r\n\r\n#[derive(PartialEq, Eq)]\r\nenum ActiveState {\r\n    NotYetStarted,\r\n    Active,\r\n    Suspended,\r\n    WillSuspend,\r\n}\r\n\r\nimpl ActiveState {\r\n    #[inline]\r\n    fn should_run(&self) -> bool {\r\n        match self {\r\n            ActiveState::NotYetStarted | ActiveState::Suspended => false,\r\n            ActiveState::Active | ActiveState::WillSuspend => true,\r\n        }\r\n    }\r\n}\r\n\r\nimpl Default for WinitAppRunnerState {\r\n    fn default() -> Self {\r\n        Self {\r\n            active: ActiveState::NotYetStarted,\r\n            window_event_received: false,\r\n            device_event_received: false,\r\n            redraw_requested: false,\r\n            wait_elapsed: false,\r\n            last_update: Instant::now(),\r\n            // 3 seems to be enough, 5 is a safe margin\r\n            startup_forced_updates: 5,\r\n        }\r\n    }\r\n}\r\n\r\n/// The parameters of the [`create_windows`] system.\r\npub type CreateWindowParams<'w, 's, F = ()> = (\r\n    Commands<'w, 's>,\r\n    Query<'w, 's, (Entity, &'static mut Window), F>,\r\n    EventWriter<'w, WindowCreated>,\r\n    NonSendMut<'w, WinitWindows>,\r\n    NonSendMut<'w, AccessKitAdapters>,\r\n    ResMut<'w, WinitActionHandlers>,\r\n    Res<'w, AccessibilityRequested>,\r\n);\r\n\r\n/// The [`winit::event_loop::EventLoopProxy`] with the specific [`winit::event::Event::UserEvent`] used in the [`winit_runner`].\r\n///\r\n/// The `EventLoopProxy` can be used to request a redraw from outside bevy.\r\n///\r\n/// Use `NonSend<EventLoopProxy>` to receive this resource.\r\npub type EventLoopProxy = winit::event_loop::EventLoopProxy<UserEvent>;\r\n\r\ntype UserEvent = RequestRedraw;\r\n\r\n/// The default [`App::runner`] for the [`WinitPlugin`] plugin.\r\n///\r\n/// Overriding the app's [runner](bevy_app::App::runner) while using `WinitPlugin` will bypass the\r\n/// `EventLoop`.\r\npub fn winit_runner(mut app: App) {\r\n    if app.plugins_state() == PluginsState::Ready {\r\n        app.finish();\r\n        app.cleanup();\r\n    }\r\n\r\n    let event_loop = app\r\n        .world\r\n        .remove_non_send_resource::<EventLoop<UserEvent>>()\r\n        .unwrap();\r\n\r\n    app.world\r\n        .insert_non_send_resource(event_loop.create_proxy());\r\n\r\n    let mut runner_state = WinitAppRunnerState::default();\r\n\r\n    // prepare structures to access data in the world\r\n    let mut app_exit_event_reader = ManualEventReader::<AppExit>::default();\r\n    let mut redraw_event_reader = ManualEventReader::<RequestRedraw>::default();\r\n\r\n    let mut focused_windows_state: SystemState<(Res<WinitSettings>, Query<&Window>)> =\r\n        SystemState::new(&mut app.world);\r\n\r\n    let mut event_writer_system_state: SystemState<(\r\n        EventWriter<WindowResized>,\r\n        NonSend<WinitWindows>,\r\n        Query<(&mut Window, &mut CachedWindow)>,\r\n        NonSend<AccessKitAdapters>,\r\n    )> = SystemState::new(&mut app.world);\r\n\r\n    let mut create_window =\r\n        SystemState::<CreateWindowParams<Added<Window>>>::from_world(&mut app.world);\r\n    let mut winit_events = Vec::default();\r\n    // set up the event loop\r\n    let event_handler = move |event, event_loop: &EventLoopWindowTarget<UserEvent>| {\r\n        handle_winit_event(\r\n            &mut app,\r\n            &mut app_exit_event_reader,\r\n            &mut runner_state,\r\n            &mut create_window,\r\n            &mut event_writer_system_state,\r\n            &mut focused_windows_state,\r\n            &mut redraw_event_reader,\r\n            &mut winit_events,\r\n            event,\r\n            event_loop,\r\n        );\r\n    };\r\n\r\n    trace!(\"starting winit event loop\");\r\n    // TODO(clean): the winit docs mention using `spawn` instead of `run` on WASM.\r\n    if let Err(err) = event_loop.run(event_handler) {\r\n        error!(\"winit event loop returned an error: {err}\");\r\n    }\r\n}\r\n\r\n#[allow(clippy::too_many_arguments /* TODO: probs can reduce # of args */)]\r\nfn handle_winit_event(\r\n    app: &mut App,\r\n    app_exit_event_reader: &mut ManualEventReader<AppExit>,\r\n    runner_state: &mut WinitAppRunnerState,\r\n    create_window: &mut SystemState<CreateWindowParams<Added<Window>>>,\r\n    event_writer_system_state: &mut SystemState<(\r\n        EventWriter<WindowResized>,\r\n        NonSend<WinitWindows>,\r\n        Query<(&mut Window, &mut CachedWindow)>,\r\n        NonSend<AccessKitAdapters>,\r\n    )>,\r\n    focused_windows_state: &mut SystemState<(Res<WinitSettings>, Query<&Window>)>,\r\n    redraw_event_reader: &mut ManualEventReader<RequestRedraw>,\r\n    winit_events: &mut Vec<WinitEvent>,\r\n    event: Event<UserEvent>,\r\n    event_loop: &EventLoopWindowTarget<UserEvent>,\r\n) {\r\n    #[cfg(feature = \"trace\")]\r\n    let _span = bevy_utils::tracing::info_span!(\"winit event_handler\").entered();\r\n\r\n    if app.plugins_state() != PluginsState::Cleaned {\r\n        if app.plugins_state() != PluginsState::Ready {\r\n            #[cfg(not(target_arch = \"wasm32\"))]\r\n            tick_global_task_pools_on_main_thread();\r\n        } else {\r\n            app.finish();\r\n            app.cleanup();\r\n        }\r\n        runner_state.redraw_requested = true;\r\n\r\n        if let Some(app_exit_events) = app.world.get_resource::<Events<AppExit>>() {\r\n            if app_exit_event_reader.read(app_exit_events).last().is_some() {\r\n                event_loop.exit();\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    match event {\r\n        Event::AboutToWait => {\r\n            let (config, windows) = focused_windows_state.get(&app.world);\r\n            let focused = windows.iter().any(|window| window.focused);\r\n            let mut should_update = match config.update_mode(focused) {\r\n                UpdateMode::Continuous => {\r\n                    runner_state.redraw_requested\r\n                        || runner_state.window_event_received\r\n                        || runner_state.device_event_received\r\n                }\r\n                UpdateMode::Reactive { .. } => {\r\n                    runner_state.wait_elapsed\r\n                        || runner_state.redraw_requested\r\n                        || runner_state.window_event_received\r\n                        || runner_state.device_event_received\r\n                }\r\n                UpdateMode::ReactiveLowPower { .. } => {\r\n                    runner_state.wait_elapsed\r\n                        || runner_state.redraw_requested\r\n                        || runner_state.window_event_received\r\n                }\r\n            };\r\n\r\n            // Ensure that an update is triggered on the first iterations for app initialization\r\n            if runner_state.startup_forced_updates > 0 {\r\n                runner_state.startup_forced_updates -= 1;\r\n                should_update = true;\r\n            }\r\n\r\n            // Trigger one last update to enter suspended state\r\n            if runner_state.active == ActiveState::WillSuspend {\r\n                should_update = true;\r\n            }\r\n\r\n            if should_update {\r\n                let visible = windows.iter().any(|window| window.visible);\r\n                let (_, winit_windows, _, _) = event_writer_system_state.get_mut(&mut app.world);\r\n                if visible && runner_state.active != ActiveState::WillSuspend {\r\n                    for window in winit_windows.windows.values() {\r\n                        window.request_redraw();\r\n                    }\r\n                } else {\r\n                    // there are no windows, or they are not visible.\r\n                    // Winit won't send events on some platforms, so trigger an update manually.\r\n                    run_app_update_if_should(\r\n                        runner_state,\r\n                        app,\r\n                        focused_windows_state,\r\n                        event_loop,\r\n                        create_window,\r\n                        app_exit_event_reader,\r\n                        redraw_event_reader,\r\n                        winit_events,\r\n                    );\r\n                    if runner_state.active != ActiveState::Suspended {\r\n                        event_loop.set_control_flow(ControlFlow::Poll);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        Event::NewEvents(cause) => {\r\n            runner_state.wait_elapsed = match cause {\r\n                StartCause::WaitCancelled {\r\n                    requested_resume: Some(resume),\r\n                    ..\r\n                } => resume >= Instant::now(),\r\n                _ => true,\r\n            };\r\n        }\r\n        Event::WindowEvent {\r\n            event, window_id, ..\r\n        } => {\r\n            let (mut window_resized, winit_windows, mut windows, access_kit_adapters) =\r\n                event_writer_system_state.get_mut(&mut app.world);\r\n\r\n            let Some(window) = winit_windows.get_window_entity(window_id) else {\r\n                warn!(\"Skipped event {event:?} for unknown winit Window Id {window_id:?}\");\r\n                return;\r\n            };\r\n\r\n            let Ok((mut win, _)) = windows.get_mut(window) else {\r\n                warn!(\"Window {window:?} is missing `Window` component, skipping event {event:?}\");\r\n                return;\r\n            };\r\n\r\n            // Allow AccessKit to respond to `WindowEvent`s before they reach\r\n            // the engine.\r\n            if let Some(adapter) = access_kit_adapters.get(&window) {\r\n                if let Some(winit_window) = winit_windows.get_window(window) {\r\n                    adapter.process_event(winit_window, &event);\r\n                }\r\n            }\r\n\r\n            runner_state.window_event_received = true;\r\n\r\n            match event {\r\n                WindowEvent::Resized(size) => {\r\n                    react_to_resize(&mut win, size, &mut window_resized, window);\r\n                }\r\n                WindowEvent::CloseRequested => winit_events.send(WindowCloseRequested { window }),\r\n                WindowEvent::KeyboardInput { ref event, .. } => {\r\n                    if event.state.is_pressed() {\r\n                        if let Some(char) = &event.text {\r\n                            let char = char.clone();\r\n                            winit_events.send(ReceivedCharacter { window, char });\r\n                        }\r\n                    }\r\n                    winit_events.send(converters::convert_keyboard_input(event, window));\r\n                }\r\n                WindowEvent::CursorMoved { position, .. } => {\r\n                    let physical_position = DVec2::new(position.x, position.y);\r\n\r\n                    let last_position = win.physical_cursor_position();\r\n                    let delta = last_position.map(|last_pos| {\r\n                        (physical_position.as_vec2() - last_pos) / win.resolution.scale_factor()\r\n                    });\r\n\r\n                    win.set_physical_cursor_position(Some(physical_position));\r\n                    let position =\r\n                        (physical_position / win.resolution.scale_factor() as f64).as_vec2();\r\n                    winit_events.send(CursorMoved {\r\n                        window,\r\n                        position,\r\n                        delta,\r\n                    });\r\n                }\r\n                WindowEvent::CursorEntered { .. } => {\r\n                    winit_events.send(CursorEntered { window });\r\n                }\r\n                WindowEvent::CursorLeft { .. } => {\r\n                    win.set_physical_cursor_position(None);\r\n                    winit_events.send(CursorLeft { window });\r\n                }\r\n                WindowEvent::MouseInput { state, button, .. } => {\r\n                    winit_events.send(MouseButtonInput {\r\n                        button: converters::convert_mouse_button(button),\r\n                        state: converters::convert_element_state(state),\r\n                        window,\r\n                    });\r\n                }\r\n                WindowEvent::TouchpadMagnify { delta, .. } => {\r\n                    winit_events.send(TouchpadMagnify(delta as f32));\r\n                }\r\n                WindowEvent::TouchpadRotate { delta, .. } => {\r\n                    winit_events.send(TouchpadRotate(delta));\r\n                }\r\n                WindowEvent::MouseWheel { delta, .. } => match delta {\r\n                    event::MouseScrollDelta::LineDelta(x, y) => {\r\n                        winit_events.send(MouseWheel {\r\n                            unit: MouseScrollUnit::Line,\r\n                            x,\r\n                            y,\r\n                            window,\r\n                        });\r\n                    }\r\n                    event::MouseScrollDelta::PixelDelta(p) => {\r\n                        winit_events.send(MouseWheel {\r\n                            unit: MouseScrollUnit::Pixel,\r\n                            x: p.x as f32,\r\n                            y: p.y as f32,\r\n                            window,\r\n                        });\r\n                    }\r\n                },\r\n                WindowEvent::Touch(touch) => {\r\n                    let location = touch\r\n                        .location\r\n                        .to_logical(win.resolution.scale_factor() as f64);\r\n                    winit_events.send(converters::convert_touch_input(touch, location, window));\r\n                }\r\n                WindowEvent::ScaleFactorChanged {\r\n                    scale_factor,\r\n                    mut inner_size_writer,\r\n                } => {\r\n                    let prior_factor = win.resolution.scale_factor();\r\n                    win.resolution.set_scale_factor(scale_factor as f32);\r\n                    // Note: this may be different from new_scale_factor if\r\n                    // `scale_factor_override` is set to Some(thing)\r\n                    let new_factor = win.resolution.scale_factor();\r\n\r\n                    let mut new_inner_size =\r\n                        PhysicalSize::new(win.physical_width(), win.physical_height());\r\n                    let scale_factor_override = win.resolution.scale_factor_override();\r\n                    if let Some(forced_factor) = scale_factor_override {\r\n                        // This window is overriding the OS-suggested DPI, so its physical size\r\n                        // should be set based on the overriding value. Its logical size already\r\n                        // incorporates any resize constraints.\r\n                        let maybe_new_inner_size = LogicalSize::new(win.width(), win.height())\r\n                            .to_physical::<u32>(forced_factor as f64);\r\n                        if let Err(err) = inner_size_writer.request_inner_size(new_inner_size) {\r\n                            warn!(\"Winit Failed to resize the window: {err}\");\r\n                        } else {\r\n                            new_inner_size = maybe_new_inner_size;\r\n                        }\r\n                    }\r\n                    let new_logical_width = new_inner_size.width as f32 / new_factor;\r\n                    let new_logical_height = new_inner_size.height as f32 / new_factor;\r\n\r\n                    let width_equal = relative_eq!(win.width(), new_logical_width);\r\n                    let height_equal = relative_eq!(win.height(), new_logical_height);\r\n                    win.resolution\r\n                        .set_physical_resolution(new_inner_size.width, new_inner_size.height);\r\n\r\n                    winit_events.send(WindowBackendScaleFactorChanged {\r\n                        window,\r\n                        scale_factor,\r\n                    });\r\n                    if scale_factor_override.is_none() && !relative_eq!(new_factor, prior_factor) {\r\n                        winit_events.send(WindowScaleFactorChanged {\r\n                            window,\r\n                            scale_factor,\r\n                        });\r\n                    }\r\n\r\n                    if !width_equal || !height_equal {\r\n                        winit_events.send(WindowResized {\r\n                            window,\r\n                            width: new_logical_width,\r\n                            height: new_logical_height,\r\n                        });\r\n                    }\r\n                }\r\n                WindowEvent::Focused(focused) => {\r\n                    win.focused = focused;\r\n                    winit_events.send(WindowFocused { window, focused });\r\n                }\r\n                WindowEvent::Occluded(occluded) => {\r\n                    winit_events.send(WindowOccluded { window, occluded });\r\n                }\r\n                WindowEvent::DroppedFile(path_buf) => {\r\n                    winit_events.send(FileDragAndDrop::DroppedFile { window, path_buf });\r\n                }\r\n                WindowEvent::HoveredFile(path_buf) => {\r\n                    winit_events.send(FileDragAndDrop::HoveredFile { window, path_buf });\r\n                }\r\n                WindowEvent::HoveredFileCancelled => {\r\n                    winit_events.send(FileDragAndDrop::HoveredFileCanceled { window });\r\n                }\r\n                WindowEvent::Moved(position) => {\r\n                    let position = ivec2(position.x, position.y);\r\n                    win.position.set(position);\r\n                    winit_events.send(WindowMoved { window, position });\r\n                }\r\n                WindowEvent::Ime(event) => match event {\r\n                    event::Ime::Preedit(value, cursor) => {\r\n                        winit_events.send(Ime::Preedit {\r\n                            window,\r\n                            value,\r\n                            cursor,\r\n                        });\r\n                    }\r\n                    event::Ime::Commit(value) => {\r\n                        winit_events.send(Ime::Commit { window, value });\r\n                    }\r\n                    event::Ime::Enabled => {\r\n                        winit_events.send(Ime::Enabled { window });\r\n                    }\r\n                    event::Ime::Disabled => {\r\n                        winit_events.send(Ime::Disabled { window });\r\n                    }\r\n                },\r\n                WindowEvent::ThemeChanged(theme) => {\r\n                    winit_events.send(WindowThemeChanged {\r\n                        window,\r\n                        theme: convert_winit_theme(theme),\r\n                    });\r\n                }\r\n                WindowEvent::Destroyed => {\r\n                    winit_events.send(WindowDestroyed { window });\r\n                }\r\n                WindowEvent::RedrawRequested => {\r\n                    run_app_update_if_should(\r\n                        runner_state,\r\n                        app,\r\n                        focused_windows_state,\r\n                        event_loop,\r\n                        create_window,\r\n                        app_exit_event_reader,\r\n                        redraw_event_reader,\r\n                        winit_events,\r\n                    );\r\n                }\r\n                _ => {}\r\n            }\r\n\r\n            let mut windows = app.world.query::<(&mut Window, &mut CachedWindow)>();\r\n            if let Ok((window_component, mut cache)) = windows.get_mut(&mut app.world, window) {\r\n                if window_component.is_changed() {\r\n                    cache.window = window_component.clone();\r\n                }\r\n            }\r\n        }\r\n        Event::DeviceEvent { event, .. } => {\r\n            runner_state.device_event_received = true;\r\n            if let DeviceEvent::MouseMotion { delta: (x, y) } = event {\r\n                let delta = Vec2::new(x as f32, y as f32);\r\n                winit_events.send(MouseMotion { delta });\r\n            }\r\n        }\r\n        Event::Suspended => {\r\n            winit_events.send(ApplicationLifetime::Suspended);\r\n            // Mark the state as `WillSuspend`. This will let the schedule run one last time\r\n            // before actually suspending to let the application react\r\n            runner_state.active = ActiveState::WillSuspend;\r\n        }\r\n        Event::Resumed => {\r\n            #[cfg(any(target_os = \"android\", target_os = \"ios\", target_os = \"macos\"))]\r\n            {\r\n                if runner_state.active == ActiveState::NotYetStarted {\r\n                    create_windows(event_loop, create_window.get_mut(&mut app.world));\r\n                    create_window.apply(&mut app.world);\r\n                }\r\n            }\r\n\r\n            match runner_state.active {\r\n                ActiveState::NotYetStarted => winit_events.send(ApplicationLifetime::Started),\r\n                _ => winit_events.send(ApplicationLifetime::Resumed),\r\n            }\r\n            runner_state.active = ActiveState::Active;\r\n            runner_state.redraw_requested = true;\r\n            #[cfg(target_os = \"android\")]\r\n            {\r\n                // Get windows that are cached but without raw handles. Those window were already created, but got their\r\n                // handle wrapper removed when the app was suspended.\r\n                let mut query = app\r\n                        .world\r\n                        .query_filtered::<(Entity, &Window), (With<CachedWindow>, Without<bevy_window::RawHandleWrapper>)>();\r\n                if let Ok((entity, window)) = query.get_single(&app.world) {\r\n                    use raw_window_handle::{HasDisplayHandle, HasWindowHandle};\r\n                    let window = window.clone();\r\n\r\n                    let (\r\n                        ..,\r\n                        mut winit_windows,\r\n                        mut adapters,\r\n                        mut handlers,\r\n                        accessibility_requested,\r\n                    ) = create_window.get_mut(&mut app.world);\r\n\r\n                    let winit_window = winit_windows.create_window(\r\n                        event_loop,\r\n                        entity,\r\n                        &window,\r\n                        &mut adapters,\r\n                        &mut handlers,\r\n                        &accessibility_requested,\r\n                    );\r\n\r\n                    let wrapper = RawHandleWrapper {\r\n                        window_handle: winit_window.window_handle().unwrap().as_raw(),\r\n                        display_handle: winit_window.display_handle().unwrap().as_raw(),\r\n                    };\r\n\r\n                    app.world.entity_mut(entity).insert(wrapper);\r\n                }\r\n                event_loop.set_control_flow(ControlFlow::Wait);\r\n            }\r\n        }\r\n        Event::UserEvent(RequestRedraw) => {\r\n            runner_state.redraw_requested = true;\r\n        }\r\n        _ => (),\r\n    }\r\n\r\n    // We drain events after every received winit event in addition to on app update to ensure\r\n    // the work of pushing events into event queues is spread out over time in case the app becomes\r\n    // dormant for a long stretch.\r\n    forward_winit_events(winit_events, app);\r\n}\r\n\r\n#[allow(clippy::too_many_arguments)]\r\nfn run_app_update_if_should(\r\n    runner_state: &mut WinitAppRunnerState,\r\n    app: &mut App,\r\n    focused_windows_state: &mut SystemState<(Res<WinitSettings>, Query<&Window>)>,\r\n    event_loop: &EventLoopWindowTarget<UserEvent>,\r\n    create_window: &mut SystemState<CreateWindowParams<Added<Window>>>,\r\n    app_exit_event_reader: &mut ManualEventReader<AppExit>,\r\n    redraw_event_reader: &mut ManualEventReader<RequestRedraw>,\r\n    winit_events: &mut Vec<WinitEvent>,\r\n) {\r\n    runner_state.reset_on_update();\r\n\r\n    if !runner_state.active.should_run() {\r\n        return;\r\n    }\r\n\r\n    forward_winit_events(winit_events, app);\r\n\r\n    if runner_state.active == ActiveState::WillSuspend {\r\n        runner_state.active = ActiveState::Suspended;\r\n        #[cfg(target_os = \"android\")]\r\n        {\r\n            // Remove the `RawHandleWrapper` from the primary window.\r\n            // This will trigger the surface destruction.\r\n            let mut query = app.world.query_filtered::<Entity, With<PrimaryWindow>>();\r\n            let entity = query.single(&app.world);\r\n            app.world.entity_mut(entity).remove::<RawHandleWrapper>();\r\n            event_loop.set_control_flow(ControlFlow::Wait);\r\n        }\r\n    }\r\n\r\n    if app.plugins_state() == PluginsState::Cleaned {\r\n        runner_state.last_update = Instant::now();\r\n\r\n        app.update();\r\n\r\n        // decide when to run the next update\r\n        let (config, windows) = focused_windows_state.get(&app.world);\r\n        let focused = windows.iter().any(|window| window.focused);\r\n        match config.update_mode(focused) {\r\n            UpdateMode::Continuous => {\r\n                runner_state.redraw_requested = true;\r\n                event_loop.set_control_flow(ControlFlow::Wait);\r\n            }\r\n            UpdateMode::Reactive { wait } | UpdateMode::ReactiveLowPower { wait } => {\r\n                // TODO(bug): this is unexpected behavior.\r\n                // When Reactive, user expects bevy to actually wait that amount of time,\r\n                // and not potentially infinitely depending on plateform specifics (which this does)\r\n                // Need to verify the plateform specifics (whether this can occur in\r\n                // rare-but-possible cases) and replace this with a panic or a log warn!\r\n                if let Some(next) = runner_state.last_update.checked_add(*wait) {\r\n                    event_loop.set_control_flow(ControlFlow::WaitUntil(next));\r\n                } else {\r\n                    event_loop.set_control_flow(ControlFlow::Wait);\r\n                }\r\n            }\r\n        }\r\n\r\n        if let Some(app_redraw_events) = app.world.get_resource::<Events<RequestRedraw>>() {\r\n            if redraw_event_reader.read(app_redraw_events).last().is_some() {\r\n                runner_state.redraw_requested = true;\r\n            }\r\n        }\r\n\r\n        if let Some(app_exit_events) = app.world.get_resource::<Events<AppExit>>() {\r\n            if app_exit_event_reader.read(app_exit_events).last().is_some() {\r\n                event_loop.exit();\r\n            }\r\n        }\r\n    }\r\n\r\n    // create any new windows\r\n    // (even if app did not update, some may have been created by plugin setup)\r\n    create_windows(event_loop, create_window.get_mut(&mut app.world));\r\n    create_window.apply(&mut app.world);\r\n}\r\n\r\nfn react_to_resize(\r\n    win: &mut Mut<'_, Window>,\r\n    size: winit::dpi::PhysicalSize<u32>,\r\n    window_resized: &mut EventWriter<WindowResized>,\r\n    window: Entity,\r\n) {\r\n    win.resolution\r\n        .set_physical_resolution(size.width, size.height);\r\n\r\n    window_resized.send(WindowResized {\r\n        window,\r\n        width: win.width(),\r\n        height: win.height(),\r\n    });\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\bevy\\crates\\bevy_winit\\src\\winit_config.rs\r\n\r\n````rust\r\nuse bevy_ecs::system::Resource;\r\nuse bevy_utils::Duration;\r\n\r\n/// Settings for the [`WinitPlugin`](super::WinitPlugin).\r\n#[derive(Debug, Resource)]\r\npub struct WinitSettings {\r\n    /// Determines how frequently the application can update when it has focus.\r\n    pub focused_mode: UpdateMode,\r\n    /// Determines how frequently the application can update when it's out of focus.\r\n    pub unfocused_mode: UpdateMode,\r\n}\r\n\r\nimpl WinitSettings {\r\n    /// Default settings for games.\r\n    ///\r\n    /// [`Continuous`](UpdateMode::Continuous) if windows have focus,\r\n    /// [`ReactiveLowPower`](UpdateMode::ReactiveLowPower) otherwise.\r\n    pub fn game() -> Self {\r\n        WinitSettings {\r\n            focused_mode: UpdateMode::Continuous,\r\n            unfocused_mode: UpdateMode::ReactiveLowPower {\r\n                wait: Duration::from_secs_f64(1.0 / 60.0), // 60Hz\r\n            },\r\n        }\r\n    }\r\n\r\n    /// Default settings for desktop applications.\r\n    ///\r\n    /// [`Reactive`](UpdateMode::Reactive) if windows have focus,\r\n    /// [`ReactiveLowPower`](UpdateMode::ReactiveLowPower) otherwise.\r\n    ///\r\n    /// Use the [`EventLoopProxy`](crate::EventLoopProxy) to request a redraw from outside bevy.\r\n    pub fn desktop_app() -> Self {\r\n        WinitSettings {\r\n            focused_mode: UpdateMode::Reactive {\r\n                wait: Duration::from_secs(5),\r\n            },\r\n            unfocused_mode: UpdateMode::ReactiveLowPower {\r\n                wait: Duration::from_secs(60),\r\n            },\r\n        }\r\n    }\r\n\r\n    /// Returns the current [`UpdateMode`].\r\n    ///\r\n    /// **Note:** The output depends on whether the window has focus or not.\r\n    pub fn update_mode(&self, focused: bool) -> &UpdateMode {\r\n        match focused {\r\n            true => &self.focused_mode,\r\n            false => &self.unfocused_mode,\r\n        }\r\n    }\r\n}\r\n\r\nimpl Default for WinitSettings {\r\n    fn default() -> Self {\r\n        WinitSettings::game()\r\n    }\r\n}\r\n\r\n/// Determines how frequently an [`App`](bevy_app::App) should update.\r\n///\r\n/// **Note:** This setting is independent of VSync. VSync is controlled by a window's\r\n/// [`PresentMode`](bevy_window::PresentMode) setting. If an app can update faster than the refresh\r\n/// rate, but VSync is enabled, the update rate will be indirectly limited by the renderer.\r\n#[derive(Debug, Clone, Copy)]\r\npub enum UpdateMode {\r\n    /// The [`App`](bevy_app::App) will update over and over, as fast as it possibly can, until an\r\n    /// [`AppExit`](bevy_app::AppExit) event appears.\r\n    Continuous,\r\n    /// The [`App`](bevy_app::App) will update in response to the following, until an\r\n    /// [`AppExit`](bevy_app::AppExit) event appears:\r\n    /// - `wait` time has elapsed since the previous update\r\n    /// - a redraw has been requested by [`RequestRedraw`](bevy_window::RequestRedraw)\r\n    /// - new [window](`winit::event::WindowEvent`) or [raw input](`winit::event::DeviceEvent`)\r\n    /// events have appeared\r\n    /// - a redraw has been requested with the [`EventLoopProxy`](crate::EventLoopProxy)\r\n    Reactive {\r\n        /// The approximate time from the start of one update to the next.\r\n        ///\r\n        /// **Note:** This has no upper limit.\r\n        /// The [`App`](bevy_app::App) will wait indefinitely if you set this to [`Duration::MAX`].\r\n        wait: Duration,\r\n    },\r\n    /// The [`App`](bevy_app::App) will update in response to the following, until an\r\n    /// [`AppExit`](bevy_app::AppExit) event appears:\r\n    /// - `wait` time has elapsed since the previous update\r\n    /// - a redraw has been requested by [`RequestRedraw`](bevy_window::RequestRedraw)\r\n    /// - new [window events](`winit::event::WindowEvent`) have appeared\r\n    /// - a redraw has been requested with the [`EventLoopProxy`](crate::EventLoopProxy)\r\n    ///\r\n    /// **Note:** Unlike [`Reactive`](`UpdateMode::Reactive`), this mode will ignore events that\r\n    /// don't come from interacting with a window, like [`MouseMotion`](winit::event::DeviceEvent::MouseMotion).\r\n    /// Use this mode if, for example, you only want your app to update when the mouse cursor is\r\n    /// moving over a window, not just moving in general. This can greatly reduce power consumption.\r\n    ReactiveLowPower {\r\n        /// The approximate time from the start of one update to the next.\r\n        ///\r\n        /// **Note:** This has no upper limit.\r\n        /// The [`App`](bevy_app::App) will wait indefinitely if you set this to [`Duration::MAX`].\r\n        wait: Duration,\r\n    },\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\bevy\\crates\\bevy_pbr\\src\\render\\mesh_view_bindings.rs\r\n\r\n````rust\r\nuse std::{array, num::NonZeroU64};\r\n\r\nuse bevy_core_pipeline::{\r\n    core_3d::ViewTransmissionTexture,\r\n    prepass::ViewPrepassTextures,\r\n    tonemapping::{\r\n        get_lut_bind_group_layout_entries, get_lut_bindings, Tonemapping, TonemappingLuts,\r\n    },\r\n};\r\nuse bevy_ecs::{\r\n    component::Component,\r\n    entity::Entity,\r\n    system::{Commands, Query, Res},\r\n};\r\nuse bevy_render::{\r\n    globals::{GlobalsBuffer, GlobalsUniform},\r\n    render_asset::RenderAssets,\r\n    render_resource::{binding_types::*, *},\r\n    renderer::RenderDevice,\r\n    texture::{BevyDefault, FallbackImage, FallbackImageMsaa, FallbackImageZero, Image},\r\n    view::{Msaa, ViewUniform, ViewUniforms},\r\n};\r\n\r\n#[cfg(all(feature = \"webgl\", target_arch = \"wasm32\", not(feature = \"webgpu\")))]\r\nuse bevy_render::render_resource::binding_types::texture_cube;\r\nuse environment_map::EnvironmentMapLight;\r\n\r\nuse crate::{\r\n    environment_map::{self, RenderViewEnvironmentMapBindGroupEntries},\r\n    irradiance_volume::{\r\n        self, IrradianceVolume, RenderViewIrradianceVolumeBindGroupEntries,\r\n        IRRADIANCE_VOLUMES_ARE_USABLE,\r\n    },\r\n    prepass, FogMeta, GlobalLightMeta, GpuFog, GpuLights, GpuPointLights, LightMeta,\r\n    LightProbesBuffer, LightProbesUniform, MeshPipeline, MeshPipelineKey, RenderViewLightProbes,\r\n    ScreenSpaceAmbientOcclusionTextures, ShadowSamplers, ViewClusterBindings, ViewShadowBindings,\r\n};\r\n\r\n#[derive(Clone)]\r\npub struct MeshPipelineViewLayout {\r\n    pub bind_group_layout: BindGroupLayout,\r\n\r\n    #[cfg(debug_assertions)]\r\n    pub texture_count: usize,\r\n}\r\n\r\nbitflags::bitflags! {\r\n    /// A key that uniquely identifies a [`MeshPipelineViewLayout`].\r\n    ///\r\n    /// Used to generate all possible layouts for the mesh pipeline in [`generate_view_layouts`],\r\n    /// so special care must be taken to not add too many flags, as the number of possible layouts\r\n    /// will grow exponentially.\r\n    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\r\n    #[repr(transparent)]\r\n    pub struct MeshPipelineViewLayoutKey: u32 {\r\n        const MULTISAMPLED                = 1 << 0;\r\n        const DEPTH_PREPASS               = 1 << 1;\r\n        const NORMAL_PREPASS              = 1 << 2;\r\n        const MOTION_VECTOR_PREPASS       = 1 << 3;\r\n        const DEFERRED_PREPASS            = 1 << 4;\r\n    }\r\n}\r\n\r\nimpl MeshPipelineViewLayoutKey {\r\n    // The number of possible layouts\r\n    pub const COUNT: usize = Self::all().bits() as usize + 1;\r\n\r\n    /// Builds a unique label for each layout based on the flags\r\n    pub fn label(&self) -> String {\r\n        use MeshPipelineViewLayoutKey as Key;\r\n\r\n        format!(\r\n            \"mesh_view_layout{}{}{}{}{}\",\r\n            self.contains(Key::MULTISAMPLED)\r\n                .then_some(\"_multisampled\")\r\n                .unwrap_or_default(),\r\n            self.contains(Key::DEPTH_PREPASS)\r\n                .then_some(\"_depth\")\r\n                .unwrap_or_default(),\r\n            self.contains(Key::NORMAL_PREPASS)\r\n                .then_some(\"_normal\")\r\n                .unwrap_or_default(),\r\n            self.contains(Key::MOTION_VECTOR_PREPASS)\r\n                .then_some(\"_motion\")\r\n                .unwrap_or_default(),\r\n            self.contains(Key::DEFERRED_PREPASS)\r\n                .then_some(\"_deferred\")\r\n                .unwrap_or_default(),\r\n        )\r\n    }\r\n}\r\n\r\nimpl From<MeshPipelineKey> for MeshPipelineViewLayoutKey {\r\n    fn from(value: MeshPipelineKey) -> Self {\r\n        let mut result = MeshPipelineViewLayoutKey::empty();\r\n\r\n        if value.msaa_samples() > 1 {\r\n            result |= MeshPipelineViewLayoutKey::MULTISAMPLED;\r\n        }\r\n        if value.contains(MeshPipelineKey::DEPTH_PREPASS) {\r\n            result |= MeshPipelineViewLayoutKey::DEPTH_PREPASS;\r\n        }\r\n        if value.contains(MeshPipelineKey::NORMAL_PREPASS) {\r\n            result |= MeshPipelineViewLayoutKey::NORMAL_PREPASS;\r\n        }\r\n        if value.contains(MeshPipelineKey::MOTION_VECTOR_PREPASS) {\r\n            result |= MeshPipelineViewLayoutKey::MOTION_VECTOR_PREPASS;\r\n        }\r\n        if value.contains(MeshPipelineKey::DEFERRED_PREPASS) {\r\n            result |= MeshPipelineViewLayoutKey::DEFERRED_PREPASS;\r\n        }\r\n\r\n        result\r\n    }\r\n}\r\n\r\nimpl From<Msaa> for MeshPipelineViewLayoutKey {\r\n    fn from(value: Msaa) -> Self {\r\n        let mut result = MeshPipelineViewLayoutKey::empty();\r\n\r\n        if value.samples() > 1 {\r\n            result |= MeshPipelineViewLayoutKey::MULTISAMPLED;\r\n        }\r\n\r\n        result\r\n    }\r\n}\r\n\r\nimpl From<Option<&ViewPrepassTextures>> for MeshPipelineViewLayoutKey {\r\n    fn from(value: Option<&ViewPrepassTextures>) -> Self {\r\n        let mut result = MeshPipelineViewLayoutKey::empty();\r\n\r\n        if let Some(prepass_textures) = value {\r\n            if prepass_textures.depth.is_some() {\r\n                result |= MeshPipelineViewLayoutKey::DEPTH_PREPASS;\r\n            }\r\n            if prepass_textures.normal.is_some() {\r\n                result |= MeshPipelineViewLayoutKey::NORMAL_PREPASS;\r\n            }\r\n            if prepass_textures.motion_vectors.is_some() {\r\n                result |= MeshPipelineViewLayoutKey::MOTION_VECTOR_PREPASS;\r\n            }\r\n            if prepass_textures.deferred.is_some() {\r\n                result |= MeshPipelineViewLayoutKey::DEFERRED_PREPASS;\r\n            }\r\n        }\r\n\r\n        result\r\n    }\r\n}\r\n\r\nfn buffer_layout(\r\n    buffer_binding_type: BufferBindingType,\r\n    has_dynamic_offset: bool,\r\n    min_binding_size: Option<NonZeroU64>,\r\n) -> BindGroupLayoutEntryBuilder {\r\n    match buffer_binding_type {\r\n        BufferBindingType::Uniform => uniform_buffer_sized(has_dynamic_offset, min_binding_size),\r\n        BufferBindingType::Storage { read_only } => {\r\n            if read_only {\r\n                storage_buffer_read_only_sized(has_dynamic_offset, min_binding_size)\r\n            } else {\r\n                storage_buffer_sized(has_dynamic_offset, min_binding_size)\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/// Returns the appropriate bind group layout vec based on the parameters\r\nfn layout_entries(\r\n    clustered_forward_buffer_binding_type: BufferBindingType,\r\n    layout_key: MeshPipelineViewLayoutKey,\r\n    render_device: &RenderDevice,\r\n) -> Vec<BindGroupLayoutEntry> {\r\n    let mut entries = DynamicBindGroupLayoutEntries::new_with_indices(\r\n        ShaderStages::FRAGMENT,\r\n        (\r\n            // View\r\n            (\r\n                0,\r\n                uniform_buffer::<ViewUniform>(true).visibility(ShaderStages::VERTEX_FRAGMENT),\r\n            ),\r\n            // Lights\r\n            (1, uniform_buffer::<GpuLights>(true)),\r\n            // Point Shadow Texture Cube Array\r\n            (\r\n                2,\r\n                #[cfg(all(\r\n                    not(feature = \"ios_simulator\"),\r\n                    any(\r\n                        not(feature = \"webgl\"),\r\n                        not(target_arch = \"wasm32\"),\r\n                        feature = \"webgpu\"\r\n                    )\r\n                ))]\r\n                texture_cube_array(TextureSampleType::Depth),\r\n                #[cfg(any(\r\n                    feature = \"ios_simulator\",\r\n                    all(feature = \"webgl\", target_arch = \"wasm32\", not(feature = \"webgpu\"))\r\n                ))]\r\n                texture_cube(TextureSampleType::Depth),\r\n            ),\r\n            // Point Shadow Texture Array Sampler\r\n            (3, sampler(SamplerBindingType::Comparison)),\r\n            // Directional Shadow Texture Array\r\n            (\r\n                4,\r\n                #[cfg(any(\r\n                    not(feature = \"webgl\"),\r\n                    not(target_arch = \"wasm32\"),\r\n                    feature = \"webgpu\"\r\n                ))]\r\n                texture_2d_array(TextureSampleType::Depth),\r\n                #[cfg(all(feature = \"webgl\", target_arch = \"wasm32\", not(feature = \"webgpu\")))]\r\n                texture_2d(TextureSampleType::Depth),\r\n            ),\r\n            // Directional Shadow Texture Array Sampler\r\n            (5, sampler(SamplerBindingType::Comparison)),\r\n            // PointLights\r\n            (\r\n                6,\r\n                buffer_layout(\r\n                    clustered_forward_buffer_binding_type,\r\n                    false,\r\n                    Some(GpuPointLights::min_size(\r\n                        clustered_forward_buffer_binding_type,\r\n                    )),\r\n                ),\r\n            ),\r\n            // ClusteredLightIndexLists\r\n            (\r\n                7,\r\n                buffer_layout(\r\n                    clustered_forward_buffer_binding_type,\r\n                    false,\r\n                    Some(ViewClusterBindings::min_size_cluster_light_index_lists(\r\n                        clustered_forward_buffer_binding_type,\r\n                    )),\r\n                ),\r\n            ),\r\n            // ClusterOffsetsAndCounts\r\n            (\r\n                8,\r\n                buffer_layout(\r\n                    clustered_forward_buffer_binding_type,\r\n                    false,\r\n                    Some(ViewClusterBindings::min_size_cluster_offsets_and_counts(\r\n                        clustered_forward_buffer_binding_type,\r\n                    )),\r\n                ),\r\n            ),\r\n            // Globals\r\n            (\r\n                9,\r\n                uniform_buffer::<GlobalsUniform>(false).visibility(ShaderStages::VERTEX_FRAGMENT),\r\n            ),\r\n            // Fog\r\n            (10, uniform_buffer::<GpuFog>(true)),\r\n            // Light probes\r\n            (11, uniform_buffer::<LightProbesUniform>(true)),\r\n            // Screen space ambient occlusion texture\r\n            (\r\n                12,\r\n                texture_2d(TextureSampleType::Float { filterable: false }),\r\n            ),\r\n        ),\r\n    );\r\n\r\n    // EnvironmentMapLight\r\n    let environment_map_entries = environment_map::get_bind_group_layout_entries(render_device);\r\n    entries = entries.extend_with_indices((\r\n        (13, environment_map_entries[0]),\r\n        (14, environment_map_entries[1]),\r\n        (15, environment_map_entries[2]),\r\n    ));\r\n\r\n    // Irradiance volumes\r\n    if IRRADIANCE_VOLUMES_ARE_USABLE {\r\n        let irradiance_volume_entries =\r\n            irradiance_volume::get_bind_group_layout_entries(render_device);\r\n        entries = entries.extend_with_indices((\r\n            (16, irradiance_volume_entries[0]),\r\n            (17, irradiance_volume_entries[1]),\r\n        ));\r\n    }\r\n\r\n    // Tonemapping\r\n    let tonemapping_lut_entries = get_lut_bind_group_layout_entries();\r\n    entries = entries.extend_with_indices((\r\n        (18, tonemapping_lut_entries[0]),\r\n        (19, tonemapping_lut_entries[1]),\r\n    ));\r\n\r\n    // Prepass\r\n    if cfg!(any(not(feature = \"webgl\"), not(target_arch = \"wasm32\")))\r\n        || (cfg!(all(feature = \"webgl\", target_arch = \"wasm32\"))\r\n            && !layout_key.contains(MeshPipelineViewLayoutKey::MULTISAMPLED))\r\n    {\r\n        for (entry, binding) in prepass::get_bind_group_layout_entries(layout_key)\r\n            .iter()\r\n            .zip([20, 21, 22, 23])\r\n        {\r\n            if let Some(entry) = entry {\r\n                entries = entries.extend_with_indices(((binding as u32, *entry),));\r\n            }\r\n        }\r\n    }\r\n\r\n    // View Transmission Texture\r\n    entries = entries.extend_with_indices((\r\n        (\r\n            24,\r\n            texture_2d(TextureSampleType::Float { filterable: true }),\r\n        ),\r\n        (25, sampler(SamplerBindingType::Filtering)),\r\n    ));\r\n\r\n    entries.to_vec()\r\n}\r\n\r\n/// Generates all possible view layouts for the mesh pipeline, based on all combinations of\r\n/// [`MeshPipelineViewLayoutKey`] flags.\r\npub fn generate_view_layouts(\r\n    render_device: &RenderDevice,\r\n    clustered_forward_buffer_binding_type: BufferBindingType,\r\n) -> [MeshPipelineViewLayout; MeshPipelineViewLayoutKey::COUNT] {\r\n    array::from_fn(|i| {\r\n        let key = MeshPipelineViewLayoutKey::from_bits_truncate(i as u32);\r\n        let entries = layout_entries(clustered_forward_buffer_binding_type, key, render_device);\r\n\r\n        #[cfg(debug_assertions)]\r\n        let texture_count: usize = entries\r\n            .iter()\r\n            .filter(|entry| matches!(entry.ty, BindingType::Texture { .. }))\r\n            .count();\r\n\r\n        MeshPipelineViewLayout {\r\n            bind_group_layout: render_device\r\n                .create_bind_group_layout(key.label().as_str(), &entries),\r\n            #[cfg(debug_assertions)]\r\n            texture_count,\r\n        }\r\n    })\r\n}\r\n\r\n#[derive(Component)]\r\npub struct MeshViewBindGroup {\r\n    pub value: BindGroup,\r\n}\r\n\r\n#[allow(clippy::too_many_arguments)]\r\npub fn prepare_mesh_view_bind_groups(\r\n    mut commands: Commands,\r\n    render_device: Res<RenderDevice>,\r\n    mesh_pipeline: Res<MeshPipeline>,\r\n    shadow_samplers: Res<ShadowSamplers>,\r\n    light_meta: Res<LightMeta>,\r\n    global_light_meta: Res<GlobalLightMeta>,\r\n    fog_meta: Res<FogMeta>,\r\n    view_uniforms: Res<ViewUniforms>,\r\n    views: Query<(\r\n        Entity,\r\n        &ViewShadowBindings,\r\n        &ViewClusterBindings,\r\n        Option<&ScreenSpaceAmbientOcclusionTextures>,\r\n        Option<&ViewPrepassTextures>,\r\n        Option<&ViewTransmissionTexture>,\r\n        &Tonemapping,\r\n        Option<&RenderViewLightProbes<EnvironmentMapLight>>,\r\n        Option<&RenderViewLightProbes<IrradianceVolume>>,\r\n    )>,\r\n    (images, mut fallback_images, fallback_image, fallback_image_zero): (\r\n        Res<RenderAssets<Image>>,\r\n        FallbackImageMsaa,\r\n        Res<FallbackImage>,\r\n        Res<FallbackImageZero>,\r\n    ),\r\n    msaa: Res<Msaa>,\r\n    globals_buffer: Res<GlobalsBuffer>,\r\n    tonemapping_luts: Res<TonemappingLuts>,\r\n    light_probes_buffer: Res<LightProbesBuffer>,\r\n) {\r\n    if let (\r\n        Some(view_binding),\r\n        Some(light_binding),\r\n        Some(point_light_binding),\r\n        Some(globals),\r\n        Some(fog_binding),\r\n        Some(light_probes_binding),\r\n    ) = (\r\n        view_uniforms.uniforms.binding(),\r\n        light_meta.view_gpu_lights.binding(),\r\n        global_light_meta.gpu_point_lights.binding(),\r\n        globals_buffer.buffer.binding(),\r\n        fog_meta.gpu_fogs.binding(),\r\n        light_probes_buffer.binding(),\r\n    ) {\r\n        for (\r\n            entity,\r\n            shadow_bindings,\r\n            cluster_bindings,\r\n            ssao_textures,\r\n            prepass_textures,\r\n            transmission_texture,\r\n            tonemapping,\r\n            render_view_environment_maps,\r\n            render_view_irradiance_volumes,\r\n        ) in &views\r\n        {\r\n            let fallback_ssao = fallback_images\r\n                .image_for_samplecount(1, TextureFormat::bevy_default())\r\n                .texture_view\r\n                .clone();\r\n            let ssao_view = ssao_textures\r\n                .map(|t| &t.screen_space_ambient_occlusion_texture.default_view)\r\n                .unwrap_or(&fallback_ssao);\r\n\r\n            let layout = &mesh_pipeline.get_view_layout(\r\n                MeshPipelineViewLayoutKey::from(*msaa)\r\n                    | MeshPipelineViewLayoutKey::from(prepass_textures),\r\n            );\r\n\r\n            let mut entries = DynamicBindGroupEntries::new_with_indices((\r\n                (0, view_binding.clone()),\r\n                (1, light_binding.clone()),\r\n                (2, &shadow_bindings.point_light_depth_texture_view),\r\n                (3, &shadow_samplers.point_light_sampler),\r\n                (4, &shadow_bindings.directional_light_depth_texture_view),\r\n                (5, &shadow_samplers.directional_light_sampler),\r\n                (6, point_light_binding.clone()),\r\n                (7, cluster_bindings.light_index_lists_binding().unwrap()),\r\n                (8, cluster_bindings.offsets_and_counts_binding().unwrap()),\r\n                (9, globals.clone()),\r\n                (10, fog_binding.clone()),\r\n                (11, light_probes_binding.clone()),\r\n                (12, ssao_view),\r\n            ));\r\n\r\n            let environment_map_bind_group_entries = RenderViewEnvironmentMapBindGroupEntries::get(\r\n                render_view_environment_maps,\r\n                &images,\r\n                &fallback_image,\r\n                &render_device,\r\n            );\r\n\r\n            match environment_map_bind_group_entries {\r\n                RenderViewEnvironmentMapBindGroupEntries::Single {\r\n                    diffuse_texture_view,\r\n                    specular_texture_view,\r\n                    sampler,\r\n                } => {\r\n                    entries = entries.extend_with_indices((\r\n                        (13, diffuse_texture_view),\r\n                        (14, specular_texture_view),\r\n                        (15, sampler),\r\n                    ));\r\n                }\r\n                RenderViewEnvironmentMapBindGroupEntries::Multiple {\r\n                    ref diffuse_texture_views,\r\n                    ref specular_texture_views,\r\n                    sampler,\r\n                } => {\r\n                    entries = entries.extend_with_indices((\r\n                        (13, diffuse_texture_views.as_slice()),\r\n                        (14, specular_texture_views.as_slice()),\r\n                        (15, sampler),\r\n                    ));\r\n                }\r\n            }\r\n\r\n            let irradiance_volume_bind_group_entries = if IRRADIANCE_VOLUMES_ARE_USABLE {\r\n                Some(RenderViewIrradianceVolumeBindGroupEntries::get(\r\n                    render_view_irradiance_volumes,\r\n                    &images,\r\n                    &fallback_image,\r\n                    &render_device,\r\n                ))\r\n            } else {\r\n                None\r\n            };\r\n\r\n            match irradiance_volume_bind_group_entries {\r\n                Some(RenderViewIrradianceVolumeBindGroupEntries::Single {\r\n                    texture_view,\r\n                    sampler,\r\n                }) => {\r\n                    entries = entries.extend_with_indices(((16, texture_view), (17, sampler)));\r\n                }\r\n                Some(RenderViewIrradianceVolumeBindGroupEntries::Multiple {\r\n                    ref texture_views,\r\n                    sampler,\r\n                }) => {\r\n                    entries = entries\r\n                        .extend_with_indices(((16, texture_views.as_slice()), (17, sampler)));\r\n                }\r\n                None => {}\r\n            }\r\n\r\n            let lut_bindings = get_lut_bindings(&images, &tonemapping_luts, tonemapping);\r\n            entries = entries.extend_with_indices(((18, lut_bindings.0), (19, lut_bindings.1)));\r\n\r\n            // When using WebGL, we can't have a depth texture with multisampling\r\n            let prepass_bindings;\r\n            if cfg!(any(not(feature = \"webgl\"), not(target_arch = \"wasm32\"))) || msaa.samples() == 1\r\n            {\r\n                prepass_bindings = prepass::get_bindings(prepass_textures);\r\n                for (binding, index) in prepass_bindings\r\n                    .iter()\r\n                    .map(Option::as_ref)\r\n                    .zip([20, 21, 22, 23])\r\n                    .flat_map(|(b, i)| b.map(|b| (b, i)))\r\n                {\r\n                    entries = entries.extend_with_indices(((index, binding),));\r\n                }\r\n            };\r\n\r\n            let transmission_view = transmission_texture\r\n                .map(|transmission| &transmission.view)\r\n                .unwrap_or(&fallback_image_zero.texture_view);\r\n\r\n            let transmission_sampler = transmission_texture\r\n                .map(|transmission| &transmission.sampler)\r\n                .unwrap_or(&fallback_image_zero.sampler);\r\n\r\n            entries =\r\n                entries.extend_with_indices(((24, transmission_view), (25, transmission_sampler)));\r\n\r\n            commands.entity(entity).insert(MeshViewBindGroup {\r\n                value: render_device.create_bind_group(\"mesh_view_bind_group\", layout, &entries),\r\n            });\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\bevy\\crates\\bevy_ecs_compile_fail_tests\\tests\\ui\\world_query_derive.rs\r\n\r\n````rust\r\nuse bevy_ecs::prelude::*;\r\nuse bevy_ecs::query::QueryData;\r\n\r\n#[derive(Component)]\r\nstruct Foo;\r\n\r\n#[derive(QueryData)]\r\nstruct MutableUnmarked {\r\n    a: &'static mut Foo,\r\n}\r\n\r\n#[derive(QueryData)]\r\n#[query_data(mutable)]\r\nstruct MutableMarked {\r\n    a: &'static mut Foo,\r\n}\r\n\r\n#[derive(QueryData)]\r\nstruct NestedMutableUnmarked {\r\n    a: MutableMarked,\r\n}\r\n\r\nfn main() {}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Games\\bevy\\crates\\bevy_winit\\src\\system.rs\r\n\r\n````rust\r\nuse bevy_ecs::{\r\n    entity::Entity,\r\n    event::EventWriter,\r\n    prelude::{Changed, Component},\r\n    query::QueryFilter,\r\n    removal_detection::RemovedComponents,\r\n    system::{NonSendMut, Query, SystemParamItem},\r\n};\r\nuse bevy_utils::tracing::{error, info, warn};\r\nuse bevy_window::{\r\n    RawHandleWrapper, Window, WindowClosed, WindowCreated, WindowMode, WindowResized,\r\n};\r\n\r\nuse raw_window_handle::{HasDisplayHandle, HasWindowHandle};\r\nuse winit::{\r\n    dpi::{LogicalPosition, LogicalSize, PhysicalPosition, PhysicalSize},\r\n    event_loop::EventLoopWindowTarget,\r\n};\r\n\r\n#[cfg(target_arch = \"wasm32\")]\r\nuse winit::platform::web::WindowExtWebSys;\r\n\r\nuse crate::{\r\n    converters::{\r\n        self, convert_enabled_buttons, convert_window_level, convert_window_theme,\r\n        convert_winit_theme,\r\n    },\r\n    get_best_videomode, get_fitting_videomode, CreateWindowParams, WinitWindows,\r\n};\r\n\r\n/// Creates new windows on the [`winit`] backend for each entity with a newly-added\r\n/// [`Window`] component.\r\n///\r\n/// If any of these entities are missing required components, those will be added with their\r\n/// default values.\r\n#[allow(clippy::too_many_arguments)]\r\npub fn create_windows<F: QueryFilter + 'static>(\r\n    event_loop: &EventLoopWindowTarget<crate::UserEvent>,\r\n    (\r\n        mut commands,\r\n        mut created_windows,\r\n        mut window_created_events,\r\n        mut winit_windows,\r\n        mut adapters,\r\n        mut handlers,\r\n        accessibility_requested,\r\n    ): SystemParamItem<CreateWindowParams<F>>,\r\n) {\r\n    for (entity, mut window) in &mut created_windows {\r\n        if winit_windows.get_window(entity).is_some() {\r\n            continue;\r\n        }\r\n\r\n        info!(\r\n            \"Creating new window {:?} ({:?})\",\r\n            window.title.as_str(),\r\n            entity\r\n        );\r\n\r\n        let winit_window = winit_windows.create_window(\r\n            event_loop,\r\n            entity,\r\n            &window,\r\n            &mut adapters,\r\n            &mut handlers,\r\n            &accessibility_requested,\r\n        );\r\n\r\n        if let Some(theme) = winit_window.theme() {\r\n            window.window_theme = Some(convert_winit_theme(theme));\r\n        }\r\n\r\n        window\r\n            .resolution\r\n            .set_scale_factor(winit_window.scale_factor() as f32);\r\n        commands\r\n            .entity(entity)\r\n            .insert(RawHandleWrapper {\r\n                window_handle: winit_window.window_handle().unwrap().as_raw(),\r\n                display_handle: winit_window.display_handle().unwrap().as_raw(),\r\n            })\r\n            .insert(CachedWindow {\r\n                window: window.clone(),\r\n            });\r\n\r\n        #[cfg(target_arch = \"wasm32\")]\r\n        {\r\n            if window.fit_canvas_to_parent {\r\n                let canvas = winit_window\r\n                    .canvas()\r\n                    .expect(\"window.canvas() can only be called in main thread.\");\r\n                let style = canvas.style();\r\n                style.set_property(\"width\", \"100%\").unwrap();\r\n                style.set_property(\"height\", \"100%\").unwrap();\r\n            }\r\n        }\r\n        window_created_events.send(WindowCreated { window: entity });\r\n    }\r\n}\r\n\r\npub(crate) fn despawn_windows(\r\n    mut closed: RemovedComponents<Window>,\r\n    window_entities: Query<&Window>,\r\n    mut close_events: EventWriter<WindowClosed>,\r\n    mut winit_windows: NonSendMut<WinitWindows>,\r\n) {\r\n    for window in closed.read() {\r\n        info!(\"Closing window {:?}\", window);\r\n        // Guard to verify that the window is in fact actually gone,\r\n        // rather than having the component added and removed in the same frame.\r\n        if !window_entities.contains(window) {\r\n            winit_windows.remove_window(window);\r\n            close_events.send(WindowClosed { window });\r\n        }\r\n    }\r\n}\r\n\r\n/// The cached state of the window so we can check which properties were changed from within the app.\r\n#[derive(Debug, Clone, Component)]\r\npub struct CachedWindow {\r\n    pub window: Window,\r\n}\r\n\r\n/// Propagates changes from [`Window`] entities to the [`winit`] backend.\r\n///\r\n/// # Notes\r\n///\r\n/// - [`Window::present_mode`] and [`Window::composite_alpha_mode`] changes are handled by the `bevy_render` crate.\r\n/// - [`Window::transparent`] cannot be changed after the window is created.\r\n/// - [`Window::canvas`] cannot be changed after the window is created.\r\n/// - [`Window::focused`] cannot be manually changed to `false` after the window is created.\r\npub(crate) fn changed_windows(\r\n    mut changed_windows: Query<(Entity, &mut Window, &mut CachedWindow), Changed<Window>>,\r\n    winit_windows: NonSendMut<WinitWindows>,\r\n    mut window_resized: EventWriter<WindowResized>,\r\n) {\r\n    for (entity, mut window, mut cache) in &mut changed_windows {\r\n        let Some(winit_window) = winit_windows.get_window(entity) else {\r\n            continue;\r\n        };\r\n\r\n        if window.title != cache.window.title {\r\n            winit_window.set_title(window.title.as_str());\r\n        }\r\n\r\n        if window.mode != cache.window.mode {\r\n            let new_mode = match window.mode {\r\n                WindowMode::BorderlessFullscreen => {\r\n                    Some(Some(winit::window::Fullscreen::Borderless(None)))\r\n                }\r\n                mode @ (WindowMode::Fullscreen | WindowMode::SizedFullscreen) => {\r\n                    if let Some(current_monitor) = winit_window.current_monitor() {\r\n                        let videomode = match mode {\r\n                            WindowMode::Fullscreen => get_best_videomode(&current_monitor),\r\n                            WindowMode::SizedFullscreen => get_fitting_videomode(\r\n                                &current_monitor,\r\n                                window.width() as u32,\r\n                                window.height() as u32,\r\n                            ),\r\n                            _ => unreachable!(),\r\n                        };\r\n\r\n                        Some(Some(winit::window::Fullscreen::Exclusive(videomode)))\r\n                    } else {\r\n                        warn!(\"Could not determine current monitor, ignoring exclusive fullscreen request for window {:?}\", window.title);\r\n                        None\r\n                    }\r\n                }\r\n                WindowMode::Windowed => Some(None),\r\n            };\r\n\r\n            if let Some(new_mode) = new_mode {\r\n                if winit_window.fullscreen() != new_mode {\r\n                    winit_window.set_fullscreen(new_mode);\r\n                }\r\n            }\r\n        }\r\n        if window.resolution != cache.window.resolution {\r\n            let physical_size = PhysicalSize::new(\r\n                window.resolution.physical_width(),\r\n                window.resolution.physical_height(),\r\n            );\r\n            if let Some(size_now) = winit_window.request_inner_size(physical_size) {\r\n                crate::react_to_resize(&mut window, size_now, &mut window_resized, entity);\r\n            }\r\n        }\r\n\r\n        if window.physical_cursor_position() != cache.window.physical_cursor_position() {\r\n            if let Some(physical_position) = window.physical_cursor_position() {\r\n                let position = PhysicalPosition::new(physical_position.x, physical_position.y);\r\n\r\n                if let Err(err) = winit_window.set_cursor_position(position) {\r\n                    error!(\"could not set cursor position: {:?}\", err);\r\n                }\r\n            }\r\n        }\r\n\r\n        if window.cursor.icon != cache.window.cursor.icon {\r\n            winit_window.set_cursor_icon(converters::convert_cursor_icon(window.cursor.icon));\r\n        }\r\n\r\n        if window.cursor.grab_mode != cache.window.cursor.grab_mode {\r\n            crate::winit_windows::attempt_grab(winit_window, window.cursor.grab_mode);\r\n        }\r\n\r\n        if window.cursor.visible != cache.window.cursor.visible {\r\n            winit_window.set_cursor_visible(window.cursor.visible);\r\n        }\r\n\r\n        if window.cursor.hit_test != cache.window.cursor.hit_test {\r\n            if let Err(err) = winit_window.set_cursor_hittest(window.cursor.hit_test) {\r\n                window.cursor.hit_test = cache.window.cursor.hit_test;\r\n                warn!(\r\n                    \"Could not set cursor hit test for window {:?}: {:?}\",\r\n                    window.title, err\r\n                );\r\n            }\r\n        }\r\n\r\n        if window.decorations != cache.window.decorations\r\n            && window.decorations != winit_window.is_decorated()\r\n        {\r\n            winit_window.set_decorations(window.decorations);\r\n        }\r\n\r\n        if window.resizable != cache.window.resizable\r\n            && window.resizable != winit_window.is_resizable()\r\n        {\r\n            winit_window.set_resizable(window.resizable);\r\n        }\r\n\r\n        if window.enabled_buttons != cache.window.enabled_buttons {\r\n            winit_window.set_enabled_buttons(convert_enabled_buttons(window.enabled_buttons));\r\n        }\r\n\r\n        if window.resize_constraints != cache.window.resize_constraints {\r\n            let constraints = window.resize_constraints.check_constraints();\r\n            let min_inner_size = LogicalSize {\r\n                width: constraints.min_width,\r\n                height: constraints.min_height,\r\n            };\r\n            let max_inner_size = LogicalSize {\r\n                width: constraints.max_width,\r\n                height: constraints.max_height,\r\n            };\r\n\r\n            winit_window.set_min_inner_size(Some(min_inner_size));\r\n            if constraints.max_width.is_finite() && constraints.max_height.is_finite() {\r\n                winit_window.set_max_inner_size(Some(max_inner_size));\r\n            }\r\n        }\r\n\r\n        if window.position != cache.window.position {\r\n            if let Some(position) = crate::winit_window_position(\r\n                &window.position,\r\n                &window.resolution,\r\n                winit_window.available_monitors(),\r\n                winit_window.primary_monitor(),\r\n                winit_window.current_monitor(),\r\n            ) {\r\n                let should_set = match winit_window.outer_position() {\r\n                    Ok(current_position) => current_position != position,\r\n                    _ => true,\r\n                };\r\n\r\n                if should_set {\r\n                    winit_window.set_outer_position(position);\r\n                }\r\n            }\r\n        }\r\n\r\n        if let Some(maximized) = window.internal.take_maximize_request() {\r\n            winit_window.set_maximized(maximized);\r\n        }\r\n\r\n        if let Some(minimized) = window.internal.take_minimize_request() {\r\n            winit_window.set_minimized(minimized);\r\n        }\r\n\r\n        if window.focused != cache.window.focused && window.focused {\r\n            winit_window.focus_window();\r\n        }\r\n\r\n        if window.window_level != cache.window.window_level {\r\n            winit_window.set_window_level(convert_window_level(window.window_level));\r\n        }\r\n\r\n        // Currently unsupported changes\r\n        if window.transparent != cache.window.transparent {\r\n            window.transparent = cache.window.transparent;\r\n            warn!(\"Winit does not currently support updating transparency after window creation.\");\r\n        }\r\n\r\n        #[cfg(target_arch = \"wasm32\")]\r\n        if window.canvas != cache.window.canvas {\r\n            window.canvas = cache.window.canvas.clone();\r\n            warn!(\r\n                \"Bevy currently doesn't support modifying the window canvas after initialization.\"\r\n            );\r\n        }\r\n\r\n        if window.ime_enabled != cache.window.ime_enabled {\r\n            winit_window.set_ime_allowed(window.ime_enabled);\r\n        }\r\n\r\n        if window.ime_position != cache.window.ime_position {\r\n            winit_window.set_ime_cursor_area(\r\n                LogicalPosition::new(window.ime_position.x, window.ime_position.y),\r\n                PhysicalSize::new(10, 10),\r\n            );\r\n        }\r\n\r\n        if window.window_theme != cache.window.window_theme {\r\n            winit_window.set_theme(window.window_theme.map(convert_window_theme));\r\n        }\r\n\r\n        if window.visible != cache.window.visible {\r\n            winit_window.set_visible(window.visible);\r\n        }\r\n\r\n        cache.window = window.clone();\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\nWhen minimized, my Bevy game spams the logs with\r\n\r\n2024-04-03T20:11:34.646700Z  WARN log: Requested size 1x1 is outside of the supported range: Extent3d { width: 0, height: 0, depth_or_array_layers: 1 }..=Extent3d { width: 0, height: 0, depth_or_array_layers: 1 }\r\n2024-04-03T20:11:34.668761Z  WARN log: Requested size 1x1 is outside of the supported range: Extent3d { width: 0, height: 0, depth_or_array_layers: 1 }..=Extent3d { width: 0, height: 0, depth_or_array_layers: 1 }\r\n2024-04-03T20:11:34.691634Z  WARN log: Requested size 1x1 is outside of the supported range: Extent3d { width: 0, height: 0, depth_or_array_layers: 1 }..=Extent3d { width: 0, height: 0, depth_or_array_layers: 1 }\r\n2024-04-03T20:11:34.720110Z  WARN log: Requested size 1x1 is outside of the supported range: Extent3d { width: 0, height: 0, depth_or_array_layers: 1 }..=Extent3d { width: 0, height: 0, depth_or_array_layers: 1 }\r\n2024-04-03T20:11:34.741235Z  WARN log: Requested size 1x1 is outside of the supported range: Extent3d { width: 0, height: 0, depth_or_array_layers: 1 }..=Extent3d { width: 0, height: 0, depth_or_array_layers: 1 }\r\n2024-04-03T20:11:34.768480Z  WARN log: Requested size 1x1 is outside of the supported range: Extent3d { width: 0, height: 0, depth_or_array_layers: 1 }..=Extent3d { width: 0, height: 0, depth_or_array_layers: 1 }\r\n2024-04-03T20:11:34.790977Z  WARN log: Requested size 1x1 is outside of the supported range: Extent3d { width: 0, height: 0, depth_or_array_layers: 1 }..=Extent3d { width: 0, height: 0, depth_or_array_layers: 1 }\r\n2024-04-03T20:11:34.812517Z  WARN log: Requested size 1x1 is outside of the supported range: Extent3d { width: 0, height: 0, depth_or_array_layers: 1 }..=Extent3d { width: 0, height: 0, depth_or_array_layers: 1 }\r\n2024-04-03T20:11:34.843047Z  WARN log: Requested size 1x1 is outside of the supported range: Extent3d { width: 0, height: 0, depth_or_array_layers: 1 }..=Extent3d { width: 0, height: 0, depth_or_array_layers: 1 }\r\n\r\n\r\nwhen resizing the window, it also complains\r\n\r\n2024-04-03T20:11:57.020117Z  WARN log: Requested size 1171x722 is outside of the supported range: Extent3d { width: 1151, height: 698, depth_or_array_layers: 1 }..=Extent3d { width: 1151, height: 698, depth_or_array_layers: 1 }\r\n2024-04-03T20:11:57.059909Z  WARN log: Requested size 1151x698 is outside of the supported range: Extent3d { width: 1103, height: 656, depth_or_array_layers: 1 }..=Extent3d { width: 1103, height: 656, depth_or_array_layers: 1 }\r\n2024-04-03T20:11:57.111997Z  WARN log: Requested size 1103x656 is outside of the supported range: Extent3d { width: 1040, height: 606, depth_or_array_layers: 1 }..=Extent3d { width: 1040, height: 606, depth_or_array_layers: 1 }\r\n2024-04-03T20:11:57.144875Z  WARN log: Requested size 1040x606 is outside of the supported range: Extent3d { width: 1008, height: 579, depth_or_array_layers: 1 }..=Extent3d { width: 1008, height: 579, depth_or_array_layers: 1 }\r\n2024-04-03T20:11:57.203423Z  WARN log: Requested size 1008x579 is outside of the supported range: Extent3d { width: 988, height: 556, depth_or_array_layers: 1 }..=Extent3d { width: 988, height: 556, depth_or_array_layers: 1 }\r\n2024-04-03T20:11:57.234837Z  WARN log: Requested size 988x556 is outside of the supported range: Extent3d { width: 983, height: 550, depth_or_array_layers: 1 }..=Extent3d { width: 983, height: 550, depth_or_array_layers: 1 }\r\n2024-04-03T20:11:57.273270Z  WARN log: Requested size 983x550 is outside of the supported range: Extent3d { width: 978, height: 544, depth_or_array_layers: 1 }..=Extent3d { width: 978, height: 544, depth_or_array_layers: 1 }\r\n2024-04-03T20:11:57.315373Z  WARN log: Requested size 978x544 is outside of the supported range: Extent3d { width: 972, height: 538, depth_or_array_layers: 1 }..=Extent3d { width: 972, height: 538, depth_or_array_layers: 1 }\r\n2024-04-03T20:11:57.343810Z  WARN log: Requested size 972x538 is outside of the supported range: Extent3d { width: 971, height: 536, depth_or_array_layers: 1 }..=Extent3d { width: 971, height: 536, depth_or_array_layers: 1 }\r\n2024-04-03T20:11:57.398545Z  WARN log: Requested size 971x536 is outside of the supported range: Extent3d { width: 970, height: 534, depth_or_array_layers: 1 }..=Extent3d { width: 970, height: 534, depth_or_array_layers: 1 }\r\n\r\n\r\nPlease analyze the Bevy source code and identify a remedy.\r\n",
        "files": []
    },
    "response": {
        "candidates": [
            {
                "content": {
                    "parts": [
                        {
                            "text": "## Analysis of Bevy Source Code and Remedy for Window Resize Spam\n\nThe log spam you're experiencing when minimizing and resizing your Bevy game is caused by a known issue in the `bevy_winit` plugin, specifically in the `prepare_windows` system. This system is responsible for configuring the window surface and obtaining a swapchain texture for rendering. \n\nHere's the breakdown of the issue and potential remedies:\n\n**Problem:**\n\n1. **Minimum Size Issue:** When a window is minimized, its physical size becomes very small (often 1x1). This triggers the `prepare_windows` system to attempt to configure the surface with this small size. However, the `wgpu` backend often has minimum size requirements for textures, leading to the \"Requested size is outside of the supported range\" warning.\n2. **Resize Spam:** During resize, the `prepare_windows` system attempts to configure the surface with the requested size on every frame until it fits within the supported range. This leads to repeated warnings in the log for every frame it takes to resize the window.\n\n**Potential Remedies:**\n\n1. **Minimum Size:**\n    * **Ignore Minimized Size:** One solution is to modify the `prepare_windows` system to ignore resize events when the window is minimized. This can be achieved by checking the window's state and skipping the configuration if it's minimized.\n    * **Set Minimum Size:** Another option is to set a reasonable minimum size for the window using the `WindowResizeConstraints` component. This ensures the requested size never goes below the supported range.\n2. **Resize Spam:**\n    * **Debounce Resize Events:** Instead of configuring the surface every frame during resize, implement a debounce mechanism. This would trigger the configuration only after a certain time has passed since the last resize event, reducing the log spam.\n    * **Log Once:** Modify the `prepare_windows` system to log the warning message only once when the requested size is outside the supported range, instead of logging it every frame.\n\n**Implementation:**\n\nThe specific implementation will depend on your preferred approach. Here's an example of how you could modify the `prepare_windows` system to ignore minimized size:\n\n```rust\nfn prepare_windows(...) {\n    ...\n    for window in windows.windows.values_mut() {\n        ...\n        if window.mode != WindowMode::Minimized {\n            // Configure the surface only if the window is not minimized\n            ...\n        }\n    }\n}\n```\n\nRemember to test your changes thoroughly and ensure they don't introduce new issues. \n\n**Additional Notes:**\n\n* This issue is actively being discussed and worked on within the Bevy community. You can follow the progress and contribute to the discussion on the Bevy GitHub repository: https://github.com/bevyengine/bevy/issues/7194\n* Consider using a logging library that allows filtering messages by severity level. This way, you can suppress the warning messages while still keeping track of other important logs.\n"
                        }
                    ],
                    "role": "model"
                },
                "finishReason": "STOP",
                "index": 0,
                "safetyRatings": [
                    {
                        "category": "HARM_CATEGORY_SEXUALLY_EXPLICIT",
                        "probability": "NEGLIGIBLE"
                    },
                    {
                        "category": "HARM_CATEGORY_HATE_SPEECH",
                        "probability": "NEGLIGIBLE"
                    },
                    {
                        "category": "HARM_CATEGORY_HARASSMENT",
                        "probability": "NEGLIGIBLE"
                    },
                    {
                        "category": "HARM_CATEGORY_DANGEROUS_CONTENT",
                        "probability": "NEGLIGIBLE"
                    }
                ]
            }
        ]
    }
}