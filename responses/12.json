{
    "response": {
        "candidates": [
            {
                "content": {
                    "parts": [
                        {
                            "text": "## Horobi Transcript Utility - ChatGPT - Revamped\n\nThis document outlines the revamped structure and functionality of the Horobi Transcript Utility for ChatGPT, focusing on modularity and improved organization.\n\n### Dependencies\n\nEnsure the following commands are available for full functionality:\n\n- `pwsh`\n- `fzf`\n- `hx`\n- `sqlite3` (optional, for directory suggestions)\n- `zoxide` (optional, for directory suggestions)\n- `rg` (optional, for directory suggestions)\n- `eza` (optional, for directory suggestions)\n\n### Structure\n\nThe new structure will consist of an entry point script (`main.ps1`) and individual action scripts within an `actions` folder. \n\n### Actions\n\nHere's a breakdown of the actions and their functionalities:\n\n#### 1. Set API Key\n\n**Outline:**\n\n1. **Input:**\n    - Read API key from clipboard or prompt user for manual input.\n2. **Processing:**\n    - Extract the bearer token from the API key.\n    - Set the `GEMINI_API_KEY` environment variable with the extracted token.\n3. **Outcome:**\n    - The `GEMINI_API_KEY` environment variable is set for subsequent actions.\n\n**Implementation (`actions/Set API Key.ps1`):**\n\n```powershell\n# Choose input method\n$choice = fzf --prompt \"Choose input method: \" --header \"Set API Key\" --options \"Clipboard\", \"Manual\"\n\nif ($choice -eq \"Clipboard\") {\n  $apiKey = Get-Clipboard\n} else {\n  Write-Host -NoNewLine \"Enter the API key: \"\n  $apiKey = Read-Host -AsSecureString\n  # Convert SecureString to plain text\n  $ptr = [Runtime.InteropServices.Marshal]::SecureStringToBSTR($apiKey)\n  try {\n    $apiKey = [Runtime.InteropServices.Marshal]::PtrToStringBSTR($ptr)\n  } finally {\n    [Runtime.InteropServices.Marshal]::ZeroFreeBSTR($ptr)\n  }\n}\n\n# Extract bearer token\n$bearerToken = $apiKey -replace '.*Bearer (.*)', '$1'\n\n# Set environment variable\n$env:GEMINI_API_KEY = $bearerToken\n\nWrite-Host \"API Key set as environment variable.\"\n```\n\n#### 2. Expand Backup to Conversations\n\n**Outline:**\n\n1. **Input:**\n    - List available zip files in the backup folder.\n    - Allow user to select a specific zip file.\n2. **Processing:**\n    - Ensure the selected zip file is downloaded locally (if stored on OneDrive).\n    - Extract conversations from the zip file to the `conversations\\yyyy\\mm\\dd` structure.\n3. **Outcome:**\n    - Conversations are extracted and organized by date.\n\n**Implementation (`actions/Expand Backup.ps1`):**\n\n```powershell\n# List zip files in backup folder\n$zipFiles = Get-ChildItem -Path \"backups\" -Filter \"*.zip\"\n\n# Allow user to select a zip file\n$chosenZip = $zipFiles | fzf --prompt \"Select backup zip: \" --header \"Available Backups\"\n\n# Ensure file is downloaded locally\nif ($(attrib $chosenZip.FullName).split() -contains \"O\") {\n  Write-Host \"Downloading $chosenZip...\"\n  attrib +p $chosenZip.FullName\n  Start-Sleep -Seconds 10\n  attrib -p $chosenZip.FullName\n}\n\n# Extract conversations\nAdd-Type -AssemblyName System.IO.Compression.FileSystem\n$zip = [System.IO.Compression.ZipFile]::OpenRead($chosenZip.FullName)\nforeach ($entry in $zip.Entries) {\n  $targetPath = Join-Path \"conversations\" -ChildPath $entry.Name\n  $targetDir = Split-Path $targetPath -Parent\n  New-Item -ItemType Directory -Path $targetDir -Force | Out-Null\n  $entry.ExtractToDirectory($targetPath)\n}\n$zip.Dispose()\n\nWrite-Host \"Conversations extracted to 'conversations' folder.\"\n```\n\n#### 3. Download Conversations\n\n**Outline:**\n\n1. **Pre-conditions:**\n    - Check if the `conversations` folder exists and is not empty.\n    - Check if the `GEMINI_API_KEY` environment variable is set.\n2. **Input:**\n    - Fetch the list of conversations from the website.\n3. **Processing:**\n    - Identify conversations to be downloaded based on update time (newer than last backup or not present locally).\n    - Download the identified conversations and store them in the `conversations\\yyyy\\mm\\dd` structure.\n4. **Outcome:**\n    - New or updated conversations are downloaded and organized by date.\n\n**Implementation (`actions/Download Conversations.ps1`):**\n\n```powershell\n# Check pre-conditions\nif (-not (Test-Path \"conversations\")) {\n  Write-Error \"Run 'Expand Backup' action first.\"\n  return\n}\n\nif (-not (Test-Path Env:GEMINI_API_KEY)) {\n  Write-Error \"Set API key first.\"\n  return\n}\n\n# Fetch conversation list from website\n# (Implementation using API calls and update time comparison)\n\n# Identify conversations to download\n\n# Download conversations and store them in the appropriate folders\n```\n\n#### 4. Search Conversations\n\n**Outline:**\n\n1. **Input:**\n    - Use `fzf` to allow the user to enter a search query.\n2. **Processing:**\n    - Use `ripgrep` to search for the query within the conversation files.\n    - Use `fzf` to display the search results interactively.\n3. **Outcome:**\n    - The user can easily search and navigate through their ChatGPT conversations.\n\n**Implementation (`actions/Search Conversations.ps1`):**\n\n```powershell\n# Get search query from user\n$query = fzf --prompt \"Enter search query: \"\n\n# Search conversations using ripgrep\n$results = rg $query \"conversations\" --column --line-number --no-heading --color=always --smart-case\n\n# Display results with fzf\n$results | fzf --ansi --preview 'bat --color=always {1} --highlight-line {2}' --preview-window 'up,60%,border-bottom,+{2}+3/3,~3'\n```\n\n### Updating the Repository\n\nTo update the Horobi repository to this new structure:\n\n1. Create a new `actions` folder.\n2. Move the existing scripts into the `actions` folder and rename them according to their functionalities.\n3. Create a new `main.ps1` script that will serve as the entry point.\n4. In `main.ps1`, enumerate the action scripts and provide a menu for the user to choose and execute actions.\n\nThis new structure will improve organization, maintainability, and clarity of the Horobi Transcript Utility.\n"
                        }
                    ],
                    "role": "model"
                },
                "finishReason": "STOP",
                "index": 0,
                "safetyRatings": [
                    {
                        "category": "HARM_CATEGORY_SEXUALLY_EXPLICIT",
                        "probability": "NEGLIGIBLE"
                    },
                    {
                        "category": "HARM_CATEGORY_HATE_SPEECH",
                        "probability": "NEGLIGIBLE"
                    },
                    {
                        "category": "HARM_CATEGORY_HARASSMENT",
                        "probability": "NEGLIGIBLE"
                    },
                    {
                        "category": "HARM_CATEGORY_DANGEROUS_CONTENT",
                        "probability": "NEGLIGIBLE"
                    }
                ]
            }
        ]
    },
    "prompt": "# Summary\r\n\r\n\r\n## D:\\Repos\\Experiments\\horobi-transcript-utility\\chatgpt\\expand_backup_conversations.ps1\r\n\r\n````powershell\r\n$convos = Get-Content .\\outputs\\backup-conversations.json | ConvertFrom-Json\r\nNew-Item -ItemType Directory -Path .\\outputs\\conversations -ErrorAction SilentlyContinue | Out-Null\r\n$i = 0\r\nforeach ($convo in $convos) {\r\n    # progress bar\r\n    $i++\r\n    Write-Progress -Activity \"Expanding conversations\" -Status \"Conversations expanded: $i\" -PercentComplete (($i / $convos.Count) * 100)\r\n    $convo_id = $convo.id\r\n    $convo | ConvertTo-Json -Depth 100 | Out-File -FilePath \".\\outputs\\conversations\\$convo_id.json\"\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Experiments\\horobi-transcript-utility\\chatgpt\\get_backup_conversations.ps1\r\n\r\n````powershell\r\n. .\\get_latest_backup.ps1\r\n$found = Get-Backup\r\n\r\nNew-Item -ItemType Directory -Path \"outputs\" -ErrorAction SilentlyContinue\r\n\r\nAdd-Type -AssemblyName System.IO.Compression.FileSystem\r\nAdd-Type -AssemblyName System.IO.Compression\r\n\r\n$zipFilePath = $found.FullName\r\n\r\n# Open the zip file\r\n$zipStream = [System.IO.File]::OpenRead($zipFilePath)\r\n$zipArchive = New-Object System.IO.Compression.ZipArchive($zipStream)\r\n\r\n# Iterate through each file in the zip\r\nforeach ($entry in $zipArchive.Entries) {\r\n    Write-Host \"Entry: $($entry.FullName)\"\r\n\r\n    # If you want to perform operations on each file, you can open a stream\r\n    # For example, to read the content of a file:\r\n    if (!$entry.FullName.EndsWith(\"/\")) { # This checks if the entry is a file\r\n        if ($entry.FullName -eq \"conversations.json\") {\r\n            $reader = New-Object System.IO.StreamReader($entry.Open())\r\n            $content = $reader.ReadToEnd()\r\n            # pretty print\r\n            Set-Content -Path \"outputs\\backup-conversations.json\" -Value $($content | ConvertFrom-Json | ConvertTo-Json -Depth 100)\r\n            $reader.Close()\r\n        }\r\n    }\r\n}\r\n\r\n# Clean up\r\n$zipArchive.Dispose()\r\n$zipStream.Close()\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Experiments\\horobi-transcript-utility\\chatgpt\\pull_convo_contents.ps1\r\n\r\n````powershell\r\n# ensure output dir exists\r\nNew-Item -ItemType Directory -Path .\\outputs\\conversations -ErrorAction SilentlyContinue | Out-Null\r\n\r\n# get bearer token\r\n$code = Get-Content inputs\\input.txt\r\n$auth = $code | Select-String -Pattern 'authorization' | Select-Object -First 1\r\n$auth = $auth -replace '.*\"(.*)\".*', '$1'\r\n\r\n$conversation_ids = Get-Content .\\outputs\\conversation-ids-to-download.txt\r\n$i = 0\r\nforeach ($id in $conversation_ids) {\r\n    $i++\r\n    Write-Progress -Activity \"Downloading conversations\" -Status \"Conversation $i of $($conversation_ids.Count)\" -PercentComplete ($i / $conversation_ids.Count * 100)\r\n    if (Test-Path \".\\outputs\\conversations\\$id.json\") {\r\n        Write-Host \"Conversation $id already downloaded\"\r\n        continue\r\n    }\r\n    Write-Host \"Downloading conversation $id\"\r\n\r\n    $rand = Get-Random -Minimum 1 -Maximum 5\r\n    Start-Sleep -Seconds $rand\r\n\r\n    $uri = \"https://chat.openai.com/backend-api/conversation/$id\"\r\n    $headers = @{\r\n        \"authority\"=\"chat.openai.com\"\r\n        \"authorization\" = \"$auth\"\r\n    }\r\n\r\n    $session = New-Object Microsoft.PowerShell.Commands.WebRequestSession\r\n    $session.UserAgent = \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36 Edg/120.0.0.0\"\r\n    \r\n    $resp = Invoke-WebRequest `\r\n    -UseBasicParsing `\r\n    -WebSession $session `\r\n    -Uri $uri `\r\n    -Headers $headers\r\n\r\n    $data = $resp.Content | ConvertFrom-Json\r\n    $data | ConvertTo-Json -Depth 100 | Out-File -FilePath \".\\outputs\\conversations\\$id.json\"\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Experiments\\horobi-transcript-utility\\chatgpt\\summarize_workspace.ps1\r\n\r\n````powershell\r\nWrite-Host \"Creating output dir if not exists\"\r\nNew-Item -ItemType Directory -Path \"outputs\" -ErrorAction SilentlyContinue\r\n\r\nWrite-Host \"Clearing previous prompt file\"\r\n$outfile = \"outputs\\prompt.md\"\r\nClear-Content $outfile -ErrorAction SilentlyContinue\r\n\r\nWrite-Host \"Gathering\"\r\n# Capture both .ps1 files and the directory structure\r\n$found = Get-ChildItem -Recurse | Where-Object { $_.Name.EndsWith(\".ps1\") }\r\nAdd-Content $outfile \"Found $($found.Count) PowerShell scripts in $(Get-Location)`n\"\r\n\r\nWrite-Host \"Iterating\"\r\nforeach ($file in $found) {\r\n    $relativePath = $file.FullName.Replace((Get-Location).Path + \"\\\", \"\")\r\n    \r\n    Write-Host \"building prompt for $($file.Name)\"\r\n    # Use the relative path for the language specifier in markdown code blocks\r\n    Add-Content $outfile \"=====BEGIN $relativePath`n$(Get-Content $file -Raw)`n===== END $relativePath\"\r\n}\r\n\r\nWrite-Host \"Summary complete. Markdown file created at $outfile\"\r\nGet-Content $outfile\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Experiments\\horobi-transcript-utility\\chatgpt\\build_download_list.ps1\r\n\r\n````powershell\r\n# Read the contents of backup-conversations.json and conversations.json\r\n$backupConversations = Get-Content -Raw -Path \"outputs\\backup-conversations.json\" | ConvertFrom-Json\r\n$conversations = Get-Content -Raw -Path \"outputs\\conversations.json\" | ConvertFrom-Json\r\n\r\n# Create a hashtable to store the backup conversations by ID\r\n$backupConversationsById = @{}\r\n$epoch = [datetime]'1970-01-01T00:00:00Z'\r\nforeach ($conversation in $backupConversations) {\r\n    $backupConversationsById[$conversation.id] = $epoch.AddSeconds($($backup.update_time | Sort-Object -Bottom 1))\r\n}\r\n\r\n# Filter conversations from conversations.json based on update_time\r\n$newConversations = $conversations | Where-Object {\r\n    if ($backupConversationsById.ContainsKey($_.id)) {\r\n        return [DateTime]::Parse($_.update_time) -gt $backupConversationsById[$_.id]\r\n    }\r\n    else {\r\n        return $true\r\n    }\r\n}\r\n\r\n# Get the IDs of conversations from conversations.json with newer update_time\r\n$newConversationIds = $newConversations | Sort-Object -Property update_time -Descending | Select-Object -ExpandProperty id\r\n\r\n# Output the conversation IDs\r\n$newConversationIds > outputs\\conversation-ids-to-download.txt\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Experiments\\horobi-transcript-utility\\chatgpt\\ensure_backup_on_disk.ps1\r\n\r\n````powershell\r\n. .\\get_latest_backup.ps1\r\n$found = Get-Backup\r\n\r\nWrite-Host \"Found latest ChatGPT export from $($found.Date)\"\r\nWrite-Host \"Ensuring file is locally available\"\r\nif ($(attrib $found.FullName).split() -contains \"O\") {\r\n    Write-Host \"File is not on disk! Downloading...\"\r\n    # This sets the flag that OneDrive will detect and will actually download the file for us\r\n    attrib +p $found.FullName\r\n    Start-Sleep -Seconds 10\r\n    attrib -p $found.FullName\r\n} else {\r\n    Write-Host \"File is already on disk! Woohoo!\"\r\n}\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Experiments\\horobi-transcript-utility\\chatgpt\\get_latest_backup.ps1\r\n\r\n````powershell\r\nfunction Get-Backup() {\r\n    # Get the path to the current user's Documents folder\r\n    $documentsPath = [System.Environment]::GetFolderPath('MyDocuments')\r\n\r\n    # Construct the backup path\r\n    $backup = Join-Path $documentsPath -ChildPath \"Backups\\openai\"\r\n\r\n    # \u276f ls $backup  \r\n    # f7e3523a860037df03f4159667310c78871d35b9fbd3ee38766f4077efa38218-2023-11-07-04-19-49.zip\r\n    # 'openai chatgpt download f7e3523a860037df03f4159667310c78871d35b9fbd3ee38766f4077efa38218-2023-08-11-00-12-56.zip'\r\n    $found = Get-ChildItem $backup\r\n    # get the latest according to the date at the end\r\n    # we need to extract the date from the filename\r\n    $found = $found | ForEach-Object { \r\n        $date = $_.Name -replace '.*-(\\d{4}-\\d{2}-\\d{2}-\\d{2}-\\d{2}-\\d{2})\\.zip', '$1'\r\n        $date = [datetime]::ParseExact($date, \"yyyy-MM-dd-HH-mm-ss\", $null)\r\n        $_ | Add-Member -NotePropertyName \"Date\" -NotePropertyValue $date -PassThru\r\n    } | Sort-Object -Property Date -Descending | Select-Object -First 1\r\n    return $found\r\n}\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Experiments\\horobi-transcript-utility\\chatgpt\\pull_convo_list.ps1\r\n\r\n````powershell\r\n$backup = Get-Content .\\outputs\\backup-conversations.json | ConvertFrom-Json\r\n# Create a DateTime object for the Unix epoch\r\n$epoch = [datetime]'1970-01-01T00:00:00Z'\r\n# Add the number of seconds in the Unix timestamp to the epoch\r\n$backup_date = $epoch.AddSeconds($($backup.update_time | Sort-Object -Bottom 1))\r\n\r\nWrite-Host \"Latest update in the backup: $backup_date\"\r\n\r\n$code = Get-Content inputs\\input.txt\r\n# Extract `\"authorization\"=\"Bearer ...\"` from the code file\r\n$auth = $code | Select-String -Pattern 'authorization' | Select-Object -First 1\r\n# now we have `\"authorization\" = \"Bearer ...\"` so we want the string inside the second quote pair\r\n$auth = $auth -replace '.*\"(.*)\".*', '$1'\r\n\r\n$uri = \"https://chat.openai.com/backend-api/conversations?offset=0&limit=100&order=updated\"\r\n$headers = @{\r\n  \"authority\"=\"chat.openai.com\"\r\n  \"authorization\" = \"$auth\"\r\n}\r\n\r\n$session = New-Object Microsoft.PowerShell.Commands.WebRequestSession\r\n$session.UserAgent = \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36 Edg/120.0.0.0\"\r\n\r\n$resp = Invoke-WebRequest `\r\n-UseBasicParsing `\r\n-WebSession $session `\r\n-Uri $uri `\r\n-Headers $headers\r\n\r\n$data = $resp.Content | ConvertFrom-Json\r\nWrite-Host \"Fetched $($data.items.Count) items out of $($data.total)\"\r\n$fetched_date = $data.items.update_time | Sort-Object -Top 1\r\nWrite-Host \"Oldest update: $($fetched_date)\"\r\n\r\n$results = @()\r\n\r\n# If the oldest update is still newer than the backup, we need to fetch more\r\nif ($fetched_date -gt $backup_date) {\r\n  $offset = 100\r\n  while ($fetched_date -gt $backup_date) {\r\n    Start-Sleep -Seconds 3\r\n    $results += $data.items\r\n    $uri = \"https://chat.openai.com/backend-api/conversations?offset=$offset&limit=100&order=updated\"\r\n    $resp = Invoke-WebRequest `\r\n    -UseBasicParsing `\r\n    -WebSession $session `\r\n    -Uri $uri `\r\n    -Headers $headers\r\n    $data = $resp.Content | ConvertFrom-Json\r\n    Write-Host \"Received $($data.items.Count) items, apparently $($data.total) exist remotely. Total received: $($results.Count)\"\r\n    $fetched_date = $data.items.update_time | Sort-Object -Top 1\r\n    Write-Host \"Oldest update: $($fetched_date)\"\r\n    $offset += 100\r\n  }\r\n  $results += $data.items\r\n} else {\r\n  $results = $data.items\r\n}\r\n\r\nWrite-Host \"Total fetched items: $($results.Count)\"\r\nSet-Content -Path .\\outputs\\conversations.json -Value ($results | ConvertTo-Json -Depth 100)\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Experiments\\horobi-transcript-utility\\chatgpt\\README.md\r\n\r\n````markdown\r\n# Horobi Transcript Utility - ChatGPT\r\n\r\nI want to search my full chat history with ChatGPT.\r\n\r\nUsing OpenAI's GDPR export, we can get a lot of our data without hammering the API.\r\n\r\nHowever, conversation updates after the export must be fetched from the website.\r\n\r\n- [`get_latest_backup.ps1`](.\\get_latest_backup.ps1) - Find the latest zip file from GDPR export\r\n- [`get_backup_conversations.ps1`](.\\get_backup_conversations.ps1) - Extract conversations.json from the zip file\r\n- [`ensure_backup_on_disk.ps1`](.\\ensure_backup_on_disk.ps1) - Helper to ensure the backup is on disk; download w/ OneDrive\r\n- [`pull_convo_list.ps1`](.\\pull_convo_list.ps1) - get the list of conversation IDs and updated timestamps\r\n- [`build_download_list.ps1`](.\\build_download_list.ps1) - retain only the IDs of conversations updated after the export\r\n- [`pull_convo_contents.ps1`](.\\pull_convo_contents.ps1) - download conversation jsons\r\n- [`expand_backup_conversations.ps1`](.\\expand_backup_conversations.ps1) - unused at this time\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\Experiments\\horobi-transcript-utility\\chatgpt\\inputs\\how-to.md\r\n\r\n````markdown\r\n1. Visit https://chat.openai.com/\r\n2. Open your browser inspector network tab, look for a request like `https://chat.openai.com/backend-api/conversations?offset=0&limit=28&order=updated`\r\n3. Copy it as powershell\r\n4. Paste into [`input.txt`](./input.txt)\r\n\r\n```pwsh\r\n./pull_convo_list.ps1\r\n./build_download_list.ps1\r\n./pull_convo_contents.ps1\r\n```\r\n\r\n# Inspecting JWTs\r\n\r\n[CyberChef](https://gchq.github.io/CyberChef/) ([GitHub](https://github.com/gchq/CyberChef)) can be ran locally, which is better than building a habit around tools jwt.io.\r\n````\r\n\r\n\r\n\r\n\r\n\r\n===\r\n\r\n\r\nThat is the summary of a set of scripts I made to help with the automation of archiving my conversations with chatgpt.\r\nI am also working on a series of scripts for interacting with the Gemini 1.5 Pro API.\r\n# Summary\r\n\r\n\r\n## D:\\Repos\\ml\\gemini-engine\\actions\\View a response in VSCode.ps1\r\n\r\n````powershell\r\n# Select response file\r\n$chosenResponseFile = Get-ChildItem -Path responses -Filter \"*.json\" `\r\n    | Select-Object -ExpandProperty Name `\r\n    | Sort-Object -Descending `\r\n    | fzf --no-sort\r\n\r\n# Check if file was selected\r\nif ([string]::IsNullOrEmpty($chosenResponseFile)) {\r\n    Write-Host \"No response file selected.\"\r\n    return\r\n}\r\n\r\n# Read response data\r\n$responseData = Get-Content -Raw -Path \"responses/$chosenResponseFile\" `\r\n    | ConvertFrom-Json\r\n\r\n# Extract the \"good part\"\r\n# (Modify this logic based on the actual response structure)\r\n$extracted = $responseData.response.candidates.content.parts.text\r\n\r\n# Open the extracted content in VSCode\r\n$extracted | code -\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\ml\\gemini-engine\\actions\\Mark directories of interest.ps1\r\n\r\n````powershell\r\n# Check if locations.txt exists, create if not\r\nif (!(Test-Path -Path \"locations.txt\")) {\r\n    New-Item -ItemType File -Path \"locations.txt\" | Out-Null\r\n}\r\n  \r\n## Define the mark function\r\nfunction mark {\r\n    $currentDir = (Get-Location).Path\r\n    Add-Content -Path \"locations.txt\" -Value $currentDir\r\n    Write-Host \"Marked directory: $currentDir\"\r\n}\r\n  \r\n# Start a subshell with the mark function available\r\n$newShell = New-Object System.Management.Automation.Runspaces.Runspace\r\n$newShell.Open()\r\n$newShell.SessionStateProxy.SetVariable(\"mark\", $function:mark)\r\nInvoke-Expression \"& { $newShell.CreatePipeline().Invoke() }\"\r\n\r\n# Close the subshell\r\n$newShell.Close()\r\n\r\nWrite-Host \"Finished marking directories.\"\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\ml\\gemini-engine\\actions\\Summarize directory to clipboard.ps1\r\n\r\n````powershell\r\n# Prompt user to enter the directory to summarize\r\n$starting_dir = Read-Host \"Enter the directory to summarize\"\r\nif ([string]::IsNullOrWhiteSpace($starting_dir) -or -not (Test-Path $starting_dir)) {\r\n    Write-Host \"Invalid or no directory specified. Exiting...\"\r\n    return\r\n}\r\n\r\n# Check if the specified directory is a Git repository\r\n\r\n$choices = Get-ChildItem -Recurse -File -Path $starting_dir | Select-Object -ExpandProperty FullName\r\n$isGitDir = $(git -C $starting_dir rev-parse --is-inside-work-tree) -eq 'true'\r\nif ($isGitDir) {\r\n    $choices = $choices | Where-Object { -not (git -C $starting_dir check-ignore $_) }\r\n}\r\n\r\n# There is opportunity for a submenu here to present the user the current extension list and allow them to modify it considering the extensions found in the directory\r\n$allowed_extensions = Get-Content .\\summarizable_extensions.txt\r\n\r\n# Ensure that the user is only presented files with allowed extensions\r\n$choices = $choices | Where-Object { \r\n    if ($_ -match \"(\\.[^\\.\\\\/:*?\"\"<>|\\r\\n]+)$\") {\r\n        return $allowed_extensions -contains $matches[1] \r\n    }\r\n    return $false\r\n}\r\n\r\n# Prompt the user to select files to summarize\r\n$files = @()\r\nwhile ($true) {\r\n    $chosen = $choices | fzf --multi --bind \"ctrl-a:select-all,ctrl-d:deselect-all,ctrl-t:toggle-all\" --header \"Selection will repeat until Ctrl+C received\"\r\n    if ($null -eq $chosen) {\r\n        break\r\n    }\r\n    $files += $chosen\r\n}\r\n\r\n$lang_ext_lookup = Get-Content .\\extension_to_markdown_fence.ini -Raw | ConvertFrom-StringData\r\n\r\n$content = $files | ForEach-Object { \r\n    $path = $_\r\n    $content = Get-Content \"$path\" -Raw\r\n    $extension = [System.IO.Path]::GetExtension($path)\r\n    $lang = $lang_ext_lookup[$extension] ?? $extension.TrimStart('.')\r\n    return \"\r\n# $path\r\n\r\n$('`'*4)$lang\r\n$content\r\n$('`'*4)\r\n\r\n\"\r\n}\r\n| Out-String\r\n$content = \"# Summary`n`n$content`n\"\r\n$content | Set-Clipboard\r\nWrite-Host \"Copied $($files.Count) files to clipboard\"\r\n\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\ml\\gemini-engine\\actions\\Load api key from 1password vault.ps1\r\n\r\n````powershell\r\n$env:GEMINI_API_KEY = op read \"op://Private/Google AI Studio Gemini API key/credential\"\r\nWrite-Host \"API Key loaded into GEMINI_API_KEY environment variable.\"\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\ml\\gemini-engine\\actions\\Upload a file.ps1\r\n\r\n````powershell\r\n# Get user choice\r\n$filePath = Get-ChildItem -Path files `\r\n| ForEach-Object { $_.Name } `\r\n| fzf\r\n\r\n# Overwrite check\r\nif ($cachedFiles.ContainsKey($filePath)) {\r\n  $overwrite = Read-Host \"$filePath already exists, overwrite? (y/n)\"\r\n  if ($overwrite -ne \"y\") { continue }\r\n}\r\n\r\n# Get mimetype\r\n$fileMimetype = Get-Content .\\mimetypes.txt | fzf\r\n\r\n# Upload file\r\n$fileUrl = python file_upload.py \"files/$filePath\" \"$fileMimetype\"\r\nif ($? -eq $false) {\r\n  Write-Warning \"Failed to upload file.\"\r\n  continue\r\n}\r\n\r\n# Update cached data\r\n$cachedFiles[$filePath] = [PSCustomObject]@{\r\n  url = $fileUrl\r\n  mimetype = $fileMimetype\r\n}\r\n$cachedFiles | ConvertTo-Json | Set-Content -Path \"files.json\"\r\n\r\n# Inform the user\r\nWrite-Host \"Uploaded file and saved the url to the cache.\"\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\ml\\gemini-engine\\actions\\Interactive mode.ps1\r\n\r\n````powershell\r\nwhile ($true) {\r\n    $chosenFileName = $cachedFiles.Keys | fzf\r\n    if ([string]::IsNullOrEmpty($chosenFileName)) {\r\n        $file = [PSCustomObject]@{\r\n            url = $null\r\n            mimetype = $null\r\n        }\r\n    } else {\r\n        $file = $cachedFiles[$chosenFileName]\r\n    }\r\n    $prompt = Read-Host \"Prompt\"\r\n    if ([string]::IsNullOrWhiteSpace($prompt)) {\r\n        break\r\n    }\r\n    $payload = [pscustomobject]@{\r\n        prompt = $prompt\r\n        file_url = $file.url\r\n        file_mimetype = $file.mimetype\r\n    }\r\n    python inference.py $($payload | ConvertTo-Json)\r\n    pause\r\n}\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\ml\\gemini-engine\\actions\\Show prompt lengths.ps1\r\n\r\n````powershell\r\n$promptFiles = Get-ChildItem -Path \"prompts\" -Filter \"*.txt\"\r\n\r\n# Loop through each file and calculate length\r\n$summary = @()\r\nforeach ($file in $promptFiles) {\r\n  $content = Get-Content -Path $file.FullName -Raw\r\n  $length = $content.Length\r\n  $summary += [PSCustomObject]@{\r\n    Name   = $file.BaseName\r\n    Length = $length\r\n  }\r\n}\r\n\r\n$summary | Format-Table -AutoSize\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\ml\\gemini-engine\\actions\\Manually set API key.ps1\r\n\r\n````powershell\r\n# Read the secure string\r\nWrite-Host -NoNewLine \"Enter the API key: \"\r\n$secureString = Read-Host -AsSecureString\r\n\r\n# Convert SecureString to BSTR (Basic String) and then to a plain text string\r\n$ptr = [Runtime.InteropServices.Marshal]::SecureStringToBSTR($secureString)\r\ntry {\r\n    $plainText = [Runtime.InteropServices.Marshal]::PtrToStringBSTR($ptr)\r\n} finally {\r\n    # Make sure to free the BSTR to prevent memory leaks\r\n    [Runtime.InteropServices.Marshal]::ZeroFreeBSTR($ptr)\r\n}\r\n\r\n# Now you can use $plainText as a regular string\r\n# For example, setting it as an environment variable\r\n$ENV:GEMINI_API_KEY = $plainText\r\n\r\n# Use the environment variable\r\nWrite-Host \"Set the API key as an environment variable.\"\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\ml\\gemini-engine\\actions\\Create a new prompt.ps1\r\n\r\n````powershell\r\n$promptName = Read-Host \"Enter a name for the prompt (.txt gets appended)\"\r\n$promptName += \".txt\"\r\n# Open prompt file in editor\r\nhx prompts/$promptName\r\n# Update cached data\r\n$cachedPrompts += $promptName\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\ml\\gemini-engine\\actions\\Perform image inference.ps1\r\n\r\n````powershell\r\nif (-not (Test-Path Env:GEMINI_API_KEY)) {\r\n    Write-Warning \"GEMINI_API_KEY environment variable not set.\"\r\n    return\r\n}\r\n\r\n# Select file and prompt using fzf\r\n$chosenFileName = $cachedFiles.Keys | fzf --prompt \"Select file: \" --header \"Cached Files\"\r\n$file = $cachedFiles[$chosenFileName]\r\nPush-Location prompts\r\n$env:SHELL=\"pwsh\"\r\n$chosenPromptName = fzf --preview \"bat {}\" --prompt \"Select prompt: \" --header \"Available Prompts\"\r\nPop-Location\r\n# Read prompt content\r\n$prompt = Get-Content -Raw \"prompts\\$chosenPromptName\"\r\n# Prepare payload and call Python script\r\n$payload = [pscustomobject]@{\r\n    prompt = $prompt\r\n    file_url = $file.url\r\n    file_mimetype = $file.mimetype\r\n}\r\n$file = New-TemporaryFile\r\n$payload | ConvertTo-Json | Set-Content -Path $file.FullName\r\ntry {\r\n    python inference.py \"$($file.FullName)\"\r\n} finally {\r\n    Remove-Item -Path $file.FullName\r\n}\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\ml\\gemini-engine\\actions\\Edit prompts.ps1\r\n\r\n````powershell\r\n$file = $cachedPrompts | fzf --prompt \"Select prompt to edit: \" --header \"Cached Prompts\"\r\nhx \"prompts\\$file\"\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\ml\\gemini-engine\\actions\\Preview cached files.ps1\r\n\r\n````powershell\r\n$cachedfiles.Keys `\r\n    | ForEach-Object { \r\n        $entry = $cachedfiles[$_]\r\n        $name = $_\r\n        $url = $entry.url\r\n        $mimetype = $entry.mimetype    \r\n        # format as %-20s %-20s %-20s\r\n        \"{0,-20} {1,-20} {2,-64}\" -f $name, $mimetype, $url\r\n    } `\r\n    | fzf\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\ml\\gemini-engine\\actions\\Install python dependencies.ps1\r\n\r\n````powershell\r\npip install -q google-api-python-client google-generativeai\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\ml\\gemini-engine\\actions\\Suggest directory path to clipboard.ps1\r\n\r\n````powershell\r\n$suggestions = @()\r\nif (Get-Command sqlite3) {\r\n    $suggestions += sqlite3 -json $Env:APPDATA\\Code\\User\\globalStorage\\state.vscdb \"SELECT * FROM ItemTable WHERE key = 'history.recentlyOpenedPathsList';\" .exit `\r\n        | ConvertFrom-Json `\r\n        | Select-Object -ExpandProperty value `\r\n        | ConvertFrom-Json `\r\n        | Select-Object -ExpandProperty entries `\r\n        | Where-Object { $_.folderUri?.StartsWith(\"file:///\") } `\r\n        | Select-Object -ExpandProperty folderUri `\r\n        | ForEach-Object { [System.Uri]::UnescapeDataString($_) } `\r\n        | ForEach-Object { $_ -replace '^file:///', '' } `\r\n        | ForEach-Object { $_.Substring(0,1).ToUpper() + $_.Substring(1)}\r\n} else {\r\n    Write-Warning \"sqlite3 wasn't detected\"\r\n}\r\n\r\nif (Get-Command zoxide) {\r\n    $suggestions += zoxide query -l\r\n} else {\r\n    Write-Warning \"zoxide wasn't detected\"\r\n}\r\n\r\n$psreadlinepath = \"$Env:APPDATA\\Microsoft\\Windows\\PowerShell\\PSReadLine\"\r\nif ((Test-Path $psreadlinepath) -and (Get-Command rg)) {\r\n    $suggestions += rg \"^cd [A-Za-z]:\\\\[^;]*\" $psreadlinepath --only-matching --no-line-number --no-heading --no-filename\r\n} else {\r\n    Write-Warning \"PSReadLine wasn't detected\"\r\n}\r\n$old = $env:SHELL\r\n$env:SHELL=\"pwsh\"\r\ntry {\r\n    $chosen = $suggestions `\r\n        | ForEach-Object { $_ -replace '/', '\\' } `\r\n        | Sort-Object -Unique `\r\n        | Where-Object { Test-Path $_ } `\r\n        | fzf --prompt \"Select a directory: \" --preview \"eza -1 --icons=always {}\"\r\n    $chosen | Set-Clipboard\r\n    Write-Host \"Directory copied to clipboard: $chosen\"\r\n} finally {\r\n    $env:SHELL = $old\r\n}\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\ml\\gemini-engine\\actions\\Perform text-only inference.ps1\r\n\r\n````powershell\r\nif (-not (Test-Path Env:GEMINI_API_KEY)) {\r\n    Write-Warning \"GEMINI_API_KEY environment variable not set.\"\r\n    return\r\n}\r\n\r\nPush-Location prompts\r\n$env:SHELL=\"pwsh\"\r\n$chosenPromptName = fzf --preview \"bat {}\" --prompt \"Select prompt: \" --header \"Available Prompts\"\r\nPop-Location\r\n# Read prompt content\r\n$prompt = Get-Content -Raw \"prompts\\$chosenPromptName\"\r\n# Prepare payload and call Python script\r\n$payload = [pscustomobject]@{\r\n    prompt = $prompt\r\n    file_url = $file.url\r\n    file_mimetype = $file.mimetype\r\n}\r\n$file = New-TemporaryFile\r\n$payload | ConvertTo-Json | Set-Content -Path $file.FullName\r\ntry {\r\n    python inference.py \"$($file.FullName)\" | code -\r\n} finally {\r\n    Remove-Item -Path $file.FullName\r\n}\r\n````\r\n\r\n\r\n\r\n## D:\\Repos\\ml\\gemini-engine\\README.md\r\n\r\n````markdown\r\n<div align=\"center\">\r\n\r\n# Gemini Engine\r\n\r\n<img height=400 src=\"https://cards.scryfall.io/large/front/2/e/2e03e05b-011b-4695-950b-98dd7643b8a0.jpg?1562636055\">\r\n\r\nMine\r\n[![Discord](https://img.shields.io/discord/967118679370264627.svg?colorB=7289DA&logo=data:image/png)](https://discord.gg/5mbUY3mu6m)\r\n\r\nGoogle Developer Community\r\n[![Discord](https://img.shields.io/discord/1009525727504384150.svg?colorB=7289DA&logo=data:image/png)](https://discord.gg/google-dev-community)\r\n\r\n</div>\r\n\r\nA collection of scripts I'm using to interact with the Gemini 1.5 Pro API.\r\n\r\n### Dependencies\r\n\r\nThis project expects the following commands to be available for full functionality:\r\n\r\n- `pwsh`\r\n- `fzf`\r\n- `hx`\r\n- `sqlite3`\r\n- `zoxide`\r\n- `rg`\r\n- `eza`\r\n\r\n## Leaking API keys\r\n\r\nThe Google python APIs will include your API key in the error messages.\r\n\r\nClear your Jupyter notebook cell outputs before committing notebooks to reduce risk of leaking your API key.\r\n\r\n## Mimetypes\r\n\r\nSourced from https://www.iana.org/assignments/media-types/media-types.xhtml using\r\n\r\n```javascript\r\ncopy(Array.from(document.querySelectorAll(\"td:nth-child(2)\")).map(x => x.innerText).join(\"\\n\"))\r\n```\r\n````\r\n\r\nThe horobi thing does a few things.\r\nBecause I have exported a snapshot in time using the GDPR export thing, not all the conversations must be downloaded.\r\nWe only need to download conversations that aren't included in the backup, and conversations that aren't already downloaded from previous iterations of the script.\r\nThe backup is stored in a zip in my OneDrive.\r\nWe want to be able to search the conversations, each conversation has a GUID.\r\nBy extracting the conversations from the zip file and the website, we can create a json file for each conversation.\r\nThe web interface lists the conversation change date, so we must fetch conversations, taking pages until we get to the page that contains conversations that haven't been modified since the last backup.\r\n\r\nThe scripts in the horobi-transcript-utility aren't intuitively named, and some are trying to do multiple things at once.\r\nI want to separate them into the core concerns.\r\nAdditionally, the method of putting all the jsons in the output folder flat is not scalable.\r\nWindows doesn't like a billion files in a flat structure, so we can group them by yyyy/mm/dd structure.\r\nWe must also consider the case of a conversation that has been download previously but has since had an update.\r\nLet's have the yyyy/mm/dd be the date of the start of the conversation so we don't need to deal with moving if a conversation spans multiple days.\r\n\r\nHere is an example conversation.json\r\n\r\n```json\r\n{\r\n  \"title\": \"Bevy Egui Inspector Integration\",\r\n  \"create_time\": 1705717139.508822,\r\n  \"update_time\": 1705717177.912138,\r\n  \"moderation_results\": [],\r\n  \"current_node\": \"debe6711-dfdd-433f-a6e0-39f4db5b0e94\",\r\n  \"conversation_id\": \"0a1aa351-2351-4fd4-946f-7a5a8eb03bea\",\r\n  \"is_archived\": false,\r\n  \"safe_urls\": [\r\n    \"window.name\"\r\n  ]\r\n}\r\n```\r\n\r\nLet's aim for a similar structure as the gemini-engine repo.\r\n\r\nWe will have an entrypoint ps1 file that will enumerate a folder containing individual action ps1 files.\r\n\r\nWe will want the following actions:\r\n\r\n- Set API key from request copied as powershell from browser network tools\r\n  - read from clipboard\r\n  - extract bearer token\r\n  - set as environment variable\r\n- Expand backup to conversations\\yyyy\\mm\\dd\r\n  - list zips in the backup folder\r\n  - ensure file is locally available by using attrib to get onedrive to download it\r\n  - extract the conversations\r\n- Download conversations not present on disk yet\r\n  - if conversations folder empty or not exist, error regarding running expand backup first\r\n  - if bearer token env not set, error regarding running set api key first\r\n  - get list of conversations from the website\r\n  - identify conversations to be downloaded based on update time\r\n  - download conversations\r\n- Search conversations\r\n  - use fzf and ripgrep\r\n\r\nPlease format your response as markdown, with the code blocks identifying the content of the scripts.\r\n\r\nHere is some context on using fzf and ripgrep from their github\r\n\r\n```md\r\nUsing fzf as interactive Ripgrep launcher\r\nWe have learned that we can bind reload action to a key (e.g. --bind=ctrl-r:execute(ps -ef)). In the next example, we are going to bind reload action to change event so that whenever the user changes the query string on fzf, reload action is triggered.\r\n\r\nHere is a variation of the above rfv script. fzf will restart Ripgrep every time the user updates the query string on fzf. Searching and filtering is completely done by Ripgrep, and fzf merely provides the interactive interface. So we lose the \"fuzziness\", but the performance will be better on larger projects, and it will free up memory as you narrow down the results.\r\n\r\n#!/usr/bin/env bash\r\n\r\n# 1. Search for text in files using Ripgrep\r\n# 2. Interactively restart Ripgrep with reload action\r\n# 3. Open the file in Vim\r\nRG_PREFIX=\"rg --column --line-number --no-heading --color=always --smart-case \"\r\nINITIAL_QUERY=\"${*:-}\"\r\n: | fzf --ansi --disabled --query \"$INITIAL_QUERY\" \\\r\n    --bind \"start:reload:$RG_PREFIX {q}\" \\\r\n    --bind \"change:reload:sleep 0.1; $RG_PREFIX {q} || true\" \\\r\n    --delimiter : \\\r\n    --preview 'bat --color=always {1} --highlight-line {2}' \\\r\n    --preview-window 'up,60%,border-bottom,+{2}+3/3,~3' \\\r\n    --bind 'enter:become(vim {1} +{2})'\r\nimage\r\n\r\nInstead of starting fzf in the usual rg ... | fzf form, we start fzf with an empty input (: | fzf), then we make it start the initial Ripgrep process immediately via start:reload binding. This way, fzf owns the initial Ripgrep process so it can kill it on the next reload. Otherwise, the process will keep running in the background.\r\nFiltering is no longer a responsibility of fzf; hence --disabled\r\n{q} in the reload command evaluates to the query string on fzf prompt.\r\nsleep 0.1 in the reload command is for \"debouncing\". This small delay will reduce the number of intermediate Ripgrep processes while we're typing in a query.\r\n```\r\n\r\nLet's think step by step.\r\nCreate an English outline for each action that is to be created, the steps within the action that need to be taken, and the expected outcome of the action.\r\nActions will have user input using Read-Host for free-text and fzf for choice from enumerable options.\r\nOutcomes will be state changes such as setting environment variables, creating files, or modifying files.\r\nThen, proceed with creating the implementation of the actions in the markdown code block for each ps1 file.\r\n\r\nInclude instructions for updating the horobi repository from its current state to the new state.\r\n\r\nThank you, I look forward to your response.\r\n- Teamy",
    "file_url": null,
    "file_mimetype": null
}