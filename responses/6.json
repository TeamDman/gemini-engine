{
    "response": {
        "candidates": [
            {
                "content": {
                    "parts": [
                        {
                            "text": "## Action Proposal: Download a cached file\n\n### Summary\n\nThis action will allow users to download a file that has been previously uploaded and cached by the \"Upload a file\" action. \n\n### File Name\n\nDownload a cached file.ps1\n\n### Implementation\n\n```powershell\n# Select file to download\n$chosenFileName = $cachedFiles.Keys | fzf --prompt \"Select file to download: \" --header \"Cached Files\"\n\n# Check if file was selected\nif ([string]::IsNullOrEmpty($chosenFileName)) {\n    Write-Host \"No file selected.\"\n    return\n}\n\n# Get file URL and mimetype\n$fileUrl = $cachedFiles[$chosenFileName].url\n$fileMimetype = $cachedFiles[$chosenFileName].mimetype\n\n# Download file\nInvoke-WebRequest -Uri $fileUrl -OutFile \"$chosenFileName\"\n\n# Inform the user\nWrite-Host \"Downloaded file: $chosenFileName\"\n```\n\nThis script will:\n\n1. Use `fzf` to present a list of cached file names for the user to choose from.\n2. Check if a file was selected.\n3. Retrieve the URL and mimetype of the selected file from the cached data.\n4. Use `Invoke-WebRequest` to download the file from the URL and save it locally with the chosen file name.\n5. Inform the user that the file has been downloaded.\n"
                        }
                    ],
                    "role": "model"
                },
                "finishReason": "STOP",
                "index": 0,
                "safetyRatings": [
                    {
                        "category": "HARM_CATEGORY_SEXUALLY_EXPLICIT",
                        "probability": "NEGLIGIBLE"
                    },
                    {
                        "category": "HARM_CATEGORY_HATE_SPEECH",
                        "probability": "NEGLIGIBLE"
                    },
                    {
                        "category": "HARM_CATEGORY_HARASSMENT",
                        "probability": "NEGLIGIBLE"
                    },
                    {
                        "category": "HARM_CATEGORY_DANGEROUS_CONTENT",
                        "probability": "NEGLIGIBLE"
                    }
                ]
            }
        ]
    },
    "prompt": "\r\n#REGION D:\\Repos\\ml\\gemini-engine\\actions\\Upload a file.ps1\r\n# Get user choice\r\n$filePath = Get-ChildItem -Path files `\r\n| ForEach-Object { $_.Name } `\r\n| fzf\r\n\r\n# Overwrite check\r\nif ($cachedFiles.ContainsKey($filePath)) {\r\n  $overwrite = Read-Host \"$filePath already exists, overwrite? (y/n)\"\r\n  if ($overwrite -ne \"y\") { continue }\r\n}\r\n\r\n# Get mimetype\r\n$fileMimetype = Get-Content .\\mimetypes.txt | fzf\r\n\r\n# Upload file\r\n$fileUrl = python file_upload.py \"files/$filePath\" \"$fileMimetype\"\r\nif ($? -eq $false) {\r\n  Write-Warning \"Failed to upload file.\"\r\n  continue\r\n}\r\n\r\n# Update cached data\r\n$cachedFiles[$filePath] = [PSCustomObject]@{\r\n  url = $fileUrl\r\n  mimetype = $fileMimetype\r\n}\r\n$cachedFiles | ConvertTo-Json | Set-Content -Path \"files.json\"\r\n\r\n# Inform the user\r\nWrite-Host \"Uploaded file and saved the url to the cache.\"\r\n\r\n#ENDREGION\r\n\r\n\r\n#REGION D:\\Repos\\ml\\gemini-engine\\actions\\Interactive mode.ps1\r\nwhile ($true) {\r\n    $chosenFileName = $cachedFiles.Keys | fzf\r\n    if ([string]::IsNullOrEmpty($chosenFileName)) {\r\n        $file = [PSCustomObject]@{\r\n            url = $null\r\n            mimetype = $null\r\n        }\r\n    } else {\r\n        $file = $cachedFiles[$chosenFileName]\r\n    }\r\n    $prompt = Read-Host \"Prompt\"\r\n    if ([string]::IsNullOrWhiteSpace($prompt)) {\r\n        break\r\n    }\r\n    $payload = [pscustomobject]@{\r\n        prompt = $prompt\r\n        file_url = $file.url\r\n        file_mimetype = $file.mimetype\r\n    }\r\n    python inference.py $($payload | ConvertTo-Json)\r\n    pause\r\n}\r\n#ENDREGION\r\n\r\n\r\n#REGION D:\\Repos\\ml\\gemini-engine\\actions\\Create a new prompt.ps1\r\n$promptName = Read-Host \"Enter a name for the prompt (.txt gets appended)\"\r\n$promptName += \".txt\"\r\n# Open prompt file in editor\r\nhx prompts/$promptName\r\n# Update cached data\r\n$cachedPrompts += $promptName\r\n#ENDREGION\r\n\r\n\r\n#REGION D:\\Repos\\ml\\gemini-engine\\actions\\Preview cached files.ps1\r\n$cachedfiles.Keys `\r\n    | ForEach-Object { \r\n        $entry = $cachedfiles[$_]\r\n        $name = $_\r\n        $url = $entry.url\r\n        $mimetype = $entry.mimetype    \r\n        # format as %-20s %-20s %-20s\r\n        \"{0,-20} {1,-20} {2,-64}\" -f $name, $mimetype, $url\r\n    } `\r\n    | fzf\r\n#ENDREGION\r\n\r\n\r\n#REGION D:\\Repos\\ml\\gemini-engine\\actions\\View a response in VSCode.ps1\r\n# Select response file\r\n$chosenResponseFile = Get-ChildItem -Path responses -Filter \"*.json\" `\r\n    | Select-Object -ExpandProperty Name `\r\n    | Sort-Object -Descending `\r\n    | fzf --no-sort\r\n\r\n# Check if file was selected\r\nif ([string]::IsNullOrEmpty($chosenResponseFile)) {\r\n    Write-Host \"No response file selected.\"\r\n    return\r\n}\r\n\r\n# Read response data\r\n$responseData = Get-Content -Raw -Path \"responses/$chosenResponseFile\" `\r\n    | ConvertFrom-Json\r\n\r\n# Extract the \"good part\"\r\n# (Modify this logic based on the actual response structure)\r\n$extracted = $responseData.response.candidates.content.parts.text\r\n\r\n# Open the extracted content in VSCode\r\n$extracted | code -\r\n\r\n#ENDREGION\r\n\r\n\r\n#REGION D:\\Repos\\ml\\gemini-engine\\actions\\Execute a prompt inference.ps1\r\n# Select file and prompt using fzf\r\n$chosenFileName = $cachedFiles.Keys | fzf --prompt \"Select file: \" --header \"Cached Files\"\r\n$file = $cachedFiles[$chosenFileName]\r\nPush-Location prompts\r\n$env:SHELL=\"pwsh\"\r\n$chosenPromptName = fzf --preview \"bat {}\" --prompt \"Select prompt: \" --header \"Available Prompts\"\r\nPop-Location\r\n# Read prompt content\r\n$prompt = Get-Content -Raw \"prompts\\$chosenPromptName\"\r\n# Prepare payload and call Python script\r\n$payload = [pscustomobject]@{\r\n    prompt = $prompt\r\n    file_url = $file.url\r\n    file_mimetype = $file.mimetype\r\n}\r\n$file = New-TemporaryFile\r\n$payload | ConvertTo-Json | Set-Content -Path $file.FullName\r\ntry {\r\n    python inference.py \"$($file.FullName)\"\r\n} finally {\r\n    Remove-Item -Path $file.FullName\r\n}\r\n#ENDREGION\r\n\r\n\r\n#REGION D:\\Repos\\ml\\gemini-engine\\actions\\Copy file summary to clipboard.ps1\r\n$choices = Get-ChildItem -Recurse -File | Select-Object -ExpandProperty FullName\r\n\r\n$files = @()\r\nwhile ($true) {\r\n    $chosen = $choices | fzf --multi --bind \"ctrl-a:select-all,ctrl-d:deselect-all,ctrl-t:toggle-all\" --header \"Selection will repeat until Ctrl+C received\"\r\n    if ($null -eq $chosen) {\r\n        break\r\n    }\r\n    $files += $chosen\r\n}\r\n$content = $files | ForEach-Object { \r\n    $content = Get-Content $_ -Raw\r\n    return \"\r\n#REGION $($_)\r\n$content\r\n#ENDREGION\r\n\"\r\n}\r\n| Out-String\r\n$content | Set-Clipboard\r\nWrite-Host \"Copied $($files.Count) files to clipboard\"\r\n#ENDREGION\r\n\r\n\r\n#REGION D:\\Repos\\ml\\gemini-engine\\actions\\Load api key from 1password vault.ps1\r\n$env:GEMINI_API_KEY = op read \"op://Private/Google AI Studio Gemini API key/credential\"\r\nWrite-Host \"API Key loaded into GEMINI_API_KEY environment variable.\"\r\n#ENDREGION\r\n\r\n\r\n#REGION D:\\Repos\\ml\\gemini-engine\\feedback\\mimetypes.md\r\nhttps://discord.com/channels/1009525727504384150/1182420115661267085/1222619212577640650\r\n\r\n```python\r\n# Prepare file to upload to GenAI File API\r\nfile_path = \"beans.txt\"\r\n\r\n# media = MediaFileUpload(file_path, mimetype=\"application/json\")\r\nmedia = MediaFileUpload(file_path, mimetype=mimetypes.guess_type(file_path)[0])\r\nbody = {\"file\": {\"displayName\": \"A text file\"}}\r\n\r\n# Upload file\r\ncreate_file_request = genai_service.media().upload(media_body=media, body=body)\r\ncreate_file_response = create_file_request.execute()\r\nfile_uri = create_file_response[\"file\"][\"uri\"]\r\nfile_mimetype = create_file_response[\"file\"][\"mimeType\"]\r\nprint(\"Uploaded file: \" + file_uri)\r\n```\r\nThis works\r\nUploaded file: https://generativelanguage.googleapis.com/v1beta/files/y...\r\n\r\nThis fails\r\n\r\n```python\r\n# Make Gemini 1.5 API LLM call\r\nprompt = \"Describe the contents of the text file\"\r\nmodel = \"models/gemini-1.5-pro-latest\"\r\ncontents = {\"contents\": [{ \r\n  \"parts\":[\r\n    {\"text\": prompt},\r\n    {\"file_data\": {\"file_uri\": file_uri, \"mime_type\": file_mimetype}}]\r\n}]}\r\ngenai_request = genai_service.models().generateContent(model=model, body=contents)\r\nresp = genai_request.execute()\r\nprint(len(resp[\"candidates\"]))\r\n```\r\nHttpError: <HttpError 400 when requesting https:...\r\nreturned \"Request contains an invalid argument.\". Details: \"Request contains an invalid argument.\"\r\n\r\nthe FAQ doc lists image/webp as supported but I received the same error when trying a webp file, mimetypes.py doesn't contain an entry for it from what I can tell so this happens which doesn't prevent the genai_servbice.media().upload from working but it fails at inference time\r\n\r\n```python\r\nmimetypes.guess_type(\"abc.webp\")\r\n> (None,None)\r\n```\r\n\r\n\r\n#ENDREGION\r\n\r\n\r\n#REGION D:\\Repos\\ml\\gemini-engine\\actions\\Edit prompts.ps1\r\n$file = $cachedPrompts | fzf --prompt \"Select prompt to edit: \" --header \"Cached Prompts\"\r\nhx \"prompts\\$file\"\r\n#ENDREGION\r\n\r\n\r\n#REGION D:\\Repos\\ml\\gemini-engine\\actions\\Manually set API key.ps1\r\n# Read the secure string\r\nWrite-Host -NoNewLine \"Enter the API key: \"\r\n$secureString = Read-Host -AsSecureString\r\n\r\n# Convert SecureString to BSTR (Basic String) and then to a plain text string\r\n$ptr = [Runtime.InteropServices.Marshal]::SecureStringToBSTR($secureString)\r\ntry {\r\n    $plainText = [Runtime.InteropServices.Marshal]::PtrToStringBSTR($ptr)\r\n} finally {\r\n    # Make sure to free the BSTR to prevent memory leaks\r\n    [Runtime.InteropServices.Marshal]::ZeroFreeBSTR($ptr)\r\n}\r\n\r\n# Now you can use $plainText as a regular string\r\n# For example, setting it as an environment variable\r\n$ENV:GEMINI_API_KEY = $plainText\r\n\r\n# Use the environment variable\r\nWrite-Host \"Set the API key as an environment variable.\"\r\n#ENDREGION\r\n\r\n\r\n#REGION D:\\Repos\\ml\\gemini-engine\\actions\\Install python dependencies.ps1\r\npip install -q google-api-python-client google-generativeai\r\n#ENDREGION\r\n\r\n\r\n#REGION D:\\Repos\\ml\\gemini-engine\\README.md\r\n<div align=\"center\">\r\n\r\n# Gemini Engine\r\n\r\n<img height=500 src=\"https://cards.scryfall.io/large/front/2/e/2e03e05b-011b-4695-950b-98dd7643b8a0.jpg?1562636055\">\r\n\r\nMine\r\n[![Discord](https://img.shields.io/discord/967118679370264627.svg?colorB=7289DA&logo=data:image/png)](https://discord.gg/5mbUY3mu6m)\r\n\r\nGoogle Developer Community\r\n[![Discord](https://img.shields.io/discord/1009525727504384150.svg?colorB=7289DA&logo=data:image/png)](https://discord.gg/google-dev-community)\r\n\r\n</div>\r\n\r\nA collection of scripts I'm using to interact with the Gemini 1.5 Pro API.\r\n\r\n## Leaking API keys\r\n\r\nThe Google python APIs will include your API key in the error messages.\r\n\r\nClear your cell outputs before committing notebooks to reduce risk of leaking your API key.\r\n\r\n## Mimetypes\r\n\r\nSourced from https://www.iana.org/assignments/media-types/media-types.xhtml using\r\n\r\n```javascript\r\ncopy(Array.from(document.querySelectorAll(\"td:nth-child(2)\")).map(x => x.innerText).join(\"\\n\"))\r\n```\r\n#ENDREGION\r\n\r\n\r\n#REGION D:\\Repos\\ml\\gemini-engine\\gemini.ps1\r\n# gemini.ps1\r\n\r\n# Load cached data\r\nif (Test-Path -Path .\\files.json) {\r\n  $cachedFiles = Get-Content -Path \"files.json\" | ConvertFrom-Json -AsHashtable\r\n} else {\r\n  $cachedFiles = @{}\r\n}\r\nif (-not (Test-Path -Path .\\prompts)) {\r\n  New-Item -ItemType Directory -Path .\\prompts | Out-Null\r\n}\r\n$cachedPrompts = Get-ChildItem -Path \"prompts/*.txt\" | Select-Object -ExpandProperty Name\r\n\r\nwhile ($true) {\r\n  $action = Get-ChildItem -Path actions `\r\n    | Select-Object -ExpandProperty name `\r\n    | Sort-Object -Descending `\r\n    | fzf --prompt \"Action: \" --header \"Select an action to run\"\r\n  if ([string]::IsNullOrWhiteSpace($action)) {\r\n    break\r\n  }\r\n  . \".\\actions\\$action\"\r\n  pause\r\n}\r\n\r\n#ENDREGION\r\n\r\n\r\n#REGION D:\\Repos\\ml\\gemini-engine\\README.md\r\n<div align=\"center\">\r\n\r\n# Gemini Engine\r\n\r\n<img height=500 src=\"https://cards.scryfall.io/large/front/2/e/2e03e05b-011b-4695-950b-98dd7643b8a0.jpg?1562636055\">\r\n\r\nMine\r\n[![Discord](https://img.shields.io/discord/967118679370264627.svg?colorB=7289DA&logo=data:image/png)](https://discord.gg/5mbUY3mu6m)\r\n\r\nGoogle Developer Community\r\n[![Discord](https://img.shields.io/discord/1009525727504384150.svg?colorB=7289DA&logo=data:image/png)](https://discord.gg/google-dev-community)\r\n\r\n</div>\r\n\r\nA collection of scripts I'm using to interact with the Gemini 1.5 Pro API.\r\n\r\n## Leaking API keys\r\n\r\nThe Google python APIs will include your API key in the error messages.\r\n\r\nClear your cell outputs before committing notebooks to reduce risk of leaking your API key.\r\n\r\n## Mimetypes\r\n\r\nSourced from https://www.iana.org/assignments/media-types/media-types.xhtml using\r\n\r\n```javascript\r\ncopy(Array.from(document.querySelectorAll(\"td:nth-child(2)\")).map(x => x.innerText).join(\"\\n\"))\r\n```\r\n#ENDREGION\r\n\r\nThis is the suite of scripts I am using to interact with the Gemini API.\r\nPropose a new action.\r\nProvide an English summary of what it will do.\r\nPropose the file name ending with .ps1, spaces are preferred over other separators.\r\nProvide the implementation.\r\n",
    "file_url": null,
    "file_mimetype": null
}