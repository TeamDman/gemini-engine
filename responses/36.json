{
    "payload": {
        "prompt": "# Summary\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\cablenetwork\\ICableBlock.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.common.cablenetwork;\r\n\r\npublic interface ICableBlock {\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\client\\render\\FormItemExtensions.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.client.render;\r\n\r\nimport net.minecraft.client.renderer.BlockEntityWithoutLevelRenderer;\r\nimport net.minecraftforge.client.extensions.common.IClientItemExtensions;\r\n\r\npublic class FormItemExtensions implements IClientItemExtensions {\r\n    private final BlockEntityWithoutLevelRenderer RENDERER = new FormItemRenderer();\r\n\r\n    @Override\r\n    public BlockEntityWithoutLevelRenderer getCustomRenderer() {\r\n        return RENDERER;\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\client\\gui\\screen\\ProgramEditScreen.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.client.gui.screen;\r\n\r\nimport ca.teamdman.sfm.client.ProgramSyntaxHighlightingHelper;\r\nimport ca.teamdman.sfm.client.ProgramTokenContextActions;\r\nimport ca.teamdman.sfm.client.gui.EditorUtils;\r\nimport ca.teamdman.sfm.common.Constants;\r\nimport com.mojang.blaze3d.vertex.PoseStack;\r\nimport com.mojang.blaze3d.vertex.Tesselator;\r\nimport com.mojang.math.Matrix4f;\r\nimport net.minecraft.client.Minecraft;\r\nimport net.minecraft.client.gui.GuiComponent;\r\nimport net.minecraft.client.gui.components.Button;\r\nimport net.minecraft.client.gui.components.MultiLineEditBox;\r\nimport net.minecraft.client.gui.components.MultilineTextField;\r\nimport net.minecraft.client.gui.screens.ConfirmScreen;\r\nimport net.minecraft.client.gui.screens.Screen;\r\nimport net.minecraft.client.renderer.LightTexture;\r\nimport net.minecraft.client.renderer.MultiBufferSource;\r\nimport net.minecraft.network.chat.CommonComponents;\r\nimport net.minecraft.network.chat.Component;\r\nimport net.minecraft.network.chat.MutableComponent;\r\nimport net.minecraft.network.chat.Style;\r\nimport org.lwjgl.glfw.GLFW;\r\n\r\nimport java.util.Collections;\r\nimport java.util.List;\r\nimport java.util.Optional;\r\nimport java.util.concurrent.atomic.AtomicInteger;\r\nimport java.util.function.Consumer;\r\n\r\nimport static ca.teamdman.sfm.common.Constants.LocalizationKeys.PROGRAM_EDIT_SCREEN_DONE_BUTTON_TOOLTIP;\r\n\r\npublic class ProgramEditScreen extends Screen {\r\n    private final String INITIAL_CONTENT;\r\n    private final Consumer<String> CALLBACK;\r\n    @SuppressWarnings(\"NotNullFieldNotInitialized\")\r\n    private MyMultiLineEditBox textarea;\r\n    private String lastProgram = \"\";\r\n    private List<MutableComponent> lastProgramWithSyntaxHighlighting = Collections.emptyList();\r\n\r\n    public ProgramEditScreen(String initialContent, Consumer<String> callback) {\r\n        super(Constants.LocalizationKeys.PROGRAM_EDIT_SCREEN_TITLE.getComponent());\r\n        this.INITIAL_CONTENT = initialContent;\r\n        this.CALLBACK = callback;\r\n    }\r\n\r\n    public static MutableComponent substring(MutableComponent component, int start, int end) {\r\n        var rtn = Component.empty();\r\n        AtomicInteger seen = new AtomicInteger(0);\r\n        component.visit((style, content) -> {\r\n            int contentStart = Math.max(start - seen.get(), 0);\r\n            int contentEnd = Math.min(end - seen.get(), content.length());\r\n\r\n            if (contentStart < contentEnd) {\r\n                rtn.append(Component.literal(content.substring(contentStart, contentEnd)).withStyle(style));\r\n            }\r\n            seen.addAndGet(content.length());\r\n            return Optional.empty();\r\n        }, Style.EMPTY);\r\n        return rtn;\r\n    }\r\n\r\n    @Override\r\n    protected void init() {\r\n        super.init();\r\n        assert this.minecraft != null;\r\n        this.minecraft.keyboardHandler.setSendRepeatsToGui(true);\r\n        this.textarea = this.addRenderableWidget(new MyMultiLineEditBox());\r\n        textarea.setValue(INITIAL_CONTENT);\r\n        this.setInitialFocus(textarea);\r\n\r\n        this.addRenderableWidget(new Button(\r\n                this.width / 2 - 2 - 150,\r\n                this.height / 2 - 100 + 195,\r\n                300,\r\n                20,\r\n                CommonComponents.GUI_DONE,\r\n                (p_97691_) -> this.onClosePerformCallback(),\r\n                (btn, pose, mx, my) -> renderTooltip(\r\n                        pose,\r\n                        font.split(\r\n                                PROGRAM_EDIT_SCREEN_DONE_BUTTON_TOOLTIP.getComponent(),\r\n                                Math.max(\r\n                                        width\r\n                                        / 2\r\n                                        - 43,\r\n                                        170\r\n                                )\r\n                        ),\r\n                        mx,\r\n                        my\r\n                )\r\n        ));\r\n    }\r\n\r\n    public void onClosePerformCallback() {\r\n        CALLBACK.accept(textarea.getValue());\r\n\r\n        assert this.minecraft != null;\r\n        this.minecraft.popGuiLayer();\r\n    }\r\n\r\n    @Override\r\n    public void onClose() {\r\n        if (!INITIAL_CONTENT.equals(textarea.getValue())) {\r\n            // if content changed => ask to save\r\n            assert this.minecraft != null;\r\n            // push confirm screen\r\n            this.minecraft.pushGuiLayer(new ConfirmScreen(\r\n                    doSave -> {\r\n                        this.minecraft.popGuiLayer();\r\n                        if (doSave) {\r\n                            onClosePerformCallback();\r\n                        } else {\r\n                            this.minecraft.popGuiLayer();\r\n                        }\r\n                    },\r\n                    Constants.LocalizationKeys.SAVE_CHANGES_CONFIRM_SCREEN_TITLE.getComponent(),\r\n                    Constants.LocalizationKeys.SAVE_CHANGES_CONFIRM_SCREEN_MESSAGE.getComponent(),\r\n                    Constants.LocalizationKeys.SAVE_CHANGES_CONFIRM_SCREEN_YES_BUTTON.getComponent(),\r\n                    Constants.LocalizationKeys.SAVE_CHANGES_CONFIRM_SCREEN_NO_BUTTON.getComponent()\r\n            ));\r\n        } else {\r\n            super.onClose();\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public boolean keyReleased(int pKeyCode, int pScanCode, int pModifiers) {\r\n        if (pKeyCode == GLFW.GLFW_KEY_LEFT_CONTROL || pKeyCode == GLFW.GLFW_KEY_RIGHT_CONTROL) {\r\n            // if control released => update syntax highlighting\r\n            textarea.rebuild(Screen.hasControlDown());\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    @Override\r\n    public boolean charTyped(char pCodePoint, int pModifiers) {\r\n        if (Screen.hasControlDown() && pCodePoint == ' ') {\r\n            return true;\r\n        }\r\n        return super.charTyped(pCodePoint, pModifiers);\r\n    }\r\n\r\n    public void scrollToTop() {\r\n        textarea.setScrollAmount(0d);\r\n    }\r\n\r\n    @Override\r\n    public boolean keyPressed(int pKeyCode, int pScanCode, int pModifiers) {\r\n        if ((pKeyCode == GLFW.GLFW_KEY_ENTER || pKeyCode == GLFW.GLFW_KEY_KP_ENTER) && Screen.hasShiftDown()) {\r\n            onClosePerformCallback();\r\n            return true;\r\n        }\r\n        if (pKeyCode == GLFW.GLFW_KEY_TAB) {\r\n            // if tab pressed with no selection and not holding shift => insert 4 spaces\r\n            // if tab pressed with no selection and holding shift => de-indent current line\r\n            // if tab pressed with selection and not holding shift => de-indent lines containing selection 4 spaces\r\n            // if tab pressed with selection and holding shift => indent lines containing selection 4 spaces\r\n            String content = textarea.getValue();\r\n            int cursor = textarea.getCursorPosition();\r\n            int selectionCursor = textarea.getSelectionCursorPosition();\r\n            EditorUtils.ManipulationResult result;\r\n            if (Screen.hasShiftDown()) { // de-indent\r\n                result = EditorUtils.deindent(content, cursor, selectionCursor);\r\n            } else { // indent\r\n                result = EditorUtils.indent(content, cursor, selectionCursor);\r\n            }\r\n            textarea.setValue(result.content());\r\n            textarea.setCursorPosition(result.cursorPosition());\r\n            textarea.setSelectionCursorPosition(result.selectionCursorPosition());\r\n            return true;\r\n        }\r\n        if (pKeyCode == GLFW.GLFW_KEY_LEFT_CONTROL || pKeyCode == GLFW.GLFW_KEY_RIGHT_CONTROL) {\r\n            // if control pressed => update syntax highlighting\r\n            textarea.rebuild(Screen.hasControlDown());\r\n            return true;\r\n        }\r\n        if (pKeyCode == GLFW.GLFW_KEY_SLASH && Screen.hasControlDown()) {\r\n            // toggle line comments for selected lines\r\n            String content = textarea.getValue();\r\n            int cursor = textarea.getCursorPosition();\r\n            int selectionCursor = textarea.getSelectionCursorPosition();\r\n            EditorUtils.ManipulationResult result = EditorUtils.toggleComments(content, cursor, selectionCursor);\r\n            textarea.setValue(result.content());\r\n            textarea.setCursorPosition(result.cursorPosition());\r\n            textarea.setSelectionCursorPosition(result.selectionCursorPosition());\r\n            return true;\r\n        }\r\n        if (pKeyCode == GLFW.GLFW_KEY_SPACE && Screen.hasControlDown()) {\r\n            ProgramTokenContextActions.getContextAction(\r\n                            textarea.getValue(),\r\n                            textarea.getCursorPosition()\r\n                    )\r\n                    .ifPresent(Runnable::run);\r\n\r\n            // disable the underline since it doesn't refresh when the context action closes\r\n            textarea.rebuild(false);\r\n            return true;\r\n        }\r\n        return super.keyPressed(pKeyCode, pScanCode, pModifiers);\r\n    }\r\n\r\n    @Override\r\n    public void resize(Minecraft mc, int x, int y) {\r\n        var prev = this.textarea.getValue();\r\n        init(mc, x, y);\r\n        super.resize(mc, x, y);\r\n        this.textarea.setValue(prev);\r\n    }\r\n\r\n    @Override\r\n    public void render(PoseStack poseStack, int mx, int my, float partialTicks) {\r\n        this.renderBackground(poseStack);\r\n        super.render(poseStack, mx, my, partialTicks);\r\n    }\r\n\r\n    private class MyMultiLineEditBox extends MultiLineEditBox {\r\n        public MyMultiLineEditBox() {\r\n            super(\r\n                    ProgramEditScreen.this.font,\r\n                    ProgramEditScreen.this.width / 2 - 200,\r\n                    ProgramEditScreen.this.height / 2 - 110,\r\n                    400,\r\n                    200,\r\n                    Component.literal(\"\"),\r\n                    Component.literal(\"\")\r\n            );\r\n        }\r\n\r\n        public int getCursorPosition() {\r\n            return this.textField.cursor;\r\n        }\r\n\r\n        public void setCursorPosition(int cursor) {\r\n            this.textField.cursor = cursor;\r\n        }\r\n\r\n        @Override\r\n        public boolean mouseClicked(double p_239101_, double p_239102_, int p_239103_) {\r\n            try {\r\n                return super.mouseClicked(p_239101_, p_239102_, p_239103_);\r\n            } catch (Exception e) {\r\n                e.printStackTrace();\r\n                return false;\r\n            }\r\n        }\r\n\r\n        public int getSelectionCursorPosition() {\r\n            return this.textField.selectCursor;\r\n        }\r\n\r\n        public void setSelectionCursorPosition(int cursor) {\r\n            this.textField.selectCursor = cursor;\r\n        }\r\n\r\n        private void rebuild(boolean showContextActionHints) {\r\n            lastProgram = this.textField.value();\r\n            lastProgramWithSyntaxHighlighting = ProgramSyntaxHighlightingHelper.withSyntaxHighlighting(\r\n                    lastProgram,\r\n                    showContextActionHints\r\n            );\r\n        }\r\n\r\n        @Override\r\n        protected void renderContents(PoseStack poseStack, int mx, int my, float partialTicks) {\r\n            Matrix4f matrix4f = poseStack.last().pose();\r\n            if (!lastProgram.equals(this.textField.value())) {\r\n                rebuild(Screen.hasControlDown());\r\n            }\r\n            List<MutableComponent> lines = lastProgramWithSyntaxHighlighting;\r\n            boolean isCursorVisible = this.isFocused() && this.frame / 6 % 2 == 0;\r\n            boolean isCursorAtEndOfLine = false;\r\n            int cursorIndex = textField.cursor();\r\n            int lineX = this.x + this.innerPadding();\r\n            int lineY = this.y + this.innerPadding();\r\n            int charCount = 0;\r\n            int cursorX = 0;\r\n            int cursorY = 0;\r\n            MultilineTextField.StringView selectedRange = this.textField.getSelected();\r\n            int selectionStart = selectedRange.beginIndex();\r\n            int selectionEnd = selectedRange.endIndex();\r\n\r\n            for (int line = 0; line < lines.size(); ++line) {\r\n                var componentColoured = lines.get(line);\r\n                int lineLength = componentColoured.getString().length();\r\n                int lineHeight = this.font.lineHeight + (line == 0 ? 2 : 0);\r\n                boolean cursorOnThisLine = isCursorVisible\r\n                                           && cursorIndex >= charCount\r\n                                           && cursorIndex <= charCount + lineLength;\r\n                var buffer = MultiBufferSource.immediate(Tesselator.getInstance().getBuilder());\r\n\r\n                if (cursorOnThisLine) {\r\n                    isCursorAtEndOfLine = cursorIndex == charCount + lineLength;\r\n                    cursorY = lineY;\r\n                    // we draw the raw before coloured in case of token recognition errors\r\n                    // draw before cursor\r\n                    cursorX = this.font.drawInBatch(\r\n                            substring(componentColoured, 0, cursorIndex - charCount),\r\n                            lineX,\r\n                            lineY,\r\n                            -1,\r\n                            true,\r\n                            matrix4f,\r\n                            buffer,\r\n                            false,\r\n                            0,\r\n                            LightTexture.FULL_BRIGHT\r\n                    ) - 1;\r\n                    this.font.drawInBatch(\r\n                            substring(componentColoured, cursorIndex - charCount, lineLength),\r\n                            cursorX,\r\n                            lineY,\r\n                            -1,\r\n                            true,\r\n                            matrix4f,\r\n                            buffer,\r\n                            false,\r\n                            0,\r\n                            LightTexture.FULL_BRIGHT\r\n                    );\r\n                } else {\r\n                    this.font.drawInBatch(\r\n                            componentColoured,\r\n                            lineX,\r\n                            lineY,\r\n                            -1,\r\n                            true,\r\n                            matrix4f,\r\n                            buffer,\r\n                            false,\r\n                            0,\r\n                            LightTexture.FULL_BRIGHT\r\n                    );\r\n                }\r\n                buffer.endBatch();\r\n\r\n                // Check if the selection is within the current line\r\n                if (selectionStart <= charCount + lineLength && selectionEnd > charCount) {\r\n                    int lineSelectionStart = Math.max(selectionStart - charCount, 0);\r\n                    int lineSelectionEnd = Math.min(selectionEnd - charCount, lineLength);\r\n\r\n                    int highlightStartX = this.font.width(substring(componentColoured, 0, lineSelectionStart));\r\n                    int highlightEndX = this.font.width(substring(componentColoured, 0, lineSelectionEnd));\r\n\r\n                    this.renderHighlight(\r\n                            poseStack,\r\n                            lineX + highlightStartX,\r\n                            lineY,\r\n                            lineX + highlightEndX,\r\n                            lineY + lineHeight\r\n                    );\r\n                }\r\n\r\n                lineY += lineHeight;\r\n                charCount += lineLength + 1;\r\n            }\r\n\r\n            if (isCursorAtEndOfLine) {\r\n                this.font.drawShadow(poseStack, \"_\", cursorX, cursorY, -1);\r\n            } else {\r\n                GuiComponent.fill(poseStack, cursorX, cursorY - 1, cursorX + 1, cursorY + 1 + 9, -1);\r\n            }\r\n        }\r\n\r\n    }\r\n}\r\n\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\resourcetype\\ItemResourceType.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.common.resourcetype;\r\n\r\nimport net.minecraft.world.item.Item;\r\nimport net.minecraft.world.item.ItemStack;\r\nimport net.minecraftforge.common.capabilities.ForgeCapabilities;\r\nimport net.minecraftforge.items.IItemHandler;\r\nimport net.minecraftforge.registries.ForgeRegistries;\r\nimport net.minecraftforge.registries.IForgeRegistry;\r\n\r\npublic class ItemResourceType extends ResourceType<ItemStack, Item, IItemHandler> {\r\n    public ItemResourceType() {\r\n        super(ForgeCapabilities.ITEM_HANDLER);\r\n    }\r\n\r\n    @Override\r\n    public IForgeRegistry<Item> getRegistry() {\r\n        return ForgeRegistries.ITEMS;\r\n    }\r\n\r\n\r\n    @Override\r\n    public Item getItem(ItemStack itemStack) {\r\n        return itemStack.getItem();\r\n    }\r\n\r\n    @Override\r\n    public ItemStack copy(ItemStack stack) {\r\n        return stack.copy();\r\n    }\r\n\r\n    @Override\r\n    protected ItemStack setCount(ItemStack stack, long amount) {\r\n        int finalAmount = amount > Integer.MAX_VALUE ? Integer.MAX_VALUE : (int) amount;\r\n        stack.setCount(finalAmount);\r\n        return stack;\r\n    }\r\n\r\n    @Override\r\n    public long getAmount(ItemStack stack) {\r\n        return stack.getCount();\r\n    }\r\n\r\n    @Override\r\n    public ItemStack getStackInSlot(IItemHandler cap, int slot) {\r\n        return cap.getStackInSlot(slot);\r\n    }\r\n\r\n    @Override\r\n    public ItemStack extract(IItemHandler handler, int slot, long amount, boolean simulate) {\r\n        int finalAmount = amount > Integer.MAX_VALUE ? Integer.MAX_VALUE : (int) amount;\r\n        // Mekanism bin intentionally only returns 64x stacks without going past the max stack size\r\n        // https://github.com/mekanism/Mekanism/blob/f92b48a49e0766cd3aa78e95c9c4a47ba90402f5/src/main/java/mekanism/common/inventory/slot/BasicInventorySlot.java#L174-L175\r\n        return handler.extractItem(slot, finalAmount, simulate);\r\n    }\r\n\r\n    @Override\r\n    public boolean matchesStackType(Object o) {\r\n        return o instanceof ItemStack;\r\n    }\r\n\r\n    @Override\r\n    public boolean matchesCapabilityType(Object o) {\r\n        return o instanceof IItemHandler;\r\n    }\r\n\r\n    @Override\r\n    public int getSlots(IItemHandler handler) {\r\n        return handler.getSlots();\r\n    }\r\n\r\n    @Override\r\n    public long getMaxStackSize(ItemStack itemStack) {\r\n        return itemStack.getMaxStackSize();\r\n    }\r\n\r\n    @Override\r\n    public long getMaxStackSize(IItemHandler handler, int slot) {\r\n        return handler.getSlotLimit(slot);\r\n    }\r\n\r\n    /**\r\n     * @return remaining stack that was not inserted\r\n     */\r\n    @Override\r\n    public ItemStack insert(IItemHandler handler, int slot, ItemStack stack, boolean simulate) {\r\n        return handler.insertItem(slot, stack, simulate);\r\n    }\r\n\r\n    @Override\r\n    public boolean isEmpty(ItemStack stack) {\r\n        return stack.isEmpty();\r\n    }\r\n\r\n    @Override\r\n    public ItemStack getEmptyStack() {\r\n        return ItemStack.EMPTY;\r\n    }\r\n\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\net\\ServerboundLabelGunClearPacket.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.common.net;\r\n\r\nimport ca.teamdman.sfm.common.item.LabelGunItem;\r\nimport ca.teamdman.sfm.common.program.LabelPositionHolder;\r\nimport net.minecraft.network.FriendlyByteBuf;\r\nimport net.minecraft.world.InteractionHand;\r\nimport net.minecraftforge.network.NetworkEvent;\r\n\r\nimport java.util.function.Supplier;\r\n\r\npublic record ServerboundLabelGunClearPacket(\r\n        InteractionHand hand\r\n) {\r\n    public static void encode(ServerboundLabelGunClearPacket msg, FriendlyByteBuf buf) {\r\n        buf.writeEnum(msg.hand);\r\n    }\r\n\r\n    public static ServerboundLabelGunClearPacket decode(\r\n            FriendlyByteBuf buf\r\n    ) {\r\n        return new ServerboundLabelGunClearPacket(buf.readEnum(InteractionHand.class));\r\n    }\r\n\r\n    public static void handle(\r\n            ServerboundLabelGunClearPacket msg, Supplier<NetworkEvent.Context> ctx\r\n    ) {\r\n        ctx.get().enqueueWork(() -> {\r\n            var sender = ctx.get().getSender();\r\n            if (sender == null) {\r\n                return;\r\n            }\r\n            var stack = sender.getItemInHand(msg.hand);\r\n            if (stack.getItem() instanceof LabelGunItem) {\r\n                LabelPositionHolder.empty().save(stack);\r\n            }\r\n        });\r\n        ctx.get().setPacketHandled(true);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfml\\ast\\BoolExpr.java\r\n\r\n````java\r\npackage ca.teamdman.sfml.ast;\r\n\r\nimport ca.teamdman.sfm.common.program.ProgramContext;\r\n\r\nimport java.util.function.Predicate;\r\n\r\npublic record BoolExpr(\r\n        Predicate<ProgramContext> pred,\r\n        String sourceCode\r\n) implements Predicate<ProgramContext>, ASTNode {\r\n\r\n    @Override\r\n    public boolean test(ProgramContext context) {\r\n        return pred.test(context);\r\n    }\r\n\r\n    public BoolExpr negate() {\r\n        return new BoolExpr(pred.negate(), \"NOT \" + sourceCode);\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return sourceCode;\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\block\\CableBlock.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.common.block;\r\n\r\nimport ca.teamdman.sfm.common.cablenetwork.CableNetworkManager;\r\nimport ca.teamdman.sfm.common.cablenetwork.ICableBlock;\r\nimport net.minecraft.core.BlockPos;\r\nimport net.minecraft.server.level.ServerLevel;\r\nimport net.minecraft.world.level.Level;\r\nimport net.minecraft.world.level.block.Block;\r\nimport net.minecraft.world.level.block.SoundType;\r\nimport net.minecraft.world.level.block.state.BlockState;\r\nimport net.minecraft.world.level.material.Material;\r\n\r\npublic class CableBlock extends Block implements ICableBlock {\r\n\r\n    public CableBlock() {\r\n        super(Block.Properties\r\n                      .of(Material.METAL)\r\n                      .destroyTime(1f)\r\n                      .sound(SoundType.METAL));\r\n    }\r\n\r\n    @SuppressWarnings(\"deprecation\")\r\n    @Override\r\n    public void neighborChanged(\r\n            BlockState state,\r\n            Level level,\r\n            BlockPos pos,\r\n            Block block,\r\n            BlockPos fromPos,\r\n            boolean movedByPiston\r\n    ) {\r\n        if (!(level instanceof ServerLevel)) return;\r\n        // reassess neighbours of the CABLE's position\r\n        CableNetworkManager\r\n                .getOrRegisterNetworkFromCablePosition(level, pos)\r\n                .ifPresent(network -> network.rebuildAdjacentInventories(pos));\r\n    }\r\n\r\n    @SuppressWarnings(\"deprecation\")\r\n    @Override\r\n    public void onPlace(BlockState state, Level world, BlockPos pos, BlockState oldState, boolean isMoving) {\r\n        CableNetworkManager.getOrRegisterNetworkFromCablePosition(world, pos);\r\n    }\r\n\r\n    @SuppressWarnings(\"deprecation\")\r\n    @Override\r\n    public void onRemove(BlockState state, Level level, BlockPos pos, BlockState newState, boolean isMoving) {\r\n        CableNetworkManager.removeCable(level, pos);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\block\\TestBarrelBlock.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.common.block;\r\n\r\nimport net.minecraft.core.BlockPos;\r\nimport net.minecraft.world.level.Level;\r\nimport net.minecraft.world.level.block.BarrelBlock;\r\nimport net.minecraft.world.level.block.SoundType;\r\nimport net.minecraft.world.level.block.state.BlockBehaviour;\r\nimport net.minecraft.world.level.block.state.BlockState;\r\nimport net.minecraft.world.level.material.Material;\r\n\r\npublic class TestBarrelBlock extends BarrelBlock {\r\n    public TestBarrelBlock() {\r\n        super(BlockBehaviour.Properties.of(Material.WOOD).strength(2.5F).sound(SoundType.WOOD));\r\n    }\r\n\r\n    @Override\r\n    public void onRemove(BlockState pState, Level pLevel, BlockPos pPos, BlockState pNewState, boolean pIsMoving) {\r\n//        var container = (Container) pLevel.getBlockEntity(pPos);\r\n//        int stacks = IntStream.range(0, container.getContainerSize()).mapToObj(container::getItem).mapToInt(ItemStack::getCount).sum();\r\n//        System.out.println(\"test barrel removed \" + stacks/64);\r\n        if (!pState.is(pNewState.getBlock())) {\r\n            pLevel.removeBlockEntity(pPos);\r\n            super.onRemove(pState, pLevel, pPos, pNewState, pIsMoving);\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\resourcetype\\ForgeEnergyResourceType.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.common.resourcetype;\r\n\r\nimport net.minecraft.resources.ResourceLocation;\r\nimport net.minecraftforge.common.capabilities.ForgeCapabilities;\r\nimport net.minecraftforge.energy.IEnergyStorage;\r\nimport net.minecraftforge.registries.IForgeRegistry;\r\nimport org.apache.commons.lang3.NotImplementedException;\r\n\r\npublic class ForgeEnergyResourceType extends ResourceType<Integer, Class<Integer>, IEnergyStorage> {\r\n    public ForgeEnergyResourceType() {\r\n        super(ForgeCapabilities.ENERGY);\r\n    }\r\n\r\n    @Override\r\n    public long getAmount(Integer integer) {\r\n        return integer;\r\n    }\r\n\r\n    @Override\r\n    public Integer getStackInSlot(IEnergyStorage iEnergyStorage, int slot) {\r\n        return iEnergyStorage.getEnergyStored();\r\n    }\r\n\r\n    @Override\r\n    public Integer extract(IEnergyStorage iEnergyStorage, int slot, long amount, boolean simulate) {\r\n        int finalAmount = amount > Integer.MAX_VALUE ? Integer.MAX_VALUE : (int) amount;\r\n        return iEnergyStorage.extractEnergy(finalAmount, simulate);\r\n    }\r\n\r\n    @Override\r\n    public int getSlots(IEnergyStorage handler) {\r\n        return 1;\r\n    }\r\n\r\n    @Override\r\n    public long getMaxStackSize(Integer integer) {\r\n        return Long.MAX_VALUE;\r\n    }\r\n\r\n    @Override\r\n    public long getMaxStackSize(IEnergyStorage iEnergyStorage, int slot) {\r\n        return iEnergyStorage.getMaxEnergyStored();\r\n    }\r\n\r\n    @Override\r\n    public Integer insert(IEnergyStorage iEnergyStorage, int slot, Integer integer, boolean simulate) {\r\n        return integer - iEnergyStorage.receiveEnergy(integer, simulate);\r\n    }\r\n\r\n    @Override\r\n    public boolean isEmpty(Integer integer) {\r\n        return integer == 0;\r\n    }\r\n\r\n    @Override\r\n    public boolean matchesStackType(Object o) {\r\n        return o instanceof Integer;\r\n    }\r\n\r\n    @Override\r\n    public boolean matchesCapabilityType(Object o) {\r\n        return o instanceof IEnergyStorage;\r\n    }\r\n\r\n    @Override\r\n    public Integer getEmptyStack() {\r\n        return 0;\r\n    }\r\n\r\n    public static final ResourceLocation REGISTRY_KEY = new ResourceLocation(\"forge\", \"energy\");\r\n\r\n    @Override\r\n    public ResourceLocation getRegistryKey(Integer integer) {\r\n        return REGISTRY_KEY;\r\n    }\r\n\r\n    @Override\r\n    public IForgeRegistry<Class<Integer>> getRegistry() {\r\n        throw new NotImplementedException();\r\n    }\r\n\r\n    @Override\r\n    public boolean registryKeyExists(ResourceLocation location) {\r\n        return location.equals(REGISTRY_KEY);\r\n    }\r\n\r\n    @Override\r\n    public Class<Integer> getItem(Integer integer) {\r\n        return Integer.class;\r\n    }\r\n\r\n    @Override\r\n    public Integer copy(Integer integer) {\r\n        return integer;\r\n    }\r\n\r\n    @Override\r\n    protected Integer setCount(Integer integer, long amount) {\r\n        return amount > Integer.MAX_VALUE ? Integer.MAX_VALUE : (int) amount;\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\SFM.java\r\n\r\n````java\r\npackage ca.teamdman.sfm;\r\n\r\nimport ca.teamdman.sfm.client.registry.SFMMenuScreens;\r\nimport ca.teamdman.sfm.common.registry.*;\r\nimport net.minecraftforge.fml.common.Mod;\r\nimport net.minecraftforge.fml.event.lifecycle.FMLClientSetupEvent;\r\nimport net.minecraftforge.fml.event.lifecycle.FMLCommonSetupEvent;\r\nimport net.minecraftforge.fml.javafmlmod.FMLJavaModLoadingContext;\r\nimport org.apache.logging.log4j.LogManager;\r\nimport org.apache.logging.log4j.Logger;\r\n\r\n@Mod(\"sfm\")\r\npublic class SFM {\r\n    public static final String MOD_ID = \"sfm\";\r\n    public static final Logger LOGGER = LogManager.getLogger(SFM.MOD_ID);\r\n\r\n    public SFM() {\r\n        var bus = FMLJavaModLoadingContext\r\n                .get()\r\n                .getModEventBus();\r\n        SFMBlocks.register(bus);\r\n        SFMItems.register(bus);\r\n        SFMResourceTypes.register(bus);\r\n        SFMBlockEntities.register(bus);\r\n        SFMCapabilityProviderMappers.register(bus);\r\n        SFMMenus.register(bus);\r\n        SFMRecipeTypes.register(bus);\r\n        SFMRecipeSerializers.register(bus);\r\n        bus.addListener((FMLClientSetupEvent e) -> SFMMenuScreens.register());\r\n        bus.addListener((FMLCommonSetupEvent e) -> SFMPackets.register());\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\cablenetwork\\CableNetwork.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.common.cablenetwork;\r\n\r\nimport ca.teamdman.sfm.common.util.SFMUtils;\r\nimport com.mojang.datafixers.util.Pair;\r\nimport it.unimi.dsi.fastutil.longs.Long2ObjectMap;\r\nimport it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;\r\nimport it.unimi.dsi.fastutil.longs.LongOpenHashSet;\r\nimport it.unimi.dsi.fastutil.longs.LongSet;\r\nimport net.minecraft.core.BlockPos;\r\nimport net.minecraft.core.Direction;\r\nimport net.minecraft.world.level.Level;\r\nimport net.minecraftforge.common.capabilities.ICapabilityProvider;\r\n\r\nimport javax.annotation.Nullable;\r\nimport java.util.ArrayList;\r\nimport java.util.Arrays;\r\nimport java.util.List;\r\nimport java.util.Optional;\r\nimport java.util.stream.Stream;\r\n\r\npublic class CableNetwork {\r\n\r\n    protected final Level LEVEL;\r\n    protected final LongSet CABLE_POSITIONS = new LongOpenHashSet();\r\n    protected final Long2ObjectMap<ICapabilityProvider> CAPABILITY_PROVIDER_BY_POSITION = new Long2ObjectOpenHashMap<>();\r\n\r\n    public CableNetwork(Level level) {\r\n        this.LEVEL = level;\r\n    }\r\n\r\n    /**\r\n     * Only cable blocks are valid network members\r\n     */\r\n    public static boolean isCable(@Nullable Level world, BlockPos cablePos) {\r\n        if (world == null) return false;\r\n        return world\r\n                .getBlockState(cablePos)\r\n                .getBlock() instanceof ICableBlock;\r\n    }\r\n\r\n    public void rebuildNetwork(BlockPos start) {\r\n        CABLE_POSITIONS.clear();\r\n        CAPABILITY_PROVIDER_BY_POSITION.clear();\r\n        discoverCables(start).forEach(this::addCable);\r\n    }\r\n\r\n    public void rebuildNetworkFromCache(BlockPos start, CableNetwork cache) {\r\n        CABLE_POSITIONS.clear();\r\n        CAPABILITY_PROVIDER_BY_POSITION.clear();\r\n\r\n        // discover existing cables\r\n        var cables = SFMUtils.getRecursiveStream((current, next, results) -> {\r\n            results.accept(current);\r\n            for (Direction d : Direction.values()) {\r\n                BlockPos offset = current.offset(d.getNormal());\r\n                if (cache.containsCablePosition(offset)) {\r\n                    next.accept(offset);\r\n                }\r\n            }\r\n        }, start).toList();\r\n        for (BlockPos cablePos : cables) {\r\n            CABLE_POSITIONS.add(cablePos.asLong());\r\n        }\r\n        // discover existing capability providers\r\n        cables\r\n                .stream()\r\n                .flatMap(cablePos -> Arrays.stream(Direction.values()).map(Direction::getNormal).map(cablePos::offset))\r\n                .distinct()\r\n                .filter(pos -> cache.CAPABILITY_PROVIDER_BY_POSITION.containsKey(pos.asLong()))\r\n                .map(capPos -> Pair.of(capPos, cache.CAPABILITY_PROVIDER_BY_POSITION.get(capPos.asLong())))\r\n                .forEach(pair -> CAPABILITY_PROVIDER_BY_POSITION.put(pair.getFirst().asLong(), pair.getSecond()));\r\n    }\r\n\r\n    public Stream<BlockPos> discoverCables(BlockPos startPos) {\r\n        return SFMUtils.getRecursiveStream((current, next, results) -> {\r\n            results.accept(current);\r\n            for (Direction d : Direction.values()) {\r\n                BlockPos offset = current.offset(d.getNormal());\r\n                if (isCable(getLevel(), offset)) {\r\n                    next.accept(offset);\r\n                }\r\n            }\r\n        }, startPos);\r\n    }\r\n\r\n    public void addCable(BlockPos pos) {\r\n        boolean isNewMember = CABLE_POSITIONS.add(pos.asLong());\r\n        if (isNewMember) {\r\n            rebuildAdjacentInventories(pos);\r\n        }\r\n    }\r\n\r\n    public Level getLevel() {\r\n        return LEVEL;\r\n    }\r\n\r\n    /**\r\n     * Collects the capability providers of blocks neighbouring the cable\r\n     *\r\n     * @param cablePos position of the cable\r\n     */\r\n    public void rebuildAdjacentInventories(BlockPos cablePos) {\r\n        Arrays\r\n                .stream(Direction.values())\r\n                .map(Direction::getNormal)\r\n                .map(cablePos::offset)\r\n                .distinct()\r\n                .peek(pos -> CAPABILITY_PROVIDER_BY_POSITION.remove(pos.asLong())) // Bust the cache\r\n                .filter(this::isAdjacentToCable) // Verify if should [re]join network\r\n                .map(pos -> SFMUtils\r\n                        .discoverCapabilityProvider(LEVEL, pos)\r\n                        .map(prov -> Pair.of(pos, prov))) // Check if we can get capabilities from this block\r\n                .filter(Optional::isPresent)\r\n                .map(Optional::get)\r\n                .forEach(prov -> CAPABILITY_PROVIDER_BY_POSITION.put(\r\n                        prov.getFirst().asLong(),\r\n                        prov.getSecond()\r\n                )); // track it\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"CableNetwork{level=\"\r\n               + getLevel().dimension().location()\r\n               + \", #cables=\"\r\n               + getCableCount()\r\n               + \", #capabilityProviders=\"\r\n               + CAPABILITY_PROVIDER_BY_POSITION.size()\r\n               + \"}\";\r\n    }\r\n\r\n    /**\r\n     * Cables should only join the network if they would be touching a cable already in the network\r\n     *\r\n     * @param pos Candidate cable position\r\n     * @return {@code true} if adjacent to cable in network\r\n     */\r\n    public boolean isAdjacentToCable(BlockPos pos) {\r\n        for (Direction direction : Direction.values()) {\r\n            if (containsCablePosition(pos.offset(direction.getNormal()))) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    public boolean containsCablePosition(BlockPos pos) {\r\n        return CABLE_POSITIONS.contains(pos.asLong());\r\n    }\r\n\r\n    public boolean isInNetwork(BlockPos pos) {\r\n        return CAPABILITY_PROVIDER_BY_POSITION.containsKey(pos.asLong());\r\n    }\r\n\r\n\r\n    public Optional<ICapabilityProvider> getCapabilityProvider(BlockPos pos) {\r\n        return Optional.ofNullable(CAPABILITY_PROVIDER_BY_POSITION.get(pos.asLong()));\r\n    }\r\n\r\n    public int getCableCount() {\r\n        return CABLE_POSITIONS.size();\r\n    }\r\n\r\n    /**\r\n     * Merges a network into this one, such as when a cable connects two networks\r\n     *\r\n     * @param other Foreign network\r\n     */\r\n    public void mergeNetwork(CableNetwork other) {\r\n        CABLE_POSITIONS.addAll(other.CABLE_POSITIONS);\r\n        CAPABILITY_PROVIDER_BY_POSITION.putAll(other.CAPABILITY_PROVIDER_BY_POSITION);\r\n    }\r\n\r\n    public boolean isEmpty() {\r\n        return CABLE_POSITIONS.isEmpty();\r\n    }\r\n\r\n    public Stream<BlockPos> getCablePositions() {\r\n        return CABLE_POSITIONS.longStream().mapToObj(BlockPos::of);\r\n    }\r\n\r\n    public Stream<BlockPos> getCapabilityProviderPositions() {\r\n        return CAPABILITY_PROVIDER_BY_POSITION.keySet().longStream().mapToObj(BlockPos::of);\r\n    }\r\n\r\n    /**\r\n     * Discover what networks would exist if this network did not have a cable at {@code cablePos}.\r\n     * @param cablePos cable position to be removed\r\n     * @return resulting networks to replace this network\r\n     */\r\n    protected List<CableNetwork> withoutCable(BlockPos cablePos) {\r\n        CABLE_POSITIONS.remove(cablePos.asLong());\r\n        List<CableNetwork> branches = new ArrayList<>();\r\n        for (var direction : Direction.values()) {\r\n            var offsetPos = cablePos.offset(direction.getNormal());\r\n            if (!containsCablePosition(offsetPos)) continue;\r\n            // make sure that a branch network doesn't already contain this cable\r\n            if (branches.stream().anyMatch(n -> n.containsCablePosition(offsetPos))) continue;\r\n            var branchNetwork = new CableNetwork(this.getLevel());\r\n            branchNetwork.rebuildNetworkFromCache(offsetPos, this);\r\n            branches.add(branchNetwork);\r\n        }\r\n        return branches;\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\util\\OpenContainerTracker.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.common.util;\r\n\r\nimport ca.teamdman.sfm.SFM;\r\nimport net.minecraft.server.level.ServerPlayer;\r\nimport net.minecraft.world.inventory.AbstractContainerMenu;\r\nimport net.minecraftforge.eventbus.api.SubscribeEvent;\r\nimport net.minecraftforge.fml.common.Mod;\r\n\r\nimport java.util.Map;\r\nimport java.util.WeakHashMap;\r\nimport java.util.stream.Stream;\r\n\r\nimport static net.minecraftforge.event.entity.player.PlayerContainerEvent.Close;\r\nimport static net.minecraftforge.event.entity.player.PlayerContainerEvent.Open;\r\n\r\n@Mod.EventBusSubscriber(bus = Mod.EventBusSubscriber.Bus.FORGE, modid = SFM.MOD_ID)\r\npublic class OpenContainerTracker {\r\n    private static final Map<ServerPlayer, AbstractContainerMenu> OPEN_CONTAINERS = new WeakHashMap<>();\r\n\r\n    @SuppressWarnings(\"unchecked\")\r\n    public static <T extends AbstractContainerMenu> Stream<Map.Entry<ServerPlayer, T>> getPlayersWithOpenContainer(Class<T> menuClass) {\r\n        return OPEN_CONTAINERS.entrySet().stream()\r\n                .filter(e -> menuClass.isInstance(e.getValue()))\r\n                .map(e -> (Map.Entry<ServerPlayer, T>) e);\r\n    }\r\n\r\n    @SubscribeEvent\r\n    public static void onOpenContainer(Open event) {\r\n        if (event.getEntity() instanceof ServerPlayer serverPlayer) {\r\n            OPEN_CONTAINERS.put(serverPlayer, event.getContainer());\r\n        }\r\n    }\r\n\r\n    @SubscribeEvent\r\n    public static void onCloseContainer(Close event) {\r\n        if (event.getEntity() instanceof ServerPlayer serverPlayer) {\r\n            OPEN_CONTAINERS.remove(serverPlayer);\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\net\\ClientboundInputInspectionResultsPacket.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.common.net;\r\n\r\nimport ca.teamdman.sfm.client.ClientStuff;\r\nimport net.minecraft.network.FriendlyByteBuf;\r\nimport net.minecraftforge.network.NetworkEvent;\r\n\r\nimport java.util.function.Supplier;\r\n\r\npublic record ClientboundInputInspectionResultsPacket(\r\n        String results\r\n) {\r\n    public static final int MAX_RESULTS_LENGTH = 20480;\r\n\r\n    public static void encode(\r\n            ClientboundInputInspectionResultsPacket msg, FriendlyByteBuf friendlyByteBuf\r\n    ) {\r\n        friendlyByteBuf.writeUtf(msg.results(), MAX_RESULTS_LENGTH);\r\n    }\r\n\r\n    public static ClientboundInputInspectionResultsPacket decode(FriendlyByteBuf friendlyByteBuf) {\r\n        return new ClientboundInputInspectionResultsPacket(\r\n                friendlyByteBuf.readUtf(MAX_RESULTS_LENGTH)\r\n        );\r\n    }\r\n\r\n    public static void handle(\r\n            ClientboundInputInspectionResultsPacket msg, Supplier<NetworkEvent.Context> contextSupplier\r\n    ) {\r\n        contextSupplier.get().enqueueWork(() -> ClientStuff.showProgramEditScreen(msg.results, next -> {\r\n        }));\r\n        contextSupplier.get().setPacketHandled(true);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfml\\ast\\Limit.java\r\n\r\n````java\r\npackage ca.teamdman.sfml.ast;\r\n\r\nimport static ca.teamdman.sfml.ast.ResourceQuantity.IdExpansionBehaviour.NO_EXPAND;\r\n\r\npublic record Limit(\r\n        ResourceQuantity quantity,\r\n        ResourceQuantity retention\r\n) implements ASTNode {\r\n    public static final Limit MAX_QUANTITY_NO_RETENTION = new Limit(\r\n            new ResourceQuantity(new Number(Long.MAX_VALUE), NO_EXPAND),\r\n            new ResourceQuantity(new Number(0), NO_EXPAND)\r\n    );\r\n    public static final Limit MAX_QUANTITY_MAX_RETENTION = new Limit(\r\n            new ResourceQuantity(new Number(Long.MAX_VALUE), NO_EXPAND),\r\n            new ResourceQuantity(new Number(Long.MAX_VALUE), NO_EXPAND)\r\n    );\r\n\r\n    public static final Limit UNSET = new Limit(\r\n            ResourceQuantity.UNSET,\r\n            ResourceQuantity.UNSET\r\n    );\r\n\r\n    public Limit withDefaults(Limit limit) {\r\n        if (quantity() == ResourceQuantity.UNSET && retention() == ResourceQuantity.UNSET) {\r\n            return limit;\r\n        } else if (quantity() == ResourceQuantity.UNSET) {\r\n            return new Limit(\r\n                    limit.quantity(),\r\n                    retention()\r\n            );\r\n        } else if (retention() == ResourceQuantity.UNSET) {\r\n            return new Limit(\r\n                    quantity(),\r\n                    limit.retention()\r\n            );\r\n        }\r\n        return this;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return quantity + \" RETAIN \" + retention;\r\n    }\r\n\r\n    public String toStringCondensed(Limit defaults) {\r\n        StringBuilder sb = new StringBuilder();\r\n        if (!quantity.number().equals(defaults.quantity().number())) {\r\n            sb.append(quantity);\r\n        }\r\n        if (!retention.number().equals(defaults.retention().number())) {\r\n            if (!sb.isEmpty()) sb.append(\" \");\r\n            sb.append(\"RETAIN \").append(retention);\r\n        }\r\n        return sb.toString();\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfml\\ast\\ResourceIdSet.java\r\n\r\n````java\r\npackage ca.teamdman.sfml.ast;\r\n\r\nimport java.util.Set;\r\nimport java.util.function.Predicate;\r\n\r\npublic record ResourceIdSet(\r\n        Set<ResourceIdentifier<?, ?, ?>> resourceIds\r\n) implements ASTNode, Predicate<Object> {\r\n    public static final ResourceIdSet EMPTY = new ResourceIdSet(Set.of());\r\n\r\n    public boolean test(Object stack) {\r\n        for (ResourceIdentifier<?, ?, ?> exclude : resourceIds) {\r\n            if (exclude.test(stack)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\client\\package-info.java\r\n\r\n````java\r\n@ParametersAreNonnullByDefault\r\n@MethodsReturnNonnullByDefault\r\n@FieldsAreNonnullByDefault\r\npackage ca.teamdman.sfm.client;\r\n\r\nimport net.minecraft.FieldsAreNonnullByDefault;\r\nimport net.minecraft.MethodsReturnNonnullByDefault;\r\n\r\nimport javax.annotation.ParametersAreNonnullByDefault;\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\net\\ClientboundManagerGuiPacket.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.common.net;\r\n\r\nimport ca.teamdman.sfm.client.ClientStuff;\r\nimport ca.teamdman.sfm.common.blockentity.ManagerBlockEntity;\r\nimport ca.teamdman.sfml.ast.Program;\r\nimport net.minecraft.network.FriendlyByteBuf;\r\nimport net.minecraftforge.network.NetworkEvent;\r\n\r\nimport java.util.function.Supplier;\r\n\r\npublic record ClientboundManagerGuiPacket(\r\n        int windowId,\r\n        String program,\r\n        ManagerBlockEntity.State state,\r\n        long[] tickTimes\r\n) {\r\n\r\n    public static void encode(\r\n            ClientboundManagerGuiPacket msg, FriendlyByteBuf friendlyByteBuf\r\n    ) {\r\n        friendlyByteBuf.writeVarInt(msg.windowId());\r\n        friendlyByteBuf.writeUtf(msg.program(), Program.MAX_PROGRAM_LENGTH);\r\n        friendlyByteBuf.writeEnum(msg.state());\r\n        friendlyByteBuf.writeLongArray(msg.tickTimes());\r\n    }\r\n\r\n    public static ClientboundManagerGuiPacket decode(FriendlyByteBuf friendlyByteBuf) {\r\n        return new ClientboundManagerGuiPacket(\r\n                friendlyByteBuf.readVarInt(),\r\n                friendlyByteBuf.readUtf(Program.MAX_PROGRAM_LENGTH),\r\n                friendlyByteBuf.readEnum(ManagerBlockEntity.State.class),\r\n                friendlyByteBuf.readLongArray()\r\n        );\r\n    }\r\n\r\n    public static void handle(\r\n            ClientboundManagerGuiPacket msg, Supplier<NetworkEvent.Context> contextSupplier\r\n    ) {\r\n        contextSupplier.get().enqueueWork(() -> ClientStuff.updateMenu(msg));\r\n        contextSupplier.get().setPacketHandled(true);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfml\\ast\\NumberRangeSet.java\r\n\r\n````java\r\npackage ca.teamdman.sfml.ast;\r\n\r\npublic record NumberRangeSet(NumberRange[] ranges) implements ASTNode {\r\n    public static NumberRangeSet MAX_RANGE = new NumberRangeSet(new NumberRange[]{NumberRange.MAX_RANGE});\r\n    public boolean contains(int value) {\r\n        for (NumberRange range : ranges) {\r\n            if (range.contains(value)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\client\\jei\\package-info.java\r\n\r\n````java\r\n@ParametersAreNonnullByDefault\r\n@MethodsReturnNonnullByDefault\r\n@FieldsAreNonnullByDefault\r\npackage ca.teamdman.sfm.client.jei;\r\n\r\nimport net.minecraft.FieldsAreNonnullByDefault;\r\nimport net.minecraft.MethodsReturnNonnullByDefault;\r\n\r\nimport javax.annotation.ParametersAreNonnullByDefault;\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\client\\registry\\SFMMenuScreens.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.client.registry;\r\n\r\nimport ca.teamdman.sfm.client.gui.screen.ManagerScreen;\r\nimport ca.teamdman.sfm.common.registry.SFMMenus;\r\nimport net.minecraft.client.gui.screens.MenuScreens;\r\n\r\npublic class SFMMenuScreens {\r\n    public static void register() {\r\n        MenuScreens.register(SFMMenus.MANAGER_MENU.get(), ManagerScreen::new);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\client\\render\\package-info.java\r\n\r\n````java\r\n@ParametersAreNonnullByDefault\r\n@MethodsReturnNonnullByDefault\r\n@FieldsAreNonnullByDefault\r\npackage ca.teamdman.sfm.client.render;\r\n\r\nimport net.minecraft.FieldsAreNonnullByDefault;\r\nimport net.minecraft.MethodsReturnNonnullByDefault;\r\n\r\nimport javax.annotation.ParametersAreNonnullByDefault;\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\capabilityprovidermapper\\CapabilityProviderMapper.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.common.capabilityprovidermapper;\r\n\r\nimport net.minecraft.core.BlockPos;\r\nimport net.minecraft.world.level.LevelAccessor;\r\nimport net.minecraftforge.common.capabilities.ICapabilityProvider;\r\n\r\nimport java.util.Optional;\r\n\r\npublic interface CapabilityProviderMapper {\r\n    Optional<ICapabilityProvider> getProviderFor(LevelAccessor level, BlockPos pos);\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfml\\ast\\ResourceLimit.java\r\n\r\n````java\r\npackage ca.teamdman.sfml.ast;\r\n\r\nimport ca.teamdman.sfm.common.program.InputResourceTracker;\r\nimport ca.teamdman.sfm.common.program.OutputResourceTracker;\r\n\r\nimport java.util.concurrent.atomic.AtomicLong;\r\nimport java.util.function.Consumer;\r\nimport java.util.function.Predicate;\r\n\r\nimport static ca.teamdman.sfml.ast.ResourceQuantity.IdExpansionBehaviour.EXPAND;\r\nimport static ca.teamdman.sfml.ast.ResourceQuantity.IdExpansionBehaviour.NO_EXPAND;\r\n\r\npublic record ResourceLimit<STACK, ITEM, CAP>(\r\n        ResourceIdentifier<STACK, ITEM, CAP> resourceId,\r\n        Limit limit\r\n) implements ASTNode, Predicate<Object> {\r\n    public static final ResourceLimit<?, ?, ?> TAKE_ALL_LEAVE_NONE = new ResourceLimit<>(\r\n            ResourceIdentifier.MATCH_ALL, Limit.MAX_QUANTITY_NO_RETENTION\r\n    );\r\n    public static final ResourceLimit<?, ?, ?> ACCEPT_ALL_WITHOUT_RESTRAINT = new ResourceLimit<>(\r\n            ResourceIdentifier.MATCH_ALL, Limit.MAX_QUANTITY_MAX_RETENTION\r\n    );\r\n\r\n    public ResourceLimit<STACK, ITEM, CAP> withDefaults(Limit defaults) {\r\n        return new ResourceLimit<>(resourceId, limit.withDefaults(defaults));\r\n    }\r\n\r\n    public ResourceLimit<STACK, ITEM, CAP> withLimit(Limit limit) {\r\n        return new ResourceLimit<>(resourceId, limit);\r\n    }\r\n\r\n    public void gatherInputTrackers(Consumer<InputResourceTracker<?, ?, ?>> gatherer, ResourceIdSet exclusions) {\r\n        if (limit.quantity().idExpansionBehaviour() == NO_EXPAND) {\r\n            if (limit.retention().idExpansionBehaviour() == NO_EXPAND) {\r\n                // no sharing, single tracker\r\n                gatherer.accept(new InputResourceTracker<>(\r\n                        this,\r\n                        exclusions,\r\n                        new AtomicLong(0),\r\n                        new AtomicLong(0)\r\n                ));\r\n            } else if (limit.retention().idExpansionBehaviour() == EXPAND) {\r\n                // expand retention\r\n                // share quantity\r\n                AtomicLong quantity = new AtomicLong(0);\r\n                resourceId\r\n                        .expand()\r\n                        .forEach(rid -> gatherer.accept(new InputResourceTracker<>(\r\n                                new ResourceLimit<>(rid, limit),\r\n                                exclusions,\r\n                                quantity,\r\n                                new AtomicLong(0)\r\n                        )));\r\n            }\r\n        } else if (limit.quantity().idExpansionBehaviour() == EXPAND) {\r\n            if (limit.retention().idExpansionBehaviour() == NO_EXPAND) {\r\n                // expand quantity\r\n                // share retention\r\n                AtomicLong retention = new AtomicLong(0);\r\n                resourceId\r\n                        .expand()\r\n                        .forEach(rid -> gatherer.accept(new InputResourceTracker<>(\r\n                                new ResourceLimit<>(rid, limit),\r\n                                exclusions,\r\n                                new AtomicLong(0),\r\n                                retention\r\n                        )));\r\n            } else if (limit.retention().idExpansionBehaviour() == EXPAND) {\r\n                // no sharing, multiple trackers\r\n                resourceId\r\n                        .expand()\r\n                        .forEach(rid -> gatherer.accept(new InputResourceTracker<>(\r\n                                new ResourceLimit<>(rid, limit),\r\n                                exclusions,\r\n                                new AtomicLong(0),\r\n                                new AtomicLong(0)\r\n                        )));\r\n            }\r\n        }\r\n    }\r\n\r\n    public void gatherOutputTrackers(Consumer<OutputResourceTracker<?, ?, ?>> gatherer, ResourceIdSet exclusions) {\r\n        if (limit.quantity().idExpansionBehaviour() == NO_EXPAND) {\r\n            if (limit.retention().idExpansionBehaviour() == NO_EXPAND) {\r\n                // single tracker\r\n                gatherer.accept(new OutputResourceTracker<>(this, exclusions, new AtomicLong(0), new AtomicLong(0)));\r\n            } else if (limit.retention().idExpansionBehaviour() == EXPAND) {\r\n                // tracker for each retention, sharing quantity\r\n                AtomicLong quantity = new AtomicLong(0);\r\n                resourceId\r\n                        .expand()\r\n                        .forEach(rid -> gatherer.accept(new OutputResourceTracker<>(\r\n                                new ResourceLimit<>(rid, limit),\r\n                                exclusions,\r\n                                quantity,\r\n                                new AtomicLong(0)\r\n                        )));\r\n            }\r\n        } else if (limit.quantity().idExpansionBehaviour() == EXPAND) {\r\n            if (limit.retention().idExpansionBehaviour() == NO_EXPAND) {\r\n                // tracker for each quantity, sharing retention\r\n                AtomicLong retained = new AtomicLong(0);\r\n                resourceId\r\n                        .expand()\r\n                        .forEach(rid -> gatherer.accept(new OutputResourceTracker<>(\r\n                                new ResourceLimit<>(rid, limit),\r\n                                exclusions,\r\n                                new AtomicLong(0),\r\n                                retained\r\n                        )));\r\n            } else if (limit.retention().idExpansionBehaviour() == EXPAND) {\r\n                // expand both quantity and retention, no sharing\r\n                resourceId\r\n                        .expand()\r\n                        .forEach(rid -> gatherer.accept(new OutputResourceTracker<>(\r\n                                new ResourceLimit<>(rid, limit),\r\n                                exclusions,\r\n                                new AtomicLong(0),\r\n                                new AtomicLong(0)\r\n                        )));\r\n            }\r\n        }\r\n    }\r\n\r\n    public boolean test(Object stack) {\r\n        return resourceId.test(stack);\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return limit + \" \" + resourceId;\r\n    }\r\n\r\n    public String toStringCondensed(Limit defaults) {\r\n        return (limit.toStringCondensed(defaults) + \" \" + resourceId.toStringCondensed()).trim();\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\registry\\SFMItems.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.common.registry;\r\n\r\nimport ca.teamdman.sfm.SFM;\r\nimport ca.teamdman.sfm.common.item.*;\r\nimport net.minecraft.world.item.BlockItem;\r\nimport net.minecraft.world.item.CreativeModeTab;\r\nimport net.minecraft.world.item.Item;\r\nimport net.minecraft.world.item.ItemStack;\r\nimport net.minecraft.world.level.block.Block;\r\nimport net.minecraftforge.eventbus.api.IEventBus;\r\nimport net.minecraftforge.registries.DeferredRegister;\r\nimport net.minecraftforge.registries.ForgeRegistries;\r\nimport net.minecraftforge.registries.RegistryObject;\r\n\r\npublic class SFMItems {\r\n    public static final CreativeModeTab TAB = new CreativeModeTab(SFM.MOD_ID) {\r\n        @Override\r\n        public ItemStack makeIcon() {\r\n            return new ItemStack(SFMBlocks.MANAGER_BLOCK.get());\r\n        }\r\n    };\r\n    private static final DeferredRegister<Item> ITEMS = DeferredRegister.create(ForgeRegistries.ITEMS, SFM.MOD_ID);\r\n    public static final RegistryObject<Item> MANAGER_ITEM = register(\"manager\", SFMBlocks.MANAGER_BLOCK);\r\n    public static final RegistryObject<Item> CABLE_ITEM = register(\"cable\", SFMBlocks.CABLE_BLOCK);\r\n    public static final RegistryObject<Item> PRINTING_PRESS_ITEM = ITEMS.register(\r\n            \"printing_press\",\r\n            PrintingPressBlockItem::new\r\n    );\r\n    //    public static final  RegistryObject<Item>   BATTERY_ITEM    = register(\"battery\", SFMBlocks.BATTERY_BLOCK);\r\n    public static final RegistryObject<Item> WATER_TANK_ITEM = register(\"water_tank\", SFMBlocks.WATER_TANK_BLOCK);\r\n    public static final RegistryObject<Item> DISK_ITEM = ITEMS.register(\"disk\", DiskItem::new);\r\n    public static final RegistryObject<Item> LABEL_GUN_ITEM = ITEMS.register(\r\n            \"labelgun\",\r\n            LabelGunItem::new\r\n    ); // TODO: rename on a major version update to label_gun\r\n    public static final RegistryObject<Item> NETWORK_TOOL_ITEM = ITEMS.register(\"network_tool\", NetworkToolItem::new);\r\n\r\n    public static final RegistryObject<Item> FORM_ITEM = ITEMS.register(\"form\", FormItem::new);\r\n    public static final RegistryObject<Item> EXPERIENCE_SHARD_ITEM = ITEMS.register(\"xp_shard\", ExperienceShard::new);\r\n    public static final RegistryObject<Item> EXPERIENCE_GOOP_ITEM = ITEMS.register(\"xp_goop\", ExperienceGoop::new);\r\n\r\n    public static void register(IEventBus bus) {\r\n        ITEMS.register(bus);\r\n    }\r\n\r\n    private static RegistryObject<Item> register(String name, RegistryObject<Block> block) {\r\n        return ITEMS.register(name, () -> new BlockItem(block.get(), new Item.Properties().tab(TAB)));\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\block\\BatteryBlock.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.common.block;\r\n\r\nimport ca.teamdman.sfm.SFM;\r\nimport ca.teamdman.sfm.common.blockentity.BatteryBlockEntity;\r\nimport ca.teamdman.sfm.common.registry.SFMBlockEntities;\r\nimport net.minecraft.core.BlockPos;\r\nimport net.minecraft.world.InteractionHand;\r\nimport net.minecraft.world.InteractionResult;\r\nimport net.minecraft.world.entity.player.Player;\r\nimport net.minecraft.world.level.Level;\r\nimport net.minecraft.world.level.block.Block;\r\nimport net.minecraft.world.level.block.EntityBlock;\r\nimport net.minecraft.world.level.block.entity.BlockEntity;\r\nimport net.minecraft.world.level.block.state.BlockBehaviour;\r\nimport net.minecraft.world.level.block.state.BlockState;\r\nimport net.minecraft.world.level.block.state.StateDefinition;\r\nimport net.minecraft.world.level.block.state.properties.IntegerProperty;\r\nimport net.minecraft.world.level.material.Material;\r\nimport net.minecraft.world.phys.BlockHitResult;\r\nimport net.minecraftforge.common.capabilities.ForgeCapabilities;\r\n\r\npublic class BatteryBlock extends Block implements EntityBlock {\r\n    public static final IntegerProperty LEVEL = IntegerProperty.create(\"level\", 0, 10);\r\n\r\n    public BatteryBlock() {\r\n        super(BlockBehaviour.Properties.of(Material.METAL).strength(5.0F, 6.0F));\r\n        this.registerDefaultState(this.getStateDefinition().any().setValue(LEVEL, 0));\r\n    }\r\n\r\n    @Override\r\n    public BlockEntity newBlockEntity(BlockPos pos, BlockState state) {\r\n        return SFMBlockEntities.BATTERY_BLOCK_ENTITY\r\n                .get()\r\n                .create(pos, state);\r\n    }\r\n\r\n    @Override\r\n    protected void createBlockStateDefinition(StateDefinition.Builder<Block, BlockState> builder) {\r\n        builder.add(LEVEL);\r\n    }\r\n\r\n    @SuppressWarnings(\"deprecation\")\r\n    @Override\r\n    public InteractionResult use(\r\n            BlockState pState,\r\n            Level pLevel,\r\n            BlockPos pPos,\r\n            Player pPlayer,\r\n            InteractionHand pHand,\r\n            BlockHitResult pHit\r\n    ) {\r\n        BlockEntity be = pLevel.getBlockEntity(pPos);\r\n        if (be instanceof BatteryBlockEntity bbe) {\r\n            var cap = bbe.getCapability(ForgeCapabilities.ENERGY, pHit.getDirection());\r\n            cap.ifPresent(c -> {\r\n                if (pPlayer.isShiftKeyDown()) {\r\n                    c.extractEnergy(1000, false);\r\n                } else {\r\n                    c.receiveEnergy(1000, false);\r\n                }\r\n                SFM.LOGGER.info(\"Energy stored: {}\", c.getEnergyStored());\r\n            });\r\n        }\r\n        return InteractionResult.SUCCESS;\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\blockentity\\ManagerBlockEntity.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.common.blockentity;\r\n\r\nimport ca.teamdman.sfm.common.Constants;\r\nimport ca.teamdman.sfm.common.containermenu.ManagerContainerMenu;\r\nimport ca.teamdman.sfm.common.item.DiskItem;\r\nimport ca.teamdman.sfm.common.net.ClientboundManagerGuiPacket;\r\nimport ca.teamdman.sfm.common.registry.SFMBlockEntities;\r\nimport ca.teamdman.sfm.common.registry.SFMPackets;\r\nimport ca.teamdman.sfm.common.util.OpenContainerTracker;\r\nimport ca.teamdman.sfm.common.util.SFMContainerUtil;\r\nimport ca.teamdman.sfml.ast.Program;\r\nimport net.minecraft.ChatFormatting;\r\nimport net.minecraft.core.BlockPos;\r\nimport net.minecraft.core.NonNullList;\r\nimport net.minecraft.nbt.CompoundTag;\r\nimport net.minecraft.network.chat.Component;\r\nimport net.minecraft.world.ContainerHelper;\r\nimport net.minecraft.world.entity.player.Inventory;\r\nimport net.minecraft.world.entity.player.Player;\r\nimport net.minecraft.world.inventory.AbstractContainerMenu;\r\nimport net.minecraft.world.item.ItemStack;\r\nimport net.minecraft.world.level.Level;\r\nimport net.minecraft.world.level.block.entity.BaseContainerBlockEntity;\r\nimport net.minecraft.world.level.block.state.BlockState;\r\nimport net.minecraftforge.network.PacketDistributor;\r\n\r\nimport javax.annotation.Nullable;\r\nimport java.util.Collections;\r\nimport java.util.Optional;\r\nimport java.util.Set;\r\n\r\npublic class ManagerBlockEntity extends BaseContainerBlockEntity {\r\n    public static final int TICK_TIME_HISTORY_SIZE = 20;\r\n    private final NonNullList<ItemStack> ITEMS = NonNullList.withSize(1, ItemStack.EMPTY);\r\n    private final long[] tickTimeNanos = new long[TICK_TIME_HISTORY_SIZE];\r\n    private @Nullable Program program = null;\r\n    private int tick = 0;\r\n    private int unprocessedRedstonePulses = 0; // used by redstone trigger\r\n    private boolean shouldRebuildProgram = false;\r\n    private int tickIndex = 0;\r\n\r\n    public ManagerBlockEntity(BlockPos blockPos, BlockState blockState) {\r\n        super(SFMBlockEntities.MANAGER_BLOCK_ENTITY.get(), blockPos, blockState);\r\n    }\r\n\r\n    public static void serverTick(\r\n            @SuppressWarnings(\"unused\") Level level,\r\n            @SuppressWarnings(\"unused\") BlockPos pos,\r\n            @SuppressWarnings(\"unused\") BlockState state,\r\n            ManagerBlockEntity tile\r\n    ) {\r\n        long start = System.nanoTime();\r\n        tile.tick++;\r\n        if (tile.shouldRebuildProgram) {\r\n            tile.rebuildProgramAndUpdateDisk();\r\n            tile.shouldRebuildProgram = false;\r\n        }\r\n        if (tile.program != null) {\r\n            boolean didSomething = tile.program.tick(tile);\r\n            if (didSomething) {\r\n                long nanoTimePassed = Long.min(System.nanoTime() - start, Integer.MAX_VALUE);\r\n                tile.tickTimeNanos[tile.tickIndex] = (int) nanoTimePassed;\r\n                tile.tickIndex = (tile.tickIndex + 1) % tile.tickTimeNanos.length;\r\n                tile.sendUpdatePacket();\r\n            }\r\n        }\r\n    }\r\n\r\n    private void sendUpdatePacket() {\r\n        OpenContainerTracker.getPlayersWithOpenContainer(ManagerContainerMenu.class)\r\n                .filter(entry -> entry.getValue().MANAGER_POSITION.equals(getBlockPos()))\r\n                .forEach(entry -> SFMPackets.MANAGER_CHANNEL.send(\r\n                        PacketDistributor.PLAYER.with(entry::getKey),\r\n                        new ClientboundManagerGuiPacket(\r\n                                entry.getValue().containerId,\r\n                                getProgramString().orElse(\"\"),\r\n                                getState(),\r\n                                getTickTimeNanos()\r\n                        )\r\n                ));\r\n    }\r\n\r\n    public int getTick() {\r\n        return tick;\r\n    }\r\n\r\n    public Optional<Program> getProgram() {\r\n        return Optional.ofNullable(program);\r\n    }\r\n\r\n    public void setProgram(String program) {\r\n        getDisk().ifPresent(disk -> {\r\n            DiskItem.setProgram(disk, program);\r\n            rebuildProgramAndUpdateDisk();\r\n            setChanged();\r\n        });\r\n    }\r\n\r\n    public void trackRedstonePulseUnprocessed() {\r\n        unprocessedRedstonePulses++;\r\n    }\r\n\r\n    public void clearRedstonePulseQueue() {\r\n        unprocessedRedstonePulses = 0;\r\n    }\r\n\r\n    public int getUnprocessedRedstonePulseCount() {\r\n        return unprocessedRedstonePulses;\r\n    }\r\n\r\n    public State getState() {\r\n        if (getDisk().isEmpty()) return State.NO_DISK;\r\n        if (getProgramString().isEmpty()) return State.NO_PROGRAM;\r\n        if (program == null) return State.INVALID_PROGRAM;\r\n        return State.RUNNING;\r\n    }\r\n\r\n    public Optional<String> getProgramString() {\r\n        return getDisk().map(DiskItem::getProgram).filter(prog -> !prog.isBlank());\r\n    }\r\n\r\n    public Set<String> getReferencedLabels() {\r\n        if (program == null) return Collections.emptySet();\r\n        return program.referencedLabels();\r\n    }\r\n\r\n    public Optional<ItemStack> getDisk() {\r\n        var item = getItem(0);\r\n        if (item.getItem() instanceof DiskItem) return Optional.of(item);\r\n        return Optional.empty();\r\n    }\r\n\r\n    public void rebuildProgramAndUpdateDisk() {\r\n        if (level != null && level.isClientSide()) return;\r\n        this.program = getDisk()\r\n                .flatMap(itemStack -> DiskItem.updateDetails(itemStack, this))\r\n                .orElse(null);\r\n        sendUpdatePacket();\r\n    }\r\n\r\n    @Override\r\n    protected Component getDefaultName() {\r\n        return Constants.LocalizationKeys.MANAGER_CONTAINER.getComponent();\r\n    }\r\n\r\n    @Override\r\n    protected AbstractContainerMenu createMenu(int windowId, Inventory inv) {\r\n        return new ManagerContainerMenu(windowId, inv, this);\r\n    }\r\n\r\n    @Override\r\n    public int getContainerSize() {\r\n        return ITEMS.size();\r\n    }\r\n\r\n    @Override\r\n    public boolean isEmpty() {\r\n        return ITEMS.isEmpty();\r\n    }\r\n\r\n    @Override\r\n    public ItemStack getItem(int slot) {\r\n        if (slot < 0 || slot >= ITEMS.size()) return ItemStack.EMPTY;\r\n        return ITEMS.get(slot);\r\n    }\r\n\r\n    @Override\r\n    public ItemStack removeItem(int slot, int amount) {\r\n        var result = ContainerHelper.removeItem(ITEMS, slot, amount);\r\n        if (slot == 0) rebuildProgramAndUpdateDisk();\r\n        setChanged();\r\n        return result;\r\n    }\r\n\r\n    @Override\r\n    public ItemStack removeItemNoUpdate(int slot) {\r\n        var result = ContainerHelper.takeItem(ITEMS, slot);\r\n        if (slot == 0) rebuildProgramAndUpdateDisk();\r\n        setChanged();\r\n        return result;\r\n    }\r\n\r\n    @Override\r\n    public void setItem(int slot, ItemStack stack) {\r\n        if (slot < 0 || slot >= ITEMS.size()) return;\r\n        ITEMS.set(slot, stack);\r\n        if (slot == 0) rebuildProgramAndUpdateDisk();\r\n        setChanged();\r\n    }\r\n\r\n    @Override\r\n    public int getMaxStackSize() {\r\n        return 1;\r\n    }\r\n\r\n    @Override\r\n    public boolean canPlaceItem(int slot, ItemStack stack) {\r\n        return stack.getItem() instanceof DiskItem;\r\n    }\r\n\r\n    @Override\r\n    public boolean stillValid(Player player) {\r\n        return SFMContainerUtil.stillValid(this, player);\r\n    }\r\n\r\n    @Override\r\n    public void load(CompoundTag tag) {\r\n        super.load(tag);\r\n        ContainerHelper.loadAllItems(tag, ITEMS);\r\n        this.shouldRebuildProgram = true;\r\n    }\r\n\r\n    @Override\r\n    protected void saveAdditional(CompoundTag tag) {\r\n        super.saveAdditional(tag);\r\n        ContainerHelper.saveAllItems(tag, ITEMS);\r\n    }\r\n\r\n\r\n    @Override\r\n    public void clearContent() {\r\n        ITEMS.clear();\r\n    }\r\n\r\n    public void reset() {\r\n        getDisk().ifPresent(disk -> {\r\n            disk.setTag(null);\r\n            setItem(0, disk);\r\n            setChanged();\r\n        });\r\n    }\r\n\r\n    public long[] getTickTimeNanos() {\r\n        // tickTimeNanos is used as a cyclical buffer, transform it to have the first index be the most recent tick\r\n        long[] result = new long[tickTimeNanos.length];\r\n        System.arraycopy(tickTimeNanos, tickIndex, result, 0, tickTimeNanos.length - tickIndex);\r\n        System.arraycopy(tickTimeNanos, 0, result, tickTimeNanos.length - tickIndex, tickIndex);\r\n        return result;\r\n    }\r\n\r\n    public enum State {\r\n        NO_PROGRAM(\r\n                ChatFormatting.RED,\r\n                Constants.LocalizationKeys.MANAGER_GUI_STATE_NO_PROGRAM\r\n        ), NO_DISK(\r\n                ChatFormatting.RED,\r\n                Constants.LocalizationKeys.MANAGER_GUI_STATE_NO_DISK\r\n        ), RUNNING(ChatFormatting.GREEN, Constants.LocalizationKeys.MANAGER_GUI_STATE_RUNNING), INVALID_PROGRAM(\r\n                ChatFormatting.DARK_RED,\r\n                Constants.LocalizationKeys.MANAGER_GUI_STATE_INVALID_PROGRAM\r\n        );\r\n\r\n        public final ChatFormatting COLOR;\r\n        public final Constants.LocalizationKeys.LocalizationEntry LOC;\r\n\r\n        State(ChatFormatting color, Constants.LocalizationKeys.LocalizationEntry loc) {\r\n            COLOR = color;\r\n            LOC = loc;\r\n        }\r\n    }\r\n\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\client\\ProgramSyntaxHighlightingHelper.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.client;\r\n\r\nimport ca.teamdman.sfml.SFMLLexer;\r\nimport net.minecraft.ChatFormatting;\r\nimport net.minecraft.network.chat.Component;\r\nimport net.minecraft.network.chat.MutableComponent;\r\nimport net.minecraft.network.chat.Style;\r\nimport org.antlr.v4.runtime.CharStreams;\r\nimport org.antlr.v4.runtime.CommonTokenStream;\r\nimport org.antlr.v4.runtime.Token;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\npublic class ProgramSyntaxHighlightingHelper {\r\n\r\n    public static List<MutableComponent> withSyntaxHighlighting(String programString, boolean showContextActionHints) {\r\n        SFMLLexer lexer = new SFMLLexer(CharStreams.fromString(programString));\r\n        lexer.INCLUDE_UNUSED = true;\r\n        CommonTokenStream tokens = new CommonTokenStream(lexer) {\r\n            // This is a hack to make hidden tokens show up in the token stream\r\n            @Override\r\n            public List<Token> getHiddenTokensToRight(int tokenIndex, int channel) {\r\n                if (channel == Token.DEFAULT_CHANNEL) {\r\n                    return getHiddenTokensToRight(tokenIndex, Token.HIDDEN_CHANNEL);\r\n                } else {\r\n                    return super.getHiddenTokensToRight(tokenIndex, channel);\r\n                }\r\n            }\r\n\r\n            @Override\r\n            public List<Token> getHiddenTokensToLeft(int tokenIndex, int channel) {\r\n                if (channel == Token.DEFAULT_CHANNEL) {\r\n                    return getHiddenTokensToLeft(tokenIndex, Token.HIDDEN_CHANNEL);\r\n                } else {\r\n                    return super.getHiddenTokensToLeft(tokenIndex, channel);\r\n                }\r\n            }\r\n        };\r\n        List<MutableComponent> textComponents = new ArrayList<>();\r\n        MutableComponent lineComponent = Component.empty();\r\n        tokens.fill();\r\n        for (Token token : tokens.getTokens()) {\r\n            if (token.getType() == SFMLLexer.EOF) break;\r\n            // the token may contain newlines in it, so we need to split it up\r\n            String[] lines = token.getText().split(\"\\n\", -1);\r\n            for (int i = 0; i < lines.length; i++) {\r\n                if (i != 0) {\r\n                    textComponents.add(lineComponent);\r\n                    lineComponent = Component.empty();\r\n                }\r\n                String line = lines[i];\r\n                if (!line.isEmpty()) {\r\n                    var text = Component.literal(line).withStyle(getStyle(token, showContextActionHints));\r\n                    lineComponent = lineComponent.append(text);\r\n                }\r\n            }\r\n        }\r\n        textComponents.add(lineComponent);\r\n\r\n        return textComponents;\r\n    }\r\n\r\n    private static Style getStyle(Token token, boolean showContextActionHints) {\r\n        Style style = Style.EMPTY;\r\n        style = style.withColor(getColour(token));\r\n        if (showContextActionHints && ProgramTokenContextActions.hasContextAction(token)) {\r\n            style = style.withUnderlined(true);\r\n        }\r\n        return style;\r\n    }\r\n\r\n    private static ChatFormatting getColour(Token token) {\r\n        //noinspection EnhancedSwitchMigration\r\n        switch (token.getType()) {\r\n            case SFMLLexer.SIDE:\r\n            case SFMLLexer.TOP:\r\n            case SFMLLexer.BOTTOM:\r\n            case SFMLLexer.NORTH:\r\n            case SFMLLexer.SOUTH:\r\n            case SFMLLexer.EAST:\r\n            case SFMLLexer.WEST:\r\n            case SFMLLexer.EACH:\r\n                return ChatFormatting.DARK_PURPLE;\r\n            case SFMLLexer.LINE_COMMENT:\r\n                return ChatFormatting.GRAY;\r\n            case SFMLLexer.INPUT:\r\n            case SFMLLexer.FROM:\r\n            case SFMLLexer.TO:\r\n            case SFMLLexer.OUTPUT:\r\n            case SFMLLexer.FORGET:\r\n                return ChatFormatting.LIGHT_PURPLE;\r\n            case SFMLLexer.NAME:\r\n            case SFMLLexer.EVERY:\r\n            case SFMLLexer.END:\r\n            case SFMLLexer.DO:\r\n            case SFMLLexer.IF:\r\n            case SFMLLexer.ELSE:\r\n            case SFMLLexer.THEN:\r\n            case SFMLLexer.HAS:\r\n            case SFMLLexer.TRUE:\r\n            case SFMLLexer.FALSE:\r\n            case SFMLLexer.NOT:\r\n                return ChatFormatting.BLUE;\r\n            case SFMLLexer.IDENTIFIER:\r\n            case SFMLLexer.STRING:\r\n                return ChatFormatting.GREEN;\r\n            case SFMLLexer.TICKS:\r\n            case SFMLLexer.SLOTS:\r\n            case SFMLLexer.EXCEPT:\r\n            case SFMLLexer.RETAIN:\r\n            case SFMLLexer.LONE:\r\n            case SFMLLexer.ONE:\r\n            case SFMLLexer.OVERALL:\r\n            case SFMLLexer.SOME:\r\n            case SFMLLexer.AND:\r\n                return ChatFormatting.GOLD;\r\n            case SFMLLexer.NUMBER:\r\n            case SFMLLexer.GT:\r\n            case SFMLLexer.LT:\r\n            case SFMLLexer.EQ:\r\n            case SFMLLexer.GE:\r\n            case SFMLLexer.LE:\r\n            case SFMLLexer.GT_SYMBOL:\r\n            case SFMLLexer.LT_SYMBOL:\r\n            case SFMLLexer.EQ_SYMBOL:\r\n            case SFMLLexer.GE_SYMBOL:\r\n            case SFMLLexer.LE_SYMBOL:\r\n                return ChatFormatting.AQUA;\r\n            case SFMLLexer.UNUSED:\r\n            case SFMLLexer.REDSTONE:\r\n            case SFMLLexer.PULSE:\r\n                return ChatFormatting.RED;\r\n            case SFMLLexer.ROUND:\r\n            case SFMLLexer.ROBIN:\r\n            case SFMLLexer.BY:\r\n            case SFMLLexer.BLOCK:\r\n            case SFMLLexer.LABEL:\r\n                return ChatFormatting.YELLOW;\r\n            default:\r\n                return ChatFormatting.WHITE;\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\net\\ServerboundManagerFixPacket.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.common.net;\r\n\r\nimport ca.teamdman.sfm.common.blockentity.ManagerBlockEntity;\r\nimport ca.teamdman.sfm.common.containermenu.ManagerContainerMenu;\r\nimport ca.teamdman.sfm.common.registry.SFMPackets;\r\nimport net.minecraft.core.BlockPos;\r\nimport net.minecraft.network.FriendlyByteBuf;\r\nimport net.minecraftforge.network.NetworkEvent;\r\n\r\nimport java.util.function.Supplier;\r\n\r\npublic record ServerboundManagerFixPacket(\r\n        int windowId,\r\n        BlockPos pos\r\n) {\r\n    public static void encode(ServerboundManagerFixPacket msg, FriendlyByteBuf friendlyByteBuf) {\r\n        friendlyByteBuf.writeVarInt(msg.windowId());\r\n        friendlyByteBuf.writeBlockPos(msg.pos());\r\n    }\r\n\r\n    public static ServerboundManagerFixPacket decode(FriendlyByteBuf friendlyByteBuf) {\r\n        return new ServerboundManagerFixPacket(\r\n                friendlyByteBuf.readVarInt(),\r\n                friendlyByteBuf.readBlockPos()\r\n        );\r\n    }\r\n\r\n    public static void handle(ServerboundManagerFixPacket msg, Supplier<NetworkEvent.Context> contextSupplier) {\r\n        SFMPackets.handleServerboundContainerPacket(\r\n                contextSupplier,\r\n                ManagerContainerMenu.class,\r\n                ManagerBlockEntity.class,\r\n                msg.pos,\r\n                msg.windowId,\r\n                (menu, manager) -> manager\r\n                        .getDisk()\r\n                        .ifPresent(disk -> manager\r\n                                .getProgram()\r\n                                .ifPresent(program -> program.fixWarnings(disk, manager)))\r\n        );\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\Constants.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.common;\r\n\r\nimport ca.teamdman.sfm.SFM;\r\nimport ca.teamdman.sfm.common.registry.SFMBlocks;\r\nimport ca.teamdman.sfm.common.registry.SFMItems;\r\nimport ca.teamdman.sfm.common.util.SFMUtils;\r\nimport net.minecraft.ChatFormatting;\r\nimport net.minecraft.client.resources.language.I18n;\r\nimport net.minecraft.network.chat.Component;\r\nimport net.minecraft.network.chat.MutableComponent;\r\nimport net.minecraft.network.chat.contents.TranslatableContents;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.function.Supplier;\r\n\r\npublic class Constants {\r\n    public static final class LocalizationKeys {\r\n        public static final LocalizationEntry PROGRAM_EDIT_SCREEN_TITLE = new LocalizationEntry(\r\n                \"gui.sfm.text_editor.title\",\r\n                \"Text Editor\"\r\n        );\r\n        public static final LocalizationEntry PROGRAM_EDIT_SCREEN_DONE_BUTTON_TOOLTIP = new LocalizationEntry(\r\n                \"gui.sfm.text_editor.done_button.tooltip\",\r\n                \"Shift+Enter to submit\"\r\n        );\r\n        public static final LocalizationEntry SAVE_CHANGES_CONFIRM_SCREEN_TITLE = new LocalizationEntry(\r\n                \"gui.sfm.save_changes_confirm.title\",\r\n                \"Save changes\"\r\n        );\r\n        public static final LocalizationEntry SAVE_CHANGES_CONFIRM_SCREEN_MESSAGE = new LocalizationEntry(\r\n                \"gui.sfm.save_changes_confirm.message\",\r\n                \"Do you want to save before exiting?\"\r\n        );\r\n        public static final LocalizationEntry SAVE_CHANGES_CONFIRM_SCREEN_YES_BUTTON = new LocalizationEntry(\r\n                \"gui.sfm.save_changes_confirm.yes_button\",\r\n                \"Save changes\"\r\n        );\r\n        public static final LocalizationEntry SAVE_CHANGES_CONFIRM_SCREEN_NO_BUTTON = new LocalizationEntry(\r\n                \"gui.sfm.save_changes_confirm.no_button\",\r\n                \"Don't save\"\r\n        );\r\n\r\n        @SuppressWarnings(\"unused\") // used by minecraft without us having to directly reference\r\n        public static LocalizationEntry MOD_NAME = new LocalizationEntry(\r\n                \"mod.name\",\r\n                \"Super Factory Manager\"\r\n        );\r\n\r\n        @SuppressWarnings(\"unused\") // used by minecraft without us having to directly reference\r\n        public static LocalizationEntry ITEM_GROUP = new LocalizationEntry(\r\n                \"itemGroup.sfm\",\r\n                \"Super Factory Manager\"\r\n        );\r\n\r\n        @SuppressWarnings(\"unused\") // used by minecraft without us having to directly reference\r\n        public static LocalizationEntry CABLE_BLOCK = new LocalizationEntry(\r\n                () -> SFMBlocks.CABLE_BLOCK.get().getDescriptionId(),\r\n                () -> \"Inventory Cable\"\r\n        );\r\n\r\n        @SuppressWarnings(\"unused\") // used by minecraft without us having to directly reference\r\n        public static LocalizationEntry MANAGER_BLOCK = new LocalizationEntry(\r\n                () -> SFMBlocks.MANAGER_BLOCK.get().getDescriptionId(),\r\n                () -> \"Factory Manager\"\r\n        );\r\n        @SuppressWarnings(\"unused\") // used by minecraft without us having to directly reference\r\n        public static LocalizationEntry PRINTING_PRESS_BLOCK = new LocalizationEntry(\r\n                () -> SFMBlocks.PRINTING_PRESS_BLOCK.get().getDescriptionId(),\r\n                () -> \"Printing Press\"\r\n        );\r\n\r\n        public static final LocalizationEntry PRINTING_PRESS_JEI_CATEGORY_TITLE = new LocalizationEntry(\r\n                \"gui.jei.category.sfm.printing_press\",\r\n                \"Printing Press\"\r\n        );\r\n\r\n        public static final LocalizationEntry FALLING_ANVIL_JEI_CATEGORY_TITLE = new LocalizationEntry(\r\n                \"gui.jei.category.sfm.falling_anvil\",\r\n                \"Falling Anvil\"\r\n        );\r\n\r\n        public static final LocalizationEntry FALLING_ANVIL_JEI_CONSUMED = new LocalizationEntry(\r\n                \"gui.jei.category.sfm.falling_anvil.consumed\",\r\n                \"Gets consumed\"\r\n        );\r\n        public static final LocalizationEntry FALLING_ANVIL_JEI_NOT_CONSUMED = new LocalizationEntry(\r\n                \"gui.jei.category.sfm.falling_anvil.not_consumed\",\r\n                \"Not consumed\"\r\n        );\r\n\r\n        public static final LocalizationEntry PRINTING_PRESS_TOOLTIP = new LocalizationEntry(\r\n                () -> SFMItems.PRINTING_PRESS_ITEM.get().getDescriptionId() + \".tooltip\",\r\n                () -> \"Place with an air gap below a downward facing piston. Extend the piston to use.\"\r\n        );\r\n\r\n        @SuppressWarnings(\"unused\") // used by minecraft without us having to directly reference\r\n        public static LocalizationEntry TEST_BARREL_BLOCK = new LocalizationEntry(\r\n                () -> SFMBlocks.TEST_BARREL_BLOCK.get().getDescriptionId(),\r\n                () -> \"Test Barrel\"\r\n        );\r\n\r\n        @SuppressWarnings(\"unused\") // used by minecraft without us having to directly reference\r\n        public static LocalizationEntry WATER_TANK_BLOCK = new LocalizationEntry(\r\n                () -> SFMBlocks.WATER_TANK_BLOCK.get().getDescriptionId(),\r\n                () -> \"Water Tank\"\r\n        );\r\n        @SuppressWarnings(\"unused\") // used by minecraft without us having to directly reference\r\n        public static LocalizationEntry BATTERY_BLOCK = new LocalizationEntry(\r\n                () -> SFMBlocks.BATTERY_BLOCK.get().getDescriptionId(),\r\n                () -> \"Battery (WIP)\"\r\n        );\r\n        @SuppressWarnings(\"unused\") // used by minecraft without us having to directly reference\r\n        public static LocalizationEntry DISK_ITEM = new LocalizationEntry(\r\n                () -> SFMItems.DISK_ITEM.get().getDescriptionId(),\r\n                () -> \"Factory Manager Program Disk\"\r\n        );\r\n\r\n        @SuppressWarnings(\"unused\") // used by minecraft without us having to directly reference\r\n        public static LocalizationEntry EXPERIENCE_GOOP_ITEM = new LocalizationEntry(\r\n                () -> SFMItems.EXPERIENCE_GOOP_ITEM.get().getDescriptionId(),\r\n                () -> \"Experience Goop\"\r\n        );\r\n        @SuppressWarnings(\"unused\") // used by minecraft without us having to directly reference\r\n        public static LocalizationEntry EXPERIENCE_SHARD_ITEM = new LocalizationEntry(\r\n                () -> SFMItems.EXPERIENCE_SHARD_ITEM.get().getDescriptionId(),\r\n                () -> \"Experience Shard\"\r\n        );\r\n\r\n        @SuppressWarnings(\"unused\") // used by minecraft without us having to directly reference\r\n        public static LocalizationEntry FORM_ITEM = new LocalizationEntry(\r\n                () -> SFMItems.FORM_ITEM.get().getDescriptionId(),\r\n                () -> \"Printing Form\"\r\n        );\r\n\r\n        public static final LocalizationEntry DISK_ITEM_TOOLTIP_LABEL_HEADER = new LocalizationEntry(\r\n                () -> SFMItems.DISK_ITEM.get().getDescriptionId() + \".tooltip.label_section.header\",\r\n                () -> \"Labels\"\r\n        );\r\n        public static final LocalizationEntry DISK_ITEM_TOOLTIP_LABEL = new LocalizationEntry(\r\n                () -> SFMItems.DISK_ITEM.get().getDescriptionId() + \".tooltip.label_section.entry\",\r\n                () -> \" - %s: %d blocks\"\r\n        );\r\n        @SuppressWarnings(\"unused\") // used by minecraft without us having to directly reference\r\n        public static LocalizationEntry LABEL_GUN_ITEM = new LocalizationEntry(\r\n                () -> SFMItems.LABEL_GUN_ITEM.get().getDescriptionId(),\r\n                () -> \"Label Gun\"\r\n        );\r\n        public static final LocalizationEntry LABEL_GUN_CHAT_PULLED = new LocalizationEntry(\r\n                () -> SFMItems.LABEL_GUN_ITEM.get().getDescriptionId() + \".chat.pulled\",\r\n                () -> \"Pulled labels from the manager.\"\r\n        );\r\n        public static final LocalizationEntry LABEL_GUN_CHAT_PUSHED = new LocalizationEntry(\r\n                () -> SFMItems.LABEL_GUN_ITEM.get().getDescriptionId() + \".chat.pushed\",\r\n                () -> \"Pushed labels to the manager.\"\r\n        );\r\n\r\n        @SuppressWarnings(\"unused\") // used by minecraft without us having to directly reference\r\n        public static LocalizationEntry NETWORK_TOOL_ITEM = new LocalizationEntry(\r\n                () -> SFMItems.NETWORK_TOOL_ITEM.get().getDescriptionId(),\r\n                () -> \"Network Tool\"\r\n        );\r\n\r\n        public static final LocalizationEntry NETWORK_TOOL_ITEM_TOOLTIP_1 = new LocalizationEntry(\r\n                () -> SFMItems.NETWORK_TOOL_ITEM.get().getDescriptionId() + \".tooltip.1\",\r\n                () -> \"Shows cables through walls when held.\"\r\n        );\r\n        public static final LocalizationEntry NETWORK_TOOL_ITEM_TOOLTIP_2 = new LocalizationEntry(\r\n                () -> SFMItems.NETWORK_TOOL_ITEM.get().getDescriptionId() + \".tooltip.2\",\r\n                () -> \"Right click a block face to view diagnostic info.\"\r\n        );\r\n        public static final LocalizationEntry NETWORK_TOOL_ITEM_TOOLTIP_3 = new LocalizationEntry(\r\n                () -> SFMItems.NETWORK_TOOL_ITEM.get().getDescriptionId() + \".tooltip.3\",\r\n                () -> ChatFormatting.GRAY\r\n                      + \"You might not need this, don't forget you can press \"\r\n                      + ChatFormatting.AQUA\r\n                      + \"%s\"\r\n                      + ChatFormatting.GRAY\r\n                      + \" in an inventory to toggle the inspector.\"\r\n        );\r\n        public static final LocalizationEntry LABEL_GUN_ITEM_TOOLTIP_1 = new LocalizationEntry(\r\n                () -> SFMItems.LABEL_GUN_ITEM.get().getDescriptionId() + \".tooltip.1\",\r\n                () -> \"Right click a Factory Manager to push labels.\"\r\n        );\r\n        public static final LocalizationEntry LABEL_GUN_ITEM_TOOLTIP_2 = new LocalizationEntry(\r\n                () -> SFMItems.LABEL_GUN_ITEM.get().getDescriptionId() + \".tooltip.2\",\r\n                () -> \"Right click a Factory Manager while sneaking to pull labels.\"\r\n        );\r\n        public static final LocalizationEntry LABEL_GUN_ITEM_TOOLTIP_3 = new LocalizationEntry(\r\n                () -> SFMItems.LABEL_GUN_ITEM.get().getDescriptionId() + \".tooltip.3\",\r\n                () -> \"Hold control to apply labels to blocks of the same type adjacent to cables.\"\r\n        );\r\n        public static final LocalizationEntry LABEL_GUN_ITEM_NAME_WITH_LABEL = new LocalizationEntry(\r\n                () -> SFMItems.LABEL_GUN_ITEM.get().getDescriptionId() + \".with_label\",\r\n                () -> \"Label Gun: \\\"%s\\\"\"\r\n        );\r\n        public static final LocalizationEntry WATER_TANK_ITEM_TOOLTIP_1 = new LocalizationEntry(\r\n                () -> SFMBlocks.WATER_TANK_BLOCK.get().getDescriptionId() + \".tooltip.1\",\r\n                () -> \"Requires two adjacent water sources\"\r\n        );\r\n        public static final LocalizationEntry WATER_TANK_ITEM_TOOLTIP_2 = new LocalizationEntry(\r\n                () -> SFMBlocks.WATER_TANK_BLOCK.get().getDescriptionId() + \".tooltip.2\",\r\n                () -> \"More effective when also adjacent to other water tanks\"\r\n        );\r\n        public static final LocalizationEntry LABEL_GUN_GUI_TITLE = new LocalizationEntry(\r\n                \"gui.sfm.title.labelgun\",\r\n                \"Label Gun\"\r\n        );\r\n        public static final LocalizationEntry PROGRAM_TEMPLATE_PICKER_GUI_WARNING_1 = new LocalizationEntry(\r\n                \"gui.sfm.program_template_picker.warning1\",\r\n                \"Hitting \\\"Done\\\" will on the next screen will overwrite your existing program!\"\r\n        );\r\n        public static final LocalizationEntry PROGRAM_TEMPLATE_PICKER_GUI_WARNING_2 = new LocalizationEntry(\r\n                \"gui.sfm.program_template_picker.warning2\",\r\n                \"Hit <esc> to cancel instead.\"\r\n        );\r\n        public static final LocalizationEntry PROGRAM_TEMPLATE_PICKER_GUI_TITLE = new LocalizationEntry(\r\n                \"gui.sfm.title.program_template_picker\",\r\n                \"Program Template Picker\"\r\n        );\r\n        public static final LocalizationEntry LABEL_GUN_GUI_LABEL_PLACEHOLDER = new LocalizationEntry(\r\n                \"gui.sfm.label_gun.placeholder\",\r\n                \"Label\"\r\n        );\r\n        public static final LocalizationEntry LABEL_GUN_GUI_LABEL_BUTTON = new LocalizationEntry(\r\n                \"gui.sfm.label_gun.label_button\",\r\n                \"%s (%d)\"\r\n        );\r\n\r\n        public static final LocalizationEntry LABEL_GUN_GUI_PRUNE_BUTTON = new LocalizationEntry(\r\n                \"gui.sfm.label_gun.prune_button\",\r\n                \"Prune\"\r\n        );\r\n        public static final LocalizationEntry LABEL_GUN_GUI_CLEAR_BUTTON = new LocalizationEntry(\r\n                \"gui.sfm.label_gun.clear_button\",\r\n                \"Clear\"\r\n        );\r\n\r\n\r\n        public static final LocalizationEntry MANAGER_GUI_PASTE_FROM_CLIPBOARD_BUTTON_TOOLTIP = new LocalizationEntry(\r\n                \"gui.sfm.manager.tooltip.paste\",\r\n                \"Press Ctrl+V to paste.\"\r\n        );\r\n        public static final LocalizationEntry MANAGER_GUI_EDIT_BUTTON_TOOLTIP = new LocalizationEntry(\r\n                \"gui.sfm.manager.edit_button.tooltip\",\r\n                \"Press Ctrl+E to edit.\"\r\n        );\r\n        public static final LocalizationEntry MANAGER_GUI_EDIT_BUTTON = new LocalizationEntry(\r\n                \"gui.sfm.manager.edit_button\",\r\n                \"Edit\"\r\n        );\r\n        public static final LocalizationEntry MANAGER_GUI_RESET_BUTTON_TOOLTIP = new LocalizationEntry(\r\n                \"gui.sfm.manager.tooltip.reset\",\r\n                \"Wipes ALL disk data.\"\r\n        );\r\n        public static final LocalizationEntry MANAGER_CONTAINER = new LocalizationEntry(\r\n                \"container.sfm.manager\",\r\n                \"Factory Manager\"\r\n        );\r\n\r\n        public static final LocalizationEntry PROGRAM_WARNING_UNUSED_LABEL = new LocalizationEntry(\r\n                \"program.sfm.warnings.unused_label\",\r\n                \"Label \\\"%s\\\" is used in code but not assigned in the world.\"\r\n        );\r\n        public static final LocalizationEntry PROGRAM_WARNING_UNKNOWN_RESOURCE_TYPE = new LocalizationEntry(\r\n                \"program.sfm.warnings.unknown_resource_type\",\r\n                \"The resource type \\\"%s\\\" in \\\"%s\\\" is not supported.\"\r\n        );\r\n        public static final LocalizationEntry PROGRAM_WARNING_UNKNOWN_RESOURCE_ID = new LocalizationEntry(\r\n                \"program.sfm.warnings.unknown_resource_id\",\r\n                \"Resource \\\"%s\\\" was not found.\"\r\n        );\r\n        public static final LocalizationEntry PROGRAM_WARNING_UNDEFINED_LABEL = new LocalizationEntry(\r\n                \"program.sfm.warnings.undefined_label\",\r\n                \"Label \\\"%s\\\" is assigned in the world but not defined in code.\"\r\n        );\r\n        public static final LocalizationEntry PROGRAM_WARNING_DISCONNECTED_LABEL = new LocalizationEntry(\r\n                \"program.sfm.warnings.disconnected_label\",\r\n                \"Label \\\"%s\\\" is assigned in the world at %s but not connected by cables.\"\r\n        );\r\n        public static final LocalizationEntry PROGRAM_WARNING_ADJACENT_BUT_DISCONNECTED_LABEL = new LocalizationEntry(\r\n                \"program.sfm.warnings.adjacent_but_disconnected_label\",\r\n                \"Label \\\"%s\\\" is assigned in the world at %s and is connected by cables but is not detected as a valid inventory.\"\r\n        );\r\n        public static final LocalizationEntry PROGRAM_ERROR_COMPILE_FAILED = new LocalizationEntry(\r\n                \"program.sfm.error.compile_failed\",\r\n                \"Failed to compile.\"\r\n        );\r\n        public static final LocalizationEntry PROGRAM_ERROR_LITERAL = new LocalizationEntry(\r\n                \"program.sfm.error.literal\",\r\n                \"%s\"\r\n        );\r\n        public static final LocalizationEntry PROGRAM_ERROR_MALFORMED_RESOURCE_TYPE = new LocalizationEntry(\r\n                \"program.sfm.error.malformed_resource_type\",\r\n                \"Program has a malformed resource type \\\"%s\\\".\\nReminder: Resource types must be literals, not wildcards.\"\r\n        );\r\n        public static final LocalizationEntry MANAGER_GUI_STATE_NO_PROGRAM = new LocalizationEntry(\r\n                \"gui.sfm.manager.state.no_program\",\r\n                \"no program\"\r\n        );\r\n        public static final LocalizationEntry MANAGER_GUI_STATE = new LocalizationEntry(\r\n                \"gui.sfm.manager.state\",\r\n                \"State: %s\"\r\n        );\r\n\r\n        public static final LocalizationEntry CONTAINER_INSPECTOR_SHOW_EXPORTS_BUTTON = new LocalizationEntry(\r\n                \"gui.sfm.container_inspector.show_exports_button\",\r\n                \"Export Inspector\"\r\n        );\r\n        public static final LocalizationEntry CONTAINER_INSPECTOR_MEKANISM_NULL_DIRECTION_WARNING = new LocalizationEntry(\r\n                \"gui.sfm.container_inspector.mekanism_null_direction_warning\",\r\n                \"MEKANISM BLOCKS ARE READ-ONLY FROM THE NULL DIRECTION!!!!!!\"\r\n        );\r\n        public static final LocalizationEntry CONTAINER_INSPECTOR_MEKANISM_MACHINE_INPUTS = new LocalizationEntry(\r\n                \"gui.sfm.container_inspector.mekanism_machine_inputs\",\r\n                \"The following are based on the MACHINE'S input config\"\r\n        );\r\n        public static final LocalizationEntry CONTAINER_INSPECTOR_MEKANISM_MACHINE_OUTPUTS = new LocalizationEntry(\r\n                \"gui.sfm.container_inspector.mekanism_machine_outputs\",\r\n                \"The following are based on the MACHINE'S output config\"\r\n        );\r\n\r\n        public static final LocalizationEntry CONTAINER_INSPECTOR_CONTAINER_SLOT_COUNT = new LocalizationEntry(\r\n                \"gui.sfm.container_inspector.container_slot_count\",\r\n                \"Container Slots: %d\"\r\n        );\r\n        public static final LocalizationEntry CONTAINER_INSPECTOR_INVENTORY_SLOT_COUNT = new LocalizationEntry(\r\n                \"gui.sfm.container_inspector.inventory_slot_count\",\r\n                \"Inventory Slots: %d\"\r\n        );\r\n\r\n\r\n        public static final LocalizationEntry MANAGER_GUI_PEAK_TICK_TIME = new LocalizationEntry(\r\n                \"gui.sfm.manager.peak_tick_time\",\r\n                \"Peak tick time: %s ms\"\r\n        );\r\n        public static final LocalizationEntry MANAGER_GUI_HOVERED_TICK_TIME = new LocalizationEntry(\r\n                \"gui.sfm.manager.hovered_tick_time\",\r\n                \"Hovered tick time: %s ms\"\r\n        );\r\n        public static final LocalizationEntry MANAGER_GUI_STATE_NO_DISK = new LocalizationEntry(\r\n                \"gui.sfm.manager.state.no_disk\",\r\n                \"missing disk\"\r\n        );\r\n        public static final LocalizationEntry MANAGER_GUI_STATE_RUNNING = new LocalizationEntry(\r\n                \"gui.sfm.manager.state.running\",\r\n                \"running\"\r\n        );\r\n        public static final LocalizationEntry MANAGER_GUI_STATE_INVALID_PROGRAM = new LocalizationEntry(\r\n                \"gui.sfm.manager.state.invalid_program\",\r\n                \"invalid program\"\r\n        );\r\n        public static final LocalizationEntry MANAGER_GUI_PASTE_FROM_CLIPBOARD_BUTTON = new LocalizationEntry(\r\n                \"gui.sfm.manager.button.paste_clipboard\",\r\n                \"Paste from clipboard\"\r\n        );\r\n        public static final LocalizationEntry MANAGER_GUI_COPY_TO_CLIPBOARD_BUTTON = new LocalizationEntry(\r\n                \"gui.sfm.manager.button.copy_to_clipboard\",\r\n                \"Copy to clipboard\"\r\n        );\r\n        public static final LocalizationEntry MANAGER_GUI_VIEW_EXAMPLES_BUTTON = new LocalizationEntry(\r\n                \"gui.sfm.manager.button.view_examples\",\r\n                \"View examples\"\r\n        );\r\n        public static final LocalizationEntry MANAGER_GUI_VIEW_EXAMPLES_BUTTON_TOOLTIP = new LocalizationEntry(\r\n                \"gui.sfm.manager.button.view_examples.tooltip\",\r\n                \"Press Ctrl+Shift+E to view examples.\"\r\n        );\r\n        public static final LocalizationEntry MANAGER_GUI_RESET_BUTTON = new LocalizationEntry(\r\n                \"gui.sfm.manager.button.reset\",\r\n                \"Reset\"\r\n        );\r\n\r\n        public static final LocalizationEntry MANAGER_GUI_WARNING_BUTTON_TOOLTIP = new LocalizationEntry(\r\n                \"gui.sfm.manager.button.warning.tooltip\",\r\n                \"Click to copy code with warnings and errors.\\nShift-click to attempt to fix warnings.\"\r\n        );\r\n\r\n        public static final LocalizationEntry MANAGER_GUI_WARNING_BUTTON_TOOLTIP_READ_ONLY = new LocalizationEntry(\r\n                \"gui.sfm.manager.button.warning.tooltip.read_only\",\r\n                \"Click to copy code with warnings and errors.\"\r\n        );\r\n\r\n        public static final LocalizationEntry MANAGER_GUI_STATUS_LOADED_CLIPBOARD = new LocalizationEntry(\r\n                \"gui.sfm.manager.status.loaded_clipboard\",\r\n                \"Loaded from clipboard!\"\r\n        );\r\n        public static final LocalizationEntry MANAGER_GUI_STATUS_SAVED_CLIPBOARD = new LocalizationEntry(\r\n                \"gui.sfm.manager.status.saved_clipboard\",\r\n                \"Saved to clipboard!\"\r\n        );\r\n        public static final LocalizationEntry MANAGER_GUI_STATUS_RESET = new LocalizationEntry(\r\n                \"gui.sfm.manager.status.reset\",\r\n                \"Reset program and labels!\"\r\n        );\r\n        public static final LocalizationEntry MANAGER_GUI_STATUS_FIX = new LocalizationEntry(\r\n                \"gui.sfm.manager.status.fix\",\r\n                \"Cleaning up labels!\"\r\n        );\r\n\r\n        public static final LocalizationEntry GUI_ADVANCED_TOOLTIP_HINT = new LocalizationEntry(\r\n                \"gui.sfm.advanced.tooltip.hint\",\r\n                ChatFormatting.GRAY + \"Hold \" + ChatFormatting.AQUA + \"%s\" + ChatFormatting.GRAY + \" for more info\"\r\n        );\r\n\r\n        public static final LocalizationEntry MORE_HOVER_INFO_KEY = new LocalizationEntry(\r\n                \"key.sfm.more_info\",\r\n                \"Show More Item Hover Info\"\r\n        );\r\n\r\n        public static final LocalizationEntry CONTAINER_INSPECTOR_TOGGLE_KEY = new LocalizationEntry(\r\n                \"key.sfm.container_inspector.activation_key\",\r\n                \"Toggle Container Inspector\"\r\n        );\r\n\r\n        public static final LocalizationEntry SFM_KEY_CATEGORY = new LocalizationEntry(\r\n                \"key.categories.sfm\",\r\n                \"Super Factory Manager\"\r\n        );\r\n\r\n        public static List<LocalizationEntry> getEntries() {\r\n            // use reflection to get all the public static LocalizationEntry fields\r\n            var rtn = new ArrayList<LocalizationEntry>();\r\n            for (var field : Constants.LocalizationKeys.class.getFields()) {\r\n                if (field.getType() == LocalizationEntry.class) {\r\n                    try {\r\n                        rtn.add((LocalizationEntry) field.get(null));\r\n                    } catch (IllegalAccessException e) {\r\n                        SFM.LOGGER.error(\"Failed reading entry field\", e);\r\n                    }\r\n                }\r\n            }\r\n            return rtn;\r\n        }\r\n\r\n        public record LocalizationEntry(\r\n                Supplier<String> key,\r\n                Supplier<String> value\r\n        ) {\r\n            public LocalizationEntry(String key, String value) {\r\n                this(() -> key, () -> value);\r\n            }\r\n\r\n            public TranslatableContents get(Object... args) {\r\n                return SFMUtils.getTranslatableContents(key.get(), args);\r\n            }\r\n\r\n            public TranslatableContents get() {\r\n                return SFMUtils.getTranslatableContents(key.get());\r\n            }\r\n\r\n            public String getString() {\r\n                return I18n.get(key.get());\r\n            }\r\n\r\n            public String getString(Object... args) {\r\n                return I18n.get(key.get(), args);\r\n            }\r\n\r\n            public MutableComponent getComponent() {\r\n                return Component.translatable(key.get());\r\n            }\r\n\r\n            public MutableComponent getComponent(Object... args) {\r\n                return Component.translatable(key.get(), args);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfml\\ast\\TimerTrigger.java\r\n\r\n````java\r\npackage ca.teamdman.sfml.ast;\r\n\r\nimport ca.teamdman.sfm.common.program.ProgramContext;\r\n\r\nimport java.util.List;\r\n\r\npublic record TimerTrigger(\r\n        Interval interval,\r\n        Block block\r\n) implements Trigger {\r\n    @Override\r\n    public Block getBlock() {\r\n        return block;\r\n    }\r\n\r\n    @Override\r\n    public boolean shouldTick(ProgramContext context) {\r\n        if (context.getExecutionPolicy() == ProgramContext.ExecutionPolicy.EXPLORE_BRANCHES) return true;\r\n        return context.getManager().getTick() % interval.getTicks() == 0;\r\n    }\r\n\r\n    @Override\r\n    public void tick(ProgramContext context) {\r\n        block.tick(context);\r\n    }\r\n\r\n    @Override\r\n    public List<Statement> getStatements() {\r\n        return List.of(block);\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        String rtn = \"EVERY \" + interval + \" DO\\n\"\r\n                     + block.toString().indent(1).stripTrailing()\r\n                     + \"\\nEND\";\r\n        return rtn;\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\recipe\\PrintingPressRecipe.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.common.recipe;\r\n\r\nimport ca.teamdman.sfm.common.blockentity.PrintingPressBlockEntity;\r\nimport ca.teamdman.sfm.common.item.FormItem;\r\nimport ca.teamdman.sfm.common.registry.SFMRecipeSerializers;\r\nimport ca.teamdman.sfm.common.registry.SFMRecipeTypes;\r\nimport com.google.gson.JsonObject;\r\nimport net.minecraft.network.FriendlyByteBuf;\r\nimport net.minecraft.resources.ResourceLocation;\r\nimport net.minecraft.world.item.ItemStack;\r\nimport net.minecraft.world.item.crafting.Ingredient;\r\nimport net.minecraft.world.item.crafting.Recipe;\r\nimport net.minecraft.world.item.crafting.RecipeSerializer;\r\nimport net.minecraft.world.item.crafting.RecipeType;\r\nimport net.minecraft.world.level.Level;\r\nimport org.jetbrains.annotations.Nullable;\r\n\r\nimport java.util.Objects;\r\n\r\n/**\r\n * Printing press copies a form using ink and paper.\r\n */\r\npublic class PrintingPressRecipe implements Recipe<PrintingPressBlockEntity> {\r\n    public final ResourceLocation ID;\r\n    public final Ingredient FORM;\r\n    public final Ingredient INK;\r\n    public final Ingredient PAPER;\r\n\r\n    /**\r\n     *\r\n     */\r\n    public PrintingPressRecipe(\r\n            ResourceLocation id,\r\n            Ingredient form,\r\n            Ingredient ink,\r\n            Ingredient paper\r\n    ) {\r\n        this.ID = id;\r\n        this.FORM = form;\r\n        this.INK = ink;\r\n        this.PAPER = paper;\r\n    }\r\n\r\n    @Override\r\n    public boolean matches(PrintingPressBlockEntity pContainer, Level pLevel) {\r\n        return PAPER.test(pContainer.getPaper()) && INK.test(pContainer.getInk()) && FORM.test(FormItem.getReference(\r\n                pContainer.getForm()));\r\n    }\r\n\r\n    @Override\r\n    public ItemStack assemble(PrintingPressBlockEntity pContainer) {\r\n        ItemStack rtn = FormItem.getReference(pContainer.getForm());\r\n        rtn.setCount(pContainer.getPaper().getCount());\r\n        return rtn;\r\n    }\r\n\r\n    @Override\r\n    public boolean canCraftInDimensions(int pWidth, int pHeight) {\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public ItemStack getResultItem() {\r\n        return ItemStack.EMPTY;\r\n    }\r\n\r\n    @Override\r\n    public ResourceLocation getId() {\r\n        return ID;\r\n    }\r\n\r\n    @Override\r\n    public RecipeSerializer<?> getSerializer() {\r\n        return SFMRecipeSerializers.PRINTING_PRESS.get();\r\n    }\r\n\r\n    @Override\r\n    public RecipeType<?> getType() {\r\n        return SFMRecipeTypes.PRINTING_PRESS.get();\r\n    }\r\n\r\n    @Override\r\n    public boolean equals(Object obj) {\r\n        if (obj == this) return true;\r\n        if (obj == null || obj.getClass() != this.getClass()) return false;\r\n        var that = (PrintingPressRecipe) obj;\r\n        return Objects.equals(this.ID, that.ID) &&\r\n               Objects.equals(this.FORM, that.FORM) &&\r\n               Objects.equals(this.INK, that.INK) &&\r\n               Objects.equals(this.PAPER, that.PAPER);\r\n    }\r\n\r\n    @Override\r\n    public int hashCode() {\r\n        return Objects.hash(ID, FORM, INK, PAPER);\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"PrintingPressRecipe[\" +\r\n               \"id=\" + ID + \", \" +\r\n               \"form=\" + FORM + \", \" +\r\n               \"ink=\" + INK + \", \" +\r\n               \"paper=\" + PAPER + ']';\r\n    }\r\n\r\n    public static class Serializer implements RecipeSerializer<PrintingPressRecipe> {\r\n        @Override\r\n        public PrintingPressRecipe fromJson(ResourceLocation pRecipeId, JsonObject pSerializedRecipe) {\r\n            Ingredient form = Ingredient.fromJson(pSerializedRecipe.get(\"form\"));\r\n            Ingredient ink = Ingredient.fromJson(pSerializedRecipe.get(\"ink\"));\r\n            Ingredient paper = Ingredient.fromJson(pSerializedRecipe.get(\"paper\"));\r\n            return new PrintingPressRecipe(pRecipeId, form, ink, paper);\r\n        }\r\n\r\n        @Override\r\n        public @Nullable PrintingPressRecipe fromNetwork(ResourceLocation pRecipeId, FriendlyByteBuf pBuffer) {\r\n            Ingredient form = Ingredient.fromNetwork(pBuffer);\r\n            Ingredient ink = Ingredient.fromNetwork(pBuffer);\r\n            Ingredient paper = Ingredient.fromNetwork(pBuffer);\r\n            return new PrintingPressRecipe(pRecipeId, form, ink, paper);\r\n        }\r\n\r\n        @Override\r\n        public void toNetwork(FriendlyByteBuf pBuffer, PrintingPressRecipe pRecipe) {\r\n            pRecipe.FORM.toNetwork(pBuffer);\r\n            pRecipe.INK.toNetwork(pBuffer);\r\n            pRecipe.PAPER.toNetwork(pBuffer);\r\n        }\r\n    }\r\n\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\package-info.java\r\n\r\n````java\r\n\r\n\r\n@ParametersAreNonnullByDefault\r\n@MethodsReturnNonnullByDefault\r\n@FieldsAreNonnullByDefault\r\npackage ca.teamdman.sfm;\r\n\r\nimport net.minecraft.FieldsAreNonnullByDefault;\r\nimport net.minecraft.MethodsReturnNonnullByDefault;\r\n\r\nimport javax.annotation.ParametersAreNonnullByDefault;\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\util\\SFMUtils.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.common.util;\r\n\r\nimport ca.teamdman.sfm.SFM;\r\nimport ca.teamdman.sfm.common.capabilityprovidermapper.CapabilityProviderMapper;\r\nimport ca.teamdman.sfm.common.program.LimitedInputSlot;\r\nimport ca.teamdman.sfm.common.registry.SFMCapabilityProviderMappers;\r\nimport ca.teamdman.sfm.common.registry.SFMResourceTypes;\r\nimport ca.teamdman.sfm.common.resourcetype.ResourceType;\r\nimport ca.teamdman.sfml.ast.Number;\r\nimport ca.teamdman.sfml.ast.*;\r\nimport net.minecraft.core.BlockPos;\r\nimport net.minecraft.core.Direction;\r\nimport net.minecraft.nbt.CompoundTag;\r\nimport net.minecraft.nbt.ListTag;\r\nimport net.minecraft.nbt.StringTag;\r\nimport net.minecraft.nbt.Tag;\r\nimport net.minecraft.network.chat.contents.TranslatableContents;\r\nimport net.minecraft.resources.ResourceKey;\r\nimport net.minecraft.resources.ResourceLocation;\r\nimport net.minecraft.world.level.LevelAccessor;\r\nimport net.minecraftforge.common.capabilities.CapabilityProvider;\r\nimport net.minecraftforge.common.capabilities.ICapabilityProvider;\r\n\r\nimport javax.annotation.Nullable;\r\nimport java.util.*;\r\nimport java.util.function.Consumer;\r\nimport java.util.stream.Stream;\r\n\r\npublic class SFMUtils {\r\n\r\n    /**\r\n     * Gets a stream using a self-feeding mapping function. Prevents the\r\n     * re-traversal of elements that have been visited before.\r\n     *\r\n     * @param operator Consumes queue elements to build the result set and\r\n     *                 append the next queue elements\r\n     * @param first    Initial value, not checked against the filter\r\n     * @param <T>      Type that the mapper consumes and produces\r\n     * @return Stream result after termination of the recursive mapping process\r\n     */\r\n    public static <T> Stream<T> getRecursiveStream(\r\n            RecursiveBuilder<T> operator, T first\r\n    ) {\r\n        Stream.Builder<T> builder = Stream.builder();\r\n        Set<T> debounce = new HashSet<>();\r\n        Deque<T> toVisit = new ArrayDeque<>();\r\n        toVisit.add(first);\r\n        debounce.add(first);\r\n        while (!toVisit.isEmpty()) {\r\n            T current = toVisit.pop();\r\n            operator.accept(current, next -> {\r\n                if (!debounce.contains(next)) {\r\n                    debounce.add(next);\r\n                    toVisit.add(next);\r\n                }\r\n            }, builder::add);\r\n        }\r\n        return builder.build();\r\n    }\r\n\r\n    public static TranslatableContents deserializeTranslation(CompoundTag tag) {\r\n        var key = tag.getString(\"key\");\r\n        var args = tag\r\n                .getList(\"args\", Tag.TAG_STRING)\r\n                .stream()\r\n                .map(StringTag.class::cast)\r\n                .map(StringTag::getAsString)\r\n                .toArray();\r\n        return getTranslatableContents(key, args);\r\n    }\r\n\r\n    public static CompoundTag serializeTranslation(TranslatableContents contents) {\r\n        CompoundTag tag = new CompoundTag();\r\n        tag.putString(\"key\", contents.getKey());\r\n        ListTag args = new ListTag();\r\n        for (var arg : contents.getArgs()) {\r\n            args.add(StringTag.valueOf(arg.toString()));\r\n        }\r\n        tag.put(\"args\", args);\r\n        return tag;\r\n    }\r\n\r\n    /**\r\n     * Helper method to avoid noisy git merges between versions\r\n     */\r\n    public static TranslatableContents getTranslatableContents(String key, Object... args) {\r\n        return new TranslatableContents(key, args);\r\n    }\r\n\r\n    /**\r\n     * Helper method to avoid noisy git merges between versions\r\n     */\r\n    public static TranslatableContents getTranslatableContents(String key) {\r\n        return getTranslatableContents(key, new Object[]{});\r\n    }\r\n\r\n    public interface RecursiveBuilder<T> {\r\n\r\n        void accept(T current, Consumer<T> next, Consumer<T> results);\r\n    }\r\n\r\n    public static <STACK, ITEM, CAP> Optional<InputStatement> getInputStatementForSlot(\r\n            LimitedInputSlot<STACK, ITEM, CAP> slot,\r\n            LabelAccess labelAccess\r\n    ) {\r\n        STACK potential = slot.peekExtractPotential();\r\n        if (slot.type.isEmpty(potential)) return Optional.empty();\r\n        long toMove = slot.type.getAmount(potential);\r\n        toMove = Long.min(toMove, slot.tracker.getResourceLimit().limit().quantity().number().value());\r\n        long remainingObligation = slot.tracker.getRemainingRetentionObligation();\r\n        toMove -= Long.min(toMove, remainingObligation);\r\n        potential = slot.type.withCount(potential, toMove);\r\n        STACK stack = potential;\r\n\r\n        return SFMResourceTypes.DEFERRED_TYPES\r\n                .get()\r\n                .getResourceKey(slot.type)\r\n                .map(x -> {\r\n                    //noinspection unchecked,rawtypes\r\n                    return (ResourceKey<ResourceType<STACK, ITEM, CAP>>) (ResourceKey) x;\r\n                })\r\n                .map((ResourceKey<ResourceType<STACK, ITEM, CAP>> resourceTypeResourceKey) -> SFMUtils.getInputStatementForStack(\r\n                        resourceTypeResourceKey,\r\n                        slot.type,\r\n                        stack,\r\n                        \"temp\",\r\n                        slot.slot,\r\n                        false,\r\n                        null\r\n                ))\r\n                // update the labels\r\n                .map(inputStatement -> new InputStatement(new LabelAccess(\r\n                        labelAccess.labels(),\r\n                        labelAccess.directions(),\r\n                        inputStatement.labelAccess()\r\n                                .slots(),\r\n                        RoundRobin.disabled()\r\n                ), inputStatement.resourceLimits(), inputStatement.each()));\r\n    }\r\n\r\n\r\n    public static <STACK, ITEM, CAP> InputStatement getInputStatementForStack(\r\n            ResourceKey<ResourceType<STACK, ITEM, CAP>> resourceTypeResourceKey,\r\n            ResourceType<STACK, ITEM, CAP> resourceType,\r\n            STACK stack,\r\n            String label,\r\n            int slot,\r\n            boolean each,\r\n            @Nullable Direction direction\r\n    ) {\r\n        LabelAccess labelAccess = new LabelAccess(\r\n                List.of(new Label(label)),\r\n                new DirectionQualifier(\r\n                        direction == null\r\n                        ? EnumSet.noneOf(Direction.class)\r\n                        : EnumSet.of(direction)),\r\n                new NumberRangeSet(\r\n                        new NumberRange[]{new NumberRange(slot, slot)}\r\n                ),\r\n                RoundRobin.disabled()\r\n        );\r\n        Limit limit = new Limit(\r\n                new ResourceQuantity(\r\n                        new Number(resourceType.getAmount(stack)),\r\n                        ResourceQuantity.IdExpansionBehaviour.NO_EXPAND\r\n                ),\r\n                new ResourceQuantity(\r\n                        new Number(0),\r\n                        ResourceQuantity.IdExpansionBehaviour.NO_EXPAND\r\n                )\r\n        );\r\n        ResourceLocation stackId = resourceType.getRegistryKey(stack);\r\n        ResourceIdentifier<STACK, ITEM, CAP> resourceIdentifier = new ResourceIdentifier<>(\r\n                resourceTypeResourceKey.location().getNamespace(),\r\n                resourceTypeResourceKey.location().getPath(),\r\n                stackId.getNamespace(),\r\n                stackId.getPath()\r\n        );\r\n        ResourceLimit<STACK, ITEM, CAP> resourceLimit = new ResourceLimit<>(\r\n                resourceIdentifier, limit\r\n        );\r\n        ResourceLimits resourceLimits = new ResourceLimits(\r\n                List.of(resourceLimit),\r\n                ResourceIdSet.EMPTY\r\n        );\r\n        return new InputStatement(\r\n                labelAccess,\r\n                resourceLimits,\r\n                each\r\n        );\r\n    }\r\n\r\n    public static String truncate(String input, int maxLength) {\r\n        if (input.length() > maxLength) {\r\n            SFM.LOGGER.warn(\r\n                    \"input too big, truncation has occurred! (len={}, max={}, over={})\",\r\n                    input.length(),\r\n                    maxLength,\r\n                    maxLength - input.length()\r\n            );\r\n            String truncationWarning = \"\\n...truncated\";\r\n            return input.substring(0, maxLength - truncationWarning.length()) + truncationWarning;\r\n        }\r\n        return input;\r\n    }\r\n\r\n    /**\r\n     * Find a {@link CapabilityProvider} as provided by the registered capability provider mappers.\r\n     * If multiple {@link CapabilityProviderMapper}s match, the first one is returned.\r\n     */\r\n    @SuppressWarnings(\"UnstableApiUsage\") // for the javadoc lol\r\n    public static Optional<ICapabilityProvider> discoverCapabilityProvider(LevelAccessor level, BlockPos pos) {\r\n        return SFMCapabilityProviderMappers.DEFERRED_MAPPERS\r\n                .get()\r\n                .getValues()\r\n                .stream()\r\n                .map(mapper -> mapper.getProviderFor(level, pos))\r\n                .filter(Optional::isPresent)\r\n                .map(Optional::get)\r\n                .findFirst();\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\registry\\SFMCapabilityProviderMappers.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.common.registry;\r\n\r\nimport ca.teamdman.sfm.SFM;\r\nimport ca.teamdman.sfm.common.capabilityprovidermapper.BlockEntityCapabilityProviderMapper;\r\nimport ca.teamdman.sfm.common.capabilityprovidermapper.CapabilityProviderMapper;\r\nimport ca.teamdman.sfm.common.capabilityprovidermapper.CauldronCapabilityProviderMapper;\r\nimport net.minecraft.resources.ResourceLocation;\r\nimport net.minecraftforge.eventbus.api.IEventBus;\r\nimport net.minecraftforge.registries.DeferredRegister;\r\nimport net.minecraftforge.registries.IForgeRegistry;\r\nimport net.minecraftforge.registries.RegistryBuilder;\r\nimport net.minecraftforge.registries.RegistryObject;\r\n\r\nimport java.util.function.Supplier;\r\n\r\npublic class SFMCapabilityProviderMappers {\r\n    public static final  ResourceLocation                                   REGISTRY_ID      = new ResourceLocation(\r\n            SFM.MOD_ID,\r\n            \"capability_provider_mappers\"\r\n    );\r\n    private static final DeferredRegister<CapabilityProviderMapper>         MAPPERS          = DeferredRegister.create(\r\n            REGISTRY_ID,\r\n            SFM.MOD_ID\r\n    );\r\n    public static final  Supplier<IForgeRegistry<CapabilityProviderMapper>> DEFERRED_MAPPERS = MAPPERS.makeRegistry(() -> new RegistryBuilder<CapabilityProviderMapper>().setName(\r\n            REGISTRY_ID));\r\n\r\n    public static final RegistryObject<BlockEntityCapabilityProviderMapper> BLOCK_ENTITY_MAPPER = MAPPERS.register(\r\n            \"block_entity\",\r\n            BlockEntityCapabilityProviderMapper::new\r\n    );\r\n\r\n    public static final RegistryObject<CauldronCapabilityProviderMapper> CAULDRON_MAPPER = MAPPERS.register(\r\n            \"cauldron\",\r\n            CauldronCapabilityProviderMapper::new\r\n    );\r\n\r\n    public static void register(IEventBus bus) {\r\n        MAPPERS.register(bus);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\client\\handler\\package-info.java\r\n\r\n````java\r\n@ParametersAreNonnullByDefault\r\n@MethodsReturnNonnullByDefault\r\n@FieldsAreNonnullByDefault\r\npackage ca.teamdman.sfm.client.handler;\r\n\r\nimport net.minecraft.FieldsAreNonnullByDefault;\r\nimport net.minecraft.MethodsReturnNonnullByDefault;\r\n\r\nimport javax.annotation.ParametersAreNonnullByDefault;\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\block\\WaterTankBlock.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.common.block;\r\n\r\nimport ca.teamdman.sfm.common.Constants;\r\nimport ca.teamdman.sfm.common.blockentity.WaterTankBlockEntity;\r\nimport ca.teamdman.sfm.common.registry.SFMBlockEntities;\r\nimport ca.teamdman.sfm.common.util.SFMUtils;\r\nimport net.minecraft.ChatFormatting;\r\nimport net.minecraft.core.BlockPos;\r\nimport net.minecraft.core.Direction;\r\nimport net.minecraft.network.chat.Component;\r\nimport net.minecraft.sounds.SoundEvent;\r\nimport net.minecraft.tags.FluidTags;\r\nimport net.minecraft.world.item.ItemStack;\r\nimport net.minecraft.world.item.TooltipFlag;\r\nimport net.minecraft.world.item.context.BlockPlaceContext;\r\nimport net.minecraft.world.level.BlockGetter;\r\nimport net.minecraft.world.level.Level;\r\nimport net.minecraft.world.level.LevelAccessor;\r\nimport net.minecraft.world.level.block.*;\r\nimport net.minecraft.world.level.block.entity.BlockEntity;\r\nimport net.minecraft.world.level.block.state.BlockBehaviour;\r\nimport net.minecraft.world.level.block.state.BlockState;\r\nimport net.minecraft.world.level.block.state.StateDefinition;\r\nimport net.minecraft.world.level.block.state.properties.BooleanProperty;\r\nimport net.minecraft.world.level.material.Fluid;\r\nimport net.minecraft.world.level.material.FluidState;\r\nimport net.minecraft.world.level.material.Fluids;\r\nimport net.minecraft.world.level.material.Material;\r\nimport org.jetbrains.annotations.Nullable;\r\n\r\nimport java.util.List;\r\nimport java.util.Optional;\r\n\r\n@SuppressWarnings(\"deprecation\")\r\n\r\npublic class WaterTankBlock extends BaseEntityBlock implements EntityBlock, BucketPickup, LiquidBlockContainer {\r\n    public static final BooleanProperty      IN_WATER = BooleanProperty.create(\"in_water\");\r\n\r\n\r\n    public WaterTankBlock() {\r\n        super(BlockBehaviour.Properties.of(Material.PISTON).destroyTime(2).sound(SoundType.WOOD));\r\n        registerDefaultState(getStateDefinition().any().setValue(IN_WATER, false));\r\n    }\r\n\r\n\r\n    @Override\r\n    @SuppressWarnings(\"deprecation\")\r\n    public void onPlace(BlockState pState, Level pLevel, BlockPos pPos, BlockState pOldState, boolean pIsMoving) {\r\n        super.onPlace(pState, pLevel, pPos, pOldState, pIsMoving);\r\n        for (Direction direction : Direction.values()) {\r\n            recount(pLevel, pPos.offset(direction.getNormal()));\r\n        }\r\n    }\r\n\r\n    @Override\r\n    @SuppressWarnings(\"deprecation\")\r\n    public void onRemove(BlockState pState, Level pLevel, BlockPos pPos, BlockState pNewState, boolean pIsMoving) {\r\n        super.onRemove(pState, pLevel, pPos, pNewState, pIsMoving);\r\n        for (Direction direction : Direction.values()) {\r\n            recount(pLevel, pPos.offset(direction.getNormal()));\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void appendHoverText(\r\n            ItemStack pStack,\r\n            @Nullable BlockGetter pLevel,\r\n            List<Component> pTooltip,\r\n            TooltipFlag pFlag\r\n    ) {\r\n        pTooltip.add(Constants.LocalizationKeys.WATER_TANK_ITEM_TOOLTIP_1\r\n                             .getComponent()\r\n                             .withStyle(ChatFormatting.GRAY));\r\n        pTooltip.add(Constants.LocalizationKeys.WATER_TANK_ITEM_TOOLTIP_2\r\n                             .getComponent()\r\n                             .withStyle(ChatFormatting.GRAY));\r\n    }\r\n\r\n    public void recount(Level level, BlockPos pos) {\r\n        if (!(level.getBlockEntity(pos) instanceof WaterTankBlockEntity be)) return;\r\n        var tanks = SFMUtils.getRecursiveStream((current, next, results) -> {\r\n            results.accept(current);\r\n            for (var d : Direction.values()) {\r\n                var offset = current.getBlockPos().offset(d.getNormal());\r\n                if (!(level.getBlockEntity(offset) instanceof WaterTankBlockEntity blockEntity)) continue;\r\n                next.accept(blockEntity);\r\n            }\r\n        }, be).toList();\r\n        tanks.forEach(t -> t.setConnectedCount(tanks.size()));\r\n    }\r\n\r\n    @Override\r\n    public RenderShape getRenderShape(BlockState state) {\r\n        return RenderShape.MODEL;\r\n    }\r\n\r\n    @Override\r\n    protected void createBlockStateDefinition(StateDefinition.Builder<Block, BlockState> builder) {\r\n        builder.add(IN_WATER);\r\n    }\r\n\r\n    @Nullable\r\n    @Override\r\n    public BlockEntity newBlockEntity(BlockPos pos, BlockState state) {\r\n        return SFMBlockEntities.WATER_TANK_BLOCK_ENTITY.get().create(pos, state);\r\n    }\r\n\r\n    @Nullable\r\n    @Override\r\n    public BlockState getStateForPlacement(BlockPlaceContext context) {\r\n        return defaultBlockState().setValue(\r\n                IN_WATER,\r\n                isActive(context.getLevel(), context.getClickedPos())\r\n        );\r\n    }\r\n\r\n    public boolean isActive(LevelAccessor level, BlockPos pos) {\r\n        int neighbourWaterCount = 0;\r\n        for (Direction direction : Direction.values()) {\r\n            FluidState state = level.getFluidState(pos.relative(direction));\r\n            if (state.isSource() && state.is(FluidTags.WATER)) {\r\n                if (++neighbourWaterCount == 2) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    @Override\r\n    @SuppressWarnings(\"deprecation\")\r\n    public void neighborChanged(\r\n            BlockState state,\r\n            Level level,\r\n            BlockPos pos,\r\n            Block blockIn,\r\n            BlockPos fromPos,\r\n            boolean isMoving\r\n    ) {\r\n        if (level.isClientSide) return;\r\n        boolean isActive = isActive(level, pos);\r\n        if (state.getValue(IN_WATER) != isActive) {\r\n            BlockState newState = defaultBlockState().setValue(IN_WATER, isActive);\r\n            level.setBlock(\r\n                    pos,\r\n                    newState,\r\n                    1 | 2\r\n            );\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public ItemStack pickupBlock(LevelAccessor level, BlockPos pos, BlockState state) {\r\n        return state.getValue(IN_WATER) ? new ItemStack(Fluids.WATER.getBucket()) : ItemStack.EMPTY;\r\n    }\r\n\r\n    @Override\r\n    public Optional<SoundEvent> getPickupSound() {\r\n        return Fluids.WATER.getPickupSound();\r\n    }\r\n\r\n    @Override\r\n    public boolean canPlaceLiquid(BlockGetter level, BlockPos pos, BlockState state, Fluid fluid) {\r\n        return fluid.isSame(Fluids.WATER);\r\n    }\r\n\r\n    @Override\r\n    public boolean placeLiquid(LevelAccessor level, BlockPos pos, BlockState state, FluidState fluid) {\r\n        return fluid.getType().isSame(Fluids.WATER);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\handler\\package-info.java\r\n\r\n````java\r\n\r\n\r\n@ParametersAreNonnullByDefault\r\n@MethodsReturnNonnullByDefault\r\n@FieldsAreNonnullByDefault\r\npackage ca.teamdman.sfm.common.handler;\r\n\r\nimport net.minecraft.FieldsAreNonnullByDefault;\r\nimport net.minecraft.MethodsReturnNonnullByDefault;\r\n\r\nimport javax.annotation.ParametersAreNonnullByDefault;\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\program\\InputResourceTracker.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.common.program;\r\n\r\nimport ca.teamdman.sfm.common.resourcetype.ResourceType;\r\nimport ca.teamdman.sfml.ast.ResourceIdSet;\r\nimport ca.teamdman.sfml.ast.ResourceLimit;\r\nimport it.unimi.dsi.fastutil.ints.Int2LongArrayMap;\r\n\r\nimport java.util.concurrent.atomic.AtomicLong;\r\nimport java.util.function.Predicate;\r\n\r\npublic class InputResourceTracker<STACK, ITEM, CAP> implements Predicate<Object> {\r\n\r\n    private final ResourceLimit<STACK, ITEM, CAP> RESOURCE_LIMIT;\r\n    private final ResourceIdSet EXCLUSIONS;\r\n    private final Int2LongArrayMap RETENTION_OBLIGATIONS = new Int2LongArrayMap();\r\n    private final AtomicLong TRANSFERRED;\r\n    private final AtomicLong RETENTION_OBLIGATION_PROGRESS;\r\n\r\n    public InputResourceTracker(\r\n            ResourceLimit<STACK, ITEM, CAP> limit,\r\n            ResourceIdSet exclusions,\r\n            AtomicLong transferred,\r\n            AtomicLong retentionObligationProgress\r\n    ) {\r\n        this.RESOURCE_LIMIT = limit;\r\n        this.EXCLUSIONS = exclusions;\r\n        this.TRANSFERRED = transferred;\r\n        this.RETENTION_OBLIGATION_PROGRESS = retentionObligationProgress;\r\n    }\r\n\r\n    public boolean isDone() {\r\n        return TRANSFERRED.get() >= RESOURCE_LIMIT.limit().quantity().number().value();\r\n    }\r\n\r\n    public long getExistingRetentionObligation(int slot) {\r\n        return RETENTION_OBLIGATIONS.getOrDefault(slot, 0);\r\n    }\r\n\r\n    public long getRemainingRetentionObligation() {\r\n        return RESOURCE_LIMIT.limit().retention().number().value() - RETENTION_OBLIGATION_PROGRESS.get();\r\n    }\r\n\r\n    public void trackRetentionObligation(int slot, long promise) {\r\n        this.RETENTION_OBLIGATION_PROGRESS.accumulateAndGet(promise, Long::sum);\r\n        this.RETENTION_OBLIGATIONS.merge(slot, promise, Long::sum);\r\n    }\r\n\r\n    public ResourceLimit<STACK, ITEM, CAP> getResourceLimit() {\r\n        return RESOURCE_LIMIT;\r\n    }\r\n\r\n    public long getMaxTransferable() {\r\n        return RESOURCE_LIMIT.limit().quantity().number().value() - TRANSFERRED.get();\r\n    }\r\n\r\n    public void trackTransfer(long amount) {\r\n        TRANSFERRED.accumulateAndGet(amount, Long::sum);\r\n    }\r\n\r\n    @Override\r\n    public boolean test(Object stack) {\r\n        return RESOURCE_LIMIT.test(stack) && !EXCLUSIONS.test(stack);\r\n    }\r\n\r\n    public boolean matchesCapabilityType(Object capability) {\r\n        ResourceType<STACK, ITEM, CAP> resourceType = RESOURCE_LIMIT.resourceId().getResourceType();\r\n        return resourceType != null && resourceType.matchesCapabilityType(capability);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\program\\LimitedOutputSlotObjectPool.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.common.program;\r\n\r\nimport java.util.Arrays;\r\nimport java.util.List;\r\n\r\n/**\r\n * A pool of {@link LimitedOutputSlot} objects to avoid the garbage collector\r\n * <p>\r\n * This assumes that the pool will be used in a single thread.\r\n */\r\npublic class LimitedOutputSlotObjectPool {\r\n    public static final LimitedOutputSlotObjectPool INSTANCE = new LimitedOutputSlotObjectPool();\r\n    @SuppressWarnings(\"rawtypes\")\r\n    private LimitedOutputSlot[] pool = new LimitedOutputSlot[1];\r\n    private int index = -1;\r\n\r\n    /**\r\n     * Acquire a {@link LimitedOutputSlot} from the pool, or creates a new one if none available\r\n     */\r\n    public <STACK, ITEM, CAP> LimitedOutputSlot<STACK, ITEM, CAP> acquire(\r\n            CAP handler,\r\n            int slot,\r\n            OutputResourceTracker<STACK, ITEM, CAP> tracker\r\n    ) {\r\n        if (index == -1) {\r\n            return new LimitedOutputSlot<>(handler, slot, tracker);\r\n        } else {\r\n            @SuppressWarnings(\"unchecked\") LimitedOutputSlot<STACK, ITEM, CAP> obj = pool[index];\r\n            index--;\r\n            obj.init(handler, slot, tracker);\r\n            return obj;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Release a {@link LimitedOutputSlot} back into the pool for it to be reused instead of garbage collected\r\n     */\r\n    public void release(LimitedOutputSlot<?, ?, ?> obj) {\r\n        if (index == pool.length - 1) {\r\n            // we need to grow the array\r\n            pool = Arrays.copyOf(pool, pool.length * 2);\r\n        }\r\n        pool[++index] = obj;\r\n    }\r\n\r\n    /**\r\n     * Release a {@link LimitedOutputSlot} back into the pool for it to be reused instead of garbage collected\r\n     */\r\n    @SuppressWarnings(\"rawtypes\")\r\n    public void release(List<LimitedOutputSlot> slots) {\r\n        // handle resizing\r\n        if (index + slots.size() >= pool.length) {\r\n            int slotsFree = pool.length - index - 1;\r\n            int newLength = pool.length + slots.size() - slotsFree;\r\n            pool = Arrays.copyOf(pool, newLength);\r\n        }\r\n        // add to pool\r\n        for (LimitedOutputSlot<?, ?, ?> slot : slots) {\r\n            index++;\r\n            pool[index] = slot;\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfml\\ast\\Label.java\r\n\r\n````java\r\npackage ca.teamdman.sfml.ast;\r\n\r\npublic record Label(String name) implements ASTNode {\r\n    @Override\r\n    public String toString() {\r\n        return name;\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfml\\ast\\ASTNode.java\r\n\r\n````java\r\npackage ca.teamdman.sfml.ast;\r\n\r\nimport java.util.List;\r\n\r\npublic interface ASTNode {\r\n    default List<Statement> getStatements() {\r\n        return List.of();\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfml\\ast\\ResourceComparer.java\r\n\r\n````java\r\npackage ca.teamdman.sfml.ast;\r\n\r\nimport ca.teamdman.sfm.common.resourcetype.ResourceType;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\npublic record ResourceComparer<STACK, ITEM, CAP>(\r\n        ComparisonOperator op,\r\n        ResourceQuantity quantity,\r\n        ResourceIdentifier<STACK, ITEM, CAP> res\r\n) implements ASTNode {\r\n    public BoolExpr toBooleanExpression(SetOperator setOp, LabelAccess labelAccess, String sourceCode) {\r\n        return new BoolExpr(\r\n                context -> {\r\n                    ResourceType<STACK, ITEM, CAP> type = res.getResourceType();\r\n                    if (type == null) return false;\r\n                    // get the inventories to check\r\n\r\n                    var handlers = type.getCapabilities(context, labelAccess);\r\n\r\n                    // track how many items seen\r\n                    long overallCount = 0;\r\n                    // track how many inventories satisfied the condition\r\n                    List<Boolean> satisfiedSet = new ArrayList<>();\r\n\r\n                    for (var cap : (Iterable<CAP>) handlers::iterator) {\r\n                        long invCount = 0;\r\n                        for (var stack : (Iterable<STACK>) type.collect(cap, labelAccess)::iterator) {\r\n                            if (this.res.test(stack)) {\r\n                                invCount += type.getAmount(stack);\r\n                                overallCount += type.getAmount(stack);\r\n                            }\r\n                        }\r\n                        satisfiedSet.add(this.op.test(invCount, this.quantity.number().value()));\r\n                    }\r\n                    var isOverallSatisfied = this.op.test(overallCount, this.quantity.number().value());\r\n                    return setOp.test(isOverallSatisfied, satisfiedSet);\r\n                },\r\n                labelAccess + \" HAS \" + sourceCode\r\n        );\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return op().getSourceCode() + \" \" + quantity() + \" \" + res().toStringCondensed();\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\net\\ClientboundLabelInspectionResultsPacket.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.common.net;\r\n\r\nimport ca.teamdman.sfm.client.ClientStuff;\r\nimport net.minecraft.network.FriendlyByteBuf;\r\nimport net.minecraftforge.network.NetworkEvent;\r\n\r\nimport java.util.function.Supplier;\r\n\r\npublic record ClientboundLabelInspectionResultsPacket(\r\n        String results\r\n) {\r\n    public static final int MAX_RESULTS_LENGTH = 50_000;\r\n\r\n    public static void encode(\r\n            ClientboundLabelInspectionResultsPacket msg, FriendlyByteBuf friendlyByteBuf\r\n    ) {\r\n        friendlyByteBuf.writeUtf(msg.results(), MAX_RESULTS_LENGTH);\r\n    }\r\n\r\n    public static ClientboundLabelInspectionResultsPacket decode(FriendlyByteBuf friendlyByteBuf) {\r\n        return new ClientboundLabelInspectionResultsPacket(\r\n                friendlyByteBuf.readUtf(MAX_RESULTS_LENGTH)\r\n        );\r\n    }\r\n\r\n    public static void handle(\r\n            ClientboundLabelInspectionResultsPacket msg, Supplier<NetworkEvent.Context> contextSupplier\r\n    ) {\r\n        contextSupplier.get().enqueueWork(() -> ClientStuff.showProgramEditScreen(msg.results, next -> {\r\n        }));\r\n        contextSupplier.get().setPacketHandled(true);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\net\\ServerboundLabelInspectionRequestPacket.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.common.net;\r\n\r\nimport ca.teamdman.sfm.SFM;\r\nimport ca.teamdman.sfm.common.containermenu.ManagerContainerMenu;\r\nimport ca.teamdman.sfm.common.program.LabelPositionHolder;\r\nimport ca.teamdman.sfm.common.registry.SFMItems;\r\nimport ca.teamdman.sfm.common.registry.SFMPackets;\r\nimport ca.teamdman.sfml.ast.Program;\r\nimport net.minecraft.core.BlockPos;\r\nimport net.minecraft.network.FriendlyByteBuf;\r\nimport net.minecraft.server.level.ServerPlayer;\r\nimport net.minecraftforge.network.NetworkEvent;\r\nimport net.minecraftforge.network.PacketDistributor;\r\n\r\nimport java.util.Set;\r\nimport java.util.function.Supplier;\r\n\r\npublic record ServerboundLabelInspectionRequestPacket(\r\n        String label\r\n) {\r\n    public static void encode(ServerboundLabelInspectionRequestPacket msg, FriendlyByteBuf friendlyByteBuf) {\r\n        friendlyByteBuf.writeUtf(msg.label(), Program.MAX_LABEL_LENGTH);\r\n    }\r\n\r\n    public static ServerboundLabelInspectionRequestPacket decode(FriendlyByteBuf friendlyByteBuf) {\r\n        return new ServerboundLabelInspectionRequestPacket(\r\n                friendlyByteBuf.readUtf(Program.MAX_LABEL_LENGTH)\r\n        );\r\n    }\r\n\r\n    public static void handle(\r\n            ServerboundLabelInspectionRequestPacket msg,\r\n            Supplier<NetworkEvent.Context> contextSupplier\r\n    ) {\r\n        contextSupplier.get().enqueueWork(() -> {\r\n            // we don't know if the player has the program edit screen open from a manager or a disk in hand\r\n            ServerPlayer player = contextSupplier.get().getSender();\r\n            if (player == null) return;\r\n            SFM.LOGGER.info(\"Received label inspection request packet from player \" + player.getStringUUID());\r\n            LabelPositionHolder labelPositionHolder;\r\n            if (player.containerMenu instanceof ManagerContainerMenu mcm) {\r\n                SFM.LOGGER.info(\"Player is using a manager container menu - will append additional info to payload\");\r\n                labelPositionHolder = LabelPositionHolder.from(mcm.CONTAINER.getItem(0));\r\n            } else {\r\n                if (player.getMainHandItem().is(SFMItems.DISK_ITEM.get())) {\r\n                    labelPositionHolder = LabelPositionHolder.from(player.getMainHandItem());\r\n                } else if (player.getOffhandItem().is(SFMItems.DISK_ITEM.get())) {\r\n                    labelPositionHolder = LabelPositionHolder.from(player.getOffhandItem());\r\n                } else {\r\n                    labelPositionHolder = null;\r\n                }\r\n            }\r\n            if (labelPositionHolder == null) {\r\n                SFM.LOGGER.info(\"Label holder wasn't found - aborting\");\r\n                return;\r\n            }\r\n            SFM.LOGGER.info(\"building payload\");\r\n            StringBuilder payload = new StringBuilder();\r\n            payload.append(\"-- Positions for label \\\"\").append(msg.label()).append(\"\\\" --\\n\");\r\n            payload.append(labelPositionHolder.getPositions(msg.label()).size()).append(\" assignments\\n\");\r\n            payload.append(\"-- Summary --\\n\");\r\n            labelPositionHolder.get().getOrDefault(msg.label(), Set.of()).forEach(pos -> {\r\n                payload\r\n                        .append(pos.getX())\r\n                        .append(\",\")\r\n                        .append(pos.getY())\r\n                        .append(\",\")\r\n                        .append(pos.getZ());\r\n                if (player.getLevel().isLoaded(pos)) {\r\n                    payload\r\n                            .append(\" -- \")\r\n                            .append(player.getLevel().getBlockState(pos).getBlock().getName().getString());\r\n                } else {\r\n                    payload\r\n                            .append(\" -- chunk not loaded\");\r\n                }\r\n                payload\r\n                        .append(\"\\n\");\r\n            });\r\n\r\n            payload.append(\"\\n\\n\\n-- Detailed --\\n\");\r\n            for (BlockPos pos : labelPositionHolder.get().getOrDefault(msg.label(), Set.of())) {\r\n                if (payload.length() > 20_000) {\r\n                    payload.append(\"... (truncated)\");\r\n                    break;\r\n                }\r\n                payload\r\n                        .append(pos.getX())\r\n                        .append(\",\")\r\n                        .append(pos.getY())\r\n                        .append(\",\")\r\n                        .append(pos.getZ());\r\n                if (player.getLevel().isLoaded(pos)) {\r\n                    payload\r\n                            .append(\" -- \")\r\n                            .append(player.getLevel().getBlockState(pos).getBlock().getName().getString());\r\n\r\n                    payload.append(\"\\n\").append(ServerboundContainerExportsInspectionRequestPacket\r\n                                                        .buildInspectionResults(player.getLevel(), pos)\r\n                                                        .indent(1));\r\n                } else {\r\n                    payload\r\n                            .append(\" -- chunk not loaded\");\r\n                }\r\n                payload\r\n                        .append(\"\\n\");\r\n            }\r\n            SFM.LOGGER.info(\"Sending payload response length=\"\r\n                            + payload.length()\r\n                            + \" to player \"\r\n                            + player.getStringUUID());\r\n            SFMPackets.INSPECTION_CHANNEL.send(\r\n                    PacketDistributor.PLAYER.with(() -> player),\r\n                    new ClientboundLabelInspectionResultsPacket(\r\n                            payload.toString()\r\n                    )\r\n            );\r\n        });\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\client\\gui\\screen\\package-info.java\r\n\r\n````java\r\n@ParametersAreNonnullByDefault\r\n@MethodsReturnNonnullByDefault\r\n@FieldsAreNonnullByDefault\r\npackage ca.teamdman.sfm.client.gui.screen;\r\n\r\nimport net.minecraft.FieldsAreNonnullByDefault;\r\nimport net.minecraft.MethodsReturnNonnullByDefault;\r\n\r\nimport javax.annotation.ParametersAreNonnullByDefault;\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\client\\handler\\ItemWorldRenderer.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.client.handler;\r\n\r\nimport ca.teamdman.sfm.SFM;\r\nimport ca.teamdman.sfm.common.item.LabelGunItem;\r\nimport ca.teamdman.sfm.common.item.NetworkToolItem;\r\nimport ca.teamdman.sfm.common.program.LabelPositionHolder;\r\nimport com.google.common.collect.HashMultimap;\r\nimport com.mojang.blaze3d.platform.GlStateManager;\r\nimport com.mojang.blaze3d.systems.RenderSystem;\r\nimport com.mojang.blaze3d.vertex.*;\r\nimport net.minecraft.client.Camera;\r\nimport net.minecraft.client.Minecraft;\r\nimport net.minecraft.client.gui.Font;\r\nimport net.minecraft.client.renderer.GameRenderer;\r\nimport net.minecraft.client.renderer.MultiBufferSource;\r\nimport net.minecraft.client.renderer.RenderStateShard;\r\nimport net.minecraft.client.renderer.RenderType;\r\nimport net.minecraft.client.renderer.texture.TextureAtlas;\r\nimport net.minecraft.core.BlockPos;\r\nimport net.minecraft.nbt.CompoundTag;\r\nimport net.minecraft.nbt.NbtUtils;\r\nimport net.minecraft.nbt.Tag;\r\nimport net.minecraftforge.api.distmarker.Dist;\r\nimport net.minecraftforge.client.event.RenderLevelStageEvent;\r\nimport net.minecraftforge.eventbus.api.SubscribeEvent;\r\nimport net.minecraftforge.fml.common.Mod;\r\nimport org.jetbrains.annotations.Nullable;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.Collection;\r\nimport java.util.List;\r\n\r\n@Mod.EventBusSubscriber(modid = SFM.MOD_ID, bus = Mod.EventBusSubscriber.Bus.FORGE, value = Dist.CLIENT)\r\n/*\r\n * This class uses code from tasgon's \"observable\" mod, also using MPLv2\r\n * https://github.com/tasgon/observable/blob/master/common/src/main/kotlin/observable/client/Overlay.kt\r\n */\r\npublic class ItemWorldRenderer {\r\n    private static final int BUFFER_SIZE = 256;\r\n    @SuppressWarnings(\"deprecation\")\r\n    private static final RenderType RENDER_TYPE = RenderType.create(\r\n            \"sfmlabels\",\r\n            DefaultVertexFormat.POSITION_COLOR,\r\n            VertexFormat.Mode.QUADS,\r\n            BUFFER_SIZE,\r\n            false,\r\n            false,\r\n            RenderType.CompositeState\r\n                    .builder()\r\n                    .setTextureState(new RenderStateShard.TextureStateShard(TextureAtlas.LOCATION_BLOCKS, false, false))\r\n                    .setDepthTestState(new RenderStateShard.DepthTestStateShard(\"always\", 519))\r\n                    .setTransparencyState(\r\n                            new RenderStateShard.TransparencyStateShard(\r\n                                    \"src_to_one\",\r\n                                    () -> {\r\n                                        RenderSystem.enableBlend();\r\n                                        RenderSystem.blendFunc(\r\n                                                GlStateManager.SourceFactor.SRC_ALPHA,\r\n                                                GlStateManager.DestFactor.ONE\r\n                                        );\r\n                                    },\r\n                                    () -> {\r\n                                        RenderSystem.disableBlend();\r\n                                        RenderSystem.defaultBlendFunc();\r\n                                    }\r\n                            )\r\n                    )\r\n                    .createCompositeState(true)\r\n    );\r\n    @Nullable\r\n    private static VertexBuffer capabilityProviderVBO;\r\n    @Nullable\r\n    private static VertexBuffer cableVBO;\r\n\r\n    @SubscribeEvent\r\n    public static void renderLabelHighlights(RenderLevelStageEvent event) {\r\n        if (event.getStage() != RenderLevelStageEvent.Stage.AFTER_TRANSLUCENT_BLOCKS) return;\r\n        var player = Minecraft.getInstance().player;\r\n        if (player == null) return;\r\n\r\n        var labelGun = player.getMainHandItem();\r\n        if (!(labelGun.getItem() instanceof LabelGunItem)) labelGun = player.getOffhandItem();\r\n        if (labelGun.getItem() instanceof LabelGunItem) {\r\n            var labels = LabelPositionHolder.from(labelGun);\r\n            var labelPositions = HashMultimap.<BlockPos, String>create();\r\n            labels.forEach((label, pos1) -> labelPositions.put(pos1, label));\r\n\r\n            var poseStack = event.getPoseStack();\r\n            var camera = Minecraft.getInstance().gameRenderer.getMainCamera();\r\n            var bufferSource = Minecraft.getInstance().renderBuffers().bufferSource();\r\n\r\n            RenderSystem.disableDepthTest();\r\n\r\n            poseStack.pushPose();\r\n            poseStack.translate(-camera.getPosition().x, -camera.getPosition().y, -camera.getPosition().z);\r\n\r\n            { // draw labels\r\n                for (var entry : labelPositions.asMap().entrySet()) {\r\n                    drawLabel(poseStack, camera, entry.getKey(), bufferSource, entry.getValue());\r\n                }\r\n            }\r\n            { // draw highlights\r\n                RENDER_TYPE.setupRenderState();\r\n                RenderSystem.disableTexture();\r\n\r\n                if (capabilityProviderVBO == null) {\r\n                    capabilityProviderVBO = new VertexBuffer();\r\n                    capabilityProviderVBO.bind();\r\n                    capabilityProviderVBO.upload(createCapabilityProviderVBO());\r\n                } else {\r\n                    capabilityProviderVBO.bind();\r\n                }\r\n\r\n                for (var pos : labelPositions.keySet()) {\r\n                    poseStack.pushPose();\r\n                    poseStack.translate(pos.getX(), pos.getY(), pos.getZ());\r\n\r\n                    //noinspection DataFlowIssue\r\n                    capabilityProviderVBO.drawWithShader(\r\n                            poseStack.last().pose(),\r\n                            event.getProjectionMatrix(),\r\n                            GameRenderer.getPositionColorShader()\r\n                    );\r\n                    poseStack.popPose();\r\n                }\r\n\r\n                VertexBuffer.unbind();\r\n                RENDER_TYPE.clearRenderState();\r\n                RenderSystem.enableTexture();\r\n            }\r\n            bufferSource.endBatch();\r\n            poseStack.popPose();\r\n            RenderSystem.enableDepthTest();\r\n        }\r\n\r\n        var networkTool = player.getMainHandItem();\r\n        if (!(networkTool.getItem() instanceof NetworkToolItem)) networkTool = player.getOffhandItem();\r\n        if (networkTool.getItem() instanceof NetworkToolItem) {\r\n            List<BlockPos> cablePositions = new ArrayList<>();\r\n            List<BlockPos> capabilityProviderPositions = new ArrayList<>();\r\n            // gather network positions from item\r\n            networkTool.getOrCreateTag().getList(\"networks\", Tag.TAG_COMPOUND).forEach(networkTag -> {\r\n                ((CompoundTag) networkTag).getList(\"cable_positions\", Tag.TAG_COMPOUND)\r\n                        .stream()\r\n                        .map(CompoundTag.class::cast)\r\n                        .map(NbtUtils::readBlockPos)\r\n                        .forEach(cablePositions::add);\r\n                ((CompoundTag) networkTag)\r\n                        .getList(\"capability_provider_positions\", Tag.TAG_COMPOUND)\r\n                        .stream()\r\n                        .map(CompoundTag.class::cast)\r\n                        .map(NbtUtils::readBlockPos)\r\n                        .forEach(capabilityProviderPositions::add);\r\n            });\r\n\r\n            var poseStack = event.getPoseStack();\r\n            var camera = Minecraft.getInstance().gameRenderer.getMainCamera();\r\n            var bufferSource = Minecraft.getInstance().renderBuffers().bufferSource();\r\n\r\n            RenderSystem.disableDepthTest();\r\n\r\n            poseStack.pushPose();\r\n            poseStack.translate(\r\n                    -camera.getPosition().x,\r\n                    -camera.getPosition().y,\r\n                    -camera.getPosition().z\r\n            );\r\n\r\n            { // draw highlights\r\n                RENDER_TYPE.setupRenderState();\r\n                RenderSystem.disableTexture();\r\n\r\n                if (capabilityProviderVBO == null) {\r\n                    capabilityProviderVBO = new VertexBuffer();\r\n                    capabilityProviderVBO.bind();\r\n                    capabilityProviderVBO.upload(createCapabilityProviderVBO());\r\n                } else {\r\n                    capabilityProviderVBO.bind();\r\n                }\r\n\r\n                for (var blockPos : capabilityProviderPositions) {\r\n                    poseStack.pushPose();\r\n                    poseStack.translate(blockPos.getX(), blockPos.getY(), blockPos.getZ());\r\n\r\n                    //noinspection DataFlowIssue\r\n                    capabilityProviderVBO.drawWithShader(\r\n                            poseStack.last().pose(),\r\n                            event.getProjectionMatrix(),\r\n                            GameRenderer.getPositionColorShader()\r\n                    );\r\n                    poseStack.popPose();\r\n                }\r\n\r\n\r\n                if (cableVBO == null) {\r\n                    cableVBO = new VertexBuffer();\r\n                    cableVBO.bind();\r\n                    cableVBO.upload(createCableVBO());\r\n                } else {\r\n                    cableVBO.bind();\r\n                }\r\n\r\n                for (var blockPos : cablePositions) {\r\n                    poseStack.pushPose();\r\n                    poseStack.translate(blockPos.getX(), blockPos.getY(), blockPos.getZ());\r\n\r\n                    //noinspection DataFlowIssue\r\n                    cableVBO.drawWithShader(\r\n                            poseStack.last().pose(),\r\n                            event.getProjectionMatrix(),\r\n                            GameRenderer.getPositionColorShader()\r\n                    );\r\n                    poseStack.popPose();\r\n                }\r\n\r\n                VertexBuffer.unbind();\r\n                RENDER_TYPE.clearRenderState();\r\n                RenderSystem.enableTexture();\r\n            }\r\n            bufferSource.endBatch();\r\n            poseStack.popPose();\r\n            RenderSystem.enableDepthTest();\r\n        }\r\n    }\r\n\r\n    private static void drawLabel(\r\n            PoseStack poseStack,\r\n            Camera camera,\r\n            BlockPos pos,\r\n            MultiBufferSource mbs,\r\n            Collection<String> labels\r\n    ) {\r\n        poseStack.pushPose();\r\n        poseStack.translate(pos.getX() + 0.5, pos.getY() + 0.5, pos.getZ() + 0.5);\r\n        poseStack.mulPose(camera.rotation());\r\n        poseStack.scale(-0.025f, -0.025f, 0.025f);\r\n        Font font = Minecraft.getInstance().font;\r\n        poseStack.translate(0, labels.size() * (font.lineHeight + 0.1) / -2f, 0);\r\n        for (var label : labels) {\r\n            font.drawInBatch(\r\n                    label,\r\n                    -font.width(label) / 2f,\r\n                    0,\r\n                    -0x1,\r\n                    false,\r\n                    poseStack.last().pose(),\r\n                    mbs,\r\n                    true,\r\n                    0,\r\n                    0xF000F0\r\n            );\r\n            poseStack.translate(0, font.lineHeight + 0.1, 0);\r\n        }\r\n        poseStack.popPose();\r\n    }\r\n\r\n    public static BufferBuilder.RenderedBuffer createCapabilityProviderVBO() {\r\n        return createShape(100, 0, 255, 100);\r\n    }\r\n\r\n    public static BufferBuilder.RenderedBuffer createCableVBO() {\r\n        return createShape(100, 255, 0, 100);\r\n    }\r\n\r\n    public static BufferBuilder.RenderedBuffer createShape(int r, int g, int b, int a) {\r\n        var builder = new BufferBuilder(4 * 6 * 8);\r\n        builder.begin(VertexFormat.Mode.QUADS, DefaultVertexFormat.POSITION_COLOR);\r\n\r\n        builder.vertex(0F, 1F, 0F).color(r, g, b, a).endVertex();\r\n        builder.vertex(0F, 1F, 1F).color(r, g, b, a).endVertex();\r\n        builder.vertex(1F, 1F, 1F).color(r, g, b, a).endVertex();\r\n        builder.vertex(1F, 1F, 0F).color(r, g, b, a).endVertex();\r\n\r\n        builder.vertex(0F, 1F, 0F).color(r, g, b, a).endVertex();\r\n        builder.vertex(1F, 1F, 0F).color(r, g, b, a).endVertex();\r\n        builder.vertex(1F, 0F, 0F).color(r, g, b, a).endVertex();\r\n        builder.vertex(0F, 0F, 0F).color(r, g, b, a).endVertex();\r\n\r\n        builder.vertex(1F, 1F, 1F).color(r, g, b, a).endVertex();\r\n        builder.vertex(0F, 1F, 1F).color(r, g, b, a).endVertex();\r\n        builder.vertex(0F, 0F, 1F).color(r, g, b, a).endVertex();\r\n        builder.vertex(1F, 0F, 1F).color(r, g, b, a).endVertex();\r\n\r\n        builder.vertex(0F, 1F, 1F).color(r, g, b, a).endVertex();\r\n        builder.vertex(0F, 1F, 0F).color(r, g, b, a).endVertex();\r\n        builder.vertex(0F, 0F, 0F).color(r, g, b, a).endVertex();\r\n        builder.vertex(0F, 0F, 1F).color(r, g, b, a).endVertex();\r\n\r\n        builder.vertex(1F, 0F, 1F).color(r, g, b, a).endVertex();\r\n        builder.vertex(1F, 0F, 0F).color(r, g, b, a).endVertex();\r\n        builder.vertex(1F, 1F, 0F).color(r, g, b, a).endVertex();\r\n        builder.vertex(1F, 1F, 1F).color(r, g, b, a).endVertex();\r\n\r\n        builder.vertex(1F, 0F, 0F).color(r, g, b, a).endVertex();\r\n        builder.vertex(1F, 0F, 1F).color(r, g, b, a).endVertex();\r\n        builder.vertex(0F, 0F, 1F).color(r, g, b, a).endVertex();\r\n        builder.vertex(0F, 0F, 0F).color(r, g, b, a).endVertex();\r\n\r\n        return builder.end();\r\n    }\r\n\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\handler\\FallingAnvilHandler.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.common.handler;\r\n\r\nimport ca.teamdman.sfm.SFM;\r\nimport ca.teamdman.sfm.common.item.FormItem;\r\nimport ca.teamdman.sfm.common.recipe.PrintingPressRecipe;\r\nimport ca.teamdman.sfm.common.registry.SFMItems;\r\nimport ca.teamdman.sfm.common.registry.SFMRecipeTypes;\r\nimport net.minecraft.world.entity.Entity;\r\nimport net.minecraft.world.entity.item.FallingBlockEntity;\r\nimport net.minecraft.world.entity.item.ItemEntity;\r\nimport net.minecraft.world.item.EnchantedBookItem;\r\nimport net.minecraft.world.item.ItemStack;\r\nimport net.minecraft.world.item.Items;\r\nimport net.minecraft.world.item.enchantment.Enchantment;\r\nimport net.minecraft.world.item.enchantment.EnchantmentHelper;\r\nimport net.minecraft.world.item.enchantment.EnchantmentInstance;\r\nimport net.minecraft.world.level.Level;\r\nimport net.minecraft.world.level.block.AnvilBlock;\r\nimport net.minecraft.world.level.block.Block;\r\nimport net.minecraft.world.level.block.Blocks;\r\nimport net.minecraft.world.phys.AABB;\r\nimport net.minecraftforge.event.entity.EntityLeaveLevelEvent;\r\nimport net.minecraftforge.eventbus.api.SubscribeEvent;\r\nimport net.minecraftforge.fml.common.Mod;\r\n\r\nimport java.util.List;\r\nimport java.util.Map;\r\n\r\n@Mod.EventBusSubscriber(modid = SFM.MOD_ID, bus = Mod.EventBusSubscriber.Bus.FORGE)\r\npublic class FallingAnvilHandler {\r\n    @SubscribeEvent\r\n    public static void onLeave(EntityLeaveLevelEvent event) {\r\n        if (event.getEntity() instanceof FallingBlockEntity fbe) {\r\n            if (fbe.getBlockState().getBlock() instanceof AnvilBlock) {\r\n                var landPosition = fbe.blockPosition();\r\n                Level level = event.getLevel();\r\n                Block block = level.getBlockState(landPosition.below()).getBlock();\r\n                if (block == Blocks.IRON_BLOCK) { // create a form\r\n                    List<PrintingPressRecipe> recipes = level\r\n                            .getRecipeManager()\r\n                            .getAllRecipesFor(SFMRecipeTypes.PRINTING_PRESS.get());\r\n                    var items = level\r\n                            .getEntitiesOfClass(ItemEntity.class, new AABB(landPosition))\r\n                            .stream()\r\n                            .filter(Entity::isAlive)\r\n                            .filter(e -> !e.getItem().isEmpty())\r\n                            .toList();\r\n                    boolean didForm = false;\r\n\r\n                    for (ItemEntity item : items) {\r\n                        for (PrintingPressRecipe recipe : recipes) {\r\n                            // check if the item can be turned into a form\r\n                            if (recipe.FORM.test(item.getItem())) {\r\n                                didForm = true;\r\n                                item.setItem(FormItem.getForm(item.getItem()));\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                    if (didForm) {\r\n                        level.setBlockAndUpdate(landPosition.below(), Blocks.AIR.defaultBlockState());\r\n                    }\r\n                } else if (block == Blocks.OBSIDIAN) { // crush and disenchant items\r\n                    List<ItemEntity> items = level\r\n                            .getEntitiesOfClass(ItemEntity.class, new AABB(landPosition))\r\n                            .stream()\r\n                            .filter(Entity::isAlive)\r\n                            .filter(e -> !e.getItem().isEmpty())\r\n                            .toList();\r\n                    { // crush enchanted books into xp shards\r\n                        items\r\n                                .stream()\r\n                                .filter(e -> e.getItem().is(Items.ENCHANTED_BOOK))\r\n                                .forEach(e -> e.setItem(new ItemStack(\r\n                                        SFMItems.EXPERIENCE_SHARD_ITEM.get(),\r\n                                        e.getItem().getCount()\r\n                                )));\r\n                    }\r\n                    { // remove enchantments from items\r\n                        List<ItemEntity> bookEntities = items.stream().filter(e -> e.getItem().is(Items.BOOK)).toList();\r\n                        int booksAvailable = bookEntities.stream().mapToInt(e -> e.getItem().getCount()).sum();\r\n                        List<ItemEntity> enchanted = items\r\n                                .stream()\r\n                                .filter(e -> !e.getItem().getEnchantmentTags().isEmpty())\r\n                                .toList();\r\n\r\n\r\n                        for (ItemEntity enchItemEntity : enchanted) {\r\n                            ItemStack enchStack = enchItemEntity.getItem();\r\n                            int enchStackSize = enchStack.getCount();\r\n                            Map<Enchantment, Integer> enchantments = EnchantmentHelper.getEnchantments(enchStack);\r\n                            var enchIter = enchantments.entrySet().iterator();\r\n                            while (enchIter.hasNext()) {\r\n                                var entry = enchIter.next();\r\n                                if (booksAvailable < enchStackSize) break;\r\n\r\n                                // Create an enchanted book with the enchantment\r\n                                ItemStack toSpawn = new ItemStack(Items.ENCHANTED_BOOK, enchStackSize);\r\n                                EnchantedBookItem.addEnchantment(\r\n                                        toSpawn,\r\n                                        new EnchantmentInstance(entry.getKey(), entry.getValue())\r\n                                );\r\n                                level.addFreshEntity(new ItemEntity(\r\n                                        level,\r\n                                        landPosition.getX(),\r\n                                        landPosition.getY(),\r\n                                        landPosition.getZ(),\r\n                                        toSpawn\r\n                                ));\r\n\r\n                                // Remove the enchantment from the item\r\n                                enchIter.remove();\r\n                                EnchantmentHelper.setEnchantments(enchantments, enchStack);\r\n                                booksAvailable -= enchStackSize;\r\n                                if (enchantments.isEmpty()) {\r\n                                    break;\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                        for (ItemEntity bookEntity : bookEntities) {\r\n                            bookEntity.kill();\r\n                        }\r\n                        while (booksAvailable > 0) {\r\n                            int toSpawn = Math.min(booksAvailable, 64);\r\n                            level.addFreshEntity(new ItemEntity(\r\n                                    level,\r\n                                    landPosition.getX(),\r\n                                    landPosition.getY(),\r\n                                    landPosition.getZ(),\r\n                                    new ItemStack(Items.BOOK, toSpawn)\r\n                            ));\r\n                            booksAvailable -= toSpawn;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfml\\ast\\ResourceLimits.java\r\n\r\n````java\r\npackage ca.teamdman.sfml.ast;\r\n\r\nimport ca.teamdman.sfm.common.program.InputResourceTracker;\r\nimport ca.teamdman.sfm.common.program.OutputResourceTracker;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.stream.Collectors;\r\n\r\npublic record ResourceLimits(\r\n        List<? extends ResourceLimit<?, ?, ?>> resourceLimits,\r\n        ResourceIdSet exclusions\r\n) implements ASTNode {\r\n    public List<InputResourceTracker<?, ?, ?>> createInputTrackers() {\r\n        List<InputResourceTracker<?, ?, ?>> rtn = new ArrayList<>();\r\n        resourceLimits.forEach(rl -> rl.gatherInputTrackers(rtn::add, exclusions));\r\n        return rtn;\r\n    }\r\n\r\n    public List<OutputResourceTracker<?, ?, ?>> createOutputTrackers() {\r\n        List<OutputResourceTracker<?, ?, ?>> rtn = new ArrayList<>();\r\n        resourceLimits.forEach(rl -> rl.gatherOutputTrackers(rtn::add, exclusions));\r\n        return rtn;\r\n    }\r\n\r\n    public ResourceLimits withDefaults(Limit limit) {\r\n        return new ResourceLimits(resourceLimits.stream().map(il -> il.withDefaults(limit)).toList(), exclusions);\r\n    }\r\n\r\n    public ResourceLimits withExclusions(ResourceIdSet exclusions) {\r\n        return new ResourceLimits(resourceLimits, exclusions);\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        String rtn = this.resourceLimits.stream()\r\n                .map(ResourceLimit::toString)\r\n                .collect(Collectors.joining(\",\\n\"));\r\n        if (!exclusions.resourceIds().isEmpty()) {\r\n            rtn += \"\\nEXCEPT\\n\" + exclusions.resourceIds().stream()\r\n                    .map(ResourceIdentifier::toString)\r\n                    .collect(Collectors.joining(\",\\n\"));\r\n        }\r\n        return rtn;\r\n    }\r\n\r\n    public String toStringPretty(Limit defaults) {\r\n        String rtn = resourceLimits.stream()\r\n                .map(rl -> rl.toStringCondensed(defaults))\r\n                .map(x -> resourceLimits.size() == 1 ? x : x + \",\")\r\n                .collect(Collectors.joining(\"\\n\"));\r\n        if (!exclusions.resourceIds().isEmpty()) {\r\n            rtn += \"\\nEXCEPT\\n\" + exclusions.resourceIds().stream()\r\n                    .map(ResourceIdentifier::toStringCondensed)\r\n                    .collect(Collectors.joining(\",\\n\"));\r\n        }\r\n        return rtn;\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\item\\DiskItem.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.common.item;\r\n\r\nimport ca.teamdman.sfm.client.ClientStuff;\r\nimport ca.teamdman.sfm.client.ProgramSyntaxHighlightingHelper;\r\nimport ca.teamdman.sfm.client.registry.SFMKeyMappings;\r\nimport ca.teamdman.sfm.common.Constants;\r\nimport ca.teamdman.sfm.common.blockentity.ManagerBlockEntity;\r\nimport ca.teamdman.sfm.common.net.ServerboundDiskItemSetProgramPacket;\r\nimport ca.teamdman.sfm.common.program.LabelPositionHolder;\r\nimport ca.teamdman.sfm.common.registry.SFMItems;\r\nimport ca.teamdman.sfm.common.registry.SFMPackets;\r\nimport ca.teamdman.sfm.common.util.SFMUtils;\r\nimport ca.teamdman.sfml.ast.Program;\r\nimport net.minecraft.ChatFormatting;\r\nimport net.minecraft.nbt.CompoundTag;\r\nimport net.minecraft.nbt.ListTag;\r\nimport net.minecraft.nbt.Tag;\r\nimport net.minecraft.network.chat.Component;\r\nimport net.minecraft.network.chat.MutableComponent;\r\nimport net.minecraft.network.chat.contents.TranslatableContents;\r\nimport net.minecraft.world.InteractionHand;\r\nimport net.minecraft.world.InteractionResultHolder;\r\nimport net.minecraft.world.entity.player.Player;\r\nimport net.minecraft.world.item.Item;\r\nimport net.minecraft.world.item.ItemStack;\r\nimport net.minecraft.world.item.TooltipFlag;\r\nimport net.minecraft.world.level.Level;\r\nimport net.minecraftforge.api.distmarker.Dist;\r\nimport net.minecraftforge.fml.DistExecutor;\r\nimport net.minecraftforge.fml.loading.FMLEnvironment;\r\nimport org.jetbrains.annotations.NotNull;\r\n\r\nimport javax.annotation.Nullable;\r\nimport java.util.Collections;\r\nimport java.util.List;\r\nimport java.util.Optional;\r\nimport java.util.concurrent.atomic.AtomicReference;\r\nimport java.util.stream.Collectors;\r\n\r\npublic class DiskItem extends Item {\r\n    public DiskItem() {\r\n        super(new Item.Properties().tab(SFMItems.TAB));\r\n    }\r\n\r\n    public static String getProgram(ItemStack stack) {\r\n        return stack\r\n                .getOrCreateTag()\r\n                .getString(\"sfm:program\");\r\n    }\r\n\r\n    public static Optional<Program> updateDetails(ItemStack stack, @Nullable ManagerBlockEntity manager) {\r\n        AtomicReference<Program> rtn = new AtomicReference<>(null);\r\n        Program.compile(\r\n                getProgram(stack),\r\n                (successProgram, builder) -> {\r\n                    setProgramName(stack, successProgram.name());\r\n                    setWarnings(stack, successProgram.gatherWarnings(stack, manager));\r\n                    setErrors(stack, Collections.emptyList());\r\n                    rtn.set(successProgram);\r\n                },\r\n                failure -> {\r\n                    setWarnings(stack, Collections.emptyList());\r\n                    setErrors(stack, failure);\r\n                }\r\n        );\r\n        return Optional.ofNullable(rtn.get());\r\n    }\r\n\r\n    public static void setProgram(ItemStack stack, String program) {\r\n        stack\r\n                .getOrCreateTag()\r\n                .putString(\"sfm:program\", program.replaceAll(\"\\r\", \"\"));\r\n\r\n    }\r\n\r\n    @Override\r\n    public @NotNull InteractionResultHolder<ItemStack> use(Level pLevel, Player pPlayer, InteractionHand pUsedHand) {\r\n        var stack = pPlayer.getItemInHand(pUsedHand);\r\n        if (pLevel.isClientSide) {\r\n            ClientStuff.showProgramEditScreen(\r\n                    stack,\r\n                    programString -> SFMPackets.DISK_ITEM_CHANNEL.sendToServer(new ServerboundDiskItemSetProgramPacket(\r\n                            programString,\r\n                            pUsedHand\r\n                    ))\r\n            );\r\n        }\r\n        return InteractionResultHolder.sidedSuccess(stack, pLevel.isClientSide());\r\n    }\r\n\r\n    public static void setErrors(ItemStack stack, List<TranslatableContents> errors) {\r\n        stack\r\n                .getOrCreateTag()\r\n                .put(\r\n                        \"sfm:errors\",\r\n                        errors\r\n                                .stream()\r\n                                .map(SFMUtils::serializeTranslation)\r\n                                .collect(ListTag::new, ListTag::add, ListTag::addAll)\r\n                );\r\n    }\r\n\r\n\r\n    public static void setWarnings(ItemStack stack, List<TranslatableContents> warnings) {\r\n        stack\r\n                .getOrCreateTag()\r\n                .put(\r\n                        \"sfm:warnings\",\r\n                        warnings\r\n                                .stream()\r\n                                .map(SFMUtils::serializeTranslation)\r\n                                .collect(ListTag::new, ListTag::add, ListTag::addAll)\r\n                );\r\n    }\r\n\r\n\r\n    public static List<TranslatableContents> getErrors(ItemStack stack) {\r\n        return stack\r\n                .getOrCreateTag()\r\n                .getList(\"sfm:errors\", Tag.TAG_COMPOUND)\r\n                .stream()\r\n                .map(CompoundTag.class::cast)\r\n                .map(SFMUtils::deserializeTranslation)\r\n                .toList();\r\n    }\r\n\r\n    public static List<TranslatableContents> getWarnings(ItemStack stack) {\r\n        return stack\r\n                .getOrCreateTag()\r\n                .getList(\"sfm:warnings\", Tag.TAG_COMPOUND)\r\n                .stream()\r\n                .map(CompoundTag.class::cast)\r\n                .map(SFMUtils::deserializeTranslation)\r\n                .collect(\r\n                        Collectors.toList());\r\n    }\r\n\r\n    public static String getProgramName(ItemStack stack) {\r\n        return stack\r\n                .getOrCreateTag()\r\n                .getString(\"sfm:name\");\r\n    }\r\n\r\n    public static void setProgramName(ItemStack stack, String name) {\r\n        if (stack.getItem() instanceof DiskItem) {\r\n            stack\r\n                    .getOrCreateTag()\r\n                    .putString(\"sfm:name\", name);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public Component getName(ItemStack stack) {\r\n        if (FMLEnvironment.dist == Dist.CLIENT) {\r\n            if (ClientStuff.isMoreInfoKeyDown()) return super.getName(stack);\r\n        }\r\n        var name = getProgramName(stack);\r\n        if (name.isEmpty()) return super.getName(stack);\r\n        return Component.literal(name).withStyle(ChatFormatting.AQUA);\r\n    }\r\n\r\n\r\n    @Override\r\n    public void appendHoverText(\r\n            ItemStack stack, @Nullable Level level, List<Component> list, TooltipFlag detail\r\n    ) {\r\n\r\n        if (stack.hasTag()) {\r\n            boolean showProgram = DistExecutor.unsafeRunForDist(\r\n                    () -> ClientStuff::isMoreInfoKeyDown,\r\n                    () -> () -> false\r\n            );\r\n            if (!showProgram) {\r\n                list.addAll(LabelPositionHolder.from(stack).asHoverText());\r\n                getErrors(stack)\r\n                        .stream()\r\n                        .map(MutableComponent::create)\r\n                        .map(line -> line.withStyle(ChatFormatting.RED))\r\n                        .forEach(list::add);\r\n                getWarnings(stack)\r\n                        .stream()\r\n                        .map(MutableComponent::create)\r\n                        .map(line -> line.withStyle(ChatFormatting.YELLOW))\r\n                        .forEach(list::add);\r\n                list.add(Constants.LocalizationKeys.GUI_ADVANCED_TOOLTIP_HINT\r\n                                 .getComponent(SFMKeyMappings.MORE_INFO_TOOLTIP_KEY.get().getTranslatedKeyMessage())\r\n                                 .withStyle(ChatFormatting.AQUA));\r\n            } else {\r\n                var program = getProgram(stack);\r\n                if (!program.isEmpty()) {\r\n                    var start = Component.empty();\r\n                    ChatFormatting[] rainbowColors = new ChatFormatting[]{\r\n                            ChatFormatting.DARK_RED,\r\n                            ChatFormatting.RED,\r\n                            ChatFormatting.GOLD,\r\n                            ChatFormatting.YELLOW,\r\n                            ChatFormatting.DARK_GREEN,\r\n                            ChatFormatting.GREEN,\r\n                            ChatFormatting.DARK_AQUA,\r\n                            ChatFormatting.AQUA,\r\n                            ChatFormatting.DARK_BLUE,\r\n                            ChatFormatting.BLUE,\r\n                            ChatFormatting.DARK_PURPLE,\r\n                            ChatFormatting.LIGHT_PURPLE\r\n                    };\r\n                    int rainbowColorsLength = rainbowColors.length;\r\n                    int fullCycleLength = 2 * rainbowColorsLength - 2;\r\n                    for (int i = 0; i < getName(stack).getString().length() - 2; i++) {\r\n                        int cyclePosition = i % fullCycleLength;\r\n                        int adjustedIndex = cyclePosition < rainbowColorsLength\r\n                                            ? cyclePosition\r\n                                            : fullCycleLength - cyclePosition;\r\n                        ChatFormatting color = rainbowColors[adjustedIndex];\r\n                        start = start.append(Component.literal(\"=\").withStyle(color));\r\n                    }\r\n                    list.add(start);\r\n                    list.addAll(ProgramSyntaxHighlightingHelper.withSyntaxHighlighting(program, false));\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\item\\LabelGunItem.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.common.item;\r\n\r\nimport ca.teamdman.sfm.client.ClientStuff;\r\nimport ca.teamdman.sfm.common.Constants;\r\nimport ca.teamdman.sfm.common.net.ServerboundLabelGunUsePacket;\r\nimport ca.teamdman.sfm.common.program.LabelPositionHolder;\r\nimport ca.teamdman.sfm.common.registry.SFMItems;\r\nimport ca.teamdman.sfm.common.registry.SFMPackets;\r\nimport net.minecraft.ChatFormatting;\r\nimport net.minecraft.client.gui.screens.Screen;\r\nimport net.minecraft.network.chat.Component;\r\nimport net.minecraft.world.InteractionHand;\r\nimport net.minecraft.world.InteractionResult;\r\nimport net.minecraft.world.InteractionResultHolder;\r\nimport net.minecraft.world.entity.player.Player;\r\nimport net.minecraft.world.item.Item;\r\nimport net.minecraft.world.item.ItemStack;\r\nimport net.minecraft.world.item.TooltipFlag;\r\nimport net.minecraft.world.item.context.UseOnContext;\r\nimport net.minecraft.world.level.Level;\r\n\r\nimport javax.annotation.Nullable;\r\nimport java.util.Comparator;\r\nimport java.util.List;\r\n\r\npublic class LabelGunItem extends Item {\r\n    public LabelGunItem() {\r\n        super(new Properties().stacksTo(1).tab(SFMItems.TAB));\r\n    }\r\n\r\n    public static void setActiveLabel(ItemStack gun, String label) {\r\n        if (label.isEmpty()) return;\r\n        LabelPositionHolder.from(gun).addReferencedLabel(label).save(gun);\r\n        gun.getOrCreateTag().putString(\"sfm:active_label\", label);\r\n    }\r\n\r\n    public static String getActiveLabel(ItemStack stack) {\r\n        //noinspection DataFlowIssue\r\n        return !stack.hasTag() ? \"\" : stack.getTag().getString(\"sfm:active_label\");\r\n    }\r\n\r\n    public static String getNextLabel(ItemStack gun, int change) {\r\n        var labels = LabelPositionHolder.from(gun).get().keySet().stream().sorted(Comparator.naturalOrder()).toList();\r\n        if (labels.isEmpty()) return \"\";\r\n        var currentLabel = getActiveLabel(gun);\r\n\r\n        int currentLabelIndex = 0;\r\n        for (int i = 0; i < labels.size(); i++) {\r\n            if (labels.get(i).equals(currentLabel)) {\r\n                currentLabelIndex = i;\r\n                break;\r\n            }\r\n        }\r\n\r\n        int nextLabelIndex = currentLabelIndex + change;\r\n        // ensure going negative wraps around\r\n        nextLabelIndex = ((nextLabelIndex % labels.size()) + labels.size()) % labels.size();\r\n\r\n        return labels.get(nextLabelIndex);\r\n    }\r\n\r\n    @Override\r\n    public InteractionResult onItemUseFirst(\r\n            ItemStack gun, UseOnContext ctx\r\n    ) {\r\n        var level = ctx.getLevel();\r\n        if (level.isClientSide && ctx.getPlayer() != null) {\r\n            SFMPackets.LABEL_GUN_ITEM_CHANNEL.sendToServer(new ServerboundLabelGunUsePacket(\r\n                    ctx.getHand(),\r\n                    ctx.getClickedPos(),\r\n                    Screen.hasControlDown(),\r\n                    ctx.getPlayer().isShiftKeyDown()\r\n            ));\r\n            return InteractionResult.SUCCESS;\r\n        }\r\n        return InteractionResult.CONSUME;\r\n    }\r\n\r\n    @Override\r\n    public void appendHoverText(\r\n            ItemStack stack, @Nullable Level level, List<Component> lines, TooltipFlag detail\r\n    ) {\r\n        lines.add(Constants.LocalizationKeys.LABEL_GUN_ITEM_TOOLTIP_1.getComponent().withStyle(ChatFormatting.GRAY));\r\n        lines.add(Constants.LocalizationKeys.LABEL_GUN_ITEM_TOOLTIP_2.getComponent().withStyle(ChatFormatting.GRAY));\r\n        lines.add(Constants.LocalizationKeys.LABEL_GUN_ITEM_TOOLTIP_3.getComponent().withStyle(ChatFormatting.GRAY));\r\n        lines.addAll(LabelPositionHolder.from(stack).asHoverText());\r\n    }\r\n\r\n    @Override\r\n    public InteractionResultHolder<ItemStack> use(\r\n            Level level,\r\n            Player player,\r\n            InteractionHand hand\r\n    ) {\r\n        var stack = player.getItemInHand(hand);\r\n        if (level.isClientSide) {\r\n            ClientStuff.showLabelGunScreen(stack, hand);\r\n        }\r\n        return InteractionResultHolder.sidedSuccess(stack, level.isClientSide());\r\n    }\r\n\r\n    @Override\r\n    public Component getName(ItemStack stack) {\r\n        var name = getActiveLabel(stack);\r\n        if (name.isEmpty()) return super.getName(stack);\r\n        return Constants.LocalizationKeys.LABEL_GUN_ITEM_NAME_WITH_LABEL\r\n                .getComponent(name)\r\n                .withStyle(ChatFormatting.AQUA);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\net\\ServerboundLabelGunPrunePacket.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.common.net;\r\n\r\nimport ca.teamdman.sfm.common.item.LabelGunItem;\r\nimport ca.teamdman.sfm.common.program.LabelPositionHolder;\r\nimport net.minecraft.network.FriendlyByteBuf;\r\nimport net.minecraft.world.InteractionHand;\r\nimport net.minecraftforge.network.NetworkEvent;\r\n\r\nimport java.util.function.Supplier;\r\n\r\npublic record ServerboundLabelGunPrunePacket(\r\n        InteractionHand hand\r\n) {\r\n    public static void encode(ServerboundLabelGunPrunePacket msg, FriendlyByteBuf buf) {\r\n        buf.writeEnum(msg.hand);\r\n    }\r\n\r\n    public static ServerboundLabelGunPrunePacket decode(\r\n            FriendlyByteBuf buf\r\n    ) {\r\n        return new ServerboundLabelGunPrunePacket(buf.readEnum(InteractionHand.class));\r\n    }\r\n\r\n    public static void handle(\r\n            ServerboundLabelGunPrunePacket msg, Supplier<NetworkEvent.Context> ctx\r\n    ) {\r\n        ctx.get().enqueueWork(() -> {\r\n            var sender = ctx.get().getSender();\r\n            if (sender == null) {\r\n                return;\r\n            }\r\n            var stack = sender.getItemInHand(msg.hand);\r\n            if (stack.getItem() instanceof LabelGunItem) {\r\n                LabelPositionHolder.from(stack).prune().save(stack);\r\n            }\r\n        });\r\n        ctx.get().setPacketHandled(true);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfml\\ast\\ResourceQuantity.java\r\n\r\n````java\r\npackage ca.teamdman.sfml.ast;\r\n\r\npublic record ResourceQuantity(\r\n        Number number,\r\n        IdExpansionBehaviour idExpansionBehaviour\r\n) implements ASTNode {\r\n    @SuppressWarnings(\"DataFlowIssue\")\r\n    public static ResourceQuantity UNSET = new ResourceQuantity(null, IdExpansionBehaviour.NO_EXPAND);\r\n    public static ResourceQuantity MAX_QUANTITY = new ResourceQuantity(\r\n            new Number(Long.MAX_VALUE),\r\n            IdExpansionBehaviour.NO_EXPAND\r\n    );\r\n\r\n    public ResourceQuantity add(ResourceQuantity quantity) {\r\n        return new ResourceQuantity(\r\n                number.add(quantity.number),\r\n                idExpansionBehaviour\r\n        );\r\n    }\r\n\r\n    public enum IdExpansionBehaviour {\r\n        EXPAND,\r\n        NO_EXPAND\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return number + (idExpansionBehaviour == IdExpansionBehaviour.EXPAND ? \" EACH\" : \"\");\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\command\\package-info.java\r\n\r\n````java\r\n\r\n@ParametersAreNonnullByDefault\r\n@MethodsReturnNonnullByDefault\r\n@FieldsAreNonnullByDefault\r\npackage ca.teamdman.sfm.common.command;\r\n\r\nimport net.minecraft.FieldsAreNonnullByDefault;\r\nimport net.minecraft.MethodsReturnNonnullByDefault;\r\n\r\nimport javax.annotation.ParametersAreNonnullByDefault;\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\client\\gui\\screen\\ManagerScreen.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.client.gui.screen;\r\n\r\nimport ca.teamdman.sfm.SFM;\r\nimport ca.teamdman.sfm.client.ClientStuff;\r\nimport ca.teamdman.sfm.common.containermenu.ManagerContainerMenu;\r\nimport ca.teamdman.sfm.common.item.DiskItem;\r\nimport ca.teamdman.sfm.common.net.ServerboundManagerFixPacket;\r\nimport ca.teamdman.sfm.common.net.ServerboundManagerProgramPacket;\r\nimport ca.teamdman.sfm.common.net.ServerboundManagerResetPacket;\r\nimport ca.teamdman.sfm.common.registry.SFMPackets;\r\nimport com.mojang.blaze3d.systems.RenderSystem;\r\nimport com.mojang.blaze3d.vertex.*;\r\nimport com.mojang.math.Matrix4f;\r\nimport net.minecraft.ChatFormatting;\r\nimport net.minecraft.client.Minecraft;\r\nimport net.minecraft.client.gui.components.Button;\r\nimport net.minecraft.client.gui.screens.Screen;\r\nimport net.minecraft.client.gui.screens.inventory.AbstractContainerScreen;\r\nimport net.minecraft.client.player.LocalPlayer;\r\nimport net.minecraft.client.renderer.GameRenderer;\r\nimport net.minecraft.client.resources.language.I18n;\r\nimport net.minecraft.network.chat.Component;\r\nimport net.minecraft.resources.ResourceLocation;\r\nimport net.minecraft.world.entity.player.Inventory;\r\nimport net.minecraftforge.client.gui.widget.ExtendedButton;\r\nimport org.lwjgl.glfw.GLFW;\r\n\r\nimport java.text.DecimalFormat;\r\nimport java.text.SimpleDateFormat;\r\nimport java.util.List;\r\n\r\nimport static ca.teamdman.sfm.common.Constants.LocalizationKeys.*;\r\n\r\npublic class ManagerScreen extends AbstractContainerScreen<ManagerContainerMenu> {\r\n    private static final ResourceLocation BACKGROUND_TEXTURE_LOCATION = new ResourceLocation(\r\n            SFM.MOD_ID,\r\n            \"textures/gui/container/manager.png\"\r\n    );\r\n    private final float STATUS_DURATION = 40;\r\n    private Component status = Component.empty();\r\n    private float statusCountdown = 0;\r\n    @SuppressWarnings(\"NotNullFieldNotInitialized\")\r\n    private ExtendedButton diagButton;\r\n    @SuppressWarnings(\"NotNullFieldNotInitialized\")\r\n    private ExtendedButton clipboardPasteButton;\r\n    @SuppressWarnings(\"NotNullFieldNotInitialized\")\r\n    private ExtendedButton clipboardCopyButton;\r\n    @SuppressWarnings(\"NotNullFieldNotInitialized\")\r\n    private ExtendedButton resetButton;\r\n    @SuppressWarnings(\"NotNullFieldNotInitialized\")\r\n    private ExtendedButton editButton;\r\n    @SuppressWarnings(\"NotNullFieldNotInitialized\")\r\n    private ExtendedButton examplesButton;\r\n\r\n    public List<ExtendedButton> getButtonsForJEIExclusionZones() {\r\n        return List.of(\r\n                clipboardPasteButton,\r\n                editButton,\r\n                examplesButton,\r\n                clipboardCopyButton\r\n        );\r\n    }\r\n\r\n    public ManagerScreen(ManagerContainerMenu menu, Inventory inv, Component title) {\r\n        super(menu, inv, title);\r\n    }\r\n\r\n    public boolean isReadOnly() {\r\n        LocalPlayer player = Minecraft.getInstance().player;\r\n        return player == null || player.isSpectator();\r\n    }\r\n\r\n    public void updateVisibilities() {\r\n        boolean diskPresent = menu.getSlot(0).hasItem();\r\n        diagButton.visible = shouldShowDiagButton();\r\n        clipboardCopyButton.visible = diskPresent;\r\n        clipboardPasteButton.visible = diskPresent && !isReadOnly();\r\n        resetButton.visible = diskPresent && !isReadOnly();\r\n        editButton.visible = diskPresent && !isReadOnly();\r\n    }\r\n\r\n    private Button.OnTooltip buildTooltip(LocalizationEntry entry) {\r\n        return (btn, pose, mx, my) -> renderTooltip(\r\n                pose,\r\n                font.split(\r\n                        entry.getComponent(),\r\n                        Math.max(\r\n                                width\r\n                                / 2\r\n                                - 43,\r\n                                170\r\n                        )\r\n                ),\r\n                mx,\r\n                my\r\n        );\r\n    }\r\n\r\n    @Override\r\n    protected void init() {\r\n        super.init();\r\n        int buttonWidth = 120;\r\n        clipboardPasteButton = this.addRenderableWidget(new ExtendedButtonWithTooltip(\r\n                (this.width - this.imageWidth) / 2 - buttonWidth,\r\n                (this.height - this.imageHeight) / 2 + 16,\r\n                buttonWidth,\r\n                16,\r\n                MANAGER_GUI_PASTE_FROM_CLIPBOARD_BUTTON.getComponent(),\r\n                button -> this.onLoadClipboard(),\r\n                buildTooltip(MANAGER_GUI_PASTE_FROM_CLIPBOARD_BUTTON_TOOLTIP)\r\n        ));\r\n        editButton = this.addRenderableWidget(new ExtendedButtonWithTooltip(\r\n                (this.width - this.imageWidth) / 2 - buttonWidth,\r\n                (this.height - this.imageHeight) / 2 + 16 + 50,\r\n                buttonWidth,\r\n                16,\r\n                MANAGER_GUI_EDIT_BUTTON.getComponent(),\r\n                button -> onEdit(),\r\n                buildTooltip(MANAGER_GUI_EDIT_BUTTON_TOOLTIP)\r\n        ));\r\n        examplesButton = this.addRenderableWidget(new ExtendedButtonWithTooltip(\r\n                (this.width - this.imageWidth) / 2 - buttonWidth,\r\n                (this.height - this.imageHeight) / 2 + 16 * 2 + 50,\r\n                buttonWidth,\r\n                16,\r\n                MANAGER_GUI_VIEW_EXAMPLES_BUTTON.getComponent(),\r\n                button -> onShowExamples(),\r\n                buildTooltip(MANAGER_GUI_VIEW_EXAMPLES_BUTTON_TOOLTIP)\r\n        ));\r\n        clipboardCopyButton = this.addRenderableWidget(new ExtendedButton(\r\n                (this.width - this.imageWidth) / 2 - buttonWidth,\r\n                (this.height - this.imageHeight) / 2 + 128,\r\n                buttonWidth,\r\n                16,\r\n                MANAGER_GUI_COPY_TO_CLIPBOARD_BUTTON.getComponent(),\r\n                button -> this.onSaveClipboard()\r\n        ));\r\n        resetButton = this.addRenderableWidget(new ExtendedButtonWithTooltip(\r\n                (this.width - this.imageWidth) / 2 + 120,\r\n                (this.height - this.imageHeight) / 2 + 10,\r\n                50,\r\n                12,\r\n                MANAGER_GUI_RESET_BUTTON.getComponent(),\r\n                button -> sendReset(),\r\n                buildTooltip(MANAGER_GUI_RESET_BUTTON_TOOLTIP)\r\n        ));\r\n        diagButton = this.addRenderableWidget(new ExtendedButtonWithTooltip(\r\n                (this.width - this.imageWidth) / 2 + 35,\r\n                (this.height - this.imageHeight) / 2 + 48,\r\n                12,\r\n                14,\r\n                Component.literal(\"!\"),\r\n                button -> {\r\n                    if (Screen.hasShiftDown() && !isReadOnly()) {\r\n                        sendAttemptFix();\r\n                    } else {\r\n                        this.onSaveDiagClipboard();\r\n                    }\r\n                },\r\n                buildTooltip(isReadOnly()\r\n                             ? MANAGER_GUI_WARNING_BUTTON_TOOLTIP_READ_ONLY\r\n                             : MANAGER_GUI_WARNING_BUTTON_TOOLTIP)\r\n        ));\r\n        updateVisibilities();\r\n    }\r\n\r\n    private void onEdit() {\r\n        ClientStuff.showProgramEditScreen(menu.CONTAINER.getItem(0), this::sendProgram);\r\n    }\r\n\r\n    private void onShowExamples() {\r\n        Minecraft\r\n                .getInstance()\r\n                .pushGuiLayer(new ProgramTemplatePickerScreen(template -> ClientStuff.showProgramEditScreen(\r\n                        template,\r\n                        this::sendProgram\r\n                )));\r\n    }\r\n\r\n    private void sendReset() {\r\n        SFMPackets.MANAGER_CHANNEL.sendToServer(new ServerboundManagerResetPacket(\r\n                menu.containerId,\r\n                menu.MANAGER_POSITION\r\n        ));\r\n        status = MANAGER_GUI_STATUS_RESET.getComponent();\r\n        statusCountdown = STATUS_DURATION;\r\n    }\r\n\r\n    private void sendAttemptFix() {\r\n        SFMPackets.MANAGER_CHANNEL.sendToServer(new ServerboundManagerFixPacket(\r\n                menu.containerId,\r\n                menu.MANAGER_POSITION\r\n        ));\r\n        status = MANAGER_GUI_STATUS_FIX.getComponent();\r\n        statusCountdown = STATUS_DURATION;\r\n    }\r\n\r\n    private void sendProgram(String program) {\r\n        SFMPackets.MANAGER_CHANNEL.sendToServer(new ServerboundManagerProgramPacket(\r\n                menu.containerId,\r\n                menu.MANAGER_POSITION,\r\n                program\r\n        ));\r\n        menu.program = program;\r\n        status = MANAGER_GUI_STATUS_LOADED_CLIPBOARD.getComponent();\r\n        statusCountdown = STATUS_DURATION;\r\n    }\r\n\r\n    private void onSaveClipboard() {\r\n        try {\r\n            Minecraft.getInstance().keyboardHandler.setClipboard(menu.program);\r\n            status = MANAGER_GUI_STATUS_SAVED_CLIPBOARD.getComponent();\r\n            statusCountdown = STATUS_DURATION;\r\n        } catch (Throwable t) {\r\n            SFM.LOGGER.error(\"failed to save clipboard\", t);\r\n        }\r\n    }\r\n\r\n    private boolean shouldShowDiagButton() {\r\n        var disk = menu.CONTAINER.getItem(0);\r\n        if (!(disk.getItem() instanceof DiskItem)) return false;\r\n        var errors = DiskItem.getErrors(disk);\r\n        var warnings = DiskItem.getWarnings(disk);\r\n        return !errors.isEmpty() || !warnings.isEmpty();\r\n    }\r\n\r\n    private void onSaveDiagClipboard() {\r\n        try {\r\n            var disk = menu.CONTAINER.getItem(0);\r\n            if (!(disk.getItem() instanceof DiskItem)) return;\r\n            StringBuilder content = new StringBuilder(menu.program);\r\n\r\n            content\r\n                    .append(\"\\n\\n-- Diagnostic info \")\r\n                    .append(new SimpleDateFormat(\"yyyy-MM-dd HH:mm.ss\").format(new java.util.Date()))\r\n                    .append(\" --\");\r\n\r\n            var errors = DiskItem.getErrors(disk);\r\n            if (!errors.isEmpty()) {\r\n                content.append(\"\\n\\n-- Errors\\n\");\r\n                for (var error : errors) {\r\n                    content.append(\"-- * \").append(I18n.get(error.getKey(), error.getArgs())).append(\"\\n\");\r\n                }\r\n            }\r\n\r\n            var warnings = DiskItem.getWarnings(disk);\r\n            if (!warnings.isEmpty()) {\r\n                content.append(\"\\n\\n-- Warnings\\n\");\r\n                for (var warning : warnings) {\r\n                    content.append(\"-- * \").append(I18n.get(warning.getKey(), warning.getArgs())).append(\"\\n\");\r\n                }\r\n            }\r\n\r\n            Minecraft.getInstance().keyboardHandler.setClipboard(content.toString());\r\n            status = MANAGER_GUI_STATUS_SAVED_CLIPBOARD.getComponent();\r\n            statusCountdown = STATUS_DURATION;\r\n        } catch (Throwable t) {\r\n            SFM.LOGGER.error(\"failed saving clipboard\", t);\r\n        }\r\n    }\r\n\r\n    private void onLoadClipboard() {\r\n        try {\r\n            String contents = Minecraft.getInstance().keyboardHandler.getClipboard();\r\n            sendProgram(contents);\r\n        } catch (Throwable t) {\r\n            SFM.LOGGER.error(\"failed loading clipboard\", t);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public boolean keyPressed(int pKeyCode, int pScanCode, int pModifiers) {\r\n        if (Screen.isPaste(pKeyCode) && clipboardPasteButton.visible) {\r\n            onLoadClipboard();\r\n            return true;\r\n        } else if (Screen.isCopy(pKeyCode) && clipboardCopyButton.visible) {\r\n            onSaveClipboard();\r\n            return true;\r\n        } else if (pKeyCode == GLFW.GLFW_KEY_E\r\n                   && Screen.hasControlDown()\r\n                   && Screen.hasShiftDown()\r\n                   && examplesButton.visible) {\r\n            onShowExamples();\r\n            return true;\r\n        } else if (pKeyCode == GLFW.GLFW_KEY_E && Screen.hasControlDown() && editButton.visible) {\r\n            onEdit();\r\n            return true;\r\n        }\r\n        return super.keyPressed(pKeyCode, pScanCode, pModifiers);\r\n    }\r\n\r\n    @Override\r\n    protected void renderLabels(PoseStack poseStack, int mx, int my) {\r\n        // draw title\r\n        super.renderLabels(poseStack, mx, my);\r\n\r\n        // draw state string\r\n        var state = menu.state;\r\n        this.font.draw(\r\n                poseStack,\r\n                MANAGER_GUI_STATE.getComponent(state.LOC.getComponent().withStyle(state.COLOR)),\r\n                titleLabelX,\r\n                20,\r\n                0\r\n        );\r\n\r\n        // draw status string\r\n        if (statusCountdown > 0) {\r\n            this.font.draw(\r\n                    poseStack,\r\n                    status,\r\n                    inventoryLabelX + font.width(playerInventoryTitle.getString()) + 5,\r\n                    inventoryLabelY,\r\n                    0\r\n            );\r\n        }\r\n\r\n        // Find the maximum tick time for normalization\r\n        long peakTickTimeNanoseconds = 0;\r\n        for (int i = 0; i < menu.tickTimeNanos.length; i++) {\r\n            peakTickTimeNanoseconds = Long.max(peakTickTimeNanoseconds, menu.tickTimeNanos[i]);\r\n        }\r\n        long yMax = Long.max(peakTickTimeNanoseconds, 50000000); // Start with max at 50ms but allow it to grow\r\n\r\n        // Constants for the plot size and position\r\n        final int plotX = titleLabelX + 45;\r\n        final int plotY = 40;\r\n        final int spaceBetweenPoints = 6;\r\n        final int plotWidth = spaceBetweenPoints * (menu.tickTimeNanos.length - 1);\r\n        final int plotHeight = 30;\r\n\r\n\r\n        // Set up rendering\r\n        RenderSystem.disableTexture();\r\n        RenderSystem.enableBlend();\r\n        RenderSystem.defaultBlendFunc();\r\n        RenderSystem.setShader(GameRenderer::getPositionColorShader);\r\n        Tesselator tesselator = Tesselator.getInstance();\r\n        Matrix4f pose = poseStack.last().pose();\r\n        BufferBuilder bufferbuilder;\r\n\r\n        // Draw the plot background\r\n        bufferbuilder = tesselator.getBuilder();\r\n        bufferbuilder.begin(VertexFormat.Mode.DEBUG_LINE_STRIP, DefaultVertexFormat.POSITION_COLOR);\r\n        bufferbuilder.vertex(pose, plotX, plotY, 0).color(0, 0, 0, 0.5f).endVertex();\r\n        bufferbuilder.vertex(pose, plotX + plotWidth, plotY, 0).color(0, 0, 0, 0.5f).endVertex();\r\n        bufferbuilder.vertex(pose, plotX + plotWidth, plotY + plotHeight, 0).color(0, 0, 0, 0.5f).endVertex();\r\n        bufferbuilder.vertex(pose, plotX, plotY + plotHeight, 0).color(0, 0, 0, 0.5f).endVertex();\r\n        bufferbuilder.vertex(pose, plotX, plotY, 0).color(0, 0, 0, 0.5f).endVertex();\r\n        tesselator.end();\r\n\r\n        // Draw lines for each data point\r\n        bufferbuilder = tesselator.getBuilder();\r\n        bufferbuilder.begin(VertexFormat.Mode.DEBUG_LINE_STRIP, DefaultVertexFormat.POSITION_COLOR);\r\n        int mouseTickTimeIndex = -1;\r\n        for (int i = 0; i < menu.tickTimeNanos.length; i++) {\r\n            long y = menu.tickTimeNanos[i];\r\n            float normalizedTickTime = y == 0 ? 0 : (float) (Math.log10(y) / Math.log10(yMax));\r\n            int plotPosY = plotY + plotHeight - (int) (normalizedTickTime * plotHeight);\r\n\r\n            int plotPosX = plotX + spaceBetweenPoints * i;\r\n\r\n            // Color the lines based on their tick times (green to red)\r\n            var c = getMillisecondColour(y / 1_000_000f);\r\n            //noinspection DataFlowIssue\r\n            float red = ((c.getColor() >> 16) & 0xFF) / 255f;\r\n            float green = ((c.getColor() >> 8) & 0xFF) / 255f;\r\n            float blue = (c.getColor() & 0xFF) / 255f;\r\n\r\n            bufferbuilder\r\n                    .vertex(pose, (float) plotPosX, (float) plotPosY, (float) getBlitOffset())\r\n                    .color(red, green, blue, 1f)\r\n                    .endVertex();\r\n\r\n            // Check if the mouse is hovering over this line\r\n            if (mx - leftPos >= plotPosX - spaceBetweenPoints / 2\r\n                && mx - leftPos <= plotPosX + spaceBetweenPoints / 2\r\n                && my - topPos >= plotY - 2\r\n                && my - topPos <= plotY + plotHeight + 2) {\r\n                mouseTickTimeIndex = i;\r\n            }\r\n        }\r\n        tesselator.end();\r\n\r\n        // Draw the tick time text\r\n        var format = new DecimalFormat(\"0.000\");\r\n        if (mouseTickTimeIndex != -1) { // We are hovering over the plot\r\n            // Draw the tick time text for the hovered point instead of peak\r\n            long hoveredTickTimeNanoseconds = menu.tickTimeNanos[mouseTickTimeIndex];\r\n            var hoveredTickTimeMilliseconds = hoveredTickTimeNanoseconds / 1_000_000f;\r\n\r\n            this.font.draw(\r\n                    poseStack,\r\n                    MANAGER_GUI_HOVERED_TICK_TIME.getComponent(Component\r\n                                                                       .literal(format.format(\r\n                                                                               hoveredTickTimeMilliseconds))\r\n                                                                       .withStyle(getMillisecondColour(\r\n                                                                               hoveredTickTimeMilliseconds))),\r\n                    titleLabelX,\r\n                    20f + font.lineHeight + 0.1f,\r\n                    0\r\n            );\r\n\r\n            // draw a vertical line\r\n            RenderSystem.setShader(GameRenderer::getPositionColorShader);\r\n            tesselator = Tesselator.getInstance();\r\n            bufferbuilder = tesselator.getBuilder();\r\n            bufferbuilder.begin(VertexFormat.Mode.DEBUG_LINE_STRIP, DefaultVertexFormat.POSITION_COLOR);\r\n            pose = poseStack.last().pose();\r\n\r\n            int x = plotX + spaceBetweenPoints * mouseTickTimeIndex;\r\n            bufferbuilder\r\n                    .vertex(pose, (float) x, (float) plotY, (float) getBlitOffset())\r\n                    .color(1f, 1f, 1f, 1f)\r\n                    .endVertex();\r\n            bufferbuilder\r\n                    .vertex(pose, (float) x, (float) plotY + plotHeight, (float) getBlitOffset())\r\n                    .color(1f, 1f, 1f, 1f)\r\n                    .endVertex();\r\n            tesselator.end();\r\n        } else {\r\n            // Draw the tick time text for peak value\r\n            var peakTickTimeMilliseconds = peakTickTimeNanoseconds / 1_000_000f;\r\n            this.font.draw(\r\n                    poseStack,\r\n                    MANAGER_GUI_PEAK_TICK_TIME.getComponent(Component\r\n                                                                    .literal(format.format(peakTickTimeMilliseconds))\r\n                                                                    .withStyle(getMillisecondColour(\r\n                                                                            peakTickTimeMilliseconds))),\r\n                    titleLabelX,\r\n                    20f + font.lineHeight + 0.1f,\r\n                    0\r\n            );\r\n        }\r\n\r\n        // Restore stuff\r\n        RenderSystem.disableBlend();\r\n        RenderSystem.enableTexture();\r\n    }\r\n\r\n    public ChatFormatting getMillisecondColour(float ms) {\r\n        if (ms <= 5) {\r\n            return ChatFormatting.GREEN;\r\n        } else if (ms <= 15) {\r\n            return ChatFormatting.YELLOW;\r\n        } else {\r\n            return ChatFormatting.RED;\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void render(PoseStack poseStack, int mx, int my, float partialTicks) {\r\n        this.renderBackground(poseStack);\r\n        super.render(poseStack, mx, my, partialTicks);\r\n        this.renderTooltip(poseStack, mx, my);\r\n\r\n        updateVisibilities();\r\n\r\n        // update status countdown\r\n        statusCountdown -= partialTicks;\r\n    }\r\n\r\n    @Override\r\n    protected void renderTooltip(PoseStack pose, int mx, int my) {\r\n        super.renderTooltip(pose, mx, my);\r\n        this.renderables\r\n                .stream()\r\n                .filter(ExtendedButtonWithTooltip.class::isInstance)\r\n                .map(ExtendedButtonWithTooltip.class::cast)\r\n                .forEach(x -> x.renderToolTip(pose, mx, my));\r\n\r\n    }\r\n\r\n    @Override\r\n    protected void renderBg(PoseStack matrixStack, float partialTicks, int mx, int my) {\r\n        //        Lighting.setupForFlatItems();\r\n        RenderSystem.setShader(GameRenderer::getPositionTexShader);\r\n        RenderSystem.setShaderColor(1f, 1f, 1f, 1f);\r\n        RenderSystem.setShaderTexture(0, BACKGROUND_TEXTURE_LOCATION);\r\n        int i = (this.width - this.imageWidth) / 2;\r\n        int j = (this.height - this.imageHeight) / 2;\r\n        this.blit(matrixStack, i, j, 0, 0, this.imageWidth, this.imageHeight);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\package-info.java\r\n\r\n````java\r\n\r\n\r\n@ParametersAreNonnullByDefault\r\n@MethodsReturnNonnullByDefault\r\n@FieldsAreNonnullByDefault\r\npackage ca.teamdman.sfm.common;\r\n\r\nimport net.minecraft.FieldsAreNonnullByDefault;\r\nimport net.minecraft.MethodsReturnNonnullByDefault;\r\n\r\nimport javax.annotation.ParametersAreNonnullByDefault;\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfml\\ast\\Block.java\r\n\r\n````java\r\npackage ca.teamdman.sfml.ast;\r\n\r\nimport ca.teamdman.sfm.common.program.ProgramContext;\r\n\r\nimport java.util.List;\r\n\r\npublic record Block(List<Statement> statements) implements Statement {\r\n    @Override\r\n    public void tick(ProgramContext context) {\r\n        for (Statement statement : statements) {\r\n            statement.tick(context);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        var rtn = new StringBuilder();\r\n        for (Statement statement : statements) {\r\n            if (statement instanceof InputStatement ins) {\r\n                rtn.append(ins.toStringPretty().strip());\r\n            } else if (statement instanceof OutputStatement outs) {\r\n                rtn.append(outs.toStringPretty().strip());\r\n            } else {\r\n                rtn.append(statement.toString().strip());\r\n            }\r\n            rtn.append(\"\\n\");\r\n        }\r\n        return rtn.toString().strip();\r\n    }\r\n\r\n    @Override\r\n    public List<Statement> getStatements() {\r\n        return statements;\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfml\\ast\\RoundRobin.java\r\n\r\n````java\r\npackage ca.teamdman.sfml.ast;\r\n\r\nimport ca.teamdman.sfm.common.program.LabelPositionHolder;\r\nimport net.minecraft.core.BlockPos;\r\n\r\nimport java.util.Collection;\r\nimport java.util.List;\r\nimport java.util.stream.Stream;\r\n\r\npublic class RoundRobin implements ASTNode {\r\n    private final Behaviour behaviour;\r\n    private int index = 0;\r\n\r\n    public RoundRobin(Behaviour behaviour) {\r\n        this.behaviour = behaviour;\r\n    }\r\n\r\n    public static RoundRobin disabled() {\r\n        return new RoundRobin(Behaviour.UNMODIFIED);\r\n    }\r\n\r\n    public Stream<BlockPos> gather(LabelAccess labelAccess, LabelPositionHolder labelPositions) {\r\n        return switch (behaviour) {\r\n            case BY_LABEL -> {\r\n                int index = this.next(labelAccess.labels().size());\r\n                yield labelPositions.getPositions(labelAccess.labels().get(index).name()).stream();\r\n            }\r\n            case BY_BLOCK -> {\r\n                List<BlockPos> positions = labelAccess.labels().stream()\r\n                        .map(Label::name)\r\n                        .map(labelPositions::getPositions)\r\n                        .flatMap(Collection::stream)\r\n                        .distinct()\r\n                        .toList();\r\n                if (positions.isEmpty()) {\r\n                    yield Stream.empty();\r\n                }\r\n                yield Stream.of(positions.get(this.next(positions.size())));\r\n            }\r\n            default -> labelAccess.labels().stream()\r\n                    .map(Label::name)\r\n                    .map(labelPositions::getPositions)\r\n                    .flatMap(Collection::stream);\r\n        };\r\n    }\r\n\r\n    public int next(int max) {\r\n        return index++ % max;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return switch (behaviour) {\r\n            case UNMODIFIED -> \"NOT ROUND ROBIN\";\r\n            case BY_BLOCK -> \"ROUND ROBIN BY BLOCK\";\r\n            case BY_LABEL -> \"ROUND ROBIN BY LABEL\";\r\n        };\r\n    }\r\n\r\n    public boolean isEnabled() {\r\n        return behaviour != Behaviour.UNMODIFIED;\r\n    }\r\n\r\n    public enum Behaviour {\r\n        UNMODIFIED,\r\n        BY_BLOCK,\r\n        BY_LABEL\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfml\\ast\\IfStatement.java\r\n\r\n````java\r\npackage ca.teamdman.sfml.ast;\r\n\r\nimport ca.teamdman.sfm.common.program.ProgramContext;\r\n\r\nimport java.util.List;\r\nimport java.util.function.Predicate;\r\n\r\npublic record IfStatement(\r\n        BoolExpr condition,\r\n        Block trueBlock,\r\n        Block falseBlock\r\n) implements ASTNode, Statement {\r\n    @Override\r\n    public void tick(ProgramContext context) {\r\n        Predicate<ProgramContext> condition = this.condition;\r\n        if (context.getExecutionPolicy() == ProgramContext.ExecutionPolicy.EXPLORE_BRANCHES) {\r\n            condition = ctx -> {\r\n                int conditionIndex = ctx.getProgram().getConditionIndex(this);\r\n                return (ctx.getExplorationBranchIndex() & (1 << conditionIndex)) != 0;\r\n            };\r\n        }\r\n\r\n        if (condition.test(context)) {\r\n            context.pushPath(new ProgramContext.Branch(this, true));\r\n            trueBlock.tick(context);\r\n        } else {\r\n            context.pushPath(new ProgramContext.Branch(this, false));\r\n            falseBlock.tick(context);\r\n        }\r\n\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        var rtn = \"IF \" + condition + \" THEN\\n\" + trueBlock.toString().strip().indent(1).stripTrailing();\r\n        if (!falseBlock.getStatements().isEmpty()) {\r\n            rtn += \"\\nELSE\\n\" + falseBlock.toString().strip().indent(1);\r\n        }\r\n        rtn += \"\\nEND\";\r\n//        var rtn = new StringBuilder();\r\n//        rtn.append(\"IF \").append(condition).append(\" THEN\\n\").append(trueBlock.toString().indent(1));\r\n//        if (!falseBlock.getStatements().isEmpty()) {\r\n//            rtn.append(\"\\nELSE\\n\").append(falseBlock.toString().indent(1));\r\n//        }\r\n//        rtn.append(\"\\nEND\");\r\n        return rtn.strip();\r\n    }\r\n\r\n    @Override\r\n    public List<Statement> getStatements() {\r\n        return List.of(trueBlock, falseBlock);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\registry\\SFMMenus.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.common.registry;\r\n\r\n\r\nimport ca.teamdman.sfm.SFM;\r\nimport ca.teamdman.sfm.client.ClientStuff;\r\nimport ca.teamdman.sfm.common.blockentity.ManagerBlockEntity;\r\nimport ca.teamdman.sfm.common.containermenu.ManagerContainerMenu;\r\nimport net.minecraft.network.FriendlyByteBuf;\r\nimport net.minecraft.world.entity.player.Inventory;\r\nimport net.minecraft.world.inventory.MenuType;\r\nimport net.minecraft.world.level.block.entity.BlockEntity;\r\nimport net.minecraftforge.common.extensions.IForgeMenuType;\r\nimport net.minecraftforge.eventbus.api.IEventBus;\r\nimport net.minecraftforge.fml.DistExecutor;\r\nimport net.minecraftforge.network.IContainerFactory;\r\nimport net.minecraftforge.registries.DeferredRegister;\r\nimport net.minecraftforge.registries.ForgeRegistries;\r\nimport net.minecraftforge.registries.RegistryObject;\r\n\r\npublic class SFMMenus {\r\n    private static final DeferredRegister<MenuType<?>> MENU_TYPES = DeferredRegister.create(\r\n            ForgeRegistries.MENU_TYPES,\r\n            SFM.MOD_ID\r\n    );\r\n\r\n    public static void register(IEventBus bus) {\r\n        MENU_TYPES.register(bus);\r\n    }\r\n\r\n    public static final RegistryObject<MenuType<ManagerContainerMenu>> MANAGER_MENU = MENU_TYPES.register(\r\n            \"manager\",\r\n            () -> IForgeMenuType.create(\r\n                    new IContainerFactory<>() {\r\n                        @Override\r\n                        public ManagerContainerMenu create(\r\n                                int windowId,\r\n                                Inventory inv,\r\n                                FriendlyByteBuf data\r\n                        ) {\r\n                            return new ManagerContainerMenu(\r\n                                    windowId,\r\n                                    inv,\r\n                                    data\r\n                            );\r\n                        }\r\n\r\n                        @Override\r\n                        public ManagerContainerMenu create(\r\n                                int windowId,\r\n                                Inventory inv\r\n                        ) {\r\n                            return DistExecutor.unsafeRunForDist(\r\n                                    () -> () -> {\r\n                                        BlockEntity be = ClientStuff.getLookBlockEntity();\r\n                                        if (!(be instanceof ManagerBlockEntity mbe))\r\n                                            return IContainerFactory.super.create(windowId, inv);\r\n                                        return new ManagerContainerMenu(windowId, inv, mbe);\r\n                                    },\r\n                                    () -> () -> IContainerFactory.super.create(\r\n                                            windowId,\r\n                                            inv\r\n                                    )\r\n                            );\r\n                        }\r\n                    })\r\n    );\r\n\r\n\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\command\\SFMCommand.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.common.command;\r\n\r\nimport ca.teamdman.sfm.SFM;\r\nimport ca.teamdman.sfm.common.cablenetwork.CableNetworkManager;\r\nimport net.minecraft.commands.Commands;\r\nimport net.minecraft.commands.arguments.blocks.BlockInput;\r\nimport net.minecraft.commands.arguments.blocks.BlockStateArgument;\r\nimport net.minecraft.server.level.ServerLevel;\r\nimport net.minecraft.world.level.block.Block;\r\nimport net.minecraftforge.event.RegisterCommandsEvent;\r\nimport net.minecraftforge.eventbus.api.SubscribeEvent;\r\nimport net.minecraftforge.fml.common.Mod;\r\n\r\nimport static com.mojang.brigadier.Command.SINGLE_SUCCESS;\r\n\r\n@Mod.EventBusSubscriber(bus = Mod.EventBusSubscriber.Bus.FORGE, modid = SFM.MOD_ID)\r\npublic class SFMCommand {\r\n    @SubscribeEvent\r\n    public static void onRegisterCommand(final RegisterCommandsEvent event) {\r\n        var command = Commands.literal(\"sfm\");\r\n        command.then(Commands.literal(\"bust_cable_network_cache\")\r\n                             .requires(source -> source.hasPermission(2))\r\n                             .executes(ctx -> {\r\n                                 SFM.LOGGER.info(\"Busting cable networks\");\r\n                                 CableNetworkManager.clear();\r\n                                 return SINGLE_SUCCESS;\r\n                             }));\r\n        command.then(Commands.literal(\"show_bad_cable_cache_entries\")\r\n                             .requires(source -> source.hasPermission(2))\r\n                             .then(Commands.argument(\"block\", BlockStateArgument.block(event.getBuildContext()))\r\n                                           .executes(ctx -> {\r\n                                               ServerLevel level = ctx.getSource().getLevel();\r\n                                               CableNetworkManager.getBadCableCachePositions(level).forEach(pos -> {\r\n                                                   BlockInput block = BlockStateArgument\r\n                                                           .getBlock(\r\n                                                                   ctx,\r\n                                                                   \"block\"\r\n                                                           );\r\n                                                   block.place(\r\n                                                           level,\r\n                                                           pos,\r\n                                                           Block.UPDATE_ALL\r\n                                                   );\r\n                                               });\r\n                                               return SINGLE_SUCCESS;\r\n                                           })));\r\n        event.getDispatcher().register(command);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\resourcetype\\package-info.java\r\n\r\n````java\r\n\r\n\r\n@ParametersAreNonnullByDefault\r\n@MethodsReturnNonnullByDefault\r\n@FieldsAreNonnullByDefault\r\npackage ca.teamdman.sfm.common.resourcetype;\r\n\r\nimport net.minecraft.FieldsAreNonnullByDefault;\r\nimport net.minecraft.MethodsReturnNonnullByDefault;\r\n\r\nimport javax.annotation.ParametersAreNonnullByDefault;\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\resourcetype\\FluidResourceType.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.common.resourcetype;\r\n\r\nimport net.minecraft.world.level.material.Fluid;\r\nimport net.minecraftforge.common.capabilities.ForgeCapabilities;\r\nimport net.minecraftforge.fluids.FluidStack;\r\nimport net.minecraftforge.fluids.capability.IFluidHandler;\r\nimport net.minecraftforge.registries.ForgeRegistries;\r\nimport net.minecraftforge.registries.IForgeRegistry;\r\n\r\npublic class FluidResourceType extends ResourceType<FluidStack, Fluid, IFluidHandler> {\r\n    public FluidResourceType() {\r\n        super(ForgeCapabilities.FLUID_HANDLER);\r\n    }\r\n\r\n    @Override\r\n    public IForgeRegistry<Fluid> getRegistry() {\r\n        return ForgeRegistries.FLUIDS;\r\n    }\r\n\r\n    @Override\r\n    public Fluid getItem(FluidStack fluidStack) {\r\n        return fluidStack.getFluid();\r\n    }\r\n\r\n    @Override\r\n    public FluidStack copy(FluidStack fluidStack) {\r\n        return fluidStack.copy();\r\n    }\r\n\r\n    @Override\r\n    protected FluidStack setCount(FluidStack fluidStack, long amount) {\r\n        int finalAmount = amount > Integer.MAX_VALUE ? Integer.MAX_VALUE : (int) amount;\r\n        fluidStack.setAmount(finalAmount);\r\n        return fluidStack;\r\n    }\r\n\r\n    @Override\r\n    public long getAmount(FluidStack stack) {\r\n        return stack.getAmount();\r\n    }\r\n\r\n    @Override\r\n    public FluidStack getStackInSlot(IFluidHandler cap, int slot) {\r\n        return cap.getFluidInTank(slot);\r\n    }\r\n\r\n    @Override\r\n    public FluidStack extract(IFluidHandler handler, int slot, long amount, boolean simulate) {\r\n        var in          = getStackInSlot(handler, slot);\r\n        int finalAmount = amount > Integer.MAX_VALUE ? Integer.MAX_VALUE : (int) amount;\r\n        var toExtract   = new FluidStack(in.getFluid(), Math.min(in.getAmount(), finalAmount));\r\n        return handler.drain(\r\n                toExtract,\r\n                simulate ? IFluidHandler.FluidAction.SIMULATE : IFluidHandler.FluidAction.EXECUTE\r\n        );\r\n    }\r\n\r\n    @Override\r\n    public boolean matchesStackType(Object o) {\r\n        return o instanceof FluidStack;\r\n    }\r\n\r\n    @Override\r\n    public boolean matchesCapabilityType(Object o) {\r\n        return o instanceof IFluidHandler;\r\n    }\r\n\r\n    @Override\r\n    public int getSlots(IFluidHandler handler) {\r\n        return handler.getTanks();\r\n    }\r\n\r\n    @Override\r\n    public long getMaxStackSize(FluidStack fluidStack) {\r\n        return Integer.MAX_VALUE;\r\n    }\r\n\r\n    @Override\r\n    public long getMaxStackSize(IFluidHandler iFluidHandler, int slot) {\r\n        return iFluidHandler.getTankCapacity(slot);\r\n    }\r\n\r\n    @Override\r\n    public FluidStack insert(IFluidHandler handler, int slot, FluidStack stack, boolean simulate) {\r\n        //todo: PR to forge to add a method that takes tank slot index\r\n        var x = handler.fill(stack, simulate ? IFluidHandler.FluidAction.SIMULATE : IFluidHandler.FluidAction.EXECUTE);\r\n\r\n        // convert units to find amount NOT inserted\r\n        return new FluidStack(stack.getFluid(), stack.getAmount() - x);\r\n    }\r\n\r\n    @Override\r\n    public boolean isEmpty(FluidStack stack) {\r\n        return stack.isEmpty();\r\n    }\r\n\r\n    @Override\r\n    public FluidStack getEmptyStack() {\r\n        return FluidStack.EMPTY;\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfml\\ast\\Program.java\r\n\r\n````java\r\npackage ca.teamdman.sfml.ast;\r\n\r\nimport ca.teamdman.sfm.SFM;\r\nimport ca.teamdman.sfm.common.Constants;\r\nimport ca.teamdman.sfm.common.blockentity.ManagerBlockEntity;\r\nimport ca.teamdman.sfm.common.cablenetwork.CableNetworkManager;\r\nimport ca.teamdman.sfm.common.item.DiskItem;\r\nimport ca.teamdman.sfm.common.program.LabelPositionHolder;\r\nimport ca.teamdman.sfm.common.program.ProgramContext;\r\nimport ca.teamdman.sfm.common.resourcetype.ResourceType;\r\nimport ca.teamdman.sfm.common.util.SFMUtils;\r\nimport ca.teamdman.sfml.SFMLLexer;\r\nimport ca.teamdman.sfml.SFMLParser;\r\nimport net.minecraft.ResourceLocationException;\r\nimport net.minecraft.network.chat.contents.TranslatableContents;\r\nimport net.minecraft.resources.ResourceLocation;\r\nimport net.minecraft.world.item.ItemStack;\r\nimport net.minecraftforge.fml.loading.FMLEnvironment;\r\nimport org.antlr.v4.runtime.*;\r\n\r\nimport javax.annotation.Nullable;\r\nimport java.util.*;\r\nimport java.util.function.BiConsumer;\r\nimport java.util.function.Consumer;\r\n\r\npublic record Program(\r\n        String name,\r\n        List<Trigger> triggers,\r\n        Set<String> referencedLabels,\r\n        Set<ResourceIdentifier<?, ?, ?>> referencedResources\r\n) implements Statement {\r\n    public static final int MAX_PROGRAM_LENGTH = 80960;\r\n    public static final int MAX_LABEL_LENGTH = 256;\r\n\r\n    public static void compile(\r\n            String programString,\r\n            BiConsumer<Program, ASTBuilder> onSuccess,\r\n            Consumer<List<TranslatableContents>> onFailure\r\n    ) {\r\n        SFMLLexer lexer = new SFMLLexer(CharStreams.fromString(programString));\r\n        CommonTokenStream tokens = new CommonTokenStream(lexer);\r\n        SFMLParser parser = new SFMLParser(tokens);\r\n        ASTBuilder builder = new ASTBuilder();\r\n\r\n        // set up error capturing\r\n        lexer.removeErrorListeners();\r\n        parser.removeErrorListeners();\r\n        List<TranslatableContents> errors = new ArrayList<>();\r\n        List<String> buildErrors = new ArrayList<>();\r\n        ListErrorListener listener = new ListErrorListener(buildErrors);\r\n        lexer.addErrorListener(listener);\r\n        parser.addErrorListener(listener);\r\n\r\n        // initial parse\r\n        SFMLParser.ProgramContext context = parser.program();\r\n        buildErrors.stream().map(Constants.LocalizationKeys.PROGRAM_ERROR_LITERAL::get).forEach(errors::add);\r\n\r\n        // build AST\r\n        Program program = null;\r\n        try {\r\n            program = builder.visitProgram(context);\r\n            // make sure all referenced resources exist now during compilation instead of waiting for the program to tick\r\n\r\n            for (ResourceIdentifier<?, ?, ?> referencedResource : program.referencedResources) {\r\n                try {\r\n                    ResourceType<?, ?, ?> resourceType = referencedResource.getResourceType();\r\n                    if (resourceType == null) {\r\n                        errors.add(Constants.LocalizationKeys.PROGRAM_WARNING_UNKNOWN_RESOURCE_TYPE.get(\r\n                                referencedResource));\r\n                    }\r\n                } catch (ResourceLocationException e) {\r\n                    errors.add(Constants.LocalizationKeys.PROGRAM_ERROR_MALFORMED_RESOURCE_TYPE.get(referencedResource));\r\n                }\r\n            }\r\n        } catch (ResourceLocationException | IllegalArgumentException | AssertionError e) {\r\n            errors.add(Constants.LocalizationKeys.PROGRAM_ERROR_LITERAL.get(e.getMessage()));\r\n        } catch (Throwable t) {\r\n            errors.add(Constants.LocalizationKeys.PROGRAM_ERROR_COMPILE_FAILED.get());\r\n            SFM.LOGGER.error(\"Encountered unhandled error while compiling program\", t);\r\n            if (!FMLEnvironment.production) {\r\n                var message = t.getMessage();\r\n                if (message != null) {\r\n                    errors.add(SFMUtils.getTranslatableContents(t.getClass().getSimpleName() + \": \" + message));\r\n                } else {\r\n                    errors.add(SFMUtils.getTranslatableContents(t.getClass().getSimpleName()));\r\n                }\r\n            }\r\n        }\r\n\r\n\r\n        if (errors.isEmpty()) {\r\n            onSuccess.accept(program, builder);\r\n        } else {\r\n            onFailure.accept(errors);\r\n        }\r\n    }\r\n\r\n    public ArrayList<TranslatableContents> gatherWarnings(ItemStack disk, @Nullable ManagerBlockEntity manager) {\r\n        var warnings = new ArrayList<TranslatableContents>();\r\n        var labels = LabelPositionHolder.from(disk);\r\n        // labels in code but not in world\r\n        for (String label : referencedLabels) {\r\n            var isUsed = !labels.getPositions(label).isEmpty();\r\n            if (!isUsed) {\r\n                warnings.add(Constants.LocalizationKeys.PROGRAM_WARNING_UNUSED_LABEL.get(label));\r\n            }\r\n        }\r\n\r\n        // labels used in world but not defined in code\r\n        labels.get().keySet()\r\n                .stream()\r\n                .filter(x -> !referencedLabels.contains(x))\r\n                .forEach(label -> warnings.add(Constants.LocalizationKeys.PROGRAM_WARNING_UNDEFINED_LABEL.get(label)));\r\n\r\n        if (manager != null) {\r\n            // labels in world but not connected via cables\r\n            CableNetworkManager\r\n                    .getOrRegisterNetworkFromManagerPosition(manager)\r\n                    .ifPresent(network -> labels.forEach((label, pos) -> {\r\n                var inNetwork = network.isInNetwork(pos);\r\n                var adjacent = network.isAdjacentToCable(pos);\r\n                if (!inNetwork) {\r\n                    if (adjacent) {\r\n                        warnings.add(Constants.LocalizationKeys.PROGRAM_WARNING_ADJACENT_BUT_DISCONNECTED_LABEL.get(\r\n                                label,\r\n                                String.format(\r\n                                        \"[%d,%d,%d]\",\r\n                                        pos.getX(),\r\n                                        pos.getY(),\r\n                                        pos.getZ()\r\n                                )\r\n                        ));\r\n                    } else {\r\n                        warnings.add(Constants.LocalizationKeys.PROGRAM_WARNING_DISCONNECTED_LABEL.get(\r\n                                label,\r\n                                String.format(\r\n                                        \"[%d,%d,%d]\",\r\n                                        pos.getX(),\r\n                                        pos.getY(),\r\n                                        pos.getZ()\r\n                                )\r\n                        ));\r\n                    }\r\n                }\r\n            }));\r\n        }\r\n\r\n        // try and validate that references resources exist\r\n        for (var resource : referencedResources) {\r\n            // skip regex resources\r\n            Optional<ResourceLocation> loc = resource.getLocation();\r\n            if (loc.isEmpty()) continue;\r\n\r\n            // make sure resource type is registered\r\n            var type = resource.getResourceType();\r\n            if (type == null) {\r\n                warnings.add(Constants.LocalizationKeys.PROGRAM_WARNING_UNKNOWN_RESOURCE_TYPE.get(\r\n                        resource.resourceTypeNamespace\r\n                        + \":\"\r\n                        + resource.resourceTypeName,\r\n                        resource\r\n                ));\r\n                continue;\r\n            }\r\n\r\n            // make sure resource exists in the registry\r\n            if (!type.registryKeyExists(loc.get())) {\r\n                warnings.add(Constants.LocalizationKeys.PROGRAM_WARNING_UNKNOWN_RESOURCE_ID.get(resource));\r\n            }\r\n        }\r\n        return warnings;\r\n    }\r\n\r\n    public void fixWarnings(ItemStack disk, ManagerBlockEntity manager) {\r\n        var labels = LabelPositionHolder.from(disk);\r\n        // remove labels not defined in code\r\n        labels.removeIf(label -> !referencedLabels.contains(label));\r\n\r\n        // remove labels not connected via cables\r\n        CableNetworkManager\r\n                .getOrRegisterNetworkFromManagerPosition(manager)\r\n                .ifPresent(network -> labels.removeIf((label, pos) -> !network.isInNetwork(pos)));\r\n        labels.save(disk);\r\n\r\n        // update warnings\r\n        DiskItem.setWarnings(disk, gatherWarnings(disk, manager));\r\n    }\r\n\r\n    public boolean tick(ManagerBlockEntity manager) {\r\n        // update warnings on disk item every 20 seconds\r\n        if (manager.getTick() % 20 == 0) {\r\n            manager.getDisk().ifPresent(disk -> DiskItem.setWarnings(disk, gatherWarnings(disk, manager)));\r\n        }\r\n\r\n        // build the context and tick the program\r\n        var context = new ProgramContext(this, manager, ProgramContext.ExecutionPolicy.UNRESTRICTED);\r\n        tick(context);\r\n\r\n        manager.clearRedstonePulseQueue();\r\n        //noinspection UnnecessaryLocalVariable\r\n        boolean didSomething = triggers.stream().anyMatch(t -> t.shouldTick(context));\r\n        return didSomething;\r\n    }\r\n\r\n    @Override\r\n    public List<Statement> getStatements() {\r\n        return triggers.stream().map(x -> (Statement) x).toList();\r\n    }\r\n\r\n    @Override\r\n    public void tick(ProgramContext context) {\r\n        for (Trigger t : triggers) {\r\n            if (t.shouldTick(context)) {\r\n                t.tick(context.copy());\r\n            }\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        var rtn = new StringBuilder();\r\n        rtn.append(\"NAME \\\"\").append(name).append(\"\\\"\\n\");\r\n        for (Trigger trigger : triggers) {\r\n            rtn.append(trigger).append(\"\\n\");\r\n        }\r\n        return rtn.toString();\r\n    }\r\n\r\n    public void replaceOutputStatement(OutputStatement oldStatement, OutputStatement newStatement) {\r\n        Deque<Statement> toPatch = new ArrayDeque<>();\r\n        toPatch.add(this);\r\n        while (!toPatch.isEmpty()) {\r\n            Statement statement = toPatch.pollFirst();\r\n            List<Statement> children = statement.getStatements();\r\n            for (int i = 0; i < children.size(); i++) {\r\n                Statement child = children.get(i);\r\n                if (child == oldStatement) {\r\n                    children.set(i, newStatement);\r\n                } else {\r\n                    toPatch.add(child);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public int getConditionIndex(IfStatement statement) {\r\n        Deque<Statement> toVisit = new ArrayDeque<>();\r\n        toVisit.add(this);\r\n        int seen = 0;\r\n        while (!toVisit.isEmpty()) {\r\n            Statement current = toVisit.pollFirst();\r\n            if (current instanceof IfStatement ifStatement) {\r\n                if (ifStatement == statement) {\r\n                    return seen;\r\n                }\r\n                seen++;\r\n            }\r\n            toVisit.addAll(current.getStatements());\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    public int getConditionCount() {\r\n        Deque<Statement> toVisit = new ArrayDeque<>();\r\n        toVisit.add(this);\r\n        int seen = 0;\r\n        while (!toVisit.isEmpty()) {\r\n            Statement current = toVisit.pollFirst();\r\n            if (current instanceof IfStatement) {\r\n                seen++;\r\n            }\r\n            toVisit.addAll(current.getStatements());\r\n        }\r\n        return seen;\r\n    }\r\n\r\n    public static class ListErrorListener extends BaseErrorListener {\r\n        private final List<String> errors;\r\n\r\n        public ListErrorListener(List<String> errors) {\r\n            this.errors = errors;\r\n        }\r\n\r\n        @Override\r\n        public void syntaxError(\r\n                Recognizer<?, ?> recognizer,\r\n                Object offendingSymbol,\r\n                int line,\r\n                int charPositionInLine,\r\n                String msg,\r\n                RecognitionException e\r\n        ) {\r\n            errors.add(\"line \" + line + \":\" + charPositionInLine + \" \" + msg);\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfml\\ast\\ASTBuilder.java\r\n\r\n````java\r\npackage ca.teamdman.sfml.ast;\r\n\r\nimport ca.teamdman.sfml.SFMLBaseVisitor;\r\nimport ca.teamdman.sfml.SFMLParser;\r\nimport org.antlr.v4.runtime.ParserRuleContext;\r\nimport org.antlr.v4.runtime.misc.Pair;\r\nimport org.antlr.v4.runtime.tree.ParseTree;\r\n\r\nimport javax.annotation.Nullable;\r\nimport java.util.*;\r\nimport java.util.stream.Collectors;\r\n\r\npublic class ASTBuilder extends SFMLBaseVisitor<ASTNode> {\r\n    private final Set<Label> USED_LABELS = new HashSet<>();\r\n    private final Set<ResourceIdentifier<?, ?, ?>> USED_RESOURCES = new HashSet<>();\r\n    private final List<Pair<ASTNode, ParserRuleContext>> AST_NODE_CONTEXTS = new LinkedList<>();\r\n\r\n    public List<Pair<ASTNode, ParserRuleContext>> getNodesUnderCursor(int cursorPos) {\r\n        return AST_NODE_CONTEXTS\r\n                .stream()\r\n                .filter(pair -> pair.b != null)\r\n                .filter(pair -> pair.b.start.getStartIndex() <= cursorPos && pair.b.stop.getStopIndex() >= cursorPos)\r\n                .collect(Collectors.toList());\r\n    }\r\n\r\n    public Optional<ASTNode> getNodeAtIndex(int index) {\r\n        if (index < 0 || index >= AST_NODE_CONTEXTS.size()) return Optional.empty();\r\n        return Optional.ofNullable(AST_NODE_CONTEXTS.get(index).a);\r\n    }\r\n\r\n    public int getIndexForNode(ASTNode node) {\r\n        return AST_NODE_CONTEXTS\r\n                .stream()\r\n                .filter(pair -> pair.a == node)\r\n                .map(AST_NODE_CONTEXTS::indexOf)\r\n                .findFirst()\r\n                .orElse(-1);\r\n    }\r\n\r\n    @Override\r\n    public StringHolder visitName(@Nullable SFMLParser.NameContext ctx) {\r\n        if (ctx == null) return new StringHolder(\"\");\r\n        StringHolder name = visitString(ctx.string());\r\n        AST_NODE_CONTEXTS.add(new Pair<>(name, ctx));\r\n        return name;\r\n    }\r\n\r\n    @Override\r\n    public ASTNode visitResource(SFMLParser.ResourceContext ctx) {\r\n        var str = ctx\r\n                .children\r\n                .stream()\r\n                .map(ParseTree::getText)\r\n                .collect(Collectors.joining())\r\n                .replaceAll(\"::\", \":*:\")\r\n                .replaceAll(\":$\", \":*\")\r\n                .replaceAll(\"\\\\*\", \".*\");\r\n        var rtn = ResourceIdentifier.fromString(str);\r\n        USED_RESOURCES.add(rtn);\r\n        rtn.assertValid();\r\n        AST_NODE_CONTEXTS.add(new Pair<>(rtn, ctx));\r\n        return rtn;\r\n    }\r\n\r\n    @Override\r\n    public ResourceIdentifier<?, ?, ?> visitStringResource(SFMLParser.StringResourceContext ctx) {\r\n        var rtn = ResourceIdentifier.fromString(visitString(ctx.string()).value());\r\n        USED_RESOURCES.add(rtn);\r\n        rtn.assertValid();\r\n        AST_NODE_CONTEXTS.add(new Pair<>(rtn, ctx));\r\n        return rtn;\r\n    }\r\n\r\n    @Override\r\n    public StringHolder visitString(SFMLParser.StringContext ctx) {\r\n        var content = ctx.getText();\r\n        StringHolder str = new StringHolder(content.substring(1, content.length() - 1));\r\n        AST_NODE_CONTEXTS.add(new Pair<>(str, ctx));\r\n        return str;\r\n    }\r\n\r\n    @Override\r\n    public Label visitRawLabel(SFMLParser.RawLabelContext ctx) {\r\n        var label = new Label(ctx.getText());\r\n        if (label.name().length() > Program.MAX_LABEL_LENGTH) {\r\n            throw new IllegalArgumentException(\"Label name cannot be longer than \"\r\n                                               + Program.MAX_LABEL_LENGTH\r\n                                               + \" characters.\");\r\n        }\r\n        USED_LABELS.add(label);\r\n        AST_NODE_CONTEXTS.add(new Pair<>(label, ctx));\r\n        return label;\r\n    }\r\n\r\n    @Override\r\n    public Label visitStringLabel(SFMLParser.StringLabelContext ctx) {\r\n        var label = new Label(visitString(ctx.string()).value());\r\n        if (label.name().length() > Program.MAX_LABEL_LENGTH) {\r\n            throw new IllegalArgumentException(\"Label name cannot be longer than \"\r\n                                               + Program.MAX_LABEL_LENGTH\r\n                                               + \" characters.\");\r\n        }\r\n        USED_LABELS.add(label);\r\n        AST_NODE_CONTEXTS.add(new Pair<>(label, ctx));\r\n        return label;\r\n    }\r\n\r\n    @Override\r\n    public Program visitProgram(SFMLParser.ProgramContext ctx) {\r\n        var name = visitName(ctx.name());\r\n        var triggers = ctx\r\n                .trigger()\r\n                .stream()\r\n                .map(this::visit)\r\n                .map(Trigger.class::cast)\r\n                .collect(Collectors.toList());\r\n        var labels = USED_LABELS\r\n                .stream()\r\n                .map(Label::name)\r\n                .collect(Collectors.toSet());\r\n        Program program = new Program(name.value(), triggers, labels, USED_RESOURCES);\r\n        AST_NODE_CONTEXTS.add(new Pair<>(program, ctx));\r\n        return program;\r\n    }\r\n\r\n    @Override\r\n    public ASTNode visitTimerTrigger(SFMLParser.TimerTriggerContext ctx) {\r\n        var time = (Interval) visit(ctx.interval());\r\n        if (time.getSeconds() < 1) throw new IllegalArgumentException(\"Minimum trigger interval is 1 second.\");\r\n        var block = visitBlock(ctx.block());\r\n        TimerTrigger timerTrigger = new TimerTrigger(time, block);\r\n        AST_NODE_CONTEXTS.add(new Pair<>(timerTrigger, ctx));\r\n        return timerTrigger;\r\n    }\r\n\r\n    @Override\r\n    public ASTNode visitBooleanRedstone(SFMLParser.BooleanRedstoneContext ctx) {\r\n        ComparisonOperator comp = ComparisonOperator.GREATER_OR_EQUAL;\r\n        Number num = new Number(0);\r\n        if (ctx.comparisonOp() != null && ctx.number() != null) {\r\n            comp = visitComparisonOp(ctx.comparisonOp());\r\n            num = visitNumber(ctx.number());\r\n        }\r\n\r\n        ComparisonOperator finalComp = comp;\r\n        assert num.value() <= Integer.MAX_VALUE;\r\n        int finalNum = (int) num.value();\r\n        //noinspection DataFlowIssue // if the program is ticking, level shouldn't be null\r\n        BoolExpr boolExpr = new BoolExpr(\r\n                programContext -> finalComp.test(\r\n                        (long) programContext\r\n                                .getManager()\r\n                                .getLevel()\r\n                                .getBestNeighborSignal(programContext\r\n                                                               .getManager()\r\n                                                               .getBlockPos()),\r\n                        (long) finalNum\r\n                ),\r\n                ctx.getText()\r\n        );\r\n        AST_NODE_CONTEXTS.add(new Pair<>(boolExpr, ctx));\r\n        return boolExpr;\r\n    }\r\n\r\n    @Override\r\n    public ASTNode visitPulseTrigger(SFMLParser.PulseTriggerContext ctx) {\r\n        var block = visitBlock(ctx.block());\r\n        RedstoneTrigger redstoneTrigger = new RedstoneTrigger(block);\r\n        AST_NODE_CONTEXTS.add(new Pair<>(redstoneTrigger, ctx));\r\n        return redstoneTrigger;\r\n    }\r\n\r\n    @Override\r\n    public Number visitNumber(SFMLParser.NumberContext ctx) {\r\n        Number number = new Number(Long.parseLong(ctx.getText()));\r\n        AST_NODE_CONTEXTS.add(new Pair<>(number, ctx));\r\n        return number;\r\n    }\r\n\r\n    @Override\r\n    public Interval visitTicks(SFMLParser.TicksContext ctx) {\r\n        var num = visitNumber(ctx.number());\r\n        assert num.value() <= Integer.MAX_VALUE;\r\n        Interval interval = Interval.fromTicks((int) num.value());\r\n        AST_NODE_CONTEXTS.add(new Pair<>(interval, ctx));\r\n        return interval;\r\n    }\r\n\r\n    @Override\r\n    public Interval visitSeconds(SFMLParser.SecondsContext ctx) {\r\n        var num = visitNumber(ctx.number());\r\n        assert num.value() <= Integer.MAX_VALUE;\r\n        Interval interval = Interval.fromSeconds((int) num.value());\r\n        AST_NODE_CONTEXTS.add(new Pair<>(interval, ctx));\r\n        return interval;\r\n    }\r\n\r\n    @Override\r\n    public InputStatement visitInputStatementStatement(SFMLParser.InputStatementStatementContext ctx) {\r\n        InputStatement input = (InputStatement) visit(ctx.inputstatement());\r\n        AST_NODE_CONTEXTS.add(new Pair<>(input, ctx));\r\n        return input;\r\n    }\r\n\r\n    @Override\r\n    public OutputStatement visitOutputStatementStatement(SFMLParser.OutputStatementStatementContext ctx) {\r\n        OutputStatement output = (OutputStatement) visit(ctx.outputstatement());\r\n        AST_NODE_CONTEXTS.add(new Pair<>(output, ctx));\r\n        return output;\r\n    }\r\n\r\n    @Override\r\n    public InputStatement visitInputstatement(SFMLParser.InputstatementContext ctx) {\r\n        var labelAccess = visitLabelaccess(ctx.labelaccess());\r\n        var matchers = visitInputmatchers(ctx.inputmatchers());\r\n        var exclusions = visitResourceexclusion(ctx.resourceexclusion());\r\n        var each = ctx.EACH() != null;\r\n        InputStatement inputStatement = new InputStatement(labelAccess, matchers.withExclusions(exclusions), each);\r\n        AST_NODE_CONTEXTS.add(new Pair<>(inputStatement, ctx));\r\n        return inputStatement;\r\n    }\r\n\r\n    @Override\r\n    public OutputStatement visitOutputstatement(SFMLParser.OutputstatementContext ctx) {\r\n        var labelAccess = visitLabelaccess(ctx.labelaccess());\r\n        var matchers = visitOutputmatchers(ctx.outputmatchers());\r\n        var exclusions = visitResourceexclusion(ctx.resourceexclusion());\r\n        var each = ctx.EACH() != null;\r\n        OutputStatement outputStatement = new OutputStatement(labelAccess, matchers.withExclusions(exclusions), each);\r\n        AST_NODE_CONTEXTS.add(new Pair<>(outputStatement, ctx));\r\n        return outputStatement;\r\n    }\r\n\r\n    @Override\r\n    public LabelAccess visitLabelaccess(SFMLParser.LabelaccessContext ctx) {\r\n        LabelAccess labelAccess = new LabelAccess(\r\n                ctx.label().stream().map(this::visit).map(Label.class::cast).collect(Collectors.toList()),\r\n                visitSidequalifier(ctx.sidequalifier()),\r\n                visitSlotqualifier(ctx.slotqualifier()),\r\n                visitRoundrobin(ctx.roundrobin())\r\n        );\r\n        AST_NODE_CONTEXTS.add(new Pair<>(labelAccess, ctx));\r\n        return labelAccess;\r\n    }\r\n\r\n    @Override\r\n    public RoundRobin visitRoundrobin(@Nullable SFMLParser.RoundrobinContext ctx) {\r\n        if (ctx == null) return RoundRobin.disabled();\r\n        return ctx.BLOCK() != null\r\n               ? new RoundRobin(RoundRobin.Behaviour.BY_BLOCK)\r\n               : new RoundRobin(RoundRobin.Behaviour.BY_LABEL);\r\n    }\r\n\r\n    @Override\r\n    public IfStatement visitIfstatement(SFMLParser.IfstatementContext ctx) {\r\n        var conditions = ctx\r\n                .boolexpr()\r\n                .stream()\r\n                .map(this::visit)\r\n                .map(BoolExpr.class::cast)\r\n                .collect(Collectors.toCollection(ArrayDeque::new));\r\n        var blocks = ctx.block().stream()\r\n                .map(this::visitBlock)\r\n                .collect(Collectors.toCollection(ArrayDeque::new));\r\n\r\n        IfStatement nestedStatement;\r\n        if (conditions.size() < blocks.size()) {\r\n            Block elseBlock = blocks.removeLast();\r\n            Block ifBlock = blocks.removeLast();\r\n            nestedStatement = new IfStatement(\r\n                    conditions.removeLast(),\r\n                    ifBlock,\r\n                    elseBlock\r\n            );\r\n        } else {\r\n            nestedStatement = new IfStatement(\r\n                    conditions.removeLast(),\r\n                    blocks.removeLast(),\r\n                    new Block(List.of())\r\n            );\r\n        }\r\n        while (!blocks.isEmpty()) {\r\n            nestedStatement = new IfStatement(\r\n                    conditions.removeLast(),\r\n                    blocks.removeLast(),\r\n                    new Block(List.of(nestedStatement))\r\n            );\r\n        }\r\n        assert conditions.isEmpty();\r\n\r\n        AST_NODE_CONTEXTS.add(new Pair<>(nestedStatement, ctx));\r\n        return nestedStatement;\r\n    }\r\n\r\n    @Override\r\n    public IfStatement visitIfStatementStatement(SFMLParser.IfStatementStatementContext ctx) {\r\n        IfStatement ifStatement = visitIfstatement(ctx.ifstatement());\r\n        AST_NODE_CONTEXTS.add(new Pair<>(ifStatement, ctx));\r\n        return ifStatement;\r\n    }\r\n\r\n    @Override\r\n    public BoolExpr visitBooleanTrue(SFMLParser.BooleanTrueContext ctx) {\r\n        BoolExpr boolExpr = new BoolExpr(__ -> true, \"TRUE\");\r\n        AST_NODE_CONTEXTS.add(new Pair<>(boolExpr, ctx));\r\n        return boolExpr;\r\n    }\r\n\r\n    @Override\r\n    public BoolExpr visitBooleanHas(SFMLParser.BooleanHasContext ctx) {\r\n        var setOp = visitSetOp(ctx.setOp());\r\n        var labelAccess = visitLabelaccess(ctx.labelaccess());\r\n        var comparison = visitResourcecomparison(ctx.resourcecomparison());\r\n        BoolExpr booleanExpression = comparison.toBooleanExpression(\r\n                setOp,\r\n                labelAccess,\r\n                setOp.name().toUpperCase() + \" \" + labelAccess + \" HAS \" + comparison\r\n        );\r\n        AST_NODE_CONTEXTS.add(new Pair<>(booleanExpression, ctx));\r\n        return booleanExpression;\r\n    }\r\n\r\n    @Override\r\n    public SetOperator visitSetOp(@Nullable SFMLParser.SetOpContext ctx) {\r\n        if (ctx == null) return SetOperator.OVERALL;\r\n        SetOperator from = SetOperator.from(ctx.getText());\r\n        AST_NODE_CONTEXTS.add(new Pair<>(from, ctx));\r\n        return from;\r\n    }\r\n\r\n    @Override\r\n    public ResourceComparer<?, ?, ?> visitResourcecomparison(SFMLParser.ResourcecomparisonContext ctx) {\r\n        ComparisonOperator op = visitComparisonOp(ctx.comparisonOp());\r\n        Number num = visitNumber(ctx.number());\r\n        ResourceQuantity quantity = new ResourceQuantity(num, ResourceQuantity.IdExpansionBehaviour.NO_EXPAND);\r\n        ResourceIdentifier<?, ?, ?> item = (ResourceIdentifier<?, ?, ?>) visit(ctx.resourceid());\r\n        ResourceComparer<?, ?, ?> resourceComparer = new ResourceComparer<>(op, quantity, item);\r\n        AST_NODE_CONTEXTS.add(new Pair<>(resourceComparer, ctx));\r\n        return resourceComparer;\r\n    }\r\n\r\n    @Override\r\n    public ComparisonOperator visitComparisonOp(SFMLParser.ComparisonOpContext ctx) {\r\n        ComparisonOperator from = ComparisonOperator.from(ctx.getText());\r\n        AST_NODE_CONTEXTS.add(new Pair<>(from, ctx));\r\n        return from;\r\n    }\r\n\r\n    @Override\r\n    public BoolExpr visitBooleanConjunction(SFMLParser.BooleanConjunctionContext ctx) {\r\n        var left = (BoolExpr) visit(ctx.boolexpr(0));\r\n        var right = (BoolExpr) visit(ctx.boolexpr(1));\r\n        BoolExpr boolExpr = new BoolExpr(left.and(right), left.sourceCode() + \" AND \" + right.sourceCode());\r\n        AST_NODE_CONTEXTS.add(new Pair<>(boolExpr, ctx));\r\n        return boolExpr;\r\n    }\r\n\r\n    @Override\r\n    public BoolExpr visitBooleanDisjunction(SFMLParser.BooleanDisjunctionContext ctx) {\r\n        var left = (BoolExpr) visit(ctx.boolexpr(0));\r\n        var right = (BoolExpr) visit(ctx.boolexpr(1));\r\n        BoolExpr boolExpr = new BoolExpr(left.or(right), left.sourceCode() + \" OR \" + right.sourceCode());\r\n        AST_NODE_CONTEXTS.add(new Pair<>(boolExpr, ctx));\r\n        return boolExpr;\r\n    }\r\n\r\n    @Override\r\n    public BoolExpr visitBooleanFalse(SFMLParser.BooleanFalseContext ctx) {\r\n        BoolExpr boolExpr = new BoolExpr(__ -> false, \"FALSE\");\r\n        AST_NODE_CONTEXTS.add(new Pair<>(boolExpr, ctx));\r\n        return boolExpr;\r\n    }\r\n\r\n    @Override\r\n    public BoolExpr visitBooleanParen(SFMLParser.BooleanParenContext ctx) {\r\n        BoolExpr expr = (BoolExpr) visit(ctx.boolexpr());\r\n        AST_NODE_CONTEXTS.add(new Pair<>(expr, ctx));\r\n        return expr;\r\n    }\r\n\r\n    @Override\r\n    public BoolExpr visitBooleanNegation(SFMLParser.BooleanNegationContext ctx) {\r\n        var x = (BoolExpr) visit(ctx.boolexpr());\r\n        BoolExpr boolExpr = new BoolExpr(x.negate(), \"NOT \" + x.sourceCode());\r\n        AST_NODE_CONTEXTS.add(new Pair<>(boolExpr, ctx));\r\n        return boolExpr;\r\n    }\r\n\r\n    @Override\r\n    public Limit visitQuantityRetentionLimit(SFMLParser.QuantityRetentionLimitContext ctx) {\r\n        var quantity = visitQuantity(ctx.quantity());\r\n        var retain = visitRetention(ctx.retention());\r\n        Limit limit = new Limit(quantity, retain);\r\n        AST_NODE_CONTEXTS.add(new Pair<>(limit, ctx));\r\n        return limit;\r\n    }\r\n\r\n    @Override\r\n    public ResourceIdSet visitResourceexclusion(@Nullable SFMLParser.ResourceexclusionContext ctx) {\r\n        if (ctx == null) return ResourceIdSet.EMPTY;\r\n        ResourceIdSet resourceIdSet = new ResourceIdSet(ctx\r\n                                                                .resourceid()\r\n                                                                .stream()\r\n                                                                .map(this::visit)\r\n                                                                .map(ResourceIdentifier.class::cast)\r\n                                                                .collect(HashSet::new, HashSet::add, HashSet::addAll));\r\n        AST_NODE_CONTEXTS.add(new Pair<>(resourceIdSet, ctx));\r\n        return resourceIdSet;\r\n    }\r\n\r\n    @Override\r\n    public ResourceLimits visitInputmatchers(@Nullable SFMLParser.InputmatchersContext ctx) {\r\n        if (ctx == null) {\r\n            return new ResourceLimits(List.of(ResourceLimit.TAKE_ALL_LEAVE_NONE), ResourceIdSet.EMPTY);\r\n        }\r\n        ResourceLimits resourceLimits = ((ResourceLimits) visit(ctx.movement())).withDefaults(Limit.MAX_QUANTITY_NO_RETENTION);\r\n        AST_NODE_CONTEXTS.add(new Pair<>(resourceLimits, ctx));\r\n        return resourceLimits;\r\n    }\r\n\r\n\r\n    @Override\r\n    public ResourceLimits visitOutputmatchers(@Nullable SFMLParser.OutputmatchersContext ctx) {\r\n        if (ctx == null) {\r\n            return new ResourceLimits(List.of(ResourceLimit.ACCEPT_ALL_WITHOUT_RESTRAINT), ResourceIdSet.EMPTY);\r\n        }\r\n        ResourceLimits resourceLimits = ((ResourceLimits) visit(ctx.movement())).withDefaults(Limit.MAX_QUANTITY_MAX_RETENTION);\r\n        AST_NODE_CONTEXTS.add(new Pair<>(resourceLimits, ctx));\r\n        return resourceLimits;\r\n    }\r\n\r\n    @Override\r\n    public ASTNode visitResourceLimitMovement(SFMLParser.ResourceLimitMovementContext ctx) {\r\n        ResourceLimits resourceLimits = new ResourceLimits(\r\n                ctx.resourcelimit().stream()\r\n                        .map(this::visitResourcelimit)\r\n                        .collect(Collectors.toList()),\r\n                ResourceIdSet.EMPTY\r\n        );\r\n        AST_NODE_CONTEXTS.add(new Pair<>(resourceLimits, ctx));\r\n        return resourceLimits;\r\n    }\r\n\r\n    @Override\r\n    public ResourceLimits visitLimitMovement(SFMLParser.LimitMovementContext ctx) {\r\n        ResourceLimits resourceLimits = new ResourceLimits(\r\n                List.of(new ResourceLimit<>(\r\n                        ResourceIdentifier.MATCH_ALL, (Limit) this.visit(ctx.limit())\r\n                )),\r\n                ResourceIdSet.EMPTY\r\n        );\r\n        AST_NODE_CONTEXTS.add(new Pair<>(resourceLimits, ctx));\r\n        return resourceLimits;\r\n    }\r\n\r\n    @Override\r\n    public ResourceLimit<?, ?, ?> visitResourcelimit(SFMLParser.ResourcelimitContext ctx) {\r\n\r\n        var res = (ResourceIdentifier<?, ?, ?>) visit(ctx.resourceid());\r\n\r\n        if (ctx.limit() == null)\r\n            return new ResourceLimit<>(res, Limit.UNSET);\r\n\r\n        var limit = (Limit) visit(ctx.limit());\r\n        ResourceLimit<?, ?, ?> resourceLimit = new ResourceLimit<>(res, limit);\r\n        AST_NODE_CONTEXTS.add(new Pair<>(resourceLimit, ctx));\r\n        return resourceLimit;\r\n    }\r\n\r\n    @Override\r\n    public NumberRangeSet visitSlotqualifier(@Nullable SFMLParser.SlotqualifierContext ctx) {\r\n        NumberRangeSet numberRangeSet = visitRangeset(ctx == null ? null : ctx.rangeset());\r\n        AST_NODE_CONTEXTS.add(new Pair<>(numberRangeSet, ctx));\r\n        return numberRangeSet;\r\n    }\r\n\r\n    @Override\r\n    public ASTNode visitForgetStatementStatement(SFMLParser.ForgetStatementStatementContext ctx) {\r\n        ForgetStatement statement = (ForgetStatement) visit(ctx.forgetstatement());\r\n        AST_NODE_CONTEXTS.add(new Pair<>(statement, ctx));\r\n        return statement;\r\n    }\r\n\r\n    @Override\r\n    public ForgetStatement visitForgetstatement(SFMLParser.ForgetstatementContext ctx) {\r\n        List<Label> labels = ctx\r\n                .label()\r\n                .stream()\r\n                .map(this::visit)\r\n                .map(Label.class::cast)\r\n                .collect(Collectors.toList());\r\n        if (labels.isEmpty()) {\r\n            labels = USED_LABELS.stream().toList();\r\n        }\r\n        return new ForgetStatement(labels);\r\n    }\r\n\r\n    @Override\r\n    public NumberRangeSet visitRangeset(@Nullable SFMLParser.RangesetContext ctx) {\r\n        if (ctx == null) return NumberRangeSet.MAX_RANGE;\r\n        NumberRangeSet numberRangeSet = new NumberRangeSet(ctx\r\n                                                                   .range()\r\n                                                                   .stream()\r\n                                                                   .map(this::visitRange)\r\n                                                                   .toArray(NumberRange[]::new));\r\n        AST_NODE_CONTEXTS.add(new Pair<>(numberRangeSet, ctx));\r\n        return numberRangeSet;\r\n    }\r\n\r\n    @Override\r\n    public NumberRange visitRange(SFMLParser.RangeContext ctx) {\r\n        var iter = ctx.number().stream().map(this::visitNumber).mapToLong(Number::value).iterator();\r\n        var start = iter.next();\r\n        if (iter.hasNext()) {\r\n            var end = iter.next();\r\n            NumberRange numberRange = new NumberRange(start, end);\r\n            AST_NODE_CONTEXTS.add(new Pair<>(numberRange, ctx));\r\n            return numberRange;\r\n        } else {\r\n            NumberRange numberRange = new NumberRange(start, start);\r\n            AST_NODE_CONTEXTS.add(new Pair<>(numberRange, ctx));\r\n            return numberRange;\r\n        }\r\n    }\r\n\r\n\r\n    @Override\r\n    public Limit visitRetentionLimit(SFMLParser.RetentionLimitContext ctx) {\r\n        var retain = visitRetention(ctx.retention());\r\n        Limit limit = new Limit(ResourceQuantity.UNSET, retain);\r\n        AST_NODE_CONTEXTS.add(new Pair<>(limit, ctx));\r\n        return limit;\r\n    }\r\n\r\n    @Override\r\n    public Limit visitQuantityLimit(SFMLParser.QuantityLimitContext ctx) {\r\n        var quantity = visitQuantity(ctx.quantity());\r\n        Limit limit = new Limit(quantity, ResourceQuantity.UNSET);\r\n        AST_NODE_CONTEXTS.add(new Pair<>(limit, ctx));\r\n        return limit;\r\n    }\r\n\r\n    @Override\r\n    public ResourceQuantity visitRetention(@Nullable SFMLParser.RetentionContext ctx) {\r\n        if (ctx == null)\r\n            return ResourceQuantity.UNSET;\r\n        ResourceQuantity quantity = new ResourceQuantity(\r\n                visitNumber(ctx.number()),\r\n                ctx.EACH() != null\r\n                ? ResourceQuantity.IdExpansionBehaviour.EXPAND\r\n                : ResourceQuantity.IdExpansionBehaviour.NO_EXPAND\r\n        );\r\n        AST_NODE_CONTEXTS.add(new Pair<>(quantity, ctx));\r\n        return quantity;\r\n    }\r\n\r\n    @Override\r\n    public ResourceQuantity visitQuantity(@Nullable SFMLParser.QuantityContext ctx) {\r\n        if (ctx == null) return ResourceQuantity.MAX_QUANTITY;\r\n        ResourceQuantity quantity = new ResourceQuantity(\r\n                visitNumber(ctx.number()),\r\n                ctx.EACH() != null\r\n                ? ResourceQuantity.IdExpansionBehaviour.EXPAND\r\n                : ResourceQuantity.IdExpansionBehaviour.NO_EXPAND\r\n        );\r\n        AST_NODE_CONTEXTS.add(new Pair<>(quantity, ctx));\r\n        return quantity;\r\n    }\r\n\r\n    @Override\r\n    public DirectionQualifier visitSidequalifier(@Nullable SFMLParser.SidequalifierContext ctx) {\r\n        if (ctx == null) return DirectionQualifier.NULL_DIRECTION;\r\n        DirectionQualifier directionQualifier = new DirectionQualifier(\r\n                EnumSet.copyOf(ctx.side().stream()\r\n                                       .map(this::visitSide)\r\n                                       .map(DirectionQualifier::lookup)\r\n                                       .toList())\r\n        );\r\n        AST_NODE_CONTEXTS.add(new Pair<>(directionQualifier, ctx));\r\n        return directionQualifier;\r\n    }\r\n\r\n    @Override\r\n    public Side visitSide(SFMLParser.SideContext ctx) {\r\n        Side side = Side.valueOf(ctx.getText().toUpperCase(Locale.ROOT));\r\n        AST_NODE_CONTEXTS.add(new Pair<>(side, ctx));\r\n        return side;\r\n    }\r\n\r\n    @Override\r\n    public Block visitBlock(@Nullable SFMLParser.BlockContext ctx) {\r\n        if (ctx == null) return new Block(Collections.emptyList());\r\n        var statements = ctx\r\n                .statement()\r\n                .stream()\r\n                .map(this::visit)\r\n                .map(Statement.class::cast)\r\n                .collect(Collectors.toList());\r\n        Block block = new Block(statements);\r\n        AST_NODE_CONTEXTS.add(new Pair<>(block, ctx));\r\n        return block;\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfml\\ast\\StringHolder.java\r\n\r\n````java\r\npackage ca.teamdman.sfml.ast;\r\n\r\npublic record StringHolder(String value) implements ASTNode {\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfml\\ast\\ForgetStatement.java\r\n\r\n````java\r\npackage ca.teamdman.sfml.ast;\r\n\r\nimport ca.teamdman.sfm.common.program.ProgramContext;\r\n\r\nimport java.util.List;\r\nimport java.util.Objects;\r\nimport java.util.stream.Collectors;\r\n\r\npublic record ForgetStatement(\r\n        List<Label> labels\r\n) implements Statement {\r\n    @Override\r\n    public void tick(ProgramContext context) {\r\n        // map-replace existing inputs with ones that exclude the union of the label access\r\n        var newInputs = context.getInputs()\r\n                .stream()\r\n                .map(input -> new InputStatement(\r\n                        new LabelAccess(\r\n                                input.labelAccess().labels().stream()\r\n                                        .filter(label -> !this.labels.contains(label))\r\n                                        .collect(Collectors.toList()),\r\n                                input.labelAccess().directions(),\r\n                                input.labelAccess().slots(),\r\n                                input.labelAccess().roundRobin()\r\n                        ),\r\n                        input.resourceLimits(),\r\n                        input.each()\r\n                ))\r\n                .filter(input -> !input.labelAccess().labels().isEmpty())\r\n                .toList();\r\n        context.getInputs().clear();\r\n        context.getInputs().addAll(newInputs);\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"FORGET \" + labels.stream().map(Objects::toString).collect(Collectors.joining(\", \"));\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfml\\ast\\ResourceIdentifier.java\r\n\r\n````java\r\npackage ca.teamdman.sfml.ast;\r\n\r\nimport ca.teamdman.sfm.SFM;\r\nimport ca.teamdman.sfm.common.program.RegexCache;\r\nimport ca.teamdman.sfm.common.registry.SFMResourceTypes;\r\nimport ca.teamdman.sfm.common.resourcetype.ResourceType;\r\nimport it.unimi.dsi.fastutil.objects.Object2ObjectOpenHashMap;\r\nimport net.minecraft.ResourceLocationException;\r\nimport net.minecraft.resources.ResourceLocation;\r\n\r\nimport javax.annotation.Nullable;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.Objects;\r\nimport java.util.Optional;\r\nimport java.util.function.Predicate;\r\nimport java.util.regex.Pattern;\r\nimport java.util.regex.PatternSyntaxException;\r\n\r\n// resourceTypeName resourceNamespace, resourceTypeName name, resource resourceNamespace, resource name\r\n// sfm:item:minecraft:stone\r\npublic class ResourceIdentifier<STACK, ITEM, CAP> implements ASTNode, Predicate<Object> {\r\n\r\n    public static final ResourceIdentifier<?, ?, ?> MATCH_ALL = new ResourceIdentifier<>(\r\n            \".*\",\r\n            \".*\"\r\n    );\r\n\r\n    public final String resourceTypeNamespace;\r\n    public final String resourceTypeName;\r\n    public final String resourceNamespace;\r\n    public final String resourceName;\r\n    private @Nullable ResourceType<STACK, ITEM, CAP> resourceTypeCache = null;\r\n\r\n\r\n    private final Predicate<String> resourceNamespacePredicate;\r\n    private final Predicate<String> resourceNamePredicate;\r\n\r\n    public ResourceIdentifier(\r\n            String resourceTypeNamespace,\r\n            String resourceTypeName,\r\n            String resourceNamespace,\r\n            String resourceName\r\n    ) {\r\n        this.resourceTypeNamespace = resourceTypeNamespace;\r\n        this.resourceTypeName = resourceTypeName;\r\n        this.resourceNamespace = resourceNamespace;\r\n        this.resourceName = resourceName;\r\n        this.resourceNamespacePredicate = RegexCache.buildPredicate(resourceNamespace);\r\n        this.resourceNamePredicate = RegexCache.buildPredicate(resourceName);\r\n    }\r\n\r\n    public boolean matchesStack(ResourceLocation stackId) {\r\n        return resourceNamePredicate.test(stackId.getPath()) && resourceNamespacePredicate.test(stackId.getNamespace());\r\n    }\r\n\r\n    public ResourceIdentifier(String value) {\r\n        this(SFM.MOD_ID, \"item\", \".*\", value);\r\n    }\r\n\r\n    public ResourceIdentifier(String namespace, String value) {\r\n        this(SFM.MOD_ID, \"item\", namespace, value);\r\n    }\r\n\r\n    public ResourceIdentifier(String typeName, String resourceNamespace, String resourceName) {\r\n        this(SFM.MOD_ID, typeName, resourceNamespace, resourceName);\r\n    }\r\n\r\n    public static <STACK, ITEM, CAP> ResourceIdentifier<STACK, ITEM, CAP> fromString(String string) {\r\n        var parts = string.split(\":\");\r\n        if (parts.length == 1) {\r\n            return new ResourceIdentifier<>(parts[0]);\r\n        } else if (parts.length == 2) {\r\n            return new ResourceIdentifier<>(parts[0], parts[1]);\r\n        } else if (parts.length == 3) {\r\n            return new ResourceIdentifier<>(parts[0], parts[1], parts[2]);\r\n        } else if (parts.length == 4) {\r\n            return new ResourceIdentifier<>(parts[0], parts[1], parts[2], parts[3]);\r\n        } else {\r\n            throw new IllegalArgumentException(\"bad resource id: \" + string);\r\n        }\r\n    }\r\n\r\n    public void assertValid() throws IllegalArgumentException {\r\n        try {\r\n            if (RegexCache.isRegexPattern(this.resourceNamespace)) {\r\n                Pattern.compile(this.resourceNamespace);\r\n            }\r\n            if (RegexCache.isRegexPattern(this.resourceName)) {\r\n                Pattern.compile(this.resourceName);\r\n            }\r\n        } catch (PatternSyntaxException e) {\r\n            throw new IllegalArgumentException(\"Invalid resource identifier pattern \\\"\"\r\n                                               + this\r\n                                               + \"\\\" - \"\r\n                                               + e.getMessage());\r\n        }\r\n    }\r\n\r\n    public Optional<ResourceLocation> getLocation() {\r\n        try {\r\n            return Optional.of(new ResourceLocation(resourceNamespace, resourceName));\r\n        } catch (ResourceLocationException e) {\r\n            return Optional.empty();\r\n        }\r\n    }\r\n\r\n    private static final Map<ResourceIdentifier<?, ?, ?>, List<ResourceIdentifier<?, ?, ?>>> expansionCache = new Object2ObjectOpenHashMap<>();\r\n\r\n    public boolean test(Object other) {\r\n        ResourceType<STACK, ITEM, CAP> resourceType = getResourceType();\r\n        return resourceType != null && resourceType.matchesStack(this, other);\r\n    }\r\n\r\n    public List<ResourceIdentifier<STACK, ITEM, CAP>> expand() {\r\n        if (this.getResourceType() == SFMResourceTypes.FORGE_ENERGY.get())\r\n            return List.of(new ResourceIdentifier<>(\r\n                    this.resourceTypeNamespace,\r\n                    this.resourceTypeName,\r\n                    \"forge\",\r\n                    \"energy\"\r\n            ));\r\n        if (expansionCache.containsKey(this)) {\r\n            //noinspection unchecked,rawtypes\r\n            return (List<ResourceIdentifier<STACK, ITEM, CAP>>) (List) expansionCache.get(this);\r\n        }\r\n        ResourceType<STACK, ITEM, CAP> resourceType = getResourceType();\r\n        //noinspection DataFlowIssue // if we get here, it should have a registry\r\n        List<ResourceIdentifier<STACK, ITEM, CAP>> rtn = resourceType.getRegistry().getEntries().stream()\r\n                .filter(e -> matchesStack(e.getKey().location()))\r\n                .map(e -> new ResourceIdentifier<STACK, ITEM, CAP>(\r\n                        resourceTypeNamespace,\r\n                        resourceTypeName,\r\n                        e.getKey().location().getNamespace(),\r\n                        e.getKey().location().getPath()\r\n                )).toList();\r\n        //noinspection unchecked,rawtypes\r\n        expansionCache.put(this, (List) rtn);\r\n        return rtn;\r\n    }\r\n\r\n    public void setResourceTypeCache(@Nullable ResourceType<STACK, ITEM, CAP> resourceTypeCache) {\r\n        this.resourceTypeCache = resourceTypeCache;\r\n    }\r\n\r\n    public @Nullable ResourceType<STACK, ITEM, CAP> getResourceType() {\r\n        if (resourceTypeCache == null) {\r\n            //noinspection unchecked\r\n            setResourceTypeCache((ResourceType<STACK, ITEM, CAP>) SFMResourceTypes.fastLookup(\r\n                    resourceTypeNamespace,\r\n                    resourceTypeName\r\n            ));\r\n        }\r\n        return resourceTypeCache;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return resourceTypeNamespace + \":\" + resourceTypeName + \":\" + resourceNamespace + \":\" + resourceName;\r\n    }\r\n\r\n    public String toStringCondensed() {\r\n        String rtn;\r\n        if (resourceTypeNamespace.equals(SFM.MOD_ID) && resourceTypeName.equals(\"item\")) {\r\n            if (resourceNamespace.equals(\".*\")) {\r\n                rtn = resourceName;\r\n            } else {\r\n                rtn = resourceNamespace + \":\" + resourceName;\r\n            }\r\n        } else if (\r\n                resourceTypeNamespace.equals(SFM.MOD_ID)\r\n                && resourceTypeName.equals(\"forge_energy\")\r\n                && getLocation()\r\n                        .filter(rl -> rl.equals(new ResourceLocation(\"forge\", \"energy\")))\r\n                        .isPresent()\r\n        ) {\r\n            rtn = \"forge_energy::\";\r\n        } else if (resourceTypeNamespace.equals(SFM.MOD_ID)) {\r\n            rtn = resourceTypeName + \":\" + resourceNamespace + \":\" + resourceName;\r\n        } else {\r\n            rtn = resourceTypeNamespace + \":\" + resourceTypeName + \":\" + resourceNamespace + \":\" + resourceName;\r\n        }\r\n        return rtn;\r\n    }\r\n\r\n    @Override\r\n    public boolean equals(Object o) {\r\n        if (this == o) return true;\r\n        if (o == null || getClass() != o.getClass()) return false;\r\n        ResourceIdentifier<?, ?, ?> that = (ResourceIdentifier<?, ?, ?>) o;\r\n        return Objects.equals(resourceTypeNamespace, that.resourceTypeNamespace)\r\n               && Objects.equals(resourceTypeName, that.resourceTypeName)\r\n               && Objects.equals(resourceNamespace, that.resourceNamespace)\r\n               && Objects.equals(resourceName, that.resourceName);\r\n    }\r\n\r\n    @Override\r\n    public int hashCode() {\r\n        return Objects.hash(resourceTypeNamespace, resourceTypeName, resourceNamespace, resourceName);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\compat\\SFMMekanismCompat.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.common.compat;\r\n\r\nimport ca.teamdman.sfm.SFM;\r\nimport ca.teamdman.sfm.common.Constants;\r\nimport ca.teamdman.sfm.common.registry.SFMResourceTypes;\r\nimport ca.teamdman.sfm.common.resourcetype.*;\r\nimport ca.teamdman.sfml.ast.DirectionQualifier;\r\nimport mekanism.api.RelativeSide;\r\nimport mekanism.common.lib.transmitter.TransmissionType;\r\nimport mekanism.common.tile.component.TileComponentConfig;\r\nimport mekanism.common.tile.component.config.ConfigInfo;\r\nimport mekanism.common.tile.component.config.DataType;\r\nimport mekanism.common.tile.interfaces.ISideConfiguration;\r\nimport net.minecraft.core.Direction;\r\nimport net.minecraft.resources.ResourceLocation;\r\nimport net.minecraft.world.level.block.entity.BlockEntity;\r\nimport net.minecraftforge.registries.DeferredRegister;\r\n\r\nimport java.util.HashSet;\r\nimport java.util.Optional;\r\nimport java.util.Set;\r\nimport java.util.stream.Collectors;\r\n\r\npublic class SFMMekanismCompat {\r\n    @SuppressWarnings(\"DataFlowIssue\")\r\n    public static Optional<ResourceType<?, ?, ?>> getResourceType(TransmissionType trans) {\r\n        return switch (trans) {\r\n            case ITEM -> Optional.of(SFMResourceTypes.ITEM.get());\r\n            case FLUID -> Optional.of(SFMResourceTypes.FLUID.get());\r\n            case GAS -> Optional.of(SFMResourceTypes.DEFERRED_TYPES\r\n                                            .get()\r\n                                            .getValue(new ResourceLocation(SFM.MOD_ID, \"gas\")));\r\n            case INFUSION -> Optional.of(SFMResourceTypes.DEFERRED_TYPES\r\n                                                 .get()\r\n                                                 .getValue(new ResourceLocation(SFM.MOD_ID, \"infusion\")));\r\n            case PIGMENT -> Optional.of(SFMResourceTypes.DEFERRED_TYPES\r\n                                                .get()\r\n                                                .getValue(new ResourceLocation(SFM.MOD_ID, \"pigment\")));\r\n            case SLURRY -> Optional.of(SFMResourceTypes.DEFERRED_TYPES\r\n                                               .get()\r\n                                               .getValue(new ResourceLocation(SFM.MOD_ID, \"slurry\")));\r\n            default -> Optional.empty();\r\n        };\r\n    }\r\n\r\n    public static String gatherInspectionResults(BlockEntity blockEntity) {\r\n        if (!(blockEntity instanceof ISideConfiguration sideConfiguration)) {\r\n            return \"\";\r\n        }\r\n        StringBuilder sb = new StringBuilder();\r\n        sb.append(\"-- Mekanism stuff\\n\");\r\n        TileComponentConfig config = sideConfiguration.getConfig();\r\n        for (TransmissionType type : TransmissionType.values()) {\r\n            getResourceType(type)\r\n                    .flatMap(resourceType -> SFMResourceTypes.DEFERRED_TYPES.get().getResourceKey(resourceType))\r\n                    .ifPresent(resourceTypeKey -> {\r\n                        ConfigInfo info = config.getConfig(type);\r\n                        if (info != null) {\r\n                            Set<Direction> outputSides = info.getSides(DataType::canOutput);\r\n                            if (!outputSides.isEmpty()) {\r\n                                sb\r\n                                        .append(\"-- \")\r\n                                        .append(Constants.LocalizationKeys.CONTAINER_INSPECTOR_MEKANISM_MACHINE_OUTPUTS.getString())\r\n                                        .append(\"\\n\");\r\n                                sb.append(\"INPUT \").append(resourceTypeKey.location()).append(\":: FROM target \");\r\n                                sb.append(outputSides\r\n                                                  .stream()\r\n                                                  .map(DirectionQualifier::directionToString)\r\n                                                  .collect(Collectors.joining(\", \")));\r\n                                sb.append(\" SIDE\\n\");\r\n                            }\r\n\r\n                            Set<Direction> inputSides = new HashSet<>();\r\n                            for (RelativeSide side : RelativeSide.values()) {\r\n                                DataType dataType = info.getDataType(side);\r\n                                if (dataType == DataType.INPUT\r\n                                    || dataType == DataType.INPUT_1\r\n                                    || dataType == DataType.INPUT_2\r\n                                    || dataType == DataType.INPUT_OUTPUT) {\r\n                                    inputSides.add(side.getDirection(sideConfiguration.getDirection()));\r\n                                }\r\n                            }\r\n                            if (!inputSides.isEmpty()) {\r\n                                sb\r\n                                        .append(\"-- \")\r\n                                        .append(Constants.LocalizationKeys.CONTAINER_INSPECTOR_MEKANISM_MACHINE_INPUTS.getString())\r\n                                        .append(\"\\n\");\r\n                                sb.append(\"OUTPUT \").append(resourceTypeKey.location()).append(\":: TO target \");\r\n                                sb.append(inputSides\r\n                                                  .stream()\r\n                                                  .map(DirectionQualifier::directionToString)\r\n                                                  .collect(Collectors.joining(\", \")));\r\n                                sb.append(\" SIDE\\n\");\r\n                            }\r\n                        }\r\n                    });\r\n        }\r\n        return sb.toString();\r\n    }\r\n\r\n    public static void register(DeferredRegister<ResourceType<?, ?, ?>> types) {\r\n        types.register(\r\n                \"gas\",\r\n                GasResourceType::new\r\n        );\r\n        types.register(\r\n                \"infusion\",\r\n                InfuseResourceType::new\r\n        );\r\n\r\n        types.register(\r\n                \"pigment\",\r\n                PigmentResourceType::new\r\n        );\r\n        types.register(\r\n                \"slurry\",\r\n                SlurryResourceType::new\r\n        );\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\client\\registry\\SFMKeyMappings.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.client.registry;\r\n\r\nimport ca.teamdman.sfm.SFM;\r\nimport ca.teamdman.sfm.common.Constants;\r\nimport com.mojang.blaze3d.platform.InputConstants;\r\nimport net.minecraft.client.KeyMapping;\r\nimport net.minecraftforge.api.distmarker.Dist;\r\nimport net.minecraftforge.client.event.RegisterKeyMappingsEvent;\r\nimport net.minecraftforge.client.settings.KeyConflictContext;\r\nimport net.minecraftforge.client.settings.KeyModifier;\r\nimport net.minecraftforge.common.util.Lazy;\r\nimport net.minecraftforge.eventbus.api.SubscribeEvent;\r\nimport net.minecraftforge.fml.common.Mod;\r\nimport org.lwjgl.glfw.GLFW;\r\n\r\n\r\n@Mod.EventBusSubscriber(bus = Mod.EventBusSubscriber.Bus.MOD, modid = SFM.MOD_ID, value = Dist.CLIENT)\r\n\r\npublic class SFMKeyMappings {\r\n    public static final Lazy<KeyMapping> MORE_INFO_TOOLTIP_KEY = Lazy.of(() -> new KeyMapping(\r\n            Constants.LocalizationKeys.MORE_HOVER_INFO_KEY.key().get(),\r\n            KeyConflictContext.GUI,\r\n            InputConstants.Type.KEYSYM,\r\n            GLFW.GLFW_KEY_LEFT_SHIFT,\r\n            Constants.LocalizationKeys.SFM_KEY_CATEGORY.key().get()\r\n    ));\r\n\r\n    public static final Lazy<KeyMapping> CONTAINER_INSPECTOR_KEY = Lazy.of(() -> new KeyMapping(\r\n            Constants.LocalizationKeys.CONTAINER_INSPECTOR_TOGGLE_KEY.key().get(),\r\n            KeyConflictContext.GUI,\r\n            KeyModifier.CONTROL,\r\n            InputConstants.Type.KEYSYM,\r\n            GLFW.GLFW_KEY_I,\r\n            Constants.LocalizationKeys.SFM_KEY_CATEGORY.key().get()\r\n    ));\r\n\r\n    @SubscribeEvent\r\n    public static void registerBindings(RegisterKeyMappingsEvent event) {\r\n        event.register(MORE_INFO_TOOLTIP_KEY.get());\r\n        event.register(CONTAINER_INSPECTOR_KEY.get());\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\net\\ServerboundLabelGunUpdatePacket.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.common.net;\r\n\r\nimport ca.teamdman.sfm.common.item.LabelGunItem;\r\nimport net.minecraft.network.FriendlyByteBuf;\r\nimport net.minecraft.world.InteractionHand;\r\nimport net.minecraftforge.network.NetworkEvent;\r\n\r\nimport java.util.function.Supplier;\r\n\r\npublic record ServerboundLabelGunUpdatePacket(\r\n        String label,\r\n        InteractionHand hand\r\n) {\r\n    public static final int MAX_LABEL_LENGTH = 80;\r\n\r\n    public static void encode(ca.teamdman.sfm.common.net.ServerboundLabelGunUpdatePacket msg, FriendlyByteBuf buf) {\r\n        buf.writeUtf(msg.label, MAX_LABEL_LENGTH);\r\n        buf.writeEnum(msg.hand);\r\n    }\r\n\r\n    public static ca.teamdman.sfm.common.net.ServerboundLabelGunUpdatePacket decode(\r\n            FriendlyByteBuf buf\r\n    ) {\r\n        return new ServerboundLabelGunUpdatePacket(buf.readUtf(MAX_LABEL_LENGTH), buf.readEnum(InteractionHand.class));\r\n    }\r\n\r\n    public static void handle(\r\n            ca.teamdman.sfm.common.net.ServerboundLabelGunUpdatePacket msg, Supplier<NetworkEvent.Context> ctx\r\n    ) {\r\n        ctx.get().enqueueWork(() -> {\r\n            var sender = ctx.get().getSender();\r\n            if (sender == null) {\r\n                return;\r\n            }\r\n            var stack = sender.getItemInHand(msg.hand);\r\n            if (stack.getItem() instanceof LabelGunItem) {\r\n                LabelGunItem.setActiveLabel(stack, msg.label);\r\n            }\r\n        });\r\n        ctx.get().setPacketHandled(true);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\client\\gui\\screen\\ProgramTemplatePickerScreen.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.client.gui.screen;\r\n\r\nimport ca.teamdman.sfm.common.Constants;\r\nimport ca.teamdman.sfm.common.registry.SFMResourceTypes;\r\nimport ca.teamdman.sfml.ast.Program;\r\nimport com.mojang.blaze3d.vertex.PoseStack;\r\nimport net.minecraft.client.Minecraft;\r\nimport net.minecraft.client.gui.components.Button;\r\nimport net.minecraft.client.gui.screens.Screen;\r\nimport net.minecraft.network.chat.Component;\r\nimport net.minecraft.network.chat.MutableComponent;\r\nimport net.minecraft.resources.ResourceLocation;\r\nimport net.minecraft.server.packs.resources.Resource;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.util.Comparator;\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\nimport java.util.function.Consumer;\r\nimport java.util.stream.Collectors;\r\n\r\npublic class ProgramTemplatePickerScreen extends Screen {\r\n    private final Consumer<String> CALLBACK;\r\n\r\n    public ProgramTemplatePickerScreen(Consumer<String> callback) {\r\n        super(Constants.LocalizationKeys.PROGRAM_TEMPLATE_PICKER_GUI_TITLE.getComponent());\r\n        CALLBACK = callback;\r\n    }\r\n\r\n    @Override\r\n    protected void init() {\r\n        super.init();\r\n\r\n        //discover template programs\r\n        var irm = Minecraft.getInstance().getResourceManager();\r\n        Map<ResourceLocation, Resource> found = irm.listResources(\r\n                \"template_programs\",\r\n                (path) -> path.getPath().endsWith(\".sfml\") || path.getPath().endsWith(\".sfm\")\r\n        );\r\n        Map<String, String> templatePrograms = new HashMap<>();\r\n        for (var entry : found.entrySet()) {\r\n            try (BufferedReader reader = entry.getValue().openAsReader()) {\r\n                String program = reader.lines().collect(Collectors.joining(\"\\n\"));\r\n                if (program.contains(\"$REPLACE_RESOURCE_TYPES_HERE$\")) {\r\n                    var replacement = SFMResourceTypes.DEFERRED_TYPES.get().getEntries()\r\n                            .stream()\r\n                            .map(e -> e.getKey().location().getPath())\r\n                            .map(e -> \"INPUT \" + e + \":: FROM a\")\r\n                            .collect(Collectors.joining(\"\\n    \"));\r\n                    program = program.replace(\"$REPLACE_RESOURCE_TYPES_HERE$\", replacement);\r\n                }\r\n                String finalProgram = program;\r\n                Program.compile(\r\n                        program,\r\n                        (successProgram, builder) -> templatePrograms.put(\r\n                                successProgram.name().isBlank() ? entry.getKey().toString() : successProgram.name(),\r\n                                finalProgram\r\n                        ),\r\n                        failure -> templatePrograms.put(entry.getKey().toString(), finalProgram)\r\n                );\r\n            } catch (IOException ignored) {\r\n            }\r\n        }\r\n\r\n        // add picker buttons\r\n        {\r\n            int i = 0;\r\n            int buttonWidth = templatePrograms.keySet()\r\n                                      .stream()\r\n                                      .mapToInt(this.font::width)\r\n                                      .max().orElse(50) + 10;\r\n            int buttonHeight = 20;\r\n            int paddingX = 5;\r\n            int paddingY = 5;\r\n            int buttonsPerRow = this.width / (buttonWidth + paddingX);\r\n            for (var entry : templatePrograms\r\n                    .entrySet()\r\n                    .stream()\r\n                    .sorted((o1, o2) -> Comparator.<String>naturalOrder().compare(o1.getKey(), o2.getKey()))\r\n                    .toList()) {\r\n                int x = (this.width - (buttonWidth + paddingX) * Math.min(buttonsPerRow, templatePrograms.size())) / 2\r\n                        + paddingX\r\n                        + (i % buttonsPerRow) * (\r\n                        buttonWidth\r\n                        + paddingX\r\n                );\r\n                int y = 50 + (i / buttonsPerRow) * (buttonHeight + paddingY);\r\n                this.addRenderableWidget(new Button(\r\n                        x,\r\n                        y,\r\n                        buttonWidth,\r\n                        buttonHeight,\r\n                        Component.literal(entry.getKey()),\r\n                        (btn) -> {\r\n                            onClose();\r\n                            CALLBACK.accept(entry.getValue());\r\n                        }\r\n                ));\r\n                i++;\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    @Override\r\n    public void render(PoseStack pPoseStack, int pMouseX, int pMouseY, float pPartialTick) {\r\n        this.renderBackground(pPoseStack);\r\n        this.renderBackground(pPoseStack);\r\n        this.renderBackground(pPoseStack);\r\n        super.render(pPoseStack, pMouseX, pMouseY, pPartialTick);\r\n        MutableComponent warning1 = Constants.LocalizationKeys.PROGRAM_TEMPLATE_PICKER_GUI_WARNING_1.getComponent();\r\n        this.font.draw(\r\n                pPoseStack,\r\n                warning1,\r\n                this.width / 2f - this.font.width(warning1) / 2f,\r\n                20,\r\n                16777215\r\n        );\r\n        MutableComponent warning2 = Constants.LocalizationKeys.PROGRAM_TEMPLATE_PICKER_GUI_WARNING_2.getComponent();\r\n        this.font.draw(\r\n                pPoseStack,\r\n                warning2,\r\n                this.width / 2f - this.font.width(warning2) / 2f,\r\n                36,\r\n                16777215\r\n        );\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfml\\ast\\ComparisonOperator.java\r\n\r\n````java\r\npackage ca.teamdman.sfml.ast;\r\n\r\nimport java.util.Locale;\r\nimport java.util.function.BiPredicate;\r\n\r\npublic enum ComparisonOperator implements ASTNode, BiPredicate<Long, Long> {\r\n    GREATER((a, b) -> a > b),\r\n    LESSER((a, b) -> a < b),\r\n    EQUALS(Long::equals),\r\n    LESSER_OR_EQUAL((a, b) -> a <= b),\r\n    GREATER_OR_EQUAL((a, b) -> a >= b);\r\n\r\n    private final BiPredicate<Long, Long> PRED;\r\n\r\n    ComparisonOperator(BiPredicate<Long, Long> pred) {\r\n        this.PRED = pred;\r\n    }\r\n\r\n    public static ComparisonOperator from(String text) {\r\n        return switch (text.toUpperCase(Locale.ROOT)) {\r\n            case \"GT\", \">\" -> GREATER;\r\n            case \"LT\", \"<\" -> LESSER;\r\n            case \"EQ\", \"=\" -> EQUALS;\r\n            case \"LE\", \"<=\" -> LESSER_OR_EQUAL;\r\n            case \"GE\", \">=\" -> GREATER_OR_EQUAL;\r\n            default -> throw new IllegalArgumentException(\"Invalid comparison operator: \" + text);\r\n        };\r\n    }\r\n\r\n    public String getSourceCode() {\r\n        return switch (this) {\r\n            case GREATER -> \">\";\r\n            case LESSER -> \"<\";\r\n            case EQUALS -> \"=\";\r\n            case LESSER_OR_EQUAL -> \"<=\";\r\n            case GREATER_OR_EQUAL -> \">=\";\r\n        };\r\n    }\r\n\r\n    @Override\r\n    public boolean test(Long a, Long b) {\r\n        return PRED.test(a, b);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\program\\RegexCache.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.common.program;\r\n\r\nimport it.unimi.dsi.fastutil.objects.Object2ObjectOpenHashMap;\r\n\r\nimport java.util.Map;\r\nimport java.util.function.Predicate;\r\nimport java.util.regex.Pattern;\r\n\r\n// Having this logic inside ResourceIdentifier.java causes classloading issues lol\r\npublic class RegexCache {\r\n    private static final Map<String, Predicate<String>> patternCache = new Object2ObjectOpenHashMap<>();\r\n\r\n    static {\r\n        // we want to make common match-all patterns fast\r\n        // resource names are lowercase alphanumeric with underscores\r\n        String[] matchAny = new String[]{\r\n                \".\",\r\n                \"[a-z0-9/._-]\",\r\n                };\r\n        String[] suffixes = new String[]{\"+\", \"*\"};\r\n        for (String s : matchAny) {\r\n            for (String suffix : suffixes) {\r\n                patternCache.put(s + suffix, s1 -> true);\r\n                patternCache.put(\"^\" + s + suffix, s1 -> true);\r\n                patternCache.put(\"^\" + s + suffix + \"$\", s1 -> true);\r\n                patternCache.put(s + suffix + \"$\", s1 -> true);\r\n            }\r\n        }\r\n    }\r\n\r\n    public static Predicate<String> buildPredicate(String possiblePattern) {\r\n        return isRegexPattern(possiblePattern)\r\n               ? patternCache.computeIfAbsent(possiblePattern, x -> Pattern.compile(x).asMatchPredicate())\r\n               : possiblePattern::equals;\r\n    }\r\n\r\n    public static boolean isRegexPattern(String pattern) {\r\n        String specialChars = \".?*+^$[](){}|\\\\\";\r\n        for (int i = 0; i < pattern.length(); i++) {\r\n            if (specialChars.indexOf(pattern.charAt(i)) >= 0) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\program\\ProgramContext.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.common.program;\r\n\r\nimport ca.teamdman.sfm.common.blockentity.ManagerBlockEntity;\r\nimport ca.teamdman.sfm.common.cablenetwork.CableNetwork;\r\nimport ca.teamdman.sfm.common.cablenetwork.CableNetworkManager;\r\nimport ca.teamdman.sfml.ast.IfStatement;\r\nimport ca.teamdman.sfml.ast.InputStatement;\r\nimport ca.teamdman.sfml.ast.Program;\r\nimport net.minecraft.world.level.Level;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\npublic class ProgramContext {\r\n    private final Program PROGRAM;\r\n    private final ManagerBlockEntity MANAGER;\r\n    private final CableNetwork NETWORK;\r\n    private final List<InputStatement> INPUTS = new ArrayList<>();\r\n    private final Level LEVEL;\r\n    private final ExecutionPolicy EXECUTION_POLICY;\r\n    private final List<Branch> PATH_TAKEN = new ArrayList<>();\r\n    private final int EXPLORATION_BRANCH_INDEX;\r\n    private final int REDSTONE_PULSES;\r\n\r\n    public ProgramContext(Program program, ManagerBlockEntity manager, ExecutionPolicy executionPolicy) {\r\n        this(program, manager, executionPolicy, 0);\r\n    }\r\n\r\n    public ProgramContext(\r\n            Program program,\r\n            ManagerBlockEntity manager,\r\n            ExecutionPolicy executionPolicy,\r\n            int branchIndex\r\n    ) {\r\n        this.PROGRAM = program;\r\n        this.MANAGER = manager;\r\n        //noinspection OptionalGetWithoutIsPresent // program shouldn't be ticking if the network is bad\r\n        NETWORK = CableNetworkManager\r\n                .getOrRegisterNetworkFromManagerPosition(MANAGER)\r\n                .get();\r\n        assert MANAGER.getLevel() != null;\r\n        LEVEL = MANAGER.getLevel();\r\n        REDSTONE_PULSES = MANAGER.getUnprocessedRedstonePulseCount();\r\n        EXECUTION_POLICY = executionPolicy;\r\n        EXPLORATION_BRANCH_INDEX = branchIndex;\r\n    }\r\n\r\n    private ProgramContext(ProgramContext other) {\r\n        PROGRAM = other.PROGRAM;\r\n        MANAGER = other.MANAGER;\r\n        NETWORK = other.NETWORK;\r\n        LEVEL = other.LEVEL;\r\n        REDSTONE_PULSES = other.REDSTONE_PULSES;\r\n        EXECUTION_POLICY = other.EXECUTION_POLICY;\r\n        EXPLORATION_BRANCH_INDEX = other.EXPLORATION_BRANCH_INDEX;\r\n        INPUTS.addAll(other.INPUTS);\r\n    }\r\n\r\n    public ExecutionPolicy getExecutionPolicy() {\r\n        return EXECUTION_POLICY;\r\n    }\r\n\r\n    public List<Branch> getExecutionPath() {\r\n        return PATH_TAKEN;\r\n    }\r\n\r\n    public int getExplorationBranchIndex() {\r\n        return EXPLORATION_BRANCH_INDEX;\r\n    }\r\n\r\n    public Program getProgram() {\r\n        return PROGRAM;\r\n    }\r\n\r\n    public void pushPath(Branch branch) {\r\n        this.PATH_TAKEN.add(branch);\r\n    }\r\n\r\n    public ProgramContext copy() {\r\n        return new ProgramContext(this);\r\n    }\r\n\r\n    public int getRedstonePulses() {\r\n        return REDSTONE_PULSES;\r\n    }\r\n\r\n    public enum ExecutionPolicy {\r\n        EXPLORE_BRANCHES,\r\n        UNRESTRICTED\r\n    }\r\n\r\n    public ManagerBlockEntity getManager() {\r\n        return MANAGER;\r\n    }\r\n\r\n    public void addInput(InputStatement input) {\r\n        INPUTS.add(input);\r\n    }\r\n\r\n    public List<InputStatement> getInputs() {\r\n        return INPUTS;\r\n    }\r\n\r\n\r\n    public CableNetwork getNetwork() {\r\n        return NETWORK;\r\n    }\r\n\r\n    public record Branch(\r\n            IfStatement ifStatement,\r\n            boolean wasTrue\r\n    ) {\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\client\\jei\\FallingAnvilRecipe.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.client.jei;\r\n\r\npublic class FallingAnvilRecipe {\r\n\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\registry\\SFMRecipeSerializers.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.common.registry;\r\n\r\nimport ca.teamdman.sfm.SFM;\r\nimport ca.teamdman.sfm.common.recipe.DiskResetRecipe;\r\nimport ca.teamdman.sfm.common.recipe.PrintingPressRecipe;\r\nimport net.minecraft.world.item.crafting.RecipeSerializer;\r\nimport net.minecraft.world.item.crafting.SimpleRecipeSerializer;\r\nimport net.minecraftforge.eventbus.api.IEventBus;\r\nimport net.minecraftforge.registries.DeferredRegister;\r\nimport net.minecraftforge.registries.ForgeRegistries;\r\nimport net.minecraftforge.registries.RegistryObject;\r\n\r\npublic class SFMRecipeSerializers {\r\n    private static final DeferredRegister<RecipeSerializer<?>> RECIPE_SERIALIZERS = DeferredRegister.create(\r\n            ForgeRegistries.RECIPE_SERIALIZERS,\r\n            SFM.MOD_ID\r\n    );\r\n\r\n    public static final RegistryObject<RecipeSerializer<PrintingPressRecipe>> PRINTING_PRESS = RECIPE_SERIALIZERS.register(\r\n            \"printing_press\",\r\n            PrintingPressRecipe.Serializer::new\r\n    );\r\n\r\n    public static final RegistryObject<SimpleRecipeSerializer<DiskResetRecipe>> DISK_RESET = RECIPE_SERIALIZERS.register(\r\n            \"disk_reset\",\r\n            () -> new SimpleRecipeSerializer<>(DiskResetRecipe::new)\r\n    );\r\n\r\n    public static void register(IEventBus bus) {\r\n        RECIPE_SERIALIZERS.register(bus);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\capabilityprovidermapper\\BlockEntityCapabilityProviderMapper.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.common.capabilityprovidermapper;\r\n\r\nimport net.minecraft.core.BlockPos;\r\nimport net.minecraft.world.level.LevelAccessor;\r\nimport net.minecraftforge.common.capabilities.ICapabilityProvider;\r\n\r\nimport java.util.Optional;\r\n\r\npublic class BlockEntityCapabilityProviderMapper implements CapabilityProviderMapper {\r\n    @Override\r\n    public Optional<ICapabilityProvider> getProviderFor(LevelAccessor level, BlockPos pos) {\r\n        return Optional.ofNullable(level.getBlockEntity(pos));\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfml\\ast\\Side.java\r\n\r\n````java\r\npackage ca.teamdman.sfml.ast;\r\n\r\npublic enum Side implements ASTNode {\r\n    TOP,\r\n    BOTTOM,\r\n    NORTH,\r\n    SOUTH,\r\n    EAST,\r\n    WEST\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfml\\ast\\Trigger.java\r\n\r\n````java\r\npackage ca.teamdman.sfml.ast;\r\n\r\nimport ca.teamdman.sfm.common.program.ProgramContext;\r\n\r\nimport java.util.List;\r\n\r\npublic interface Trigger extends Statement {\r\n    boolean shouldTick(ProgramContext context);\r\n\r\n    Block getBlock();\r\n\r\n    @Override\r\n    default List<Statement> getStatements() {\r\n        return List.of(getBlock());\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\block\\ManagerBlock.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.common.block;\r\n\r\nimport ca.teamdman.sfm.common.blockentity.ManagerBlockEntity;\r\nimport ca.teamdman.sfm.common.cablenetwork.CableNetworkManager;\r\nimport ca.teamdman.sfm.common.cablenetwork.ICableBlock;\r\nimport ca.teamdman.sfm.common.containermenu.ManagerContainerMenu;\r\nimport ca.teamdman.sfm.common.registry.SFMBlockEntities;\r\nimport net.minecraft.core.BlockPos;\r\nimport net.minecraft.server.level.ServerLevel;\r\nimport net.minecraft.server.level.ServerPlayer;\r\nimport net.minecraft.world.Container;\r\nimport net.minecraft.world.Containers;\r\nimport net.minecraft.world.InteractionHand;\r\nimport net.minecraft.world.InteractionResult;\r\nimport net.minecraft.world.entity.player.Player;\r\nimport net.minecraft.world.level.Level;\r\nimport net.minecraft.world.level.block.*;\r\nimport net.minecraft.world.level.block.entity.BlockEntity;\r\nimport net.minecraft.world.level.block.entity.BlockEntityTicker;\r\nimport net.minecraft.world.level.block.entity.BlockEntityType;\r\nimport net.minecraft.world.level.block.state.BlockBehaviour;\r\nimport net.minecraft.world.level.block.state.BlockState;\r\nimport net.minecraft.world.level.block.state.StateDefinition;\r\nimport net.minecraft.world.level.block.state.properties.BlockStateProperties;\r\nimport net.minecraft.world.level.block.state.properties.BooleanProperty;\r\nimport net.minecraft.world.level.material.Material;\r\nimport net.minecraft.world.phys.BlockHitResult;\r\nimport net.minecraftforge.network.NetworkHooks;\r\n\r\nimport javax.annotation.Nullable;\r\n\r\npublic class ManagerBlock extends BaseEntityBlock implements EntityBlock, ICableBlock {\r\n    public static final BooleanProperty TRIGGERED = BlockStateProperties.TRIGGERED;\r\n\r\n    public ManagerBlock() {\r\n        super(BlockBehaviour.Properties\r\n                      .of(Material.PISTON)\r\n                      .destroyTime(2)\r\n                      .sound(SoundType.METAL));\r\n        registerDefaultState(getStateDefinition().any().setValue(TRIGGERED, false));\r\n    }\r\n\r\n    @Override\r\n    protected void createBlockStateDefinition(StateDefinition.Builder<Block, BlockState> builder) {\r\n        builder.add(TRIGGERED);\r\n    }\r\n\r\n    @SuppressWarnings(\"deprecation\")\r\n    public RenderShape getRenderShape(BlockState state) {\r\n        return RenderShape.MODEL;\r\n    }\r\n\r\n\r\n    @Override\r\n    @SuppressWarnings(\"deprecation\")\r\n    public void neighborChanged(\r\n            BlockState state,\r\n            Level level,\r\n            BlockPos pos,\r\n            Block block,\r\n            BlockPos neighbourPos,\r\n            boolean movedByPiston\r\n    ) {\r\n        if (!(level.getBlockEntity(pos) instanceof ManagerBlockEntity mgr)) return;\r\n        if (!(level instanceof ServerLevel)) return;\r\n        { // update cable network\r\n            // reassess neighbours of the CABLE's position\r\n            CableNetworkManager\r\n                    .getOrRegisterNetworkFromCablePosition(level, pos)\r\n                    .ifPresent(network -> network.rebuildAdjacentInventories(pos));\r\n        }\r\n        { // check redstone for triggers\r\n            var isPowered = level.hasNeighborSignal(pos) || level.hasNeighborSignal(pos.above());\r\n            var debounce  = state.getValue(TRIGGERED);\r\n            if (isPowered && !debounce) {\r\n                mgr.trackRedstonePulseUnprocessed();\r\n                level.setBlock(pos, state.setValue(TRIGGERED, true), 4);\r\n            } else if (!isPowered && debounce) {\r\n                level.setBlock(pos, state.setValue(TRIGGERED, false), 4);\r\n            }\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public BlockEntity newBlockEntity(BlockPos pos, BlockState state) {\r\n        return SFMBlockEntities.MANAGER_BLOCK_ENTITY\r\n                .get()\r\n                .create(pos, state);\r\n    }\r\n\r\n    @Override\r\n    @SuppressWarnings(\"deprecation\")\r\n    public InteractionResult use(\r\n            BlockState state,\r\n            Level level,\r\n            BlockPos pos,\r\n            Player player,\r\n            InteractionHand hand,\r\n            BlockHitResult hit\r\n    ) {\r\n        if (level.getBlockEntity(pos) instanceof ManagerBlockEntity manager && player instanceof ServerPlayer sp) {\r\n            NetworkHooks.openScreen(sp, manager, buf -> ManagerContainerMenu.encode(manager, buf));\r\n            return InteractionResult.CONSUME;\r\n        }\r\n        return InteractionResult.SUCCESS;\r\n    }\r\n\r\n    @Nullable\r\n    @Override\r\n    public <T extends BlockEntity> BlockEntityTicker<T> getTicker(\r\n            Level level,\r\n            BlockState state,\r\n            BlockEntityType<T> type\r\n    ) {\r\n        if (level.isClientSide()) return null;\r\n        return createTickerHelper(type, SFMBlockEntities.MANAGER_BLOCK_ENTITY.get(), ManagerBlockEntity::serverTick);\r\n    }\r\n\r\n    @Override\r\n    @SuppressWarnings(\"deprecation\")\r\n    public void onPlace(BlockState state, Level world, BlockPos pos, BlockState oldState, boolean isMoving) {\r\n        CableNetworkManager.getOrRegisterNetworkFromCablePosition(world, pos);\r\n    }\r\n\r\n    @Override\r\n    @SuppressWarnings(\"deprecation\")\r\n    public void onRemove(BlockState state, Level level, BlockPos pos, BlockState newState, boolean isMoving) {\r\n        if (!state.is(newState.getBlock())) {\r\n            if (level.getBlockEntity(pos) instanceof Container container) {\r\n                Containers.dropContents(level, pos, container);\r\n                level.updateNeighbourForOutputSignal(pos, this);\r\n            }\r\n            CableNetworkManager.removeCable(level, pos);\r\n            super.onRemove(state, level, pos, newState, isMoving);\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\recipe\\NotContainer.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.common.recipe;\r\n\r\nimport net.minecraft.world.Container;\r\nimport net.minecraft.world.entity.player.Player;\r\nimport net.minecraft.world.item.Item;\r\nimport net.minecraft.world.item.ItemStack;\r\n\r\nimport java.util.Set;\r\nimport java.util.function.Predicate;\r\n\r\n/**\r\n * Recipe stuff wants your block entities to be Containers to do stuff.\r\n * I don't want to use a Container when the block has no GUI.\r\n * This is a hack to make the recipe stuff happy.\r\n */\r\n@SuppressWarnings(\"RedundantMethodOverride\")\r\npublic interface NotContainer extends Container {\r\n\r\n    @Override\r\n    default void clearContent() {\r\n    }\r\n\r\n    @Override\r\n    default int getContainerSize() {\r\n        return 0;\r\n    }\r\n\r\n    @Override\r\n    default boolean isEmpty() {\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    default ItemStack getItem(int pSlot) {\r\n        return ItemStack.EMPTY;\r\n    }\r\n\r\n    @Override\r\n    default ItemStack removeItem(int pSlot, int pAmount) {\r\n        return ItemStack.EMPTY;\r\n\r\n    }\r\n\r\n    @Override\r\n    default ItemStack removeItemNoUpdate(int pSlot) {\r\n        return ItemStack.EMPTY;\r\n    }\r\n\r\n    @Override\r\n    default void setItem(int pSlot, ItemStack pStack) {\r\n    }\r\n\r\n    @Override\r\n    default int getMaxStackSize() {\r\n        return 0;\r\n    }\r\n\r\n    @Override\r\n    default void setChanged() {\r\n    }\r\n\r\n    @Override\r\n    default boolean stillValid(Player pPlayer) {\r\n        return false;\r\n    }\r\n\r\n    @Override\r\n    default void startOpen(Player pPlayer) {\r\n    }\r\n\r\n    @Override\r\n    default void stopOpen(Player pPlayer) {\r\n    }\r\n\r\n    @Override\r\n    default boolean canPlaceItem(int pIndex, ItemStack pStack) {\r\n        return false;\r\n    }\r\n\r\n    @Override\r\n    default int countItem(Item pItem) {\r\n        return 0;\r\n    }\r\n\r\n    @Override\r\n    default boolean hasAnyOf(Set<Item> pSet) {\r\n        return false;\r\n    }\r\n\r\n    @Override\r\n    default boolean hasAnyMatching(Predicate<ItemStack> p_216875_) {\r\n        return false;\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\cablenetwork\\CableNetworkManager.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.common.cablenetwork;\r\n\r\nimport ca.teamdman.sfm.SFM;\r\nimport ca.teamdman.sfm.common.blockentity.ManagerBlockEntity;\r\nimport net.minecraft.core.BlockPos;\r\nimport net.minecraft.world.level.Level;\r\nimport net.minecraftforge.fml.common.Mod;\r\n\r\nimport javax.annotation.Nullable;\r\nimport java.util.*;\r\nimport java.util.stream.Collectors;\r\nimport java.util.stream.Stream;\r\n\r\n/**\r\n * Helper class to memorize the relevant chains of inventory cables.\r\n * <p>\r\n * Rather than looking up the connected cable blocks for each manager each tick,\r\n * this class aims to keep track of the chains instead.\r\n * Adding or removing cable blocks that invoke the relevant methods for this class\r\n * will help build the network.\r\n * <p>\r\n * Adding cables can do one of:\r\n * - append to existing network\r\n * - cause two existing networks to join\r\n * - create a new network\r\n * <p>\r\n * Removing cables can:\r\n * - Remove it from the network\r\n * - Remove the network if it was the only member\r\n * - Cause a network to split into other networks if it was a \"bridge\" block\r\n */\r\n@Mod.EventBusSubscriber(bus = Mod.EventBusSubscriber.Bus.FORGE, modid = SFM.MOD_ID)\r\npublic class CableNetworkManager {\r\n\r\n    private static final Map<Level, List<CableNetwork>> NETWORKS = new WeakHashMap<>();\r\n\r\n    /**\r\n     * Remove a block from any networks it is in. Then, prune any empty networks.\r\n     */\r\n    public static void removeCable(Level level, BlockPos cablePos) {\r\n        getNetworkFromCablePosition(level, cablePos).ifPresent(network -> {\r\n            removeNetwork(network);\r\n            var newNetworks = network.withoutCable(cablePos);\r\n            newNetworks.forEach(CableNetworkManager::addNetwork);\r\n        });\r\n    }\r\n\r\n    public static Optional<CableNetwork> getOrRegisterNetworkFromManagerPosition(ManagerBlockEntity tile) {\r\n        return getOrRegisterNetworkFromCablePosition(tile.getLevel(), tile.getBlockPos());\r\n    }\r\n\r\n    public static Optional<CableNetwork> getNetworkFromPosition(Level level, BlockPos pos) {\r\n        return getNetworksForLevel(level)\r\n                .filter(net -> net.CABLE_POSITIONS.contains(pos.asLong())\r\n                               || net.CAPABILITY_PROVIDER_BY_POSITION.containsKey(pos.asLong()))\r\n                .findFirst();\r\n    }\r\n\r\n    public static Stream<CableNetwork> getNetworksForLevel(Level level) {\r\n        return NETWORKS.getOrDefault(level, Collections.emptyList())\r\n                .stream()\r\n                .filter(net -> net.getLevel().isClientSide() == level.isClientSide());\r\n    }\r\n\r\n    private static Optional<CableNetwork> getNetworkFromCablePosition(Level level, BlockPos pos) {\r\n        return getNetworksForLevel(level)\r\n                .filter(net -> net.containsCablePosition(pos))\r\n                .findFirst();\r\n    }\r\n\r\n    private static void removeNetwork(CableNetwork network) {\r\n        NETWORKS.getOrDefault(network.getLevel(), Collections.emptyList()).remove(network);\r\n    }\r\n\r\n    private static void addNetwork(CableNetwork network) {\r\n        NETWORKS.computeIfAbsent(network.getLevel(), k -> new ArrayList<>()).add(network);\r\n    }\r\n\r\n    /**\r\n     * Finds the set of networks that contain the given position\r\n     */\r\n    private static Set<CableNetwork> getCandidateNetworks(Level level, BlockPos pos) {\r\n        return getNetworksForLevel(level)\r\n                .filter(net -> net.isAdjacentToCable(pos))\r\n                .collect(Collectors.toSet());\r\n    }\r\n\r\n\r\n    private static Optional<CableNetwork> mergeNetworks(Set<CableNetwork> networks) {\r\n        if (networks.isEmpty()) return Optional.empty();\r\n\r\n        Iterator<CableNetwork> iterator = networks.iterator();\r\n        CableNetwork main = iterator.next();\r\n\r\n        // Merge the rest into the first\r\n        iterator.forEachRemaining(other -> {\r\n            main.mergeNetwork(other);\r\n            removeNetwork(other);\r\n        });\r\n\r\n        return Optional.of(main);\r\n    }\r\n\r\n    public static void unregisterNetworkForTestingPurposes(CableNetwork network) {\r\n        removeNetwork(network);\r\n    }\r\n\r\n    /**\r\n     * Gets the cable network object. If none exists and one should, it will create and populate\r\n     * one.\r\n     * <p>\r\n     * Networks should only exist on the server side.\r\n     */\r\n    public static Optional<CableNetwork> getOrRegisterNetworkFromCablePosition(@Nullable Level level, BlockPos pos) {\r\n        if (level == null) return Optional.empty();\r\n        if (level.isClientSide()) return Optional.empty();\r\n\r\n        // only cables define the main spine of a network\r\n        if (!CableNetwork.isCable(level, pos)) return Optional.empty();\r\n\r\n        // discover existing network for this position\r\n        Optional<CableNetwork> existing = getNetworkFromCablePosition(level, pos);\r\n        if (existing.isPresent()) return existing;\r\n\r\n        // find potential networks\r\n        Set<CableNetwork> candidates = getCandidateNetworks(level, pos);\r\n\r\n        // no candidates, create new network\r\n        if (candidates.isEmpty()) {\r\n            CableNetwork network = new CableNetwork(level);\r\n            addNetwork(network);\r\n            // rebuild network from world\r\n            // might be first time used after loading from disk\r\n            network.rebuildNetwork(pos);\r\n            return Optional.of(network);\r\n        }\r\n\r\n        // one candidate exists, add the cable to it\r\n        if (candidates.size() == 1) {\r\n            // Only one network matches this cable, add cable as member\r\n            CableNetwork network = candidates.iterator().next();\r\n            network.addCable(pos);\r\n            return Optional.of(network);\r\n        }\r\n\r\n        // more than one candidate network exists, merge them\r\n        Optional<CableNetwork> result = mergeNetworks(candidates);\r\n        result.ifPresent(net -> net.addCable(pos));\r\n        return result;\r\n    }\r\n\r\n\r\n    public static List<BlockPos> getBadCableCachePositions(Level level) {\r\n        return getNetworksForLevel(level)\r\n                .flatMap(CableNetwork::getCablePositions)\r\n                .filter(pos -> !(level.getBlockState(pos).getBlock() instanceof ICableBlock))\r\n                .collect(Collectors.toList());\r\n    }\r\n\r\n    public static void clear() {\r\n        NETWORKS.clear();\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\resourcetype\\PigmentResourceType.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.common.resourcetype;\r\n\r\nimport mekanism.api.Action;\r\nimport mekanism.api.MekanismAPI;\r\nimport mekanism.api.chemical.pigment.IPigmentHandler;\r\nimport mekanism.api.chemical.pigment.Pigment;\r\nimport mekanism.api.chemical.pigment.PigmentStack;\r\nimport net.minecraftforge.common.capabilities.Capability;\r\nimport net.minecraftforge.common.capabilities.CapabilityToken;\r\nimport net.minecraftforge.registries.IForgeRegistry;\r\n\r\nimport static net.minecraftforge.common.capabilities.CapabilityManager.get;\r\n\r\npublic class PigmentResourceType extends ResourceType<PigmentStack, Pigment, IPigmentHandler> {\r\n    public static final Capability<IPigmentHandler> CAP = get(new CapabilityToken<>() {\r\n    });\r\n\r\n    public PigmentResourceType() {\r\n        super(CAP);\r\n    }\r\n\r\n    @Override\r\n    public long getAmount(PigmentStack stack) {\r\n        return stack.getAmount();\r\n    }\r\n\r\n    @Override\r\n    public PigmentStack getStackInSlot(IPigmentHandler handler, int slot) {\r\n        return handler.getChemicalInTank(slot);\r\n    }\r\n\r\n    @Override\r\n    public PigmentStack extract(IPigmentHandler handler, int slot, long amount, boolean simulate) {\r\n        return handler.extractChemical(slot, amount, simulate ? Action.SIMULATE : Action.EXECUTE);\r\n    }\r\n\r\n    @Override\r\n    public int getSlots(IPigmentHandler handler) {\r\n        return handler.getTanks();\r\n    }\r\n\r\n    @Override\r\n    public long getMaxStackSize(PigmentStack stack) {\r\n        return Long.MAX_VALUE;\r\n    }\r\n\r\n    @Override\r\n    public long getMaxStackSize(IPigmentHandler handler, int slot) {\r\n        return handler.getTankCapacity(slot);\r\n    }\r\n\r\n    @Override\r\n    public PigmentStack insert(\r\n            IPigmentHandler handler,\r\n            int slot,\r\n            PigmentStack stack,\r\n            boolean simulate\r\n    ) {\r\n        return handler.insertChemical(slot, stack, simulate ? Action.SIMULATE : Action.EXECUTE);\r\n    }\r\n\r\n    @Override\r\n    public boolean isEmpty(PigmentStack stack) {\r\n        return stack.isEmpty();\r\n    }\r\n\r\n    @Override\r\n    public PigmentStack getEmptyStack() {\r\n        return PigmentStack.EMPTY;\r\n    }\r\n\r\n    @Override\r\n    public boolean matchesStackType(Object o) {\r\n        return o instanceof PigmentStack;\r\n    }\r\n\r\n    @Override\r\n    public boolean matchesCapabilityType(Object o) {\r\n        return o instanceof IPigmentHandler;\r\n    }\r\n\r\n\r\n    @Override\r\n    public IForgeRegistry<Pigment> getRegistry() {\r\n        return MekanismAPI.pigmentRegistry();\r\n    }\r\n\r\n    @Override\r\n    public Pigment getItem(PigmentStack stack) {\r\n        return stack.getType();\r\n    }\r\n\r\n    @Override\r\n    public PigmentStack copy(PigmentStack stack) {\r\n        return stack.copy();\r\n    }\r\n\r\n    @Override\r\n    protected PigmentStack setCount(PigmentStack stack, long amount) {\r\n        stack.setAmount(amount);\r\n        return stack;\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\program\\LimitedInputSlotObjectPool.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.common.program;\r\n\r\nimport java.util.Arrays;\r\nimport java.util.List;\r\n\r\n/**\r\n * A pool of {@link LimitedInputSlot} objects to avoid the garbage collector\r\n * <p>\r\n * This assumes that the pool will be used in a single thread.\r\n */\r\npublic class LimitedInputSlotObjectPool {\r\n    @SuppressWarnings(\"rawtypes\")\r\n    private LimitedInputSlot[] pool = new LimitedInputSlot[1];\r\n    private int index = -1;\r\n\r\n    /**\r\n     * Acquire a {@link LimitedInputSlot} from the pool, or creates a new one if none available\r\n     */\r\n    public <STACK, ITEM, CAP> LimitedInputSlot<STACK, ITEM, CAP> acquire(\r\n            CAP handler,\r\n            int slot,\r\n            InputResourceTracker<STACK, ITEM, CAP> tracker\r\n    ) {\r\n        if (index == -1) {\r\n            return new LimitedInputSlot<>(handler, slot, tracker);\r\n        } else {\r\n            @SuppressWarnings(\"unchecked\") LimitedInputSlot<STACK, ITEM, CAP> obj = pool[index];\r\n            index--;\r\n            obj.init(handler, slot, tracker);\r\n            return obj;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Release a {@link LimitedInputSlot} back into the pool for it to be reused instead of garbage collected\r\n     */\r\n    public void release(LimitedInputSlot<?, ?, ?> obj) {\r\n        if (index == pool.length - 1) {\r\n            // we need to grow the array\r\n            pool = Arrays.copyOf(pool, pool.length * 2);\r\n        }\r\n        pool[++index] = obj;\r\n    }\r\n\r\n    /**\r\n     * Release a {@link LimitedInputSlot} back into the pool for it to be reused instead of garbage collected\r\n     */\r\n    @SuppressWarnings(\"rawtypes\")\r\n    public void release(List<LimitedInputSlot> slots) {\r\n        // handle resizing\r\n        if (index + slots.size() >= pool.length) {\r\n            int slotsFree = pool.length - index - 1;\r\n            int newLength = pool.length + slots.size() - slotsFree;\r\n            pool = Arrays.copyOf(pool, newLength);\r\n        }\r\n        // add to pool\r\n        for (LimitedInputSlot slot : slots) {\r\n            index++;\r\n            pool[index] = slot;\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\net\\ServerboundManagerProgramPacket.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.common.net;\r\n\r\nimport ca.teamdman.sfm.common.blockentity.ManagerBlockEntity;\r\nimport ca.teamdman.sfm.common.containermenu.ManagerContainerMenu;\r\nimport ca.teamdman.sfm.common.registry.SFMPackets;\r\nimport ca.teamdman.sfml.ast.Program;\r\nimport net.minecraft.core.BlockPos;\r\nimport net.minecraft.network.FriendlyByteBuf;\r\nimport net.minecraftforge.network.NetworkEvent;\r\n\r\nimport java.util.function.Supplier;\r\n\r\npublic record ServerboundManagerProgramPacket(\r\n        int windowId,\r\n        BlockPos pos,\r\n        String program\r\n) {\r\n\r\n    public static void encode(ServerboundManagerProgramPacket msg, FriendlyByteBuf friendlyByteBuf) {\r\n        friendlyByteBuf.writeVarInt(msg.windowId());\r\n        friendlyByteBuf.writeBlockPos(msg.pos());\r\n        friendlyByteBuf.writeUtf(msg.program(), Program.MAX_PROGRAM_LENGTH);\r\n    }\r\n\r\n    public static ServerboundManagerProgramPacket decode(FriendlyByteBuf friendlyByteBuf) {\r\n        return new ServerboundManagerProgramPacket(\r\n                friendlyByteBuf.readVarInt(),\r\n                friendlyByteBuf.readBlockPos(),\r\n                friendlyByteBuf.readUtf(Program.MAX_PROGRAM_LENGTH)\r\n        );\r\n    }\r\n\r\n    public static void handle(ServerboundManagerProgramPacket msg, Supplier<NetworkEvent.Context> contextSupplier) {\r\n        SFMPackets.handleServerboundContainerPacket(\r\n                contextSupplier,\r\n                ManagerContainerMenu.class,\r\n                ManagerBlockEntity.class,\r\n                msg.pos,\r\n                msg.windowId,\r\n                (menu, manager) -> manager.setProgram(msg.program())\r\n        );\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\net\\ServerboundDiskItemSetProgramPacket.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.common.net;\r\n\r\nimport ca.teamdman.sfm.common.item.DiskItem;\r\nimport ca.teamdman.sfml.ast.Program;\r\nimport net.minecraft.network.FriendlyByteBuf;\r\nimport net.minecraft.world.InteractionHand;\r\nimport net.minecraftforge.network.NetworkEvent;\r\n\r\nimport java.util.function.Supplier;\r\n\r\npublic record ServerboundDiskItemSetProgramPacket(\r\n        String programString,\r\n        InteractionHand hand\r\n) {\r\n\r\n    public static void encode(ServerboundDiskItemSetProgramPacket msg, FriendlyByteBuf buf) {\r\n        buf.writeUtf(msg.programString, Program.MAX_PROGRAM_LENGTH);\r\n        buf.writeEnum(msg.hand);\r\n    }\r\n\r\n    public static ServerboundDiskItemSetProgramPacket decode(\r\n            FriendlyByteBuf buf\r\n    ) {\r\n        return new ServerboundDiskItemSetProgramPacket(\r\n                buf.readUtf(Program.MAX_PROGRAM_LENGTH),\r\n                buf.readEnum(InteractionHand.class)\r\n        );\r\n    }\r\n\r\n    public static void handle(\r\n            ServerboundDiskItemSetProgramPacket msg, Supplier<NetworkEvent.Context> ctx\r\n    ) {\r\n        ctx.get().enqueueWork(() -> {\r\n            var sender = ctx.get().getSender();\r\n            if (sender == null) {\r\n                return;\r\n            }\r\n            var stack = sender.getItemInHand(msg.hand);\r\n            if (stack.getItem() instanceof DiskItem) {\r\n                DiskItem.setProgram(stack, msg.programString);\r\n                DiskItem.updateDetails(stack, null);\r\n            }\r\n\r\n        });\r\n        ctx.get().setPacketHandled(true);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfml\\ast\\Number.java\r\n\r\n````java\r\npackage ca.teamdman.sfml.ast;\r\n\r\npublic record Number(long value) implements ASTNode {\r\n    @Override\r\n    public String toString() {\r\n        return String.valueOf(value);\r\n    }\r\n\r\n    public Number add(Number number) {\r\n        return new Number(value + number.value);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\block\\package-info.java\r\n\r\n````java\r\n\r\n@ParametersAreNonnullByDefault\r\n@MethodsReturnNonnullByDefault\r\n@FieldsAreNonnullByDefault\r\npackage ca.teamdman.sfm.common.block;\r\n\r\nimport net.minecraft.FieldsAreNonnullByDefault;\r\nimport net.minecraft.MethodsReturnNonnullByDefault;\r\n\r\nimport javax.annotation.ParametersAreNonnullByDefault;\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\net\\ServerboundManagerResetPacket.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.common.net;\r\n\r\nimport ca.teamdman.sfm.common.blockentity.ManagerBlockEntity;\r\nimport ca.teamdman.sfm.common.containermenu.ManagerContainerMenu;\r\nimport ca.teamdman.sfm.common.registry.SFMPackets;\r\nimport net.minecraft.core.BlockPos;\r\nimport net.minecraft.network.FriendlyByteBuf;\r\nimport net.minecraftforge.network.NetworkEvent;\r\n\r\nimport java.util.function.Supplier;\r\n\r\npublic record ServerboundManagerResetPacket(\r\n        int windowId,\r\n        BlockPos pos\r\n) {\r\n    public static void encode(ServerboundManagerResetPacket msg, FriendlyByteBuf friendlyByteBuf) {\r\n        friendlyByteBuf.writeVarInt(msg.windowId());\r\n        friendlyByteBuf.writeBlockPos(msg.pos());\r\n    }\r\n\r\n    public static ServerboundManagerResetPacket decode(FriendlyByteBuf friendlyByteBuf) {\r\n        return new ServerboundManagerResetPacket(\r\n                friendlyByteBuf.readVarInt(),\r\n                friendlyByteBuf.readBlockPos()\r\n        );\r\n    }\r\n\r\n    public static void handle(ServerboundManagerResetPacket msg, Supplier<NetworkEvent.Context> contextSupplier) {\r\n        SFMPackets.handleServerboundContainerPacket(\r\n                contextSupplier,\r\n                ManagerContainerMenu.class,\r\n                ManagerBlockEntity.class,\r\n                msg.pos,\r\n                msg.windowId,\r\n                (menu, manager) -> manager.reset()\r\n        );\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\client\\render\\FormItemRenderer.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.client.render;\r\n\r\nimport ca.teamdman.sfm.SFM;\r\nimport ca.teamdman.sfm.client.ClientStuff;\r\nimport ca.teamdman.sfm.common.item.FormItem;\r\nimport com.mojang.blaze3d.vertex.PoseStack;\r\nimport net.minecraft.client.Minecraft;\r\nimport net.minecraft.client.renderer.BlockEntityWithoutLevelRenderer;\r\nimport net.minecraft.client.renderer.ItemBlockRenderTypes;\r\nimport net.minecraft.client.renderer.MultiBufferSource;\r\nimport net.minecraft.client.renderer.block.model.ItemTransforms;\r\nimport net.minecraft.client.renderer.entity.ItemRenderer;\r\nimport net.minecraft.resources.ResourceLocation;\r\nimport net.minecraft.world.item.ItemStack;\r\nimport net.minecraftforge.api.distmarker.Dist;\r\nimport net.minecraftforge.client.event.ModelEvent;\r\nimport net.minecraftforge.eventbus.api.SubscribeEvent;\r\nimport net.minecraftforge.fml.common.Mod;\r\n\r\n@Mod.EventBusSubscriber(bus = Mod.EventBusSubscriber.Bus.MOD, modid = SFM.MOD_ID, value = Dist.CLIENT)\r\npublic class FormItemRenderer extends BlockEntityWithoutLevelRenderer {\r\n\r\n    private static final ResourceLocation BASE_MODEL = new ResourceLocation(SFM.MOD_ID, \"item/form_base\");\r\n\r\n    public FormItemRenderer() {\r\n        super(Minecraft.getInstance().getBlockEntityRenderDispatcher(), Minecraft.getInstance().getEntityModels());\r\n    }\r\n\r\n    @SubscribeEvent\r\n    public static void registerModels(ModelEvent.RegisterAdditional event) {\r\n        event.register(BASE_MODEL);\r\n    }\r\n\r\n    // Thanks Shadows\r\n    // https://github.com/Shadows-of-Fire/Hostile-Neural-Networks/blob/1.18/src/main/java/shadows/hostilenetworks/client/DataModelItemStackRenderer.java#L71\r\n    // https://discord.com/channels/313125603924639766/915304642668290119/1029330876208795758\r\n    @Override\r\n    public void renderByItem(\r\n            ItemStack stack,\r\n            ItemTransforms.TransformType transformType,\r\n            PoseStack poseStack,\r\n            MultiBufferSource multiBuffer,\r\n            int packedLight,\r\n            int packedOverlay\r\n    ) {\r\n        if (!(stack.getItem() instanceof FormItem)) return;\r\n        var renderer = Minecraft.getInstance().getItemRenderer();\r\n        var baseModel = renderer.getItemModelShaper().getModelManager().getModel(BASE_MODEL);\r\n        @SuppressWarnings(\"deprecation\")\r\n        var renderType = ItemBlockRenderTypes.getRenderType(stack, true);\r\n        var buffer = ItemRenderer.getFoilBufferDirect(multiBuffer, renderType, true, stack.hasFoil());\r\n        poseStack.pushPose();\r\n\r\n        if (transformType != ItemTransforms.TransformType.FIXED && transformType != ItemTransforms.TransformType.GUI) {\r\n            poseStack.scale(0.5F, 0.5F, 1F);\r\n            poseStack.translate(0.5, 0.5, 0);\r\n//            poseStack.mulPose(Vector3f.YP.rotationDegrees(-65));\r\n        }\r\n\r\n        if (ClientStuff.isMoreInfoKeyDown()) {\r\n            poseStack.pushPose();\r\n            poseStack.translate(0, 0.5f, 0.3f);\r\n            poseStack.scale(0.5f, 0.5f, 0.5f);\r\n            renderer.renderModelLists(baseModel, stack, packedLight, packedOverlay, poseStack, buffer);\r\n            poseStack.popPose();\r\n\r\n            var reference = FormItem.getReference(stack);\r\n            if (!reference.isEmpty()) {\r\n                var model = renderer.getItemModelShaper().getItemModel(reference.getItem());\r\n                if (model != null) {\r\n                    renderer.renderModelLists(model, stack, packedLight, packedOverlay, poseStack, buffer);\r\n                }\r\n            }\r\n        } else {\r\n            renderer.renderModelLists(baseModel, stack, packedLight, packedOverlay, poseStack, buffer);\r\n        }\r\n\r\n        poseStack.popPose();\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\program\\LimitedInputSlot.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.common.program;\r\n\r\nimport ca.teamdman.sfm.common.resourcetype.ResourceType;\r\n\r\nimport javax.annotation.Nullable;\r\n\r\npublic class LimitedInputSlot<STACK, ITEM, CAP> {\r\n\r\n    @SuppressWarnings(\"NotNullFieldNotInitialized\")\r\n    public ResourceType<STACK, ITEM, CAP> type;\r\n    @SuppressWarnings(\"NotNullFieldNotInitialized\")\r\n    public CAP handler;\r\n    public int slot;\r\n    @SuppressWarnings(\"NotNullFieldNotInitialized\")\r\n    public InputResourceTracker<STACK, ITEM, CAP> tracker;\r\n    private boolean done = false;\r\n    private @Nullable STACK extractSimulateCache = null;\r\n\r\n    public LimitedInputSlot(\r\n            CAP handler, int slot, InputResourceTracker<STACK, ITEM, CAP> tracker\r\n    ) {\r\n        this.init(handler, slot, tracker);\r\n    }\r\n\r\n    public boolean isDone() {\r\n        if (done) return true;\r\n        // we don't bother setting done because if this returns true it should be the last time this is called\r\n        if (tracker.isDone()) {\r\n            return true;\r\n        }\r\n        STACK stack = peekExtractPotential();\r\n        if (type.isEmpty(stack)) {\r\n            return true;\r\n        }\r\n        return !tracker.test(stack);\r\n    }\r\n\r\n    public void setDone() {\r\n        this.done = true;\r\n    }\r\n\r\n    public STACK extract(long amount) {\r\n        extractSimulateCache = null;\r\n        return type.extract(handler, slot, amount, false);\r\n    }\r\n\r\n    /**\r\n     * Checks how much could possibly be extracted from this slot.\r\n     * We need to simulate since there are some types of slots we can't undo an extract from.\r\n     * You can't put something back in the output slot of a furnace.\r\n     * This value is cached for performance.\r\n     */\r\n    public STACK peekExtractPotential() {\r\n        if (extractSimulateCache == null) {\r\n            extractSimulateCache = type.extract(handler, slot, Long.MAX_VALUE, true);\r\n        }\r\n        return extractSimulateCache;\r\n    }\r\n\r\n    public void init(CAP handler, int slot, InputResourceTracker<STACK, ITEM, CAP> tracker) {\r\n        this.done = false;\r\n        this.extractSimulateCache = null;\r\n        this.handler = handler;\r\n        this.tracker = tracker;\r\n        this.slot = slot;\r\n        //noinspection DataFlowIssue\r\n        this.type = tracker.getResourceLimit().resourceId().getResourceType();\r\n        assert type != null;\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\resourcetype\\SlurryResourceType.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.common.resourcetype;\r\n\r\nimport mekanism.api.Action;\r\nimport mekanism.api.MekanismAPI;\r\nimport mekanism.api.chemical.slurry.ISlurryHandler;\r\nimport mekanism.api.chemical.slurry.Slurry;\r\nimport mekanism.api.chemical.slurry.SlurryStack;\r\nimport net.minecraftforge.common.capabilities.Capability;\r\nimport net.minecraftforge.common.capabilities.CapabilityToken;\r\nimport net.minecraftforge.registries.IForgeRegistry;\r\n\r\nimport static net.minecraftforge.common.capabilities.CapabilityManager.get;\r\n\r\npublic class SlurryResourceType extends ResourceType<SlurryStack, Slurry, ISlurryHandler> {\r\n    public static final Capability<ISlurryHandler> CAP = get(new CapabilityToken<>() {\r\n    });\r\n\r\n    public SlurryResourceType() {\r\n        super(CAP);\r\n    }\r\n\r\n    @Override\r\n    public long getAmount(SlurryStack stack) {\r\n        return stack.getAmount();\r\n    }\r\n\r\n    @Override\r\n    public SlurryStack getStackInSlot(ISlurryHandler handler, int slot) {\r\n        return handler.getChemicalInTank(slot);\r\n    }\r\n\r\n    @Override\r\n    public SlurryStack extract(ISlurryHandler handler, int slot, long amount, boolean simulate) {\r\n        return handler.extractChemical(slot, amount, simulate ? Action.SIMULATE : Action.EXECUTE);\r\n    }\r\n\r\n    @Override\r\n    public int getSlots(ISlurryHandler handler) {\r\n        return handler.getTanks();\r\n    }\r\n\r\n    @Override\r\n    public long getMaxStackSize(SlurryStack stack) {\r\n        return Long.MAX_VALUE;\r\n    }\r\n\r\n    @Override\r\n    public long getMaxStackSize(ISlurryHandler handler, int slot) {\r\n        return handler.getTankCapacity(slot);\r\n    }\r\n\r\n    @Override\r\n    public SlurryStack insert(\r\n            ISlurryHandler handler,\r\n            int slot,\r\n            SlurryStack stack,\r\n            boolean simulate\r\n    ) {\r\n        return handler.insertChemical(slot, stack, simulate ? Action.SIMULATE : Action.EXECUTE);\r\n    }\r\n\r\n    @Override\r\n    public boolean isEmpty(SlurryStack stack) {\r\n        return stack.isEmpty();\r\n    }\r\n\r\n    @Override\r\n    public SlurryStack getEmptyStack() {\r\n        return SlurryStack.EMPTY;\r\n    }\r\n\r\n    @Override\r\n    public boolean matchesStackType(Object o) {\r\n        return o instanceof SlurryStack;\r\n    }\r\n\r\n    @Override\r\n    public boolean matchesCapabilityType(Object o) {\r\n        return o instanceof ISlurryHandler;\r\n    }\r\n\r\n\r\n    @Override\r\n    public IForgeRegistry<Slurry> getRegistry() {\r\n        return MekanismAPI.slurryRegistry();\r\n    }\r\n\r\n    @Override\r\n    public Slurry getItem(SlurryStack stack) {\r\n        return stack.getType();\r\n    }\r\n\r\n    @Override\r\n    public SlurryStack copy(SlurryStack stack) {\r\n        return stack.copy();\r\n    }\r\n\r\n    @Override\r\n    protected SlurryStack setCount(SlurryStack stack, long amount) {\r\n        stack.setAmount(amount);\r\n        return stack;\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\net\\ServerboundNetworkToolUsePacket.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.common.net;\r\n\r\nimport ca.teamdman.sfm.common.cablenetwork.CableNetworkManager;\r\nimport ca.teamdman.sfm.common.compat.SFMCompat;\r\nimport ca.teamdman.sfm.common.registry.SFMPackets;\r\nimport ca.teamdman.sfm.common.registry.SFMResourceTypes;\r\nimport ca.teamdman.sfm.common.util.SFMUtils;\r\nimport ca.teamdman.sfml.ast.DirectionQualifier;\r\nimport net.minecraft.core.BlockPos;\r\nimport net.minecraft.core.Direction;\r\nimport net.minecraft.network.FriendlyByteBuf;\r\nimport net.minecraft.resources.ResourceKey;\r\nimport net.minecraft.server.level.ServerPlayer;\r\nimport net.minecraft.world.level.Level;\r\nimport net.minecraft.world.level.block.entity.BlockEntity;\r\nimport net.minecraft.world.level.block.state.BlockState;\r\nimport net.minecraftforge.fml.loading.FMLEnvironment;\r\nimport net.minecraftforge.network.NetworkEvent;\r\nimport net.minecraftforge.network.PacketDistributor;\r\n\r\nimport java.util.function.Supplier;\r\nimport java.util.stream.Collectors;\r\n\r\npublic record ServerboundNetworkToolUsePacket(\r\n        BlockPos blockPosition,\r\n        Direction blockFace\r\n) {\r\n    public static void encode(ServerboundNetworkToolUsePacket msg, FriendlyByteBuf friendlyByteBuf) {\r\n        friendlyByteBuf.writeBlockPos(msg.blockPosition);\r\n        friendlyByteBuf.writeEnum(msg.blockFace);\r\n    }\r\n\r\n    public static ServerboundNetworkToolUsePacket decode(FriendlyByteBuf friendlyByteBuf) {\r\n        return new ServerboundNetworkToolUsePacket(\r\n                friendlyByteBuf.readBlockPos(),\r\n                friendlyByteBuf.readEnum(Direction.class)\r\n        );\r\n    }\r\n\r\n    public static void handle(\r\n            ServerboundNetworkToolUsePacket msg, Supplier<NetworkEvent.Context> contextSupplier\r\n    ) {\r\n        contextSupplier.get().enqueueWork(() -> {\r\n            // we don't know if the player has the program edit screen open from a manager or a disk in hand\r\n            ServerPlayer player = contextSupplier.get().getSender();\r\n            if (player == null) return;\r\n            Level level = player.getLevel();\r\n            BlockPos pos = msg.blockPosition();\r\n            if (!level.isLoaded(pos)) return;\r\n            StringBuilder payload = new StringBuilder()\r\n                    .append(\"---- block position ----\\n\")\r\n                    .append(pos)\r\n                    .append(\"\\n---- block state ----\\n\");\r\n            BlockState state = level.getBlockState(pos);\r\n            payload.append(state).append(\"\\n\");\r\n\r\n            CableNetworkManager.getNetworkFromPosition(level, pos).ifPresent(net -> {\r\n                payload.append(\"---- cable network ----\\n\");\r\n                payload.append(net).append(\"\\n\");\r\n            });\r\n\r\n            BlockEntity entity = level.getBlockEntity(pos);\r\n            if (entity != null) {\r\n                if (!FMLEnvironment.production) {\r\n                    payload.append(\"---- (dev only) block entity ----\\n\");\r\n                    payload.append(entity).append(\"\\n\");\r\n                }\r\n                payload.append(\"---- capability directions ----\\n\");\r\n                for (var cap : SFMCompat.getCapabilities()) {\r\n                    payload\r\n                            .append(cap.getName())\r\n                            .append(\": \");\r\n                    String directions = DirectionQualifier.EVERY_DIRECTION\r\n                            .stream()\r\n                            .filter(dir -> entity.getCapability(cap, dir).isPresent())\r\n                            .map(dir -> dir == null ? \"NULL DIRECTION\" : DirectionQualifier.directionToString(dir))\r\n                            .collect(Collectors.joining(\", \", \"[\", \"]\"));\r\n                    payload.append(directions).append(\"\\n\");\r\n                }\r\n            }\r\n\r\n\r\n            payload.append(\"---- exports ----\\n\");\r\n            int len = payload.length();\r\n            //noinspection unchecked,rawtypes\r\n            SFMResourceTypes.DEFERRED_TYPES\r\n                    .get()\r\n                    .getEntries()\r\n                    .forEach(entry -> payload.append(ServerboundContainerExportsInspectionRequestPacket.buildInspectionResults(\r\n                            (ResourceKey) entry.getKey(),\r\n                            entry.getValue(),\r\n                            level,\r\n                            pos,\r\n                            msg.blockFace\r\n                    )));\r\n            if (payload.length() == len) {\r\n                payload.append(\"No exports found\");\r\n            }\r\n            payload.append(\"\\n\");\r\n\r\n\r\n            if (entity != null) {\r\n                if (player.hasPermissions(2)) {\r\n                    payload.append(\"---- (op only) nbt data ----\\n\");\r\n                    payload.append(entity.serializeNBT()).append(\"\\n\");\r\n                }\r\n            }\r\n\r\n\r\n            SFMPackets.INSPECTION_CHANNEL.send(\r\n                    PacketDistributor.PLAYER.with(() -> player),\r\n                    new ClientboundInputInspectionResultsPacket(\r\n                            SFMUtils.truncate(\r\n                                    payload.toString(),\r\n                                    ClientboundInputInspectionResultsPacket.MAX_RESULTS_LENGTH\r\n                            ))\r\n            );\r\n        });\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\net\\ServerboundContainerExportsInspectionRequestPacket.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.common.net;\r\n\r\nimport ca.teamdman.sfm.common.Constants;\r\nimport ca.teamdman.sfm.common.compat.SFMCompat;\r\nimport ca.teamdman.sfm.common.compat.SFMMekanismCompat;\r\nimport ca.teamdman.sfm.common.registry.SFMPackets;\r\nimport ca.teamdman.sfm.common.registry.SFMResourceTypes;\r\nimport ca.teamdman.sfm.common.resourcetype.ResourceType;\r\nimport ca.teamdman.sfm.common.util.SFMUtils;\r\nimport ca.teamdman.sfml.ast.*;\r\nimport it.unimi.dsi.fastutil.ints.Int2ObjectArrayMap;\r\nimport it.unimi.dsi.fastutil.ints.Int2ObjectMap;\r\nimport net.minecraft.core.BlockPos;\r\nimport net.minecraft.core.Direction;\r\nimport net.minecraft.network.FriendlyByteBuf;\r\nimport net.minecraft.resources.ResourceKey;\r\nimport net.minecraft.resources.ResourceLocation;\r\nimport net.minecraft.world.inventory.AbstractContainerMenu;\r\nimport net.minecraft.world.level.LevelAccessor;\r\nimport net.minecraft.world.level.block.entity.BlockEntity;\r\nimport net.minecraftforge.network.NetworkEvent;\r\nimport net.minecraftforge.network.PacketDistributor;\r\nimport net.minecraftforge.registries.ForgeRegistries;\r\n\r\nimport javax.annotation.Nullable;\r\nimport java.util.ArrayList;\r\nimport java.util.Arrays;\r\nimport java.util.EnumSet;\r\nimport java.util.List;\r\nimport java.util.function.Supplier;\r\n\r\npublic record ServerboundContainerExportsInspectionRequestPacket(\r\n        int windowId,\r\n        BlockPos pos\r\n) {\r\n    public static void encode(ServerboundContainerExportsInspectionRequestPacket msg, FriendlyByteBuf friendlyByteBuf) {\r\n        friendlyByteBuf.writeVarInt(msg.windowId());\r\n        friendlyByteBuf.writeBlockPos(msg.pos());\r\n    }\r\n\r\n    public static ServerboundContainerExportsInspectionRequestPacket decode(FriendlyByteBuf friendlyByteBuf) {\r\n        return new ServerboundContainerExportsInspectionRequestPacket(\r\n                friendlyByteBuf.readVarInt(),\r\n                friendlyByteBuf.readBlockPos()\r\n        );\r\n    }\r\n\r\n    public static void handle(\r\n            ServerboundContainerExportsInspectionRequestPacket msg,\r\n            Supplier<NetworkEvent.Context> contextSupplier\r\n    ) {\r\n        SFMPackets.handleServerboundContainerPacket(\r\n                contextSupplier,\r\n                AbstractContainerMenu.class,\r\n                BlockEntity.class,\r\n                msg.pos,\r\n                msg.windowId,\r\n                (menu, blockEntity) -> {\r\n                    assert blockEntity.getLevel() != null;\r\n                    String payload = buildInspectionResults(blockEntity.getLevel(), blockEntity.getBlockPos());\r\n                    var player = contextSupplier.get().getSender();\r\n\r\n                    SFMPackets.INSPECTION_CHANNEL.send(\r\n                            PacketDistributor.PLAYER.with(() -> player),\r\n                            new ClientboundContainerExportsInspectionResultsPacket(\r\n                                    msg.windowId,\r\n                                    SFMUtils.truncate(\r\n                                            payload,\r\n                                            ClientboundContainerExportsInspectionResultsPacket.MAX_RESULTS_LENGTH\r\n                                    )\r\n                            )\r\n                    );\r\n                }\r\n        );\r\n    }\r\n\r\n\r\n    public static String buildInspectionResults(LevelAccessor level, BlockPos pos) {\r\n        StringBuilder sb = new StringBuilder();\r\n        Direction[] dirs = Arrays.copyOf(Direction.values(), Direction.values().length + 1);\r\n        dirs[dirs.length - 1] = null;\r\n        for (Direction direction : dirs) {\r\n            sb.append(\"-- \").append(direction).append(\"\\n\");\r\n            int len = sb.length();\r\n            //noinspection unchecked,rawtypes\r\n            SFMResourceTypes.DEFERRED_TYPES\r\n                    .get()\r\n                    .getEntries()\r\n                    .forEach(entry -> sb.append(buildInspectionResults(\r\n                            (ResourceKey) entry.getKey(),\r\n                            entry.getValue(),\r\n                            level,\r\n                            pos,\r\n                            direction\r\n                    )));\r\n            if (sb.length() == len) {\r\n                sb.append(\"No exports found\");\r\n            }\r\n            sb.append(\"\\n\");\r\n        }\r\n\r\n        if (SFMCompat.isMekanismLoaded()) {\r\n            BlockEntity be = level.getBlockEntity(pos);\r\n            if (be != null) {\r\n                sb.append(SFMMekanismCompat.gatherInspectionResults(be)).append(\"\\n\");\r\n            }\r\n        }\r\n\r\n        return sb.toString();\r\n    }\r\n\r\n    public static <STACK, ITEM, CAP> String buildInspectionResults(\r\n            ResourceKey<ResourceType<STACK, ITEM, CAP>> resourceTypeResourceKey,\r\n            ResourceType<STACK, ITEM, CAP> resourceType,\r\n            LevelAccessor level,\r\n            BlockPos pos,\r\n            @Nullable\r\n            Direction direction\r\n    ) {\r\n        StringBuilder sb = new StringBuilder();\r\n        SFMUtils\r\n                .discoverCapabilityProvider(level, pos)\r\n                .ifPresent(prov -> prov.getCapability(resourceType.CAPABILITY, direction).ifPresent(cap -> {\r\n                    int slots = resourceType.getSlots(cap);\r\n                    Int2ObjectMap<STACK> slotContents = new Int2ObjectArrayMap<>(slots);\r\n                    for (int slot = 0; slot < slots; slot++) {\r\n                        STACK stack = resourceType.getStackInSlot(cap, slot);\r\n                        if (!resourceType.isEmpty(stack)) {\r\n                            slotContents.put(slot, stack);\r\n                        }\r\n                    }\r\n\r\n                    if (!slotContents.isEmpty()) {\r\n                        slotContents.forEach((slot, stack) -> {\r\n                            InputStatement inputStatement = SFMUtils.getInputStatementForStack(\r\n                                    resourceTypeResourceKey,\r\n                                    resourceType,\r\n                                    stack,\r\n                                    \"target\",\r\n                                    slot,\r\n                                    false,\r\n                                    direction\r\n                            );\r\n                            sb.append(inputStatement.toStringPretty()).append(\"\\n\");\r\n                        });\r\n\r\n                        List<ResourceLimit<STACK, ITEM, CAP>> resourceLimitList = new ArrayList<>();\r\n                        slotContents.forEach((slot, stack) -> {\r\n                            ResourceLocation stackId = resourceType.getRegistryKey(stack);\r\n                            ResourceIdentifier<STACK, ITEM, CAP> resourceIdentifier = new ResourceIdentifier<>(\r\n                                    resourceTypeResourceKey.location().getNamespace(),\r\n                                    resourceTypeResourceKey.location().getPath(),\r\n                                    stackId.getNamespace(),\r\n                                    stackId.getPath()\r\n                            );\r\n                            ResourceLimit<STACK, ITEM, CAP> resourceLimit = new ResourceLimit<>(\r\n                                    resourceIdentifier,\r\n                                    Limit.MAX_QUANTITY_NO_RETENTION\r\n                            );\r\n                            resourceLimitList.add(resourceLimit);\r\n                        });\r\n                        InputStatement inputStatement = new InputStatement(\r\n                                new LabelAccess(\r\n                                        List.of(new Label(\"target\")),\r\n                                        new DirectionQualifier(direction == null\r\n                                                               ? EnumSet.noneOf(Direction.class)\r\n                                                               : EnumSet.of(direction)),\r\n                                        NumberRangeSet.MAX_RANGE,\r\n                                        RoundRobin.disabled()\r\n                                ),\r\n                                new ResourceLimits(\r\n                                        resourceLimitList.stream().distinct().toList(),\r\n                                        ResourceIdSet.EMPTY\r\n                                ),\r\n                                false\r\n                        );\r\n                        sb.append(inputStatement.toStringPretty());\r\n                    }\r\n                }));\r\n        String result = sb.toString();\r\n        if (!result.isBlank()) {\r\n            BlockEntity be = level.getBlockEntity(pos);\r\n            //noinspection DataFlowIssue\r\n            if (be != null && direction == null && ForgeRegistries.BLOCK_ENTITY_TYPES\r\n                    .getKey(be.getType())\r\n                    .getNamespace()\r\n                    .equals(\"mekanism\")) {\r\n                return \"-- \"\r\n                       + Constants.LocalizationKeys.CONTAINER_INSPECTOR_MEKANISM_NULL_DIRECTION_WARNING.getString()\r\n                       + \"\\n\"\r\n                       + result;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfml\\ast\\Statement.java\r\n\r\n````java\r\npackage ca.teamdman.sfml.ast;\r\n\r\nimport ca.teamdman.sfm.common.program.ProgramContext;\r\n\r\npublic interface Statement extends ASTNode {\r\n    void tick(ProgramContext context);\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\item\\FormItem.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.common.item;\r\n\r\nimport ca.teamdman.sfm.client.render.FormItemExtensions;\r\nimport ca.teamdman.sfm.common.registry.SFMItems;\r\nimport net.minecraft.network.chat.Component;\r\nimport net.minecraft.world.item.Item;\r\nimport net.minecraft.world.item.ItemStack;\r\nimport net.minecraft.world.item.TooltipFlag;\r\nimport net.minecraft.world.level.Level;\r\nimport net.minecraftforge.client.extensions.common.IClientItemExtensions;\r\nimport org.jetbrains.annotations.Nullable;\r\n\r\nimport java.util.List;\r\nimport java.util.function.Consumer;\r\n\r\npublic class FormItem extends Item {\r\n    public FormItem() {\r\n        super(new Item.Properties().tab(SFMItems.TAB));\r\n    }\r\n\r\n    public static ItemStack getForm(ItemStack stack) {\r\n        var formStack = new ItemStack(SFMItems.FORM_ITEM.get());\r\n        formStack.getOrCreateTag().put(\"reference\", stack.serializeNBT());\r\n        return formStack;\r\n    }\r\n\r\n    public static ItemStack getReference(ItemStack stack) {\r\n        return ItemStack.of(stack.getOrCreateTag().getCompound(\"reference\"));\r\n    }\r\n\r\n    @Override\r\n    public void initializeClient(Consumer<IClientItemExtensions> consumer) {\r\n        consumer.accept(new FormItemExtensions());\r\n    }\r\n\r\n    @Override\r\n    public void appendHoverText(\r\n            ItemStack pStack,\r\n            @Nullable Level pLevel,\r\n            List<Component> pTooltipComponents,\r\n            TooltipFlag pIsAdvanced\r\n    ) {\r\n        if (pStack.hasTag()) {\r\n            var reference = getReference(pStack);\r\n            if (!reference.isEmpty()) {\r\n                pTooltipComponents.add(reference.getHoverName());\r\n                reference.getItem().appendHoverText(reference, pLevel, pTooltipComponents, pIsAdvanced);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\item\\NetworkToolItem.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.common.item;\r\n\r\nimport ca.teamdman.sfm.client.registry.SFMKeyMappings;\r\nimport ca.teamdman.sfm.common.Constants;\r\nimport ca.teamdman.sfm.common.cablenetwork.CableNetworkManager;\r\nimport ca.teamdman.sfm.common.net.ServerboundNetworkToolUsePacket;\r\nimport ca.teamdman.sfm.common.registry.SFMItems;\r\nimport ca.teamdman.sfm.common.registry.SFMPackets;\r\nimport net.minecraft.ChatFormatting;\r\nimport net.minecraft.nbt.CompoundTag;\r\nimport net.minecraft.nbt.ListTag;\r\nimport net.minecraft.nbt.NbtUtils;\r\nimport net.minecraft.network.chat.Component;\r\nimport net.minecraft.world.InteractionResult;\r\nimport net.minecraft.world.entity.Entity;\r\nimport net.minecraft.world.item.Item;\r\nimport net.minecraft.world.item.ItemStack;\r\nimport net.minecraft.world.item.TooltipFlag;\r\nimport net.minecraft.world.item.context.UseOnContext;\r\nimport net.minecraft.world.level.Level;\r\n\r\nimport javax.annotation.Nullable;\r\nimport java.util.List;\r\n\r\npublic class NetworkToolItem extends Item {\r\n    public NetworkToolItem() {\r\n        super(new Item.Properties().stacksTo(1).tab(SFMItems.TAB));\r\n    }\r\n\r\n    @Override\r\n    public InteractionResult onItemUseFirst(ItemStack stack, UseOnContext pContext) {\r\n        if (pContext.getLevel().isClientSide) return InteractionResult.SUCCESS;\r\n\r\n        SFMPackets.INSPECTION_CHANNEL.sendToServer(new ServerboundNetworkToolUsePacket(\r\n                pContext.getClickedPos(),\r\n                pContext.getClickedFace()\r\n        ));\r\n        return InteractionResult.CONSUME;\r\n    }\r\n\r\n    @Override\r\n    public void appendHoverText(\r\n            ItemStack stack, @Nullable Level level, List<Component> lines, TooltipFlag detail\r\n    ) {\r\n        lines.add(Constants.LocalizationKeys.NETWORK_TOOL_ITEM_TOOLTIP_1.getComponent().withStyle(ChatFormatting.GRAY));\r\n        lines.add(Constants.LocalizationKeys.NETWORK_TOOL_ITEM_TOOLTIP_2.getComponent().withStyle(ChatFormatting.GRAY));\r\n        lines.add(Constants.LocalizationKeys.NETWORK_TOOL_ITEM_TOOLTIP_3.getComponent(\r\n                SFMKeyMappings.CONTAINER_INSPECTOR_KEY.get().getTranslatedKeyMessage()\r\n        ).withStyle(ChatFormatting.AQUA));\r\n    }\r\n\r\n    @Override\r\n    public void inventoryTick(ItemStack pStack, Level pLevel, Entity pEntity, int pSlotId, boolean pIsSelected) {\r\n        if (pIsSelected && !pLevel.isClientSide && pEntity.tickCount % 20 == 0) {\r\n            final long maxDistance = 128;\r\n            CompoundTag tag = new CompoundTag();\r\n            ListTag networks = new ListTag();\r\n            CableNetworkManager\r\n                    .getNetworksForLevel(pLevel)\r\n                    .filter(net -> net\r\n                            .getCablePositions()\r\n                            .anyMatch(cablePos -> cablePos.distSqr(pEntity.blockPosition())\r\n                                                  < maxDistance * maxDistance))\r\n                    .forEach(net -> {\r\n                        CompoundTag networkTag = new CompoundTag();\r\n                        networkTag.put(\r\n                                \"cable_positions\",\r\n                                net\r\n                                        .getCablePositions()\r\n                                        .map(NbtUtils::writeBlockPos)\r\n                                        .collect(ListTag::new, ListTag::add, ListTag::addAll)\r\n                        );\r\n                        networkTag.put(\r\n                                \"capability_provider_positions\",\r\n                                net\r\n                                        .getCapabilityProviderPositions()\r\n                                        .map(NbtUtils::writeBlockPos)\r\n                                        .collect(ListTag::new, ListTag::add, ListTag::addAll)\r\n                        );\r\n                        networks.add(networkTag);\r\n                    });\r\n            tag.put(\"networks\", networks);\r\n            pStack.setTag(tag);\r\n        }\r\n    }\r\n\r\n\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfml\\ast\\package-info.java\r\n\r\n````java\r\n\r\n\r\n@ParametersAreNonnullByDefault\r\n@MethodsReturnNonnullByDefault\r\n@FieldsAreNonnullByDefault\r\npackage ca.teamdman.sfml.ast;\r\n\r\nimport net.minecraft.FieldsAreNonnullByDefault;\r\nimport net.minecraft.MethodsReturnNonnullByDefault;\r\n\r\nimport javax.annotation.ParametersAreNonnullByDefault;\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\client\\registry\\package-info.java\r\n\r\n````java\r\n@ParametersAreNonnullByDefault\r\n@MethodsReturnNonnullByDefault\r\n@FieldsAreNonnullByDefault\r\npackage ca.teamdman.sfm.client.registry;\r\n\r\nimport net.minecraft.FieldsAreNonnullByDefault;\r\nimport net.minecraft.MethodsReturnNonnullByDefault;\r\n\r\nimport javax.annotation.ParametersAreNonnullByDefault;\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\recipe\\package-info.java\r\n\r\n````java\r\n\r\n\r\n@ParametersAreNonnullByDefault\r\n@MethodsReturnNonnullByDefault\r\n@FieldsAreNonnullByDefault\r\npackage ca.teamdman.sfm.common.recipe;\r\n\r\nimport net.minecraft.FieldsAreNonnullByDefault;\r\nimport net.minecraft.MethodsReturnNonnullByDefault;\r\n\r\nimport javax.annotation.ParametersAreNonnullByDefault;\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\registry\\SFMPackets.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.common.registry;\r\n\r\nimport ca.teamdman.sfm.SFM;\r\nimport ca.teamdman.sfm.common.net.*;\r\nimport net.minecraft.core.BlockPos;\r\nimport net.minecraft.resources.ResourceLocation;\r\nimport net.minecraft.world.inventory.AbstractContainerMenu;\r\nimport net.minecraft.world.level.block.entity.BlockEntity;\r\nimport net.minecraftforge.network.NetworkEvent;\r\nimport net.minecraftforge.network.NetworkRegistry;\r\nimport net.minecraftforge.network.simple.SimpleChannel;\r\n\r\nimport javax.annotation.Nullable;\r\nimport java.util.function.BiConsumer;\r\nimport java.util.function.Supplier;\r\n\r\npublic class SFMPackets {\r\n    public static final String MANAGER_CHANNEL_VERSION = \"1\";\r\n    public static final String LABEL_GUN_ITEM_CHANNEL_VERSION = \"1\";\r\n    public static final String DISK_ITEM_CHANNEL_VERSION = \"1\";\r\n    public static final String INSPECTION_CHANNEL_VERSION = \"1\";\r\n    public static final SimpleChannel MANAGER_CHANNEL = NetworkRegistry.newSimpleChannel(\r\n            new ResourceLocation(SFM.MOD_ID, \"manager\"),\r\n            MANAGER_CHANNEL_VERSION::toString,\r\n            MANAGER_CHANNEL_VERSION::equals,\r\n            MANAGER_CHANNEL_VERSION::equals\r\n    );\r\n    public static final SimpleChannel LABEL_GUN_ITEM_CHANNEL = NetworkRegistry.newSimpleChannel(\r\n            new ResourceLocation(SFM.MOD_ID, \"labelgun\"),\r\n            LABEL_GUN_ITEM_CHANNEL_VERSION::toString,\r\n            LABEL_GUN_ITEM_CHANNEL_VERSION::equals,\r\n            LABEL_GUN_ITEM_CHANNEL_VERSION::equals\r\n    );\r\n    public static final SimpleChannel DISK_ITEM_CHANNEL = NetworkRegistry.newSimpleChannel(\r\n            new ResourceLocation(SFM.MOD_ID, \"disk\"),\r\n            DISK_ITEM_CHANNEL_VERSION::toString,\r\n            DISK_ITEM_CHANNEL_VERSION::equals,\r\n            DISK_ITEM_CHANNEL_VERSION::equals\r\n    );\r\n\r\n    public static final SimpleChannel INSPECTION_CHANNEL = NetworkRegistry.newSimpleChannel(\r\n            new ResourceLocation(SFM.MOD_ID, \"inspection\"),\r\n            INSPECTION_CHANNEL_VERSION::toString,\r\n            INSPECTION_CHANNEL_VERSION::equals,\r\n            INSPECTION_CHANNEL_VERSION::equals\r\n    );\r\n\r\n    public static void register() {\r\n        MANAGER_CHANNEL.registerMessage(\r\n                0,\r\n                ServerboundManagerProgramPacket.class,\r\n                ServerboundManagerProgramPacket::encode,\r\n                ServerboundManagerProgramPacket::decode,\r\n                ServerboundManagerProgramPacket::handle\r\n        );\r\n        MANAGER_CHANNEL.registerMessage(\r\n                1,\r\n                ServerboundManagerResetPacket.class,\r\n                ServerboundManagerResetPacket::encode,\r\n                ServerboundManagerResetPacket::decode,\r\n                ServerboundManagerResetPacket::handle\r\n        );\r\n        MANAGER_CHANNEL.registerMessage(\r\n                2,\r\n                ServerboundManagerFixPacket.class,\r\n                ServerboundManagerFixPacket::encode,\r\n                ServerboundManagerFixPacket::decode,\r\n                ServerboundManagerFixPacket::handle\r\n        );\r\n        MANAGER_CHANNEL.registerMessage(\r\n                3,\r\n                ClientboundManagerGuiPacket.class,\r\n                ClientboundManagerGuiPacket::encode,\r\n                ClientboundManagerGuiPacket::decode,\r\n                ClientboundManagerGuiPacket::handle\r\n        );\r\n\r\n\r\n        LABEL_GUN_ITEM_CHANNEL.registerMessage(\r\n                0,\r\n                ServerboundLabelGunUpdatePacket.class,\r\n                ServerboundLabelGunUpdatePacket::encode,\r\n                ServerboundLabelGunUpdatePacket::decode,\r\n                ServerboundLabelGunUpdatePacket::handle\r\n        );\r\n        LABEL_GUN_ITEM_CHANNEL.registerMessage(\r\n                1,\r\n                ServerboundLabelGunPrunePacket.class,\r\n                ServerboundLabelGunPrunePacket::encode,\r\n                ServerboundLabelGunPrunePacket::decode,\r\n                ServerboundLabelGunPrunePacket::handle\r\n        );\r\n        LABEL_GUN_ITEM_CHANNEL.registerMessage(\r\n                2,\r\n                ServerboundLabelGunClearPacket.class,\r\n                ServerboundLabelGunClearPacket::encode,\r\n                ServerboundLabelGunClearPacket::decode,\r\n                ServerboundLabelGunClearPacket::handle\r\n        );\r\n        LABEL_GUN_ITEM_CHANNEL.registerMessage(\r\n                3,\r\n                ServerboundLabelGunUsePacket.class,\r\n                ServerboundLabelGunUsePacket::encode,\r\n                ServerboundLabelGunUsePacket::decode,\r\n                ServerboundLabelGunUsePacket::handle\r\n        );\r\n\r\n        DISK_ITEM_CHANNEL.registerMessage(\r\n                0,\r\n                ServerboundDiskItemSetProgramPacket.class,\r\n                ServerboundDiskItemSetProgramPacket::encode,\r\n                ServerboundDiskItemSetProgramPacket::decode,\r\n                ServerboundDiskItemSetProgramPacket::handle\r\n        );\r\n\r\n        INSPECTION_CHANNEL.registerMessage(\r\n                0,\r\n                ServerboundContainerExportsInspectionRequestPacket.class,\r\n                ServerboundContainerExportsInspectionRequestPacket::encode,\r\n                ServerboundContainerExportsInspectionRequestPacket::decode,\r\n                ServerboundContainerExportsInspectionRequestPacket::handle\r\n        );\r\n        INSPECTION_CHANNEL.registerMessage(\r\n                1,\r\n                ClientboundContainerExportsInspectionResultsPacket.class,\r\n                ClientboundContainerExportsInspectionResultsPacket::encode,\r\n                ClientboundContainerExportsInspectionResultsPacket::decode,\r\n                ClientboundContainerExportsInspectionResultsPacket::handle\r\n        );\r\n        INSPECTION_CHANNEL.registerMessage(\r\n                2,\r\n                ServerboundLabelInspectionRequestPacket.class,\r\n                ServerboundLabelInspectionRequestPacket::encode,\r\n                ServerboundLabelInspectionRequestPacket::decode,\r\n                ServerboundLabelInspectionRequestPacket::handle\r\n        );\r\n        INSPECTION_CHANNEL.registerMessage(\r\n                3,\r\n                ClientboundLabelInspectionResultsPacket.class,\r\n                ClientboundLabelInspectionResultsPacket::encode,\r\n                ClientboundLabelInspectionResultsPacket::decode,\r\n                ClientboundLabelInspectionResultsPacket::handle\r\n        );\r\n        INSPECTION_CHANNEL.registerMessage(\r\n                4,\r\n                ServerboundInputInspectionRequestPacket.class,\r\n                ServerboundInputInspectionRequestPacket::encode,\r\n                ServerboundInputInspectionRequestPacket::decode,\r\n                ServerboundInputInspectionRequestPacket::handle\r\n        );\r\n        INSPECTION_CHANNEL.registerMessage(\r\n                5,\r\n                ClientboundInputInspectionResultsPacket.class,\r\n                ClientboundInputInspectionResultsPacket::encode,\r\n                ClientboundInputInspectionResultsPacket::decode,\r\n                ClientboundInputInspectionResultsPacket::handle\r\n        );\r\n        INSPECTION_CHANNEL.registerMessage(\r\n                6,\r\n                ServerboundOutputInspectionRequestPacket.class,\r\n                ServerboundOutputInspectionRequestPacket::encode,\r\n                ServerboundOutputInspectionRequestPacket::decode,\r\n                ServerboundOutputInspectionRequestPacket::handle\r\n        );\r\n        INSPECTION_CHANNEL.registerMessage(\r\n                7,\r\n                ClientboundOutputInspectionResultsPacket.class,\r\n                ClientboundOutputInspectionResultsPacket::encode,\r\n                ClientboundOutputInspectionResultsPacket::decode,\r\n                ClientboundOutputInspectionResultsPacket::handle\r\n        );\r\n        INSPECTION_CHANNEL.registerMessage(\r\n                8,\r\n                ServerboundNetworkToolUsePacket.class,\r\n                ServerboundNetworkToolUsePacket::encode,\r\n                ServerboundNetworkToolUsePacket::decode,\r\n                ServerboundNetworkToolUsePacket::handle\r\n        );\r\n    }\r\n\r\n    public static <MENU extends AbstractContainerMenu, BE extends BlockEntity> void handleServerboundContainerPacket(\r\n            @Nullable Supplier<NetworkEvent.Context> ctxSupplier,\r\n            Class<MENU> menuClass,\r\n            Class<BE> blockEntityClass,\r\n            BlockPos pos,\r\n            int containerId,\r\n            BiConsumer<MENU, BE> callback\r\n    ) {\r\n        if (ctxSupplier == null) return;\r\n\r\n        var ctx = ctxSupplier.get();\r\n        if (ctx == null) return;\r\n        ctx.enqueueWork(() -> {\r\n            var sender = ctx.getSender();\r\n            if (sender == null) return;\r\n            if (sender.isSpectator()) return; // ignore packets from spectators\r\n\r\n            var menu = sender.containerMenu;\r\n            if (!menuClass.isInstance(menu)) return;\r\n            if (menu.containerId != containerId) return;\r\n\r\n            var level = sender.getLevel();\r\n            //noinspection ConstantValue\r\n            if (level == null) return;\r\n            if (!level.isLoaded(pos)) return;\r\n\r\n            var blockEntity = level.getBlockEntity(pos);\r\n            if (!blockEntityClass.isInstance(blockEntity)) return;\r\n            //noinspection unchecked\r\n            callback.accept((MENU) menu, (BE) blockEntity);\r\n        });\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\client\\jei\\FallingAnvilJEICategory.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.client.jei;\r\n\r\nimport ca.teamdman.sfm.SFM;\r\nimport ca.teamdman.sfm.common.Constants;\r\nimport ca.teamdman.sfm.common.item.FormItem;\r\nimport ca.teamdman.sfm.common.registry.SFMItems;\r\nimport mezz.jei.api.gui.builder.IRecipeLayoutBuilder;\r\nimport mezz.jei.api.gui.drawable.IDrawable;\r\nimport mezz.jei.api.helpers.IJeiHelpers;\r\nimport mezz.jei.api.recipe.IFocusGroup;\r\nimport mezz.jei.api.recipe.RecipeIngredientRole;\r\nimport mezz.jei.api.recipe.RecipeType;\r\nimport mezz.jei.api.recipe.category.IRecipeCategory;\r\nimport net.minecraft.nbt.ListTag;\r\nimport net.minecraft.nbt.StringTag;\r\nimport net.minecraft.network.chat.Component;\r\nimport net.minecraft.world.item.EnchantedBookItem;\r\nimport net.minecraft.world.item.Item;\r\nimport net.minecraft.world.item.ItemStack;\r\nimport net.minecraft.world.item.Items;\r\nimport net.minecraft.world.item.crafting.Ingredient;\r\nimport net.minecraft.world.item.enchantment.Enchantment;\r\nimport net.minecraft.world.item.enchantment.EnchantmentInstance;\r\nimport net.minecraft.world.level.block.Blocks;\r\nimport net.minecraftforge.registries.ForgeRegistries;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.Arrays;\r\nimport java.util.Collection;\r\nimport java.util.List;\r\n\r\npublic class FallingAnvilJEICategory implements IRecipeCategory<FallingAnvilRecipe> {\r\n\r\n    public static final RecipeType<FallingAnvilRecipe> RECIPE_TYPE = RecipeType.create(\r\n            SFM.MOD_ID,\r\n            \"falling_anvil\",\r\n            FallingAnvilRecipe.class\r\n    );\r\n    private final IDrawable background;\r\n    private final IDrawable icon;\r\n\r\n    public FallingAnvilJEICategory(IJeiHelpers jeiHelpers) {\r\n        background = jeiHelpers.getGuiHelper().createBlankDrawable(80, 54);\r\n        icon = jeiHelpers.getGuiHelper().createDrawableItemStack(new ItemStack(Blocks.ANVIL));\r\n    }\r\n\r\n    @Override\r\n    public RecipeType<FallingAnvilRecipe> getRecipeType() {\r\n        return RECIPE_TYPE;\r\n    }\r\n\r\n    @Override\r\n    public Component getTitle() {\r\n        return Constants.LocalizationKeys.FALLING_ANVIL_JEI_CATEGORY_TITLE.getComponent();\r\n    }\r\n\r\n    @Override\r\n    public IDrawable getBackground() {\r\n        return background;\r\n    }\r\n\r\n    @Override\r\n    public IDrawable getIcon() {\r\n        return icon;\r\n    }\r\n\r\n    @Override\r\n    public void setRecipe(IRecipeLayoutBuilder builder, FallingAnvilRecipe recipe, IFocusGroup focuses) {\r\n        var anvil = List.of(\r\n                new ItemStack(Items.ANVIL),\r\n                new ItemStack(Items.CHIPPED_ANVIL),\r\n                new ItemStack(Items.DAMAGED_ANVIL)\r\n        );\r\n        if (recipe instanceof FallingAnvilFormRecipe formRecipe) {\r\n            builder.addSlot(RecipeIngredientRole.CATALYST, 0, 0).addItemStacks(anvil);\r\n            builder.addSlot(RecipeIngredientRole.INPUT, 0, 18).addIngredients(formRecipe.PARENT.FORM);\r\n            ItemStack ironBlock = new ItemStack(Blocks.IRON_BLOCK);\r\n            var displayTag = ironBlock.getOrCreateTag().getCompound(\"display\");\r\n            var lore = new ListTag();\r\n            lore.add(StringTag.valueOf(Component.Serializer.toJson(Constants.LocalizationKeys.FALLING_ANVIL_JEI_CONSUMED.getComponent())));\r\n            displayTag.put(\"Lore\", lore);\r\n            ironBlock.getOrCreateTag().put(\"display\", displayTag);\r\n            builder.addSlot(RecipeIngredientRole.INPUT, 0, 36).addItemStack(ironBlock);\r\n            builder\r\n                    .addSlot(RecipeIngredientRole.OUTPUT, 50, 18)\r\n                    .addItemStacks(Arrays.stream(formRecipe.PARENT.FORM.getItems()).map(FormItem::getForm).toList());\r\n        } else if (recipe instanceof FallingAnvilDisenchantRecipe) {\r\n            Collection<Enchantment> enchants = ForgeRegistries.ENCHANTMENTS.getValues();\r\n\r\n            var tools = List.of(\r\n                    Items.DIAMOND_HELMET,\r\n                    Items.DIAMOND_CHESTPLATE,\r\n                    Items.DIAMOND_LEGGINGS,\r\n                    Items.DIAMOND_BOOTS,\r\n                    Items.DIAMOND_PICKAXE,\r\n                    Items.DIAMOND_SHOVEL,\r\n                    Items.DIAMOND_AXE,\r\n                    Items.DIAMOND_HOE,\r\n                    Items.DIAMOND_SWORD,\r\n                    Items.GOLDEN_HELMET,\r\n                    Items.GOLDEN_CHESTPLATE,\r\n                    Items.GOLDEN_LEGGINGS,\r\n                    Items.GOLDEN_BOOTS,\r\n                    Items.GOLDEN_PICKAXE,\r\n                    Items.GOLDEN_SHOVEL,\r\n                    Items.GOLDEN_AXE,\r\n                    Items.GOLDEN_HOE,\r\n                    Items.GOLDEN_SWORD,\r\n                    Items.IRON_HELMET,\r\n                    Items.IRON_CHESTPLATE,\r\n                    Items.IRON_LEGGINGS,\r\n                    Items.IRON_BOOTS,\r\n                    Items.IRON_PICKAXE,\r\n                    Items.IRON_SHOVEL,\r\n                    Items.IRON_AXE,\r\n                    Items.IRON_HOE,\r\n                    Items.IRON_SWORD,\r\n                    Items.LEATHER_HELMET,\r\n                    Items.LEATHER_CHESTPLATE,\r\n                    Items.LEATHER_LEGGINGS,\r\n                    Items.LEATHER_BOOTS,\r\n                    Items.CHAINMAIL_HELMET,\r\n                    Items.CHAINMAIL_CHESTPLATE,\r\n                    Items.CHAINMAIL_LEGGINGS,\r\n                    Items.CHAINMAIL_BOOTS,\r\n                    Items.WOODEN_PICKAXE,\r\n                    Items.WOODEN_SHOVEL,\r\n                    Items.WOODEN_AXE,\r\n                    Items.WOODEN_HOE,\r\n                    Items.WOODEN_SWORD,\r\n                    Items.BOW\r\n            );\r\n            var enchanted = new ArrayList<ItemStack>();\r\n            var books = new ArrayList<ItemStack>();\r\n            for (Enchantment enchant : enchants) {\r\n                for (Item tool : tools) {\r\n                    var stack = new ItemStack(tool);\r\n                    if (enchant.canEnchant(stack)) {\r\n                        stack.enchant(enchant, enchant.getMaxLevel());\r\n                        enchanted.add(stack);\r\n                        books.add(EnchantedBookItem.createForEnchantment(new EnchantmentInstance(\r\n                                enchant,\r\n                                enchant.getMaxLevel()\r\n                        )));\r\n                    }\r\n                }\r\n            }\r\n\r\n            builder.addSlot(RecipeIngredientRole.CATALYST, 8, 0).addItemStacks(anvil);\r\n            builder.addSlot(RecipeIngredientRole.INPUT, 0, 18).addItemStacks(enchanted);\r\n            builder.addSlot(RecipeIngredientRole.INPUT, 18, 18).addItemStack(new ItemStack(Items.BOOK));\r\n            ItemStack obsidian = new ItemStack(Blocks.OBSIDIAN);\r\n            var displayTag = obsidian.getOrCreateTag().getCompound(\"display\");\r\n            var lore = new ListTag();\r\n            lore.add(StringTag.valueOf(Component.Serializer.toJson(Constants.LocalizationKeys.FALLING_ANVIL_JEI_NOT_CONSUMED.getComponent())));\r\n            displayTag.put(\"Lore\", lore);\r\n            obsidian.getOrCreateTag().put(\"display\", displayTag);\r\n            builder.addSlot(RecipeIngredientRole.INPUT, 8, 36).addItemStack(obsidian);\r\n            builder.addSlot(RecipeIngredientRole.OUTPUT, 50, 18).addItemStacks(books);\r\n        } else if (recipe instanceof FallingAnvilExperienceShardRecipe) {\r\n            builder.addSlot(RecipeIngredientRole.CATALYST, 0, 0).addItemStacks(anvil);\r\n            builder.addSlot(RecipeIngredientRole.INPUT, 0, 18).addIngredients(Ingredient.of(Items.ENCHANTED_BOOK));\r\n            ItemStack obsidian = new ItemStack(Blocks.OBSIDIAN);\r\n            var displayTag = obsidian.getOrCreateTag().getCompound(\"display\");\r\n            var lore = new ListTag();\r\n            lore.add(StringTag.valueOf(Component.Serializer.toJson(Constants.LocalizationKeys.FALLING_ANVIL_JEI_NOT_CONSUMED.getComponent())));\r\n            displayTag.put(\"Lore\", lore);\r\n            obsidian.getOrCreateTag().put(\"display\", displayTag);\r\n            builder.addSlot(RecipeIngredientRole.INPUT, 0, 36).addItemStack(obsidian);\r\n            builder\r\n                    .addSlot(RecipeIngredientRole.OUTPUT, 50, 18)\r\n                    .addItemStack(new ItemStack(SFMItems.EXPERIENCE_SHARD_ITEM.get()));\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\containermenu\\ManagerContainerMenu.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.common.containermenu;\r\n\r\nimport ca.teamdman.sfm.common.blockentity.ManagerBlockEntity;\r\nimport ca.teamdman.sfm.common.item.DiskItem;\r\nimport ca.teamdman.sfm.common.registry.SFMMenus;\r\nimport ca.teamdman.sfml.ast.Program;\r\nimport net.minecraft.core.BlockPos;\r\nimport net.minecraft.network.FriendlyByteBuf;\r\nimport net.minecraft.world.Container;\r\nimport net.minecraft.world.SimpleContainer;\r\nimport net.minecraft.world.entity.player.Inventory;\r\nimport net.minecraft.world.entity.player.Player;\r\nimport net.minecraft.world.inventory.AbstractContainerMenu;\r\nimport net.minecraft.world.inventory.Slot;\r\nimport net.minecraft.world.item.ItemStack;\r\n\r\npublic class ManagerContainerMenu extends AbstractContainerMenu {\r\n    public final Container CONTAINER;\r\n    public final Inventory INVENTORY;\r\n    public final BlockPos MANAGER_POSITION;\r\n    public String program;\r\n    public ManagerBlockEntity.State state;\r\n    public long[] tickTimeNanos;\r\n\r\n\r\n    public ManagerContainerMenu(\r\n            int windowId,\r\n            Inventory inv,\r\n            Container container,\r\n            BlockPos blockEntityPos,\r\n            String program,\r\n            ManagerBlockEntity.State state,\r\n            long[] tickTimeNanos\r\n    ) {\r\n        super(SFMMenus.MANAGER_MENU.get(), windowId);\r\n        checkContainerSize(container, 1);\r\n        this.CONTAINER = container;\r\n        this.INVENTORY = inv;\r\n        this.MANAGER_POSITION = blockEntityPos;\r\n        this.program = program;\r\n        this.state = state;\r\n        this.tickTimeNanos = tickTimeNanos;\r\n\r\n        this.addSlot(new Slot(container, 0, 15, 47) {\r\n            @Override\r\n            public int getMaxStackSize() {\r\n                return 1;\r\n            }\r\n\r\n            @Override\r\n            public boolean mayPlace(ItemStack stack) {\r\n                return stack.getItem() instanceof DiskItem;\r\n            }\r\n        });\r\n\r\n        for (int i = 0; i < 3; ++i) {\r\n            for (int j = 0; j < 9; ++j) {\r\n                this.addSlot(new Slot(inv, j + i * 9 + 9, 8 + j * 18, 84 + i * 18));\r\n            }\r\n        }\r\n\r\n        for (int k = 0; k < 9; ++k) {\r\n            this.addSlot(new Slot(inv, k, 8 + k * 18, 142));\r\n        }\r\n    }\r\n\r\n    public ManagerContainerMenu(int windowId, Inventory inventory, FriendlyByteBuf buf) {\r\n        this(\r\n                windowId,\r\n                inventory,\r\n                new SimpleContainer(1),\r\n                buf.readBlockPos(),\r\n                buf.readUtf(Program.MAX_PROGRAM_LENGTH),\r\n                buf.readEnum(ManagerBlockEntity.State.class),\r\n                buf.readLongArray(null, ManagerBlockEntity.TICK_TIME_HISTORY_SIZE)\r\n        );\r\n    }\r\n\r\n    public ManagerContainerMenu(int windowId, Inventory inventory, ManagerBlockEntity manager) {\r\n        this(\r\n                windowId,\r\n                inventory,\r\n                manager,\r\n                manager.getBlockPos(),\r\n                manager.getProgramString().orElse(\"\"),\r\n                manager.getState(),\r\n                manager.getTickTimeNanos()\r\n        );\r\n    }\r\n\r\n    public static void encode(ManagerBlockEntity manager, FriendlyByteBuf buf) {\r\n        buf.writeBlockPos(manager.getBlockPos());\r\n        buf.writeUtf(manager.getProgramString().orElse(\"\"), Program.MAX_PROGRAM_LENGTH);\r\n        buf.writeEnum(manager.getState());\r\n        buf.writeLongArray(manager.getTickTimeNanos());\r\n    }\r\n\r\n\r\n    @Override\r\n    public boolean stillValid(Player player) {\r\n        return CONTAINER.stillValid(player);\r\n    }\r\n\r\n    @Override\r\n    public ItemStack quickMoveStack(Player player, int slotIndex) {\r\n        var slot = this.slots.get(slotIndex);\r\n        if (!slot.hasItem()) return ItemStack.EMPTY;\r\n\r\n        var containerEnd = CONTAINER.getContainerSize();\r\n        var inventoryEnd = this.slots.size();\r\n\r\n        var contents = slot.getItem();\r\n        var result = contents.copy();\r\n\r\n        if (slotIndex < containerEnd) {\r\n            // clicked slot in container\r\n            if (!this.moveItemStackTo(contents, containerEnd, inventoryEnd, true)) return ItemStack.EMPTY;\r\n        } else {\r\n            // clicked slot in inventory\r\n            if (!this.moveItemStackTo(contents, 0, containerEnd, false)) return ItemStack.EMPTY;\r\n        }\r\n\r\n        if (contents.isEmpty()) {\r\n            slot.set(ItemStack.EMPTY);\r\n        } else {\r\n            slot.setChanged();\r\n        }\r\n        return result;\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\compat\\SFMCompat.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.common.compat;\r\n\r\nimport ca.teamdman.sfm.common.resourcetype.GasResourceType;\r\nimport ca.teamdman.sfm.common.resourcetype.InfuseResourceType;\r\nimport ca.teamdman.sfm.common.resourcetype.PigmentResourceType;\r\nimport ca.teamdman.sfm.common.resourcetype.SlurryResourceType;\r\nimport net.minecraftforge.common.capabilities.Capability;\r\nimport net.minecraftforge.common.capabilities.ForgeCapabilities;\r\nimport net.minecraftforge.fml.ModList;\r\n\r\nimport java.util.List;\r\n\r\npublic class SFMCompat {\r\n    public static boolean isMekanismLoaded() {\r\n        return ModList.get().getModContainerById(\"mekanism\").isPresent();\r\n    }\r\n\r\n    public static List<Capability<?>> getCapabilities() {\r\n        if (isMekanismLoaded()) {\r\n            return List.of(\r\n                    ForgeCapabilities.ITEM_HANDLER,\r\n                    ForgeCapabilities.FLUID_HANDLER,\r\n                    ForgeCapabilities.ENERGY,\r\n                    GasResourceType.CAP,\r\n                    InfuseResourceType.CAP,\r\n                    PigmentResourceType.CAP,\r\n                    SlurryResourceType.CAP\r\n            );\r\n        } else {\r\n            return List.of(\r\n                    ForgeCapabilities.ITEM_HANDLER,\r\n                    ForgeCapabilities.FLUID_HANDLER,\r\n                    ForgeCapabilities.ENERGY\r\n            );\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfml\\ast\\DirectionQualifier.java\r\n\r\n````java\r\npackage ca.teamdman.sfml.ast;\r\n\r\nimport net.minecraft.core.Direction;\r\n\r\nimport javax.annotation.Nullable;\r\nimport java.util.EnumSet;\r\nimport java.util.stream.Stream;\r\n\r\npublic record DirectionQualifier(EnumSet<Direction> directions) implements ASTNode {\r\n\r\n    public static DirectionQualifier NULL_DIRECTION = new DirectionQualifier(EnumSet.noneOf(Direction.class));\r\n    public static DirectionQualifier EVERY_DIRECTION = new DirectionQualifier(EnumSet.allOf(Direction.class));\r\n\r\n    public static Direction lookup(Side side) {\r\n        return switch (side) {\r\n            case TOP -> Direction.UP;\r\n            case BOTTOM -> Direction.DOWN;\r\n            case NORTH -> Direction.NORTH;\r\n            case SOUTH -> Direction.SOUTH;\r\n            case EAST -> Direction.EAST;\r\n            case WEST -> Direction.WEST;\r\n        };\r\n    }\r\n\r\n    public static String directionToString(@Nullable Direction direction) {\r\n        if (direction == null) return \"\";\r\n        return switch (direction) {\r\n            case UP -> \"TOP\";\r\n            case DOWN -> \"BOTTOM\";\r\n            case NORTH -> \"NORTH\";\r\n            case SOUTH -> \"SOUTH\";\r\n            case EAST -> \"EAST\";\r\n            case WEST -> \"WEST\";\r\n        };\r\n    }\r\n\r\n    public Stream<Direction> stream() {\r\n        if (this == EVERY_DIRECTION)\r\n            return Stream.concat(directions.stream(), Stream.<Direction>builder().add(null).build());\r\n        if (directions.isEmpty()) return Stream.<Direction>builder().add(null).build();\r\n        return directions.stream();\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\compat\\package-info.java\r\n\r\n````java\r\n\r\n@ParametersAreNonnullByDefault\r\n@MethodsReturnNonnullByDefault\r\n@FieldsAreNonnullByDefault\r\npackage ca.teamdman.sfm.common.compat;\r\n\r\nimport net.minecraft.FieldsAreNonnullByDefault;\r\nimport net.minecraft.MethodsReturnNonnullByDefault;\r\n\r\nimport javax.annotation.ParametersAreNonnullByDefault;\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\util\\package-info.java\r\n\r\n````java\r\n\r\n\r\n@ParametersAreNonnullByDefault\r\n@MethodsReturnNonnullByDefault\r\n@FieldsAreNonnullByDefault\r\npackage ca.teamdman.sfm.common.util;\r\n\r\nimport net.minecraft.FieldsAreNonnullByDefault;\r\nimport net.minecraft.MethodsReturnNonnullByDefault;\r\n\r\nimport javax.annotation.ParametersAreNonnullByDefault;\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\resourcetype\\ResourceType.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.common.resourcetype;\r\n\r\nimport ca.teamdman.sfm.common.cablenetwork.CableNetwork;\r\nimport ca.teamdman.sfm.common.program.LabelPositionHolder;\r\nimport ca.teamdman.sfm.common.program.ProgramContext;\r\nimport ca.teamdman.sfml.ast.LabelAccess;\r\nimport ca.teamdman.sfml.ast.ResourceIdentifier;\r\nimport it.unimi.dsi.fastutil.objects.Object2ObjectOpenHashMap;\r\nimport net.minecraft.resources.ResourceLocation;\r\nimport net.minecraft.world.item.ItemStack;\r\nimport net.minecraftforge.common.capabilities.Capability;\r\nimport net.minecraftforge.registries.IForgeRegistry;\r\n\r\nimport java.util.Map;\r\nimport java.util.Optional;\r\nimport java.util.stream.Stream;\r\n\r\npublic abstract class ResourceType<STACK, ITEM, CAP> {\r\n    private final Map<ITEM, ResourceLocation> registryKeyCache = new Object2ObjectOpenHashMap<>();\r\n\r\n\r\n    public final Capability<CAP> CAPABILITY;\r\n\r\n    public ResourceType(Capability<CAP> CAPABILITY) {\r\n        this.CAPABILITY = CAPABILITY;\r\n    }\r\n\r\n\r\n    public abstract long getAmount(STACK stack);\r\n\r\n    public abstract STACK getStackInSlot(CAP cap, int slot);\r\n\r\n    public abstract STACK extract(CAP cap, int slot, long amount, boolean simulate);\r\n\r\n    public abstract int getSlots(CAP handler);\r\n\r\n    public abstract long getMaxStackSize(STACK stack);\r\n\r\n    public abstract long getMaxStackSize(CAP cap, int slot);\r\n\r\n\r\n    public abstract STACK insert(CAP cap, int slot, STACK stack, boolean simulate);\r\n\r\n    public abstract boolean isEmpty(STACK stack);\r\n\r\n    @SuppressWarnings(\"unused\")\r\n    public abstract STACK getEmptyStack();\r\n\r\n    public abstract boolean matchesStackType(Object o);\r\n\r\n    public boolean matchesStack(ResourceIdentifier<STACK, ITEM, CAP> resourceId, Object stack) {\r\n        if (!matchesStackType(stack)) return false;\r\n        @SuppressWarnings(\"unchecked\") STACK stack_ = (STACK) stack;\r\n        if (isEmpty(stack_)) return false;\r\n        var stackId = getRegistryKey(stack_);\r\n        return resourceId.matchesStack(stackId);\r\n    }\r\n\r\n    public abstract boolean matchesCapabilityType(Object o);\r\n\r\n    public Stream<CAP> getCapabilities(\r\n            ProgramContext programContext, LabelAccess labelAccess\r\n    ) {\r\n        Optional<ItemStack> disk = programContext.getManager().getDisk();\r\n        if (disk.isEmpty()) return Stream.empty();\r\n        LabelPositionHolder labelPositions = LabelPositionHolder.from(disk.get());\r\n        CableNetwork network = programContext.getNetwork();\r\n        return labelAccess.roundRobin().gather(labelAccess, labelPositions)\r\n                .map(network::getCapabilityProvider)\r\n                .filter(Optional::isPresent)\r\n                .map(Optional::get)\r\n                .flatMap((\r\n                                 prov -> labelAccess\r\n                                         .directions()\r\n                                         .stream()\r\n                                         .map(direction -> prov.getCapability(CAPABILITY, direction))\r\n                         ))\r\n                .map(x -> {\r\n                    //noinspection DataFlowIssue\r\n                    return x.orElse(null);\r\n                })\r\n                .filter(x -> {\r\n                    //noinspection ConstantValue,Convert2MethodRef\r\n                    return x != null;\r\n                });\r\n    }\r\n\r\n    public Stream<STACK> collect(CAP cap, LabelAccess labelAccess) {\r\n        var rtn = Stream.<STACK>builder();\r\n        for (int slot = 0; slot < getSlots(cap); slot++) {\r\n            if (!labelAccess.slots().contains(slot)) continue;\r\n            var stack = getStackInSlot(cap, slot);\r\n            if (!isEmpty(stack)) {\r\n                rtn.add(stack);\r\n            }\r\n        }\r\n        return rtn.build();\r\n    }\r\n\r\n    public boolean registryKeyExists(ResourceLocation location) {\r\n        return getRegistry().containsKey(location);\r\n    }\r\n\r\n    public ResourceLocation getRegistryKey(STACK stack) {\r\n        ITEM item = getItem(stack);\r\n        var found = registryKeyCache.get(item);\r\n        if (found != null) return found;\r\n        found = getRegistry().getKey(item);\r\n        assert found != null;\r\n        registryKeyCache.put(item, found);\r\n        return found;\r\n    }\r\n\r\n    public abstract IForgeRegistry<ITEM> getRegistry();\r\n\r\n    public abstract ITEM getItem(STACK stack);\r\n\r\n    public abstract STACK copy(STACK stack);\r\n\r\n    protected abstract STACK setCount(STACK stack, long amount);\r\n\r\n    @SuppressWarnings(\"unused\")\r\n    public STACK withCount(STACK stack, long count) {\r\n        return setCount(copy(stack), count);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\client\\handler\\ContainerScreenInspectorHandler.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.client.handler;\r\n\r\nimport ca.teamdman.sfm.SFM;\r\nimport ca.teamdman.sfm.client.ClientStuff;\r\nimport ca.teamdman.sfm.client.registry.SFMKeyMappings;\r\nimport ca.teamdman.sfm.common.Constants;\r\nimport ca.teamdman.sfm.common.net.ServerboundContainerExportsInspectionRequestPacket;\r\nimport ca.teamdman.sfm.common.registry.SFMPackets;\r\nimport com.mojang.blaze3d.platform.InputConstants;\r\nimport com.mojang.blaze3d.vertex.PoseStack;\r\nimport net.minecraft.ChatFormatting;\r\nimport net.minecraft.client.Minecraft;\r\nimport net.minecraft.client.gui.screens.inventory.AbstractContainerScreen;\r\nimport net.minecraft.network.chat.Component;\r\nimport net.minecraft.world.entity.player.Inventory;\r\nimport net.minecraft.world.inventory.AbstractContainerMenu;\r\nimport net.minecraft.world.level.block.entity.BlockEntity;\r\nimport net.minecraftforge.api.distmarker.Dist;\r\nimport net.minecraftforge.client.event.ScreenEvent;\r\nimport net.minecraftforge.client.gui.widget.ExtendedButton;\r\nimport net.minecraftforge.eventbus.api.SubscribeEvent;\r\nimport net.minecraftforge.fml.common.Mod;\r\n\r\nimport javax.annotation.Nullable;\r\n\r\n@Mod.EventBusSubscriber(modid = SFM.MOD_ID, bus = Mod.EventBusSubscriber.Bus.FORGE, value = Dist.CLIENT)\r\npublic class ContainerScreenInspectorHandler {\r\n    private static boolean visible = false;\r\n    @Nullable\r\n    private static AbstractContainerScreen<?> lastScreen = null;\r\n    private static final ExtendedButton exportInspectorButton = new ExtendedButton(\r\n            5,\r\n            50,\r\n            100,\r\n            20,\r\n            Constants.LocalizationKeys.CONTAINER_INSPECTOR_SHOW_EXPORTS_BUTTON.getComponent(),\r\n            (button) -> {\r\n                BlockEntity lookBlockEntity = ClientStuff.getLookBlockEntity();\r\n                if (lastScreen != null && lookBlockEntity != null) {\r\n                    SFMPackets.INSPECTION_CHANNEL.sendToServer(new ServerboundContainerExportsInspectionRequestPacket(\r\n                            lastScreen.getMenu().containerId,\r\n                            lookBlockEntity.getBlockPos()\r\n                    ));\r\n                }\r\n            }\r\n    );\r\n\r\n    @SubscribeEvent\r\n    public static void onMouseClick(ScreenEvent.KeyPressed.MouseButtonPressed.Pre event) {\r\n        boolean shouldCapture = Minecraft.getInstance().screen instanceof AbstractContainerScreen<?>;\r\n        if (shouldCapture && visible && exportInspectorButton.clicked(event.getMouseX(), event.getMouseY())) {\r\n            exportInspectorButton.playDownSound(Minecraft.getInstance().getSoundManager());\r\n            exportInspectorButton.onClick(event.getMouseX(), event.getMouseY());\r\n            event.setCanceled(true);\r\n        }\r\n    }\r\n\r\n    @SubscribeEvent\r\n    public static void onGuiRender(ScreenEvent.Render.Post event) {\r\n        if (!visible) return;\r\n        if (event.getScreen() instanceof AbstractContainerScreen<?> acs) {\r\n            lastScreen = acs;\r\n            AbstractContainerMenu menu = acs.getMenu();\r\n            int containerSlotCount = 0;\r\n            int inventorySlotCount = 0;\r\n            PoseStack poseStack = event.getPoseStack();\r\n            poseStack.pushPose();\r\n            poseStack.translate(0, 0, 350); // render text over the items but under the tooltips\r\n\r\n            // draw the button\r\n            exportInspectorButton.render(poseStack, event.getMouseX(), event.getMouseY(), event.getPartialTick());\r\n\r\n\r\n            // draw index on each slot\r\n            for (var slot : menu.slots) {\r\n                int colour;\r\n                if (slot.container instanceof Inventory) {\r\n                    //noinspection DataFlowIssue\r\n                    colour = ChatFormatting.YELLOW.getColor();\r\n                    inventorySlotCount++;\r\n                } else {\r\n                    colour = 0xFFF;\r\n                    containerSlotCount++;\r\n                }\r\n                Minecraft.getInstance().font.draw(\r\n                        poseStack,\r\n                        Component.literal(Integer.toString(slot.getSlotIndex())),\r\n                        acs.getGuiLeft() + slot.x,\r\n                        acs.getGuiTop() + slot.y,\r\n                        colour\r\n                );\r\n            }\r\n\r\n            // draw text for slot totals\r\n            Minecraft.getInstance().font.drawShadow(\r\n                    poseStack,\r\n                    Constants.LocalizationKeys.CONTAINER_INSPECTOR_CONTAINER_SLOT_COUNT.getComponent(Component\r\n                                                                                                             .literal(\r\n                                                                                                                     String.valueOf(\r\n                                                                                                                             containerSlotCount))\r\n                                                                                                             .withStyle(\r\n                                                                                                                     ChatFormatting.BLUE)),\r\n                    5,\r\n                    5,\r\n                    0xFFFFFF\r\n            );\r\n            Minecraft.getInstance().font.drawShadow(\r\n                    poseStack,\r\n                    Constants.LocalizationKeys.CONTAINER_INSPECTOR_INVENTORY_SLOT_COUNT.getComponent(Component\r\n                                                                                                             .literal(\r\n                                                                                                                     String.valueOf(\r\n                                                                                                                             inventorySlotCount))\r\n                                                                                                             .withStyle(\r\n                                                                                                                     ChatFormatting.YELLOW)),\r\n                    5,\r\n                    25,\r\n                    0xFFFFFF\r\n            );\r\n            poseStack.popPose();\r\n        }\r\n    }\r\n\r\n    @SubscribeEvent\r\n    public static void onKeyDown(ScreenEvent.KeyPressed.Pre event) {\r\n        var toggleKey = SFMKeyMappings.CONTAINER_INSPECTOR_KEY.get();\r\n        var toggleKeyPressed = toggleKey.isActiveAndMatches(InputConstants.Type.KEYSYM.getOrCreate(event.getKeyCode()));\r\n        if (toggleKeyPressed) {\r\n            visible = !visible;\r\n            event.setCanceled(true);\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\registry\\SFMResourceTypes.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.common.registry;\r\n\r\nimport ca.teamdman.sfm.SFM;\r\nimport ca.teamdman.sfm.common.compat.SFMCompat;\r\nimport ca.teamdman.sfm.common.compat.SFMMekanismCompat;\r\nimport ca.teamdman.sfm.common.resourcetype.FluidResourceType;\r\nimport ca.teamdman.sfm.common.resourcetype.ForgeEnergyResourceType;\r\nimport ca.teamdman.sfm.common.resourcetype.ItemResourceType;\r\nimport ca.teamdman.sfm.common.resourcetype.ResourceType;\r\nimport it.unimi.dsi.fastutil.ints.Int2ObjectArrayMap;\r\nimport net.minecraft.resources.ResourceLocation;\r\nimport net.minecraft.world.item.Item;\r\nimport net.minecraft.world.item.ItemStack;\r\nimport net.minecraft.world.level.material.Fluid;\r\nimport net.minecraftforge.energy.IEnergyStorage;\r\nimport net.minecraftforge.eventbus.api.IEventBus;\r\nimport net.minecraftforge.fluids.FluidStack;\r\nimport net.minecraftforge.fluids.capability.IFluidHandler;\r\nimport net.minecraftforge.items.IItemHandler;\r\nimport net.minecraftforge.registries.DeferredRegister;\r\nimport net.minecraftforge.registries.IForgeRegistry;\r\nimport net.minecraftforge.registries.RegistryBuilder;\r\nimport net.minecraftforge.registries.RegistryObject;\r\n\r\nimport java.util.Objects;\r\nimport java.util.function.Supplier;\r\n\r\npublic class SFMResourceTypes {\r\n    public static final ResourceLocation REGISTRY_ID = new ResourceLocation(SFM.MOD_ID, \"resource_type\");\r\n\r\n    private static final DeferredRegister<ResourceType<?, ?, ?>> TYPES = DeferredRegister.create(\r\n            REGISTRY_ID,\r\n            SFM.MOD_ID\r\n    );\r\n    public static final Supplier<IForgeRegistry<ResourceType<?, ?, ?>>> DEFERRED_TYPES = TYPES.makeRegistry(\r\n            () -> new RegistryBuilder<ResourceType<?, ?, ?>>().setName(\r\n                    REGISTRY_ID));\r\n    public static final RegistryObject<ResourceType<ItemStack, Item, IItemHandler>> ITEM = TYPES.register(\r\n            \"item\",\r\n            ItemResourceType::new\r\n    );\r\n    public static final RegistryObject<ResourceType<FluidStack, Fluid, IFluidHandler>> FLUID = TYPES.register(\r\n            \"fluid\",\r\n            FluidResourceType::new\r\n    );\r\n    public static final RegistryObject<ResourceType<Integer, Class<Integer>, IEnergyStorage>> FORGE_ENERGY = TYPES.register(\r\n            \"forge_energy\",\r\n            ForgeEnergyResourceType::new\r\n    );\r\n\r\n    private static final Int2ObjectArrayMap<ResourceType<?, ?, ?>> DEFERRED_TYPES_BY_ID = new Int2ObjectArrayMap<>();\r\n\r\n    public static ResourceType<?, ?, ?> fastLookup(String resourceTypeNamespace, String resourceTypeName) {\r\n//        return DEFERRED_TYPES.get().getValue(new ResourceLocation(resourceTypeNamespace, resourceTypeName));\r\n        return Objects.requireNonNull(DEFERRED_TYPES_BY_ID.computeIfAbsent(\r\n                resourceTypeNamespace.hashCode() ^ resourceTypeName.hashCode(),\r\n                i -> DEFERRED_TYPES.get().getValue(new ResourceLocation(resourceTypeNamespace, resourceTypeName))\r\n        ));\r\n    }\r\n\r\n    static {\r\n        if (SFMCompat.isMekanismLoaded()) {\r\n            SFMMekanismCompat.register(TYPES);\r\n        }\r\n    }\r\n\r\n    public static void register(IEventBus bus) {\r\n        TYPES.register(bus);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\net\\ServerboundOutputInspectionRequestPacket.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.common.net;\r\n\r\nimport ca.teamdman.sfm.common.blockentity.ManagerBlockEntity;\r\nimport ca.teamdman.sfm.common.containermenu.ManagerContainerMenu;\r\nimport ca.teamdman.sfm.common.program.LimitedInputSlot;\r\nimport ca.teamdman.sfm.common.program.ProgramContext;\r\nimport ca.teamdman.sfm.common.registry.SFMPackets;\r\nimport ca.teamdman.sfm.common.registry.SFMResourceTypes;\r\nimport ca.teamdman.sfm.common.resourcetype.ResourceType;\r\nimport ca.teamdman.sfm.common.util.SFMUtils;\r\nimport ca.teamdman.sfml.ast.Number;\r\nimport ca.teamdman.sfml.ast.*;\r\nimport net.minecraft.network.FriendlyByteBuf;\r\nimport net.minecraft.resources.ResourceKey;\r\nimport net.minecraft.resources.ResourceLocation;\r\nimport net.minecraft.server.level.ServerPlayer;\r\nimport net.minecraftforge.network.NetworkEvent;\r\nimport net.minecraftforge.network.PacketDistributor;\r\nimport org.antlr.v4.runtime.misc.Pair;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.ListIterator;\r\nimport java.util.Optional;\r\nimport java.util.function.Supplier;\r\n\r\npublic record ServerboundOutputInspectionRequestPacket(\r\n        String programString,\r\n        int outputNodeIndex\r\n) {\r\n    public static void encode(ServerboundOutputInspectionRequestPacket msg, FriendlyByteBuf friendlyByteBuf) {\r\n        friendlyByteBuf.writeUtf(msg.programString, Program.MAX_PROGRAM_LENGTH);\r\n        friendlyByteBuf.writeInt(msg.outputNodeIndex());\r\n    }\r\n\r\n    public static ServerboundOutputInspectionRequestPacket decode(FriendlyByteBuf friendlyByteBuf) {\r\n        return new ServerboundOutputInspectionRequestPacket(\r\n                friendlyByteBuf.readUtf(Program.MAX_PROGRAM_LENGTH),\r\n                friendlyByteBuf.readInt()\r\n        );\r\n    }\r\n\r\n    private static <STACK, ITEM, CAP> ResourceLimit<STACK, ITEM, CAP> getSlotResource(\r\n            LimitedInputSlot<STACK, ITEM, CAP> limitedInputSlot\r\n    ) {\r\n        ResourceType<STACK, ITEM, CAP> resourceType = limitedInputSlot.type;\r\n        //noinspection OptionalGetWithoutIsPresent\r\n        ResourceKey<ResourceType<STACK, ITEM, CAP>> resourceTypeResourceKey = SFMResourceTypes.DEFERRED_TYPES\r\n                .get()\r\n                .getResourceKey(limitedInputSlot.type)\r\n                .map(x -> {\r\n                    //noinspection unchecked,rawtypes\r\n                    return (ResourceKey<ResourceType<STACK, ITEM, CAP>>) (ResourceKey) x;\r\n                })\r\n                .get();\r\n        STACK stack = limitedInputSlot.peekExtractPotential();\r\n        long amount = limitedInputSlot.type.getAmount(stack);\r\n        amount = Long.min(amount, limitedInputSlot.tracker.getResourceLimit().limit().quantity().number().value());\r\n        long remainingObligation = limitedInputSlot.tracker.getRemainingRetentionObligation();\r\n        amount -= Long.min(amount, remainingObligation);\r\n        Limit amountLimit = new Limit(\r\n                new ResourceQuantity(new Number(amount), ResourceQuantity.IdExpansionBehaviour.NO_EXPAND),\r\n                ResourceQuantity.MAX_QUANTITY\r\n        );\r\n        ResourceLocation stackId = resourceType.getRegistryKey(stack);\r\n        ResourceIdentifier<STACK, ITEM, CAP> resourceIdentifier = new ResourceIdentifier<>(\r\n                resourceTypeResourceKey.location().getNamespace(),\r\n                resourceTypeResourceKey.location().getPath(),\r\n                stackId.getNamespace(),\r\n                stackId.getPath()\r\n        );\r\n        return new ResourceLimit<>(\r\n                resourceIdentifier,\r\n                amountLimit\r\n        );\r\n    }\r\n\r\n\r\n    public static void handle(\r\n            ServerboundOutputInspectionRequestPacket msg,\r\n            Supplier<NetworkEvent.Context> contextSupplier\r\n    ) {\r\n        contextSupplier.get().enqueueWork(() -> {\r\n            // we don't know if the player has the program edit screen open from a manager or a disk in hand\r\n            ServerPlayer player = contextSupplier.get().getSender();\r\n            if (player == null) return;\r\n            ManagerBlockEntity manager;\r\n            if (player.containerMenu instanceof ManagerContainerMenu mcm) {\r\n                if (player.getLevel().getBlockEntity(mcm.MANAGER_POSITION) instanceof ManagerBlockEntity mbe) {\r\n                    manager = mbe;\r\n                } else {\r\n                    return;\r\n                }\r\n            } else {\r\n                //todo: localize\r\n                SFMPackets.INSPECTION_CHANNEL.send(\r\n                        PacketDistributor.PLAYER.with(() -> player),\r\n                        new ClientboundInputInspectionResultsPacket(\r\n                                \"This inspection is only available when editing inside a manager.\")\r\n                );\r\n                return;\r\n            }\r\n            Program.compile(\r\n                    msg.programString,\r\n                    (successProgram, builder) -> builder\r\n                            .getNodeAtIndex(msg.outputNodeIndex)\r\n                            .filter(OutputStatement.class::isInstance)\r\n                            .map(OutputStatement.class::cast)\r\n                            .ifPresent(outputStatement -> {\r\n                                StringBuilder payload = new StringBuilder();\r\n                                payload.append(outputStatement.toStringPretty()).append(\"\\n\");\r\n                                payload.append(\"-- predictions may differ from actual execution results\\n\");\r\n\r\n                                successProgram.replaceOutputStatement(outputStatement, new OutputStatement(\r\n                                        outputStatement.labelAccess(),\r\n                                        outputStatement.resourceLimits(),\r\n                                        outputStatement.each()\r\n                                ) {\r\n                                    @Override\r\n                                    public void tick(ProgramContext context) {\r\n                                        StringBuilder branchPayload = new StringBuilder();\r\n\r\n                                        if (!context.getExecutionPath().isEmpty()) {\r\n                                            payload\r\n                                                    .append(\"-- POSSIBILITY \")\r\n                                                    .append(context.getExplorationBranchIndex())\r\n                                                    .append(\" --\\n\");\r\n                                            context.getExecutionPath().forEach(branch -> {\r\n                                                if (branch.wasTrue()) {\r\n                                                    payload\r\n                                                            .append(branch.ifStatement().condition().sourceCode())\r\n                                                            .append(\" -- true\");\r\n                                                } else {\r\n                                                    payload.append(branch\r\n                                                                           .ifStatement()\r\n                                                                           .condition()\r\n                                                                           .negate()\r\n                                                                           .sourceCode());\r\n                                                }\r\n                                                payload.append(\"\\n\");\r\n                                            });\r\n                                            payload.append(\"\\n\");\r\n                                        }\r\n\r\n                                        branchPayload.append(\"-- predicted inputs:\\n\");\r\n                                        List<Pair<LimitedInputSlot<?, ?, ?>, LabelAccess>> inputSlots = new ArrayList<>();\r\n                                        context\r\n                                                .getInputs()\r\n                                                .forEach(inputStatement -> inputStatement.gatherSlots(\r\n                                                        context,\r\n                                                        slot -> inputSlots.add(new Pair<>(\r\n                                                                slot,\r\n                                                                inputStatement.labelAccess()\r\n                                                        ))\r\n                                                ));\r\n                                        List<InputStatement> inputStatements = inputSlots.stream()\r\n                                                .map(slot -> SFMUtils.getInputStatementForSlot(slot.a, slot.b))\r\n                                                .filter(Optional::isPresent)\r\n                                                .map(Optional::get)\r\n                                                .toList();\r\n                                        if (inputStatements.isEmpty()) {\r\n                                            branchPayload.append(\"none\\n-- predicted outputs:\\nnone\");\r\n                                        } else {\r\n                                            inputStatements.stream()\r\n                                                    .map(InputStatement::toStringPretty)\r\n                                                    .map(x -> x + \"\\n\")\r\n                                                    .forEach(branchPayload::append);\r\n\r\n                                            branchPayload.append(\r\n                                                    \"-- predicted outputs:\\n\");\r\n                                            ResourceLimits condensedResourceLimits;\r\n                                            {\r\n                                                ResourceLimits resourceLimits = new ResourceLimits(\r\n                                                        inputSlots\r\n                                                                .stream()\r\n                                                                .map(slot -> slot.a)\r\n                                                                .map(ServerboundOutputInspectionRequestPacket::getSlotResource)\r\n                                                                .toList(),\r\n                                                        ResourceIdSet.EMPTY\r\n                                                );\r\n                                                List<ResourceLimit<?, ?, ?>> condensedResourceLimitList = new ArrayList<>();\r\n                                                for (ResourceLimit<?, ?, ?> resourceLimit : resourceLimits.resourceLimits()) {\r\n                                                    // check if an existing resource limit has the same resource identifier\r\n                                                    condensedResourceLimitList\r\n                                                            .stream()\r\n                                                            .filter(x -> x\r\n                                                                    .resourceId()\r\n                                                                    .equals(resourceLimit.resourceId()))\r\n                                                            .findFirst()\r\n                                                            .ifPresentOrElse(found -> {\r\n                                                                int i = condensedResourceLimitList.indexOf(found);\r\n                                                                ResourceLimit<?, ?, ?> newLimit = found.withLimit(new Limit(\r\n                                                                        found\r\n                                                                                .limit()\r\n                                                                                .quantity()\r\n                                                                                .add(resourceLimit.limit().quantity()),\r\n                                                                        ResourceQuantity.MAX_QUANTITY\r\n                                                                ));\r\n                                                                condensedResourceLimitList.set(i, newLimit);\r\n                                                            }, () -> condensedResourceLimitList.add(resourceLimit));\r\n                                                }\r\n                                                {\r\n                                                    // prune items not covered by the output resource limits\r\n                                                    ListIterator<ResourceLimit<?, ?, ?>> iter = condensedResourceLimitList.listIterator();\r\n                                                    while (iter.hasNext()) {\r\n                                                        ResourceLimit<?, ?, ?> resourceLimit = iter.next();\r\n                                                        // because these resource limits were generated from resource stacks\r\n                                                        // they should always be valid resource locations (not patterns)\r\n                                                        ResourceLocation resourceLimitLocation = new ResourceLocation(\r\n                                                                resourceLimit.resourceId().resourceNamespace,\r\n                                                                resourceLimit.resourceId().resourceName\r\n                                                        );\r\n                                                        long accept = outputStatement\r\n                                                                .resourceLimits()\r\n                                                                .resourceLimits()\r\n                                                                .stream()\r\n                                                                .filter(outputResourceLimit -> outputResourceLimit\r\n                                                                                                       .resourceId()\r\n                                                                                                       .matchesStack(\r\n                                                                                                               resourceLimitLocation)\r\n                                                                                               && outputStatement\r\n                                                                                                       .resourceLimits()\r\n                                                                                                       .exclusions()\r\n                                                                                                       .resourceIds()\r\n                                                                                                       .stream()\r\n                                                                                                       .noneMatch(\r\n                                                                                                               exclusion -> exclusion.matchesStack(\r\n                                                                                                                       resourceLimitLocation)))\r\n                                                                .mapToLong(rl -> rl.limit().quantity().number().value())\r\n                                                                .max()\r\n                                                                .orElse(0);\r\n                                                        if (accept == 0) {\r\n                                                            iter.remove();\r\n                                                        } else {\r\n                                                            iter.set(resourceLimit.withLimit(new Limit(\r\n                                                                    new ResourceQuantity(new Number(Long.min(\r\n                                                                            accept,\r\n                                                                            resourceLimit\r\n                                                                                    .limit()\r\n                                                                                    .quantity()\r\n                                                                                    .number()\r\n                                                                                    .value()\r\n                                                                    )), resourceLimit.limit().quantity()\r\n                                                                                                 .idExpansionBehaviour()),\r\n                                                                    ResourceQuantity.MAX_QUANTITY\r\n                                                            )));\r\n                                                        }\r\n                                                    }\r\n                                                }\r\n                                                condensedResourceLimits = new ResourceLimits(\r\n                                                        condensedResourceLimitList,\r\n                                                        ResourceIdSet.EMPTY\r\n                                                );\r\n                                            }\r\n                                            if (condensedResourceLimits.resourceLimits().isEmpty()) {\r\n                                                branchPayload.append(\"none\\n\");\r\n                                            } else {\r\n                                                branchPayload\r\n                                                        .append(new OutputStatement(\r\n                                                                outputStatement.labelAccess(),\r\n                                                                condensedResourceLimits,\r\n                                                                outputStatement.each()\r\n                                                        ).toStringPretty());\r\n                                            }\r\n\r\n                                        }\r\n                                        branchPayload.append(\"\\n\");\r\n                                        if (successProgram.getConditionCount() == 0) {\r\n                                            payload.append(branchPayload);\r\n                                        } else {\r\n                                            payload.append(branchPayload.toString().indent(4));\r\n                                        }\r\n                                    }\r\n                                });\r\n\r\n                                // run the program down each possible if-branch combination\r\n                                for (\r\n                                        int branchIndex = 0;\r\n                                        branchIndex < Math.pow(2, successProgram.getConditionCount());\r\n                                        branchIndex++\r\n                                ) {\r\n                                    successProgram.tick(new ProgramContext(\r\n                                            successProgram,\r\n                                            manager,\r\n                                            ProgramContext.ExecutionPolicy.EXPLORE_BRANCHES,\r\n                                            branchIndex\r\n                                    ));\r\n                                }\r\n\r\n\r\n                                SFMPackets.INSPECTION_CHANNEL.send(\r\n                                        PacketDistributor.PLAYER.with(() -> player),\r\n                                        new ClientboundOutputInspectionResultsPacket(payload.toString().strip())\r\n                                );\r\n                            }),\r\n                    failure -> {\r\n                        //todo: translate\r\n                        SFMPackets.INSPECTION_CHANNEL.send(\r\n                                PacketDistributor.PLAYER.with(() -> player),\r\n                                new ClientboundOutputInspectionResultsPacket(\"failed to compile program\")\r\n                        );\r\n                    }\r\n            );\r\n        });\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfml\\ast\\OutputStatement.java\r\n\r\n````java\r\npackage ca.teamdman.sfml.ast;\r\n\r\nimport ca.teamdman.sfm.SFM;\r\nimport ca.teamdman.sfm.common.program.*;\r\nimport ca.teamdman.sfm.common.resourcetype.ResourceType;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.Objects;\r\nimport java.util.function.Consumer;\r\nimport java.util.stream.Collectors;\r\nimport java.util.stream.Stream;\r\n\r\npublic class OutputStatement implements Statement {\r\n    private final LabelAccess labelAccess;\r\n    private final ResourceLimits resourceLimits;\r\n    private final boolean each;\r\n\r\n    private int lastInputCapacity = 32;\r\n    private int lastOutputCapacity = 32;\r\n\r\n    public OutputStatement(\r\n            LabelAccess labelAccess,\r\n            ResourceLimits resourceLimits,\r\n            boolean each\r\n    ) {\r\n        this.labelAccess = labelAccess;\r\n        this.resourceLimits = resourceLimits;\r\n        this.each = each;\r\n    }\r\n\r\n    /**\r\n     * Juicy method function here.\r\n     * Given two slots, move as much as possible from one to the other.\r\n     *\r\n     * @param source      The slot to pull from\r\n     * @param destination the slot to push to\r\n     * @param <STACK>     the stack type\r\n     * @param <ITEM>      the item type\r\n     * @param <CAP>       the capability type\r\n     */\r\n    public static <STACK, ITEM, CAP> void moveTo(\r\n            LimitedInputSlot<STACK, ITEM, CAP> source, LimitedOutputSlot<STACK, ITEM, CAP> destination\r\n    ) {\r\n        // always ensure types match\r\n        // items and fluids are incompatible, etc\r\n        if (!source.type.equals(destination.type)) return;\r\n\r\n        // find out what we can pull out\r\n        // should never be empty by the time we get here\r\n        STACK potential = source.peekExtractPotential();\r\n        // ensure the output slot allows this item\r\n        if (!destination.tracker.test(potential)) return;\r\n        // find out how much we can fit\r\n        STACK remainder = destination.insert(potential, true);\r\n\r\n        // how many can we move before accounting for limits\r\n        long toMove = source.type.getAmount(potential) - source.type.getAmount(remainder);\r\n        if (toMove == 0) return;\r\n\r\n        // how many have we promised to RETAIN in this slot\r\n        toMove -= source.tracker.getExistingRetentionObligation(source.slot);\r\n        // how many more need we are obligated to leave to satisfy the remainder of the RETAIN limit\r\n        long remainingObligation = source.tracker.getRemainingRetentionObligation();\r\n        remainingObligation = Long.min(toMove, remainingObligation);\r\n        toMove -= remainingObligation;\r\n\r\n        // update the obligation tracker\r\n        source.tracker.trackRetentionObligation(source.slot, remainingObligation);\r\n\r\n        // if we can't move anything after our retention obligations, we're done\r\n        if (toMove == 0) {\r\n            source.setDone();\r\n            return;\r\n        }\r\n\r\n        // apply output constraints\r\n        toMove = Math.min(toMove, destination.tracker.getMaxTransferable());\r\n\r\n        // apply input constraints\r\n        toMove = Math.min(toMove, source.tracker.getMaxTransferable());\r\n\r\n        // apply resource constraints\r\n        toMove = Math.min(toMove, source.type.getMaxStackSize(potential));\r\n        if (toMove <= 0) return;\r\n\r\n        // extract item for real\r\n        STACK extracted = source.extract(toMove);\r\n        // insert item for real\r\n        remainder = destination.insert(extracted, false);\r\n        var moved = source.type.getAmount(extracted) - source.type.getAmount(remainder);\r\n        // track transfer amounts\r\n        source.tracker.trackTransfer(moved);\r\n        destination.tracker.trackTransfer(moved);\r\n\r\n        // if remainder exists, someone lied.\r\n        // this should never happen\r\n        // will void items if it does\r\n        if (!destination.type.isEmpty(remainder)) {\r\n            SFM.LOGGER.error(\r\n                    \"Failed to move all promised items, took {} but had {} left over after insertion.\",\r\n                    extracted,\r\n                    remainder\r\n            );\r\n        }\r\n    }\r\n\r\n    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\r\n    @Override\r\n    public void tick(ProgramContext context) {\r\n        if (context.getExecutionPolicy() == ProgramContext.ExecutionPolicy.EXPLORE_BRANCHES) return;\r\n        // gather the input slots from all the input statements, +27 to hopefully avoid resizing\r\n        List<LimitedInputSlot> inputSlots = new ArrayList<>(lastInputCapacity + 27);\r\n        for (var inputStatement : context.getInputs()) {\r\n            inputStatement.gatherSlots(context, inputSlots::add);\r\n        }\r\n        if (inputSlots.isEmpty()) return; // stop if we have nothing to move\r\n        lastInputCapacity = inputSlots.size();\r\n\r\n        // collect the output slots, +27 to hopefully avoid resizing\r\n        List<LimitedOutputSlot> outputSlots = new ArrayList<>(lastOutputCapacity + 27);\r\n        gatherSlots(context, outputSlots::add);\r\n        lastOutputCapacity = outputSlots.size();\r\n\r\n        // try and move resources from input slots to output slots\r\n        var inIt = inputSlots.iterator();\r\n        while (inIt.hasNext()) {\r\n            var in = inIt.next();\r\n            if (in.isDone()) { // this slot is no longer useful\r\n                inIt.remove(); // ensure we only release slots once\r\n                InputStatement.releaseSlot(in); // release the slot to the object pool\r\n                continue;\r\n            }\r\n            var outIt = outputSlots.iterator();\r\n            while (outIt.hasNext()) {\r\n                var out = outIt.next();\r\n                if (out.isDone()) { // this slot is no longer useful\r\n                    outIt.remove(); // ensure we only release slots once\r\n                    LimitedOutputSlotObjectPool.INSTANCE.release(out); // release the slot to the object pool\r\n                    continue;\r\n                }\r\n                moveTo(in, out); // move the contents from the \"in\" slot to the \"out\" slot\r\n                if (in.isDone()) break; // stop processing output slots if we have nothing to move\r\n            }\r\n            if (outputSlots.isEmpty()) break; // stop processing input slots if we have no output slots\r\n        }\r\n\r\n        LimitedOutputSlotObjectPool.INSTANCE.release(outputSlots);\r\n        InputStatement.releaseSlots(inputSlots);\r\n    }\r\n\r\n    /**\r\n     * The output statement contains labels.\r\n     * Each block in the world can have more than one programString.\r\n     * Each block can have a block entity.\r\n     * Each block entity can have 0 or more slots.\r\n     * <p>\r\n     * We want collect the slots from all the labelled blocks.\r\n     */\r\n    @SuppressWarnings({\"rawtypes\", \"unchecked\"}) // basically impossible to make this method generic safe\r\n    public void gatherSlots(ProgramContext context, Consumer<LimitedOutputSlot<?, ?, ?>> acceptor) {\r\n        // find all the types referenced in the output statement\r\n        Stream<ResourceType> types = resourceLimits\r\n                .resourceLimits()\r\n                .stream()\r\n                .map(ResourceLimit::resourceId)\r\n                .map((ResourceIdentifier x) -> x.getResourceType())\r\n                .distinct();\r\n\r\n        if (!each) {\r\n            // create a single matcher to be shared by all capabilities\r\n            List<OutputResourceTracker<?, ?, ?>> outputTracker = resourceLimits.createOutputTrackers();\r\n            for (var type : (Iterable<ResourceType>) types::iterator) {\r\n                for (var cap : (Iterable<?>) type.getCapabilities(context, labelAccess)::iterator) {\r\n                    gatherSlots((ResourceType<Object, Object, Object>) type, cap, outputTracker, acceptor);\r\n                }\r\n            }\r\n        } else {\r\n            for (var type : (Iterable<ResourceType>) types::iterator) {\r\n                for (var cap : (Iterable<?>) type.getCapabilities(context, labelAccess)::iterator) {\r\n                    List<OutputResourceTracker<?, ?, ?>> outputTracker = resourceLimits.createOutputTrackers();\r\n                    gatherSlots((ResourceType<Object, Object, Object>) type, cap, outputTracker, acceptor);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private <STACK, ITEM, CAP> void gatherSlots(\r\n            ResourceType<STACK, ITEM, CAP> type,\r\n            CAP capability,\r\n            List<OutputResourceTracker<?, ?, ?>> trackers,\r\n            Consumer<LimitedOutputSlot<?, ?, ?>> acceptor\r\n    ) {\r\n        for (int slot = 0; slot < type.getSlots(capability); slot++) {\r\n            if (labelAccess.slots().contains(slot)) {\r\n                for (OutputResourceTracker<?, ?, ?> tracker : trackers) {\r\n                    if (tracker.matchesCapabilityType(capability)) {\r\n                        //noinspection unchecked\r\n                        acceptor.accept(LimitedOutputSlotObjectPool.INSTANCE.acquire(\r\n                                capability,\r\n                                slot,\r\n                                (OutputResourceTracker<STACK, ITEM, CAP>) tracker\r\n                        ));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public LabelAccess labelAccess() {\r\n        return labelAccess;\r\n    }\r\n\r\n    public ResourceLimits resourceLimits() {\r\n        return resourceLimits;\r\n    }\r\n\r\n    public boolean each() {\r\n        return each;\r\n    }\r\n\r\n    @Override\r\n    public boolean equals(Object obj) {\r\n        if (obj == this) return true;\r\n        if (obj == null || obj.getClass() != this.getClass()) return false;\r\n        var that = (OutputStatement) obj;\r\n        return Objects.equals(this.labelAccess, that.labelAccess) &&\r\n               Objects.equals(this.resourceLimits, that.resourceLimits) &&\r\n               this.each == that.each;\r\n    }\r\n\r\n    @Override\r\n    public int hashCode() {\r\n        return Objects.hash(labelAccess, resourceLimits, each);\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"OUTPUT \" + resourceLimits + \" TO \" + (each ? \"EACH \" : \"\") + labelAccess;\r\n    }\r\n\r\n    public String toStringPretty() {\r\n        StringBuilder sb = new StringBuilder();\r\n        sb.append(\"OUTPUT\");\r\n        String rls = resourceLimits.toStringPretty(Limit.MAX_QUANTITY_MAX_RETENTION);\r\n        if (rls.lines().count() > 1) {\r\n            sb.append(\"\\n\");\r\n            sb.append(rls.lines().map(s -> \"  \" + s).collect(Collectors.joining(\"\\n\")));\r\n            sb.append(\"\\n\");\r\n        } else {\r\n            sb.append(\" \");\r\n            sb.append(rls);\r\n            sb.append(\" \");\r\n        }\r\n        sb.append(\"TO \");\r\n        sb.append(each ? \"EACH \" : \"\");\r\n        sb.append(labelAccess);\r\n        return sb.toString();\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\registry\\package-info.java\r\n\r\n````java\r\n\r\n\r\n@ParametersAreNonnullByDefault\r\n@MethodsReturnNonnullByDefault\r\n@FieldsAreNonnullByDefault\r\npackage ca.teamdman.sfm.common.registry;\r\n\r\nimport net.minecraft.FieldsAreNonnullByDefault;\r\nimport net.minecraft.MethodsReturnNonnullByDefault;\r\n\r\nimport javax.annotation.ParametersAreNonnullByDefault;\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\cablenetwork\\package-info.java\r\n\r\n````java\r\n\r\n@ParametersAreNonnullByDefault\r\n@MethodsReturnNonnullByDefault\r\n@FieldsAreNonnullByDefault\r\npackage ca.teamdman.sfm.common.cablenetwork;\r\n\r\nimport net.minecraft.FieldsAreNonnullByDefault;\r\nimport net.minecraft.MethodsReturnNonnullByDefault;\r\n\r\nimport javax.annotation.ParametersAreNonnullByDefault;\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\client\\jei\\PrintingPressJEICategory.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.client.jei;\r\n\r\nimport ca.teamdman.sfm.SFM;\r\nimport ca.teamdman.sfm.common.Constants;\r\nimport ca.teamdman.sfm.common.item.FormItem;\r\nimport ca.teamdman.sfm.common.recipe.PrintingPressRecipe;\r\nimport ca.teamdman.sfm.common.registry.SFMBlocks;\r\nimport mezz.jei.api.gui.builder.IRecipeLayoutBuilder;\r\nimport mezz.jei.api.gui.drawable.IDrawable;\r\nimport mezz.jei.api.helpers.IJeiHelpers;\r\nimport mezz.jei.api.recipe.IFocusGroup;\r\nimport mezz.jei.api.recipe.RecipeIngredientRole;\r\nimport mezz.jei.api.recipe.RecipeType;\r\nimport mezz.jei.api.recipe.category.IRecipeCategory;\r\nimport net.minecraft.network.chat.Component;\r\nimport net.minecraft.world.item.ItemStack;\r\n\r\nimport java.util.Arrays;\r\n\r\npublic class PrintingPressJEICategory implements IRecipeCategory<PrintingPressRecipe> {\r\n\r\n    public static final RecipeType<PrintingPressRecipe> RECIPE_TYPE = RecipeType.create(\r\n            SFM.MOD_ID,\r\n            \"printing_press\",\r\n            PrintingPressRecipe.class\r\n    );\r\n    private final IDrawable background;\r\n    private final IDrawable icon;\r\n    private final IDrawable slot;\r\n\r\n    public PrintingPressJEICategory(IJeiHelpers jeiHelpers) {\r\n        background = jeiHelpers.getGuiHelper().createBlankDrawable(50, 54);\r\n        icon = jeiHelpers.getGuiHelper().createDrawableItemStack(new ItemStack(SFMBlocks.PRINTING_PRESS_BLOCK.get()));\r\n        slot = jeiHelpers.getGuiHelper().getSlotDrawable();\r\n    }\r\n\r\n    @Override\r\n    public RecipeType<PrintingPressRecipe> getRecipeType() {\r\n        return RECIPE_TYPE;\r\n    }\r\n\r\n    @Override\r\n    public Component getTitle() {\r\n        return Constants.LocalizationKeys.PRINTING_PRESS_JEI_CATEGORY_TITLE.getComponent();\r\n    }\r\n\r\n    @Override\r\n    public IDrawable getBackground() {\r\n        return background;\r\n    }\r\n\r\n    @Override\r\n    public IDrawable getIcon() {\r\n        return icon;\r\n    }\r\n\r\n    @Override\r\n    public void setRecipe(IRecipeLayoutBuilder builder, PrintingPressRecipe recipe, IFocusGroup focuses) {\r\n        builder\r\n                .addSlot(RecipeIngredientRole.INPUT, 0, 0)\r\n                .addItemStacks(Arrays.stream(recipe.FORM.getItems()).map(FormItem::getForm).toList())\r\n                .setBackground(slot, -1, -1);\r\n        builder.addSlot(RecipeIngredientRole.INPUT, 0, 18).addIngredients(recipe.INK).setBackground(slot, -1, -1);\r\n        builder.addSlot(RecipeIngredientRole.INPUT, 0, 36).addIngredients(recipe.PAPER).setBackground(slot, -1, -1);\r\n        builder.addSlot(RecipeIngredientRole.OUTPUT, 25, 18).addIngredients(recipe.FORM);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\client\\gui\\screen\\ExtendedButtonWithTooltip.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.client.gui.screen;\r\n\r\nimport com.mojang.blaze3d.vertex.PoseStack;\r\nimport net.minecraft.network.chat.Component;\r\nimport net.minecraftforge.client.gui.widget.ExtendedButton;\r\n\r\npublic class ExtendedButtonWithTooltip extends ExtendedButton {\r\n    private final OnTooltip TOOLTIP;\r\n\r\n    public ExtendedButtonWithTooltip(\r\n            int xPos,\r\n            int yPos,\r\n            int width,\r\n            int height,\r\n            Component displayString,\r\n            OnPress handler,\r\n            OnTooltip tooltip\r\n    ) {\r\n        super(xPos, yPos, width, height, displayString, handler);\r\n        TOOLTIP = tooltip;\r\n    }\r\n\r\n    @Override\r\n    public void renderToolTip(PoseStack pose, int mx, int my) {\r\n        if (isHovered && visible) {\r\n            TOOLTIP.onTooltip(this, pose, mx, my);\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\client\\ClientStuff.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.client;\r\n\r\nimport ca.teamdman.sfm.SFM;\r\nimport ca.teamdman.sfm.client.gui.screen.LabelGunScreen;\r\nimport ca.teamdman.sfm.client.gui.screen.ProgramEditScreen;\r\nimport ca.teamdman.sfm.client.registry.SFMKeyMappings;\r\nimport ca.teamdman.sfm.client.render.PrintingPressBlockEntityRenderer;\r\nimport ca.teamdman.sfm.common.containermenu.ManagerContainerMenu;\r\nimport ca.teamdman.sfm.common.item.DiskItem;\r\nimport ca.teamdman.sfm.common.net.ClientboundManagerGuiPacket;\r\nimport ca.teamdman.sfm.common.registry.SFMBlockEntities;\r\nimport com.mojang.blaze3d.platform.InputConstants;\r\nimport net.minecraft.client.Minecraft;\r\nimport net.minecraft.client.multiplayer.ClientLevel;\r\nimport net.minecraft.client.player.LocalPlayer;\r\nimport net.minecraft.world.InteractionHand;\r\nimport net.minecraft.world.item.ItemStack;\r\nimport net.minecraft.world.level.block.entity.BlockEntity;\r\nimport net.minecraft.world.phys.BlockHitResult;\r\nimport net.minecraft.world.phys.HitResult;\r\nimport net.minecraftforge.api.distmarker.Dist;\r\nimport net.minecraftforge.client.event.EntityRenderersEvent;\r\nimport net.minecraftforge.eventbus.api.SubscribeEvent;\r\nimport net.minecraftforge.fml.common.Mod;\r\nimport net.minecraftforge.fml.loading.FMLEnvironment;\r\n\r\nimport javax.annotation.Nullable;\r\nimport java.util.function.Consumer;\r\n\r\n@Mod.EventBusSubscriber(modid = SFM.MOD_ID, value = Dist.CLIENT, bus = Mod.EventBusSubscriber.Bus.MOD)\r\npublic class ClientStuff {\r\n    public static void showLabelGunScreen(ItemStack stack, InteractionHand hand) {\r\n        Minecraft\r\n                .getInstance()\r\n                .setScreen(new LabelGunScreen(stack, hand));\r\n    }\r\n\r\n    public static void showProgramEditScreen(String initialContent, Consumer<String> callback) {\r\n        ProgramEditScreen screen = new ProgramEditScreen(initialContent, callback);\r\n        if (Minecraft.getInstance().screen == null) {\r\n            Minecraft\r\n                    .getInstance()\r\n                    .setScreen(screen);\r\n        } else {\r\n            Minecraft\r\n                    .getInstance()\r\n                    .pushGuiLayer(screen);\r\n        }\r\n        screen.scrollToTop();\r\n    }\r\n\r\n    public static void showProgramEditScreen(ItemStack diskItem, Consumer<String> callback) {\r\n        showProgramEditScreen(DiskItem.getProgram(diskItem), callback);\r\n    }\r\n\r\n    @SubscribeEvent\r\n    public static void onRegisterRenderers(EntityRenderersEvent.RegisterRenderers event) {\r\n        event.registerBlockEntityRenderer(\r\n                SFMBlockEntities.PRINTING_PRESS_BLOCK_ENTITY.get(),\r\n                PrintingPressBlockEntityRenderer::new\r\n        );\r\n    }\r\n\r\n    public static boolean isMoreInfoKeyDown() {\r\n        // special effort is needed to ensure this works properly when the manager screen is open\r\n        // https://github.com/mekanism/Mekanism/blob/f92b48a49e0766cd3aa78e95c9c4a47ba90402f5/src/main/java/mekanism/client/key/MekKeyHandler.java\r\n        long handle = Minecraft.getInstance().getWindow().getWindow();\r\n        return InputConstants.isKeyDown(\r\n                handle,\r\n                SFMKeyMappings.MORE_INFO_TOOLTIP_KEY\r\n                        .get()\r\n                        .getKey()\r\n                        .getValue()\r\n        );\r\n    }\r\n\r\n    public static void updateMenu(ClientboundManagerGuiPacket msg) {\r\n        LocalPlayer player = Minecraft.getInstance().player;\r\n        if (player == null) return;\r\n        var container = player.containerMenu;\r\n        if (container instanceof ManagerContainerMenu menu && container.containerId == msg.windowId()) {\r\n            menu.tickTimeNanos = msg.tickTimes();\r\n            menu.state = msg.state();\r\n            menu.program = msg.program();\r\n        }\r\n    }\r\n\r\n    public static @Nullable BlockEntity getLookBlockEntity() {\r\n        assert FMLEnvironment.dist.isClient();\r\n        ClientLevel level = Minecraft.getInstance().level;\r\n        if (level == null) return null;\r\n        HitResult hr = Minecraft.getInstance().hitResult;\r\n        if (hr == null) return null;\r\n        if (hr.getType() != HitResult.Type.BLOCK) return null;\r\n        var pos = ((BlockHitResult) hr).getBlockPos();\r\n        return level.getBlockEntity(pos);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\item\\ExperienceShard.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.common.item;\r\n\r\nimport ca.teamdman.sfm.common.registry.SFMItems;\r\nimport net.minecraft.world.item.Item;\r\n\r\npublic class ExperienceShard extends Item {\r\n    public ExperienceShard() {\r\n        super(new Item.Properties().tab(SFMItems.TAB));\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\item\\PrintingPressBlockItem.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.common.item;\r\n\r\nimport ca.teamdman.sfm.common.Constants;\r\nimport ca.teamdman.sfm.common.registry.SFMBlocks;\r\nimport ca.teamdman.sfm.common.registry.SFMItems;\r\nimport net.minecraft.ChatFormatting;\r\nimport net.minecraft.network.chat.Component;\r\nimport net.minecraft.world.item.BlockItem;\r\nimport net.minecraft.world.item.ItemStack;\r\nimport net.minecraft.world.item.TooltipFlag;\r\nimport net.minecraft.world.level.Level;\r\nimport org.jetbrains.annotations.Nullable;\r\n\r\nimport java.util.List;\r\n\r\npublic class PrintingPressBlockItem extends BlockItem {\r\n    public PrintingPressBlockItem() {\r\n        super(SFMBlocks.PRINTING_PRESS_BLOCK.get(), new Properties().tab(SFMItems.TAB));\r\n    }\r\n\r\n    @Override\r\n    public void appendHoverText(ItemStack pStack, @Nullable Level pLevel, List<Component> pTooltip, TooltipFlag pFlag) {\r\n        super.appendHoverText(pStack, pLevel, pTooltip, pFlag);\r\n        pTooltip.add(Constants.LocalizationKeys.PRINTING_PRESS_TOOLTIP.getComponent().withStyle(ChatFormatting.GRAY));\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\program\\OutputResourceTracker.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.common.program;\r\n\r\nimport ca.teamdman.sfm.common.resourcetype.ResourceType;\r\nimport ca.teamdman.sfml.ast.ResourceIdSet;\r\nimport ca.teamdman.sfml.ast.ResourceLimit;\r\n\r\nimport java.util.concurrent.atomic.AtomicLong;\r\nimport java.util.function.Predicate;\r\n\r\npublic class OutputResourceTracker<STACK, ITEM, CAP> implements Predicate<Object> {\r\n    private final ResourceLimit<STACK, ITEM, CAP> LIMIT;\r\n    private final ResourceIdSet EXCLUSIONS;\r\n    private final AtomicLong TRANSFERRED;\r\n    private final AtomicLong RETENTION_OBLIGATION_PROGRESS;\r\n\r\n    public OutputResourceTracker(\r\n            ResourceLimit<STACK, ITEM, CAP> resourceLimit,\r\n            ResourceIdSet exclusions,\r\n            AtomicLong transferred,\r\n            AtomicLong retentionObligationProgress\r\n    ) {\r\n        this.LIMIT = resourceLimit;\r\n        this.EXCLUSIONS = exclusions;\r\n        this.TRANSFERRED = transferred;\r\n        this.RETENTION_OBLIGATION_PROGRESS = retentionObligationProgress;\r\n    }\r\n\r\n    /**\r\n     * Done when we have reached the transfer limit, or when the retention is satisfied\r\n     */\r\n    public boolean isDone() {\r\n        return TRANSFERRED.get() >= LIMIT.limit().quantity().number().value()\r\n               || RETENTION_OBLIGATION_PROGRESS.get() >= LIMIT.limit().retention().number().value();\r\n    }\r\n\r\n    /**\r\n     * Update obligation progress as new limited slots are prepared\r\n     */\r\n    public void visit(LimitedOutputSlot<STACK, ITEM, CAP> slot) {\r\n        var stack = slot.getStackInSlot();\r\n        if (test(stack)) {\r\n            RETENTION_OBLIGATION_PROGRESS.accumulateAndGet(slot.type.getAmount(stack), Long::sum);\r\n        }\r\n    }\r\n\r\n    public void trackTransfer(long amount) {\r\n        TRANSFERRED.accumulateAndGet(amount, Long::sum);\r\n        RETENTION_OBLIGATION_PROGRESS.accumulateAndGet(amount, Long::sum);\r\n    }\r\n\r\n    /**\r\n     * How much more are we allowed to move\r\n     */\r\n    public long getMaxTransferable() {\r\n        long remainingRetentionRoom = LIMIT.limit().retention().number().value() - RETENTION_OBLIGATION_PROGRESS.get();\r\n        long unusedQuantity = LIMIT.limit().quantity().number().value() - TRANSFERRED.get();\r\n        return Math.min(unusedQuantity, remainingRetentionRoom);\r\n    }\r\n\r\n    public boolean matchesCapabilityType(Object capability) {\r\n        ResourceType<STACK, ITEM, CAP> resourceType = LIMIT.resourceId().getResourceType();\r\n        return resourceType != null && resourceType.matchesCapabilityType(capability);\r\n    }\r\n\r\n    @Override\r\n    public boolean test(Object stack) {\r\n        return LIMIT.test(stack) && !EXCLUSIONS.test(stack);\r\n    }\r\n\r\n    public ResourceLimit<STACK, ITEM, CAP> getLimit() {\r\n        return LIMIT;\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\net\\ServerboundLabelGunUsePacket.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.common.net;\r\n\r\nimport ca.teamdman.sfm.common.Constants;\r\nimport ca.teamdman.sfm.common.blockentity.ManagerBlockEntity;\r\nimport ca.teamdman.sfm.common.cablenetwork.CableNetwork;\r\nimport ca.teamdman.sfm.common.cablenetwork.CableNetworkManager;\r\nimport ca.teamdman.sfm.common.item.LabelGunItem;\r\nimport ca.teamdman.sfm.common.program.LabelPositionHolder;\r\nimport ca.teamdman.sfm.common.util.SFMUtils;\r\nimport net.minecraft.core.BlockPos;\r\nimport net.minecraft.core.Direction;\r\nimport net.minecraft.network.FriendlyByteBuf;\r\nimport net.minecraft.world.InteractionHand;\r\nimport net.minecraft.world.level.block.Block;\r\nimport net.minecraftforge.network.NetworkEvent;\r\n\r\nimport java.util.Arrays;\r\nimport java.util.HashSet;\r\nimport java.util.List;\r\nimport java.util.Set;\r\nimport java.util.function.Supplier;\r\nimport java.util.stream.Collectors;\r\n\r\npublic record ServerboundLabelGunUsePacket(\r\n        InteractionHand hand,\r\n        BlockPos pos,\r\n        boolean isCtrlKeyDown,\r\n        boolean isShiftKeyDown\r\n) {\r\n\r\n    public static void encode(ServerboundLabelGunUsePacket msg, FriendlyByteBuf buf) {\r\n        buf.writeEnum(msg.hand);\r\n        buf.writeBlockPos(msg.pos);\r\n        buf.writeBoolean(msg.isCtrlKeyDown);\r\n        buf.writeBoolean(msg.isShiftKeyDown);\r\n    }\r\n\r\n    public static ServerboundLabelGunUsePacket decode(\r\n            FriendlyByteBuf buf\r\n    ) {\r\n        return new ServerboundLabelGunUsePacket(\r\n                buf.readEnum(InteractionHand.class),\r\n                buf.readBlockPos(),\r\n                buf.readBoolean(),\r\n                buf.readBoolean()\r\n        );\r\n    }\r\n\r\n    public static void handle(\r\n            ServerboundLabelGunUsePacket msg, Supplier<NetworkEvent.Context> ctx\r\n    ) {\r\n        ctx.get().enqueueWork(() -> {\r\n            var sender = ctx.get().getSender();\r\n            if (sender == null) {\r\n                return;\r\n            }\r\n            var stack = sender.getItemInHand(msg.hand);\r\n            var level = sender.getLevel();\r\n            if (!(stack.getItem() instanceof LabelGunItem)) {\r\n                return;\r\n            }\r\n\r\n            var gunLabels = LabelPositionHolder.from(stack);\r\n            var pos = msg.pos;\r\n\r\n            // target is a manager, perform push or pull action\r\n            if (level.getBlockEntity(pos) instanceof ManagerBlockEntity manager) {\r\n                manager.getDisk().ifPresent(disk -> {\r\n                    if (msg.isShiftKeyDown) {\r\n                        // start with labels from disk\r\n                        var newLabels = LabelPositionHolder.from(disk);\r\n                        // ensure script-referenced labels are included\r\n                        manager.getReferencedLabels().forEach(newLabels::addReferencedLabel);\r\n                        // save to gun\r\n                        newLabels.save(stack);\r\n                        // give feedback to player\r\n                        sender.sendSystemMessage(Constants.LocalizationKeys.LABEL_GUN_CHAT_PULLED.getComponent());\r\n                    } else {\r\n                        // save gun labels to disk\r\n                        gunLabels.save(disk);\r\n                        // rebuild program\r\n                        manager.rebuildProgramAndUpdateDisk();\r\n                        // mark manager dirty\r\n                        manager.setChanged();\r\n                        // give feedback to player\r\n                        sender.sendSystemMessage(Constants.LocalizationKeys.LABEL_GUN_CHAT_PUSHED.getComponent());\r\n                    }\r\n                });\r\n                return;\r\n            }\r\n\r\n            // target is not a manager, we will perform label toggle\r\n            var activeLabel = LabelGunItem.getActiveLabel(stack);\r\n            if (activeLabel.isEmpty()) return;\r\n\r\n            if (msg.isCtrlKeyDown) {\r\n                // find all connected inventories of the same block type and toggle the label on all of them\r\n                // if any of them don't have it, apply it, otherwise strip from all\r\n\r\n                // find all cable positions so that we only include inventories adjacent to a cable\r\n                Set<BlockPos> cablePositions = CableNetworkManager\r\n                        .getNetworksForLevel(level)\r\n                        .flatMap(CableNetwork::getCablePositions)\r\n                        .collect(Collectors.toSet());\r\n\r\n                // get positions of all connected blocks of the same type\r\n                Block targetBlock = level.getBlockState(pos).getBlock();\r\n                List<BlockPos> positions = SFMUtils.getRecursiveStream((current, nextQueue, results) -> {\r\n                    results.accept(current);\r\n                    for (var d : Direction.values()) {\r\n                        var offset = current.offset(d.getNormal());\r\n                        if (level.getBlockState(offset).getBlock() == targetBlock) {\r\n                            // this is the block we are looking for\r\n                            // ensure it is also adjacent to a cable\r\n                            if (Arrays\r\n                                    .stream(Direction.values())\r\n                                    .anyMatch(d2 -> cablePositions.contains(offset.offset(d2.getNormal())))) {\r\n                                nextQueue.accept(offset);\r\n                            }\r\n                        }\r\n                    }\r\n                }, pos).toList();\r\n\r\n                // check if any of the positions are missing the label\r\n                var existing = new HashSet<>(gunLabels.getPositions(activeLabel));\r\n                boolean anyMissing = positions.stream().anyMatch(p -> !existing.contains(p));\r\n\r\n                // apply or strip label from all positions\r\n                if (anyMissing) {\r\n                    gunLabels.addAll(activeLabel, positions);\r\n                } else {\r\n                    positions.forEach(p -> gunLabels.remove(activeLabel, p));\r\n                }\r\n            } else {\r\n                // normal behaviour - operate on a single position\r\n                if (msg.isShiftKeyDown) {\r\n                    // clear all labels from this position\r\n                    gunLabels.remove(pos);\r\n                } else {\r\n                    // toggle the active label for this position\r\n                    gunLabels.toggle(activeLabel, pos);\r\n                }\r\n            }\r\n\r\n            // write changes to label gun stack\r\n            gunLabels.save(stack);\r\n        });\r\n        ctx.get().setPacketHandled(true);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\registry\\SFMBlocks.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.common.registry;\r\n\r\nimport ca.teamdman.sfm.SFM;\r\nimport ca.teamdman.sfm.common.block.*;\r\nimport net.minecraft.world.level.block.Block;\r\nimport net.minecraftforge.eventbus.api.IEventBus;\r\nimport net.minecraftforge.registries.DeferredRegister;\r\nimport net.minecraftforge.registries.ForgeRegistries;\r\nimport net.minecraftforge.registries.RegistryObject;\r\n\r\n\r\npublic class SFMBlocks {\r\n    private static final DeferredRegister<Block> BLOCKS = DeferredRegister.create(ForgeRegistries.BLOCKS, SFM.MOD_ID);\r\n    public static final RegistryObject<Block> MANAGER_BLOCK = BLOCKS.register(\"manager\", ManagerBlock::new);\r\n    public static final RegistryObject<Block> PRINTING_PRESS_BLOCK = BLOCKS.register(\r\n            \"printing_press\",\r\n            PrintingPressBlock::new\r\n    );\r\n    public static final RegistryObject<Block> WATER_TANK_BLOCK = BLOCKS.register(\"water_tank\", WaterTankBlock::new);\r\n    public static final RegistryObject<Block> CABLE_BLOCK = BLOCKS.register(\"cable\", CableBlock::new);\r\n    public static final RegistryObject<Block> BATTERY_BLOCK = BLOCKS.register(\"battery\", BatteryBlock::new);\r\n    public static final RegistryObject<Block> TEST_BARREL_BLOCK = BLOCKS.register(\"test_barrel\", TestBarrelBlock::new);\r\n\r\n    public static void register(IEventBus bus) {\r\n        BLOCKS.register(bus);\r\n    }\r\n\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\util\\SFMContainerUtil.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.common.util;\r\n\r\nimport net.minecraft.world.entity.player.Player;\r\nimport net.minecraft.world.level.block.entity.BlockEntity;\r\n\r\npublic class SFMContainerUtil {\r\n    public static boolean stillValid(BlockEntity blockEntity, Player player) {\r\n        var level = blockEntity.getLevel();\r\n        if (level == null) return false;\r\n        var pos   = blockEntity.getBlockPos();\r\n        if (level.getBlockEntity(pos) != blockEntity) return false;\r\n        double dist = player.distanceToSqr(\r\n                (double) pos.getX() + 0.5D,\r\n                (double) pos.getY() + 0.5D,\r\n                (double) pos.getZ() + 0.5D\r\n        );\r\n        return dist <= 64.0D;\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\program\\LabelPositionHolder.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.common.program;\r\n\r\nimport ca.teamdman.sfm.common.Constants;\r\nimport net.minecraft.ChatFormatting;\r\nimport net.minecraft.core.BlockPos;\r\nimport net.minecraft.nbt.*;\r\nimport net.minecraft.network.chat.Component;\r\nimport net.minecraft.world.item.ItemStack;\r\n\r\nimport java.util.*;\r\nimport java.util.function.BiConsumer;\r\nimport java.util.function.BiPredicate;\r\nimport java.util.function.Predicate;\r\nimport java.util.stream.Collectors;\r\n\r\n@SuppressWarnings(\"UnusedReturnValue\")\r\npublic class LabelPositionHolder {\r\n    private final Map<String, Set<BlockPos>> LABELS = new HashMap<>();\r\n\r\n    private LabelPositionHolder() {\r\n\r\n    }\r\n\r\n    public static LabelPositionHolder empty() {\r\n        return new LabelPositionHolder();\r\n    }\r\n\r\n    public static LabelPositionHolder from(ItemStack stack) {\r\n        var labels = LabelPositionHolder.empty();\r\n        var tag = stack.getOrCreateTag().getCompound(\"sfm:labels\");\r\n        for (var label : tag.getAllKeys()) {\r\n            // old: storing BlockPos as long\r\n            labels.addAll(label, tag.getList(label, Tag.TAG_LONG).stream()\r\n                    .map(LongTag.class::cast)\r\n                    .mapToLong(LongTag::getAsLong)\r\n                    .mapToObj(BlockPos::of).collect(Collectors.toList()));\r\n\r\n            // new: storing BlockPos as compound\r\n            labels.addAll(label, tag.getList(label, Tag.TAG_COMPOUND).stream()\r\n                    .map(CompoundTag.class::cast)\r\n                    .map(NbtUtils::readBlockPos)\r\n                    .collect(Collectors.toList()));\r\n        }\r\n        return labels;\r\n    }\r\n\r\n    public CompoundTag serialize() {\r\n        var tag = new CompoundTag();\r\n        for (var label : get().keySet()) {\r\n            var list = new ListTag();\r\n            list.addAll(LABELS.get(label)\r\n                                .stream()\r\n                                .map(NbtUtils::writeBlockPos)\r\n                                .toList());\r\n            tag.put(label, list);\r\n        }\r\n        return tag;\r\n    }\r\n\r\n    public boolean contains(String label, BlockPos pos) {\r\n        return LABELS.getOrDefault(label, Collections.emptySet()).contains(pos);\r\n    }\r\n\r\n    public LabelPositionHolder toggle(String label, BlockPos pos) {\r\n        if (contains(label, pos)) {\r\n            remove(label, pos);\r\n        } else {\r\n            add(label, pos);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    public Map<String, Set<BlockPos>> get() {\r\n        return LABELS;\r\n    }\r\n\r\n    public Set<BlockPos> getPositions(String label) {\r\n        return LABELS.computeIfAbsent(label, s -> new HashSet<>());\r\n    }\r\n\r\n    public LabelPositionHolder addAll(String label, Collection<BlockPos> positions) {\r\n        getPositions(label).addAll(positions);\r\n        return this;\r\n    }\r\n\r\n    public LabelPositionHolder addReferencedLabel(String label) {\r\n        getPositions(label);\r\n        return this;\r\n    }\r\n\r\n    public List<Component> asHoverText() {\r\n        var rtn = new ArrayList<Component>();\r\n        if (LABELS.isEmpty()) return rtn;\r\n        rtn.add(Constants.LocalizationKeys.DISK_ITEM_TOOLTIP_LABEL_HEADER\r\n                        .getComponent()\r\n                        .withStyle(ChatFormatting.UNDERLINE));\r\n        for (var entry : LABELS.entrySet()) {\r\n            rtn.add(Constants.LocalizationKeys.DISK_ITEM_TOOLTIP_LABEL.getComponent(\r\n                    entry.getKey(),\r\n                    entry.getValue().size()\r\n            ).withStyle(ChatFormatting.GRAY));\r\n        }\r\n        return rtn;\r\n    }\r\n\r\n    public LabelPositionHolder remove(BlockPos value) {\r\n        LABELS.values().forEach(list -> list.remove(value));\r\n        return this;\r\n    }\r\n\r\n    public LabelPositionHolder prune() {\r\n        LABELS.entrySet().removeIf(entry -> entry.getValue().isEmpty());\r\n        return this;\r\n    }\r\n\r\n    public LabelPositionHolder clear() {\r\n        LABELS.clear();\r\n        return this;\r\n    }\r\n\r\n    public LabelPositionHolder add(String label, BlockPos position) {\r\n        getPositions(label).add(position);\r\n        return this;\r\n    }\r\n\r\n    public LabelPositionHolder remove(String label, BlockPos pos) {\r\n        getPositions(label).remove(pos);\r\n        return this;\r\n    }\r\n\r\n    public LabelPositionHolder save(ItemStack stack) {\r\n        stack.getOrCreateTag().put(\"sfm:labels\", serialize());\r\n        return this;\r\n    }\r\n\r\n    public LabelPositionHolder removeIf(BiPredicate<String, BlockPos> predicate) {\r\n        LABELS.forEach((key, value) -> value.removeIf(pos -> predicate.test(key, pos)));\r\n        return this;\r\n    }\r\n\r\n    public LabelPositionHolder removeIf(Predicate<String> predicate) {\r\n        LABELS.keySet().removeIf(predicate);\r\n        return this;\r\n    }\r\n\r\n    public LabelPositionHolder forEach(BiConsumer<String, BlockPos> consumer) {\r\n        LABELS.forEach((key, value) -> value.forEach(pos -> consumer.accept(key, pos)));\r\n        return this;\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\resourcetype\\GasResourceType.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.common.resourcetype;\r\n\r\nimport mekanism.api.Action;\r\nimport mekanism.api.MekanismAPI;\r\nimport mekanism.api.chemical.gas.Gas;\r\nimport mekanism.api.chemical.gas.GasStack;\r\nimport mekanism.api.chemical.gas.IGasHandler;\r\nimport net.minecraftforge.common.capabilities.Capability;\r\nimport net.minecraftforge.common.capabilities.CapabilityToken;\r\nimport net.minecraftforge.registries.IForgeRegistry;\r\n\r\nimport static net.minecraftforge.common.capabilities.CapabilityManager.get;\r\n\r\npublic class GasResourceType extends ResourceType<GasStack, Gas, IGasHandler> {\r\n    public static final Capability<IGasHandler> CAP = get(new CapabilityToken<>() {\r\n    });\r\n\r\n    public GasResourceType() {\r\n        super(CAP);\r\n    }\r\n\r\n    @Override\r\n    public long getAmount(GasStack gasStack) {\r\n        return gasStack.getAmount();\r\n    }\r\n\r\n    @Override\r\n    public GasStack getStackInSlot(IGasHandler iGasHandler, int slot) {\r\n        return iGasHandler.getChemicalInTank(slot);\r\n    }\r\n\r\n    @Override\r\n    public GasStack extract(IGasHandler handler, int slot, long amount, boolean simulate) {\r\n        return handler.extractChemical(slot, amount, simulate ? Action.SIMULATE : Action.EXECUTE);\r\n    }\r\n\r\n    @Override\r\n    public int getSlots(IGasHandler handler) {\r\n        return handler.getTanks();\r\n    }\r\n\r\n    @Override\r\n    public long getMaxStackSize(GasStack gasStack) {\r\n        return Long.MAX_VALUE;\r\n    }\r\n\r\n    @Override\r\n    public long getMaxStackSize(IGasHandler handler, int slot) {\r\n        return handler.getTankCapacity(slot);\r\n    }\r\n\r\n    @Override\r\n    public GasStack insert(IGasHandler handler, int slot, GasStack gasStack, boolean simulate) {\r\n        return handler.insertChemical(slot, gasStack, simulate ? Action.SIMULATE : Action.EXECUTE);\r\n    }\r\n\r\n    @Override\r\n    public boolean isEmpty(GasStack gasStack) {\r\n        return gasStack.isEmpty();\r\n    }\r\n\r\n    @Override\r\n    public GasStack getEmptyStack() {\r\n        return GasStack.EMPTY;\r\n    }\r\n\r\n    @Override\r\n    public boolean matchesStackType(Object o) {\r\n        return o instanceof GasStack;\r\n    }\r\n\r\n    @Override\r\n    public boolean matchesCapabilityType(Object o) {\r\n        return o instanceof IGasHandler;\r\n    }\r\n\r\n\r\n    @Override\r\n    public IForgeRegistry<Gas> getRegistry() {\r\n        return MekanismAPI.gasRegistry();\r\n    }\r\n\r\n    @Override\r\n    public Gas getItem(GasStack gasStack) {\r\n        return gasStack.getType();\r\n    }\r\n\r\n    @Override\r\n    public GasStack copy(GasStack gasStack) {\r\n        return gasStack.copy();\r\n    }\r\n\r\n    @Override\r\n    protected GasStack setCount(GasStack gasStack, long amount) {\r\n        gasStack.setAmount(amount);\r\n        return gasStack;\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\blockentity\\PrintingPressBlockEntity.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.common.blockentity;\r\n\r\nimport ca.teamdman.sfm.common.recipe.NotContainer;\r\nimport ca.teamdman.sfm.common.registry.SFMBlockEntities;\r\nimport ca.teamdman.sfm.common.registry.SFMItems;\r\nimport ca.teamdman.sfm.common.registry.SFMRecipeTypes;\r\nimport net.minecraft.core.BlockPos;\r\nimport net.minecraft.core.Direction;\r\nimport net.minecraft.nbt.CompoundTag;\r\nimport net.minecraft.network.Connection;\r\nimport net.minecraft.network.protocol.Packet;\r\nimport net.minecraft.network.protocol.game.ClientGamePacketListener;\r\nimport net.minecraft.network.protocol.game.ClientboundBlockEntityDataPacket;\r\nimport net.minecraft.world.item.ItemStack;\r\nimport net.minecraft.world.item.crafting.RecipeManager;\r\nimport net.minecraft.world.level.block.Block;\r\nimport net.minecraft.world.level.block.entity.BlockEntity;\r\nimport net.minecraft.world.level.block.state.BlockState;\r\nimport net.minecraftforge.common.capabilities.Capability;\r\nimport net.minecraftforge.common.capabilities.ForgeCapabilities;\r\nimport net.minecraftforge.common.util.LazyOptional;\r\nimport net.minecraftforge.items.IItemHandler;\r\nimport net.minecraftforge.items.ItemStackHandler;\r\nimport net.minecraftforge.items.wrapper.CombinedInvWrapper;\r\nimport org.jetbrains.annotations.NotNull;\r\nimport org.jetbrains.annotations.Nullable;\r\n\r\n/**\r\n * Accepts a paper item and a form item.\r\n * When a piston is pressed on top of this block, it will print the form onto the paper.\r\n */\r\npublic class PrintingPressBlockEntity extends BlockEntity implements NotContainer {\r\n\r\n    private final ItemStackHandler FORM = new ItemStackHandler(1) {\r\n        @Override\r\n        protected void onContentsChanged(int slot) {\r\n            setChanged();\r\n            if (level != null)\r\n                level.sendBlockUpdated(worldPosition, getBlockState(), getBlockState(), Block.UPDATE_ALL);\r\n        }\r\n\r\n        @Override\r\n        public int getSlotLimit(int slot) {\r\n            return 1;\r\n        }\r\n\r\n        @Override\r\n        public boolean isItemValid(int slot, ItemStack stack) {\r\n            return stack.getItem() == SFMItems.FORM_ITEM.get();\r\n        }\r\n    };\r\n\r\n    private final ItemStackHandler INK = new ItemStackHandler(1) {\r\n        @Override\r\n        protected void onContentsChanged(int slot) {\r\n            setChanged();\r\n            if (level != null)\r\n                level.sendBlockUpdated(worldPosition, getBlockState(), getBlockState(), Block.UPDATE_ALL);\r\n        }\r\n\r\n        @Override\r\n        public boolean isItemValid(int slot, ItemStack stack) {\r\n            if (getLevel() == null) return false;\r\n            return getLevel().getRecipeManager()\r\n                    .getAllRecipesFor(SFMRecipeTypes.PRINTING_PRESS.get()).stream().anyMatch(r -> r.INK.test(stack));\r\n        }\r\n    };\r\n\r\n    private final ItemStackHandler PAPER = new ItemStackHandler(1) {\r\n        @Override\r\n        protected void onContentsChanged(int slot) {\r\n            setChanged();\r\n            if (level != null)\r\n                level.sendBlockUpdated(worldPosition, getBlockState(), getBlockState(), Block.UPDATE_ALL);\r\n        }\r\n\r\n        @Override\r\n        public int getSlotLimit(int slot) {\r\n            return 1;\r\n        }\r\n\r\n        @Override\r\n        public boolean isItemValid(int slot, ItemStack stack) {\r\n            if (getLevel() == null) return false;\r\n            return getLevel().getRecipeManager()\r\n                    .getAllRecipesFor(SFMRecipeTypes.PRINTING_PRESS.get()).stream().anyMatch(r -> r.PAPER.test(stack));\r\n        }\r\n    };\r\n    private final LazyOptional<IItemHandler> ITEMS_CAPABILITY = LazyOptional.of(() -> new CombinedInvWrapper(\r\n            FORM,\r\n            INK,\r\n            PAPER\r\n    ));\r\n\r\n    public PrintingPressBlockEntity(\r\n            BlockPos pPos, BlockState pBlockState\r\n    ) {\r\n        super(SFMBlockEntities.PRINTING_PRESS_BLOCK_ENTITY.get(), pPos, pBlockState);\r\n    }\r\n\r\n    @Override\r\n    public void load(CompoundTag tag) {\r\n        super.load(tag);\r\n        readItems(tag);\r\n    }\r\n\r\n\r\n    @Override\r\n    protected void saveAdditional(CompoundTag tag) {\r\n        super.saveAdditional(tag);\r\n        writeItems(tag);\r\n    }\r\n\r\n    private void writeItems(CompoundTag tag) {\r\n        tag.put(\"form\", FORM.serializeNBT());\r\n        tag.put(\"paper\", PAPER.serializeNBT());\r\n        tag.put(\"ink\", INK.serializeNBT());\r\n    }\r\n\r\n    private void readItems(CompoundTag tag) {\r\n        INK.deserializeNBT(tag.getCompound(\"ink\"));\r\n        PAPER.deserializeNBT(tag.getCompound(\"paper\"));\r\n        FORM.deserializeNBT(tag.getCompound(\"form\"));\r\n    }\r\n\r\n    @Override\r\n    public @NotNull <T> LazyOptional<T> getCapability(@NotNull Capability<T> cap, @Nullable Direction side) {\r\n        if (cap == ForgeCapabilities.ITEM_HANDLER) {\r\n            return ITEMS_CAPABILITY.cast();\r\n        }\r\n        return super.getCapability(cap, side);\r\n    }\r\n\r\n    public ItemStack acceptStack(ItemStack stack) {\r\n        ItemStack remainder;\r\n        if (!stack.isEmpty()) {\r\n            remainder = FORM.insertItem(0, stack.copy(), false);\r\n            if (remainder.getCount() < stack.getCount()) {\r\n                stack.shrink(stack.getCount() - remainder.getCount());\r\n                return stack;\r\n            }\r\n            remainder = INK.insertItem(0, stack.copy(), false);\r\n            if (remainder.getCount() < stack.getCount()) {\r\n                stack.shrink(stack.getCount() - remainder.getCount());\r\n                return stack;\r\n            }\r\n            remainder = PAPER.insertItem(0, stack.copy(), false);\r\n            if (remainder.getCount() < stack.getCount()) {\r\n                stack.shrink(stack.getCount() - remainder.getCount());\r\n                return stack;\r\n            }\r\n        } else {\r\n            ItemStack found;\r\n            found = PAPER.extractItem(0, 64, false);\r\n            if (!found.isEmpty()) {\r\n                return found;\r\n            }\r\n            found = FORM.extractItem(0, 64, false);\r\n            if (!found.isEmpty()) {\r\n                return found;\r\n            }\r\n            found = INK.extractItem(0, 64, false);\r\n            if (!found.isEmpty()) {\r\n                return found;\r\n            }\r\n        }\r\n        return stack;\r\n    }\r\n\r\n    @Override\r\n    public CompoundTag getUpdateTag() {\r\n        var tag = super.getUpdateTag();\r\n        writeItems(tag);\r\n        return tag;\r\n    }\r\n\r\n    @Nullable\r\n    @Override\r\n    public Packet<ClientGamePacketListener> getUpdatePacket() {\r\n        return ClientboundBlockEntityDataPacket.create(this);\r\n    }\r\n\r\n    @Override\r\n    public void onDataPacket(Connection net, ClientboundBlockEntityDataPacket pkt) {\r\n        super.onDataPacket(net, pkt);\r\n        CompoundTag tag = pkt.getTag();\r\n        if (tag != null)\r\n            readItems(tag);\r\n    }\r\n\r\n    public ItemStack getPaper() {\r\n        return PAPER.getStackInSlot(0);\r\n    }\r\n\r\n    public ItemStack getInk() {\r\n        return INK.getStackInSlot(0);\r\n    }\r\n\r\n    public ItemStack getForm() {\r\n        return FORM.getStackInSlot(0);\r\n    }\r\n\r\n    public void performPrint() {\r\n        if (getLevel() == null) return;\r\n        RecipeManager recipeManager = getLevel().getRecipeManager();\r\n        recipeManager.getRecipeFor(SFMRecipeTypes.PRINTING_PRESS.get(), this, getLevel()).ifPresent(recipe -> {\r\n            ItemStack paper = getPaper();\r\n            ItemStack ink = getInk();\r\n            ItemStack form = getForm();\r\n            if (paper.isEmpty() || ink.isEmpty() || form.isEmpty()) {\r\n                return;\r\n            }\r\n            paper = recipe.assemble(this);\r\n            PAPER.setStackInSlot(0, paper);\r\n            ink.shrink(1);\r\n            INK.setStackInSlot(0, ink);\r\n        });\r\n    }\r\n\r\n    public ItemStack[] getStacksToDrop() {\r\n        return new ItemStack[]{getPaper(), getInk(), getForm()};\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\capabilityprovidermapper\\CauldronCapabilityProviderMapper.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.common.capabilityprovidermapper;\r\n\r\nimport net.minecraft.core.BlockPos;\r\nimport net.minecraft.core.Direction;\r\nimport net.minecraft.world.level.LevelAccessor;\r\nimport net.minecraft.world.level.block.Block;\r\nimport net.minecraft.world.level.block.Blocks;\r\nimport net.minecraft.world.level.block.LayeredCauldronBlock;\r\nimport net.minecraft.world.level.material.Fluids;\r\nimport net.minecraftforge.common.capabilities.Capability;\r\nimport net.minecraftforge.common.capabilities.ForgeCapabilities;\r\nimport net.minecraftforge.common.capabilities.ICapabilityProvider;\r\nimport net.minecraftforge.common.util.LazyOptional;\r\nimport net.minecraftforge.fluids.FluidStack;\r\nimport net.minecraftforge.fluids.capability.IFluidHandler;\r\nimport org.jetbrains.annotations.NotNull;\r\nimport org.jetbrains.annotations.Nullable;\r\n\r\nimport javax.annotation.Nonnull;\r\nimport java.util.Optional;\r\n\r\npublic class CauldronCapabilityProviderMapper implements CapabilityProviderMapper {\r\n    @Override\r\n    public Optional<ICapabilityProvider> getProviderFor(LevelAccessor level, BlockPos pos) {\r\n        var state = level.getBlockState(pos);\r\n        if (state.getBlock() == Blocks.CAULDRON\r\n            || state.getBlock() == Blocks.WATER_CAULDRON\r\n            || state.getBlock() == Blocks.LAVA_CAULDRON) {\r\n            return Optional.of(new CauldronCapabilityProvider(level, pos));\r\n        }\r\n        return Optional.empty();\r\n    }\r\n\r\n    private static class CauldronCapabilityProvider implements ICapabilityProvider {\r\n        private final LazyOptional<IFluidHandler> fluidHandlerLazyOptional;\r\n\r\n\r\n        public CauldronCapabilityProvider(LevelAccessor level, BlockPos pos) {\r\n            this.fluidHandlerLazyOptional = LazyOptional.of(() -> new CauldronFluidHandler(level, pos));\r\n        }\r\n\r\n        @Nonnull\r\n        @Override\r\n        public @NotNull <T> LazyOptional<T> getCapability(@Nonnull Capability<T> cap, @Nullable Direction side) {\r\n            if (cap == ForgeCapabilities.FLUID_HANDLER) {\r\n                return fluidHandlerLazyOptional.cast();\r\n            }\r\n            return LazyOptional.empty();\r\n        }\r\n    }\r\n\r\n    private record CauldronFluidHandler(\r\n            LevelAccessor level,\r\n            BlockPos pos\r\n    ) implements IFluidHandler {\r\n\r\n        @Override\r\n        public int getTanks() {\r\n            return 1;\r\n        }\r\n\r\n        @Override\r\n        public @NotNull FluidStack getFluidInTank(int tank) {\r\n            var state = level.getBlockState(pos);\r\n            if (state.getBlock() == Blocks.WATER_CAULDRON) {\r\n                int level = state.getValue(LayeredCauldronBlock.LEVEL);\r\n                if (level == 0) {\r\n                    return FluidStack.EMPTY;\r\n                }\r\n                return new FluidStack(Fluids.WATER, level * 250);\r\n            } else if (state.getBlock() == Blocks.LAVA_CAULDRON) {\r\n                return new FluidStack(Fluids.LAVA, 1000);\r\n            }\r\n            return FluidStack.EMPTY;\r\n        }\r\n\r\n        @Override\r\n        public int getTankCapacity(int tank) {\r\n            return 1000;\r\n        }\r\n\r\n        @Override\r\n        public boolean isFluidValid(int tank, @NotNull FluidStack stack) {\r\n            return stack.getFluid() == Fluids.WATER || stack.getFluid() == Fluids.LAVA;\r\n        }\r\n\r\n        @Override\r\n        public int fill(FluidStack resource, FluidAction action) {\r\n            var state = level.getBlockState(pos);\r\n            if (state.getBlock() == Blocks.CAULDRON) { // if empty\r\n                if (resource.getFluid() == Fluids.WATER) {\r\n                    int layers = Math.min(3, resource.getAmount() / 250);\r\n                    if (action.execute()) {\r\n                        level.setBlock(\r\n                                pos,\r\n                                Blocks.WATER_CAULDRON.defaultBlockState().setValue(\r\n                                        LayeredCauldronBlock.LEVEL,\r\n                                        layers\r\n                                ),\r\n                                Block.UPDATE_ALL\r\n                        );\r\n                    }\r\n                    return layers * 250;\r\n                } else if (resource.getFluid() == Fluids.LAVA && resource.getAmount() >= 1000) {\r\n                    if (action.execute()) {\r\n                        level.setBlock(\r\n                                pos,\r\n                                Blocks.LAVA_CAULDRON.defaultBlockState(),\r\n                                Block.UPDATE_ALL\r\n                        );\r\n                    }\r\n                    return 1000;\r\n                }\r\n            } else if (state.getBlock() instanceof LayeredCauldronBlock) {\r\n                int waterLevel = state.getValue(LayeredCauldronBlock.LEVEL);\r\n                if (waterLevel >= 3) {\r\n                    return 0;\r\n                }\r\n                int waterLevelIncrease = Math.min(3 - waterLevel, Math.min(3, resource.getAmount() / 250));\r\n                if (action.execute()) {\r\n                    level.setBlock(\r\n                            pos,\r\n                            state.setValue(LayeredCauldronBlock.LEVEL, waterLevel + waterLevelIncrease),\r\n                            Block.UPDATE_ALL\r\n                    );\r\n                }\r\n                return waterLevelIncrease * 250;\r\n            }\r\n            return 0;\r\n        }\r\n\r\n        @Override\r\n        public @NotNull FluidStack drain(FluidStack resource, FluidAction action) {\r\n            var state = level.getBlockState(pos);\r\n            if (state.getBlock() instanceof LayeredCauldronBlock) {\r\n                int waterLevel = state.getValue(LayeredCauldronBlock.LEVEL);\r\n                if (waterLevel == 0) {\r\n                    return FluidStack.EMPTY;\r\n                }\r\n                int waterLevelDrain = Math.min(waterLevel, resource.getAmount() / 250);\r\n                if (action.execute()) {\r\n                    int resultLevel = waterLevel - waterLevelDrain;\r\n                    if (resultLevel == 0) {\r\n                        level.setBlock(\r\n                                pos,\r\n                                Blocks.CAULDRON.defaultBlockState(),\r\n                                Block.UPDATE_ALL\r\n                        );\r\n                    } else {\r\n                        level.setBlock(\r\n                                pos,\r\n                                state.setValue(LayeredCauldronBlock.LEVEL, resultLevel),\r\n                                Block.UPDATE_ALL\r\n                        );\r\n                    }\r\n                }\r\n                return new FluidStack(Fluids.WATER, waterLevelDrain * 250);\r\n            } else if (state.getBlock() == Blocks.LAVA_CAULDRON && resource.getAmount() >= 1000) {\r\n                if (action.execute()) {\r\n                    level.setBlock(\r\n                            pos,\r\n                            Blocks.CAULDRON.defaultBlockState(),\r\n                            Block.UPDATE_ALL\r\n                    );\r\n                }\r\n                return new FluidStack(Fluids.LAVA, 1000);\r\n            }\r\n            return FluidStack.EMPTY;\r\n        }\r\n\r\n        @Override\r\n        public @NotNull FluidStack drain(int maxDrain, FluidAction action) {\r\n            var state = level.getBlockState(pos);\r\n            if (state.getBlock() instanceof LayeredCauldronBlock) {\r\n                int waterLevel = state.getValue(LayeredCauldronBlock.LEVEL);\r\n                if (waterLevel == 0) {\r\n                    return FluidStack.EMPTY;\r\n                }\r\n                int waterLevelDrain = Math.min(waterLevel, maxDrain / 250);\r\n                if (action.execute()) {\r\n                    level.setBlock(\r\n                            pos,\r\n                            state.setValue(LayeredCauldronBlock.LEVEL, waterLevel - waterLevelDrain),\r\n                            Block.UPDATE_ALL\r\n                    );\r\n                }\r\n                return new FluidStack(Fluids.WATER, waterLevelDrain * 250);\r\n            } else if (state.getBlock() == Blocks.LAVA_CAULDRON && maxDrain >= 1000) {\r\n                if (action.execute()) {\r\n                    level.setBlock(\r\n                            pos,\r\n                            Blocks.CAULDRON.defaultBlockState(),\r\n                            Block.UPDATE_ALL\r\n                    );\r\n                }\r\n                return new FluidStack(Fluids.LAVA, 1000);\r\n            }\r\n            return FluidStack.EMPTY;\r\n        }\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfml\\ast\\InputStatement.java\r\n\r\n````java\r\npackage ca.teamdman.sfml.ast;\r\n\r\nimport ca.teamdman.sfm.common.program.InputResourceTracker;\r\nimport ca.teamdman.sfm.common.program.LimitedInputSlot;\r\nimport ca.teamdman.sfm.common.program.LimitedInputSlotObjectPool;\r\nimport ca.teamdman.sfm.common.program.ProgramContext;\r\nimport ca.teamdman.sfm.common.resourcetype.ResourceType;\r\n\r\nimport java.util.List;\r\nimport java.util.function.Consumer;\r\nimport java.util.stream.Collectors;\r\nimport java.util.stream.Stream;\r\n\r\npublic record InputStatement(\r\n        LabelAccess labelAccess,\r\n        ResourceLimits resourceLimits,\r\n        boolean each\r\n) implements Statement {\r\n\r\n    @Override\r\n    public void tick(ProgramContext context) {\r\n        context.addInput(this);\r\n    }\r\n\r\n    private static final LimitedInputSlotObjectPool SLOT_POOL = new LimitedInputSlotObjectPool();\r\n\r\n    @SuppressWarnings(\"rawtypes\")\r\n    public static void releaseSlots(List<LimitedInputSlot> slots) {\r\n        SLOT_POOL.release(slots);\r\n    }\r\n\r\n    public static void releaseSlot(LimitedInputSlot<?, ?, ?> slot) {\r\n        SLOT_POOL.release(slot);\r\n    }\r\n\r\n    @SuppressWarnings({\"rawtypes\", \"unchecked\"}) // basically impossible to make this method generic safe\r\n    public void gatherSlots(ProgramContext context, Consumer<LimitedInputSlot<?, ?, ?>> acceptor) {\r\n        Stream<ResourceType> types = resourceLimits\r\n                .resourceLimits()\r\n                .stream()\r\n                .map(ResourceLimit::resourceId)\r\n                .map((ResourceIdentifier x) -> x.getResourceType())\r\n                .distinct();\r\n\r\n        if (!each) {\r\n            // create a single matcher to be shared by all capabilities\r\n            List<InputResourceTracker<?, ?, ?>> inputMatchers = resourceLimits.createInputTrackers();\r\n            for (var type : (Iterable<ResourceType>) types::iterator) {\r\n                for (var capability : (Iterable) type.getCapabilities(context, labelAccess)::iterator) {\r\n                    gatherSlots((ResourceType<Object, Object, Object>) type, capability, inputMatchers, acceptor);\r\n                }\r\n            }\r\n        } else {\r\n            for (ResourceType type : (Iterable<ResourceType>) types::iterator) {\r\n                for (var cap : (Iterable<?>) type.getCapabilities(context, labelAccess)::iterator) {\r\n                    List<InputResourceTracker<?, ?, ?>> inputTrackers = resourceLimits.createInputTrackers();\r\n                    gatherSlots((ResourceType<Object, Object, Object>) type, cap, inputTrackers, acceptor);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private <STACK, ITEM, CAP> void gatherSlots(\r\n            ResourceType<STACK, ITEM, CAP> type,\r\n            CAP capability,\r\n            List<InputResourceTracker<?, ?, ?>> trackers,\r\n            Consumer<LimitedInputSlot<?, ?, ?>> acceptor\r\n    ) {\r\n        for (int slot = 0; slot < type.getSlots(capability); slot++) {\r\n            if (labelAccess.slots().contains(slot)) {\r\n                STACK stack = type.getStackInSlot(capability, slot);\r\n                if (!type.isEmpty(stack)) {\r\n                    for (InputResourceTracker<?, ?, ?> tracker : trackers) {\r\n                        if (tracker.matchesCapabilityType(capability) && tracker.test(stack)) {\r\n                            //noinspection unchecked\r\n                            acceptor.accept(SLOT_POOL.acquire(\r\n                                    capability,\r\n                                    slot,\r\n                                    (InputResourceTracker<STACK, ITEM, CAP>) tracker\r\n                            ));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"INPUT \" + resourceLimits + \" FROM \" + (each ? \"EACH \" : \"\") + labelAccess;\r\n    }\r\n\r\n    public String toStringPretty() {\r\n        StringBuilder sb = new StringBuilder();\r\n        sb.append(\"INPUT\");\r\n        String rls = resourceLimits.toStringPretty(Limit.MAX_QUANTITY_NO_RETENTION);\r\n        if (rls.lines().count() > 1) {\r\n            sb.append(\"\\n\");\r\n            sb.append(rls.lines().map(s -> \"  \" + s).collect(Collectors.joining(\"\\n\")));\r\n            sb.append(\"\\n\");\r\n        } else {\r\n            sb.append(\" \");\r\n            sb.append(rls);\r\n            sb.append(\" \");\r\n        }\r\n        sb.append(\"FROM \");\r\n        sb.append(each ? \"EACH \" : \"\");\r\n        sb.append(labelAccess);\r\n        return sb.toString();\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\client\\jei\\FallingAnvilFormRecipe.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.client.jei;\r\n\r\nimport ca.teamdman.sfm.common.recipe.PrintingPressRecipe;\r\n\r\npublic class FallingAnvilFormRecipe extends FallingAnvilRecipe {\r\n    public final PrintingPressRecipe PARENT;\r\n\r\n    public FallingAnvilFormRecipe(PrintingPressRecipe parent) {\r\n        this.PARENT = parent;\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\client\\ProgramTokenContextActions.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.client;\r\n\r\nimport ca.teamdman.sfm.SFM;\r\nimport ca.teamdman.sfm.common.net.ServerboundInputInspectionRequestPacket;\r\nimport ca.teamdman.sfm.common.net.ServerboundLabelInspectionRequestPacket;\r\nimport ca.teamdman.sfm.common.net.ServerboundOutputInspectionRequestPacket;\r\nimport ca.teamdman.sfm.common.registry.SFMPackets;\r\nimport ca.teamdman.sfml.SFMLLexer;\r\nimport ca.teamdman.sfml.SFMLParser;\r\nimport ca.teamdman.sfml.ast.*;\r\nimport org.antlr.v4.runtime.CharStreams;\r\nimport org.antlr.v4.runtime.CommonTokenStream;\r\nimport org.antlr.v4.runtime.ParserRuleContext;\r\nimport org.antlr.v4.runtime.Token;\r\n\r\nimport java.util.Optional;\r\nimport java.util.stream.Collectors;\r\nimport java.util.stream.Stream;\r\n\r\npublic class ProgramTokenContextActions {\r\n\r\n    public static Optional<Runnable> getContextAction(String programString, int cursorPosition) {\r\n        var lexer = new SFMLLexer(CharStreams.fromString(programString));\r\n        var tokens = new CommonTokenStream(lexer);\r\n        var parser = new SFMLParser(tokens);\r\n        var builder = new ASTBuilder();\r\n        try {\r\n            builder.visitProgram(parser.program());\r\n            SFM.LOGGER.info(\"Gathering context actions for cursor position \" + cursorPosition);\r\n            return Stream.concat(\r\n                            builder\r\n                                    .getNodesUnderCursor(cursorPosition)\r\n                                    .stream(),\r\n                            builder\r\n                                    .getNodesUnderCursor(cursorPosition - 1)\r\n                                    .stream()\r\n                    )\r\n                    .map(pair -> getContextAction(programString, builder, pair.a, pair.b, cursorPosition))\r\n                    .filter(Optional::isPresent)\r\n                    .map(Optional::get)\r\n                    .findFirst();\r\n        } catch (Throwable t) {\r\n            return Optional.of(() -> ClientStuff.showProgramEditScreen(\"-- Encountered error, program parse failed:\\n--\"\r\n                                                                       + t.getMessage(), next -> {\r\n            }));\r\n        }\r\n    }\r\n\r\n    public static Optional<Runnable> getContextAction(\r\n            String programString,\r\n            ASTBuilder builder,\r\n            ASTNode node,\r\n            ParserRuleContext parserRuleContext,\r\n            int cursorPosition\r\n    ) {\r\n        SFM.LOGGER.info(\"Checking if context action exists for node {} {}\", node.getClass(), node);\r\n        if (node instanceof ResourceIdentifier<?, ?, ?> rid) {\r\n            SFM.LOGGER.info(\"Found context action for resource identifier node\");\r\n            return Optional.of(() -> {\r\n                String expansion = rid\r\n                        .expand()\r\n                        .stream()\r\n                        .map(ResourceIdentifier::toStringCondensed)\r\n                        .collect(Collectors.joining(\",\\n\"));\r\n                ClientStuff.showProgramEditScreen(expansion, next -> {\r\n                });\r\n            });\r\n        } else if (node instanceof Label label) {\r\n            SFM.LOGGER.info(\"Found context action for label node\");\r\n            return Optional.of(() -> SFMPackets.INSPECTION_CHANNEL.sendToServer(new ServerboundLabelInspectionRequestPacket(\r\n                    label.name()\r\n            )));\r\n        } else if (node instanceof InputStatement) {\r\n            if (cursorPosition > parserRuleContext.getStart().getStartIndex() + \"INPUT\".length()) {\r\n                SFM.LOGGER.info(\"Found context action for input node, but the cursor isn't at the start of the node\");\r\n                return Optional.empty();\r\n            }\r\n            SFM.LOGGER.info(\"Found context action for input node\");\r\n            int nodeIndex = builder.getIndexForNode(node);\r\n            return Optional.of(() -> SFMPackets.INSPECTION_CHANNEL.sendToServer(new ServerboundInputInspectionRequestPacket(\r\n                    programString,\r\n                    nodeIndex\r\n            )));\r\n        } else if (node instanceof OutputStatement) {\r\n            if (cursorPosition > parserRuleContext.getStart().getStartIndex() + \"OUTPUT\".length()) {\r\n                SFM.LOGGER.info(\"Found context action for output node, but the cursor isn't at the start of the node\");\r\n                return Optional.empty();\r\n            }\r\n            SFM.LOGGER.info(\"Found context action for output node\");\r\n            int nodeIndex = builder.getIndexForNode(node);\r\n            return Optional.of(() -> SFMPackets.INSPECTION_CHANNEL.sendToServer(new ServerboundOutputInspectionRequestPacket(\r\n                    programString,\r\n                    nodeIndex\r\n            )));\r\n        }\r\n        return Optional.empty();\r\n    }\r\n\r\n    public static boolean hasContextAction(Token token) {\r\n        return switch (token.getType()) {\r\n            case SFMLLexer.INPUT, SFMLLexer.OUTPUT, SFMLLexer.IDENTIFIER -> true;\r\n            default -> false;\r\n        };\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\registry\\SFMBlockEntities.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.common.registry;\r\n\r\n\r\nimport ca.teamdman.sfm.SFM;\r\nimport ca.teamdman.sfm.common.blockentity.BatteryBlockEntity;\r\nimport ca.teamdman.sfm.common.blockentity.ManagerBlockEntity;\r\nimport ca.teamdman.sfm.common.blockentity.PrintingPressBlockEntity;\r\nimport ca.teamdman.sfm.common.blockentity.WaterTankBlockEntity;\r\nimport net.minecraft.world.level.block.entity.BlockEntityType;\r\nimport net.minecraftforge.eventbus.api.IEventBus;\r\nimport net.minecraftforge.registries.DeferredRegister;\r\nimport net.minecraftforge.registries.ForgeRegistries;\r\nimport net.minecraftforge.registries.RegistryObject;\r\n\r\n@SuppressWarnings(\"DataFlowIssue\")\r\npublic final class SFMBlockEntities {\r\n\r\n    private static final DeferredRegister<BlockEntityType<?>> BLOCK_ENTITY_TYPES = DeferredRegister.create(\r\n            ForgeRegistries.BLOCK_ENTITY_TYPES,\r\n            SFM.MOD_ID\r\n    );\r\n\r\n    public static void register(IEventBus bus) {\r\n        BLOCK_ENTITY_TYPES.register(bus);\r\n    }\r\n\r\n    public static final RegistryObject<BlockEntityType<ManagerBlockEntity>> MANAGER_BLOCK_ENTITY = BLOCK_ENTITY_TYPES.register(\r\n            \"manager\",\r\n            () -> BlockEntityType.Builder\r\n                    .of(ManagerBlockEntity::new, SFMBlocks.MANAGER_BLOCK.get())\r\n                    .build(null)\r\n    );\r\n    public static final RegistryObject<BlockEntityType<PrintingPressBlockEntity>> PRINTING_PRESS_BLOCK_ENTITY = BLOCK_ENTITY_TYPES.register(\r\n            \"printing_press\",\r\n            () -> BlockEntityType.Builder\r\n                    .of(PrintingPressBlockEntity::new, SFMBlocks.PRINTING_PRESS_BLOCK.get())\r\n                    .build(null)\r\n    );\r\n\r\n    public static final RegistryObject<BlockEntityType<WaterTankBlockEntity>> WATER_TANK_BLOCK_ENTITY = BLOCK_ENTITY_TYPES.register(\r\n            \"water_tank\",\r\n            () -> BlockEntityType.Builder\r\n                    .of(WaterTankBlockEntity::new, SFMBlocks.WATER_TANK_BLOCK.get())\r\n                    .build(null)\r\n    );\r\n\r\n    public static final RegistryObject<BlockEntityType<BatteryBlockEntity>> BATTERY_BLOCK_ENTITY = BLOCK_ENTITY_TYPES.register(\r\n            \"battery\",\r\n            () -> BlockEntityType.Builder\r\n                    .of(BatteryBlockEntity::new, SFMBlocks.BATTERY_BLOCK.get())\r\n                    .build(null)\r\n    );\r\n\r\n\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\blockentity\\BatteryBlockEntity.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.common.blockentity;\r\n\r\nimport ca.teamdman.sfm.common.registry.SFMBlockEntities;\r\nimport net.minecraft.core.BlockPos;\r\nimport net.minecraft.core.Direction;\r\nimport net.minecraft.world.level.block.entity.BlockEntity;\r\nimport net.minecraft.world.level.block.state.BlockState;\r\nimport net.minecraftforge.common.capabilities.Capability;\r\nimport net.minecraftforge.common.capabilities.ForgeCapabilities;\r\nimport net.minecraftforge.common.util.LazyOptional;\r\nimport net.minecraftforge.energy.EnergyStorage;\r\nimport net.minecraftforge.energy.IEnergyStorage;\r\nimport org.jetbrains.annotations.NotNull;\r\nimport org.jetbrains.annotations.Nullable;\r\n\r\npublic class BatteryBlockEntity extends BlockEntity {\r\n\r\n    public final IEnergyStorage               CONTAINER  = new EnergyStorage(\r\n            Integer.MAX_VALUE,\r\n            Integer.MAX_VALUE,\r\n            Integer.MAX_VALUE\r\n    );\r\n    public final LazyOptional<IEnergyStorage> CAPABILITY = LazyOptional.of(() -> CONTAINER);\r\n\r\n    public BatteryBlockEntity(\r\n            BlockPos pPos,\r\n            BlockState pBlockState\r\n    ) {\r\n        super(SFMBlockEntities.BATTERY_BLOCK_ENTITY.get(), pPos, pBlockState);\r\n    }\r\n\r\n\r\n    @Override\r\n    public @NotNull <T> LazyOptional<T> getCapability(@NotNull Capability<T> cap, @Nullable Direction side) {\r\n        if (cap == ForgeCapabilities.ENERGY) {\r\n            return CAPABILITY.cast();\r\n        } else {\r\n            return super.getCapability(cap, side);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void invalidateCaps() {\r\n        CAPABILITY.invalidate();\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\resourcetype\\InfuseResourceType.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.common.resourcetype;\r\n\r\nimport mekanism.api.Action;\r\nimport mekanism.api.MekanismAPI;\r\nimport mekanism.api.chemical.infuse.IInfusionHandler;\r\nimport mekanism.api.chemical.infuse.InfuseType;\r\nimport mekanism.api.chemical.infuse.InfusionStack;\r\nimport net.minecraftforge.common.capabilities.Capability;\r\nimport net.minecraftforge.common.capabilities.CapabilityToken;\r\nimport net.minecraftforge.registries.IForgeRegistry;\r\n\r\nimport static net.minecraftforge.common.capabilities.CapabilityManager.get;\r\n\r\npublic class InfuseResourceType extends ResourceType<InfusionStack, InfuseType, IInfusionHandler> {\r\n    public static final Capability<IInfusionHandler> CAP = get(new CapabilityToken<>() {\r\n    });\r\n\r\n    public InfuseResourceType() {\r\n        super(CAP);\r\n    }\r\n\r\n    @Override\r\n    public long getAmount(InfusionStack stack) {\r\n        return stack.getAmount();\r\n    }\r\n\r\n    @Override\r\n    public InfusionStack getStackInSlot(IInfusionHandler handler, int slot) {\r\n        return handler.getChemicalInTank(slot);\r\n    }\r\n\r\n    @Override\r\n    public InfusionStack extract(IInfusionHandler handler, int slot, long amount, boolean simulate) {\r\n        return handler.extractChemical(slot, amount, simulate ? Action.SIMULATE : Action.EXECUTE);\r\n    }\r\n\r\n    @Override\r\n    public int getSlots(IInfusionHandler handler) {\r\n        return handler.getTanks();\r\n    }\r\n\r\n    @Override\r\n    public long getMaxStackSize(InfusionStack stack) {\r\n        return Long.MAX_VALUE;\r\n    }\r\n\r\n    @Override\r\n    public long getMaxStackSize(IInfusionHandler handler, int slot) {\r\n        return handler.getTankCapacity(slot);\r\n    }\r\n\r\n    @Override\r\n    public InfusionStack insert(\r\n            IInfusionHandler handler,\r\n            int slot,\r\n            InfusionStack stack,\r\n            boolean simulate\r\n    ) {\r\n        return handler.insertChemical(slot, stack, simulate ? Action.SIMULATE : Action.EXECUTE);\r\n    }\r\n\r\n    @Override\r\n    public boolean isEmpty(InfusionStack stack) {\r\n        return stack.isEmpty();\r\n    }\r\n\r\n    @Override\r\n    public InfusionStack getEmptyStack() {\r\n        return InfusionStack.EMPTY;\r\n    }\r\n\r\n    @Override\r\n    public boolean matchesStackType(Object o) {\r\n        return o instanceof InfusionStack;\r\n    }\r\n\r\n    @Override\r\n    public boolean matchesCapabilityType(Object o) {\r\n        return o instanceof IInfusionHandler;\r\n    }\r\n\r\n\r\n    @Override\r\n    public IForgeRegistry<InfuseType> getRegistry() {\r\n        return MekanismAPI.infuseTypeRegistry();\r\n    }\r\n\r\n    @Override\r\n    public InfuseType getItem(InfusionStack stack) {\r\n        return stack.getType();\r\n    }\r\n\r\n    @Override\r\n    public InfusionStack copy(InfusionStack stack) {\r\n        return stack.copy();\r\n    }\r\n\r\n    @Override\r\n    protected InfusionStack setCount(InfusionStack stack, long amount) {\r\n        stack.setAmount(amount);\r\n        return stack;\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\client\\gui\\EditorUtils.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.client.gui;\r\n\r\npublic class EditorUtils {\r\n    private static int findLineStart(String content, int cursorPos) {\r\n        while (cursorPos > 0 && content.charAt(cursorPos - 1) != '\\n') {\r\n            cursorPos--;\r\n        }\r\n        return cursorPos;\r\n    }\r\n\r\n    private static int findLineEnd(String content, int cursorPos) {\r\n        while (cursorPos < content.length() && content.charAt(cursorPos) != '\\n') {\r\n            cursorPos++;\r\n        }\r\n        return cursorPos;\r\n    }\r\n\r\n    /**\r\n     * Indents the given content, and updates the cursor and selection.\r\n     *\r\n     * @param content            The content to indent\r\n     * @param cursorPos          The index within the string of the cursor\r\n     * @param selectionCursorPos The index within the string of the selection cursor. If equal to cursorPosition, no selection is present.\r\n     * @return The indented content, and the new cursor and selection cursor positions\r\n     */\r\n    public static ManipulationResult indent(String content, int cursorPos, int selectionCursorPos) {\r\n        StringBuilder sb = new StringBuilder(content);\r\n        int lineStart = findLineStart(content, Math.min(cursorPos, selectionCursorPos));\r\n        int lineEnd = findLineEnd(content, Math.max(cursorPos, selectionCursorPos));\r\n        if (lineStart == lineEnd) {\r\n            sb.insert(lineStart, \"    \");\r\n            if (lineStart <= cursorPos) {\r\n                cursorPos += 4;\r\n            }\r\n            if (lineStart <= selectionCursorPos) {\r\n                selectionCursorPos += 4;\r\n            }\r\n        } else {\r\n            while (lineStart < lineEnd) {\r\n                sb.insert(lineStart, \"    \");\r\n                lineEnd += 4;\r\n                if (lineStart < cursorPos) {\r\n                    cursorPos += 4;\r\n                }\r\n                if (lineStart < selectionCursorPos) {\r\n                    selectionCursorPos += 4;\r\n                }\r\n                lineStart = findLineEnd(sb.toString(), lineStart) + 1;\r\n            }\r\n        }\r\n        return new ManipulationResult(sb.toString(), cursorPos, selectionCursorPos);\r\n    }\r\n\r\n    /**\r\n     * Deindents the given content, and updates the cursor and selection.\r\n     *\r\n     * @param content            The content to deindent\r\n     * @param cursorPos          The index within the string of the cursor\r\n     * @param selectionCursorPos The index within the string of the selection cursor. If equal to cursorPosition, no selection is present.\r\n     * @return The deindented content, and the new cursor and selection cursor positions\r\n     */\r\n    public static ManipulationResult deindent(String content, int cursorPos, int selectionCursorPos) {\r\n        StringBuilder sb = new StringBuilder(content);\r\n        int lineStart = findLineStart(content, Math.min(cursorPos, selectionCursorPos));\r\n        int lineEnd = findLineEnd(content, Math.max(cursorPos, selectionCursorPos));\r\n\r\n        while (lineStart < lineEnd) {\r\n            for (int i = 0; i < 4 && lineStart < sb.length() && sb.charAt(lineStart) == ' '; i++) {\r\n                sb.deleteCharAt(lineStart);\r\n                lineEnd--;\r\n                if (lineStart < cursorPos) {\r\n                    cursorPos--;\r\n                }\r\n                if (lineStart < selectionCursorPos) {\r\n                    selectionCursorPos--;\r\n                }\r\n            }\r\n            lineStart = findLineEnd(sb.toString(), lineStart) + 1;\r\n        }\r\n        return new ManipulationResult(sb.toString(), cursorPos, selectionCursorPos);\r\n    }\r\n\r\n    /**\r\n     * Perform the operation for hitting Ctrl+/\r\n     * If the selection contains a line not starting with \"--\", prepend each line with \"--\"\r\n     * If all lines in the selection start with \"--\", trim \"--\" from the start of each line\r\n     *\r\n     * @param content The content in the buffer\r\n     * @param cursorPos The index within the content for the cursor position\r\n     * @param selectionCursorPos The index within the content for the selection cursor. If equal to cursorPosition, no selection is present.\r\n     * @return The modified content, and the new cursor positions accommodating the shifting of said content\r\n     */\r\n    public static ManipulationResult toggleComments(String content, int cursorPos, int selectionCursorPos) {\r\n        StringBuilder sb = new StringBuilder(content);\r\n        int lineStart = findLineStart(content, Math.min(cursorPos, selectionCursorPos));\r\n        int lineEnd = findLineEnd(content, Math.max(cursorPos, selectionCursorPos));\r\n\r\n        boolean allLinesCommented = true;\r\n        while (lineStart < lineEnd) {\r\n            if (lineStart + 2 >= sb.length() || sb.charAt(lineStart) != '-' || sb.charAt(lineStart + 1) != '-') {\r\n                allLinesCommented = false;\r\n                break;\r\n            }\r\n            lineStart = findLineEnd(sb.toString(), lineStart) + 1;\r\n        }\r\n\r\n        lineStart = findLineStart(content, Math.min(cursorPos, selectionCursorPos));\r\n        lineEnd = findLineEnd(content, Math.max(cursorPos, selectionCursorPos));\r\n\r\n        if (allLinesCommented) {\r\n            while (lineStart < lineEnd) {\r\n                sb.delete(lineStart, lineStart + 2);\r\n                lineEnd -= 2;\r\n                if (lineStart < cursorPos) {\r\n                    cursorPos -= 2;\r\n                }\r\n                if (lineStart < selectionCursorPos) {\r\n                    selectionCursorPos -= 2;\r\n                }\r\n                lineStart = findLineEnd(sb.toString(), lineStart) + 1;\r\n            }\r\n        } else {\r\n            while (lineStart < lineEnd) {\r\n                sb.insert(lineStart, \"--\");\r\n                lineEnd += 2;\r\n                if (lineStart <= cursorPos) {\r\n                    cursorPos += 2;\r\n                }\r\n                if (lineStart <= selectionCursorPos) {\r\n                    selectionCursorPos += 2;\r\n                }\r\n                lineStart = findLineEnd(sb.toString(), lineStart) + 1;\r\n            }\r\n        }\r\n        return new ManipulationResult(sb.toString(), cursorPos, selectionCursorPos);\r\n    }\r\n\r\n    public record ManipulationResult(\r\n            String content,\r\n            int cursorPosition,\r\n            int selectionCursorPosition\r\n    ) {\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\client\\jei\\SFMJEIPlugin.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.client.jei;\r\n\r\nimport ca.teamdman.sfm.SFM;\r\nimport ca.teamdman.sfm.client.gui.screen.ManagerScreen;\r\nimport ca.teamdman.sfm.common.recipe.PrintingPressRecipe;\r\nimport ca.teamdman.sfm.common.registry.SFMBlocks;\r\nimport ca.teamdman.sfm.common.registry.SFMRecipeTypes;\r\nimport mezz.jei.api.IModPlugin;\r\nimport mezz.jei.api.JeiPlugin;\r\nimport mezz.jei.api.gui.handlers.IGuiContainerHandler;\r\nimport mezz.jei.api.registration.IGuiHandlerRegistration;\r\nimport mezz.jei.api.registration.IRecipeCatalystRegistration;\r\nimport mezz.jei.api.registration.IRecipeCategoryRegistration;\r\nimport mezz.jei.api.registration.IRecipeRegistration;\r\nimport net.minecraft.client.Minecraft;\r\nimport net.minecraft.client.renderer.Rect2i;\r\nimport net.minecraft.resources.ResourceLocation;\r\nimport net.minecraft.world.item.ItemStack;\r\nimport net.minecraft.world.item.crafting.RecipeManager;\r\nimport net.minecraft.world.level.block.Blocks;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\n@JeiPlugin\r\npublic class SFMJEIPlugin implements IModPlugin {\r\n    @Override\r\n    public ResourceLocation getPluginUid() {\r\n        return new ResourceLocation(SFM.MOD_ID, \"sfm\");\r\n    }\r\n\r\n    @Override\r\n    public void registerCategories(IRecipeCategoryRegistration registration) {\r\n        registration.addRecipeCategories(\r\n                new PrintingPressJEICategory(registration.getJeiHelpers()),\r\n                new FallingAnvilJEICategory(registration.getJeiHelpers())\r\n        );\r\n    }\r\n\r\n    @Override\r\n    public void registerRecipeCatalysts(IRecipeCatalystRegistration registration) {\r\n        registration.addRecipeCatalyst(\r\n                new ItemStack(SFMBlocks.PRINTING_PRESS_BLOCK.get()),\r\n                PrintingPressJEICategory.RECIPE_TYPE\r\n        );\r\n        registration.addRecipeCatalyst(\r\n                new ItemStack(Blocks.ANVIL),\r\n                FallingAnvilJEICategory.RECIPE_TYPE\r\n        );\r\n    }\r\n\r\n    @Override\r\n    public void registerRecipes(IRecipeRegistration registration) {\r\n        List<PrintingPressRecipe> printingPressRecipes = new ArrayList<>();\r\n        List<FallingAnvilRecipe> fallingAnvilRecipes = new ArrayList<>();\r\n        var level = Minecraft.getInstance().level;\r\n        assert level != null;\r\n        RecipeManager recipeManager = level.getRecipeManager();\r\n        recipeManager.getAllRecipesFor(SFMRecipeTypes.PRINTING_PRESS.get()).forEach(r -> {\r\n            printingPressRecipes.add(r);\r\n            fallingAnvilRecipes.add(new FallingAnvilFormRecipe(r));\r\n        });\r\n        fallingAnvilRecipes.add(new FallingAnvilDisenchantRecipe());\r\n        fallingAnvilRecipes.add(new FallingAnvilExperienceShardRecipe());\r\n        registration.addRecipes(PrintingPressJEICategory.RECIPE_TYPE, printingPressRecipes);\r\n        registration.addRecipes(FallingAnvilJEICategory.RECIPE_TYPE, fallingAnvilRecipes);\r\n    }\r\n\r\n    @Override\r\n    public void registerGuiHandlers(IGuiHandlerRegistration registration) {\r\n        registration.addGuiContainerHandler(ManagerScreen.class, new IGuiContainerHandler<>() {\r\n            @Override\r\n            public List<Rect2i> getGuiExtraAreas(ManagerScreen screen) {\r\n                var buttons = screen.getButtonsForJEIExclusionZones();\r\n                return buttons\r\n                        .stream()\r\n                        .filter(b -> b.visible)\r\n                        .map(b -> new Rect2i(b.x, b.y, b.getWidth(), b.getHeight()))\r\n                        .toList();\r\n            }\r\n        });\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\blockentity\\package-info.java\r\n\r\n````java\r\n\r\n@ParametersAreNonnullByDefault\r\n@MethodsReturnNonnullByDefault\r\n@FieldsAreNonnullByDefault\r\npackage ca.teamdman.sfm.common.blockentity;\r\n\r\nimport net.minecraft.FieldsAreNonnullByDefault;\r\nimport net.minecraft.MethodsReturnNonnullByDefault;\r\n\r\nimport javax.annotation.ParametersAreNonnullByDefault;\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\client\\render\\PrintingPressBlockEntityRenderer.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.client.render;\r\n\r\nimport ca.teamdman.sfm.common.blockentity.PrintingPressBlockEntity;\r\nimport com.mojang.blaze3d.vertex.PoseStack;\r\nimport com.mojang.math.Vector3f;\r\nimport net.minecraft.client.Minecraft;\r\nimport net.minecraft.client.renderer.MultiBufferSource;\r\nimport net.minecraft.client.renderer.block.model.ItemTransforms;\r\nimport net.minecraft.client.renderer.blockentity.BlockEntityRenderer;\r\nimport net.minecraft.client.renderer.blockentity.BlockEntityRendererProvider;\r\nimport net.minecraft.world.item.ItemStack;\r\n\r\npublic class PrintingPressBlockEntityRenderer implements BlockEntityRenderer<PrintingPressBlockEntity> {\r\n    public PrintingPressBlockEntityRenderer(BlockEntityRendererProvider.Context pContext) {\r\n\r\n    }\r\n\r\n    @Override\r\n    public void render(\r\n            PrintingPressBlockEntity blockEntity,\r\n            float partialTick,\r\n            PoseStack poseStack,\r\n            MultiBufferSource buf,\r\n            int packedLight,\r\n            int packedOverlay\r\n    ) {\r\n        var paper = blockEntity.getPaper();\r\n        var dye = blockEntity.getInk();\r\n        var form = blockEntity.getForm();\r\n        var depthAxis = new Vector3f(1, 0, 0);\r\n        poseStack.pushPose();\r\n        poseStack.translate(0.5, 1, 0.6);\r\n        poseStack.mulPose(depthAxis.rotationDegrees(-90));\r\n\r\n        for (var stack : new ItemStack[]{form, paper, dye}) {\r\n            if (!stack.isEmpty()) {\r\n                Minecraft\r\n                        .getInstance()\r\n                        .getItemRenderer()\r\n                        .renderStatic(\r\n                                stack,\r\n                                ItemTransforms.TransformType.GROUND,\r\n                                packedLight,\r\n                                packedOverlay,\r\n                                poseStack,\r\n                                buf,\r\n                                (int) blockEntity.getBlockPos().asLong()\r\n                        );\r\n                poseStack.translate(0.01, 0.01, 0.03);\r\n            }\r\n        }\r\n        poseStack.popPose();\r\n\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\net\\package-info.java\r\n\r\n````java\r\n\r\n\r\n@ParametersAreNonnullByDefault\r\n@MethodsReturnNonnullByDefault\r\n@FieldsAreNonnullByDefault\r\npackage ca.teamdman.sfm.common.net;\r\n\r\nimport net.minecraft.FieldsAreNonnullByDefault;\r\nimport net.minecraft.MethodsReturnNonnullByDefault;\r\n\r\nimport javax.annotation.ParametersAreNonnullByDefault;\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\block\\PrintingPressBlock.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.common.block;\r\n\r\nimport ca.teamdman.sfm.common.blockentity.PrintingPressBlockEntity;\r\nimport ca.teamdman.sfm.common.registry.SFMBlockEntities;\r\nimport net.minecraft.core.BlockPos;\r\nimport net.minecraft.world.Containers;\r\nimport net.minecraft.world.InteractionHand;\r\nimport net.minecraft.world.InteractionResult;\r\nimport net.minecraft.world.entity.player.Player;\r\nimport net.minecraft.world.item.ItemStack;\r\nimport net.minecraft.world.level.Level;\r\nimport net.minecraft.world.level.block.*;\r\nimport net.minecraft.world.level.block.entity.BlockEntity;\r\nimport net.minecraft.world.level.block.state.BlockBehaviour;\r\nimport net.minecraft.world.level.block.state.BlockState;\r\nimport net.minecraft.world.level.material.Material;\r\nimport net.minecraft.world.phys.BlockHitResult;\r\n\r\npublic class PrintingPressBlock extends BaseEntityBlock implements EntityBlock {\r\n\r\n    public PrintingPressBlock() {\r\n        super(BlockBehaviour.Properties.of(Material.METAL).strength(5.0F, 6.0F).noOcclusion());\r\n        this.registerDefaultState(this.defaultBlockState());\r\n    }\r\n\r\n    @Override\r\n    public BlockEntity newBlockEntity(BlockPos pos, BlockState state) {\r\n        return SFMBlockEntities.PRINTING_PRESS_BLOCK_ENTITY\r\n                .get()\r\n                .create(pos, state);\r\n    }\r\n\r\n    @SuppressWarnings(\"deprecation\")\r\n    public RenderShape getRenderShape(BlockState state) {\r\n        return RenderShape.MODEL;\r\n    }\r\n\r\n    @Override\r\n    @SuppressWarnings(\"deprecation\")\r\n    public void neighborChanged(\r\n            BlockState pState,\r\n            Level pLevel,\r\n            BlockPos pPos,\r\n            Block pBlock,\r\n            BlockPos pFromPos,\r\n            boolean pIsMoving\r\n    ) {\r\n        super.neighborChanged(pState, pLevel, pPos, pBlock, pFromPos, pIsMoving);\r\n        if (!pLevel.isClientSide\r\n            && pFromPos.getY() == pPos.getY() + 1\r\n            && pLevel.getBlockState(pFromPos).getBlock() == Blocks.PISTON_HEAD\r\n            && pLevel.getBlockEntity(pPos) instanceof PrintingPressBlockEntity blockEntity) {\r\n            blockEntity.performPrint();\r\n        }\r\n    }\r\n\r\n    @Override\r\n    @SuppressWarnings(\"deprecation\")\r\n    public InteractionResult use(\r\n            BlockState state,\r\n            Level level,\r\n            BlockPos pos,\r\n            Player player,\r\n            InteractionHand hand,\r\n            BlockHitResult hit\r\n    ) {\r\n        if (!level.isClientSide() && level.getBlockEntity(pos) instanceof PrintingPressBlockEntity blockEntity) {\r\n            var stack = player.getItemInHand(hand);\r\n            player.setItemInHand(hand, blockEntity.acceptStack(stack));\r\n        }\r\n        return InteractionResult.SUCCESS;\r\n    }\r\n\r\n    @SuppressWarnings(\"deprecation\")\r\n    public void onRemove(BlockState pState, Level pLevel, BlockPos pPos, BlockState pNewState, boolean pIsMoving) {\r\n        if (!pState.is(pNewState.getBlock())) {\r\n            BlockEntity blockentity = pLevel.getBlockEntity(pPos);\r\n            if (blockentity instanceof PrintingPressBlockEntity blockEntity) {\r\n                for (ItemStack itemStack : blockEntity.getStacksToDrop()) {\r\n                    Containers.dropItemStack(pLevel, pPos.getX(), pPos.getY(), pPos.getZ(), itemStack);\r\n                }\r\n                pLevel.updateNeighbourForOutputSignal(pPos, this);\r\n            }\r\n\r\n            super.onRemove(pState, pLevel, pPos, pNewState, pIsMoving);\r\n        }\r\n    }\r\n\r\n\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\client\\jei\\FallingAnvilExperienceShardRecipe.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.client.jei;\r\n\r\npublic class FallingAnvilExperienceShardRecipe extends FallingAnvilRecipe {\r\n\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\net\\ClientboundContainerExportsInspectionResultsPacket.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.common.net;\r\n\r\nimport ca.teamdman.sfm.client.ClientStuff;\r\nimport net.minecraft.client.Minecraft;\r\nimport net.minecraft.client.player.LocalPlayer;\r\nimport net.minecraft.network.FriendlyByteBuf;\r\nimport net.minecraftforge.network.NetworkEvent;\r\n\r\nimport java.util.function.Supplier;\r\n\r\npublic record ClientboundContainerExportsInspectionResultsPacket(\r\n        int windowId,\r\n        String results\r\n) {\r\n    public static final int MAX_RESULTS_LENGTH = 20480;\r\n\r\n    public static void encode(\r\n            ClientboundContainerExportsInspectionResultsPacket msg, FriendlyByteBuf friendlyByteBuf\r\n    ) {\r\n        friendlyByteBuf.writeVarInt(msg.windowId());\r\n        friendlyByteBuf.writeUtf(msg.results(), MAX_RESULTS_LENGTH);\r\n    }\r\n\r\n    public static ClientboundContainerExportsInspectionResultsPacket decode(FriendlyByteBuf friendlyByteBuf) {\r\n        return new ClientboundContainerExportsInspectionResultsPacket(\r\n                friendlyByteBuf.readVarInt(),\r\n                friendlyByteBuf.readUtf(MAX_RESULTS_LENGTH)\r\n        );\r\n    }\r\n\r\n    public static void handle(\r\n            ClientboundContainerExportsInspectionResultsPacket msg, Supplier<NetworkEvent.Context> contextSupplier\r\n    ) {\r\n        contextSupplier.get().enqueueWork(() -> {\r\n            LocalPlayer player = Minecraft.getInstance().player;\r\n            if (player == null) return;\r\n            var container = player.containerMenu;\r\n            if (container.containerId != msg.windowId) return;\r\n            ClientStuff.showProgramEditScreen(msg.results, next -> {\r\n            });\r\n        });\r\n        contextSupplier.get().setPacketHandled(true);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfml\\ast\\NumberRange.java\r\n\r\n````java\r\npackage ca.teamdman.sfml.ast;\r\n\r\npublic record NumberRange(\r\n        long start,\r\n        long end\r\n) implements ASTNode {\r\n    public static final NumberRange MAX_RANGE = new NumberRange(Long.MIN_VALUE, Long.MAX_VALUE);\r\n\r\n    /**\r\n     * Inclusive\r\n     */\r\n    public boolean contains(int value) {\r\n        return value >= start && value <= end;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        if (start == end) return String.valueOf(start);\r\n        return start + \"-\" + end;\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfml\\ast\\SetOperator.java\r\n\r\n````java\r\npackage ca.teamdman.sfml.ast;\r\n\r\nimport java.util.List;\r\nimport java.util.Locale;\r\nimport java.util.function.BiPredicate;\r\n\r\npublic enum SetOperator implements ASTNode, BiPredicate<Boolean, List<Boolean>> {\r\n    OVERALL((overall, __) -> overall),\r\n    SOME((__, set) -> set.stream().anyMatch(Boolean::booleanValue)),\r\n    EVERY((__, set) -> set.stream().allMatch(Boolean::booleanValue)),\r\n    ONE((__, set) -> set.stream().filter(Boolean::booleanValue).count() == 1),\r\n    LONE((__, set) -> set.stream().filter(Boolean::booleanValue).count() <= 1);\r\n\r\n    private final BiPredicate<Boolean, List<Boolean>> PRED;\r\n\r\n    SetOperator(BiPredicate<Boolean, List<Boolean>> pred) {\r\n        this.PRED = pred;\r\n    }\r\n\r\n    public static SetOperator from(String text) {\r\n        text = text.toUpperCase(Locale.ROOT);\r\n        if (text.equals(\"EACH\")) {\r\n            text = \"EVERY\";\r\n        }\r\n        return SetOperator.valueOf(text);\r\n    }\r\n\r\n    @Override\r\n    public boolean test(Boolean overall, List<Boolean> counts) {\r\n        return PRED.test(overall, counts);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\program\\LimitedOutputSlot.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.common.program;\r\n\r\nimport ca.teamdman.sfm.common.resourcetype.ResourceType;\r\n\r\nimport javax.annotation.Nullable;\r\n\r\npublic class LimitedOutputSlot<STACK, ITEM, CAP> {\r\n    @SuppressWarnings(\"NotNullFieldNotInitialized\") // done in init method in constructor\r\n    public ResourceType<STACK, ITEM, CAP> type;\r\n    @SuppressWarnings(\"NotNullFieldNotInitialized\") // done in init method in constructor\r\n    public CAP capability;\r\n    public int slot;\r\n    @SuppressWarnings(\"NotNullFieldNotInitialized\") // done in init method in constructor\r\n    public OutputResourceTracker<STACK, ITEM, CAP> tracker;\r\n    private @Nullable STACK stackInSlotCache = null;\r\n\r\n    public LimitedOutputSlot(\r\n            CAP capability, int slot, OutputResourceTracker<STACK, ITEM, CAP> tracker\r\n    ) {\r\n        this.init(capability, slot, tracker);\r\n    }\r\n\r\n    public boolean isDone() {\r\n        if (tracker.isDone()) {\r\n            return true;\r\n        }\r\n        STACK stack = getStackInSlot();\r\n        long count = type.getAmount(stack);\r\n        if (count >= type.getMaxStackSize(capability, slot)) {\r\n            // if the maxStackSize is different, that will be handled by moveTo\r\n            // for the general case, it will be faster to just assume 64 is the max stack size\r\n            return true;\r\n        }\r\n        return count != 0 && !tracker.test(stack);\r\n    }\r\n\r\n    public STACK getStackInSlot() {\r\n        if (stackInSlotCache == null) {\r\n            stackInSlotCache = type.getStackInSlot(capability, slot);\r\n        }\r\n        return stackInSlotCache;\r\n    }\r\n\r\n    public STACK insert(STACK stack, boolean simulate) {\r\n        if (!simulate) stackInSlotCache = null;\r\n        return type.insert(capability, slot, stack, simulate);\r\n    }\r\n\r\n    public void init(CAP handler, int slot, OutputResourceTracker<STACK, ITEM, CAP> tracker) {\r\n        this.stackInSlotCache = null;\r\n        this.capability = handler;\r\n        this.tracker = tracker;\r\n        this.slot = slot;\r\n        //noinspection DataFlowIssue\r\n        this.type = tracker.getLimit().resourceId().getResourceType();\r\n        assert type != null;\r\n        this.tracker.visit(this);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\recipe\\DiskResetRecipe.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.common.recipe;\r\n\r\nimport ca.teamdman.sfm.common.item.DiskItem;\r\nimport ca.teamdman.sfm.common.registry.SFMItems;\r\nimport ca.teamdman.sfm.common.registry.SFMRecipeSerializers;\r\nimport net.minecraft.resources.ResourceLocation;\r\nimport net.minecraft.world.inventory.CraftingContainer;\r\nimport net.minecraft.world.item.ItemStack;\r\nimport net.minecraft.world.item.crafting.CustomRecipe;\r\nimport net.minecraft.world.item.crafting.RecipeSerializer;\r\nimport net.minecraft.world.level.Level;\r\n\r\n/**\r\n * Printing press copies a form using ink and paper.\r\n */\r\npublic class DiskResetRecipe extends CustomRecipe {\r\n    public DiskResetRecipe(ResourceLocation pId) {\r\n        super(pId);\r\n    }\r\n\r\n    @Override\r\n    public boolean matches(CraftingContainer pContainer, Level pLevel) {\r\n        int foundDisks = 0;\r\n        for (int i = 0; i < pContainer.getContainerSize(); i++) {\r\n            ItemStack stack = pContainer.getItem(i);\r\n            if (stack.getItem() instanceof DiskItem) {\r\n                foundDisks++;\r\n            } else if (!stack.isEmpty()) {\r\n                return false;\r\n            }\r\n        }\r\n        return foundDisks > 0;\r\n    }\r\n\r\n    @Override\r\n    public ItemStack assemble(CraftingContainer pContainer) {\r\n        int foundDisks = 0;\r\n        for (int i = 0; i < pContainer.getContainerSize(); i++) {\r\n            ItemStack stack = pContainer.getItem(i);\r\n            if (stack.getItem() instanceof DiskItem) {\r\n                foundDisks++;\r\n            } else if (!stack.isEmpty()) {\r\n                return ItemStack.EMPTY;\r\n            }\r\n        }\r\n        return foundDisks > 0 ? new ItemStack(SFMItems.DISK_ITEM.get(), foundDisks) : ItemStack.EMPTY;\r\n    }\r\n\r\n    @Override\r\n    public boolean canCraftInDimensions(int pWidth, int pHeight) {\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public RecipeSerializer<?> getSerializer() {\r\n        return SFMRecipeSerializers.DISK_RESET.get();\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\client\\jei\\FallingAnvilDisenchantRecipe.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.client.jei;\r\n\r\npublic class FallingAnvilDisenchantRecipe extends FallingAnvilRecipe {\r\n\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\net\\ClientboundOutputInspectionResultsPacket.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.common.net;\r\n\r\nimport ca.teamdman.sfm.client.ClientStuff;\r\nimport net.minecraft.network.FriendlyByteBuf;\r\nimport net.minecraftforge.network.NetworkEvent;\r\n\r\nimport java.util.function.Supplier;\r\n\r\npublic record ClientboundOutputInspectionResultsPacket(\r\n        String results\r\n) {\r\n    public static final int MAX_RESULTS_LENGTH = 10240;\r\n\r\n    public static void encode(\r\n            ClientboundOutputInspectionResultsPacket msg, FriendlyByteBuf friendlyByteBuf\r\n    ) {\r\n        friendlyByteBuf.writeUtf(msg.results(), MAX_RESULTS_LENGTH);\r\n    }\r\n\r\n    public static ClientboundOutputInspectionResultsPacket decode(FriendlyByteBuf friendlyByteBuf) {\r\n        return new ClientboundOutputInspectionResultsPacket(\r\n                friendlyByteBuf.readUtf(MAX_RESULTS_LENGTH)\r\n        );\r\n    }\r\n\r\n    public static void handle(\r\n            ClientboundOutputInspectionResultsPacket msg, Supplier<NetworkEvent.Context> contextSupplier\r\n    ) {\r\n        contextSupplier.get().enqueueWork(() -> ClientStuff.showProgramEditScreen(msg.results, next -> {\r\n        }));\r\n        contextSupplier.get().setPacketHandled(true);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\client\\handler\\LabelGunScrollSwitcher.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.client.handler;\r\n\r\nimport ca.teamdman.sfm.SFM;\r\nimport ca.teamdman.sfm.common.item.LabelGunItem;\r\nimport ca.teamdman.sfm.common.net.ServerboundLabelGunUpdatePacket;\r\nimport ca.teamdman.sfm.common.registry.SFMPackets;\r\nimport net.minecraft.client.Minecraft;\r\nimport net.minecraft.world.InteractionHand;\r\nimport net.minecraftforge.api.distmarker.Dist;\r\nimport net.minecraftforge.client.event.InputEvent;\r\nimport net.minecraftforge.eventbus.api.SubscribeEvent;\r\nimport net.minecraftforge.fml.common.Mod;\r\n\r\n@Mod.EventBusSubscriber(modid = SFM.MOD_ID, bus = Mod.EventBusSubscriber.Bus.FORGE, value = Dist.CLIENT)\r\npublic class LabelGunScrollSwitcher {\r\n    @SubscribeEvent\r\n    public static void onScroll(InputEvent.MouseScrollingEvent event) {\r\n        var player = Minecraft.getInstance().player;\r\n        if (player == null) return;\r\n        if (!player.isShiftKeyDown()) return;\r\n        var gun  = player.getMainHandItem();\r\n        var hand = InteractionHand.MAIN_HAND;\r\n        if (!(gun.getItem() instanceof LabelGunItem)) {\r\n            gun  = player.getOffhandItem();\r\n            hand = InteractionHand.OFF_HAND;\r\n        }\r\n        if (!(gun.getItem() instanceof LabelGunItem)) return;\r\n\r\n        var next = LabelGunItem.getNextLabel(gun, event.getScrollDelta() < 0 ? -1 : 1);\r\n        SFMPackets.LABEL_GUN_ITEM_CHANNEL.sendToServer(new ServerboundLabelGunUpdatePacket(\r\n                next,\r\n                hand\r\n        ));\r\n\r\n        event.setCanceled(true);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\recipe\\PrintingPressFinishedRecipe.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.common.recipe;\r\n\r\nimport ca.teamdman.sfm.common.registry.SFMRecipeSerializers;\r\nimport com.google.gson.JsonObject;\r\nimport net.minecraft.data.recipes.FinishedRecipe;\r\nimport net.minecraft.resources.ResourceLocation;\r\nimport net.minecraft.world.item.crafting.Ingredient;\r\nimport net.minecraft.world.item.crafting.RecipeSerializer;\r\n\r\npublic class PrintingPressFinishedRecipe implements FinishedRecipe {\r\n    private final ResourceLocation id;\r\n    private final Ingredient form;\r\n    private final Ingredient ink;\r\n    private final Ingredient paper;\r\n\r\n    public PrintingPressFinishedRecipe(\r\n            ResourceLocation id,\r\n            Ingredient form,\r\n            Ingredient ink,\r\n            Ingredient paper\r\n    ) {\r\n        this.id = id;\r\n        this.form = form;\r\n        this.ink = ink;\r\n        this.paper = paper;\r\n    }\r\n\r\n    @Override\r\n    public void serializeRecipeData(JsonObject json) {\r\n        json.add(\"form\", form.toJson());\r\n        json.add(\"ink\", ink.toJson());\r\n        json.add(\"paper\", paper.toJson());\r\n    }\r\n\r\n    @Override\r\n    public ResourceLocation getId() {\r\n        return id;\r\n    }\r\n\r\n    @Override\r\n    public RecipeSerializer<?> getType() {\r\n        return SFMRecipeSerializers.PRINTING_PRESS.get();\r\n    }\r\n\r\n    @Override\r\n    public JsonObject serializeAdvancement() {\r\n        return null; // No advancements needed for this recipe\r\n    }\r\n\r\n    @Override\r\n    public ResourceLocation getAdvancementId() {\r\n        return new ResourceLocation(\"\");\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\net\\ServerboundInputInspectionRequestPacket.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.common.net;\r\n\r\nimport ca.teamdman.sfm.common.blockentity.ManagerBlockEntity;\r\nimport ca.teamdman.sfm.common.containermenu.ManagerContainerMenu;\r\nimport ca.teamdman.sfm.common.program.ProgramContext;\r\nimport ca.teamdman.sfm.common.registry.SFMPackets;\r\nimport ca.teamdman.sfm.common.util.SFMUtils;\r\nimport ca.teamdman.sfml.ast.InputStatement;\r\nimport ca.teamdman.sfml.ast.Program;\r\nimport net.minecraft.network.FriendlyByteBuf;\r\nimport net.minecraft.server.level.ServerPlayer;\r\nimport net.minecraftforge.network.NetworkEvent;\r\nimport net.minecraftforge.network.PacketDistributor;\r\n\r\nimport java.util.function.Supplier;\r\n\r\npublic record ServerboundInputInspectionRequestPacket(\r\n        String programString,\r\n        int inputNodeIndex\r\n) {\r\n    public static void encode(ServerboundInputInspectionRequestPacket msg, FriendlyByteBuf friendlyByteBuf) {\r\n        friendlyByteBuf.writeUtf(msg.programString, Program.MAX_PROGRAM_LENGTH);\r\n        friendlyByteBuf.writeInt(msg.inputNodeIndex());\r\n    }\r\n\r\n    public static ServerboundInputInspectionRequestPacket decode(FriendlyByteBuf friendlyByteBuf) {\r\n        return new ServerboundInputInspectionRequestPacket(\r\n                friendlyByteBuf.readUtf(Program.MAX_PROGRAM_LENGTH),\r\n                friendlyByteBuf.readInt()\r\n        );\r\n    }\r\n\r\n    public static void handle(\r\n            ServerboundInputInspectionRequestPacket msg, Supplier<NetworkEvent.Context> contextSupplier\r\n    ) {\r\n        contextSupplier.get().enqueueWork(() -> {\r\n            // we don't know if the player has the program edit screen open from a manager or a disk in hand\r\n            ServerPlayer player = contextSupplier.get().getSender();\r\n            if (player == null) return;\r\n            ManagerBlockEntity manager;\r\n            if (player.containerMenu instanceof ManagerContainerMenu mcm) {\r\n                if (player.getLevel().getBlockEntity(mcm.MANAGER_POSITION) instanceof ManagerBlockEntity mbe) {\r\n                    manager = mbe;\r\n                } else {\r\n                    return;\r\n                }\r\n            } else {\r\n                //todo: localize\r\n                SFMPackets.INSPECTION_CHANNEL.send(\r\n                        PacketDistributor.PLAYER.with(() -> player),\r\n                        new ClientboundInputInspectionResultsPacket(\r\n                                \"This inspection is only available when editing inside a manager.\")\r\n                );\r\n                return;\r\n            }\r\n            Program.compile(\r\n                    msg.programString,\r\n                    (successProgram, builder) -> builder\r\n                            .getNodeAtIndex(msg.inputNodeIndex)\r\n                            .filter(InputStatement.class::isInstance)\r\n                            .map(InputStatement.class::cast)\r\n                            .ifPresent(inputStatement -> {\r\n                                StringBuilder payload = new StringBuilder();\r\n                                payload\r\n                                        .append(inputStatement.toStringPretty())\r\n                                        .append(\"\\n-- peek results --\\n\");\r\n\r\n                                ProgramContext context = new ProgramContext(\r\n                                        successProgram,\r\n                                        manager,\r\n                                        ProgramContext.ExecutionPolicy.EXPLORE_BRANCHES\r\n                                );\r\n                                int preLen = payload.length();\r\n                                inputStatement.gatherSlots(\r\n                                        context,\r\n                                        slot -> SFMUtils\r\n                                                .getInputStatementForSlot(\r\n                                                        slot,\r\n                                                        inputStatement.labelAccess()\r\n                                                )\r\n                                                .ifPresent(is -> payload\r\n                                                        .append(is.toStringPretty())\r\n                                                        .append(\"\\n\"))\r\n                                );\r\n                                if (payload.length() == preLen) {\r\n                                    payload.append(\"none\");\r\n                                }\r\n\r\n                                SFMPackets.INSPECTION_CHANNEL.send(\r\n                                        PacketDistributor.PLAYER.with(() -> player),\r\n                                        new ClientboundInputInspectionResultsPacket(\r\n                                                SFMUtils.truncate(\r\n                                                        payload.toString(),\r\n                                                        ClientboundInputInspectionResultsPacket.MAX_RESULTS_LENGTH\r\n                                                ))\r\n                                );\r\n                            }),\r\n                    failure -> {\r\n                    }\r\n            );\r\n        });\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfml\\ast\\LabelAccess.java\r\n\r\n````java\r\npackage ca.teamdman.sfml.ast;\r\n\r\nimport java.util.List;\r\nimport java.util.Objects;\r\nimport java.util.stream.Collectors;\r\n\r\npublic record LabelAccess(\r\n        List<Label> labels,\r\n        DirectionQualifier directions,\r\n        NumberRangeSet slots,\r\n        RoundRobin roundRobin\r\n) implements ASTNode {\r\n    @Override\r\n    public String toString() {\r\n        StringBuilder builder = new StringBuilder();\r\n        builder.append(labels.stream().map(Objects::toString).collect(Collectors.joining(\", \")));\r\n        if (roundRobin.isEnabled()) {\r\n            builder.append(\" \").append(roundRobin);\r\n        }\r\n        if (!directions.directions().isEmpty()) {\r\n            builder.append(\" \");\r\n            builder\r\n                    .append(directions\r\n                                    .stream()\r\n                                    .map(DirectionQualifier::directionToString)\r\n                                    .collect(Collectors.joining(\", \")))\r\n                    .append(\" SIDE\");\r\n        }\r\n        if (slots.ranges().length > 0) {\r\n            if (slots.ranges().length != 1 || !slots.ranges()[0].equals(NumberRange.MAX_RANGE)) {\r\n                builder.append(\" SLOTS\");\r\n                for (NumberRange range : slots.ranges()) {\r\n                    builder.append(\" \").append(range);\r\n                }\r\n            }\r\n        }\r\n        return builder.toString();\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\program\\package-info.java\r\n\r\n````java\r\n\r\n\r\n@ParametersAreNonnullByDefault\r\n@MethodsReturnNonnullByDefault\r\n@FieldsAreNonnullByDefault\r\npackage ca.teamdman.sfm.common.program;\r\n\r\nimport net.minecraft.FieldsAreNonnullByDefault;\r\nimport net.minecraft.MethodsReturnNonnullByDefault;\r\n\r\nimport javax.annotation.ParametersAreNonnullByDefault;\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\registry\\SFMRecipeTypes.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.common.registry;\r\n\r\nimport ca.teamdman.sfm.SFM;\r\nimport ca.teamdman.sfm.common.recipe.PrintingPressRecipe;\r\nimport net.minecraft.resources.ResourceLocation;\r\nimport net.minecraft.world.item.crafting.RecipeType;\r\nimport net.minecraftforge.eventbus.api.IEventBus;\r\nimport net.minecraftforge.registries.DeferredRegister;\r\nimport net.minecraftforge.registries.ForgeRegistries;\r\nimport net.minecraftforge.registries.RegistryObject;\r\n\r\npublic class SFMRecipeTypes {\r\n    private static final DeferredRegister<RecipeType<?>> RECIPE_TYPES = DeferredRegister.create(\r\n            ForgeRegistries.RECIPE_TYPES,\r\n            SFM.MOD_ID\r\n    );\r\n\r\n    public static final RegistryObject<RecipeType<PrintingPressRecipe>> PRINTING_PRESS = RECIPE_TYPES.register(\r\n            \"printing_press\",\r\n            () -> RecipeType.simple(new ResourceLocation(SFM.MOD_ID, \"printing_press\"))\r\n    );\r\n\r\n    public static void register(IEventBus bus) {\r\n        RECIPE_TYPES.register(bus);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\item\\ExperienceGoop.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.common.item;\r\n\r\nimport ca.teamdman.sfm.common.registry.SFMItems;\r\nimport net.minecraft.world.item.Item;\r\n\r\npublic class ExperienceGoop extends Item {\r\n    public ExperienceGoop() {\r\n        super(new Properties().tab(SFMItems.TAB));\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\client\\gui\\screen\\LabelGunScreen.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.client.gui.screen;\r\n\r\nimport ca.teamdman.sfm.common.Constants;\r\nimport ca.teamdman.sfm.common.net.ServerboundLabelGunClearPacket;\r\nimport ca.teamdman.sfm.common.net.ServerboundLabelGunPrunePacket;\r\nimport ca.teamdman.sfm.common.net.ServerboundLabelGunUpdatePacket;\r\nimport ca.teamdman.sfm.common.program.LabelPositionHolder;\r\nimport ca.teamdman.sfm.common.registry.SFMPackets;\r\nimport com.mojang.blaze3d.vertex.PoseStack;\r\nimport net.minecraft.client.Minecraft;\r\nimport net.minecraft.client.gui.components.Button;\r\nimport net.minecraft.client.gui.components.EditBox;\r\nimport net.minecraft.client.gui.screens.Screen;\r\nimport net.minecraft.network.chat.CommonComponents;\r\nimport net.minecraft.world.InteractionHand;\r\nimport net.minecraft.world.item.ItemStack;\r\nimport org.lwjgl.glfw.GLFW;\r\n\r\nimport java.util.Comparator;\r\n\r\npublic class LabelGunScreen extends Screen {\r\n    private final InteractionHand HAND;\r\n    private final LabelPositionHolder LABEL_HOLDER;\r\n    @SuppressWarnings(\"NotNullFieldNotInitialized\")\r\n    private EditBox labelField;\r\n    private boolean shouldRebuildWidgets = false;\r\n\r\n    public LabelGunScreen(ItemStack labelGunStack, InteractionHand hand) {\r\n        super(Constants.LocalizationKeys.LABEL_GUN_GUI_TITLE.getComponent());\r\n        LABEL_HOLDER = LabelPositionHolder.from(labelGunStack);\r\n        HAND = hand;\r\n    }\r\n\r\n    @Override\r\n    protected void init() {\r\n        super.init();\r\n        assert this.minecraft != null;\r\n        this.minecraft.keyboardHandler.setSendRepeatsToGui(true);\r\n        this.labelField = addRenderableWidget(new EditBox(\r\n                this.font,\r\n                this.width / 2 - 150,\r\n                50,\r\n                300,\r\n                20,\r\n                Constants.LocalizationKeys.LABEL_GUN_GUI_LABEL_PLACEHOLDER.getComponent()\r\n        ));\r\n        this.setInitialFocus(labelField);\r\n        this.setFocused(labelField);\r\n        this.labelField.setFocus(true);\r\n\r\n        this.addRenderableWidget(new Button(\r\n                this.width / 2 - 210,\r\n                50,\r\n                50,\r\n                20,\r\n                Constants.LocalizationKeys.LABEL_GUN_GUI_CLEAR_BUTTON.getComponent(),\r\n                (btn) -> {\r\n                    SFMPackets.LABEL_GUN_ITEM_CHANNEL.sendToServer(new ServerboundLabelGunClearPacket(HAND));\r\n                    LABEL_HOLDER.clear();\r\n                    shouldRebuildWidgets = true;\r\n                }\r\n        ));\r\n        this.addRenderableWidget(new Button(\r\n                this.width / 2 + 160,\r\n                50,\r\n                50,\r\n                20,\r\n                Constants.LocalizationKeys.LABEL_GUN_GUI_PRUNE_BUTTON.getComponent(),\r\n                (btn) -> {\r\n                    SFMPackets.LABEL_GUN_ITEM_CHANNEL.sendToServer(new ServerboundLabelGunPrunePacket(HAND));\r\n                    LABEL_HOLDER.prune();\r\n                    shouldRebuildWidgets = true;\r\n                }\r\n        ));\r\n        this.addRenderableWidget(new Button(\r\n                this.width / 2 - 2 - 150,\r\n                this.height - 50,\r\n                300,\r\n                20,\r\n                CommonComponents.GUI_DONE,\r\n                (p_97691_) -> this.onDone()\r\n        ));\r\n        {\r\n            var labels = LABEL_HOLDER.get().keySet().stream().sorted(Comparator.naturalOrder()).toList();\r\n            int i = 0;\r\n            int buttonWidth = LABEL_HOLDER.get()\r\n                                      .entrySet()\r\n                                      .stream()\r\n                                      .map(entry -> Constants.LocalizationKeys.LABEL_GUN_GUI_LABEL_BUTTON.getComponent(\r\n                                              entry.getKey(),\r\n                                              entry.getValue().size()\r\n                                      ).getString())\r\n                                      .mapToInt(this.font::width)\r\n                                      .max().orElse(50) + 10;\r\n            int buttonHeight = 20;\r\n            int paddingX = 5;\r\n            int paddingY = 5;\r\n            int buttonsPerRow = this.width / (buttonWidth + paddingX);\r\n            for (var label : labels) {\r\n                int x = (this.width - (buttonWidth + paddingX) * Math.min(buttonsPerRow, labels.size())) / 2\r\n                        + paddingX\r\n                        + (i % buttonsPerRow) * (\r\n                        buttonWidth\r\n                        + paddingX\r\n                );\r\n                int y = 80 + (i / buttonsPerRow) * (buttonHeight + paddingY);\r\n                int count = LABEL_HOLDER.getPositions(label).size();\r\n                this.addRenderableWidget(new Button(\r\n                        x,\r\n                        y,\r\n                        buttonWidth,\r\n                        buttonHeight,\r\n                        Constants.LocalizationKeys.LABEL_GUN_GUI_LABEL_BUTTON.getComponent(label, count),\r\n                        (btn) -> {\r\n                            this.labelField.setValue(label);\r\n                            this.onDone();\r\n                        }\r\n                ));\r\n                i++;\r\n            }\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public boolean keyPressed(int key, int mod1, int mod2) {\r\n        if (super.keyPressed(key, mod1, mod2)) return true;\r\n        if (key != GLFW.GLFW_KEY_ENTER && key != GLFW.GLFW_KEY_KP_ENTER) return false;\r\n        onDone();\r\n        return true;\r\n    }\r\n\r\n    public void onDone() {\r\n        SFMPackets.LABEL_GUN_ITEM_CHANNEL.sendToServer(new ServerboundLabelGunUpdatePacket(\r\n                labelField.getValue(),\r\n                HAND\r\n        ));\r\n        onClose();\r\n    }\r\n\r\n    @Override\r\n    public void resize(Minecraft mc, int x, int y) {\r\n        var prev = this.labelField.getValue();\r\n        init(mc, x, y);\r\n        super.resize(mc, x, y);\r\n        this.labelField.setValue(prev);\r\n    }\r\n\r\n    @Override\r\n    public void render(PoseStack poseStack, int mx, int my, float partialTicks) {\r\n        if (shouldRebuildWidgets) {\r\n            // we delay this because focus gets reset _after_ the button event handler\r\n            // we want to end with the label input field focused\r\n            shouldRebuildWidgets = false;\r\n            rebuildWidgets();\r\n        }\r\n        this.renderBackground(poseStack);\r\n        super.render(poseStack, mx, my, partialTicks);\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\containermenu\\package-info.java\r\n\r\n````java\r\n\r\n\r\n@ParametersAreNonnullByDefault\r\n@MethodsReturnNonnullByDefault\r\n@FieldsAreNonnullByDefault\r\npackage ca.teamdman.sfm.common.containermenu;\r\n\r\nimport net.minecraft.FieldsAreNonnullByDefault;\r\nimport net.minecraft.MethodsReturnNonnullByDefault;\r\n\r\nimport javax.annotation.ParametersAreNonnullByDefault;\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\blockentity\\WaterTankBlockEntity.java\r\n\r\n````java\r\npackage ca.teamdman.sfm.common.blockentity;\r\n\r\nimport ca.teamdman.sfm.common.block.WaterTankBlock;\r\nimport ca.teamdman.sfm.common.registry.SFMBlockEntities;\r\nimport net.minecraft.core.BlockPos;\r\nimport net.minecraft.core.Direction;\r\nimport net.minecraft.world.level.block.entity.BlockEntity;\r\nimport net.minecraft.world.level.block.state.BlockState;\r\nimport net.minecraft.world.level.material.Fluids;\r\nimport net.minecraftforge.common.capabilities.Capability;\r\nimport net.minecraftforge.common.capabilities.ForgeCapabilities;\r\nimport net.minecraftforge.common.util.LazyOptional;\r\nimport net.minecraftforge.fluids.FluidStack;\r\nimport net.minecraftforge.fluids.capability.IFluidHandler;\r\nimport net.minecraftforge.fluids.capability.templates.FluidTank;\r\nimport org.jetbrains.annotations.NotNull;\r\nimport org.jetbrains.annotations.Nullable;\r\n\r\npublic class WaterTankBlockEntity extends BlockEntity {\r\n    public void setConnectedCount(int connectedCount) {\r\n        TANK.setCapacity(connectedCount * 1000);\r\n        TANK.getFluid().setAmount(TANK.getCapacity());\r\n    }\r\n\r\n    @Override\r\n    public void onLoad() {\r\n        super.onLoad();\r\n        ((WaterTankBlock) getBlockState().getBlock()).recount(getLevel(), getBlockPos());\r\n    }\r\n\r\n    // can't fill, only extract\r\n    public final FluidTank TANK = new FluidTank(1000, fluidStack -> false) {\r\n        {\r\n            setFluid(new FluidStack(Fluids.WATER, 1000));\r\n        }\r\n\r\n        @Override\r\n        public @NotNull FluidStack drain(int maxDrain, FluidAction action) {\r\n            if (!getLevel().getBlockState(getBlockPos()).getValue(WaterTankBlock.IN_WATER)) return FluidStack.EMPTY;\r\n            int        drained = Math.min(maxDrain, TANK.getCapacity());\r\n            FluidStack copy    = fluid.copy();\r\n            copy.setAmount(drained);\r\n            return copy;\r\n        }\r\n    };\r\n\r\n    public final LazyOptional<IFluidHandler> TANK_CAPABILITY = LazyOptional.of(() -> TANK);\r\n\r\n    public WaterTankBlockEntity(\r\n            BlockPos pos,\r\n            BlockState state\r\n    ) {\r\n        super(SFMBlockEntities.WATER_TANK_BLOCK_ENTITY.get(), pos, state);\r\n    }\r\n\r\n    @Override\r\n    public @NotNull <T> LazyOptional<T> getCapability(@NotNull Capability<T> cap, @Nullable Direction side) {\r\n        if (cap == ForgeCapabilities.FLUID_HANDLER) {\r\n            return TANK_CAPABILITY.cast();\r\n        } else {\r\n            return super.getCapability(cap, side);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void invalidateCaps() {\r\n        TANK_CAPABILITY.invalidate();\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfml\\ast\\Interval.java\r\n\r\n````java\r\npackage ca.teamdman.sfml.ast;\r\n\r\npublic record Interval(int ticks) implements ASTNode {\r\n    public static Interval fromTicks(int ticks) {\r\n        return new Interval(ticks);\r\n    }\r\n\r\n    public static Interval fromSeconds(int seconds) {\r\n        return new Interval(seconds * 20);\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return ticks + \" TICKS\";\r\n    }\r\n\r\n    public int getTicks() {\r\n        return ticks;\r\n    }\r\n\r\n    public int getSeconds() {\r\n        return ticks / 20;\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfml\\ast\\RedstoneTrigger.java\r\n\r\n````java\r\npackage ca.teamdman.sfml.ast;\r\n\r\nimport ca.teamdman.sfm.common.program.ProgramContext;\r\n\r\npublic record RedstoneTrigger(\r\n        Block block\r\n) implements Trigger {\r\n    @Override\r\n    public Block getBlock() {\r\n        return block;\r\n    }\r\n\r\n    @Override\r\n    public void tick(ProgramContext context) {\r\n        for (int i = 0; i < context.getRedstonePulses(); i++) {\r\n            block.tick(context);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public boolean shouldTick(ProgramContext context) {\r\n        if (context.getExecutionPolicy() == ProgramContext.ExecutionPolicy.EXPLORE_BRANCHES) return true;\r\n        return context.getManager().getUnprocessedRedstonePulseCount() > 0;\r\n    }\r\n}\r\n\r\n````\r\n\r\n\r\n\r\n## D:\\repos\\Minecraft\\Forge\\SuperFactoryManager\\src\\main\\java\\ca\\teamdman\\sfm\\common\\item\\package-info.java\r\n\r\n````java\r\n\r\n\r\n@ParametersAreNonnullByDefault\r\n@MethodsReturnNonnullByDefault\r\n@FieldsAreNonnullByDefault\r\npackage ca.teamdman.sfm.common.item;\r\n\r\nimport net.minecraft.FieldsAreNonnullByDefault;\r\nimport net.minecraft.MethodsReturnNonnullByDefault;\r\n\r\nimport javax.annotation.ParametersAreNonnullByDefault;\r\n````\r\n\r\n\r\n\r\nThat is part of the source code for SuperFactoryManager.\r\n\r\nThe mod has been experiencing a problem related to the manager no longer moving items, triggered by chunk loading.\r\n\r\nA reproduction of the problem is accomplished by setting up a manager with a program at 10000,4,10000\r\nin a superflat world, teleporting away, and coming back.\r\n\r\nI have isolated the problem to ResourceType.java\r\n\r\n\r\n    public Stream<CAP> getCapabilities(\r\n            ProgramContext programContext, LabelAccess labelAccess\r\n    ) {\r\n        Optional<ItemStack> disk = programContext.getManager().getDisk();\r\n        if (disk.isEmpty()) return Stream.empty();\r\n        LabelPositionHolder labelPositions = LabelPositionHolder.from(disk.get());\r\n        CableNetwork network = programContext.getNetwork();\r\n        return labelAccess.roundRobin().gather(labelAccess, labelPositions)\r\n                .map(network::getCapabilityProvider)\r\n                .filter(Optional::isPresent)\r\n                .map(Optional::get)\r\n                .flatMap((\r\n                                 prov -> labelAccess\r\n                                         .directions()\r\n                                         .stream()\r\n                                         .map(direction -> prov.getCapability(CAPABILITY, direction))\r\n                         ))\r\n                .map(x -> {\r\n                    //noinspection DataFlowIssue\r\n                    return x.orElse(null);\r\n                })\r\n                .filter(x -> {\r\n                    //noinspection ConstantValue,Convert2MethodRef\r\n                    return x != null;\r\n                });\r\n    }\r\n\r\nThis uses the network::getCapabilityProvider method, which has cached the capability provider.\r\n\r\nHere is the code for CapabilityProvider.class\r\n\r\n//\r\n// Source code recreated from a .class file by IntelliJ IDEA\r\n// (powered by FernFlower decompiler)\r\n//\r\n\r\npackage net.minecraftforge.common.capabilities;\r\n\r\nimport com.google.common.annotations.VisibleForTesting;\r\nimport java.util.function.Supplier;\r\nimport javax.annotation.ParametersAreNonnullByDefault;\r\nimport net.minecraft.MethodsReturnNonnullByDefault;\r\nimport net.minecraft.core.Direction;\r\nimport net.minecraft.nbt.CompoundTag;\r\nimport net.minecraftforge.common.util.LazyOptional;\r\nimport net.minecraftforge.event.ForgeEventFactory;\r\nimport org.jetbrains.annotations.NotNull;\r\nimport org.jetbrains.annotations.Nullable;\r\n\r\n@MethodsReturnNonnullByDefault\r\n@ParametersAreNonnullByDefault\r\npublic abstract class CapabilityProvider<B extends ICapabilityProviderImpl<B>> implements ICapabilityProviderImpl<B> {\r\n    @VisibleForTesting\r\n    static boolean SUPPORTS_LAZY_CAPABILITIES = true;\r\n    private final @NotNull Class<B> baseClass;\r\n    private @Nullable CapabilityDispatcher capabilities;\r\n    private boolean valid;\r\n    private boolean isLazy;\r\n    private Supplier<ICapabilityProvider> lazyParentSupplier;\r\n    private CompoundTag lazyData;\r\n    private boolean initialized;\r\n\r\n    protected CapabilityProvider(Class<B> baseClass) {\r\n        this(baseClass, false);\r\n    }\r\n\r\n    protected CapabilityProvider(Class<B> baseClass, boolean isLazy) {\r\n        this.valid = true;\r\n        this.isLazy = false;\r\n        this.lazyParentSupplier = null;\r\n        this.lazyData = null;\r\n        this.initialized = false;\r\n        this.baseClass = baseClass;\r\n        this.isLazy = SUPPORTS_LAZY_CAPABILITIES && isLazy;\r\n    }\r\n\r\n    protected final void gatherCapabilities() {\r\n        this.gatherCapabilities(() -> {\r\n            return null;\r\n        });\r\n    }\r\n\r\n    protected final void gatherCapabilities(@Nullable ICapabilityProvider parent) {\r\n        this.gatherCapabilities(() -> {\r\n            return parent;\r\n        });\r\n    }\r\n\r\n    protected final void gatherCapabilities(@Nullable Supplier<ICapabilityProvider> parent) {\r\n        if (this.isLazy && !this.initialized) {\r\n            this.lazyParentSupplier = parent == null ? () -> {\r\n                return null;\r\n            } : parent;\r\n        } else {\r\n            this.doGatherCapabilities(parent == null ? null : (ICapabilityProvider)parent.get());\r\n        }\r\n    }\r\n\r\n    private void doGatherCapabilities(@Nullable ICapabilityProvider parent) {\r\n        this.capabilities = ForgeEventFactory.gatherCapabilities(this.baseClass, this.getProvider(), parent);\r\n        this.initialized = true;\r\n    }\r\n\r\n    @NotNull B getProvider() {\r\n        return this;\r\n    }\r\n\r\n    protected final @Nullable CapabilityDispatcher getCapabilities() {\r\n        if (this.isLazy && !this.initialized) {\r\n            this.doGatherCapabilities(this.lazyParentSupplier == null ? null : (ICapabilityProvider)this.lazyParentSupplier.get());\r\n            if (this.lazyData != null) {\r\n                this.deserializeCaps(this.lazyData);\r\n            }\r\n        }\r\n\r\n        return this.capabilities;\r\n    }\r\n\r\n    public final boolean areCapsCompatible(CapabilityProvider<B> other) {\r\n        return this.areCapsCompatible(other.getCapabilities());\r\n    }\r\n\r\n    public final boolean areCapsCompatible(@Nullable CapabilityDispatcher other) {\r\n        CapabilityDispatcher disp = this.getCapabilities();\r\n        if (disp == null) {\r\n            return other == null ? true : other.areCompatible((CapabilityDispatcher)null);\r\n        } else {\r\n            return disp.areCompatible(other);\r\n        }\r\n    }\r\n\r\n    protected final @Nullable CompoundTag serializeCaps() {\r\n        if (this.isLazy && !this.initialized) {\r\n            return this.lazyData;\r\n        } else {\r\n            CapabilityDispatcher disp = this.getCapabilities();\r\n            return disp != null ? disp.serializeNBT() : null;\r\n        }\r\n    }\r\n\r\n    protected final void deserializeCaps(CompoundTag tag) {\r\n        if (this.isLazy && !this.initialized) {\r\n            this.lazyData = tag;\r\n        } else {\r\n            CapabilityDispatcher disp = this.getCapabilities();\r\n            if (disp != null) {\r\n                disp.deserializeNBT(tag);\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    public void invalidateCaps() {\r\n        this.valid = false;\r\n        CapabilityDispatcher disp = this.getCapabilities();\r\n        if (disp != null) {\r\n            disp.invalidate();\r\n        }\r\n\r\n    }\r\n\r\n    public void reviveCaps() {\r\n        this.valid = true;\r\n    }\r\n\r\n    public <T> @NotNull LazyOptional<T> getCapability(@NotNull Capability<T> cap, @Nullable Direction side) {\r\n        CapabilityDispatcher disp = this.getCapabilities();\r\n        return this.valid && disp != null ? disp.getCapability(cap, side) : LazyOptional.empty();\r\n    }\r\n\r\n    public static class AsField<B extends ICapabilityProviderImpl<B>> extends CapabilityProvider<B> {\r\n        private final B owner;\r\n\r\n        public AsField(Class<B> baseClass, B owner) {\r\n            super(baseClass);\r\n            this.owner = owner;\r\n        }\r\n\r\n        public AsField(Class<B> baseClass, B owner, boolean isLazy) {\r\n            super(baseClass, isLazy);\r\n            this.owner = owner;\r\n        }\r\n\r\n        public void initInternal() {\r\n            this.gatherCapabilities();\r\n        }\r\n\r\n        public @Nullable CompoundTag serializeInternal() {\r\n            return this.serializeCaps();\r\n        }\r\n\r\n        public void deserializeInternal(CompoundTag tag) {\r\n            this.deserializeCaps(tag);\r\n        }\r\n\r\n        @NotNull B getProvider() {\r\n            return this.owner;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\nand here is LazyOptional.class\r\n\r\n//\r\n// Source code recreated from a .class file by IntelliJ IDEA\r\n// (powered by FernFlower decompiler)\r\n//\r\n\r\npackage net.minecraftforge.common.util;\r\n\r\nimport java.util.HashSet;\r\nimport java.util.Objects;\r\nimport java.util.Optional;\r\nimport java.util.Set;\r\nimport javax.annotation.ParametersAreNonnullByDefault;\r\nimport net.minecraft.MethodsReturnNonnullByDefault;\r\nimport org.apache.commons.lang3.mutable.Mutable;\r\nimport org.apache.commons.lang3.mutable.MutableObject;\r\nimport org.apache.logging.log4j.Level;\r\nimport org.apache.logging.log4j.LogManager;\r\nimport org.apache.logging.log4j.Logger;\r\nimport org.jetbrains.annotations.NotNull;\r\nimport org.jetbrains.annotations.Nullable;\r\n\r\n@ParametersAreNonnullByDefault\r\n@MethodsReturnNonnullByDefault\r\npublic class LazyOptional<T> {\r\n    private final NonNullSupplier<T> supplier;\r\n    private final Object lock = new Object();\r\n    private Mutable<T> resolved;\r\n    private Set<NonNullConsumer<LazyOptional<T>>> listeners = new HashSet();\r\n    private boolean isValid = true;\r\n    private static final @NotNull LazyOptional<Void> EMPTY = new LazyOptional((NonNullSupplier)null);\r\n    private static final Logger LOGGER = LogManager.getLogger();\r\n\r\n    public static <T> LazyOptional<T> of(@Nullable NonNullSupplier<T> instanceSupplier) {\r\n        return instanceSupplier == null ? empty() : new LazyOptional(instanceSupplier);\r\n    }\r\n\r\n    public static <T> LazyOptional<T> empty() {\r\n        return EMPTY.cast();\r\n    }\r\n\r\n    public <X> LazyOptional<X> cast() {\r\n        return this;\r\n    }\r\n\r\n    private LazyOptional(@Nullable NonNullSupplier<T> instanceSupplier) {\r\n        this.supplier = instanceSupplier;\r\n    }\r\n\r\n    private @Nullable T getValue() {\r\n        if (this.isValid && this.supplier != null) {\r\n            if (this.resolved == null) {\r\n                synchronized(this.lock) {\r\n                    if (this.resolved == null) {\r\n                        T temp = this.supplier.get();\r\n                        if (temp == null) {\r\n                            LOGGER.catching(Level.WARN, new NullPointerException(\"Supplier should not return null value\"));\r\n                        }\r\n\r\n                        this.resolved = new MutableObject(temp);\r\n                    }\r\n                }\r\n            }\r\n\r\n            return this.resolved.getValue();\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    private T getValueUnsafe() {\r\n        T ret = this.getValue();\r\n        if (ret == null) {\r\n            throw new IllegalStateException(\"LazyOptional is empty or otherwise returned null from getValue() unexpectedly\");\r\n        } else {\r\n            return ret;\r\n        }\r\n    }\r\n\r\n    public boolean isPresent() {\r\n        return this.supplier != null && this.isValid;\r\n    }\r\n\r\n    public void ifPresent(NonNullConsumer<? super T> consumer) {\r\n        Objects.requireNonNull(consumer);\r\n        T val = this.getValue();\r\n        if (this.isValid && val != null) {\r\n            consumer.accept(val);\r\n        }\r\n\r\n    }\r\n\r\n    public <U> LazyOptional<U> lazyMap(NonNullFunction<? super T, ? extends U> mapper) {\r\n        Objects.requireNonNull(mapper);\r\n        return this.isPresent() ? of(() -> {\r\n            return mapper.apply(this.getValueUnsafe());\r\n        }) : empty();\r\n    }\r\n\r\n    public <U> Optional<U> map(NonNullFunction<? super T, ? extends U> mapper) {\r\n        Objects.requireNonNull(mapper);\r\n        return this.isPresent() ? Optional.of(mapper.apply(this.getValueUnsafe())) : Optional.empty();\r\n    }\r\n\r\n    public Optional<T> filter(NonNullPredicate<? super T> predicate) {\r\n        Objects.requireNonNull(predicate);\r\n        T value = this.getValue();\r\n        return value != null && predicate.test(value) ? Optional.of(value) : Optional.empty();\r\n    }\r\n\r\n    public Optional<T> resolve() {\r\n        return this.isPresent() ? Optional.of(this.getValueUnsafe()) : Optional.empty();\r\n    }\r\n\r\n    public T orElse(T other) {\r\n        T val = this.getValue();\r\n        return val != null ? val : other;\r\n    }\r\n\r\n    public T orElseGet(NonNullSupplier<? extends T> other) {\r\n        T val = this.getValue();\r\n        return val != null ? val : other.get();\r\n    }\r\n\r\n    public <X extends Throwable> T orElseThrow(NonNullSupplier<? extends X> exceptionSupplier) throws X {\r\n        T val = this.getValue();\r\n        if (val != null) {\r\n            return val;\r\n        } else {\r\n            throw (Throwable)exceptionSupplier.get();\r\n        }\r\n    }\r\n\r\n    public void addListener(NonNullConsumer<LazyOptional<T>> listener) {\r\n        if (this.isPresent()) {\r\n            this.listeners.add(listener);\r\n        } else {\r\n            listener.accept(this);\r\n        }\r\n\r\n    }\r\n\r\n    public void invalidate() {\r\n        if (this.isValid) {\r\n            this.isValid = false;\r\n            this.listeners.forEach((e) -> {\r\n                e.accept(this);\r\n            });\r\n        }\r\n\r\n    }\r\n}\r\n\r\n\r\nMy understanding is that CAPABILITY_PROVIDER_BY_POSITION is caching the ICapabilityProvider, which is worse than caching the LazyOptional for the capability since we can attach a listener to the lazyoptional to remove the cache entry.\r\nPlease suggest the adjustments necessary to cache things properly in my mod so that we don't retain invalid entries.\r\n\r\nFor more context, here is ChestBlockEntity.class\r\n\r\n//\r\n// Source code recreated from a .class file by IntelliJ IDEA\r\n// (powered by FernFlower decompiler)\r\n//\r\n\r\npackage net.minecraft.world.level.block.entity;\r\n\r\nimport net.minecraft.core.BlockPos;\r\nimport net.minecraft.core.Direction;\r\nimport net.minecraft.core.NonNullList;\r\nimport net.minecraft.nbt.CompoundTag;\r\nimport net.minecraft.network.chat.Component;\r\nimport net.minecraft.sounds.SoundEvent;\r\nimport net.minecraft.sounds.SoundEvents;\r\nimport net.minecraft.sounds.SoundSource;\r\nimport net.minecraft.world.CompoundContainer;\r\nimport net.minecraft.world.Container;\r\nimport net.minecraft.world.ContainerHelper;\r\nimport net.minecraft.world.entity.player.Inventory;\r\nimport net.minecraft.world.entity.player.Player;\r\nimport net.minecraft.world.inventory.AbstractContainerMenu;\r\nimport net.minecraft.world.inventory.ChestMenu;\r\nimport net.minecraft.world.item.ItemStack;\r\nimport net.minecraft.world.level.BlockGetter;\r\nimport net.minecraft.world.level.Level;\r\nimport net.minecraft.world.level.block.Block;\r\nimport net.minecraft.world.level.block.ChestBlock;\r\nimport net.minecraft.world.level.block.state.BlockState;\r\nimport net.minecraft.world.level.block.state.properties.ChestType;\r\nimport net.minecraftforge.common.capabilities.Capability;\r\nimport net.minecraftforge.common.capabilities.ForgeCapabilities;\r\nimport net.minecraftforge.common.util.LazyOptional;\r\nimport net.minecraftforge.items.IItemHandlerModifiable;\r\nimport net.minecraftforge.items.wrapper.InvWrapper;\r\n\r\npublic class ChestBlockEntity extends RandomizableContainerBlockEntity implements LidBlockEntity {\r\n    private static final int EVENT_SET_OPEN_COUNT = 1;\r\n    private NonNullList<ItemStack> items;\r\n    private final ContainerOpenersCounter openersCounter;\r\n    private final ChestLidController chestLidController;\r\n    private LazyOptional<IItemHandlerModifiable> chestHandler;\r\n\r\n    protected ChestBlockEntity(BlockEntityType<?> pType, BlockPos pPos, BlockState pBlockState) {\r\n        super(pType, pPos, pBlockState);\r\n        this.items = NonNullList.withSize(27, ItemStack.EMPTY);\r\n        this.openersCounter = new ContainerOpenersCounter() {\r\n            protected void onOpen(Level p_155357_, BlockPos p_155358_, BlockState p_155359_) {\r\n                ChestBlockEntity.playSound(p_155357_, p_155358_, p_155359_, SoundEvents.CHEST_OPEN);\r\n            }\r\n\r\n            protected void onClose(Level p_155367_, BlockPos p_155368_, BlockState p_155369_) {\r\n                ChestBlockEntity.playSound(p_155367_, p_155368_, p_155369_, SoundEvents.CHEST_CLOSE);\r\n            }\r\n\r\n            protected void openerCountChanged(Level p_155361_, BlockPos p_155362_, BlockState p_155363_, int p_155364_, int p_155365_) {\r\n                ChestBlockEntity.this.signalOpenCount(p_155361_, p_155362_, p_155363_, p_155364_, p_155365_);\r\n            }\r\n\r\n            protected boolean isOwnContainer(Player p_155355_) {\r\n                if (!(p_155355_.containerMenu instanceof ChestMenu)) {\r\n                    return false;\r\n                } else {\r\n                    Container container = ((ChestMenu)p_155355_.containerMenu).getContainer();\r\n                    return container == ChestBlockEntity.this || container instanceof CompoundContainer && ((CompoundContainer)container).contains(ChestBlockEntity.this);\r\n                }\r\n            }\r\n        };\r\n        this.chestLidController = new ChestLidController();\r\n    }\r\n\r\n    public ChestBlockEntity(BlockPos pPos, BlockState pBlockState) {\r\n        this(BlockEntityType.CHEST, pPos, pBlockState);\r\n    }\r\n\r\n    public int getContainerSize() {\r\n        return 27;\r\n    }\r\n\r\n    protected Component getDefaultName() {\r\n        return Component.translatable(\"container.chest\");\r\n    }\r\n\r\n    public void load(CompoundTag pTag) {\r\n        super.load(pTag);\r\n        this.items = NonNullList.withSize(this.getContainerSize(), ItemStack.EMPTY);\r\n        if (!this.tryLoadLootTable(pTag)) {\r\n            ContainerHelper.loadAllItems(pTag, this.items);\r\n        }\r\n\r\n    }\r\n\r\n    protected void saveAdditional(CompoundTag pTag) {\r\n        super.saveAdditional(pTag);\r\n        if (!this.trySaveLootTable(pTag)) {\r\n            ContainerHelper.saveAllItems(pTag, this.items);\r\n        }\r\n\r\n    }\r\n\r\n    public static void lidAnimateTick(Level pLevel, BlockPos pPos, BlockState pState, ChestBlockEntity pBlockEntity) {\r\n        pBlockEntity.chestLidController.tickLid();\r\n    }\r\n\r\n    static void playSound(Level pLevel, BlockPos pPos, BlockState pState, SoundEvent pSound) {\r\n        ChestType chesttype = (ChestType)pState.getValue(ChestBlock.TYPE);\r\n        if (chesttype != ChestType.LEFT) {\r\n            double d0 = (double)pPos.getX() + 0.5;\r\n            double d1 = (double)pPos.getY() + 0.5;\r\n            double d2 = (double)pPos.getZ() + 0.5;\r\n            if (chesttype == ChestType.RIGHT) {\r\n                Direction direction = ChestBlock.getConnectedDirection(pState);\r\n                d0 += (double)direction.getStepX() * 0.5;\r\n                d2 += (double)direction.getStepZ() * 0.5;\r\n            }\r\n\r\n            pLevel.playSound((Player)null, d0, d1, d2, pSound, SoundSource.BLOCKS, 0.5F, pLevel.random.nextFloat() * 0.1F + 0.9F);\r\n        }\r\n\r\n    }\r\n\r\n    public boolean triggerEvent(int pId, int pType) {\r\n        if (pId == 1) {\r\n            this.chestLidController.shouldBeOpen(pType > 0);\r\n            return true;\r\n        } else {\r\n            return super.triggerEvent(pId, pType);\r\n        }\r\n    }\r\n\r\n    public void startOpen(Player pPlayer) {\r\n        if (!this.remove && !pPlayer.isSpectator()) {\r\n            this.openersCounter.incrementOpeners(pPlayer, this.getLevel(), this.getBlockPos(), this.getBlockState());\r\n        }\r\n\r\n    }\r\n\r\n    public void stopOpen(Player pPlayer) {\r\n        if (!this.remove && !pPlayer.isSpectator()) {\r\n            this.openersCounter.decrementOpeners(pPlayer, this.getLevel(), this.getBlockPos(), this.getBlockState());\r\n        }\r\n\r\n    }\r\n\r\n    protected NonNullList<ItemStack> getItems() {\r\n        return this.items;\r\n    }\r\n\r\n    protected void setItems(NonNullList<ItemStack> pItems) {\r\n        this.items = pItems;\r\n    }\r\n\r\n    public float getOpenNess(float pPartialTicks) {\r\n        return this.chestLidController.getOpenness(pPartialTicks);\r\n    }\r\n\r\n    public static int getOpenCount(BlockGetter pLevel, BlockPos pPos) {\r\n        BlockState blockstate = pLevel.getBlockState(pPos);\r\n        if (blockstate.hasBlockEntity()) {\r\n            BlockEntity blockentity = pLevel.getBlockEntity(pPos);\r\n            if (blockentity instanceof ChestBlockEntity) {\r\n                return ((ChestBlockEntity)blockentity).openersCounter.getOpenerCount();\r\n            }\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    public static void swapContents(ChestBlockEntity pChest, ChestBlockEntity pOtherChest) {\r\n        NonNullList<ItemStack> nonnulllist = pChest.getItems();\r\n        pChest.setItems(pOtherChest.getItems());\r\n        pOtherChest.setItems(nonnulllist);\r\n    }\r\n\r\n    protected AbstractContainerMenu createMenu(int pId, Inventory pPlayer) {\r\n        return ChestMenu.threeRows(pId, pPlayer, this);\r\n    }\r\n\r\n    public void setBlockState(BlockState p_155251_) {\r\n        super.setBlockState(p_155251_);\r\n        if (this.chestHandler != null) {\r\n            LazyOptional<?> oldHandler = this.chestHandler;\r\n            this.chestHandler = null;\r\n            oldHandler.invalidate();\r\n        }\r\n\r\n    }\r\n\r\n    public <T> LazyOptional<T> getCapability(Capability<T> cap, Direction side) {\r\n        if (!this.remove && cap == ForgeCapabilities.ITEM_HANDLER) {\r\n            if (this.chestHandler == null) {\r\n                this.chestHandler = LazyOptional.of(this::createHandler);\r\n            }\r\n\r\n            return this.chestHandler.cast();\r\n        } else {\r\n            return super.getCapability(cap, side);\r\n        }\r\n    }\r\n\r\n    private IItemHandlerModifiable createHandler() {\r\n        BlockState state = this.getBlockState();\r\n        if (!(state.getBlock() instanceof ChestBlock)) {\r\n            return new InvWrapper(this);\r\n        } else {\r\n            Container inv = ChestBlock.getContainer((ChestBlock)state.getBlock(), state, this.getLevel(), this.getBlockPos(), true);\r\n            return new InvWrapper((Container)(inv == null ? this : inv));\r\n        }\r\n    }\r\n\r\n    public void invalidateCaps() {\r\n        super.invalidateCaps();\r\n        if (this.chestHandler != null) {\r\n            this.chestHandler.invalidate();\r\n            this.chestHandler = null;\r\n        }\r\n\r\n    }\r\n\r\n    public void recheckOpen() {\r\n        if (!this.remove) {\r\n            this.openersCounter.recheckOpeners(this.getLevel(), this.getBlockPos(), this.getBlockState());\r\n        }\r\n\r\n    }\r\n\r\n    protected void signalOpenCount(Level pLevel, BlockPos pPos, BlockState pState, int pEventId, int pEventParam) {\r\n        Block block = pState.getBlock();\r\n        pLevel.blockEvent(pPos, block, 1, pEventParam);\r\n    }\r\n}\r\n\r\n\r\nand BaseContainerBlockEntity.class\r\n\r\n//\r\n// Source code recreated from a .class file by IntelliJ IDEA\r\n// (powered by FernFlower decompiler)\r\n//\r\n\r\npackage net.minecraft.world.level.block.entity;\r\n\r\nimport javax.annotation.Nullable;\r\nimport net.minecraft.core.BlockPos;\r\nimport net.minecraft.core.Direction;\r\nimport net.minecraft.nbt.CompoundTag;\r\nimport net.minecraft.network.chat.Component;\r\nimport net.minecraft.network.chat.Component.Serializer;\r\nimport net.minecraft.sounds.SoundEvents;\r\nimport net.minecraft.sounds.SoundSource;\r\nimport net.minecraft.world.Container;\r\nimport net.minecraft.world.LockCode;\r\nimport net.minecraft.world.MenuProvider;\r\nimport net.minecraft.world.Nameable;\r\nimport net.minecraft.world.entity.player.Inventory;\r\nimport net.minecraft.world.entity.player.Player;\r\nimport net.minecraft.world.inventory.AbstractContainerMenu;\r\nimport net.minecraft.world.level.block.state.BlockState;\r\nimport net.minecraftforge.common.capabilities.Capability;\r\nimport net.minecraftforge.common.capabilities.ForgeCapabilities;\r\nimport net.minecraftforge.common.util.LazyOptional;\r\nimport net.minecraftforge.items.IItemHandler;\r\nimport net.minecraftforge.items.wrapper.InvWrapper;\r\n\r\npublic abstract class BaseContainerBlockEntity extends BlockEntity implements Container, MenuProvider, Nameable {\r\n    private LockCode lockKey;\r\n    private Component name;\r\n    private LazyOptional<?> itemHandler;\r\n\r\n    protected BaseContainerBlockEntity(BlockEntityType<?> pType, BlockPos pPos, BlockState pBlockState) {\r\n        super(pType, pPos, pBlockState);\r\n        this.lockKey = LockCode.NO_LOCK;\r\n        this.itemHandler = LazyOptional.of(() -> {\r\n            return this.createUnSidedHandler();\r\n        });\r\n    }\r\n\r\n    public void load(CompoundTag pTag) {\r\n        super.load(pTag);\r\n        this.lockKey = LockCode.fromTag(pTag);\r\n        if (pTag.contains(\"CustomName\", 8)) {\r\n            this.name = Serializer.fromJson(pTag.getString(\"CustomName\"));\r\n        }\r\n\r\n    }\r\n\r\n    protected void saveAdditional(CompoundTag pTag) {\r\n        super.saveAdditional(pTag);\r\n        this.lockKey.addToTag(pTag);\r\n        if (this.name != null) {\r\n            pTag.putString(\"CustomName\", Serializer.toJson(this.name));\r\n        }\r\n\r\n    }\r\n\r\n    public void setCustomName(Component pName) {\r\n        this.name = pName;\r\n    }\r\n\r\n    public Component getName() {\r\n        return this.name != null ? this.name : this.getDefaultName();\r\n    }\r\n\r\n    public Component getDisplayName() {\r\n        return this.getName();\r\n    }\r\n\r\n    @Nullable\r\n    public Component getCustomName() {\r\n        return this.name;\r\n    }\r\n\r\n    protected abstract Component getDefaultName();\r\n\r\n    public boolean canOpen(Player pPlayer) {\r\n        return canUnlock(pPlayer, this.lockKey, this.getDisplayName());\r\n    }\r\n\r\n    public static boolean canUnlock(Player pPlayer, LockCode pCode, Component pDisplayName) {\r\n        if (!pPlayer.isSpectator() && !pCode.unlocksWith(pPlayer.getMainHandItem())) {\r\n            pPlayer.displayClientMessage(Component.translatable(\"container.isLocked\", new Object[]{pDisplayName}), true);\r\n            pPlayer.playNotifySound(SoundEvents.CHEST_LOCKED, SoundSource.BLOCKS, 1.0F, 1.0F);\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    @Nullable\r\n    public AbstractContainerMenu createMenu(int pContainerId, Inventory pPlayerInventory, Player pPlayer) {\r\n        return this.canOpen(pPlayer) ? this.createMenu(pContainerId, pPlayerInventory) : null;\r\n    }\r\n\r\n    protected abstract AbstractContainerMenu createMenu(int var1, Inventory var2);\r\n\r\n    protected IItemHandler createUnSidedHandler() {\r\n        return new InvWrapper(this);\r\n    }\r\n\r\n    public <T> LazyOptional<T> getCapability(Capability<T> cap, @org.jetbrains.annotations.Nullable Direction side) {\r\n        return !this.remove && cap == ForgeCapabilities.ITEM_HANDLER ? this.itemHandler.cast() : super.getCapability(cap, side);\r\n    }\r\n\r\n    public void invalidateCaps() {\r\n        super.invalidateCaps();\r\n        this.itemHandler.invalidate();\r\n    }\r\n\r\n    public void reviveCaps() {\r\n        super.reviveCaps();\r\n        this.itemHandler = LazyOptional.of(() -> {\r\n            return this.createUnSidedHandler();\r\n        });\r\n    }\r\n}\r\n\r\n",
        "files": []
    },
    "response": {
        "candidates": [
            {
                "content": {
                    "parts": [
                        {
                            "text": "## Analysis of SuperFactoryManager Chunk Loading Issue\n\nBased on the provided code snippets and your analysis, the issue seems to stem from how capability providers are cached within the `CableNetwork` class, specifically in the `CAPABILITY_PROVIDER_BY_POSITION` map. This caching mechanism can lead to problems when chunks unload and reload, as the cached providers might become invalid.\n\nHere's a breakdown of the problem and potential solutions:\n\n**Problem:**\n\n* `CAPABILITY_PROVIDER_BY_POSITION` stores `ICapabilityProvider` instances directly.\n* When a chunk unloads, the associated block entities are unloaded, potentially invalidating these cached providers.\n* Upon chunk reload, the cached providers might no longer reference valid block entities, leading to unexpected behavior and item movement issues.\n\n**Solutions:**\n\n1. **Utilize LazyOptionals:**\n    * Instead of caching `ICapabilityProvider` instances, store `LazyOptional<ICapabilityProvider>` for each position.\n    * This allows for dynamic resolution of the capability provider when needed, ensuring it references a valid block entity even after chunk unloading/reloading.\n    * Implement a listener on the `LazyOptional` to detect invalidation and remove the entry from the cache.\n\n2. **Track Chunk Loading:**\n    * Implement a mechanism to track chunk loading and unloading events.\n    * When a chunk unloads, clear the cached providers associated with the unloaded block positions.\n    * Upon chunk reload, rebuild the cache by rediscovering capability providers.\n\n3. **Combine Approaches:**\n    * For optimal efficiency and robustness, consider combining LazyOptionals with chunk loading tracking.\n    * This ensures that invalid providers are removed promptly and that valid providers are readily available upon access. \n\n**Implementation Suggestions:**\n\n* **Modifying `CableNetwork`:**\n    * Change `CAPABILITY_PROVIDER_BY_POSITION` to `Map<BlockPos, LazyOptional<ICapabilityProvider>>`.\n    * Update `rebuildAdjacentInventories` and other relevant methods to work with LazyOptionals.\n    * Add a listener to each `LazyOptional` to remove the entry from the cache upon invalidation.\n\n* **Chunk Loading Tracking:**\n    * Subscribe to the `ChunkEvent.Load` and `ChunkEvent.Unload` events.\n    * In the event handlers, manage the cache based on the loaded/unloaded chunks.\n\n**Additional Considerations:**\n\n* Evaluate the performance implications of the chosen solution, especially for large networks and frequent chunk loading/unloading.\n* Consider implementing a mechanism to refresh the cache periodically to handle cases where providers become invalid without explicit chunk events. \n* Thoroughly test the implemented solution to ensure it resolves the item movement issue and functions as expected under various scenarios. \n\n**By addressing the capability provider caching issue, SuperFactoryManager should function reliably even with chunk unloading and reloading.** \n"
                        }
                    ],
                    "role": "model"
                },
                "finishReason": "STOP",
                "index": 0,
                "safetyRatings": [
                    {
                        "category": "HARM_CATEGORY_SEXUALLY_EXPLICIT",
                        "probability": "NEGLIGIBLE"
                    },
                    {
                        "category": "HARM_CATEGORY_HATE_SPEECH",
                        "probability": "NEGLIGIBLE"
                    },
                    {
                        "category": "HARM_CATEGORY_HARASSMENT",
                        "probability": "NEGLIGIBLE"
                    },
                    {
                        "category": "HARM_CATEGORY_DANGEROUS_CONTENT",
                        "probability": "NEGLIGIBLE"
                    }
                ]
            }
        ]
    }
}