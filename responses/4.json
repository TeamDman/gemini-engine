{
    "response": {
        "candidates": [
            {
                "content": {
                    "parts": [
                        {
                            "text": "## Files using `fzf` without `--prompt` and `--header`:\n\nThere are 3 files using `fzf` without specifying `--prompt` or `--header`:\n\n1. **actions\\Execute a prompt inference.ps1:** This script uses `fzf` twice:\n    - First, to select a file from the cached files.\n    - Second, to select a prompt from the `prompts` directory.\n2. **actions\\Edit prompts.ps1:** This script uses `fzf` to select a prompt from the cached prompts list.\n3. **actions\\Preview cached files.ps1:** This script uses `fzf` to display and filter the list of cached files with their details.\n\n## Proposed `--prompt` and `--header` values:\n\nHere are some suggestions for `--prompt` and `--header` values for each script:\n\n**1. actions\\Execute a prompt inference.ps1:**\n\n* **First `fzf` (file selection):**\n    * `--prompt`: \"Select file:\"\n    * `--header`: \"Cached Files\"\n* **Second `fzf` (prompt selection):**\n    * `--prompt`: \"Select prompt:\"\n    * `--header`: \"Available Prompts\"\n\n**2. actions\\Edit prompts.ps1:**\n\n* `--prompt`: \"Select prompt to edit:\"\n* `--header`: \"Cached Prompts\"\n\n**3. actions\\Preview cached files.ps1:**\n\n* `--prompt`: \"Filter files:\"\n* `--header`: \"Cached Files (Name, Mimetype, URL)\"\n\nThese are just suggestions, and you can customize them based on your preference and the specific context of each script. Adding `--prompt` and `--header` will improve the clarity and user experience of your scripts. \n"
                        }
                    ],
                    "role": "model"
                },
                "finishReason": "STOP",
                "index": 0,
                "safetyRatings": [
                    {
                        "category": "HARM_CATEGORY_SEXUALLY_EXPLICIT",
                        "probability": "NEGLIGIBLE"
                    },
                    {
                        "category": "HARM_CATEGORY_HATE_SPEECH",
                        "probability": "NEGLIGIBLE"
                    },
                    {
                        "category": "HARM_CATEGORY_HARASSMENT",
                        "probability": "NEGLIGIBLE"
                    },
                    {
                        "category": "HARM_CATEGORY_DANGEROUS_CONTENT",
                        "probability": "NEGLIGIBLE"
                    }
                ]
            }
        ]
    },
    "prompt": "\r\n\r\n#REGION D:\\Repos\\ml\\gemini-engine\\actions\\Create a prompt.ps1\r\n$promptName = Read-Host \"Enter a name for the prompt (.txt gets appended)\"\r\n$promptName += \".txt\"\r\n# Open prompt file in editor\r\nhx prompts/$promptName\r\n# Update cached data\r\n$cachedPrompts += $promptName\r\n#ENDREGION\r\n\r\n\r\n#REGION D:\\Repos\\ml\\gemini-engine\\actions\\Interactive mode.ps1\r\nwhile ($true) {\r\n    $chosenFileName = $cachedFiles.Keys | fzf\r\n    if ([string]::IsNullOrEmpty($chosenFileName)) {\r\n        $file = [PSCustomObject]@{\r\n            url = $null\r\n            mimetype = $null\r\n        }\r\n    } else {\r\n        $file = $cachedFiles[$chosenFileName]\r\n    }\r\n    $prompt = Read-Host \"Prompt\"\r\n    if ([string]::IsNullOrWhiteSpace($prompt)) {\r\n        break\r\n    }\r\n    $payload = [pscustomobject]@{\r\n        prompt = $prompt\r\n        file_url = $file.url\r\n        file_mimetype = $file.mimetype\r\n    }\r\n    python inference.py $($payload | ConvertTo-Json)\r\n    pause\r\n}\r\n#ENDREGION\r\n\r\n\r\n#REGION D:\\Repos\\ml\\gemini-engine\\actions\\Execute a prompt inference.ps1\r\n# Select file and prompt using fzf\r\n$chosenFileName = $cachedFiles.Keys | fzf\r\n$file = $cachedFiles[$chosenFileName]\r\nPush-Location prompts\r\n$chosenPromptName = fzf\r\nPop-Location\r\n# Read prompt content\r\n$prompt = Get-Content -Raw prompts\\$chosenPromptName\r\n# Prepare payload and call Python script\r\n$payload = [pscustomobject]@{\r\n    prompt = $prompt\r\n    file_url = $file.url\r\n    file_mimetype = $file.mimetype\r\n}\r\npython inference.py $($payload | ConvertTo-Json)\r\n#ENDREGION\r\n\r\n\r\n#REGION D:\\Repos\\ml\\gemini-engine\\actions\\Copy file summary to clipboard.ps1\r\n$choices = Get-ChildItem -Recurse -File | Select-Object -ExpandProperty FullName\r\n\r\n$files = @()\r\nwhile ($true) {\r\n    $chosen = $choices | fzf --multi --bind \"ctrl-a:select-all,ctrl-d:deselect-all,ctrl-t:toggle-all\" --header \"Selection will repeat until Ctrl+C received\"\r\n    if ($null -eq $chosen) {\r\n        break\r\n    }\r\n    $files += $chosen\r\n}\r\n$content = $files | ForEach-Object { \r\n    $content = Get-Content $_ -Raw\r\n    return \"\r\n#REGION $($_)\r\n$content\r\n#ENDREGION\r\n\"\r\n}\r\n| Out-String\r\n$content | Set-Clipboard\r\nWrite-Host \"Copied $($files.Count) files to clipboard\"\r\n#ENDREGION\r\n\r\n\r\n#REGION D:\\Repos\\ml\\gemini-engine\\actions\\Upload a file.ps1\r\n# Get user choice\r\n$filePath = Get-ChildItem -Path files `\r\n| ForEach-Object { $_.Name } `\r\n| fzf\r\n\r\n# Overwrite check\r\nif ($cachedFiles.ContainsKey($filePath)) {\r\n  $overwrite = Read-Host \"$filePath already exists, overwrite? (y/n)\"\r\n  if ($overwrite -ne \"y\") { continue }\r\n}\r\n\r\n# Get mimetype\r\n$fileMimetype = Get-Content .\\mimetypes.txt | fzf\r\n\r\n# Upload file\r\n$fileUrl = python file_upload.py \"files/$filePath\" \"$fileMimetype\"\r\nif ($? -eq $false) {\r\n  Write-Warning \"Failed to upload file.\"\r\n  continue\r\n}\r\n\r\n# Update cached data\r\n$cachedFiles[$filePath] = [PSCustomObject]@{\r\n  url = $fileUrl\r\n  mimetype = $fileMimetype\r\n}\r\n$cachedFiles | ConvertTo-Json | Set-Content -Path \"files.json\"\r\n\r\n# Inform the user\r\nWrite-Host \"Uploaded file and saved the url to the cache.\"\r\n\r\n#ENDREGION\r\n\r\n\r\n#REGION D:\\Repos\\ml\\gemini-engine\\actions\\Edit prompts.ps1\r\n$cachedPrompts | fzf | hx\r\n#ENDREGION\r\n\r\n\r\n#REGION D:\\Repos\\ml\\gemini-engine\\actions\\Manually set API key.ps1\r\n# Read the secure string\r\nWrite-Host -NoNewLine \"Enter the API key: \"\r\n$secureString = Read-Host -AsSecureString\r\n\r\n# Convert SecureString to BSTR (Basic String) and then to a plain text string\r\n$ptr = [Runtime.InteropServices.Marshal]::SecureStringToBSTR($secureString)\r\ntry {\r\n    $plainText = [Runtime.InteropServices.Marshal]::PtrToStringBSTR($ptr)\r\n} finally {\r\n    # Make sure to free the BSTR to prevent memory leaks\r\n    [Runtime.InteropServices.Marshal]::ZeroFreeBSTR($ptr)\r\n}\r\n\r\n# Now you can use $plainText as a regular string\r\n# For example, setting it as an environment variable\r\n$ENV:GEMINI_API_KEY = $plainText\r\n\r\n# Use the environment variable\r\nWrite-Host \"Set the API key as an environment variable.\"\r\n#ENDREGION\r\n\r\n\r\n#REGION D:\\Repos\\ml\\gemini-engine\\actions\\Preview cached files.ps1\r\n$cachedfiles.Keys `\r\n    | ForEach-Object { \r\n        $entry = $cachedfiles[$_]\r\n        $name = $_\r\n        $url = $entry.url\r\n        $mimetype = $entry.mimetype    \r\n        # format as %-20s %-20s %-20s\r\n        \"{0,-20} {1,-20} {2,-64}\" -f $name, $mimetype, $url\r\n    } `\r\n    | fzf\r\n#ENDREGION\r\n\r\n\r\n#REGION D:\\Repos\\ml\\gemini-engine\\actions\\Install python dependencies.ps1\r\npip install -q google-api-python-client google-generativeai\r\n#ENDREGION\r\n\r\n\r\n#REGION D:\\Repos\\ml\\gemini-engine\\actions\\Load api key from 1password vault.ps1\r\n$env:GEMINI_API_KEY = op read \"op://Private/Google AI Studio API key/credential\"\r\nWrite-Host \"API Key loaded into GEMINI_API_KEY environment variable.\"\r\n#ENDREGION\r\n\r\n\r\n#REGION D:\\Repos\\ml\\gemini-engine\\gemini.ps1\r\n# gemini.ps1\r\n\r\n# Load cached data\r\nif (Test-Path -Path .\\files.json) {\r\n  $cachedFiles = Get-Content -Path \"files.json\" | ConvertFrom-Json -AsHashtable\r\n} else {\r\n  $cachedFiles = @{}\r\n}\r\nif (-not (Test-Path -Path .\\prompts)) {\r\n  New-Item -ItemType Directory -Path .\\prompts | Out-Null\r\n}\r\n$cachedPrompts = Get-ChildItem -Path \"prompts/*.txt\" | Select-Object -ExpandProperty Name\r\n\r\nwhile ($true) {\r\n  $action = Get-ChildItem -Path actions `\r\n    | Select-Object -ExpandProperty name `\r\n    | Sort-Object -Descending `\r\n    | fzf --prompt \"Action: \" --header \"Select an action to run\"\r\n  if ([string]::IsNullOrWhiteSpace($action)) {\r\n    break\r\n  }\r\n  . \".\\actions\\$action\"\r\n  pause\r\n}\r\n\r\n#ENDREGION\r\n\r\n\r\n#REGION D:\\Repos\\ml\\gemini-engine\\README.md\r\n<div align=\"center\">\r\n\r\n# Gemini Engine\r\n\r\n<img height=500 src=\"https://cards.scryfall.io/large/front/2/e/2e03e05b-011b-4695-950b-98dd7643b8a0.jpg?1562636055\">\r\n\r\nMine\r\n[![Discord](https://img.shields.io/discord/967118679370264627.svg?colorB=7289DA&logo=data:image/png)](https://discord.gg/5mbUY3mu6m)\r\n\r\nGoogle Developer Community\r\n[![Discord](https://img.shields.io/discord/1009525727504384150.svg?colorB=7289DA&logo=data:image/png)](https://discord.gg/google-dev-community)\r\n\r\n</div>\r\n\r\nA collection of scripts I'm using to interact with the Gemini 1.5 Pro API.\r\n\r\n## Leaking API keys\r\n\r\nThe Google python APIs will include your API key in the error messages.\r\n\r\nClear your cell outputs before committing notebooks to reduce risk of leaking your API key.\r\n\r\n## Mimetypes\r\n\r\nSourced from https://www.iana.org/assignments/media-types/media-types.xhtml using\r\n\r\n```javascript\r\ncopy(Array.from(document.querySelectorAll(\"td:nth-child(2)\")).map(x => x.innerText).join(\"\\n\"))\r\n```\r\n#ENDREGION\r\n\r\nGive a summary of files containing the fzf command that aren't using --prompt or --header and propose --prompt and --header values that should be added.",
    "file_url": null,
    "file_mimetype": null
}