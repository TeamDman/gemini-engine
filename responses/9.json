{
    "response": {
        "candidates": [
            {
                "content": {
                    "parts": [
                        {
                            "text": "## Summarize Prompt Lengths\n\nHere's an action script that summarizes the length of each prompt in the `prompts` directory:\n\n#REGION D:\\Repos\\ml\\gemini-engine\\actions\\Summarize prompt lengths.ps1\n\n# Get all prompt files\n$promptFiles = Get-ChildItem -Path \"prompts\" -Filter \"*.txt\"\n\n# Loop through each file and calculate length\n$summary = @()\nforeach ($file in $promptFiles) {\n  $content = Get-Content -Path $file.FullName -Raw\n  $length = $content.Length\n  $summary += [PSCustomObject]@{\n    Name   = $file.BaseName\n    Length = $length\n  }\n}\n\n# Display summary in a table format\n$summary | Format-Table -AutoSize\n\n#ENDREGION\n\nThis script will:\n\n1. Get all files with the `.txt` extension in the `prompts` directory.\n2. Loop through each file and read its content.\n3. Calculate the length of the content (number of characters).\n4. Create a summary object with the prompt name and length.\n5. Display the summary information in a table format.\n\nYou can run this script like any other action script in your gemini-engine environment. \n"
                        }
                    ],
                    "role": "model"
                },
                "finishReason": "STOP",
                "index": 0,
                "safetyRatings": [
                    {
                        "category": "HARM_CATEGORY_SEXUALLY_EXPLICIT",
                        "probability": "NEGLIGIBLE"
                    },
                    {
                        "category": "HARM_CATEGORY_HATE_SPEECH",
                        "probability": "NEGLIGIBLE"
                    },
                    {
                        "category": "HARM_CATEGORY_HARASSMENT",
                        "probability": "NEGLIGIBLE"
                    },
                    {
                        "category": "HARM_CATEGORY_DANGEROUS_CONTENT",
                        "probability": "NEGLIGIBLE"
                    }
                ]
            }
        ]
    },
    "prompt": "\r\n\r\n#REGION D:\\Repos\\ml\\gemini-engine\\actions\\Copy file summary to clipboard.ps1\r\n$choices = Get-ChildItem -Recurse -File | Select-Object -ExpandProperty FullName\r\n\r\n$files = @()\r\nwhile ($true) {\r\n    $chosen = $choices | fzf --multi --bind \"ctrl-a:select-all,ctrl-d:deselect-all,ctrl-t:toggle-all\" --header \"Selection will repeat until Ctrl+C received\"\r\n    if ($null -eq $chosen) {\r\n        break\r\n    }\r\n    $files += $chosen\r\n}\r\n$content = $files | ForEach-Object { \r\n    $content = Get-Content $_ -Raw\r\n    return \"\r\n#REGION $($_)\r\n$content\r\n#ENDREGION\r\n\"\r\n}\r\n| Out-String\r\n$content | Set-Clipboard\r\nWrite-Host \"Copied $($files.Count) files to clipboard\"\r\n#ENDREGION\r\n\r\n\r\n#REGION D:\\Repos\\ml\\gemini-engine\\actions\\Upload a file.ps1\r\n# Get user choice\r\n$filePath = Get-ChildItem -Path files `\r\n| ForEach-Object { $_.Name } `\r\n| fzf\r\n\r\n# Overwrite check\r\nif ($cachedFiles.ContainsKey($filePath)) {\r\n  $overwrite = Read-Host \"$filePath already exists, overwrite? (y/n)\"\r\n  if ($overwrite -ne \"y\") { continue }\r\n}\r\n\r\n# Get mimetype\r\n$fileMimetype = Get-Content .\\mimetypes.txt | fzf\r\n\r\n# Upload file\r\n$fileUrl = python file_upload.py \"files/$filePath\" \"$fileMimetype\"\r\nif ($? -eq $false) {\r\n  Write-Warning \"Failed to upload file.\"\r\n  continue\r\n}\r\n\r\n# Update cached data\r\n$cachedFiles[$filePath] = [PSCustomObject]@{\r\n  url = $fileUrl\r\n  mimetype = $fileMimetype\r\n}\r\n$cachedFiles | ConvertTo-Json | Set-Content -Path \"files.json\"\r\n\r\n# Inform the user\r\nWrite-Host \"Uploaded file and saved the url to the cache.\"\r\n\r\n#ENDREGION\r\n\r\n\r\n#REGION D:\\Repos\\ml\\gemini-engine\\actions\\Preview cached files.ps1\r\n$cachedfiles.Keys `\r\n    | ForEach-Object { \r\n        $entry = $cachedfiles[$_]\r\n        $name = $_\r\n        $url = $entry.url\r\n        $mimetype = $entry.mimetype    \r\n        # format as %-20s %-20s %-20s\r\n        \"{0,-20} {1,-20} {2,-64}\" -f $name, $mimetype, $url\r\n    } `\r\n    | fzf\r\n#ENDREGION\r\n\r\n\r\n#REGION D:\\Repos\\ml\\gemini-engine\\actions\\Perform image inference.ps1\r\nif (-not (Test-Path Env:GEMINI_API_KEY)) {\r\n    Write-Warning \"GEMINI_API_KEY environment variable not set.\"\r\n    return\r\n}\r\n\r\n# Select file and prompt using fzf\r\n$chosenFileName = $cachedFiles.Keys | fzf --prompt \"Select file: \" --header \"Cached Files\"\r\n$file = $cachedFiles[$chosenFileName]\r\nPush-Location prompts\r\n$env:SHELL=\"pwsh\"\r\n$chosenPromptName = fzf --preview \"bat {}\" --prompt \"Select prompt: \" --header \"Available Prompts\"\r\nPop-Location\r\n# Read prompt content\r\n$prompt = Get-Content -Raw \"prompts\\$chosenPromptName\"\r\n# Prepare payload and call Python script\r\n$payload = [pscustomobject]@{\r\n    prompt = $prompt\r\n    file_url = $file.url\r\n    file_mimetype = $file.mimetype\r\n}\r\n$file = New-TemporaryFile\r\n$payload | ConvertTo-Json | Set-Content -Path $file.FullName\r\ntry {\r\n    python inference.py \"$($file.FullName)\"\r\n} finally {\r\n    Remove-Item -Path $file.FullName\r\n}\r\n#ENDREGION\r\n\r\n\r\n#REGION D:\\Repos\\ml\\gemini-engine\\actions\\Perform text-only inference.ps1\r\nif (-not (Test-Path Env:GEMINI_API_KEY)) {\r\n    Write-Warning \"GEMINI_API_KEY environment variable not set.\"\r\n    return\r\n}\r\n\r\nPush-Location prompts\r\n$env:SHELL=\"pwsh\"\r\n$chosenPromptName = fzf --preview \"bat {}\" --prompt \"Select prompt: \" --header \"Available Prompts\"\r\nPop-Location\r\n# Read prompt content\r\n$prompt = Get-Content -Raw \"prompts\\$chosenPromptName\"\r\n# Prepare payload and call Python script\r\n$payload = [pscustomobject]@{\r\n    prompt = $prompt\r\n    file_url = $file.url\r\n    file_mimetype = $file.mimetype\r\n}\r\n$file = New-TemporaryFile\r\n$payload | ConvertTo-Json | Set-Content -Path $file.FullName\r\ntry {\r\n    python inference.py \"$($file.FullName)\" | code -\r\n} finally {\r\n    Remove-Item -Path $file.FullName\r\n}\r\n#ENDREGION\r\n\r\n\r\n#REGION D:\\Repos\\ml\\gemini-engine\\actions\\View a response in VSCode.ps1\r\n# Select response file\r\n$chosenResponseFile = Get-ChildItem -Path responses -Filter \"*.json\" `\r\n    | Select-Object -ExpandProperty Name `\r\n    | Sort-Object -Descending `\r\n    | fzf --no-sort\r\n\r\n# Check if file was selected\r\nif ([string]::IsNullOrEmpty($chosenResponseFile)) {\r\n    Write-Host \"No response file selected.\"\r\n    return\r\n}\r\n\r\n# Read response data\r\n$responseData = Get-Content -Raw -Path \"responses/$chosenResponseFile\" `\r\n    | ConvertFrom-Json\r\n\r\n# Extract the \"good part\"\r\n# (Modify this logic based on the actual response structure)\r\n$extracted = $responseData.response.candidates.content.parts.text\r\n\r\n# Open the extracted content in VSCode\r\n$extracted | code -\r\n\r\n#ENDREGION\r\n\r\n\r\n#REGION D:\\Repos\\ml\\gemini-engine\\actions\\Install python dependencies.ps1\r\npip install -q google-api-python-client google-generativeai\r\n#ENDREGION\r\n\r\n\r\n#REGION D:\\Repos\\ml\\gemini-engine\\actions\\Mark directories of interest.ps1\r\n# Check if locations.txt exists, create if not\r\nif (!(Test-Path -Path \"locations.txt\")) {\r\n    New-Item -ItemType File -Path \"locations.txt\" | Out-Null\r\n}\r\n  \r\n# Define the mark function\r\nfunction mark {\r\n    $currentDir = (Get-Location).Path\r\n    Add-Content -Path \"locations.txt\" -Value $currentDir\r\n    Write-Host \"Marked directory: $currentDir\"\r\n}\r\n  \r\n# Start a subshell with the mark function available\r\n$newShell = New-Object System.Management.Automation.Runspaces.Runspace\r\n$newShell.Open()\r\n$newShell.SessionStateProxy.SetVariable(\"mark\", $function:mark)\r\nInvoke-Expression \"& { $newShell.CreatePipeline().Invoke() }\"\r\n\r\n# Close the subshell\r\n$newShell.Close()\r\n\r\nWrite-Host \"Finished marking directories.\"\r\n#ENDREGION\r\n\r\n\r\n#REGION D:\\Repos\\ml\\gemini-engine\\actions\\Load api key from 1password vault.ps1\r\n$env:GEMINI_API_KEY = op read \"op://Private/Google AI Studio Gemini API key/credential\"\r\nWrite-Host \"API Key loaded into GEMINI_API_KEY environment variable.\"\r\n#ENDREGION\r\n\r\n\r\n#REGION D:\\Repos\\ml\\gemini-engine\\actions\\Edit prompts.ps1\r\n$file = $cachedPrompts | fzf --prompt \"Select prompt to edit: \" --header \"Cached Prompts\"\r\nhx \"prompts\\$file\"\r\n#ENDREGION\r\n\r\n\r\n#REGION D:\\Repos\\ml\\gemini-engine\\actions\\Interactive mode.ps1\r\nwhile ($true) {\r\n    $chosenFileName = $cachedFiles.Keys | fzf\r\n    if ([string]::IsNullOrEmpty($chosenFileName)) {\r\n        $file = [PSCustomObject]@{\r\n            url = $null\r\n            mimetype = $null\r\n        }\r\n    } else {\r\n        $file = $cachedFiles[$chosenFileName]\r\n    }\r\n    $prompt = Read-Host \"Prompt\"\r\n    if ([string]::IsNullOrWhiteSpace($prompt)) {\r\n        break\r\n    }\r\n    $payload = [pscustomobject]@{\r\n        prompt = $prompt\r\n        file_url = $file.url\r\n        file_mimetype = $file.mimetype\r\n    }\r\n    python inference.py $($payload | ConvertTo-Json)\r\n    pause\r\n}\r\n#ENDREGION\r\n\r\n\r\n#REGION D:\\Repos\\ml\\gemini-engine\\actions\\Create a new prompt.ps1\r\n$promptName = Read-Host \"Enter a name for the prompt (.txt gets appended)\"\r\n$promptName += \".txt\"\r\n# Open prompt file in editor\r\nhx prompts/$promptName\r\n# Update cached data\r\n$cachedPrompts += $promptName\r\n#ENDREGION\r\n\r\n\r\n#REGION D:\\Repos\\ml\\gemini-engine\\actions\\Manually set API key.ps1\r\n# Read the secure string\r\nWrite-Host -NoNewLine \"Enter the API key: \"\r\n$secureString = Read-Host -AsSecureString\r\n\r\n# Convert SecureString to BSTR (Basic String) and then to a plain text string\r\n$ptr = [Runtime.InteropServices.Marshal]::SecureStringToBSTR($secureString)\r\ntry {\r\n    $plainText = [Runtime.InteropServices.Marshal]::PtrToStringBSTR($ptr)\r\n} finally {\r\n    # Make sure to free the BSTR to prevent memory leaks\r\n    [Runtime.InteropServices.Marshal]::ZeroFreeBSTR($ptr)\r\n}\r\n\r\n# Now you can use $plainText as a regular string\r\n# For example, setting it as an environment variable\r\n$ENV:GEMINI_API_KEY = $plainText\r\n\r\n# Use the environment variable\r\nWrite-Host \"Set the API key as an environment variable.\"\r\n#ENDREGION\r\n\r\n\r\n#REGION D:\\Repos\\ml\\gemini-engine\\README.md\r\n<div align=\"center\">\r\n\r\n# Gemini Engine\r\n\r\n<img height=400 src=\"https://cards.scryfall.io/large/front/2/e/2e03e05b-011b-4695-950b-98dd7643b8a0.jpg?1562636055\">\r\n\r\nMine\r\n[![Discord](https://img.shields.io/discord/967118679370264627.svg?colorB=7289DA&logo=data:image/png)](https://discord.gg/5mbUY3mu6m)\r\n\r\nGoogle Developer Community\r\n[![Discord](https://img.shields.io/discord/1009525727504384150.svg?colorB=7289DA&logo=data:image/png)](https://discord.gg/google-dev-community)\r\n\r\n</div>\r\n\r\nA collection of scripts I'm using to interact with the Gemini 1.5 Pro API.\r\n\r\n## Leaking API keys\r\n\r\nThe Google python APIs will include your API key in the error messages.\r\n\r\nClear your cell outputs before committing notebooks to reduce risk of leaking your API key.\r\n\r\n## Mimetypes\r\n\r\nSourced from https://www.iana.org/assignments/media-types/media-types.xhtml using\r\n\r\n```javascript\r\ncopy(Array.from(document.querySelectorAll(\"td:nth-child(2)\")).map(x => x.innerText).join(\"\\n\"))\r\n```\r\n#ENDREGION\r\n\r\nThis is the gemini-engine repo.\r\n\r\nCreate an action that will summarize the length of each prompt.",
    "file_url": null,
    "file_mimetype": null
}