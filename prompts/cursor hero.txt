# Summary


## D:\Repos\Games\Cursor-Hero\crates\ui_automation\src\take_snapshot.rs

````rust
use crate::gather_root_children::gather_root_children;
use crate::resolve_app::resolve_app;
use cursor_hero_ui_automation_types::prelude::*;
use itertools::Itertools;
use uiautomation::UIAutomation;

pub fn take_snapshot() -> Result<UISnapshot, GatherAppsError> {
    let automation = UIAutomation::new()?;
    let walker = automation.create_tree_walker()?;
    // let walker = automation.get_raw_view_walker()?;
    let top_level_children = gather_root_children(&automation, &walker)?;

    let focused = automation.get_focused_element()?;
    let focused_app = walker.normalize(&focused)?;

    let mut apps = vec![];
    let mut errors = vec![];
    for elem in top_level_children {
        let focused = elem.get_runtime_id() == focused_app.get_runtime_id();
        match resolve_app(&elem, &automation, focused) {
            Ok(app) => {
                apps.push((elem, app));
            }
            Err(e) => errors.push(e),
        }
    }
    let bad_errors = errors
        .into_iter()
        // NoMatch errors aren't enough to fail the whole snapshot
        .filter(|e| !matches!(e, AppResolveError::NoMatch))
        .filter(|e| !matches!(e, AppResolveError::BadVSCodeStructure(_)))
        .collect_vec();
    if !bad_errors.is_empty() {
        return Err(GatherAppsError::ResolveFailed(bad_errors));
    }

    let snapshot = UISnapshot {
        app_windows: apps.into_iter().map(|(_elem, app)| app).collect(),
    };
    Ok(snapshot)
}

#[cfg(test)]
mod tests {
    use windows::Win32::System::Com::CoInitializeEx;
    use windows::Win32::System::Com::COINIT_MULTITHREADED;

    use crate::prelude::take_snapshot;

    #[test]
    fn test_take_snapshot() {
        //todo: put this in thread initialzed for COM like below
        let snapshot = take_snapshot().unwrap();
        assert!(snapshot.app_windows.len() > 0);
    }

    #[test]
    fn test_take_snapshot_many() {
        let handle = std::thread::spawn(move || -> windows::core::Result<()> {
            unsafe {
                // Initialize COM in MTA mode
                // https://learn.microsoft.com/en-us/windows/win32/com/multithreaded-apartments
                CoInitializeEx(None, COINIT_MULTITHREADED)?;

                println!("COM initialized in MTA mode.");

                for i in 0..100 {
                    let start = std::time::Instant::now();
                    let snapshot = take_snapshot().unwrap();
                    assert!(snapshot.app_windows.len() > 0);
                    if i == 0 {
                        println!("{}", snapshot);
                    }
                    let end = std::time::Instant::now();
                    println!("time: {:?}", end - start);
                    assert!(end - start < std::time::Duration::from_secs(1));
                }

                Ok(())
            }
        });

        // Wait for the thread to complete its tasks and handle any errors
        let _ = handle.join().unwrap();
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\inference_types\src\prompt_types.rs

````rust
use bevy::prelude::*;
use cursor_hero_text_asset_types::text_asset_loader_types::TextAsset;

use crate::prelude::TextInferenceOptions;

#[derive(Reflect, Debug, PartialEq, Eq, Clone)]
pub enum TextPrompt {
    Raw {
        content: String,
        options: Option<TextInferenceOptions>,
    },
    Chat {
        chat_history: String,
        options: Option<TextInferenceOptions>,
    },
}

impl TextPrompt {
    pub fn options(&self) -> Option<TextInferenceOptions> {
        match self {
            TextPrompt::Raw { options, .. } => options.clone(),
            TextPrompt::Chat { options, .. } => options.clone(),
        }
    }
}

#[derive(Reflect, Debug, PartialEq, Eq, Clone)]
pub struct MaterializedTextPrompt {
    pub prompt: TextPrompt,
    pub materialized: String,
}

#[derive(Resource, Debug, Default, Reflect, PartialEq, Eq, Clone)]
#[reflect(Resource)]
pub struct TextPromptHandles {
    pub raw: Handle<TextAsset>,
    pub chat: Handle<TextAsset>,
}

#[derive(Reflect, Debug, PartialEq, Eq, Clone)]
pub enum SpeechPrompt {
    Raw { content: String },
}

#[derive(Reflect, Debug, PartialEq, Eq, Clone)]
pub enum TranscriptionPrompt {
    Raw { content: Vec<u8> },
}

````



## D:\Repos\Games\Cursor-Hero\crates\toolbelt_types\src\toolbelt_types.rs

````rust
use std::fmt::Debug;

use bevy::prelude::*;
use bevy::utils::HashMap;
use leafwing_input_manager::prelude::*;
use leafwing_input_manager::user_input::InputKind;
use serde::Deserialize;
use serde::Serialize;

#[derive(Actionlike, PartialEq, Eq, Clone, Copy, Hash, Debug, Reflect)]
pub enum ToolbeltAction {
    Show,
}

impl ToolbeltAction {
    fn default_mkb_binding(&self) -> UserInput {
        match self {
            Self::Show => UserInput::Single(InputKind::Keyboard(KeyCode::AltLeft)),
        }
    }
    fn default_gamepad_binding(&self) -> UserInput {
        match self {
            Self::Show => GamepadButtonType::RightTrigger2.into(),
        }
    }

    // TODO: convert toolbelt to normal tool structure
    pub fn default_input_map() -> InputMap<ToolbeltAction> {
        let mut input_map = InputMap::default();

        for variant in ToolbeltAction::variants() {
            input_map.insert(variant.default_mkb_binding(), variant);
            input_map.insert(variant.default_gamepad_binding(), variant);
        }
        input_map
    }
}

#[derive(Component, Reflect, Clone, Copy, Debug, Serialize, Deserialize, PartialEq)]
pub struct Toolbelt {
    pub open: bool,
    pub loadout: ToolbeltLoadout,
    pub layout: ToolbeltLayout,
}
impl Default for Toolbelt {
    fn default() -> Self {
        Self {
            open: false,
            loadout: ToolbeltLoadout::Default,
            layout: ToolbeltLoadout::Default.layout(),
        }
    }
}

#[derive(Bundle)]
pub struct ToolbeltBundle {
    pub circle: Wheel,
    pub spatial: SpatialBundle,
    pub name: Name,
    pub input_manager: InputManagerBundle<ToolbeltAction>,
    pub toolbelt: Toolbelt,
}
impl Default for ToolbeltBundle {
    fn default() -> Self {
        Self {
            circle: Wheel::default(),
            spatial: SpatialBundle {
                visibility: Visibility::Hidden,
                ..default()
            },
            name: Name::new("Toolbelt"),
            input_manager: InputManagerBundle::<ToolbeltAction> {
                input_map: ToolbeltAction::default_input_map(),
                ..Default::default()
            },
            toolbelt: Toolbelt::default(),
        }
    }
}

#[derive(Reflect, Clone, Copy, Debug, Default, Eq, PartialEq, Serialize, Deserialize)]
pub enum ToolbeltLoadout {
    #[default]
    Default,
    Inspector,
    Taskbar,
    Keyboard,
    Agent,
    Chat,
    WindowPosition,
}
impl ToolbeltLoadout {
    pub fn layout(&self) -> ToolbeltLayout {
        match self {
            Self::Taskbar => ToolbeltLayout::Taskbar {
                wheel: Wheel::default(),
            },
            _ => ToolbeltLayout::default(),
        }
    }
}

#[derive(Reflect, Clone, Copy, Debug, Serialize, Deserialize, PartialEq)]
pub enum ToolbeltLayout {
    Circle { wheel: Wheel },
    Taskbar { wheel: Wheel },
}
impl Default for ToolbeltLayout {
    fn default() -> Self {
        Self::Circle {
            wheel: Wheel::default(),
        }
    }
}

#[derive(Event, Debug, Reflect, Clone, Copy)]
pub struct ToolbeltPopulateEvent {
    pub id: Entity,
    pub loadout: ToolbeltLoadout,
}

#[derive(Event, Debug, Reflect)]
pub enum ToolbeltOpeningEvent {
    Opened { toolbelt_id: Entity },
    Closed { toolbelt_id: Entity },
}

#[derive(Component, Reflect, Clone, Copy, Debug, Serialize, Deserialize, PartialEq)]
pub struct Wheel {
    pub radius: f32,
    pub radius_start: f32,
    pub radius_end: f32,
    pub radius_end_bonus_per_tool_after_8: f32,
    pub spin: f32,
    pub spin_start: f32,
    pub spin_end: f32,
    pub scale: f32,
    pub scale_start: f32,
    pub scale_end: f32,
    pub alpha: f32,
    pub alpha_start: f32,
    pub alpha_end: f32,
    pub open: bool,
}
impl Default for Wheel {
    fn default() -> Self {
        Self {
            radius: 200.0,
            // min_radius: 50.0,
            radius_start: 200.0,
            radius_end: 200.0,
            radius_end_bonus_per_tool_after_8: 10.0,
            spin: 0.0,
            spin_start: 300.0,
            spin_end: 360.0,
            scale: 1.0,
            scale_start: 0.5,
            scale_end: 1.0,
            alpha: 0.0,
            alpha_start: 0.0,
            alpha_end: 1.0,
            open: false,
        }
    }
}

#[derive(Component, Reflect, Clone, Debug)]
pub struct Tool {
    pub name: String,
    pub description: String,
    pub actions: HashMap<String, Vec<UserInput>>,
    pub texture: Handle<Image>,
}

#[derive(Component, Reflect, Clone, Copy, Debug)]
pub struct ToolHelpTrigger;

pub trait ToolAction: Actionlike {
    fn default_input_map(_event: &ToolbeltPopulateEvent) -> Option<InputMap<Self>>;
    fn with_defaults<G, K>(gamepad: G, keyboard: K) -> InputMap<Self>
    where
        G: Fn(&Self) -> UserInput,
        K: Fn(&Self) -> UserInput,
        Self: Clone,
    {
        let mut input_map = InputMap::default();

        for variant in Self::variants() {
            let g = gamepad(&variant);
            let k = keyboard(&variant);
            input_map.insert(g, variant.clone());
            input_map.insert(k, variant);
        }
        input_map
    }
}

#[derive(Component, Reflect, Debug, PartialEq, Eq)]
pub struct ActiveTool;

#[derive(Event, Debug, Reflect)]
pub enum ToolActivationEvent {
    Activate(Entity),
    Deactivate(Entity),
}

#[derive(Component, Reflect, Debug)]
pub struct ToolHelp {
    pub timer: Timer,
}

````



## D:\Repos\Games\Cursor-Hero\crates\ui_automation\src\gather_children.rs

````rust
use std::collections::VecDeque;

use cursor_hero_metrics::Metrics;
use uiautomation::UIElement;
use uiautomation::UITreeWalker;

#[allow(dead_code)]
#[derive(Debug)]
pub enum StopBehaviour {
    EndOfSiblings,
    LastChildEncountered,
    TaskbarEndEncountered,
    RootEndEncountered, // Calling get_next_sibling on the last child of root will hang, so use this to mitigate
}
impl StopBehaviour {
    fn include_last_child(&self) -> bool {
        !matches!(self, StopBehaviour::TaskbarEndEncountered)
    }
}
trait GatherChildrenStopBehaviourFn {
    fn should_stop(&self, next: &UIElement) -> bool;
}

#[derive(Debug)]
struct EndOfSiblings;
impl GatherChildrenStopBehaviourFn for EndOfSiblings {
    fn should_stop(&self, _element: &UIElement) -> bool {
        false
    }
}

#[derive(Debug)]
struct LastChildEncountered {
    runtime_id_of_last: Vec<i32>,
}
impl GatherChildrenStopBehaviourFn for LastChildEncountered {
    fn should_stop(&self, element: &UIElement) -> bool {
        element.get_runtime_id() == Ok(self.runtime_id_of_last.clone())
    }
}

#[derive(Debug)]
struct TaskbarEndEncountered;
impl GatherChildrenStopBehaviourFn for TaskbarEndEncountered {
    fn should_stop(&self, element: &UIElement) -> bool {
        element.get_automation_id() == Ok("TaskbarEndAccessibilityElement".to_string())
    }
}

#[derive(Debug)]
struct RootEndEncountered;
impl GatherChildrenStopBehaviourFn for RootEndEncountered {
    fn should_stop(&self, element: &UIElement) -> bool {
        element.get_name() == Ok("Program Manager".to_string())
            && element.get_classname() == Ok("Progman".to_string())
        // This could be more specific, but until a false positive is encountered, this is fine
    }
}

pub trait GatherChildrenable {
    fn gather_children(
        &self,
        walker: &UITreeWalker,
        stop_behaviour: &StopBehaviour,
    ) -> VecDeque<UIElement>;
}
impl GatherChildrenable for UIElement {
    fn gather_children(
        &self,
        walker: &UITreeWalker,
        stop_behaviour: &StopBehaviour,
    ) -> VecDeque<UIElement> {
        gather_children(walker, self, stop_behaviour)
    }
}

pub fn gather_children(
    walker: &UITreeWalker,
    parent: &UIElement,
    stop_behaviour: &StopBehaviour,
) -> VecDeque<UIElement> {
    // println!("Gathering children of {:?}", parent);
    let mut children = VecDeque::new();
    let mut metrics = Metrics::default();

    // println!("Constructing stop behaviour fn for {:?}", stop_behaviour);
    metrics.begin("construct stop behaviour");
    let stop: Box<dyn GatherChildrenStopBehaviourFn> = match stop_behaviour {
        StopBehaviour::EndOfSiblings => Box::new(EndOfSiblings),
        StopBehaviour::LastChildEncountered => {
            // println!("Getting last child of {:?}", parent);
            let last = walker.get_last_child(parent);
            let last = match last {
                Ok(last) => last,
                Err(_) => {
                    eprintln!("Failed to get last child of {:?}", parent);
                    return children
                },
            };
            let runtime_id_of_last = last.get_runtime_id();
            let runtime_id_of_last = match runtime_id_of_last {
                Ok(runtime_id_of_last) => runtime_id_of_last,
                Err(_) => {
                    eprintln!("Failed to get runtime id of last child {:?} of {:?}", last, parent);
                    return children
                },
            };
            Box::new(LastChildEncountered { runtime_id_of_last })
        }
        StopBehaviour::TaskbarEndEncountered => Box::new(TaskbarEndEncountered),
        StopBehaviour::RootEndEncountered => Box::new(RootEndEncountered),
    };
    metrics.end("construct stop behaviour");
    // println!("Constructed stop behaviour {:?}", stop_behaviour);

    // println!("Finding first child");
    metrics.begin("find first child");
    let first = walker.get_first_child(parent);
    metrics.end("find first child");
    // println!("Found first child");

    let Ok(first) = first else {
        return children;
    };
    children.push_back(first.clone());
    let mut next = first;
    let mut i = 0;
    loop {
        // println!("About to grab next sibling of {:?}", next);
        metrics.begin(format!("get next sibling {}", i).as_str());
        let sibling = walker.get_next_sibling(&next);
        metrics.end(format!("get next sibling {}", i).as_str());
        i += 1;

        if let Ok(sibling) = sibling {
            // println!("Got sibling {:?}", sibling);
            // println!("Checking if should stop");
            if stop.should_stop(&sibling) {
                // println!("Should stop");
                if stop_behaviour.include_last_child() {
                    // println!("Including last child");
                    children.push_back(sibling.clone());
                }
                break;
            } else {
                // println!("Should not stop");
                children.push_back(sibling.clone());
                next = sibling;
            }
        } else {
            break;
        }
    }
    // println!("Gathered {} children", children.len());
    // println!("| {}", metrics.report().split(" | ").join("\n| "));
    children
}

````



## D:\Repos\Games\Cursor-Hero\crates\ui_automation_types\src\ui_automation_error_types.rs

````rust
use crate::prelude::VSCodeResolveError;
use crate::ui_automation_drill::DrillError;
use std::fmt;

#[derive(Debug)]
pub enum AppResolveError {
    UI(uiautomation::Error),
    BadStructure(String),
    BadVSCodeStructure(String),
    NoMatch,
}
impl From<uiautomation::Error> for AppResolveError {
    fn from(e: uiautomation::Error) -> Self {
        AppResolveError::UI(e)
    }
}
impl From<DrillError> for AppResolveError {
    fn from(e: DrillError) -> Self {
        match e {
            DrillError::UI(e) => AppResolveError::UI(e),
            DrillError::EmptyPath => AppResolveError::BadStructure("Empty path".to_string()),
            DrillError::BadPath => AppResolveError::BadStructure("Bad path".to_string()),
            DrillError::OutOfBounds {
                given,
                max,
                error: e,
            } => AppResolveError::BadStructure(format!(
                "Out of bounds: given: {}, max: {}, error: {}",
                given, max, e
            )),
        }
    }
}
impl From<VSCodeResolveError> for AppResolveError {
    fn from(e: VSCodeResolveError) -> Self {
        match e {
            VSCodeResolveError::UnknownSideTabKind(s) => {
                AppResolveError::BadVSCodeStructure(format!("Unknown VSCode side tab kind: {}", s))
            }
            VSCodeResolveError::UnknownState => {
                AppResolveError::BadVSCodeStructure("Unknown VSCode state".to_string())
            }
            VSCodeResolveError::UI(e) => AppResolveError::UI(e),
            VSCodeResolveError::BadChildCount { tried_accessing } => AppResolveError::BadVSCodeStructure(
                format!("Bad child count: tried accessing: {}", tried_accessing),
            ),
        }
    }
}

impl fmt::Display for AppResolveError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        // Write a descriptive message for the error.
        write!(f, "{:?}", self)
    }
}
impl std::error::Error for AppResolveError {}

#[derive(Debug)]
pub enum GatherAppsError {
    UI(uiautomation::Error),
    NoneMatch,
    ResolveFailed(Vec<AppResolveError>),
}
impl From<uiautomation::Error> for GatherAppsError {
    fn from(e: uiautomation::Error) -> Self {
        GatherAppsError::UI(e)
    }
}

impl fmt::Display for GatherAppsError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        // Write a descriptive message for the error.
        write!(f, "{:?}", self)
    }
}
impl std::error::Error for GatherAppsError {}

````



## D:\Repos\Games\Cursor-Hero\crates\tools\src\keyboard_tool.rs

````rust
use crate::prelude::*;
use bevy::prelude::*;
use bevy::utils::HashMap;
use bevy_inspector_egui::prelude::ReflectInspectorOptions;
use bevy_inspector_egui::InspectorOptions;
use cursor_hero_character_types::prelude::*;
use cursor_hero_math::prelude::Lerp;
use cursor_hero_sprint_tool_types::sprint_tool_types_plugin::SprintEvent;
use cursor_hero_toolbelt_types::prelude::*;
use enigo::Direction::Press;
use enigo::Direction::Release;
use enigo::*;
use itertools::Itertools;
use leafwing_input_manager::prelude::*;

pub struct KeyboardToolPlugin;

impl Plugin for KeyboardToolPlugin {
    fn build(&self, app: &mut App) {
        app.add_plugins(InputManagerPlugin::<KeyboardToolAction>::default());
        app.add_systems(
            Update,
            (toolbelt_events, handle_input, handle_sprint_events),
        );
    }
}

#[derive(Component, InspectorOptions, Debug, Reflect)]
#[reflect(Component, InspectorOptions)]
struct KeyboardTool {
    #[inspector(min = 0.0)]
    repeat_delay: f32,
    #[inspector(min = 0.0)]
    default_repeat_delay: f32,
    #[inspector(min = 0.0)]
    sprint_repeat_delay: f32,
}
impl Default for KeyboardTool {
    fn default() -> Self {
        Self {
            repeat_delay: 0.1,
            default_repeat_delay: 0.1,
            sprint_repeat_delay: 0.001,
        }
    }
}

fn toolbelt_events(
    mut commands: Commands,
    asset_server: Res<AssetServer>,
    mut reader: EventReader<ToolbeltPopulateEvent>,
) {
    for event in reader.read() {
        if event.loadout != ToolbeltLoadout::Keyboard {
            continue;
        }
        ToolSpawnConfig::<KeyboardTool, KeyboardToolAction>::new(
            KeyboardTool::default(),
            event.id,
            event,
        )
        .with_src_path(file!().into())
        .guess_name(file!())
        .guess_image(file!(), &asset_server, "png")
        .with_description("Keyboard inputs")
        .spawn(&mut commands);
    }
}

#[derive(Actionlike, PartialEq, Eq, Clone, Copy, Hash, Debug, Reflect)]
enum KeyboardToolAction {
    Ctrl,
    Tab,
    Enter,
    Backspace,
    // Escape,
    Shift,
    Space,
    Windows,
    UpArrow,
    DownArrow,
    LeftArrow,
    RightArrow,
}

impl KeyboardToolAction {
    fn to_enigo(self) -> Key {
        match self {
            Self::Ctrl => Key::Control,
            Self::Tab => Key::Tab,
            Self::Enter => Key::Return,
            Self::Backspace => Key::Backspace,
            // Self::Escape => Key::Escape,
            Self::Shift => Key::Shift,
            Self::Space => Key::Space,
            Self::Windows => Key::Meta,
            Self::UpArrow => Key::UpArrow,
            Self::DownArrow => Key::DownArrow,
            Self::LeftArrow => Key::LeftArrow,
            Self::RightArrow => Key::RightArrow,
        }
    }
}

impl KeyboardToolAction {
    fn default_gamepad_binding(&self) -> UserInput {
        match self {
            Self::Ctrl => GamepadButtonType::RightTrigger.into(),
            Self::Tab => GamepadButtonType::West.into(),
            Self::Enter => GamepadButtonType::North.into(),
            Self::Backspace => GamepadButtonType::East.into(),
            // Self::Escape => GamepadButtonType::Select.into(),
            Self::Shift => GamepadButtonType::LeftTrigger.into(),
            Self::Space => GamepadButtonType::South.into(),
            Self::Windows => GamepadButtonType::Start.into(),
            Self::UpArrow => GamepadButtonType::DPadUp.into(),
            Self::DownArrow => GamepadButtonType::DPadDown.into(),
            Self::LeftArrow => GamepadButtonType::DPadLeft.into(),
            Self::RightArrow => GamepadButtonType::DPadRight.into(),
        }
    }

    fn default_mkb_binding(&self) -> UserInput {
        match self {
            Self::Ctrl => KeyCode::ControlLeft.into(),
            Self::Tab => KeyCode::Tab.into(),
            Self::Enter => KeyCode::Return.into(),
            Self::Backspace => KeyCode::Back.into(),
            // Self::Escape => KeyCode::Escape.into(),
            Self::Shift => KeyCode::ShiftLeft.into(),
            Self::Space => KeyCode::Space.into(),
            Self::Windows => KeyCode::SuperLeft.into(),
            Self::UpArrow => KeyCode::Up.into(),
            Self::DownArrow => KeyCode::Down.into(),
            Self::LeftArrow => KeyCode::Left.into(),
            Self::RightArrow => KeyCode::Right.into(),
        }
    }
}

impl ToolAction for KeyboardToolAction {
    fn default_input_map(_event: &ToolbeltPopulateEvent) -> Option<InputMap<KeyboardToolAction>> {
        let mut input_map = InputMap::default();

        for variant in KeyboardToolAction::variants() {
            input_map.insert(variant.default_mkb_binding(), variant);
            input_map.insert(variant.default_gamepad_binding(), variant);
        }
        Some(input_map)
    }
}

fn handle_input(
    tool_query: Query<(Entity, &ActionState<KeyboardToolAction>, &KeyboardTool), With<ActiveTool>>,
    mut enigo: Local<Option<Enigo>>,
    time: Res<Time>,
    mut debounce: Local<HashMap<(Entity, KeyboardToolAction), Timer>>,
) {
    debounce.values_mut().for_each(|timer| {
        timer.tick(time.delta());
    });
    debounce.retain(|_, timer| !timer.finished());

    if enigo.is_none() {
        *enigo = Enigo::new(&Settings::default()).ok();
    }
    let Some(ref mut enigo) = *enigo else {
        warn!("Failed to create enigo");
        return;
    };

    for tool in tool_query.iter() {
        let (tool_id, tool_actions, tool) = tool;
        for variant in KeyboardToolAction::variants() {
            if tool_actions.pressed(variant) {
                if tool_actions.just_pressed(variant) {
                    info!("{:?} key down", variant);
                }
                if (*debounce).contains_key(&(tool_id, variant)) {
                    continue;
                } else {
                    debounce.insert(
                        (tool_id, variant),
                        Timer::from_seconds(tool.repeat_delay, TimerMode::Once),
                    );
                }
                if let Err(e) = enigo.key(variant.to_enigo(), Press) {
                    warn!("Failed to send key: {:?}", e);
                }
            }
            if tool_actions.just_released(variant) {
                info!("{:?} key up", variant);
                if let Err(e) = enigo.key(variant.to_enigo(), Release) {
                    warn!("Failed to send key: {:?}", e);
                }
            }
        }
    }
}
#[cfg(test)]
mod tests {
    // test that sending shift + arrow keys is highlighting text
    #[test]
    fn test_shift_arrow() {
        use enigo::Direction::Press;
        use enigo::Direction::Release;
        use enigo::Enigo;
        use enigo::Key;
        use enigo::Keyboard;
        use enigo::Settings;
        use std::thread::sleep;
        use std::time::Duration;

        let mut enigo = Enigo::new(&Settings::default()).unwrap();

        sleep(Duration::from_secs(1));
        enigo.key(Key::Shift, Press).unwrap();
        enigo.key(Key::Control, Press).unwrap();
        enigo.key(Key::RightArrow, Press).unwrap();

        enigo.key(Key::RightArrow, Release).unwrap();
        enigo.key(Key::Control, Release).unwrap();
        enigo.key(Key::Shift, Release).unwrap();
    }
}

fn handle_sprint_events(
    mut sprint_events: EventReader<SprintEvent>,
    character_query: Query<&Children, With<Character>>,
    toolbelt_query: Query<&Children, With<Toolbelt>>,
    mut tool_query: Query<&mut KeyboardTool>,
) {
    for event in sprint_events.read() {
        let character_id = match event {
            SprintEvent::Active { character_id, .. } => character_id,
            SprintEvent::Stop { character_id } => character_id,
        };
        let Ok(character) = character_query.get(*character_id) else {
            warn!("Character {:?} does not exist", character_id);
            continue;
        };
        let character_kids = character;
        let tool_ids = character_kids
            .iter()
            .filter_map(|kid| toolbelt_query.get(*kid).ok())
            .flat_map(|toolbelt| toolbelt.iter())
            .filter(|kid| tool_query.contains(**kid))
            .cloned()
            .collect_vec();

        match event {
            SprintEvent::Active { throttle, .. } => {
                let mut iter = tool_query.iter_many_mut(&tool_ids);
                while let Some(mut tool) = iter.fetch_next() {
                    tool.repeat_delay =
                        (tool.default_repeat_delay, tool.sprint_repeat_delay).lerp(*throttle);
                }
            }
            SprintEvent::Stop { .. } => {
                let mut iter = tool_query.iter_many_mut(&tool_ids);
                while let Some(mut tool) = iter.fetch_next() {
                    tool.repeat_delay = tool.default_repeat_delay;
                }
            }
        }
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\ui_watcher_types\src\lib.rs

````rust
pub mod ui_watcher_types;
pub mod ui_watcher_types_plugin;

pub mod prelude {
    pub use crate::ui_watcher_types::*;
    pub use crate::ui_watcher_types_plugin::*;
}

````



## D:\Repos\Games\Cursor-Hero\crates\pointer\src\pointer_plugin.rs

````rust
use bevy::prelude::*;
use cursor_hero_pointer_types::pointer_action_types::PointerActionPlugin;

use crate::pointer_click_plugin::PointerClickPlugin;
use crate::pointer_hover_plugin::PointerHoverPlugin;
use crate::pointer_positioning_plugin::PointerPositioningPlugin;
use crate::pointer_reach_plugin::PointerReachPlugin;
use crate::pointer_spawning_plugin::PointerSpawningPlugin;

pub struct PointerPlugin;
impl Plugin for PointerPlugin {
    fn build(&self, app: &mut App) {
        app.add_plugins((
            PointerHoverPlugin,
            PointerReachPlugin,
            PointerClickPlugin,
            PointerPositioningPlugin,
            PointerSpawningPlugin,
            PointerActionPlugin,
        ));
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\ui_automation_types\src\taskbar_ui_types.rs

````rust
use bevy::prelude::*;

#[derive(Debug, Reflect, Clone)]
pub struct Taskbar {
    pub entries: Vec<TaskbarEntry>,
}
#[derive(Debug, Reflect, Clone)]
pub struct TaskbarEntry {
    pub name: String,
    pub bounds: IRect,
}

````



## D:\Repos\Games\Cursor-Hero\crates\window_swap_tool_types\src\window_swap_tool_types.rs

````rust
use bevy::prelude::*;
use leafwing_input_manager::prelude::*;

use bevy_inspector_egui::prelude::ReflectInspectorOptions;
use bevy_inspector_egui::InspectorOptions;
use cursor_hero_input::active_input_state_plugin::InputMethod;
use cursor_hero_toolbelt_types::prelude::*;

#[derive(Component, Reflect, Debug, InspectorOptions)]
#[reflect(Component, InspectorOptions)]
pub struct WindowSwapTool;

impl Default for WindowSwapTool {
    fn default() -> Self {
        match InputMethod::default() {
            InputMethod::MouseAndKeyboard | InputMethod::Keyboard => Self::default_mnk(),
            InputMethod::Gamepad => Self::default_gamepad(),
        }
    }
}
impl WindowSwapTool {
    pub fn default_mnk() -> WindowSwapTool {
        WindowSwapTool
    }
    pub fn default_gamepad() -> WindowSwapTool {
        WindowSwapTool
    }
}

#[derive(Actionlike, PartialEq, Eq, Clone, Copy, Hash, Debug, Reflect)]
pub enum WindowSwapToolAction {
    Use,
}

impl WindowSwapToolAction {
    fn default_gamepad_binding(&self) -> UserInput {
        match self {
            Self::Use => GamepadButtonType::North.into(),
        }
    }

    fn default_mkb_binding(&self) -> UserInput {
        match self {
            Self::Use => KeyCode::Q.into(),
        }
    }
}
impl ToolAction for WindowSwapToolAction {
    fn default_input_map(_event: &ToolbeltPopulateEvent) -> Option<InputMap<WindowSwapToolAction>> {
        let mut input_map = InputMap::default();

        for variant in WindowSwapToolAction::variants() {
            input_map.insert(variant.default_mkb_binding(), variant);
            input_map.insert(variant.default_gamepad_binding(), variant);
        }
        Some(input_map)
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\window_position\src\lib.rs

````rust
pub mod window_position_command_plugin;
pub mod window_position_loadout_switcher_tool_plugin;
pub mod window_position_plugin;
pub mod window_position_tool_plugin;

pub mod prelude {
    pub use crate::window_position_plugin::*;
}

````



## D:\Repos\Games\Cursor-Hero\crates\winutils\src\win_keyboard.rs

````rust


````



## D:\Repos\Games\Cursor-Hero\crates\ui_automation\src\resolve_vscode.rs

````rust
use bevy::math::IVec2;
use cursor_hero_ui_automation_types::prelude::*;
use itertools::Itertools;
use uiautomation::controls::ControlType;
use uiautomation::patterns::UIExpandCollapsePattern;
use uiautomation::types::ExpandCollapseState;
use uiautomation::types::TreeScope;
use uiautomation::types::UIProperty;
use uiautomation::variants::Variant;
use uiautomation::UIAutomation;
use uiautomation::UIElement;
use uiautomation::UITreeWalker;

use crate::gather_children::gather_children;
use crate::gather_children::GatherChildrenable;
use crate::gather_children::StopBehaviour;

pub(crate) fn resolve_vscode(
    elem: &UIElement,
    automation: &UIAutomation,
    focused: bool,
) -> Result<AppWindow, AppResolveError> {
    let walker = automation.create_tree_walker()?;
    let root = elem;

    let temp = root.drill(&walker, vec![0, 0, 0, 0, 0, 1])?;

    let body = temp.drill(&walker, vec![1, 0, 1])?;
    let body = resolve_body(&body, &walker)?;

    let footer = temp.drill(&walker, vec![2, 0])?;
    let footer = resolve_footer(&footer, automation)?;
    drop(temp);

    Ok(AppWindow::VSCode(VSCodeWindow {
        focused,
        header: VSCodeWindowHeader {},
        body,
        footer,
    }))
}

fn resolve_body(
    body: &UIElement,
    walker: &UITreeWalker,
) -> Result<VSCodeWindowBody, AppResolveError> {
    let state =
        VSCodeCrawlState::try_from(gather_children(walker, body, &StopBehaviour::EndOfSiblings))?;

    let side_nav = state
        .get_side_nav_tabs_root_elem()?
        .drill(walker, vec![0, 0])?
        .gather_children(walker, &StopBehaviour::LastChildEncountered);
    // println!("side_nav: {:?}", side_nav);
    let side_nav = side_nav
        .into_iter()
        .filter(|elem| elem.get_control_type() == Ok(ControlType::TabItem))
        .map(|elem| {
            let name = elem.get_name()?;
            let kind = SideTabKind::try_from(name)?;
            let active = elem
                .get_property_value(UIProperty::ExpandCollapseExpandCollapseState)
                .map(|v| v.try_into() == Ok(ExpandCollapseState::Expanded as i32))
                .unwrap_or_default();
            if active {
                let view = state
                    .get_side_nav_view_root_elem()?
                    .drill(walker, vec![1])?;
                let view = match view.get_automation_id() {
                    Ok(id)
                        if Some(id.as_str()) == SideTabKind::Explorer.get_view_automation_id() =>
                    {
                        fn as_explorer_item(
                            walker: &UITreeWalker,
                            tree_item: UIElement,
                        ) -> Result<ExplorerItem, AppResolveError> {
                            let label = tree_item.get_name()?;
                            let ui_position_in_set = tree_item
                                .get_property_value(UIProperty::PositionInSet)?
                                .try_into()?;
                            let ui_size_of_set = tree_item
                                .get_property_value(UIProperty::SizeOfSet)?
                                .try_into()?;
                            let ui_level = tree_item
                                .get_property_value(UIProperty::Level)?
                                .try_into()?;
                            let bounds = tree_item.get_bounding_rectangle()?.to_bevy_irect();
                            let kind = tree_item
                                .get_pattern::<UIExpandCollapsePattern>()
                                .ok()
                                .map(|p| ExplorerItemKind::Directory {
                                    expanded: p.get_state() == Ok(ExpandCollapseState::Expanded),
                                })
                                .unwrap_or(ExplorerItemKind::File);
                            let path = tree_item
                                .drill(
                                    walker,
                                    match kind {
                                        ExplorerItemKind::File => vec![0, 1, 0],
                                        ExplorerItemKind::Directory { .. } => {
                                            vec![0, 2, 0]
                                        }
                                    },
                                )?
                                .get_name()?;
                            Ok(ExplorerItem {
                                label,
                                path,
                                ui_position_in_set,
                                ui_size_of_set,
                                ui_level,
                                bounds,
                                kind,
                            })
                        }
                        let sticky = view
                            .drill(walker, vec![0, 1, 0, 0, 1, 0, 3])?
                            .gather_children(walker, &StopBehaviour::EndOfSiblings)
                            .into_iter()
                            .filter_map(|tree_item| as_explorer_item(walker, tree_item).ok())
                            .collect();
                        let items = view
                            .drill(walker, vec![0, 1, 0, 0, 1, 0, 0])?
                            .gather_children(walker, &StopBehaviour::EndOfSiblings)
                            .into_iter()
                            .filter_map(|tree_item| as_explorer_item(walker, tree_item).ok())
                            .collect();
                        View::Explorer { sticky, items }
                    }
                    _ => {
                        View::Unknown {}
                        // elem: view.into()
                    }
                };

                Ok(SideTab::Open {
                    kind,
                    // button: elem.into(),
                    view,
                })
            } else {
                Ok(SideTab::Closed {
                    kind,
                    // button: elem.into(),
                })
            }
        })
        .filter_map(|res: Result<SideTab, AppResolveError>| res.ok())
        .collect();

    let editor_area_elem = state
        .get_editor_root_elem()?
        .drill(walker, vec![0, 1, 0, 0])?;
    if editor_area_elem.get_automation_id()? != EditorArea::get_expected_automation_id() {
        return Err(AppResolveError::BadVSCodeStructure(format!(
            "Editor area has wrong automation id: {}",
            editor_area_elem.get_automation_id()?
        )));
    }
    let editor_groups = editor_area_elem
        .drill(walker, vec![0, 0, 0, 1])?
        .gather_children(walker, &StopBehaviour::EndOfSiblings)
        .into_iter()
        .map(|group_elem| {
            let group_tabs_holder = group_elem.drill(walker, vec![0, 0, 0])?;
            let selected: Option<String> = group_tabs_holder
                .get_property_value(UIProperty::SelectionSelection)?
                .try_into()
                .ok();
            let group_tabs = group_tabs_holder
                .gather_children(walker, &StopBehaviour::EndOfSiblings)
                .into_iter()
                .map(|group_tab_elem| {
                    let title = group_tab_elem.get_name()?;
                    let active = selected == Some(title.clone());
                    Ok(EditorTab { title, active })
                })
                .filter_map(|r: Result<EditorTab, AppResolveError>| r.ok())
                .collect();
            let content_elem = group_elem.drill(walker, vec![1, 0, 0, 1])?;
            let content = content_elem
                .get_property_value(UIProperty::LegacyIAccessibleValue)
                .map(|variant| variant.to_string())
                .map(|text_content| EditorContent {
                    content: text_content,
                })
                .ok();

            Ok(EditorGroup {
                tabs: group_tabs,
                content,
            })
        })
        .filter_map(|r: Result<EditorGroup, AppResolveError>| r.ok())
        .collect();
    let editor_area = EditorArea {
        groups: editor_groups,
    };

    Ok(VSCodeWindowBody {
        editor_area,
        side_nav,
    })
}

fn resolve_footer(
    footer: &UIElement,
    automation: &UIAutomation,
) -> Result<VSCodeWindowFooter, AppResolveError> {
    let condition = automation.create_property_condition(
        UIProperty::AutomationId,
        Variant::from("status.editor.selection"),
        None,
    )?;
    let cursor_position_elem = footer.find_first(TreeScope::Children, &condition)?;
    let text = cursor_position_elem.get_name()?;
    // "Ln 218, Col 5"
    let cursor_position = text
        .split(", ")
        .map(|part| part.split(' ').last().and_then(|s| s.parse::<usize>().ok()))
        .collect_vec();
    let cursor_position = match cursor_position.as_slice() {
        [Some(line), Some(column)] => IVec2::new(*column as i32, *line as i32),
        _ => {
            return Err(AppResolveError::BadVSCodeStructure(format!(
                "Bad cursor position {:?}",
                cursor_position
            )))
        }
    };
    Ok(VSCodeWindowFooter { cursor_position })
}

````



## D:\Repos\Games\Cursor-Hero\crates\tools\src\scroll_tool.rs

````rust
use bevy::prelude::*;
use bevy_inspector_egui::prelude::ReflectInspectorOptions;
use bevy_inspector_egui::InspectorOptions;
use cursor_hero_character_types::prelude::*;
use cursor_hero_math::prelude::Lerp;
use cursor_hero_sprint_tool_types::sprint_tool_types_plugin::SprintEvent;
use cursor_hero_toolbelt_types::prelude::*;
use cursor_hero_winutils::win_mouse::scroll_wheel;
use itertools::Itertools;
use leafwing_input_manager::prelude::*;

use crate::prelude::*;

pub struct ScrollToolPlugin;

impl Plugin for ScrollToolPlugin {
    fn build(&self, app: &mut App) {
        app.register_type::<ScrollTool>();
        app.add_plugins(InputManagerPlugin::<ScrollToolAction>::default());
        app.add_systems(Update, toolbelt_events);
        app.add_systems(Update, handle_input);
        app.add_systems(Update, handle_sprint_events);
    }
}

#[derive(Component, InspectorOptions, Reflect)]
#[reflect(Component, InspectorOptions)]
struct ScrollTool {
    #[inspector(min = 0.0)]
    pub speed: f32,
    #[inspector(min = 0.0)]
    pub default_speed: f32,
    #[inspector(min = 0.0)]
    pub sprint_speed: f32,
}
impl Default for ScrollTool {
    fn default() -> Self {
        Self {
            speed: 1.0,
            default_speed: 1.0,
            sprint_speed: 100.0,
        }
    }
}

fn toolbelt_events(
    mut commands: Commands,
    asset_server: Res<AssetServer>,
    mut reader: EventReader<ToolbeltPopulateEvent>,
) {
    for event in reader.read() {
        let (ToolbeltLoadout::Inspector | ToolbeltLoadout::Default) = event.loadout else {
            continue;
        };
        ToolSpawnConfig::<_, ScrollToolAction>::new(ScrollTool::default(), event.id, event)
            .with_src_path(file!().into())
            .guess_name(file!())
            .guess_image(file!(), &asset_server, "png")
            .with_description("Send scroll events")
            .spawn(&mut commands);
    }
}

#[derive(Actionlike, PartialEq, Eq, Clone, Copy, Hash, Debug, Reflect)]
enum ScrollToolAction {
    ScrollUp,
    ScrollDown,
}

impl ScrollToolAction {
    fn default_gamepad_binding(&self) -> UserInput {
        match self {
            Self::ScrollUp => GamepadButtonType::DPadUp.into(),
            Self::ScrollDown => GamepadButtonType::DPadDown.into(),
        }
    }

    fn default_mkb_binding(&self) -> UserInput {
        match self {
            Self::ScrollUp => KeyCode::PageDown.into(),
            Self::ScrollDown => KeyCode::PageUp.into(),
        }
    }
}
impl ToolAction for ScrollToolAction {
    fn default_input_map(_event: &ToolbeltPopulateEvent) -> Option<InputMap<ScrollToolAction>> {
        let mut input_map = InputMap::default();

        for variant in ScrollToolAction::variants() {
            input_map.insert(variant.default_mkb_binding(), variant);
            input_map.insert(variant.default_gamepad_binding(), variant);
        }
        Some(input_map)
    }
}

fn handle_input(
    tool_query: Query<(&ActionState<ScrollToolAction>, &ScrollTool), With<ActiveTool>>,
    time: Res<Time>,
) {
    for zoom_tool in tool_query.iter() {
        let (tool_actions, tool) = zoom_tool;
        let mut amount = None;
        if tool_actions.pressed(ScrollToolAction::ScrollUp) {
            if tool_actions.just_pressed(ScrollToolAction::ScrollUp) {
                info!("Scrolling up");
            }
            amount = Some(tool.speed * time.delta_seconds());
        }
        if tool_actions.pressed(ScrollToolAction::ScrollDown) {
            if tool_actions.just_pressed(ScrollToolAction::ScrollDown) {
                info!("Scrolling down");
            }
            amount = Some(-tool.speed * time.delta_seconds());
        }
        if let Some(amount) = amount {
            match scroll_wheel(amount) {
                Ok(_) => {}
                Err(e) => {
                    error!("Error scrolling up: {:?}", e);
                }
            }
        }
    }
}

fn handle_sprint_events(
    mut sprint_events: EventReader<SprintEvent>,
    character_query: Query<&Children, With<Character>>,
    toolbelt_query: Query<&Children, With<Toolbelt>>,
    mut tool_query: Query<&mut ScrollTool>,
) {
    for event in sprint_events.read() {
        let character_id = match event {
            SprintEvent::Active { character_id, .. } => character_id,
            SprintEvent::Stop { character_id } => character_id,
        };
        let Ok(character) = character_query.get(*character_id) else {
            warn!("Character {:?} does not exist", character_id);
            continue;
        };
        let character_kids = character;
        let tool_ids = character_kids
            .iter()
            .filter_map(|kid| toolbelt_query.get(*kid).ok())
            .flat_map(|toolbelt| toolbelt.iter())
            .filter(|kid| tool_query.contains(**kid))
            .cloned()
            .collect_vec();

        match event {
            SprintEvent::Active { throttle, .. } => {
                let mut iter = tool_query.iter_many_mut(&tool_ids);
                while let Some(mut tool) = iter.fetch_next() {
                    tool.speed = (tool.default_speed, tool.sprint_speed).lerp(*throttle);
                }
            }
            SprintEvent::Stop { .. } => {
                let mut iter = tool_query.iter_many_mut(&tool_ids);
                while let Some(mut tool) = iter.fetch_next() {
                    tool.speed = tool.default_speed;
                }
            }
        }
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\winutils\examples\app_icons_example.rs

````rust
use std::rc::Rc;

use bevy::utils::HashSet;
use cursor_hero_winutils::win_errors::*;
use cursor_hero_winutils::win_icons::get_images_from_exe;
use cursor_hero_winutils::win_process::*;
use windows::core::PWSTR;
use windows::Win32::Foundation::E_ACCESSDENIED;

fn main() -> Result<()> {
    unsafe {
        let process_iter = ProcessIterator::new()?;
        let mut done = HashSet::new();
        for mut process in process_iter {
            let exe_name_pwstr = PWSTR(process.szExeFile.as_mut_ptr());
            let exe_name = exe_name_pwstr.to_string()?;
            let exe_path = match get_process_full_name(process.th32ProcessID) {
                Ok(s) => s,
                Err(e) => {
                    if matches!(
                        e,
                        Error::Windows(ref e) if e.code() == E_ACCESSDENIED
                    ) {
                        continue;
                    }
                    eprintln!(
                        "Failed to get full process name for PID {:05} ({}): {:?}",
                        process.th32ProcessID, exe_name, e
                    );
                    continue;
                }
            };
            if done.contains(&exe_path) {
                continue;
            }
            done.insert(exe_path.clone());
            let icons = get_images_from_exe(exe_path.as_str())?;
            println!(
                "Process ID: {:05}, name: {}, icon count: {}",
                process.th32ProcessID,
                exe_name,
                icons.len()
            );

            if icons.is_empty() {
                continue;
            }

            // write the image to target/app_icons/{exe_name}/{icon_index}.png
            let mut path = std::path::PathBuf::from("target/app_icons");
            path.push(exe_name);
            std::fs::create_dir_all(&path).map_err(|e| Error::Other(Rc::new(e)))?;
            for (i, icon) in icons.iter().enumerate() {
                let mut icon_path = path.clone();
                icon_path.push(format!("{}.png", i));
                icon.save(icon_path).map_err(|e| Error::Other(Rc::new(e)))?;
            }
        }
    }
    Ok(())
}

````



## D:\Repos\Games\Cursor-Hero\crates\level_bounds\src\level_bounds_plugin.rs

````rust
use bevy::prelude::*;
use bevy_xpbd_2d::components::Collider;
use bevy_xpbd_2d::components::CollidingEntities;
use bevy_xpbd_2d::components::LinearVelocity;

use bevy_xpbd_2d::components::RigidBody;
use bevy_xpbd_2d::components::Sensor;
use cursor_hero_character_types::prelude::*;
use cursor_hero_environment_types::prelude::*;

pub struct LevelBoundsPlugin;

impl Plugin for LevelBoundsPlugin {
    fn build(&self, app: &mut App) {
        app.register_type::<LevelBounds>();
        app.register_type::<LevelBoundsHolder>();
        app.register_type::<LevelBoundsParentRef>();
        app.add_event::<LevelBoundsEvent>();
        app.add_systems(Update, enforce);
        app.add_systems(
            Update,
            (
                handle_populate_environment_events,
                apply_deferred,
                handle_level_bounds_events,
            )
                .chain(),
        );
    }
}

#[derive(Event, Reflect, Debug, Clone, Copy)]
pub enum LevelBoundsEvent {
    AddPlayArea { environment_id: Entity, area: Rect },
}

#[derive(Component, Reflect)]
pub struct LevelBoundsHolder;
#[derive(Component, Reflect)]
pub struct LevelBoundsParentRef(Entity);
impl LevelBoundsParentRef {
    pub fn get(&self) -> Entity {
        self.0
    }
}
#[derive(Component, Reflect)]
pub struct LevelBounds;

fn handle_populate_environment_events(
    mut commands: Commands,
    mut events: EventReader<PopulateEnvironmentEvent>,
    environment_query: Query<(), Or<(With<HostEnvironment>, With<GameEnvironment>)>>,
) {
    for event in events.read() {
        if !environment_query.contains(event.environment_id) {
            continue;
        }

        info!(
            "Populating environment {:?} with level bounds parent",
            event
        );
        let mut level_bounds_holder_id = None;
        commands.entity(event.environment_id).with_children(|parent| {
            level_bounds_holder_id = Some(
                parent
                    .spawn((
                        SpatialBundle::default(),
                        LevelBoundsHolder,
                        Name::new("Level Bounds"),
                    ))
                    .id(),
            );
        });
        let Some(level_bounds_holder_id) = level_bounds_holder_id else {
            warn!(
                "Failed to create level bounds holder for environment {:?}",
                event
            );
            continue;
        };
        commands
            .entity(event.environment_id)
            .insert(LevelBoundsParentRef(level_bounds_holder_id));
    }
}

pub fn handle_level_bounds_events(
    mut events: EventReader<LevelBoundsEvent>,
    environment_query: Query<&LevelBoundsParentRef, With<EnvironmentKind>>,
    mut commands: Commands,
    mut deferred: Local<Vec<LevelBoundsEvent>>,
) {
    let mut new_deferred = Vec::new();
    for event in events.read().chain(deferred.into_iter()) {
        match event {
            LevelBoundsEvent::AddPlayArea {
                environment_id,
                area,
            } => {
                if let Ok(level_bounds_parent_ref) = environment_query.get(*environment_id) {
                    info!(
                        "Adding play area with size {:?} to level bounds for environment {:?}",
                        area.size(),
                        environment_id
                    );
                    commands
                        .entity(level_bounds_parent_ref.get())
                        .with_children(|parent| {
                            parent.spawn((
                                SpriteBundle {
                                    sprite: Sprite {
                                        custom_size: Some(area.size()),
                                        color: Color::ORANGE,
                                        ..default()
                                    },
                                    transform: Transform::from_translation(
                                        area.center().extend(-2.0),
                                    ),
                                    visibility: Visibility::Hidden,
                                    ..default()
                                },
                                Sensor,
                                RigidBody::Static,
                                Collider::cuboid(area.size().x, area.size().y),
                                LevelBounds,
                                Name::new("Level Bounds"),
                            ));
                        });
                } else {
                    debug!(
                        "Deferring level bounds event for environment {:?}",
                        environment_id
                    );
                    new_deferred.push(*event);
                }
            }
        }
    }
    *deferred = new_deferred;
}

#[allow(clippy::type_complexity)]
fn enforce(
    mut character_query: Query<
        (Entity, &GlobalTransform, &mut LinearVelocity),
        (With<Character>, Without<LevelBounds>),
    >,
    level_bounds: Query<
        (&GlobalTransform, &CollidingEntities),
        (With<LevelBounds>, Without<Character>),
    >,
) {
    for (character_entity, character_transform, mut character_velocity) in
        character_query.iter_mut()
    {
        let mut is_in_bounds = false;
        for (_, in_bounds) in level_bounds.iter() {
            if in_bounds.contains(&character_entity) {
                is_in_bounds = true;
                break;
            }
        }
        if !is_in_bounds {
            // debug!("Found {} level bounds", level_bounds.iter().count());
            // apply a force to to the character in the direction of the nearest boundary
            let mut nearest_boundary = None;
            let mut nearest_boundary_distance = f32::MAX;
            for (bounds_transform, _) in level_bounds.iter() {
                let distance = character_transform
                    .translation()
                    .distance(bounds_transform.translation());
                // debug!("Distance to boundary: {}", distance);
                if distance < nearest_boundary_distance {
                    nearest_boundary_distance = distance;
                    nearest_boundary = Some(bounds_transform.translation());
                }
            }
            if let Some(nearest_boundary) = nearest_boundary {
                let direction = nearest_boundary - character_transform.translation();
                character_velocity.0 +=
                    direction.normalize().xy() * direction.length_squared() / 1000.0;
            }
        }
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\memory\src\main_character_memory_plugin.rs

````rust
use bevy::prelude::*;
use cursor_hero_character_types::prelude::*;

use cursor_hero_memory_types::prelude::*;
use cursor_hero_toolbelt_types::toolbelt_types::Toolbelt;
use cursor_hero_toolbelt_types::toolbelt_types::ToolbeltPopulateEvent;
use serde::Deserialize;
use serde::Serialize;

pub struct MainCharacterMemoryPlugin;

impl Plugin for MainCharacterMemoryPlugin {
    fn build(&self, app: &mut App) {
        app.insert_resource(MainCharacterMemoryConfig::default());
        app.add_systems(Update, persist.pipe(handle_persist_errors));
        app.add_systems(
            Update,
            (apply_deferred, restore.pipe(handle_restore_errors)).chain(),
        );
    }
}
const PERSIST_FILE_NAME: &str = "main_character.json";

// not moved to lib to ensure log contains this module name
fn handle_persist_errors(In(result): In<Result<PersistSuccess, PersistError>>) {
    if let Err(e) = result {
        error!("Persist error occurred: {:?}", e);
    } else if let Ok(PersistSuccess::WritePerformed) = result {
        debug!("Persisted succeeded");
    }
}

fn handle_restore_errors(In(result): In<Result<RestoreSuccess, RestoreError>>) {
    if let Err(e) = result {
        error!("Restore error occurred: {:?}", e);
    } else if let Ok(RestoreSuccess::Performed) = result {
        info!("Restore succeeded");
    }
}

#[derive(Debug, Resource, Reflect)]
#[reflect(Resource)]
struct MainCharacterMemoryConfig {
    pub debounce_timer: Timer,
}
impl Default for MainCharacterMemoryConfig {
    fn default() -> Self {
        Self {
            debounce_timer: Timer::from_seconds(10.0, TimerMode::Repeating),
        }
    }
}

#[derive(Debug, Serialize, Deserialize, PartialEq, Clone, Copy)]
struct DiskData {
    character_position: Vec3,
    toolbelt: Toolbelt,
}

fn persist(
    mut config: ResMut<MainCharacterMemoryConfig>,
    mut debounce: Local<Option<DiskData>>,
    time: Res<Time>,
    character_query: Query<(&Transform, &Children), With<MainCharacter>>,
    toolbelt_query: Query<&Toolbelt>,
) -> Result<PersistSuccess, PersistError> {
    if !config.debounce_timer.tick(time.delta()).just_finished() {
        return Ok(PersistSuccess::Cooldown);
    }

    let character = character_query
        .get_single()
        .map_err(|_| PersistError::Query)?;
    let (character_transform, character_children) = character;
    let character_position = character_transform.translation;

    let mut found = None;
    for child in character_children.iter() {
        match (found, toolbelt_query.get(*child)) {
            (None, Ok(toolbelt)) => {
                found = Some(toolbelt);
            }
            (Some(_), Ok(_)) => {
                return Err(PersistError::Query);
            }
            _ => {}
        }
    }
    let toolbelt = *found.ok_or(PersistError::Query)?;

    let data = DiskData {
        character_position,
        toolbelt,
    };
    if debounce.is_none() || debounce.as_ref().unwrap() != &data {
        let file = get_persist_file(file!(), PERSIST_FILE_NAME, Usage::Persist)
            .map_err(PersistError::Io)?;
        write_to_disk(file, data)?;
        *debounce = Some(data);
        Ok(PersistSuccess::WritePerformed)
    } else {
        Ok(PersistSuccess::Debounce)
    }
}

fn restore(
    mut character_query: Query<(&mut Transform, &Children), Added<MainCharacter>>,
    mut toolbelt_query: Query<&mut Toolbelt>,
    mut commands: Commands,
    mut toolbelt_events: EventWriter<ToolbeltPopulateEvent>,
) -> Result<RestoreSuccess, RestoreError> {
    let Ok(character) = character_query.get_single_mut() else {
        return Ok(RestoreSuccess::NoAction);
    };
    let (mut character_transform, character_children) = character;
    let mut toolbelt_id = None;
    for child in character_children.iter() {
        match (toolbelt_id, toolbelt_query.contains(*child)) {
            (None, true) => {
                toolbelt_id = Some(child);
            }
            (Some(_), true) => {
                return Err(RestoreError::Query);
            }
            _ => {}
        }
    }
    let toolbelt_id = *toolbelt_id.ok_or(RestoreError::Query)?;
    let mut toolbelt = toolbelt_query
        .get_mut(toolbelt_id)
        .map_err(|_| RestoreError::Query)?;

    let file =
        get_persist_file(file!(), PERSIST_FILE_NAME, Usage::Restore).map_err(RestoreError::Io)?;
    let data: DiskData = read_from_disk(file)?;

    info!(
        "Restoring main character position to {:?}",
        data.character_position
    );
    character_transform.translation = data.character_position;

    info!("Restoring toolbelt to {:?}", data.toolbelt);
    *toolbelt = data.toolbelt;
    commands.entity(toolbelt_id).despawn_descendants();
    toolbelt_events.send(ToolbeltPopulateEvent {
        id: toolbelt_id,
        loadout: data.toolbelt.loadout,
    });
    // layout is going to get clobbered to defaults by toolbelt_properties_plugin
    // this is fine for now since there are no scenarios where a loadout isn't using its default layout

    Ok(RestoreSuccess::Performed)
}

````



## D:\Repos\Games\Cursor-Hero\crates\sprint_tool_types\src\sprint_tool_types_plugin.rs

````rust
use bevy::prelude::*;

pub struct SprintToolTypesPlugin;

impl Plugin for SprintToolTypesPlugin {
    fn build(&self, app: &mut App) {
        app.add_event::<SprintEvent>();
    }
}

#[derive(Event, Debug, Reflect)]
pub enum SprintEvent {
    Active { character_id: Entity, throttle: f32 },
    Stop { character_id: Entity },
}

````



## D:\Repos\Games\Cursor-Hero\crates\icon\src\lib.rs

````rust
use bevy::prelude::*;
use bevy::winit::WinitWindows;
use winit::window::Icon;

pub struct IconPlugin;

impl Plugin for IconPlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(Startup, load_window_icon);
    }
}

#[derive(Resource, Reflect, Default)]
#[reflect(Resource)]
struct WindowIconResource(Handle<Image>);

fn load_window_icon(mut commands: Commands, asset_server: Res<AssetServer>) {
    let icon_handle = asset_server.load("textures/icon.png");
    commands.add(|world: &mut World| {
        // register the system
        let system_id = world.register_system(update_window_icon);
        info!(
            "Registered update_window_icon system with id {:?}",
            system_id
        );

        // add it to the update schedule
        let mut schedules = world.resource_mut::<Schedules>();
        if let Some(schedule) = schedules.get_mut(Update) {
            schedule.add_systems(update_window_icon);
        } else {
            let mut new_schedule = Schedule::new(Update);
            new_schedule.add_systems(update_window_icon);
            schedules.insert(new_schedule);
        }

        // add handle holder with system id for later removal
        world.insert_resource(WindowIconResource(icon_handle));
    });
}

fn update_window_icon(
    windows: NonSend<WinitWindows>,
    materials: Res<Assets<Image>>,
    icon_resource: Res<WindowIconResource>,
    // mut commands: Commands,
    mut flag: Local<bool>,
) {
    if *flag {
        return;
    }
    if let Some(icon) = materials.get(&icon_resource.0) {
        // update the icon
        let icon = Icon::from_rgba(icon.clone().data, icon.size().x, icon.size().y).unwrap();
        for window in windows.windows.values() {
            window.set_window_icon(Some(icon.clone()));
        }
        info!("Updated window icon");

        // remove this system
        // commands.add(move |world: &mut World| {
        //     match world.remove_system(system_id) {
        //         Ok(_) => info!("Removed update_window_icon system since it did its job"),
        //         Err(e) => error!("Failed to remove update_window_icon system: {}", e),
        //     }
        //     let mut schedules = world.resource_mut::<Schedules>();
        //     if let Some(_schedule) = schedules.get_mut(Update) {
        //         /*
        //         https://discord.com/channels/691052431525675048/749335865876021248/1138225592064561243
        //         Alice   08/07/2023 5:42 PM
        //         We're also missing a Schedule::remove_system API, with a solution for
        //         a) dependency invalidation and
        //         b) disambiguation of multiple copies of a system in the same schedule
        //                              */
        //         // this method does not exist yet.
        //         // should probably make a PR for it
        //         // and should also include a simplified way to remove a system from a schedule
        //         // maybe a .remove_when similar to .run_if
        //         // schedule.remove_system(system_id);
        //     }
        // });
        *flag = true;
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\secret_types\src\lib.rs

````rust
pub mod secrets_types;
pub mod secrets_types_plugin;

pub mod prelude {
    pub use crate::secrets_types::*;
    pub use crate::secrets_types_plugin::*;
}

````



## D:\Repos\Games\Cursor-Hero\crates\movement_tool\src\lib.rs

````rust
pub mod movement_speed_plugin;
pub mod movement_sprint_plugin;
pub mod movement_target_plugin;
pub mod movement_tool_plugin;
pub mod movement_tool_populate_plugin;
pub mod movement_tool_tick_plugin;

````



## D:\Repos\Games\Cursor-Hero\crates\window_swap_tool_types\src\window_swap_tool_types_plugin.rs

````rust
use crate::prelude::*;
use bevy::prelude::*;

pub struct WindowSwapToolTypesPlugin;

impl Plugin for WindowSwapToolTypesPlugin {
    fn build(&self, app: &mut App) {
        app.register_type::<WindowSwapTool>();
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\worker\src\worker_plugin.rs

````rust
use bevy::prelude::*;
use crossbeam_channel::bounded;
use cursor_hero_worker_types::prelude::*;
use std::thread;

use windows::Win32::System::Com::CoInitializeEx;
use windows::Win32::System::Com::COINIT_MULTITHREADED;
pub struct WorkerPlugin<T, G>
where
    T: Message,
    G: Message,
{
    pub config: WorkerConfig<T, G>,
}

impl<T, G> Plugin for WorkerPlugin<T, G>
where
    T: Message,
    G: Message,
{
    fn build(&self, app: &mut App) {
        // TODO: conditionally register if T or G support it
        // app.register_type::<T>();
        // app.register_type::<G>();
        app.add_event::<T>();
        app.add_event::<G>();
        app.insert_resource(self.config.clone());
        app.add_systems(Startup, create_worker_thread::<T, G>);
        app.add_systems(Update, bridge_requests::<T, G>);
        app.add_systems(Update, bridge_responses::<T, G>);
    }
}

fn create_worker_thread<T: Message, G: Message>(
    config: Res<WorkerConfig<T, G>>,
    mut commands: Commands,
) {
    let (game_tx, game_rx) = bounded::<G>(10);
    let (thread_tx, thread_rx) = bounded::<T>(10);

    commands.insert_resource(Bridge {
        sender: thread_tx,
        receiver: game_rx,
    });

    let name = config.name.clone();
    let handler = config.handle_threadbound_message;
    let handler_error_handler = config.handle_threadbound_message_error_handler;
    let sleep_duration = config.sleep_duration;
    let is_ui_automation_thread = config.is_ui_automation_thread;
    if let Err(e) = thread::Builder::new().name(name.clone()).spawn(move || {
        if is_ui_automation_thread {
            unsafe {
                // Initialize COM in MTA mode
                // https://learn.microsoft.com/en-us/dotnet/framework/ui-automation/ui-automation-threading-issues
                // https://learn.microsoft.com/en-us/windows/win32/com/multithreaded-apartments
                if let Err(e) = CoInitializeEx(None, COINIT_MULTITHREADED) {
                    error!("[{}] Failed to initialize COM: {:?}", name, e);
                }
                debug!("[{}] COM initialized in MTA mode.", name);
            }
        }

        let rt = tokio::runtime::Runtime::new().unwrap();
        rt.block_on(async {
            loop {
                let msg = match thread_rx.recv() {
                    Ok(msg) => msg,
                    Err(e) => {
                        error!(
                            "[{}] Threadbound channel recv failure {:?}, exiting: ",
                            name, e
                        );
                        break;
                    }
                };
                if let Err(e) = (handler)(&msg, &game_tx) {
                    // eprintln cause bevy logging isn't guaranteed to display
                    // eprintln!(
                    //     "[{}] Failed to process thread message {:?}, got error {:?}",
                    //     name, msg, e
                    // );
                    error!(
                        "[{}] Failed to process thread message {:?}, got error {:?}",
                        name, msg, e
                    );
                    if let Err(ee) = (handler_error_handler)(&msg, &game_tx, &e) {
                        error!(
                            "[{}] BAD NEWS! Failed while processing error handler for message {:?} that produced error {:?}, got new error {:?}",
                            name, msg, e, ee
                        );
                    }
                }
                std::thread::sleep(sleep_duration);
            }
        });
    }) {
        error!("[{}] Failed to spawn thread: {:?}", config.name, e);
    } else {
        info!("[{}] Thread created", config.name);
    }
}

fn bridge_requests<T: Message, G: Message>(
    config: Res<WorkerConfig<T, G>>,
    bridge: ResMut<Bridge<T, G>>,
    mut events: EventReader<T>,
) {
    for event in events.read() {
        trace!("[{}] Bevy => Thread: {:?}", config.name, event);
        if let Err(e) = bridge.sender.send(event.clone()) {
            error!("[{}] Threadbound channel failure: {:?}", config.name, e);
        }
    }
}

fn bridge_responses<T: Message, G: Message>(
    config: Res<WorkerConfig<T, G>>,
    bridge: ResMut<Bridge<T, G>>,
    mut events: EventWriter<G>,
) {
    for msg in bridge.receiver.try_iter() {
        trace!("[{}] Thread => Bevy: {:?}", config.name, msg);
        events.send(msg);
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\character\src\character_plugin.rs

````rust
use bevy::prelude::*;

use crate::character_appearance_plugin::CharacterAppearancePlugin;
use crate::character_spawning_plugin::CharacterSpawningPlugin;
pub struct CharacterPlugin;

impl Plugin for CharacterPlugin {
    fn build(&self, app: &mut App) {
        app.add_plugins(CharacterAppearancePlugin);
        app.add_plugins(CharacterSpawningPlugin);
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\ui_automation\src\resolve_calculator.rs

````rust
use bevy::math::IVec2;
use cursor_hero_ui_automation_types::prelude::*;
use itertools::Itertools;
use uiautomation::controls::ControlType;
use uiautomation::patterns::UIExpandCollapsePattern;
use uiautomation::types::ExpandCollapseState;
use uiautomation::types::TreeScope;
use uiautomation::types::UIProperty;
use uiautomation::variants::Variant;
use uiautomation::UIAutomation;
use uiautomation::UIElement;
use uiautomation::UITreeWalker;

use crate::gather_children::gather_children;
use crate::gather_children::GatherChildrenable;
use crate::gather_children::StopBehaviour;

pub(crate) fn resolve_calculator(
    elem: &UIElement,
    automation: &UIAutomation,
    focused: bool,
) -> Result<AppWindow, AppResolveError> {
    // let walker = automation.create_tree_walker()?;
    // let root = elem;

    // let temp = root.drill(&walker, vec![0, 0, 0, 0, 0, 1])?;

    // let body = temp.drill(&walker, vec![1, 0, 1])?;
    // let body = resolve_body(&body, &walker)?;

    Ok(AppWindow::Calculator(Calculator {
        memory: CalculatorMemory { buffer: 0.0 },
    }))
}

fn resolve_body(
    body: &UIElement,
    walker: &UITreeWalker,
) -> Result<VSCodeWindowBody, AppResolveError> {
    let state =
        VSCodeCrawlState::try_from(gather_children(walker, body, &StopBehaviour::EndOfSiblings))?;

    let side_nav = state
        .get_side_nav_tabs_root_elem()?
        .drill(walker, vec![0, 0])?
        .gather_children(walker, &StopBehaviour::LastChildEncountered);
    // println!("side_nav: {:?}", side_nav);
    let side_nav = side_nav
        .into_iter()
        .filter(|elem| elem.get_control_type() == Ok(ControlType::TabItem))
        .map(|elem| {
            let name = elem.get_name()?;
            let kind = SideTabKind::try_from(name)?;
            let active = elem
                .get_property_value(UIProperty::ExpandCollapseExpandCollapseState)
                .map(|v| v.try_into() == Ok(ExpandCollapseState::Expanded as i32))
                .unwrap_or_default();
            if active {
                let view = state
                    .get_side_nav_view_root_elem()?
                    .drill(walker, vec![1])?;
                let view = match view.get_automation_id() {
                    Ok(id)
                        if Some(id.as_str()) == SideTabKind::Explorer.get_view_automation_id() =>
                    {
                        fn as_explorer_item(
                            walker: &UITreeWalker,
                            tree_item: UIElement,
                        ) -> Result<ExplorerItem, AppResolveError> {
                            let label = tree_item.get_name()?;
                            let ui_position_in_set = tree_item
                                .get_property_value(UIProperty::PositionInSet)?
                                .try_into()?;
                            let ui_size_of_set = tree_item
                                .get_property_value(UIProperty::SizeOfSet)?
                                .try_into()?;
                            let ui_level = tree_item
                                .get_property_value(UIProperty::Level)?
                                .try_into()?;
                            let bounds = tree_item.get_bounding_rectangle()?.to_bevy_irect();
                            let kind = tree_item
                                .get_pattern::<UIExpandCollapsePattern>()
                                .ok()
                                .map(|p| ExplorerItemKind::Directory {
                                    expanded: p.get_state() == Ok(ExpandCollapseState::Expanded),
                                })
                                .unwrap_or(ExplorerItemKind::File);
                            let path = tree_item
                                .drill(
                                    walker,
                                    match kind {
                                        ExplorerItemKind::File => vec![0, 1, 0],
                                        ExplorerItemKind::Directory { .. } => {
                                            vec![0, 2, 0]
                                        }
                                    },
                                )?
                                .get_name()?;
                            Ok(ExplorerItem {
                                label,
                                path,
                                ui_position_in_set,
                                ui_size_of_set,
                                ui_level,
                                bounds,
                                kind,
                            })
                        }
                        let sticky = view
                            .drill(walker, vec![0, 1, 0, 0, 1, 0, 3])?
                            .gather_children(walker, &StopBehaviour::EndOfSiblings)
                            .into_iter()
                            .filter_map(|tree_item| as_explorer_item(walker, tree_item).ok())
                            .collect();
                        let items = view
                            .drill(walker, vec![0, 1, 0, 0, 1, 0, 0])?
                            .gather_children(walker, &StopBehaviour::EndOfSiblings)
                            .into_iter()
                            .filter_map(|tree_item| as_explorer_item(walker, tree_item).ok())
                            .collect();
                        View::Explorer { sticky, items }
                    }
                    _ => {
                        View::Unknown {}
                        // elem: view.into()
                    }
                };

                Ok(SideTab::Open {
                    kind,
                    // button: elem.into(),
                    view,
                })
            } else {
                Ok(SideTab::Closed {
                    kind,
                    // button: elem.into(),
                })
            }
        })
        .filter_map(|res: Result<SideTab, AppResolveError>| res.ok())
        .collect();

    let editor_area_elem = state
        .get_editor_root_elem()?
        .drill(walker, vec![0, 1, 0, 0])?;
    if editor_area_elem.get_automation_id()? != EditorArea::get_expected_automation_id() {
        return Err(AppResolveError::BadVSCodeStructure(format!(
            "Editor area has wrong automation id: {}",
            editor_area_elem.get_automation_id()?
        )));
    }
    let editor_groups = editor_area_elem
        .drill(walker, vec![0, 0, 0, 1])?
        .gather_children(walker, &StopBehaviour::EndOfSiblings)
        .into_iter()
        .map(|group_elem| {
            let group_tabs_holder = group_elem.drill(walker, vec![0, 0, 0])?;
            let selected: Option<String> = group_tabs_holder
                .get_property_value(UIProperty::SelectionSelection)?
                .try_into()
                .ok();
            let group_tabs = group_tabs_holder
                .gather_children(walker, &StopBehaviour::EndOfSiblings)
                .into_iter()
                .map(|group_tab_elem| {
                    let title = group_tab_elem.get_name()?;
                    let active = selected == Some(title.clone());
                    Ok(EditorTab { title, active })
                })
                .filter_map(|r: Result<EditorTab, AppResolveError>| r.ok())
                .collect();
            let content_elem = group_elem.drill(walker, vec![1, 0, 0, 1])?;
            let content = content_elem
                .get_property_value(UIProperty::LegacyIAccessibleValue)
                .map(|variant| variant.to_string())
                .map(|text_content| EditorContent {
                    content: text_content,
                })
                .ok();

            Ok(EditorGroup {
                tabs: group_tabs,
                content,
            })
        })
        .filter_map(|r: Result<EditorGroup, AppResolveError>| r.ok())
        .collect();
    let editor_area = EditorArea {
        groups: editor_groups,
    };

    Ok(VSCodeWindowBody {
        editor_area,
        side_nav,
    })
}

fn resolve_footer(
    footer: &UIElement,
    automation: &UIAutomation,
) -> Result<VSCodeWindowFooter, AppResolveError> {
    let condition = automation.create_property_condition(
        UIProperty::AutomationId,
        Variant::from("status.editor.selection"),
        None,
    )?;
    let cursor_position_elem = footer.find_first(TreeScope::Children, &condition)?;
    let text = cursor_position_elem.get_name()?;
    // "Ln 218, Col 5"
    let cursor_position = text
        .split(", ")
        .map(|part| part.split(' ').last().and_then(|s| s.parse::<usize>().ok()))
        .collect_vec();
    let cursor_position = match cursor_position.as_slice() {
        [Some(line), Some(column)] => IVec2::new(*column as i32, *line as i32),
        _ => {
            return Err(AppResolveError::BadVSCodeStructure(format!(
                "Bad cursor position {:?}",
                cursor_position
            )))
        }
    };
    Ok(VSCodeWindowFooter { cursor_position })
}

````



## D:\Repos\Games\Cursor-Hero\crates\ui_watcher_types\src\ui_watcher_types.rs

````rust
use std::fmt;
use std::fmt::Display;
use std::fmt::Formatter;
use uiautomation::controls::ControlType;
use uiautomation::UIElement;

pub enum AppUIElement {
    VSCode(UIElement),
    Unknown(UIElement),
}

impl From<UIElement> for AppUIElement {
    fn from(elem: UIElement) -> Self {
        let name = elem.get_name();
        let control_type = elem.get_control_type();
        let class_name = elem.get_classname();
        match (name, control_type, class_name) {
            (Ok(name), Ok(ControlType::Pane), Ok(class_name))
                if name.ends_with("Visual Studio Code") && class_name == "Chrome_WidgetWin_1" =>
            {
                AppUIElement::VSCode(elem)
            }
            _ => AppUIElement::Unknown(elem),
        }
    }
}

impl Display for AppUIElement {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        match self {
            AppUIElement::VSCode(elem) => {
                write!(f, "Visual Studio Code: {:?}", elem.get_name())
                // match get_tree_string(elem) {
                //     Ok(text) => write!(f, "Visual Studio Code: {}", text),
                //     Err(e) => write!(f, "Visual Studio Code: {:?}", e),
                // }
            }
            AppUIElement::Unknown(elem) => write!(f, "Unknown: {:?}", elem),
        }
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\calculator_app_types\src\calculator_app_types_plugin.rs

````rust
use crate::prelude::*;
use bevy::prelude::*;

pub struct CalculatorAppTypesPlugin;

impl Plugin for CalculatorAppTypesPlugin {
    fn build(&self, app: &mut App) {
        app.register_type::<AppWindow>();
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\winutils\src\win_mouse.rs

````rust
use bevy::prelude::*;
use windows::Win32::Foundation::POINT;
use windows::Win32::UI::Input::KeyboardAndMouse::SendInput;
use windows::Win32::UI::Input::KeyboardAndMouse::INPUT;
use windows::Win32::UI::Input::KeyboardAndMouse::INPUT_0;
use windows::Win32::UI::Input::KeyboardAndMouse::INPUT_MOUSE;
use windows::Win32::UI::Input::KeyboardAndMouse::INPUT_TYPE;
use windows::Win32::UI::Input::KeyboardAndMouse::KEYBDINPUT;
use windows::Win32::UI::Input::KeyboardAndMouse::KEYBD_EVENT_FLAGS;
use windows::Win32::UI::Input::KeyboardAndMouse::MOUSEEVENTF_LEFTDOWN;
use windows::Win32::UI::Input::KeyboardAndMouse::MOUSEEVENTF_LEFTUP;
use windows::Win32::UI::Input::KeyboardAndMouse::MOUSEEVENTF_RIGHTDOWN;
use windows::Win32::UI::Input::KeyboardAndMouse::MOUSEEVENTF_RIGHTUP;
use windows::Win32::UI::Input::KeyboardAndMouse::MOUSEEVENTF_WHEEL;
use windows::Win32::UI::Input::KeyboardAndMouse::MOUSEINPUT;
use windows::Win32::UI::Input::KeyboardAndMouse::VIRTUAL_KEY;
use windows::Win32::UI::WindowsAndMessaging::GetCursorPos;
use windows::Win32::UI::WindowsAndMessaging::SetCursorPos;
use windows::Win32::UI::WindowsAndMessaging::WHEEL_DELTA;

pub fn get_cursor_position() -> Result<IVec2, windows::core::Error> {
    unsafe {
        let mut point = POINT::default();
        GetCursorPos(&mut point)?;
        Ok(IVec2::new(point.x, point.y))
    }
}

pub fn set_cursor_position(position: IVec2) -> Result<(), windows::core::Error> {
    unsafe {
        SetCursorPos(position.x, position.y)?;
        Ok(())
    }
}

pub fn left_mouse_down() -> Result<(), windows::core::Error> {
    // Prepare a mouse input for left button down
    let mouse_input = MOUSEINPUT {
        dx: 0,
        dy: 0,
        mouseData: 0,
        dwFlags: MOUSEEVENTF_LEFTDOWN,
        time: 0,
        dwExtraInfo: 0,
    };

    // Prepare an INPUT structure for the down event
    let input = INPUT {
        r#type: INPUT_MOUSE,
        Anonymous: INPUT_0 { mi: mouse_input },
    };

    // Send the input for button down
    unsafe { SendInput(&[input], std::mem::size_of::<INPUT>() as i32) };

    Ok(())
}

pub fn left_mouse_up() -> Result<(), windows::core::Error> {
    // Prepare a mouse input for left button up
    let mouse_input = MOUSEINPUT {
        dx: 0,
        dy: 0,
        mouseData: 0,
        dwFlags: MOUSEEVENTF_LEFTUP,
        time: 0,
        dwExtraInfo: 0,
    };

    // Prepare an INPUT structure for the up event
    let input = INPUT {
        r#type: INPUT_MOUSE,
        Anonymous: INPUT_0 { mi: mouse_input },
    };

    // Send the input for button up
    unsafe { SendInput(&[input], std::mem::size_of::<INPUT>() as i32) };

    Ok(())
}

#[allow(dead_code)]
pub fn left_click() -> Result<(), windows::core::Error> {
    left_mouse_down()?;
    left_mouse_up()?;
    Ok(())
}

pub fn right_mouse_down() -> Result<(), windows::core::Error> {
    // Prepare a mouse input for right button down
    let mouse_input = MOUSEINPUT {
        dx: 0,
        dy: 0,
        mouseData: 0,
        dwFlags: MOUSEEVENTF_RIGHTDOWN,
        time: 0,
        dwExtraInfo: 0,
    };

    // Prepare an INPUT structure for the down event
    let input = INPUT {
        r#type: INPUT_MOUSE,
        Anonymous: INPUT_0 { mi: mouse_input },
    };

    // Send the input for button down
    unsafe { SendInput(&[input], std::mem::size_of::<INPUT>() as i32) };

    Ok(())
}

pub fn right_mouse_up() -> Result<(), windows::core::Error> {
    // Prepare a mouse input for right button up
    let mouse_input = MOUSEINPUT {
        dx: 0,
        dy: 0,
        mouseData: 0,
        dwFlags: MOUSEEVENTF_RIGHTUP,
        time: 0,
        dwExtraInfo: 0,
    };

    // Prepare an INPUT structure for the up event
    let input = INPUT {
        r#type: INPUT_MOUSE,
        Anonymous: INPUT_0 { mi: mouse_input },
    };

    // Send the input for button up
    unsafe { SendInput(&[input], std::mem::size_of::<INPUT>() as i32) };

    Ok(())
}

// Constants
const INPUT_KEYBOARD: u32 = 1;
const VK_F23: u16 = 0x86;
const KEYEVENTF_KEYUP: u32 = 0x0002;

pub fn press_f23_key() -> Result<(), windows::core::Error> {
    let keyboard_input = KEYBDINPUT {
        wVk: VIRTUAL_KEY(VK_F23),
        wScan: 0,
        dwFlags: KEYBD_EVENT_FLAGS(0),
        time: 0,
        dwExtraInfo: 0,
    };

    let input = INPUT {
        r#type: INPUT_TYPE(INPUT_KEYBOARD),
        Anonymous: INPUT_0 { ki: keyboard_input },
    };

    unsafe { SendInput(&[input], std::mem::size_of::<INPUT>() as i32) };

    Ok(())
}

pub fn release_f23_key() -> Result<(), windows::core::Error> {
    let keyboard_input = KEYBDINPUT {
        wVk: VIRTUAL_KEY(VK_F23),
        wScan: 0,
        dwFlags: KEYBD_EVENT_FLAGS(KEYEVENTF_KEYUP),
        time: 0,
        dwExtraInfo: 0,
    };

    let input = INPUT {
        r#type: INPUT_TYPE(INPUT_KEYBOARD),
        Anonymous: INPUT_0 { ki: keyboard_input },
    };

    unsafe { SendInput(&[input], std::mem::size_of::<INPUT>() as i32) };

    Ok(())
}

pub fn scroll_wheel(scale: f32) -> Result<(), windows::core::Error> {
    let mouse_input = MOUSEINPUT {
        dx: 0,
        dy: 0,
        mouseData: (WHEEL_DELTA as f32 * scale) as i32 as u32, // https://github.com/microsoft/windows-rs/issues/2708
        dwFlags: MOUSEEVENTF_WHEEL,
        time: 0,
        dwExtraInfo: 0,
    };

    let input = INPUT {
        r#type: INPUT_MOUSE,
        Anonymous: INPUT_0 { mi: mouse_input },
    };

    unsafe { SendInput(&[input], std::mem::size_of::<INPUT>() as i32) };

    Ok(())
}

````



## D:\Repos\Games\Cursor-Hero\crates\winutils\src\win_colors.rs

````rust
use bevy::render::color::Color;
use std::error::Error;
use winreg::enums::*;
use winreg::RegKey;

pub fn get_accent_color() -> Result<Color, Box<dyn Error>> {
    let hklm = RegKey::predef(HKEY_CURRENT_USER);
    let personalization =
        hklm.open_subkey("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Accent")?;
    let accent_color: u32 = personalization.get_value("AccentColorMenu")?;
    Ok(abgr_to_rgba(accent_color))
}

pub fn get_start_color() -> Result<Color, Box<dyn Error>> {
    let hklm = RegKey::predef(HKEY_CURRENT_USER);
    let personalization =
        hklm.open_subkey("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Accent")?;
    let accent_color: u32 = personalization.get_value("StartColorMenu")?;
    Ok(abgr_to_rgba(accent_color))
}

fn abgr_to_rgba(abgr: u32) -> Color {
    let a = ((abgr >> 24) & 0xff) as u8;
    let b = ((abgr >> 16) & 0xff) as u8;
    let g = ((abgr >> 8) & 0xff) as u8;
    let r = (abgr & 0xff) as u8;

    Color::rgba_u8(r, g, b, a)
}

#[cfg(test)]
mod tests {
    #[test]
    fn test_get_accent_color() {
        match super::get_accent_color() {
            Ok(color) => println!("Accent color: {:?}", color),
            Err(e) => panic!("Error reading accent color: {}", e),
        }
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\winutils\src\win_events.rs

````rust
use bevy::math::IRect;
use bevy::math::IVec2;
use bevy::prelude::default;
use crossbeam_channel::Receiver;
use crossbeam_channel::Sender;
use once_cell::sync::Lazy;
use std::collections::HashMap;
use std::sync::Mutex;
use windows::core::PCWSTR;
use windows::Win32::Devices::HumanInterfaceDevice::HID_USAGE_GENERIC_KEYBOARD;
use windows::Win32::Devices::HumanInterfaceDevice::HID_USAGE_GENERIC_MOUSE;
use windows::Win32::Devices::HumanInterfaceDevice::HID_USAGE_PAGE_GENERIC;
use windows::Win32::Foundation::HWND;
use windows::Win32::Foundation::*;
use windows::Win32::System::Variant::VARIANT;
use windows::Win32::System::Variant::VT_I4;
use windows::Win32::UI::Accessibility::*;
use windows::Win32::UI::Input::GetRawInputData;
use windows::Win32::UI::Input::RegisterRawInputDevices;
use windows::Win32::UI::Input::HRAWINPUT;
use windows::Win32::UI::Input::RAWINPUT;
use windows::Win32::UI::Input::RAWINPUTDEVICE;
use windows::Win32::UI::Input::RAWINPUTHEADER;
use windows::Win32::UI::Input::RIDEV_INPUTSINK;
use windows::Win32::UI::Input::RID_INPUT;
use windows::Win32::UI::Input::RIM_TYPEKEYBOARD;
use windows::Win32::UI::Input::RIM_TYPEMOUSE;
use windows::Win32::UI::WindowsAndMessaging::EVENT_OBJECT_CREATE;
use windows::Win32::UI::WindowsAndMessaging::EVENT_OBJECT_DESTROY;
use windows::Win32::UI::WindowsAndMessaging::EVENT_OBJECT_HIDE;
use windows::Win32::UI::WindowsAndMessaging::EVENT_OBJECT_LIVEREGIONCHANGED;
use windows::Win32::UI::WindowsAndMessaging::EVENT_OBJECT_STATECHANGE;
use windows::Win32::UI::WindowsAndMessaging::EVENT_OBJECT_VALUECHANGE;
use windows::Win32::UI::WindowsAndMessaging::*;

#[derive(Debug)]
pub enum ProcMessage {
    MouseMoved(IVec2),
    KeyDown(char),
    Event {
        event_name: String,
        name: Option<String>,
        role: Option<String>,
        state: Option<String>,
        bounds: Option<IRect>,
    },
}

static SENDERS: Lazy<Mutex<HashMap<isize, Sender<ProcMessage>>>> =
    Lazy::new(|| Mutex::new(HashMap::new()));
static HWND_TO_HOOK: Lazy<Mutex<HashMap<isize, isize>>> = Lazy::new(|| Mutex::new(HashMap::new()));
fn store_sender_for_identifier(
    identifier: isize,
    sender: Sender<ProcMessage>,
) -> Result<(), &'static str> {
    let mut senders = SENDERS.lock().map_err(|_| "Failed to lock SENDERS map")?;
    senders.insert(identifier, sender);
    Ok(())
}
fn get_sender_for_window(hwnd: HWND) -> Option<Sender<ProcMessage>> {
    let senders = SENDERS.lock().ok()?;
    senders.get(&hwnd.0).cloned()
}
fn get_sender_for_hook(hook: HWINEVENTHOOK) -> Option<Sender<ProcMessage>> {
    let senders = SENDERS.lock().ok()?;
    senders.get(&hook.0).cloned()
}
fn store_sender(
    hwnd: HWND,
    hook: HWINEVENTHOOK,
    sender: Sender<ProcMessage>,
) -> Result<(), &'static str> {
    store_sender_for_identifier(hwnd.0, sender.clone())?;
    store_sender_for_identifier(hook.0, sender)?;
    Ok(())
}
fn drop_senders_for_window(hwnd: HWND) -> Result<(), &'static str> {
    let mut senders = SENDERS.lock().map_err(|_| "Failed to lock SENDERS map")?;

    // Remove the sender for the window
    senders.remove(&hwnd.0);

    // Get the hook for the window
    let mut hook_map = HWND_TO_HOOK
        .lock()
        .map_err(|_| "Failed to lock HWND_TO_HOOK map")?;
    if let Some(hook) = hook_map.remove(&hwnd.0) {
        // Drop the sender for the hook
        senders.remove(&hook);
    }

    Ok(())
}

pub fn create_os_event_listener() -> Result<Receiver<ProcMessage>, windows::core::Error> {
    let (tx, rx) = crossbeam_channel::unbounded();
    std::thread::spawn(move || match create_window_and_do_message_loop(tx) {
        Ok(()) => {
            unreachable!("create_window_and_do_message_loop should never return Ok");
        }
        Err(e) => {
            eprintln!("Error in os_event_listener_thread: {:?}", e);
        }
    });
    Ok(rx)
}

fn create_window_and_do_message_loop(tx: Sender<ProcMessage>) -> Result<(), windows::core::Error> {
    let hwnd = init_window()?;
    // attach_tx_pointer(hwnd, tx.clone());
    let hook = register_os_event_listener()?;
    store_sender(hwnd, hook, tx).map_err(|e| windows::core::Error::new(E_FAIL, e.into()))?;

    register_interest_in_mouse_with_os(hwnd.0)?;
    register_interest_in_keyboard_with_os(hwnd.0)?;
    unsafe {
        let mut message = MSG::default();
        println!("Starting message loop");
        while GetMessageA(&mut message, hwnd, 0, 0).as_bool() {
            TranslateMessage(&message);
            DispatchMessageA(&message);
            // println!("ballin, got {:?}", message);
        }
        DestroyWindow(hwnd)?;
    }
    Ok(())
}

fn register_os_event_listener() -> Result<HWINEVENTHOOK, windows::core::Error> {
    unsafe {
        match SetWinEventHook(
            EVENT_MIN, // or specific event codes
            EVENT_MAX, // or specific event codes
            None,      // hmodWinEventProc
            Some(os_event_procedure),
            0, // idProcess
            0, // idThread
            WINEVENT_OUTOFCONTEXT,
        ) {
            HWINEVENTHOOK(0) => Err(windows::core::Error::new(
                E_FAIL,
                "Failed to register interest in all events".into(),
            )),
            x => Ok(x),
        }
    }
}

fn register_interest_in_mouse_with_os(hwnd: isize) -> Result<(), windows::core::Error> {
    unsafe {
        let device = RAWINPUTDEVICE {
            usUsagePage: HID_USAGE_PAGE_GENERIC,
            usUsage: HID_USAGE_GENERIC_MOUSE,
            dwFlags: RIDEV_INPUTSINK,
            hwndTarget: HWND(hwnd),
        };
        RegisterRawInputDevices(&[device], std::mem::size_of::<RAWINPUTDEVICE>() as u32)
    }
}

fn register_interest_in_keyboard_with_os(hwnd: isize) -> Result<(), windows::core::Error> {
    unsafe {
        let device = RAWINPUTDEVICE {
            usUsagePage: HID_USAGE_PAGE_GENERIC,
            usUsage: HID_USAGE_GENERIC_KEYBOARD,
            dwFlags: RIDEV_INPUTSINK,
            hwndTarget: HWND(hwnd),
        };
        RegisterRawInputDevices(&[device], std::mem::size_of::<RAWINPUTDEVICE>() as u32)
    }
}

fn init_window() -> Result<HWND, windows::core::Error> {
    let class_name =
        widestring::U16CString::from_str("bruh").map_err(|_| windows::core::Error::OK)?;
    let class_name_ptr = class_name.as_ptr();
    let class_name_pcwstr = PCWSTR(class_name_ptr);

    let hinstance = unsafe { windows::Win32::System::LibraryLoader::GetModuleHandleW(None)? };

    let wnd = WNDCLASSEXW {
        cbSize: std::mem::size_of::<WNDCLASSEXW>() as u32,
        lpfnWndProc: Some(window_message_procedure),
        hInstance: hinstance.into(),
        lpszClassName: class_name_pcwstr,
        ..default()
    };

    let _reg = unsafe { RegisterClassExW(&wnd) };

    let window = unsafe {
        CreateWindowExW(
            WINDOW_EX_STYLE::default(),
            class_name_pcwstr,
            None,
            WINDOW_STYLE(0),
            CW_USEDEFAULT,
            CW_USEDEFAULT,
            CW_USEDEFAULT,
            CW_USEDEFAULT,
            None,
            None,
            hinstance,
            None,
        )
    };

    unsafe { GetLastError()? };
    if window.0 == 0 {
        return Err(windows::core::Error::from_win32());
    }

    Ok(window)
}

unsafe extern "system" fn window_message_procedure(
    hwnd: HWND,
    msg: u32,
    w_param: WPARAM,
    l_param: LPARAM,
) -> LRESULT {
    let next = || DefWindowProcW(hwnd, msg, w_param, l_param);

    // let tx = match get_tx_pointer(hwnd) {
    //     Some(tx) => tx,
    //     None => return next(),
    // };

    let tx = match get_sender_for_window(hwnd) {
        Some(tx) => tx,
        None => return next(),
    };

    match msg {
        WM_INPUT => {
            let mut size = 0;
            let result = GetRawInputData(
                HRAWINPUT(l_param.0),
                RID_INPUT,
                None, // Pointer to data is null, requesting size only
                &mut size,
                std::mem::size_of::<RAWINPUTHEADER>() as u32,
            );
            assert_eq!(result as i32, 0);

            let mut data = vec![0u8; size as usize];
            let recv_size = GetRawInputData(
                HRAWINPUT(l_param.0),
                RID_INPUT,
                Some(data.as_mut_ptr() as *mut std::ffi::c_void),
                &mut size,
                std::mem::size_of::<RAWINPUTHEADER>() as u32,
            );
            assert_eq!(recv_size as i32, size as i32);
            let input = &*(data.as_ptr() as *const RAWINPUT);

            if input.header.dwType == RIM_TYPEKEYBOARD.0
                && input.data.keyboard.Message == WM_KEYDOWN
            {
                let key = input.data.keyboard.VKey as u8 as char;
                if let Err(e) = tx.send(ProcMessage::KeyDown(key)) {
                    eprintln!("Error sending keyboard message: {:?}", e);
                    return LRESULT(0);
                }
            }

            if input.header.dwType == RIM_TYPEMOUSE.0 {
                let mouse_data = input.data.mouse;
                let x = mouse_data.lLastX;
                let y = mouse_data.lLastY;
                if let Err(e) = tx.send(ProcMessage::MouseMoved(IVec2::new(x, y))) {
                    eprintln!("Error sending mouse message: {:?}", e);
                    return LRESULT(0);
                }
            }

            LRESULT(0)
        }
        WM_DESTROY => {
            // detach_tx_pointer_and_drop(hwnd);
            drop_senders_for_window(hwnd).unwrap();
            PostQuitMessage(0);
            LRESULT(0)
        }
        _ => next(),
    }
}

unsafe extern "system" fn os_event_procedure(
    hook: HWINEVENTHOOK,
    event: u32,
    hwnd: HWND,
    object_id: i32,
    child_id: i32,
    _id_event_thread: u32,
    _dwms_event_time: u32,
) {
    if event < 1000
        || event == EVENT_OBJECT_SHOW
        || event == EVENT_OBJECT_LOCATIONCHANGE
        || event == EVENT_OBJECT_NAMECHANGE
        || event == EVENT_OBJECT_REORDER
        || event == EVENT_OBJECT_VALUECHANGE
        || event == EVENT_OBJECT_CREATE
        || event == EVENT_OBJECT_DESTROY
        || event == EVENT_OBJECT_HIDE
        || event == EVENT_OBJECT_LIVEREGIONCHANGED
    {
        return;
    }
    // if event < 1000 {
    //     return;
    // }

    let event_name = event_to_name(event).to_string();
    // println!(
    //     "Hook: {:?}, Event: {:?} ({}), HWND: {:?}, idObject: {:?}, idChild: {:?}",
    //     hook,
    //     event,
    //     event_name,
    //     hwnd,
    //     object_id,
    //     child_id
    // );

    // println!("Attempting getting tx from window hwnd: {:?}", hwnd);
    let tx = match get_sender_for_hook(hook) {
        Some(tx) => {
            // println!("Got tx from hook {:?}", hook);
            tx
        }
        None => {
            eprintln!("No tx found for hook {:?}", hook);
            return;
        }
    };

    if object_id != OBJID_CLIENT.0 {
        return;
    }
    // println!("happy path");
    // if (event == EVENT_OBJECT_SELECTIONADD || event == EVENT_OBJECT_STATECHANGE)
    //     && object_id == OBJID_CLIENT.0 {}
    // Here you get the name and state of the element that triggered the event.
    // Implement the logic to retrieve the name and state using the AccessibleObjectFromEvent function.
    let mut acc_ptr: Option<IAccessible> = None;
    let mut elem = VARIANT::default();

    // println!("Getting accessible object");
    let lookup = AccessibleObjectFromEvent(
        hwnd,
        object_id as u32,
        child_id as u32,
        &mut acc_ptr,
        &mut elem,
    );
    if lookup.is_err() {
        // eprintln!("Error getting accessible object: {:?}", lookup);
        return;
    }
    let acc = match acc_ptr {
        Some(acc) => acc,
        None => {
            // eprintln!("Error getting accessible object");
            return;
        }
    };

    // println!("Getting name");
    let name = acc.get_accName(elem.clone()).map(|x| x.to_string()).ok();

    // println!("Getting role");
    let role = acc
        .get_accRole(elem.clone())
        .and_then(|variant| variant_to_int(&variant))
        .map(|i| role_to_name(i as u32).to_string())
        .ok();

    // println!("Getting state");
    let state = acc
        .get_accState(elem.clone())
        .and_then(|variant| variant_to_int(&variant))
        .map(|i| state_to_string(i as u32))
        .ok();

    let mut pxleft = 0;
    let mut pytop = 0;
    let mut pcxwidth = 0;
    let mut pcyheight = 0;

    // println!("Getting location");
    let bounds = match acc.accLocation(&mut pxleft, &mut pytop, &mut pcxwidth, &mut pcyheight, elem)
    {
        Ok(()) => Some(IRect::from_corners(
            IVec2::new(pxleft, pytop),
            IVec2::new(pxleft + pcxwidth, pytop + pcyheight),
        )),
        Err(_) => None,
    };

    // println!("Building msg");
    let msg = ProcMessage::Event {
        event_name,
        name,
        role,
        state,
        bounds,
    };

    // println!("Sending event message {:?}", msg);
    if let Err(e) = tx.send(msg) {
        eprintln!("Error sending event message: {:?}", e);
    } else {
        // println!("Sent event message :D");
    }
}

fn variant_to_int(variant: &VARIANT) -> Result<i32, windows::core::Error> {
    let var_type = unsafe { variant.Anonymous.Anonymous.vt };

    match var_type {
        VT_I4 => {
            // Extract 32-bit integer
            Ok(unsafe { variant.Anonymous.Anonymous.Anonymous.lVal })
        }
        _ => Err(windows::core::Error::new(
            windows::Win32::Foundation::E_FAIL,
            "Unsupported VARIANT type".into(),
        )),
    }
}

// fn decimal_to_string(decimal: DECIMAL) -> Result<String, windows::core::Error> {
//     unsafe { VarBstrFromDec(&decimal, 0, 0).map(|bstr| bstr.to_string()) }
// }

// fn variant_to_string(variant: &VARIANT) -> Result<String, windows::core::Error> {
//     let var_type = unsafe { variant.Anonymous.Anonymous.vt };

//     match var_type {
//         VT_BSTR => {
//             // Extract BSTR and convert to String
//             let bstr = unsafe { &variant.Anonymous.Anonymous.Anonymous.bstrVal };
//             Ok(bstr.to_string())
//         }
//         VT_I4 => {
//             // Extract 32-bit integer and convert to String
//             let int_val = unsafe { variant.Anonymous.Anonymous.Anonymous.lVal };
//             Ok(int_val.to_string())
//         }
//         // Add more cases as needed for other VARTYPEs you expect to handle
//         _ => Err(windows::core::Error::new(
//             windows::Win32::Foundation::E_FAIL,
//             "Unsupported VARIANT type".into(),
//         )),
//     }
// }

fn state_to_string(state: u32) -> String {
    let mut states = Vec::new();
    if state & STATE_SYSTEM_ALERT_HIGH != 0 {
        states.push("STATE_SYSTEM_ALERT_HIGH")
    }
    if state & STATE_SYSTEM_ALERT_LOW != 0 {
        states.push("STATE_SYSTEM_ALERT_LOW")
    }
    if state & STATE_SYSTEM_ALERT_MEDIUM != 0 {
        states.push("STATE_SYSTEM_ALERT_MEDIUM")
    }
    if state & STATE_SYSTEM_ANIMATED != 0 {
        states.push("STATE_SYSTEM_ANIMATED")
    }
    if state & STATE_SYSTEM_BUSY != 0 {
        states.push("STATE_SYSTEM_BUSY")
    }
    if state & STATE_SYSTEM_CHECKED != 0 {
        states.push("STATE_SYSTEM_CHECKED")
    }
    if state & STATE_SYSTEM_COLLAPSED != 0 {
        states.push("STATE_SYSTEM_COLLAPSED")
    }
    if state & STATE_SYSTEM_DEFAULT != 0 {
        states.push("STATE_SYSTEM_DEFAULT")
    }
    if state & STATE_SYSTEM_EXPANDED != 0 {
        states.push("STATE_SYSTEM_EXPANDED")
    }
    if state & STATE_SYSTEM_EXTSELECTABLE != 0 {
        states.push("STATE_SYSTEM_EXTSELECTABLE")
    }
    if state & STATE_SYSTEM_FLOATING != 0 {
        states.push("STATE_SYSTEM_FLOATING")
    }
    if state & STATE_SYSTEM_FOCUSED != 0 {
        states.push("STATE_SYSTEM_FOCUSED")
    }
    if state & STATE_SYSTEM_HOTTRACKED != 0 {
        states.push("STATE_SYSTEM_HOTTRACKED")
    }
    if state & STATE_SYSTEM_INDETERMINATE != 0 {
        states.push("STATE_SYSTEM_INDETERMINATE")
    }
    if state & STATE_SYSTEM_LINKED != 0 {
        states.push("STATE_SYSTEM_LINKED")
    }
    if state & STATE_SYSTEM_MARQUEED != 0 {
        states.push("STATE_SYSTEM_MARQUEED")
    }
    if state & STATE_SYSTEM_MIXED != 0 {
        states.push("STATE_SYSTEM_MIXED")
    }
    if state & STATE_SYSTEM_MOVEABLE != 0 {
        states.push("STATE_SYSTEM_MOVEABLE")
    }
    if state & STATE_SYSTEM_MULTISELECTABLE != 0 {
        states.push("STATE_SYSTEM_MULTISELECTABLE")
    }
    if state & STATE_SYSTEM_PROTECTED != 0 {
        states.push("STATE_SYSTEM_PROTECTED")
    }
    if state & STATE_SYSTEM_READONLY != 0 {
        states.push("STATE_SYSTEM_READONLY")
    }
    if state & STATE_SYSTEM_SELECTABLE != 0 {
        states.push("STATE_SYSTEM_SELECTABLE")
    }
    if state & STATE_SYSTEM_SELECTED != 0 {
        states.push("STATE_SYSTEM_SELECTED")
    }
    if state & STATE_SYSTEM_SELFVOICING != 0 {
        states.push("STATE_SYSTEM_SELFVOICING")
    }
    if state & STATE_SYSTEM_SIZEABLE != 0 {
        states.push("STATE_SYSTEM_SIZEABLE")
    }
    if state & STATE_SYSTEM_TRAVERSED != 0 {
        states.push("STATE_SYSTEM_TRAVERSED")
    }
    if state & STATE_SYSTEM_VALID != 0 {
        states.push("STATE_SYSTEM_VALID")
    }
    states.join(",")
}

pub fn role_to_name(role: u32) -> &'static str {
    match role {
        ROLE_SYSTEM_ALERT => "ROLE_SYSTEM_ALERT",
        ROLE_SYSTEM_ANIMATION => "ROLE_SYSTEM_ANIMATION",
        ROLE_SYSTEM_APPLICATION => "ROLE_SYSTEM_APPLICATION",
        ROLE_SYSTEM_BORDER => "ROLE_SYSTEM_BORDER",
        ROLE_SYSTEM_BUTTONDROPDOWN => "ROLE_SYSTEM_BUTTONDROPDOWN",
        ROLE_SYSTEM_BUTTONDROPDOWNGRID => "ROLE_SYSTEM_BUTTONDROPDOWNGRID",
        ROLE_SYSTEM_BUTTONMENU => "ROLE_SYSTEM_BUTTONMENU",
        ROLE_SYSTEM_CARET => "ROLE_SYSTEM_CARET",
        ROLE_SYSTEM_CELL => "ROLE_SYSTEM_CELL",
        ROLE_SYSTEM_CHARACTER => "ROLE_SYSTEM_CHARACTER",
        ROLE_SYSTEM_CHART => "ROLE_SYSTEM_CHART",
        ROLE_SYSTEM_CHECKBUTTON => "ROLE_SYSTEM_CHECKBUTTON",
        ROLE_SYSTEM_CLIENT => "ROLE_SYSTEM_CLIENT",
        ROLE_SYSTEM_CLOCK => "ROLE_SYSTEM_CLOCK",
        ROLE_SYSTEM_COLUMN => "ROLE_SYSTEM_COLUMN",
        ROLE_SYSTEM_COLUMNHEADER => "ROLE_SYSTEM_COLUMNHEADER",
        ROLE_SYSTEM_COMBOBOX => "ROLE_SYSTEM_COMBOBOX",
        ROLE_SYSTEM_CURSOR => "ROLE_SYSTEM_CURSOR",
        ROLE_SYSTEM_DIAGRAM => "ROLE_SYSTEM_DIAGRAM",
        ROLE_SYSTEM_DIAL => "ROLE_SYSTEM_DIAL",
        ROLE_SYSTEM_DIALOG => "ROLE_SYSTEM_DIALOG",
        ROLE_SYSTEM_DOCUMENT => "ROLE_SYSTEM_DOCUMENT",
        ROLE_SYSTEM_DROPLIST => "ROLE_SYSTEM_DROPLIST",
        ROLE_SYSTEM_EQUATION => "ROLE_SYSTEM_EQUATION",
        ROLE_SYSTEM_GRAPHIC => "ROLE_SYSTEM_GRAPHIC",
        ROLE_SYSTEM_GRIP => "ROLE_SYSTEM_GRIP",
        ROLE_SYSTEM_GROUPING => "ROLE_SYSTEM_GROUPING",
        ROLE_SYSTEM_HELPBALLOON => "ROLE_SYSTEM_HELPBALLOON",
        ROLE_SYSTEM_HOTKEYFIELD => "ROLE_SYSTEM_HOTKEYFIELD",
        ROLE_SYSTEM_INDICATOR => "ROLE_SYSTEM_INDICATOR",
        ROLE_SYSTEM_IPADDRESS => "ROLE_SYSTEM_IPADDRESS",
        ROLE_SYSTEM_LINK => "ROLE_SYSTEM_LINK",
        ROLE_SYSTEM_LIST => "ROLE_SYSTEM_LIST",
        ROLE_SYSTEM_LISTITEM => "ROLE_SYSTEM_LISTITEM",
        ROLE_SYSTEM_MENUBAR => "ROLE_SYSTEM_MENUBAR",
        ROLE_SYSTEM_MENUITEM => "ROLE_SYSTEM_MENUITEM",
        ROLE_SYSTEM_MENUPOPUP => "ROLE_SYSTEM_MENUPOPUP",
        ROLE_SYSTEM_OUTLINE => "ROLE_SYSTEM_OUTLINE",
        ROLE_SYSTEM_OUTLINEBUTTON => "ROLE_SYSTEM_OUTLINEBUTTON",
        ROLE_SYSTEM_OUTLINEITEM => "ROLE_SYSTEM_OUTLINEITEM",
        ROLE_SYSTEM_PAGETAB => "ROLE_SYSTEM_PAGETAB",
        ROLE_SYSTEM_PAGETABLIST => "ROLE_SYSTEM_PAGETABLIST",
        ROLE_SYSTEM_PANE => "ROLE_SYSTEM_PANE",
        ROLE_SYSTEM_PROGRESSBAR => "ROLE_SYSTEM_PROGRESSBAR",
        ROLE_SYSTEM_PROPERTYPAGE => "ROLE_SYSTEM_PROPERTYPAGE",
        ROLE_SYSTEM_PUSHBUTTON => "ROLE_SYSTEM_PUSHBUTTON",
        ROLE_SYSTEM_RADIOBUTTON => "ROLE_SYSTEM_RADIOBUTTON",
        ROLE_SYSTEM_ROW => "ROLE_SYSTEM_ROW",
        ROLE_SYSTEM_ROWHEADER => "ROLE_SYSTEM_ROWHEADER",
        ROLE_SYSTEM_SCROLLBAR => "ROLE_SYSTEM_SCROLLBAR",
        ROLE_SYSTEM_SEPARATOR => "ROLE_SYSTEM_SEPARATOR",
        ROLE_SYSTEM_SLIDER => "ROLE_SYSTEM_SLIDER",
        ROLE_SYSTEM_SOUND => "ROLE_SYSTEM_SOUND",
        ROLE_SYSTEM_SPINBUTTON => "ROLE_SYSTEM_SPINBUTTON",
        ROLE_SYSTEM_SPLITBUTTON => "ROLE_SYSTEM_SPLITBUTTON",
        ROLE_SYSTEM_STATICTEXT => "ROLE_SYSTEM_STATICTEXT",
        ROLE_SYSTEM_STATUSBAR => "ROLE_SYSTEM_STATUSBAR",
        ROLE_SYSTEM_TABLE => "ROLE_SYSTEM_TABLE",
        ROLE_SYSTEM_TEXT => "ROLE_SYSTEM_TEXT",
        ROLE_SYSTEM_TITLEBAR => "ROLE_SYSTEM_TITLEBAR",
        ROLE_SYSTEM_TOOLBAR => "ROLE_SYSTEM_TOOLBAR",
        ROLE_SYSTEM_TOOLTIP => "ROLE_SYSTEM_TOOLTIP",
        ROLE_SYSTEM_WHITESPACE => "ROLE_SYSTEM_WHITESPACE",
        ROLE_SYSTEM_WINDOW => "ROLE_SYSTEM_WINDOW",
        _ => "<Unknown>",
    }
}

pub fn event_to_name(event: u32) -> &'static str {
    match event {
        EVENT_AIA_END => "EVENT_AIA_END",
        EVENT_AIA_START => "EVENT_AIA_START",
        EVENT_CONSOLE_CARET => "EVENT_CONSOLE_CARET",
        EVENT_CONSOLE_END => "EVENT_CONSOLE_END",
        EVENT_CONSOLE_END_APPLICATION => "EVENT_CONSOLE_END_APPLICATION",
        EVENT_CONSOLE_LAYOUT => "EVENT_CONSOLE_LAYOUT",
        EVENT_CONSOLE_START_APPLICATION => "EVENT_CONSOLE_START_APPLICATION",
        EVENT_CONSOLE_UPDATE_REGION => "EVENT_CONSOLE_UPDATE_REGION",
        EVENT_CONSOLE_UPDATE_SCROLL => "EVENT_CONSOLE_UPDATE_SCROLL",
        EVENT_CONSOLE_UPDATE_SIMPLE => "EVENT_CONSOLE_UPDATE_SIMPLE",
        EVENT_OBJECT_ACCELERATORCHANGE => "EVENT_OBJECT_ACCELERATORCHANGE",
        EVENT_OBJECT_CLOAKED => "EVENT_OBJECT_CLOAKED",
        EVENT_OBJECT_CONTENTSCROLLED => "EVENT_OBJECT_CONTENTSCROLLED",
        EVENT_OBJECT_CREATE => "EVENT_OBJECT_CREATE",
        EVENT_OBJECT_DEFACTIONCHANGE => "EVENT_OBJECT_DEFACTIONCHANGE",
        EVENT_OBJECT_DESCRIPTIONCHANGE => "EVENT_OBJECT_DESCRIPTIONCHANGE",
        EVENT_OBJECT_DESTROY => "EVENT_OBJECT_DESTROY",
        EVENT_OBJECT_DRAGCANCEL => "EVENT_OBJECT_DRAGCANCEL",
        EVENT_OBJECT_DRAGCOMPLETE => "EVENT_OBJECT_DRAGCOMPLETE",
        EVENT_OBJECT_DRAGDROPPED => "EVENT_OBJECT_DRAGDROPPED",
        EVENT_OBJECT_DRAGENTER => "EVENT_OBJECT_DRAGENTER",
        EVENT_OBJECT_DRAGLEAVE => "EVENT_OBJECT_DRAGLEAVE",
        EVENT_OBJECT_DRAGSTART => "EVENT_OBJECT_DRAGSTART",
        EVENT_OBJECT_END => "EVENT_OBJECT_END",
        EVENT_OBJECT_FOCUS => "EVENT_OBJECT_FOCUS",
        EVENT_OBJECT_HELPCHANGE => "EVENT_OBJECT_HELPCHANGE",
        EVENT_OBJECT_HIDE => "EVENT_OBJECT_HIDE",
        EVENT_OBJECT_HOSTEDOBJECTSINVALIDATED => "EVENT_OBJECT_HOSTEDOBJECTSINVALIDATED",
        EVENT_OBJECT_IME_CHANGE => "EVENT_OBJECT_IME_CHANGE",
        EVENT_OBJECT_IME_HIDE => "EVENT_OBJECT_IME_HIDE",
        EVENT_OBJECT_IME_SHOW => "EVENT_OBJECT_IME_SHOW",
        EVENT_OBJECT_INVOKED => "EVENT_OBJECT_INVOKED",
        EVENT_OBJECT_LIVEREGIONCHANGED => "EVENT_OBJECT_LIVEREGIONCHANGED",
        EVENT_OBJECT_LOCATIONCHANGE => "EVENT_OBJECT_LOCATIONCHANGE",
        EVENT_OBJECT_NAMECHANGE => "EVENT_OBJECT_NAMECHANGE",
        EVENT_OBJECT_PARENTCHANGE => "EVENT_OBJECT_PARENTCHANGE",
        EVENT_OBJECT_REORDER => "EVENT_OBJECT_REORDER",
        EVENT_OBJECT_SELECTION => "EVENT_OBJECT_SELECTION",
        EVENT_OBJECT_SELECTIONADD => "EVENT_OBJECT_SELECTIONADD",
        EVENT_OBJECT_SELECTIONREMOVE => "EVENT_OBJECT_SELECTIONREMOVE",
        EVENT_OBJECT_SELECTIONWITHIN => "EVENT_OBJECT_SELECTIONWITHIN",
        EVENT_OBJECT_SHOW => "EVENT_OBJECT_SHOW",
        EVENT_OBJECT_STATECHANGE => "EVENT_OBJECT_STATECHANGE",
        EVENT_OBJECT_TEXTEDIT_CONVERSIONTARGETCHANGED => {
            "EVENT_OBJECT_TEXTEDIT_CONVERSIONTARGETCHANGED"
        }
        EVENT_OBJECT_TEXTSELECTIONCHANGED => "EVENT_OBJECT_TEXTSELECTIONCHANGED",
        EVENT_OBJECT_UNCLOAKED => "EVENT_OBJECT_UNCLOAKED",
        EVENT_OBJECT_VALUECHANGE => "EVENT_OBJECT_VALUECHANGE",
        EVENT_OEM_DEFINED_END => "EVENT_OEM_DEFINED_END",
        EVENT_OEM_DEFINED_START => "EVENT_OEM_DEFINED_START",
        EVENT_SYSTEM_ALERT => "EVENT_SYSTEM_ALERT",
        EVENT_SYSTEM_ARRANGMENTPREVIEW => "EVENT_SYSTEM_ARRANGMENTPREVIEW",
        EVENT_SYSTEM_CAPTUREEND => "EVENT_SYSTEM_CAPTUREEND",
        EVENT_SYSTEM_CAPTURESTART => "EVENT_SYSTEM_CAPTURESTART",
        EVENT_SYSTEM_CONTEXTHELPEND => "EVENT_SYSTEM_CONTEXTHELPEND",
        EVENT_SYSTEM_CONTEXTHELPSTART => "EVENT_SYSTEM_CONTEXTHELPSTART",
        EVENT_SYSTEM_DESKTOPSWITCH => "EVENT_SYSTEM_DESKTOPSWITCH",
        EVENT_SYSTEM_DIALOGEND => "EVENT_SYSTEM_DIALOGEND",
        EVENT_SYSTEM_DIALOGSTART => "EVENT_SYSTEM_DIALOGSTART",
        EVENT_SYSTEM_DRAGDROPEND => "EVENT_SYSTEM_DRAGDROPEND",
        EVENT_SYSTEM_DRAGDROPSTART => "EVENT_SYSTEM_DRAGDROPSTART",
        EVENT_SYSTEM_END => "EVENT_SYSTEM_END",
        EVENT_SYSTEM_FOREGROUND => "EVENT_SYSTEM_FOREGROUND",
        EVENT_SYSTEM_IME_KEY_NOTIFICATION => "EVENT_SYSTEM_IME_KEY_NOTIFICATION",
        EVENT_SYSTEM_MENUEND => "EVENT_SYSTEM_MENUEND",
        EVENT_SYSTEM_MENUPOPUPEND => "EVENT_SYSTEM_MENUPOPUPEND",
        EVENT_SYSTEM_MENUPOPUPSTART => "EVENT_SYSTEM_MENUPOPUPSTART",
        EVENT_SYSTEM_MENUSTART => "EVENT_SYSTEM_MENUSTART",
        EVENT_SYSTEM_MINIMIZEEND => "EVENT_SYSTEM_MINIMIZEEND",
        EVENT_SYSTEM_MINIMIZESTART => "EVENT_SYSTEM_MINIMIZESTART",
        EVENT_SYSTEM_MOVESIZEEND => "EVENT_SYSTEM_MOVESIZEEND",
        EVENT_SYSTEM_MOVESIZESTART => "EVENT_SYSTEM_MOVESIZESTART",
        EVENT_SYSTEM_SCROLLINGEND => "EVENT_SYSTEM_SCROLLINGEND",
        EVENT_SYSTEM_SCROLLINGSTART => "EVENT_SYSTEM_SCROLLINGSTART",
        EVENT_SYSTEM_SOUND => "EVENT_SYSTEM_SOUND",
        EVENT_SYSTEM_SWITCHEND => "EVENT_SYSTEM_SWITCHEND",
        EVENT_SYSTEM_SWITCHER_APPDROPPED => "EVENT_SYSTEM_SWITCHER_APPDROPPED",
        EVENT_SYSTEM_SWITCHER_APPGRABBED => "EVENT_SYSTEM_SWITCHER_APPGRABBED",
        EVENT_SYSTEM_SWITCHER_APPOVERTARGET => "EVENT_SYSTEM_SWITCHER_APPOVERTARGET",
        EVENT_SYSTEM_SWITCHER_CANCELLED => "EVENT_SYSTEM_SWITCHER_CANCELLED",
        EVENT_SYSTEM_SWITCHSTART => "EVENT_SYSTEM_SWITCHSTART",
        EVENT_UIA_EVENTID_END => "EVENT_UIA_EVENTID_END",
        EVENT_UIA_EVENTID_START => "EVENT_UIA_EVENTID_START",
        EVENT_UIA_PROPID_END => "EVENT_UIA_PROPID_END",
        EVENT_UIA_PROPID_START => "EVENT_UIA_PROPID_START",
        _ => "<Unknown>",
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn listen_all() -> Result<(), windows::core::Error> {
        let rx = create_os_event_listener()?;
        while let Ok(msg) = rx.recv() {
            println!("Received message: {:?}", msg);
        }
        Ok(())
    }

    #[test]
    fn listen_events() -> Result<(), windows::core::Error> {
        let rx = create_os_event_listener()?;
        while let Ok(msg) = rx.recv() {
            if !matches!(msg, ProcMessage::Event { .. }) {
                continue;
            }
            println!("Received message: {:?}", msg);
        }
        Ok(())
    }

    #[test]
    fn listen_mouse() -> Result<(), windows::core::Error> {
        let rx = create_os_event_listener()?;
        while let Ok(msg) = rx.recv() {
            if !matches!(msg, ProcMessage::MouseMoved { .. }) {
                continue;
            }
            println!("Received message: {:?}", msg);
        }
        Ok(())
    }

    #[test]
    fn listen_keyboard() -> Result<(), windows::core::Error> {
        let rx = create_os_event_listener()?;
        while let Ok(msg) = rx.recv() {
            if !matches!(msg, ProcMessage::KeyDown { .. }) {
                continue;
            }
            println!("Received message: {:?}", msg);
        }
        Ok(())
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\click_drag_character_movement\src\lib.rs

````rust
use bevy::input::mouse::MouseButtonInput;
use bevy::input::mouse::MouseMotion;
use bevy::prelude::*;
use bevy::window::PrimaryWindow;
use bevy_xpbd_2d::components::Position;

use cursor_hero_camera::camera_plugin::update_camera_zoom;
use cursor_hero_camera::camera_plugin::FollowWithMainCamera;
use cursor_hero_camera::camera_plugin::MainCamera;
use cursor_hero_character_types::prelude::*;

pub struct ClickDragMovementPlugin;

impl Plugin for ClickDragMovementPlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(
            Update,
            (
                mouse_drag_update.after(update_camera_zoom),
                teleport_character_to_camera
                    .after(mouse_drag_update)
                    .run_if(should_teleport_character_to_camera),
            ),
        )
        .insert_resource(MouseDragState::default())
        .register_type::<MouseDragState>();
    }
}

#[derive(Reflect)]
struct Anchor {
    drag_start_world_position: Vec2,
}

#[derive(Resource, Reflect, Default)]
#[reflect(Resource)]
struct MouseDragState {
    anchor: Option<Anchor>,
    is_dragging: bool,
}

fn should_teleport_character_to_camera(
    query: Query<&FollowWithMainCamera, Added<FollowWithMainCamera>>,
    mouse_drag_state: Res<MouseDragState>,
) -> bool {
    query.iter().next().is_some() && mouse_drag_state.is_dragging
}

/// when the camera starts following a character while dragging, teleport the character to the camera
fn teleport_character_to_camera(
    mut character: Query<&mut Transform, (With<Character>, Without<MainCamera>)>,
    camera_transform_query: Query<&Transform, (With<MainCamera>, Without<Character>)>,
) {
    character.single_mut().translation = camera_transform_query.single().translation;
}

#[allow(clippy::type_complexity)]
fn mouse_drag_update(
    mut mouse_button_input_events: EventReader<MouseButtonInput>,
    mut mouse_drag_state: ResMut<MouseDragState>,
    mut mouse_motion_events: EventReader<MouseMotion>,
    mut follow: Query<&mut Position, (With<FollowWithMainCamera>, Without<MainCamera>)>,
    window_query: Query<&Window, With<PrimaryWindow>>,
    camera_query: Query<(&Camera, &GlobalTransform), (With<MainCamera>, Without<Character>)>,
    mut camera_transform_query: Query<&mut Transform, (With<MainCamera>, Without<Character>)>,
) {
    let (camera, camera_global_transform) = camera_query.single();
    let window = window_query.single();

    // drag start and end logic
    for event in mouse_button_input_events.read() {
        if event.button == MouseButton::Left {
            mouse_drag_state.is_dragging = event.state.is_pressed();
            if mouse_drag_state.is_dragging {
                // begin dragging
                if let Some(screen_position) = window.cursor_position() {
                    if let Some(world_position) = camera
                        .viewport_to_world(camera_global_transform, screen_position)
                        .map(|ray| ray.origin.truncate())
                    {
                        mouse_drag_state.anchor = Some(Anchor {
                            drag_start_world_position: world_position,
                        });
                    }
                }
            } else {
                // finish dragging
                mouse_drag_state.anchor = None;
            }
        }
    }

    if mouse_drag_state.is_dragging {
        // perform drag update
        if let Some(anchor) = &mouse_drag_state.anchor {
            if let Some(current_screen_position) = window.cursor_position() {
                // mouse is inside the window, convert to world coords
                if let Some(current_world_position) = camera
                    .viewport_to_world(camera_global_transform, current_screen_position)
                    .map(|ray| ray.origin.truncate())
                {
                    // calculate delta from the anchor
                    let delta = anchor.drag_start_world_position - current_world_position;
                    if let Ok(mut follow) = follow.get_single_mut() {
                        // reposition the thing the camera is following
                        follow.0 += delta;
                    } else {
                        // move the camera when not following something
                        camera_transform_query.single_mut().translation += delta.extend(0.0);
                    }
                    // track info needed to keep alignment with starting point
                    mouse_drag_state.anchor = Some(Anchor {
                        drag_start_world_position: anchor.drag_start_world_position,
                    });
                }
            } else {
                // cursor is outside the window, use delta to approximate mouse position
                let mut delta = mouse_motion_events
                    .read()
                    .fold(Vec2::ZERO, |acc, event| acc + event.delta);
                delta.x *= -1.0;
                if let Ok(mut follow) = follow.get_single_mut() {
                    // reposition the thing the camera is following
                    follow.0 += delta;
                } else {
                    // move the camera when not following something
                    camera_transform_query.single_mut().translation += delta.extend(0.0);
                }
            }
        }
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\environment_types\src\environment_types.rs

````rust
use bevy::prelude::*;

#[derive(Component, Debug, Reflect, Clone, Copy)]
pub enum EnvironmentKind {
    Host,
    HostUIWatcher,
    Game,
}

#[derive(Component, Debug, Reflect, Eq, PartialEq)]
pub struct EnvironmentTracker {
    pub environment_id: Entity,
}

#[derive(Component, Debug, Reflect)]
pub struct HostEnvironment;
#[derive(Component, Debug, Reflect)]
pub struct HostUIWatcherEnvironment;
#[derive(Component, Debug, Reflect)]
pub struct GameEnvironment;


#[derive(Component, Default, Reflect)]
pub struct Nametag;

#[derive(Component, Debug, Reflect)]
pub struct TrackEnvironmentTag;


#[derive(Event, Debug, Reflect)]
pub struct CreateEnvironmentRequestEvent {
    pub name: String,
    pub origin: Vec2,
    pub kind: EnvironmentKind
}

#[derive(Event, Debug, Reflect)]
pub struct PopulateEnvironmentEvent {
    pub environment_id: Entity,
}

#[derive(Event, Debug, Reflect)]
pub enum NametagEvent {
    Update {
        environment_id: Entity,
        name: String,
    },
    RecalculatePosition {
        environment_id: Entity,
    },
}

````



## D:\Repos\Games\Cursor-Hero\crates\ollama_types\src\lib.rs

````rust
pub mod ollama_types;
pub mod ollama_types_plugin;

pub mod prelude {
    pub use crate::ollama_types::*;
    pub use crate::ollama_types_plugin::*;
}

````



## D:\Repos\Games\Cursor-Hero\crates\movement_tool\src\movement_tool.rs

````rust
use crate::tool_spawning::ToolSpawnConfig;
use bevy::prelude::*;
use bevy_xpbd_2d::math::*;
use bevy_xpbd_2d::prelude::*;
use cursor_hero_character_types::prelude::*;
use cursor_hero_math::prelude::Lerp;
use itertools::Itertools;
use leafwing_input_manager::prelude::*;
use leafwing_input_manager::user_input::InputKind;

pub struct MovementToolPlugin;

impl Plugin for MovementToolPlugin {
    fn build(&self, app: &mut App) {
        
    }
}


````



## D:\Repos\Games\Cursor-Hero\crates\ollama_types\src\ollama_types_plugin.rs

````rust
use crate::prelude::*;
use bevy::prelude::*;

pub struct OllamaTypesPlugin;

impl Plugin for OllamaTypesPlugin {
    fn build(&self, app: &mut App) {
        app.register_type::<OllamaStatus>();
        app.register_type::<OllamaStatusButton>();
        app.register_type::<OllamaStatusButtonVisualState>();
        app.register_type::<OllamaStatusEvent>();
        app.add_event::<OllamaStatusEvent>();

        app.register_type::<OllamaPingEvent>();
        app.add_event::<OllamaPingEvent>();

        app.register_type::<OllamaTerminalButton>();
        app.register_type::<OllamaTerminalButtonVisualState>();
        app.register_type::<OllamaTerminalEvent>();
        app.add_event::<OllamaTerminalEvent>();
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\inference_types\src\inference_types.rs

````rust
use crate::prelude::*;
use bevy::prelude::*;

#[derive(Reflect, Debug, Clone, Default, Eq, PartialEq)]
pub struct TextInferenceOptions {
    pub num_predict: Option<usize>,
    pub stop: Option<Vec<String>>,
}

#[derive(Event, Reflect, Debug, Clone)]
pub enum TextInferenceEvent {
    Request {
        session_id: Entity,
        prompt: TextPrompt,
    },
    Response {
        session_id: Entity,
        prompt: MaterializedTextPrompt,
        response: String,
    },
}

#[derive(Event, Reflect, Debug, Clone)]
pub enum SpeechInferenceEvent {
    Request {
        session_id: Entity,
        prompt: SpeechPrompt,
    },
    Response {
        session_id: Entity,
        prompt: SpeechPrompt,
        wav: Vec<u8>,
    },
}

#[derive(Event, Reflect, Debug, Clone)]
pub enum TranscriptionInferenceEvent {
    Request {
        session_id: Entity,
        prompt: TranscriptionPrompt,
    },
    Response {
        session_id: Entity,
        prompt: TranscriptionPrompt,
        transcription: String,
    },
}

````



## D:\Repos\Games\Cursor-Hero\crates\ollama\src\ollama_status_worker_plugin.rs

````rust
use bevy::prelude::*;
use crossbeam_channel::bounded;
use crossbeam_channel::Receiver;
use crossbeam_channel::Sender;
use cursor_hero_ollama_types::prelude::*;
use std::thread;

pub struct OllamaStatusWorkerPlugin;

impl Plugin for OllamaStatusWorkerPlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(Startup, create_worker_thread);
        app.add_systems(Update, events_to_bridge);
        app.add_systems(Update, bridge_to_events);
    }
}

#[derive(Debug)]
enum GameboundMessage {
    Pong { status: OllamaStatus },
}

#[derive(Debug)]
enum ThreadboundMessage {
    Ping,
    Startup,
}

#[derive(Resource)]
struct Bridge {
    pub sender: Sender<ThreadboundMessage>,
    pub receiver: Receiver<GameboundMessage>,
}

fn create_worker_thread(mut commands: Commands) {
    let (game_tx, game_rx) = bounded::<_>(10);
    let (thread_tx, thread_rx) = bounded::<_>(10);
    commands.insert_resource(Bridge {
        sender: thread_tx,
        receiver: game_rx,
    });

    let game_tx_clone = game_tx.clone();
    thread::Builder::new()
        .name("Ollama status thread".to_string())
        .spawn(move || {
            let rt = tokio::runtime::Runtime::new().unwrap();
            rt.block_on(async {
                let game_tx = game_tx_clone;
                loop {
                    let msg = match thread_rx.recv() {
                        Ok(msg) => msg,
                        Err(_) => {
                            error!("Threadbound channel failure, exiting");
                            break;
                        }
                    };
                    match msg {
                        ThreadboundMessage::Ping => {
                            debug!("Worker received ping request, pinging Ollama API");
                            let status = match crate::ollama::get_status().await {
                                Ok(status) => status,
                                Err(e) => {
                                    error!("Failed to get status: {:?}", e);
                                    OllamaStatus::Unknown
                                }
                            };
                            if let Err(e) = game_tx.send(GameboundMessage::Pong { status }) {
                                error!("Gamebound channel failure, exiting: {}", e);
                                break;
                            }
                        }
                        ThreadboundMessage::Startup => {
                            debug!("Worker received startup request, starting Ollama API");
                            if let Err(e) = crate::ollama::start() {
                                error!("Failed to start: {:?}", e);
                            };
                        }
                    }
                    std::thread::sleep(std::time::Duration::from_millis(50));
                }
            });
        })
        .expect("Failed to spawn thread");
}

fn events_to_bridge(
    bridge: ResMut<Bridge>,
    mut ping_events: EventReader<OllamaPingEvent>,
    mut status_events: EventReader<OllamaStatusEvent>,
) {
    // Detect ping requests
    for event in ping_events.read() {
        let OllamaPingEvent::Ping = event else {
            continue;
        };
        let msg = ThreadboundMessage::Ping;
        debug!("Sending bridge message: {:?}", msg);
        if let Err(e) = bridge.sender.send(msg) {
            error!("Threadbound channel failure: {}", e);
        }
    }

    // Detect startup requests
    let starting = status_events
        .read()
        .any(|event| matches!(event, OllamaStatusEvent::Startup));
    if starting {
        status_events.clear();
        let msg = ThreadboundMessage::Startup;
        debug!("Sending bridge message: {:?}", msg);
        if let Err(e) = bridge.sender.send(msg) {
            error!("Threadbound channel failure: {}", e);
        }
    }
}

fn bridge_to_events(bridge: ResMut<Bridge>, mut events: EventWriter<OllamaPingEvent>) {
    for msg in bridge.receiver.try_iter() {
        match msg {
            GameboundMessage::Pong { status } => {
                let event = OllamaPingEvent::Pong { status };
                debug!("Received bridge response, sending game event {:?}", event);
                events.send(event);
            }
        }
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\character\src\character_appearance_plugin.rs

````rust
use bevy::prelude::*;

pub struct CharacterAppearancePlugin;
use cursor_hero_camera::camera_plugin::CameraEvent;
use cursor_hero_character_types::prelude::*;

impl Plugin for CharacterAppearancePlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(Update, update_character_appearance_from_camera_events);
    }
}

fn update_character_appearance_from_camera_events(
    mut camera_events: EventReader<CameraEvent>,
    asset_server: Res<AssetServer>,
    mut character_query: Query<&mut Handle<Image>, With<Character>>,
) {
    for event in camera_events.read() {
        match event {
            CameraEvent::BeginFollowing { target_id } => {
                if let Ok(mut texture) = character_query.get_mut(*target_id) {
                    *texture = asset_server.load(CharacterAppearance::Focused.get_texture_path());
                    info!("Updated character appearance to focused");
                }
            }
            CameraEvent::StopFollowing { target_id } => {
                if let Ok(mut texture) = character_query.get_mut(*target_id) {
                    *texture = asset_server.load(CharacterAppearance::Unfocused.get_texture_path());
                    info!("Updated character appearance to unfocused");
                }
            }
        }
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\environment_nametag\src\environment_nametag_plugin.rs

````rust
use bevy::prelude::*;
use bevy::utils::HashSet;
use cursor_hero_bevy::prelude::Vec2ToRect;
use cursor_hero_environment_types::prelude::*;
use cursor_hero_screen::screen_plugin::Screen;
use cursor_hero_screen::screen_plugin::ScreenParent;

pub struct EnvironmentNametagPlugin;

impl Plugin for EnvironmentNametagPlugin {
    fn build(&self, app: &mut App) {
        app.add_event::<NametagEvent>();
        app.add_systems(Update, spawn_nametags_in_new_environments);
        app.add_systems(Update, recalc_new_screen_nametags);
        app.add_systems(Update, handle_nametag_update_event);
        app.add_systems(Update, handle_nametag_recalculate_position_event);
        app.register_type::<Nametag>();
    }
}

fn spawn_nametags_in_new_environments(
    mut environment_reader: EventReader<PopulateEnvironmentEvent>,
    mut commands: Commands,
    environment_query: Query<&Name, Or<(With<HostEnvironment>, With<GameEnvironment>)>>,
    asset_server: Res<AssetServer>,
) {
    for event in environment_reader.read() {
        let Ok(environment_name) = environment_query.get(event.environment_id) else {
            continue;
        };
        let environment_id = event.environment_id;
        info!(
            "Spawning nametags for environment {:?} ({})",
            environment_id, environment_name
        );
        commands.entity(environment_id).with_children(|parent| {
            parent.spawn((
                Text2dBundle {
                    text: Text::from_section(
                        environment_name.to_string(),
                        TextStyle {
                            font_size: 72.0,
                            font: asset_server
                                .load("fonts/kenney_kenney-fonts/Fonts/Kenney Future Narrow.ttf"),
                            color: Color::WHITE,
                        },
                    )
                    .with_alignment(TextAlignment::Center),
                    transform: Transform::from_xyz(0.0, 200.0, 1.0).with_scale(Vec3::splat(4.0)),
                    ..default()
                },
                Nametag,
                Name::new("Nametag"),
            ));
        });
    }
}

fn recalc_new_screen_nametags(
    mut nametag_events: EventWriter<NametagEvent>,
    screen_query: Query<&Parent, Added<Screen>>,
    screen_parent_query: Query<&Parent, With<ScreenParent>>,
) {
    for new_screen_parent_id in screen_query.iter() {
        if let Ok(environment_id) = screen_parent_query.get(new_screen_parent_id.get()) {
            info!(
                "Detected new screen {:?} in environment {:?}, sending recalculate position event",
                new_screen_parent_id, environment_id
            );
            nametag_events.send(NametagEvent::RecalculatePosition {
                environment_id: environment_id.get(),
            });
        }
    }
}

fn handle_nametag_update_event(
    mut nametag_events: EventReader<NametagEvent>,
    environment_query: Query<&Children, With<EnvironmentKind>>,
    mut nametag_query: Query<(&mut Text, &mut Transform), With<Nametag>>,
) {
    for nametag_event in nametag_events.read() {
        if let NametagEvent::Update {
            environment_id,
            name,
        } = nametag_event
        {
            info!(
                "Updating nametag for environment {:?} to {}",
                environment_id, name
            );
            if let Ok(environment_children) = environment_query.get(*environment_id) {
                for child in environment_children.iter() {
                    if let Ok((mut nametag_text, _)) = nametag_query.get_mut(*child) {
                        nametag_text.sections[0].value = name.clone();
                    }
                }
            }
        }
    }
}

#[allow(clippy::type_complexity)]
fn handle_nametag_recalculate_position_event(
    mut nametag_events: EventReader<NametagEvent>,
    environment_query: Query<&Children, With<EnvironmentKind>>,
    mut nametag_query: Query<(&mut Text, &mut Transform), (With<Nametag>, Without<Screen>)>,
    screen_parent_query: Query<&Children, With<ScreenParent>>,
    screen_query: Query<(&Sprite, &GlobalTransform), (With<Screen>, Without<Nametag>)>,
) {
    let mut debounce = HashSet::new();
    for nametag_event in nametag_events.read() {
        if let NametagEvent::RecalculatePosition { environment_id } = nametag_event {
            if debounce.contains(environment_id) {
                debug!(
                    "Debounced recalculate position event for environment {:?}, skipping",
                    environment_id
                );
                continue;
            }
            info!(
                "Recalculating nametag position for environment {:?}",
                environment_id
            );
            debounce.insert(environment_id);
            if let Ok(environment_children) = environment_query.get(*environment_id) {
                let mut max_extents = Rect::default();
                for environment_child_id in environment_children.iter() {
                    // debug!(
                    //     "Checking environment child {:?} for environment {:?}",
                    //     environment_child_id, environment_id
                    // );
                    if let Ok(screen_parent_children) =
                        screen_parent_query.get(*environment_child_id)
                    {
                        debug!(
                            "Found screen parent children {:?} for environment {:?}",
                            screen_parent_children, environment_id
                        );
                        for screen_id in screen_parent_children.iter() {
                            if let Ok((screen_sprite, screen_transform)) =
                                screen_query.get(*screen_id)
                            {
                                if let Some(screen_size) = screen_sprite.custom_size {
                                    max_extents =
                                        max_extents.union(screen_size.as_size_of_rect_with_center(
                                            &screen_transform.translation().xy(),
                                        ));
                                } else {
                                    warn!(
                                        "Screen {:?} did not have custom size, skipping",
                                        screen_id
                                    );
                                }
                            }
                        }
                    }
                }
                if max_extents.is_empty() {
                    warn!(
                        "Max extents for environment {:?} was empty, skipping",
                        environment_id
                    );
                    continue;
                }
                info!(
                    "Max extents for environment {:?} is {:?}",
                    environment_id, max_extents
                );
                for child in environment_children.iter() {
                    if let Ok((_, mut nametag_transform)) = nametag_query.get_mut(*child) {
                        nametag_transform.translation.x = max_extents.center().x;
                        nametag_transform.translation.y = max_extents.max.y + 200.0;
                    }
                }
            } else {
                warn!(
                    "Could not find environment children for environment {:?}",
                    environment_id
                );
            }
        }
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\data\src\lib.rs

````rust
pub mod paths;
pub mod sounds;

````



## D:\Repos\Games\Cursor-Hero\crates\wallpaper\src\wallpaper_plugin.rs

````rust
use bevy::prelude::*;
use cursor_hero_environment_types::prelude::*;

pub struct WallpaperPlugin;

impl Plugin for WallpaperPlugin {
    fn build(&self, app: &mut App) {
        app.register_type::<Wallpaper>();
        app.add_systems(Update, spawn_wallpaper);
    }
}

#[derive(Component, Debug, Reflect)]
pub struct Wallpaper;

fn spawn_wallpaper(
    mut commands: Commands,
    mut environment_events: EventReader<PopulateEnvironmentEvent>,
    environment_query: Query<&GameEnvironment>,
    asset_server: Res<AssetServer>,
) {
    for event in environment_events.read() {
        if !environment_query.contains(event.environment_id) {
            continue;
        }
        info!(
            "Spawning wallpaper for game environment {:?}",
            event.environment_id
        );
        commands
            .entity(event.environment_id)
            .with_children(|parent| {
                parent.spawn((
                    SpriteBundle {
                        sprite: Sprite {
                            custom_size: Some(Vec2::new(1920.0, 1080.0)),
                            anchor: bevy::sprite::Anchor::TopLeft,
                            ..default()
                        },
                        texture: asset_server.load("textures/environment/game/wallpaper.png"),
                        transform: Transform::from_translation(Vec3::new(0.0, 0.0, 1.0)),
                        ..default()
                    },
                    Name::new("Wallpaper"),
                ));
            });
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\character_types\src\character_types.rs

````rust
use bevy::prelude::*;

#[derive(Component, Reflect, Default)]
pub struct Character;

#[derive(Component, Reflect, Default)]
pub struct MainCharacter;
#[derive(Component, Reflect, Default)]
pub struct AgentCharacter;

#[derive(Component, Reflect, Eq, PartialEq, Debug)]
pub enum CharacterAppearance {
    Focused,
    Unfocused,
}
impl CharacterAppearance {
    pub fn get_texture_path(&self) -> &'static str {
        match self {
            Self::Focused => "textures/character/default_character_focused.png",
            Self::Unfocused => "textures/character/default_character_unfocused.png",
        }
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\ui_automation_types\src\lib.rs

````rust
#![feature(trivial_bounds)]

mod taskbar_ui_types;
mod ui_automation_drill;
mod ui_automation_error_types;
mod ui_automation_types;
mod ui_automation_types_plugin;
mod vscode_ui_types;
mod calculator_ui_types;

pub mod prelude {
    pub use crate::taskbar_ui_types::*;
    pub use crate::ui_automation_drill::*;
    pub use crate::ui_automation_error_types::*;
    pub use crate::ui_automation_types::*;
    pub use crate::ui_automation_types_plugin::*;
    pub use crate::vscode_ui_types::*;
    pub use crate::calculator_ui_types::*;
    // pub use uiautomation;
}

````



## D:\Repos\Games\Cursor-Hero\crates\toolbelt\src\tool_help_populate.rs

````rust
use cursor_hero_host_fs_types::host_fs_types::HostPath;
use cursor_hero_toolbelt_types::toolbelt_types::*;

use bevy::prelude::*;
use bevy_xpbd_2d::components::Collider;
use bevy_xpbd_2d::components::RigidBody;
use bevy_xpbd_2d::components::Sensor;
use cursor_hero_pointer_types::prelude::*;

use leafwing_input_manager::action_state::ActionState;

#[allow(clippy::type_complexity)]
pub fn tool_help_lifecycle(
    mut commands: Commands,
    toolbelt_query: Query<
        (&ActionState<ToolbeltAction>, &Children),
        (Without<Tool>, With<Toolbelt>),
    >,
    tool_query: Query<(Entity, Option<&HostPath>, Option<&Children>, Option<&Name>), With<Tool>>,
    tool_help_triggger_query: Query<Entity, With<ToolHelpTrigger>>,
    asset_server: Res<AssetServer>,
) {
    for (toolbelt_actions, toolbelt_kids) in toolbelt_query.iter() {
        if toolbelt_actions.just_pressed(ToolbeltAction::Show) {
            for child_id in toolbelt_kids.iter() {
                let Ok(tool) = tool_query.get(*child_id) else {
                    continue;
                };

                let (tool_id, tool_src_path, _, tool_name) = tool;
                commands.entity(tool_id).with_children(|parent| {
                    let mut help = parent.spawn((
                        Name::new(format!("Help Trigger for {:?} ({:?})", tool_name, tool_id)),
                        SpriteBundle {
                            sprite: Sprite {
                                custom_size: Some(Vec2::new(50.0, 50.0)),
                                ..default()
                            },
                            transform: Transform::from_xyz(0.0, 0.0, 1.0),
                            texture: asset_server.load("textures/toolbelt_wheel/help_trigger.png"),
                            ..default()
                        },
                        Hoverable,
                        Clickable,
                        ToolHelpTrigger,
                        Sensor,
                        RigidBody::Kinematic,
                        Collider::cuboid(50.0, 50.0),
                    ));
                    if let Some(src_path) = tool_src_path {
                        help.insert(src_path.clone());
                    }
                });
            }
        } else if toolbelt_actions.just_released(ToolbeltAction::Show) {
            for child_id in toolbelt_kids.iter() {
                let Ok(tool) = tool_query.get(*child_id) else {
                    continue;
                };
                let (tool_id, _, Some(tool_children), _) = tool else {
                    continue;
                };
                for child_id in tool_children.iter() {
                    if let Ok(tool_help_trigger_id) = tool_help_triggger_query.get(*child_id) {
                        commands
                            .entity(tool_id)
                            .remove_children(&[tool_help_trigger_id]);
                        commands.entity(tool_help_trigger_id).despawn_recursive();
                    }
                }
            }
        }
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\movement_tool_types\src\movement_tool_types.rs

````rust
use bevy::prelude::*;
use leafwing_input_manager::prelude::*;
use leafwing_input_manager::user_input::InputKind;

use bevy_inspector_egui::prelude::ReflectInspectorOptions;
use bevy_inspector_egui::InspectorOptions;
use cursor_hero_input::active_input_state_plugin::InputMethod;
use cursor_hero_toolbelt_types::prelude::*;

#[derive(Component, Reflect, Debug, InspectorOptions)]
#[reflect(Component, InspectorOptions)]
pub struct MovementTool {
    #[inspector(min = 0.0)]
    pub speed: f32,
    #[inspector(min = 0.0)]
    pub default_speed: f32,
    #[inspector(min = 0.0)]
    pub sprint_speed: f32,
    pub target: MovementTarget,
}
impl Default for MovementTool {
    fn default() -> Self {
        match InputMethod::default() {
            InputMethod::MouseAndKeyboard | InputMethod::Keyboard => Self::default_mnk(),
            InputMethod::Gamepad => Self::default_gamepad(),
        }
    }
}
impl MovementTool {
    pub fn default_mnk() -> MovementTool {
        MovementTool {
            speed: 8000.0,
            default_speed: 8000.0,
            sprint_speed: 40000.0,
            target: MovementTarget::Character,
        }
    }
    pub fn default_gamepad() -> MovementTool {
        MovementTool {
            speed: 800.0,
            default_speed: 800.0,
            sprint_speed: 80000.0,
            target: MovementTarget::Character,
        }
    }
}

#[derive(Reflect, Debug, Clone, Copy)]
pub enum MovementTarget {
    Character,
    Camera(Entity),
}

#[derive(Event, Debug, Reflect)]
pub enum MovementTargetEvent {
    SetTarget {
        tool_id: Entity,
        target: MovementTarget,
    },
}

#[derive(Actionlike, PartialEq, Eq, Clone, Copy, Hash, Debug, Reflect)]
pub enum MovementToolAction {
    Move,
}

impl MovementToolAction {
    fn default_gamepad_binding(&self) -> UserInput {
        match self {
            Self::Move => UserInput::Single(InputKind::DualAxis(DualAxis::left_stick())),
        }
    }

    fn default_mkb_binding(&self) -> UserInput {
        match self {
            Self::Move => UserInput::VirtualDPad(VirtualDPad::wasd()),
        }
    }
}
impl ToolAction for MovementToolAction {
    fn default_input_map(_event: &ToolbeltPopulateEvent) -> Option<InputMap<MovementToolAction>> {
        let mut input_map = InputMap::default();

        for variant in MovementToolAction::variants() {
            input_map.insert(variant.default_mkb_binding(), variant);
            input_map.insert(variant.default_gamepad_binding(), variant);
        }
        Some(input_map)
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\floaty_nametag_types\src\floaty_nametag_types.rs

````rust
use bevy::prelude::*;

#[derive(Component, Debug, Reflect)]
pub struct FloatyName {
    pub text: String,
    pub vertical_offset: f32,
    pub appearance: NametagAppearance,
}

#[derive(Component, Debug, Reflect)]
pub struct FloatyNametag {
    pub owner: Entity,
}

#[derive(Debug, Reflect)]
pub enum NametagAppearance {
    Character,
    Databrick,
}
impl NametagAppearance {
    pub fn get_font_path(&self) -> String {
        match self {
            NametagAppearance::Character => "fonts/kenney_kenney-fonts/Fonts/Kenney Rocket.ttf",
            NametagAppearance::Databrick => "fonts/kenney_kenney-fonts/Fonts/Kenney Blocks.ttf",
        }
        .to_string()
    }
    pub fn get_text_color(&self) -> Color {
        match self {
            NametagAppearance::Character => Color::GREEN,
            NametagAppearance::Databrick => Color::BLUE,
        }
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\agent\src\agent_plugin.rs

````rust
use crate::agent_movement_plugin::AgentMovementPlugin;
use crate::agent_spawning_plugin::AgentSpawningPlugin;
use crate::insert_agent_toolbelt::InsertAgentToolbeltPlugin;
use bevy::prelude::*;

pub struct AgentPlugin;

impl Plugin for AgentPlugin {
    fn build(&self, app: &mut App) {
        app.add_plugins(InsertAgentToolbeltPlugin);
        app.add_plugins(AgentSpawningPlugin);
        app.add_plugins(AgentMovementPlugin);
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\toolbelt_types\src\lib.rs

````rust
pub mod toolbelt_types;
pub mod toolbelt_types_plugin;

pub mod prelude {
    pub use crate::toolbelt_types::*;
}

````



## D:\Repos\Games\Cursor-Hero\crates\host_event_types\src\lib.rs

````rust
mod host_event_types;
mod host_event_types_plugin;

pub mod prelude {
    pub use crate::host_event_types::*;
    pub use crate::host_event_types_plugin::*;
}

````



## D:\Repos\Games\Cursor-Hero\crates\toolbelt\src\wheel_audio.rs

````rust
use cursor_hero_toolbelt_types::toolbelt_types::*;

use bevy::audio::Volume;
use bevy::audio::VolumeLevel;
use bevy::prelude::*;

#[derive(Component)]
pub struct WheelAudio;

pub fn wheel_audio(
    mut commands: Commands,
    asset_server: Res<AssetServer>,
    mut toolbelt_events: EventReader<ToolbeltOpeningEvent>,
    toolbelt_query: Query<&GlobalTransform>,
) {
    for event in toolbelt_events.read() {
        match event {
            ToolbeltOpeningEvent::Opened { toolbelt_id } => {
                let Ok(toolbelt_transform) = toolbelt_query.get(*toolbelt_id) else {
                    continue;
                };
                commands.spawn((
                    AudioBundle {
                        source: asset_server.load("sounds/plastic toy snapping shut 1.ogg"),
                        settings: PlaybackSettings::DESPAWN
                            .with_spatial(true)
                            .with_volume(Volume::Relative(VolumeLevel::new(0.5))),
                    },
                    SpatialBundle {
                        transform: toolbelt_transform.compute_transform(),
                        ..default()
                    },
                    WheelAudio,
                    Name::new("opening sound"),
                ));
            }
            ToolbeltOpeningEvent::Closed { toolbelt_id } => {
                let Ok(toolbelt_transform) = toolbelt_query.get(*toolbelt_id) else {
                    continue;
                };
                commands.spawn((
                    AudioBundle {
                        source: asset_server
                            .load("sounds/plastic toy snapping shut 1 reversed.ogg"),
                        settings: PlaybackSettings::DESPAWN
                            .with_spatial(true)
                            .with_volume(Volume::Relative(VolumeLevel::new(0.5))),
                    },
                    SpatialBundle {
                        transform: toolbelt_transform.compute_transform(),
                        ..default()
                    },
                    WheelAudio,
                    Name::new("closing sound"),
                ));
            }
        }
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\floaty_nametag_types\src\floaty_nametag_types_plugin.rs

````rust
use crate::prelude::*;
use bevy::prelude::*;

pub struct FloatyNametagTypesPlugin;

impl Plugin for FloatyNametagTypesPlugin {
    fn build(&self, app: &mut App) {
        app.register_type::<FloatyName>();
        app.register_type::<FloatyNametag>();
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\ollama\src\lib.rs

````rust
pub mod ollama;
pub mod ollama_button_plugin;
pub mod ollama_inference_plugin;
pub mod ollama_plugin;
pub mod ollama_status_plugin;
pub mod ollama_status_worker_plugin;

pub mod prelude {
    pub use crate::ollama_plugin::*;
}

````



## D:\Repos\Games\Cursor-Hero\crates\tools\src\zoom_tool.rs

````rust
use crate::prelude::*;
use bevy::prelude::*;
use bevy_inspector_egui::prelude::ReflectInspectorOptions;
use bevy_inspector_egui::InspectorOptions;
use cursor_hero_camera::camera_plugin::MainCamera;
use cursor_hero_character_types::prelude::*;
use cursor_hero_math::prelude::Lerp;
use cursor_hero_sprint_tool_types::sprint_tool_types_plugin::SprintEvent;
use cursor_hero_toolbelt_types::prelude::*;
use itertools::Itertools;
use leafwing_input_manager::prelude::*;
pub struct ZoomToolPlugin;

impl Plugin for ZoomToolPlugin {
    fn build(&self, app: &mut App) {
        app.register_type::<ZoomTool>();
        app.add_plugins(InputManagerPlugin::<ZoomToolAction>::default());
        app.add_systems(
            Update,
            (toolbelt_events, handle_input, handle_sprint_events),
        );
    }
}

#[derive(Component, InspectorOptions, Debug, Reflect)]
#[reflect(Component, InspectorOptions)]
struct ZoomTool {
    #[inspector(min = 0.0)]
    speed: f32,
    #[inspector(min = 0.0)]
    default_speed: f32,
    #[inspector(min = 0.0)]
    sprint_speed: f32,
    #[inspector(min = 0.0001, max = 10000.0)]
    scale_min: f32,
    #[inspector(min = 0.0001, max = 10000.0)]
    scale_max: f32,
}
impl Default for ZoomTool {
    fn default() -> Self {
        Self {
            speed: 1.0,
            default_speed: 1.0,
            sprint_speed: 50.0,
            scale_min: 0.001,
            scale_max: 10.0,
        }
    }
}
fn toolbelt_events(
    mut commands: Commands,
    asset_server: Res<AssetServer>,
    mut reader: EventReader<ToolbeltPopulateEvent>,
) {
    for event in reader.read() {
        let (ToolbeltLoadout::Default | ToolbeltLoadout::Inspector) = event.loadout else {
            continue;
        };
        ToolSpawnConfig::<_, ZoomToolAction>::new(ZoomTool::default(), event.id, event)
            .with_src_path(file!().into())
            .guess_name(file!())
            .guess_image(file!(), &asset_server, "png")
            .with_description("Send scroll events")
            .spawn(&mut commands);
    }
}

#[derive(Actionlike, PartialEq, Eq, Clone, Copy, Hash, Debug, Reflect)]
enum ZoomToolAction {
    Out,
    In,
}

impl ZoomToolAction {
    fn default_gamepad_binding(&self) -> UserInput {
        match self {
            Self::Out => GamepadButtonType::DPadLeft.into(),
            Self::In => GamepadButtonType::DPadRight.into(),
        }
    }

    fn default_mkb_binding(&self) -> UserInput {
        match self {
            Self::Out => KeyCode::Home.into(),
            Self::In => KeyCode::End.into(),
        }
    }
}
impl ToolAction for ZoomToolAction {
    fn default_input_map(_event: &ToolbeltPopulateEvent) -> Option<InputMap<ZoomToolAction>> {
        let mut input_map = InputMap::default();

        for variant in ZoomToolAction::variants() {
            input_map.insert(variant.default_mkb_binding(), variant);
            input_map.insert(variant.default_gamepad_binding(), variant);
        }
        Some(input_map)
    }
}

fn handle_input(
    tool_query: Query<(&ActionState<ZoomToolAction>, &ZoomTool), With<ActiveTool>>,
    mut camera_query: Query<&mut Transform, With<MainCamera>>,
    time: Res<Time>,
) {
    for zoom_tool in tool_query.iter() {
        let (tool_actions, tool) = zoom_tool;
        let camera = camera_query.single_mut();
        let mut camera_transform = camera;
        if tool_actions.pressed(ZoomToolAction::Out) {
            let mut scale = camera_transform.scale;
            let diff = 0.1 * time.delta_seconds() * tool.speed;
            scale *= Vec3::splat(1.0) + Vec2::splat(diff).extend(0.0);
            debug!(
                "scale_min: {}, scale_max: {}",
                tool.scale_min, tool.scale_max
            );
            scale = scale.clamp(Vec3::splat(tool.scale_min), Vec3::splat(tool.scale_max));
            camera_transform.scale = scale;
            if tool_actions.just_pressed(ZoomToolAction::Out) {
                info!("Zooming out");
            }
        }
        if tool_actions.pressed(ZoomToolAction::In) {
            let mut scale = camera_transform.scale;
            let diff = 0.1 * time.delta_seconds() * tool.speed;
            scale *= Vec3::splat(1.0) - Vec2::splat(diff).extend(0.0);
            debug!(
                "scale_min: {}, scale_max: {}",
                tool.scale_min, tool.scale_max
            );
            scale = scale.clamp(Vec3::splat(tool.scale_min), Vec3::splat(tool.scale_max));
            camera_transform.scale = scale;
            if tool_actions.just_pressed(ZoomToolAction::In) {
                info!("Zooming in");
            }
        }
    }
}

fn handle_sprint_events(
    mut sprint_events: EventReader<SprintEvent>,
    character_query: Query<&Children, With<Character>>,
    toolbelt_query: Query<&Children, With<Toolbelt>>,
    mut tool_query: Query<&mut ZoomTool>,
) {
    for event in sprint_events.read() {
        let character_id = match event {
            SprintEvent::Active { character_id, .. } => character_id,
            SprintEvent::Stop { character_id } => character_id,
        };
        let Ok(character) = character_query.get(*character_id) else {
            warn!("Character {:?} does not exist", character_id);
            continue;
        };
        let character_kids = character;
        let tool_ids = character_kids
            .iter()
            .filter_map(|kid| toolbelt_query.get(*kid).ok())
            .flat_map(|toolbelt| toolbelt.iter())
            .filter(|kid| tool_query.contains(**kid))
            .cloned()
            .collect_vec();

        match event {
            SprintEvent::Active { throttle, .. } => {
                let mut iter = tool_query.iter_many_mut(&tool_ids);
                while let Some(mut tool) = iter.fetch_next() {
                    tool.speed = (tool.default_speed, tool.sprint_speed).lerp(*throttle);
                }
            }
            SprintEvent::Stop { .. } => {
                let mut iter = tool_query.iter_many_mut(&tool_ids);
                while let Some(mut tool) = iter.fetch_next() {
                    tool.speed = tool.default_speed;
                }
            }
        }
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\level_bounds\src\lib.rs

````rust
pub mod level_bounds_plugin;

````



## D:\Repos\Games\Cursor-Hero\crates\host_fs\src\lib.rs

````rust
pub mod host_fs_plugin;

pub mod prelude {
    pub use crate::host_fs_plugin::*;
}

````



## D:\Repos\Games\Cursor-Hero\crates\ui_watcher\src\ui_watcher_plugin.rs

````rust
use bevy::prelude::*;
use cursor_hero_character_types::prelude::MainCharacter;
use cursor_hero_environment_types::environment_types::EnvironmentTracker;
use cursor_hero_memory_types::prelude::get_persist_file;
use cursor_hero_memory_types::prelude::Usage;
use cursor_hero_observation_types::observation_types::SomethingObservableHappenedEvent;
use cursor_hero_ui_automation::prelude::take_snapshot;
use cursor_hero_ui_automation::prelude::UISnapshot;
use std::io::Write;
use std::thread;

use crossbeam_channel::bounded;
use crossbeam_channel::Receiver;
use crossbeam_channel::Sender;
pub struct UiWatcherPlugin;

impl Plugin for UiWatcherPlugin {
    fn build(&self, app: &mut App) {
        return;
        app.add_systems(Startup, spawn_worker_thread);
        app.add_systems(Update, handle_gamebound_messages);
        app.add_systems(Update, trigger_gather_info);
    }
}

#[derive(Debug)]
enum ThreadboundMessage {
    TakeSnapshot,
}

#[derive(Debug)]
enum GameboundMessage {
    Snapshot(UISnapshot),
}

#[derive(Resource)]
struct Bridge {
    pub sender: Sender<ThreadboundMessage>,
    pub receiver: Receiver<GameboundMessage>,
}

fn spawn_worker_thread(mut commands: Commands) {
    let (tx, rx) = bounded::<_>(10);
    let (reply_tx, reply_rx) = bounded::<_>(10); // New channel for replies

    commands.insert_resource(Bridge {
        sender: tx,
        receiver: reply_rx,
    });
    thread::spawn(move || loop {
        let action = match rx.recv() {
            Ok(action) => action,
            Err(e) => {
                error!("Failed to receive thread message, exiting: {:?}", e);
                break;
            }
        };
        if let Err(e) = handle_threadbound_messages(action, &reply_tx) {
            error!("Failed to process thread message: {:?}", e);
        }
    });
}

fn handle_threadbound_messages(
    action: ThreadboundMessage,
    reply_tx: &Sender<GameboundMessage>,
) -> Result<(), Box<dyn std::error::Error>> {
    match action {
        ThreadboundMessage::TakeSnapshot => {
            let snapshot = take_snapshot()?;
            let msg = GameboundMessage::Snapshot(snapshot);
            // println!("Sending {:?}", msg);
            reply_tx.send(msg)?;
        }
    }

    Ok(())
}

fn handle_gamebound_messages(
    bridge: Res<Bridge>,
    mut observation_events: EventWriter<SomethingObservableHappenedEvent>,
    character_query: Query<&EnvironmentTracker, With<MainCharacter>>,
) {
    let Ok(character) = character_query.get_single() else {
        warn!("Expected single main character, failed");
        while let Ok(_msg) = bridge.receiver.try_recv() { // drain the channel
        }
        return;
    };
    let character_environment = character;
    while let Ok(msg) = bridge.receiver.try_recv() {
        let (msg_kind, GameboundMessage::Snapshot(snapshot)) = ("Snapshot", msg);
        debug!("Received message {}:\n{}", msg_kind, snapshot);

        observation_events.send(SomethingObservableHappenedEvent::UISnapshot {
            snapshot: snapshot.clone(),
            environment_id: Some(character_environment.environment_id),
        });

        match get_persist_file(file!(), "results.txt", Usage::Persist) {
            Ok(mut file) => {
                if let Err(e) = file.write_all(snapshot.to_string().as_bytes()) {
                    error!("Failed to write to file: {:?}", e);
                }
            }
            Err(e) => {
                error!("Failed to open file: {:?}", e);
            }
        }
    }
}

fn trigger_gather_info(
    bridge: ResMut<Bridge>,
    mut cooldown: Local<Option<Timer>>,
    time: Res<Time>,
) {
    match *cooldown {
        Some(ref mut timer) => {
            if timer.tick(time.delta()).just_finished() {
                *cooldown = None;
            }
        }
        None => {
            debug!("Triggering gather info");
            // if let Err(e) = bridge.sender.send(ThreadboundMessage::GatherFocusInfo) {
            //     error!("Failed to send thread message: {:?}", e);
            // }
            if let Err(e) = bridge.sender.send(ThreadboundMessage::TakeSnapshot) {
                error!("Failed to send thread message: {:?}", e);
            }
            *cooldown = Some(Timer::from_seconds(5.0, TimerMode::Once));
        }
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\input\src\active_input_state_plugin.rs

````rust
use bevy::input::gamepad::GamepadEvent;
use bevy::input::keyboard::KeyboardInput;
use bevy::prelude::*;
use cursor_hero_host_event_types::prelude::HostEvent;
use cursor_hero_pointer_types::pointer_action_types::PointerAction;
use cursor_hero_pointer_types::pointer_types::MainPointer;
use leafwing_input_manager::action_state::ActionState;

pub struct ActiveInputStatePlugin;

impl Plugin for ActiveInputStatePlugin {
    fn build(&self, app: &mut App) {
        app.add_state::<InputMethod>();
        app.insert_resource(InputMethod::MouseAndKeyboard);
        app.add_systems(Update, update_input_method);
    }
}

#[derive(Resource, Reflect, Debug, Clone, Copy, Default, Eq, PartialEq, Hash, States)]
#[reflect(Resource)]
pub enum InputMethod {
    #[default]
    MouseAndKeyboard,
    Keyboard,
    Gamepad,
}


fn update_input_method(
    current_state: Res<State<InputMethod>>,
    mut next_state: ResMut<NextState<InputMethod>>,
    mut gamepad_events: EventReader<GamepadEvent>,
    mut host_events: EventReader<HostEvent>,
    mut keyboard_events: EventReader<KeyboardInput>,
    pointer_actions: Query<&ActionState<PointerAction>, With<MainPointer>>,
) {
    let current_input_method = *current_state.get();
    let keyboard_used = keyboard_events.read().count() > 0;
    let gamepad_used = gamepad_events
        .read()
        .filter(|e| match e {
            GamepadEvent::Button(_) => true,
            GamepadEvent::Axis(ax) => ax.value != 0.0,
            _ => false,
        })
        .count()
        > 0;
    let mouse_used = host_events
        .read()
        .filter(|e| **e == HostEvent::MousePhysicallyMoved)
        .count()
        > 0;
    let pointer_moved = pointer_actions.iter().any(|a| {
        a.axis_pair(PointerAction::Move)
            .map(|xy| !xy.x().is_nan() && !xy.y().is_nan() && xy.xy() != Vec2::ZERO)
            .unwrap_or(false)
    });

    
    #[derive(Debug)]
    struct DecisionInfo {
        current_input_method: InputMethod,
        keyboard_used: bool,
        gamepad_used: bool,
        mouse_used: bool,
        pointer_moved: bool,
    }
    let decision_info = DecisionInfo {
        current_input_method,
        keyboard_used,
        gamepad_used,
        mouse_used,
        pointer_moved,
    };
    let proposed_state = match decision_info {
        DecisionInfo {
            gamepad_used: true, ..
        } => InputMethod::Gamepad,
        DecisionInfo {
            current_input_method: InputMethod::MouseAndKeyboard,
            pointer_moved: true,
            ..
        } => InputMethod::Keyboard,
        DecisionInfo {
            mouse_used: true, ..
        }
        | DecisionInfo {
            current_input_method: InputMethod::Gamepad,
            keyboard_used: true,
            ..
        } => InputMethod::MouseAndKeyboard,
        DecisionInfo {
            current_input_method,
            ..
        } => current_input_method,
    };
    if proposed_state != current_input_method {
        next_state.set(proposed_state);
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\observation\src\observe_chat_plugin.rs

````rust
use bevy::prelude::*;
use cursor_hero_character_types::prelude::*;
use cursor_hero_chat_types::prelude::*;
use cursor_hero_environment_types::environment_types::EnvironmentTracker;
use cursor_hero_observation_types::prelude::*;
pub struct ObserveChatPlugin;

impl Plugin for ObserveChatPlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(Update, observe_chat);
    }
}

fn observe_chat(
    mut chat_events: EventReader<ChatEvent>,
    mut observation_events: EventWriter<SomethingObservableHappenedEvent>,
    character_query: Query<(Option<&Name>, Option<&EnvironmentTracker>), With<Character>>,
) {
    for event in chat_events.read() {
        let ChatEvent::Chat {
            character_id,
            message,
        } = event;
        let Ok(character) = character_query.get(*character_id) else {
            warn!(
                "Chat event for unknown character? character_id {:?}",
                character_id
            );
            continue;
        };
        let (character_name, character_environment_tag) = character;

        let Some(character_name) = character_name else {
            warn!(
                "Chat event for character with no name? character_id {:?}",
                character_id
            );
            continue;
        };

        let environment_id = character_environment_tag.map(|tag| tag.environment_id);

        let event = SomethingObservableHappenedEvent::Chat {
            environment_id,
            character_id: *character_id,
            character_name: character_name.to_string(),
            message: message.clone(),
        };
        debug!("Sending event: {:?}", event);
        observation_events.send(event);
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\tools\src\tool_spawning.rs

````rust
use bevy::prelude::*;
use bevy::utils::HashMap;
use bevy_xpbd_2d::prelude::*;
use cursor_hero_host_fs_types::host_fs_types::HostPath;
use cursor_hero_pointer_types::prelude::*;

use cursor_hero_toolbelt_types::prelude::*;
use leafwing_input_manager::prelude::*;
use std::path::Path;
use std::path::PathBuf;

#[derive(Actionlike, PartialEq, Eq, Clone, Copy, Hash, Debug, Reflect)]
pub enum NoInputs {}

impl ToolAction for NoInputs {
    fn default_input_map(_event: &ToolbeltPopulateEvent) -> Option<InputMap<Self>> {
        None
    }
}

pub struct ToolSpawnConfig<T, Action>
where
    T: Bundle,
    Action: ToolAction + Actionlike,
{
    tag: T,
    event: ToolbeltPopulateEvent,
    name: String,
    description: String,
    display_actions: HashMap<String, Vec<UserInput>>,
    texture: Handle<Image>,
    toolbelt_id: Entity,
    starting_state: StartingState,
    size: Option<Vec2>,
    input_map: Option<InputMap<Action>>,
    src_path: Option<PathBuf>,
}

impl<T, Action> ToolSpawnConfig<T, Action>
where
    T: Bundle,
    Action: ToolAction + Actionlike + core::fmt::Debug,
{
    pub fn new(tag: T, toolbelt_id: Entity, event: &ToolbeltPopulateEvent) -> Self {
        Self {
            tag,
            event: *event,
            name: "Unnamed Tool".to_string(),
            description: "Who knows what this does?".to_string(),
            texture: Handle::default(),
            toolbelt_id,
            starting_state: StartingState::Active,
            size: Some(Vec2::new(100.0, 100.0)),
            input_map: None,
            display_actions: HashMap::new(),
            src_path: None,
        }
        .with_input_map(Action::default_input_map(event))
    }

    pub fn with_src_path(mut self, path: PathBuf) -> Self {
        self.src_path = Some(path);
        self
    }

    pub fn with_name(mut self, name: String) -> Self {
        self.name = name;
        self
    }

    pub fn with_description(mut self, description: &'static str) -> Self {
        self.description = description.to_string();
        self
    }

    pub fn guess_name(mut self, file_path: &str) -> Self {
        self.name = Self::format_tool_name_from_source(file_path);
        self
    }

    pub fn with_input_map(mut self, input_map: Option<InputMap<Action>>) -> Self {
        self.display_actions = match input_map {
            None => HashMap::new(),
            Some(ref input_map) => input_map
                .iter()
                .map(|v| (format!("{:?}", v.0), v.1.clone()))
                .collect(),
        };
        self.input_map = input_map;
        self
    }

    fn format_tool_name_from_source(file_path: &str) -> String {
        // Extract the file name from the path
        Self::clean_name(file_path)
            .split('_')
            .map(|word| {
                word.chars()
                    .enumerate()
                    .map(|(i, c)| {
                        if i == 0 {
                            c.to_uppercase().to_string()
                        } else {
                            c.to_string()
                        }
                    })
                    .collect::<String>()
            })
            .collect::<Vec<_>>()
            .join(" ")
    }

    pub fn guess_image(
        mut self,
        file_path: &str,
        asset_server: &Res<AssetServer>,
        extension: &str,
    ) -> Self {
        self.texture = asset_server.load(Self::format_tool_image_from_source(file_path, extension));
        self
    }

    fn clean_name(file_path: &str) -> &str {
        Path::new(file_path)
            .file_stem() // Get the file stem (file name without extension)
            .and_then(|stem| stem.to_str()) // Convert OsStr to &str
            .unwrap_or("")
            .trim_end_matches("_plugin")
            .trim_end_matches("_populate")
            .trim_start_matches("spawn_")
    }

    fn format_tool_image_from_source(file_path: &str, extension: &str) -> String {
        format!(
            "textures/tools/{}.{}",
            Self::clean_name(file_path),
            extension
        )
    }

    pub fn with_asset_image(
        mut self,
        file_name: &'static str,
        asset_server: &Res<AssetServer>,
    ) -> Self {
        self.texture = asset_server.load(format!("textures/tools/{}", file_name));
        self
    }

    pub fn with_image(mut self, texture: Handle<Image>) -> Self {
        self.texture = texture;
        self
    }

    pub fn with_starting_state(mut self, state: StartingState) -> Self {
        self.starting_state = state;
        self
    }

    pub fn with_size(mut self, size: Vec2) -> Self {
        self.size = Some(size);
        self
    }

    pub fn spawn(self, commands: &mut Commands) {
        commands.entity(self.toolbelt_id).with_children(|toolbelt| {
            let mut tool = toolbelt.spawn((
                Tool {
                    name: self.name.clone(),
                    description: self.description,
                    actions: self.display_actions,
                    texture: self.texture.clone(),
                },
                self.tag,
                Name::new(self.name.clone()),
                SpriteBundle {
                    sprite: Sprite {
                        custom_size: self.size,
                        ..default()
                    },
                    texture: self.texture,
                    visibility: Visibility::Hidden,
                    ..default()
                },
                Sensor,
                RigidBody::Kinematic,
                Hoverable,
                Collider::cuboid(100.0, 100.0),
            ));
            if let StartingState::Active = self.starting_state {
                tool.insert(ActiveTool);
            }
            if let Some(src_path) = self.src_path {
                tool.insert(HostPath { path: src_path });
            }
            let input_map = self.input_map.unwrap_or_default();
            tool.insert(InputManagerBundle {
                input_map,
                ..default()
            });
        });
        info!("{:?} => {:?}", self.event, self.name);
    }
}

#[allow(clippy::too_many_arguments)]
fn spawn_tool_impl(
    tool: Tool,
    event: &ToolbeltPopulateEvent,
    commands: &mut Commands,
    toolbelt_id: Entity,
    _asset_server: &Res<AssetServer>,
    tool_component: impl Component,
    input_manager: Option<impl Bundle>,
    starting_state: StartingState,
    custom_size: Option<Vec2>,
) {
    let tool_name = tool.name.clone();
    commands.entity(toolbelt_id).with_children(|toolbelt| {
        let name = Name::new(tool_name.clone());
        let texture = tool.texture.clone();
        let mut tool = toolbelt.spawn((
            tool,
            name,
            SpriteBundle {
                sprite: Sprite {
                    custom_size: custom_size.or(Some(Vec2::new(100.0, 100.0))),
                    ..default()
                },
                texture,
                visibility: Visibility::Hidden,
                ..default()
            },
            tool_component,
            Sensor,
            RigidBody::Kinematic,
            Collider::cuboid(100.0, 100.0),
        ));
        if let StartingState::Active = starting_state {
            tool.insert(ActiveTool);
        }
        if let Some(bundle) = input_manager {
            tool.insert(bundle);
        }
    });
    info!("{:?} => {:?}", event, tool_name);
}

#[allow(clippy::too_many_arguments)]
pub fn spawn_action_tool<T>(
    tool: Tool,
    event: &ToolbeltPopulateEvent,
    commands: &mut Commands,
    toolbelt_id: Entity,
    _character_id: Entity,
    asset_server: &Res<AssetServer>,
    tool_component: impl Component,
    starting_state: StartingState,
    custom_size: Option<Vec2>,
) where
    T: ToolAction + Actionlike,
{
    spawn_tool_impl(
        tool,
        event,
        commands,
        toolbelt_id,
        asset_server,
        tool_component,
        T::default_input_map(event).map(|input_map| InputManagerBundle::<T> {
            input_map,
            ..default()
        }),
        starting_state,
        custom_size,
    )
}

#[derive(Bundle)]
pub struct NoopBundle {}

#[derive(Debug)]
pub enum StartingState {
    Active,
    Inactive,
}
impl StartingState {
    pub fn as_active(&self) -> Option<ActiveTool> {
        match self {
            StartingState::Active => Some(ActiveTool),
            StartingState::Inactive => None,
        }
    }
}

#[allow(clippy::too_many_arguments)]
pub fn spawn_tool(
    tool: Tool,
    event: &ToolbeltPopulateEvent,
    commands: &mut Commands,
    toolbelt_id: Entity,
    _character_id: Entity,
    asset_server: &Res<AssetServer>,
    tool_component: impl Component,
    starting_state: StartingState,
    custom_size: Option<Vec2>,
) {
    spawn_tool_impl(
        tool,
        event,
        commands,
        toolbelt_id,
        asset_server,
        tool_component,
        None::<NoopBundle>,
        starting_state,
        custom_size,
    )
}

````



## D:\Repos\Games\Cursor-Hero\crates\toolbelt\src\tool_help_click.rs

````rust
use bevy::prelude::*;
use cursor_hero_host_fs_types::host_fs_types::HostPath;
use cursor_hero_host_fs_types::host_fs_types::HostPathAction;
use cursor_hero_pointer_types::pointer_click_types::ClickEvent;
use cursor_hero_pointer_types::pointer_click_types::Way;
use cursor_hero_toolbelt_types::toolbelt_types::ToolHelpTrigger;

/// Doesn't work with loadouts without the click tool lol
pub fn help_click_listener(
    mut click_events: EventReader<ClickEvent>,
    help_query: Query<&HostPath, With<ToolHelpTrigger>>,
    mut host_fs_events: EventWriter<HostPathAction>,
) {
    for event in click_events.read() {
        let ClickEvent::Clicked {
            target_id,
            way: Way::Left,
            ..
        } = event
        else {
            continue;
        };
        let Ok(help) = help_query.get(*target_id) else {
            continue;
        };
        let src_path = help;
        let msg = HostPathAction::OpenWithCode {
            path: src_path.clone(),
        };
        info!("Sending message: {:?}", msg);
        host_fs_events.send(msg);
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\ollama\src\ollama_status_plugin.rs

````rust
use std::time::Duration;

use bevy::prelude::*;
use bevy::utils::Instant;
use cursor_hero_ollama_types::prelude::*;

pub struct OllamaStatusPlugin;

impl Plugin for OllamaStatusPlugin {
    fn build(&self, app: &mut App) {
        app.init_resource::<OllamaStatus>();
        app.add_systems(Update, handle_startup_event);
        app.add_systems(Update, periodic_ping);
        app.add_systems(Update, handle_pong);
    }
}

fn handle_startup_event(
    mut status_events: ParamSet<(
        EventReader<OllamaStatusEvent>,
        EventWriter<OllamaStatusEvent>,
    )>,
    mut ollama_status: ResMut<OllamaStatus>,
) {
    let starting = status_events
        .p0()
        .read()
        .any(|event| matches!(event, OllamaStatusEvent::Startup));
    if !starting {
        return;
    }
    status_events.p0().clear();

    *ollama_status = OllamaStatus::Starting {
        instant: Instant::now(),
        timeout: Duration::from_secs(60),
    };
    let event = OllamaStatusEvent::Changed {
        new_value: *ollama_status,
    };
    debug!("Sending event {:?}", event);
    status_events.p1().send(event);
}

fn periodic_ping(
    mut ping_events: EventWriter<OllamaPingEvent>,
    mut last_ping: Local<Option<Instant>>,
) {
    if let Some(instant) = *last_ping {
        if instant.elapsed().as_secs() > 5 {
            ping_events.send(OllamaPingEvent::Ping);
            *last_ping = Some(Instant::now());
        }
    } else {
        ping_events.send(OllamaPingEvent::Ping);
        *last_ping = Some(Instant::now());
    }
}

fn handle_pong(
    mut ping_events: EventReader<OllamaPingEvent>,
    mut status_events: EventWriter<OllamaStatusEvent>,
    mut ollama_status: ResMut<OllamaStatus>,
) {
    for event in ping_events.read() {
        let OllamaPingEvent::Pong { status } = event else {
            continue;
        };
        // identify the new state based on the pong
        let new_status = match (*ollama_status, *status) {
            // if starting, only change to dead if the timeout has been exceeded
            (OllamaStatus::Starting { instant, timeout }, status) => {
                if status == OllamaStatus::Alive {
                    OllamaStatus::Alive
                } else if instant.elapsed() > timeout {
                    OllamaStatus::Dead
                } else {
                    OllamaStatus::Starting { instant, timeout }
                }
            }
            // respect the new status if it's not starting
            _ => *status,
        };

        if *ollama_status != new_status {
            *ollama_status = new_status;
            let event = OllamaStatusEvent::Changed {
                new_value: new_status,
            };
            debug!("Sending event {:?}", event);
            status_events.send(event);
        }
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\glados_tts\src\glados_tts.rs

````rust
use cursor_hero_glados_tts_types::glados_tts_types::GladosTtsStatus;
use reqwest::Client;
use std::error::Error;
use std::process::Command;

pub async fn generate(prompt: &str) -> Result<Vec<u8>, Box<dyn Error>> {
    // Construct the URL for the TTS endpoint
    let url = "http://localhost:8124/synthesize";

    // Create an instance of the reqwest client
    let client = Client::new();

    // Send a GET request to the server
    let response = client.post(url).body(prompt.to_string()).send().await?;

    // Ensure the request was successful and extract the bytes
    let bytes = response.bytes().await?;

    let wav = bytes.to_vec();

    // Ensure the audio decoder won't crash the freaking game
    rodio::Decoder::new(std::io::Cursor::new(wav.clone()))?;

    Ok(wav)
}

pub async fn get_status() -> Result<GladosTtsStatus, Box<dyn Error>> {
    let client = Client::new();
    match client.get("http://localhost:8124/").send().await {
        Ok(res) => match res.status().is_success() {
            true => Ok(GladosTtsStatus::Alive),
            false => Ok(GladosTtsStatus::Dead),
        },
        Err(_) => Ok(GladosTtsStatus::Dead),
    }
}

pub fn start() -> Result<(), Box<dyn Error>> {
    // wt --window 0 --profile PowerShell -- pwsh -Command "cd G:\ml\glados-tts-upstream && conda activate gladostts && python .\engine.py"
    match std::process::Command::new("wt")
        .args([
            "--window",
            "0",
            "--profile",
            "PowerShell",
            "--title",
            "GLaDOS TTS",
            "--",
            "pwsh",
            "-Command",
            "\"cd",
            "G:\\ml\\glados-tts-upstream",
            "&&",
            "conda",
            "activate",
            "gladostts",
            "&&",
            "python",
            ".\\engine.py\"",
        ])
        .spawn()
    {
        Ok(_) => Ok(()),
        Err(e) => Err(Box::new(e)),
    }
}

pub fn start_vscode() -> Result<(), Box<dyn Error>> {
    match Command::new(r"C:\Program Files\Microsoft VS Code\Code.exe")
        .args(["G:\\ml\\glados-tts-upstream"])
        .spawn()
    {
        Ok(_) => Ok(()),
        Err(e) => Err(Box::new(e)),
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\hover\src\screenshot_tool.rs

````rust
use bevy::prelude::*;
use bevy::window::PrimaryWindow;
use bevy_egui::egui;
use bevy_egui::egui::Pos2;
use bevy_egui::EguiContext;
use bevy_egui::EguiContexts;
use bevy_inspector_egui::reflect_inspector::Context;
use bevy_inspector_egui::reflect_inspector::InspectorUi;
use bevy_xpbd_2d::components::Collider;
use bevy_xpbd_2d::components::RigidBody;
use crossbeam_channel::Sender;
use cursor_hero_bevy::prelude::NegativeYVec2;
use cursor_hero_bevy::prelude::NegativeYVec3;
use cursor_hero_camera::camera_plugin::MainCamera;
use cursor_hero_character_types::prelude::*;
use cursor_hero_environment_types::prelude::TrackEnvironmentTag;
use cursor_hero_physics::damping_plugin::MovementDamping;
use cursor_hero_pointer_types::prelude::*;
use cursor_hero_screen::get_image::get_image;
use cursor_hero_screen::get_image::ScreensToImageParam;
use cursor_hero_toolbelt_types::prelude::*;
use cursor_hero_tools::cube_tool::CubeToolInteractable;
use cursor_hero_tools::prelude::*;
use cursor_hero_ui_automation::prelude::find_element_at;
use cursor_hero_ui_automation::prelude::gather_elements_at;
use cursor_hero_ui_automation::prelude::gather_incomplete_ui_tree_starting_deep;
use cursor_hero_ui_automation::prelude::DrillId;
use cursor_hero_ui_automation::prelude::ElementInfo;
use cursor_hero_worker::prelude::Message;
use cursor_hero_worker::prelude::WorkerConfig;
use cursor_hero_worker::prelude::WorkerPlugin;
use itertools::Itertools;
use leafwing_input_manager::prelude::*;
use rand::thread_rng;
use rand::Rng;

pub struct ScreenshotToolPlugin;

impl Plugin for ScreenshotToolPlugin {
    fn build(&self, app: &mut App) {
        app.add_plugins(WorkerPlugin {
            config: WorkerConfig::<ThreadboundMessage, GameboundMessage> {
                name: "screenshot_tool".to_string(),
                is_ui_automation_thread: true,
                handle_threadbound_message,
                ..default()
            },
        });
        app.register_type::<ScreenshotTool>();
        app.register_type::<ScreenshotBrick>();
        app.add_plugins(InputManagerPlugin::<ScreenshotToolAction>::default());
        app.add_systems(Update, toolbelt_events);
        app.add_systems(Update, handle_input);
        app.add_systems(Update, handle_replies);
        app.add_systems(Update, ui);
    }
}

#[derive(Debug, Reflect, Clone, Event)]
enum ThreadboundMessage {
    Capture { world_position: Vec3 },
    CaptureBrick { world_position: Vec3 },
    Print { world_position: Vec3 },
    Fracture { world_position: Vec3 },
}
impl Message for ThreadboundMessage {}

#[derive(Debug, Reflect, Clone, Event)]
enum GameboundMessage {
    Capture {
        ui_tree: ElementInfo,
        hovered_element: ElementInfo,
        world_position: Vec3,
    },
    CaptureBrick {
        ui_tree: ElementInfo,
        hovered_element: ElementInfo,
        world_position: Vec3,
    },
    Print(ElementInfo),
    Fracture {
        data: Vec<(ElementInfo, usize)>,
        world_position: Vec3,
    },
}
impl Message for GameboundMessage {}

#[derive(Component, Reflect, Default)]
struct ScreenshotTool;

#[derive(Actionlike, PartialEq, Eq, Clone, Copy, Hash, Debug, Reflect)]
enum ScreenshotToolAction {
    Capture,
    CaptureBrick,
    Print,
    Fracture,
}
impl ScreenshotToolAction {
    fn default_gamepad_binding(&self) -> UserInput {
        match self {
            Self::Capture => GamepadButtonType::RightTrigger.into(),
            Self::CaptureBrick => GamepadButtonType::South.into(),
            Self::Print => GamepadButtonType::North.into(),
            Self::Fracture => GamepadButtonType::Select.into(),
        }
    }

    fn default_mkb_binding(&self) -> UserInput {
        match self {
            Self::Capture => MouseButton::Left.into(),
            Self::CaptureBrick => MouseButton::Middle.into(),
            Self::Print => MouseButton::Right.into(),
            Self::Fracture => KeyCode::G.into(),
        }
    }
}
impl ToolAction for ScreenshotToolAction {
    fn default_input_map(_event: &ToolbeltPopulateEvent) -> Option<InputMap<ScreenshotToolAction>> {
        let mut input_map = InputMap::default();

        for variant in ScreenshotToolAction::variants() {
            input_map.insert(variant.default_mkb_binding(), variant);
            input_map.insert(variant.default_gamepad_binding(), variant);
        }
        Some(input_map)
    }
}

#[derive(Reflect, Default)]
struct ScreenshotBrickEguiState {
    selected: Option<DrillId>,
    expanded: Vec<DrillId>,
}

#[derive(Component, Reflect)]
struct ScreenshotBrick {
    ui_tree: ElementInfo,
    hero_element: ElementInfo,
    egui_state: ScreenshotBrickEguiState,
}

fn toolbelt_events(
    mut commands: Commands,
    asset_server: Res<AssetServer>,
    mut reader: EventReader<ToolbeltPopulateEvent>,
) {
    for event in reader.read() {
        if event.loadout == ToolbeltLoadout::Inspector {
            ToolSpawnConfig::<ScreenshotTool, ScreenshotToolAction>::new(
                ScreenshotTool,
                event.id,
                event,
            )
            .with_src_path(file!().into())
            .guess_name(file!())
            .guess_image(file!(), &asset_server, "webp")
            .with_description("Turn UI elements into information.")
            .spawn(&mut commands);
        }
    }
}

fn handle_input(
    tools: Query<(&ActionState<ScreenshotToolAction>, &Parent), With<ActiveTool>>,
    toolbelts: Query<&Parent, With<Toolbelt>>,
    characters: Query<&Children, With<Character>>,
    pointers: Query<&GlobalTransform, With<Pointer>>,
    mut bridge: EventWriter<ThreadboundMessage>,
    egui_context_query: Query<&EguiContext, With<PrimaryWindow>>,
) {
    for tool in tools.iter() {
        let (tool_actions, tool_parent) = tool;

        let Ok(toolbelt) = toolbelts.get(tool_parent.get()) else {
            warn!("Tool not inside a toolbelt?");
            continue;
        };
        let toolbelt_parent = toolbelt;

        let Ok(character) = characters.get(toolbelt_parent.get()) else {
            warn!("Toolbelt parent not a character?");
            continue;
        };
        let character_children = character;

        let Some(pointer) = character_children
            .iter()
            .filter_map(|x| pointers.get(*x).ok())
            .next()
        else {
            //TODO: warn if more than one pointer found
            warn!("Character {:?} missing a pointer?", toolbelt_parent.get());
            debug!("Character children: {:?}", character_children);
            continue;
        };
        let pointer_transform = pointer;
        let pointer_translation = pointer_transform.translation();
        let hovering_over_egui = egui_context_query
            .get_single()
            .ok()
            .map(|egui_context| egui_context.clone().get_mut().is_pointer_over_area())
            .unwrap_or(false);
        if hovering_over_egui {
            continue;
        }
        if tool_actions.just_pressed(ScreenshotToolAction::Capture) {
            info!("Capture");
            let msg = ThreadboundMessage::Capture {
                world_position: pointer_translation,
            };
            bridge.send(msg);
        }
        if tool_actions.just_pressed(ScreenshotToolAction::CaptureBrick) {
            info!("CaptureBrick");
            let msg = ThreadboundMessage::CaptureBrick {
                world_position: pointer_translation,
            };
            bridge.send(msg);
        }
        if tool_actions.just_pressed(ScreenshotToolAction::Print) {
            info!("Print");
            let msg = ThreadboundMessage::Print {
                world_position: pointer_translation,
            };
            bridge.send(msg);
        }
        if tool_actions.just_pressed(ScreenshotToolAction::Fracture) {
            info!("Fracture");
            let msg = ThreadboundMessage::Fracture {
                world_position: pointer_translation,
            };
            bridge.send(msg);
        }
    }
}

fn handle_threadbound_message(
    msg: &ThreadboundMessage,
    reply_tx: &Sender<GameboundMessage>,
) -> Result<(), Box<dyn std::error::Error>> {
    match msg {
        ThreadboundMessage::Capture { world_position }
        | ThreadboundMessage::CaptureBrick { world_position } => {
            let mouse_position = world_position.xy().neg_y().as_ivec2();
            debug!("Worker received click: {:?} {:?}", msg, mouse_position);

            let elem = find_element_at(mouse_position)?;
            info!("{} - {}", elem.get_classname()?, elem.get_name()?);

            let id = elem.get_automation_id()?;
            info!("Automation ID: {}", id);
            let gathered = gather_incomplete_ui_tree_starting_deep(elem)?;
            // debug!("Element info: {:?}", element_info);
            let msg = match msg {
                ThreadboundMessage::Capture { world_position } => GameboundMessage::Capture {
                    ui_tree: gathered.ui_tree,
                    hovered_element: gathered.start_info,
                    world_position: *world_position,
                },
                ThreadboundMessage::CaptureBrick { world_position } => {
                    GameboundMessage::CaptureBrick {
                        ui_tree: gathered.ui_tree,
                        hovered_element: gathered.start_info,
                        world_position: *world_position,
                    }
                }
                _ => unreachable!(),
            };
            reply_tx.send(msg)?;
        }
        ThreadboundMessage::Print { world_position } => {
            let mouse_position = world_position.xy().neg_y().as_ivec2();
            debug!("Worker received click: {:?} {:?}", msg, mouse_position);

            let elem = find_element_at(mouse_position)?;
            info!("{:?}", elem);

            // Can we click on elements with this?
            // elem.send_keys(keys, interval) exists!

            // Send the info
            let id = elem.get_automation_id()?;
            info!("Automation ID: {}", id);
            let gathered = gather_incomplete_ui_tree_starting_deep(elem)?;
            reply_tx.send(GameboundMessage::Print(gathered.ui_tree))?;
        }
        ThreadboundMessage::Fracture { world_position } => {
            let mouse_position = world_position.xy().neg_y().as_ivec2();
            debug!("Worker received click: {:?} {:?}", msg, mouse_position);

            let found = gather_elements_at(mouse_position)?;
            let data = found
                .into_iter()
                .filter_map(|(elem, depth)| {
                    gather_incomplete_ui_tree_starting_deep(elem)
                        .ok()
                        .map(|info| (info.start_info, depth))
                })
                .collect();
            reply_tx.send(GameboundMessage::Fracture {
                data,
                world_position: *world_position,
            })?;
        }
    }

    Ok(())
}

fn handle_replies(
    mut commands: Commands,
    mut bridge: EventReader<GameboundMessage>,
    screen_access: ScreensToImageParam,
    asset_server: Res<AssetServer>,
) {
    for msg in bridge.read() {
        match &msg {
            GameboundMessage::Capture {
                ui_tree,
                hovered_element,
                world_position,
            }
            | GameboundMessage::CaptureBrick {
                ui_tree,
                hovered_element,
                world_position,
            } => {
                let (size, pos, texture_region) = match msg {
                    GameboundMessage::Capture { .. } => (
                        hovered_element.bounding_rect.size(),
                        hovered_element.bounding_rect.center().extend(20.0).neg_y(),
                        hovered_element.bounding_rect,
                    ),
                    GameboundMessage::CaptureBrick { .. } => (
                        hovered_element.bounding_rect.size().normalize() * 60.0,
                        *world_position,
                        hovered_element.bounding_rect,
                    ),
                    _ => unreachable!(),
                };
                spawn_brick(
                    &mut commands,
                    ui_tree,
                    hovered_element,
                    size,
                    pos,
                    texture_region,
                    &screen_access,
                    &asset_server,
                );
            }
            GameboundMessage::Print(info) => {
                info!("Received info for element {:?}", info);
                commands.spawn((
                    AudioBundle {
                        source: asset_server.load("sounds/tape recorder eject 4.ogg"),
                        settings: PlaybackSettings::REMOVE,
                    },
                    Name::new(format!("SFX Element - {}", info.name)),
                ));
            }
            GameboundMessage::Fracture {
                data,
                world_position,
            } => {
                info!("Received info with {} elements", data.len());
                if !data.is_empty() {
                    commands.spawn((
                        SpatialBundle {
                            transform: Transform::from_translation(*world_position),
                            ..default()
                        },
                        AudioBundle {
                            source: asset_server.load("sounds/spring strung light 4.ogg"),
                            settings: PlaybackSettings::DESPAWN.with_spatial(true),
                        },
                        Name::new("Fracture Sound"),
                    ));
                }
                for (info, depth) in data {
                    // let Ok(image) = get_image(info.bounding_rect, &access) else {
                    //     continue;
                    // };
                    // let texture_handle = asset_server.add(image);

                    // spawn the element image
                    let mut elem_center_pos = info.bounding_rect.center().extend(*depth as f32);
                    elem_center_pos.y *= -1.0;
                    commands.spawn((
                        SpriteBundle {
                            transform: Transform::from_translation(elem_center_pos),
                            sprite: Sprite {
                                custom_size: Some(info.bounding_rect.size()),
                                color: Color::hsl(thread_rng().gen_range(0.0..360.0), 0.5, 0.5),
                                ..default()
                            },
                            // texture: texture_handle,
                            ..default()
                        },
                        CubeToolInteractable,
                        RigidBody::Dynamic,
                        Collider::cuboid(info.bounding_rect.width(), info.bounding_rect.height()),
                        MovementDamping::default(),
                        Name::new(format!("Element - {}", info.name)),
                    ));
                }
            }
        }
    }
}

fn spawn_brick(
    commands: &mut Commands,
    ui_tree: &ElementInfo,
    hero_element: &ElementInfo,
    size: Vec2,
    pos: Vec3,
    texture_region: Rect,
    screen_access: &ScreensToImageParam,
    asset_server: &Res<AssetServer>,
) {
    let Ok(image) = get_image(texture_region, screen_access) else {
        return;
    };
    let texture_handle = asset_server.add(image);
    let expanded = ui_tree
        .get_descendents()
        .iter()
        .chain([ui_tree].iter())
        .filter(|x| x.children.is_some())
        .map(|x| x.drill_id.clone())
        .collect();
    commands.spawn((
        SpriteBundle {
            transform: Transform::from_translation(pos),
            sprite: Sprite {
                custom_size: Some(size),
                ..default()
            },
            texture: texture_handle,
            ..default()
        },
        AudioBundle {
            source: asset_server.load("sounds/spring strung light 4.ogg"),
            settings: PlaybackSettings::REMOVE.with_spatial(true),
        },
        // FloatyName {
        //     text: element_info.name.clone(),
        //     vertical_offset: 40.0,
        //     appearance: NametagAppearance::Databrick,
        // },
        Hoverable,
        Clickable,
        CubeToolInteractable,
        RigidBody::Dynamic,
        TrackEnvironmentTag,
        ScreenshotBrick {
            ui_tree: ui_tree.clone(),
            hero_element: hero_element.clone(),
            egui_state: ScreenshotBrickEguiState {
                selected: Some(hero_element.drill_id.clone()),
                expanded,
            },
        },
        Collider::cuboid(size.x, size.y),
        MovementDamping::default(),
        Name::new(format!("Element - {}", hero_element.name)),
    ));
}

fn ui(
    mut commands: Commands,
    screen_access: ScreensToImageParam,
    asset_server: Res<AssetServer>,
    mut contexts: EguiContexts,
    mut brick_query: Query<(
        Entity,
        &mut ScreenshotBrick,
        &Sprite,
        &Name,
        &GlobalTransform,
    )>,
    camera_query: Query<(&GlobalTransform, &Camera), With<MainCamera>>,
    type_registry: Res<AppTypeRegistry>,
) {
    let Ok(camera) = camera_query.get_single() else {
        warn!("No camera found");
        return;
    };
    let (camera_transform, camera) = camera;

    let ctx = contexts.ctx_mut();
    // let scale = (camera_transform.compute_transform().scale.x * 1.0).round();
    // debug!("Scale: {}", scale);
    // ctx.set_zoom_factor(scale);

    if brick_query.is_empty() {
        return;
    }

    let mut cx = Context {
        world: None,
        queue: None,
    };

    let type_registry = type_registry.0.clone();
    let type_registry = type_registry.read();

    let mut inspector = InspectorUi::for_bevy(&type_registry, &mut cx);

    for brick in brick_query.iter_mut() {
        let (brick_id, mut brick, brick_sprite, brick_name, brick_global_transform) = brick;
        let brick_global_translation = brick_global_transform.translation();
        let popout_pos = brick_global_translation
            + Vec3::new(
                brick_sprite.custom_size.unwrap_or_default().x + 50.0,
                0.0,
                0.0,
            );
        let egui_pos = camera
            .world_to_viewport(camera_transform, brick_global_translation)
            .unwrap_or_default();

        let id = egui::Id::new(brick_id);

        egui::Window::new(brick_name.chars().take(64).collect::<String>())
            .id(id)
            .fixed_pos(Pos2::new(egui_pos.x, egui_pos.y))
            .default_width(1200.0)
            // .resizable(true)
            .show(ctx, |ui| {
                egui::SidePanel::left(id.with("tree"))
                    .resizable(true)
                    .width_range(100.0..=4000.0)
                    .default_width(600.0)
                    .show_inside(ui, |ui| {
                        ui.vertical_centered(|ui| {
                            ui.heading("UI Tree");
                        });
                        egui::ScrollArea::both().show(ui, |ui| {
                            let id = id.with(brick.ui_tree.runtime_id.clone());

                            let mut temp_egui_state = std::mem::take(&mut brick.egui_state);
                            let mut temp_info = std::mem::take(&mut brick.ui_tree);
                            ui_for_element_info(
                                &mut temp_egui_state,
                                id,
                                &mut commands,
                                &screen_access,
                                &asset_server,
                                ui,
                                &mut temp_info,
                                &mut inspector,
                                &popout_pos,
                            );
                            brick.egui_state = temp_egui_state;
                            brick.ui_tree = temp_info;

                            ui.allocate_space(ui.available_size());
                        });
                    });

                egui::TopBottomPanel::bottom(id.with("invisible bottom panel"))
                    .show_separator_line(false)
                    .show_inside(ui, |_| ());

                egui::CentralPanel::default().show_inside(ui, |ui| {
                    ui.heading("AHOY!");
                    let id = brick.egui_state.selected.clone();
                    if let Some(id) = id
                        && let Some(x) = brick.ui_tree.lookup_drill_id_mut(id)
                    {
                        inspector.ui_for_reflect(x, ui);
                    }
                    // inspector.ui_for_reflect_readonly(&data, ui);
                });
            });
    }
}

#[derive(Reflect, Debug)]
struct ElementUIData {
    runtime_id: String,
    frick: String,
}

#[allow(clippy::too_many_arguments)]
fn ui_for_element_info(
    state: &mut ScreenshotBrickEguiState,
    id: egui::Id,
    commands: &mut Commands,
    screen_access: &ScreensToImageParam,
    asset_server: &Res<AssetServer>,
    ui: &mut egui::Ui,
    element_info: &mut ElementInfo,
    _inspector: &mut InspectorUi,
    popout_pos: &Vec3,
) {
    egui::collapsing_header::CollapsingState::load_with_default_open(
        ui.ctx(),
        id,
        state.expanded.contains(&element_info.drill_id),
    )
    .show_header(ui, |ui| {
        let mut selected = state.selected == Some(element_info.drill_id.clone());
        if ui
            .toggle_value(
                &mut selected,
                format!(
                    "{:?} | {}",
                    element_info.name, element_info.localized_control_type
                ),
            )
            .changed()
        {
            state.selected = if selected {
                Some(element_info.drill_id.clone())
            } else {
                None
            };
        };
    })
    .body(|ui| {
        // if ui.button("Popout").clicked() {
        //     spawn_brick(
        //         commands,
        //         element_info,
        //         element_info.bounding_rect.size(),
        //         *popout_pos,
        //         screen_access,
        //         asset_server,
        //     )
        // }

        if let Some(children) = &mut element_info.children {
            for child in children.iter_mut() {
                ui_for_element_info(
                    state,
                    id.with(child.runtime_id.clone()),
                    commands,
                    screen_access,
                    asset_server,
                    ui,
                    child,
                    _inspector,
                    popout_pos,
                );
            }
        }
    });
}

````



## D:\Repos\Games\Cursor-Hero\crates\math\src\corner.rs

````rust
use bevy::reflect::Reflect;

#[derive(Debug, Reflect, Eq, Clone, PartialEq, Hash)]
pub enum Corner {
    TopLeft,
    TopRight,
    BottomLeft,
    BottomRight,
}
impl Corner {
    pub fn variants() -> [Self; 4] {
        [
            Self::TopLeft,
            Self::TopRight,
            Self::BottomLeft,
            Self::BottomRight,
        ]
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\hover\src\hover_tool.rs

````rust
use bevy::prelude::*;
use cursor_hero_toolbelt_types::prelude::*;
use cursor_hero_tools::prelude::*;

use crate::hover_ui_automation_plugin::HoverInfo;

pub struct HoverToolPlugin;

impl Plugin for HoverToolPlugin {
    fn build(&self, app: &mut App) {
        app.register_type::<HoverTool>();
        app.add_systems(Update, toolbelt_events);
        app.add_systems(Update, tick);
    }
}

#[derive(Component, Reflect, Default)]
struct HoverTool;

fn toolbelt_events(
    mut commands: Commands,
    asset_server: Res<AssetServer>,
    mut reader: EventReader<ToolbeltPopulateEvent>,
) {
    for event in reader.read() {
        if event.loadout == ToolbeltLoadout::Inspector {
            ToolSpawnConfig::<HoverTool, NoInputs>::new(HoverTool, event.id, event)
                .with_src_path(file!().into())
                .guess_name(file!())
                .guess_image(file!(), &asset_server, "png")
                .with_description("UI hover visuals")
                .spawn(&mut commands);
        }
    }
}

fn tick(
    tool_query: Query<Entity, (With<ActiveTool>, With<HoverTool>)>,
    mut hover_info: ResMut<HoverInfo>,
) {
    if tool_query.iter().next().is_some() {
        if !hover_info.is_enabled() {
            info!("Enabling hover info");
            hover_info.set_enabled(true);
        }
    } else if hover_info.is_enabled() {
        info!("Disabling hover info");
        hover_info.set_enabled(false);
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\winutils\src\win_errors.rs

````rust
use std::rc::Rc;
use std::string::FromUtf16Error;
use widestring::error::ContainsNul;
use windows::Win32::Foundation::BOOL;

#[derive(Debug, Clone)]
pub enum Error {
    Windows(windows::core::Error),
    WideString(ContainsNul<u16>),
    FromUtf16Error,
    Described(Rc<Error>, String),
    ImageContainerNotBigEnough,
    Other(Rc<dyn std::error::Error>),
}
impl std::fmt::Display for Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Error::Windows(e) => write!(f, "Windows error: {}", e.message()),
            Error::WideString(e) => write!(f, "Wide string error: {}", e),
            Error::FromUtf16Error => write!(f, "FromUtf16Error"),
            Error::Described(e, description) => write!(f, "{}: {}", e, description),
            Error::ImageContainerNotBigEnough => write!(f, "Image container not big enough"),
            Error::Other(e) => write!(f, "(other) {}", e),
        }
    }
}
impl std::error::Error for Error {}
impl Error {
    pub fn from_win32() -> Self {
        Error::Windows(windows::core::Error::from_win32())
    }
    pub fn with_description(self, description: String) -> Self {
        Error::Described(Rc::new(self), description)
    }
}
impl From<windows::core::Error> for Error {
    fn from(e: windows::core::Error) -> Self {
        Error::Windows(e)
    }
}
impl From<ContainsNul<u16>> for Error {
    fn from(e: ContainsNul<u16>) -> Self {
        Error::WideString(e)
    }
}
impl From<FromUtf16Error> for Error {
    fn from(_e: FromUtf16Error) -> Self {
        Error::FromUtf16Error
    }
}

pub type Result<T> = std::result::Result<T, Error>;

pub trait WithDescription<T> {
    fn with_description(self, description: String) -> Result<T>;
}
impl<T> WithDescription<T> for windows::core::Result<T> {
    fn with_description(self, description: String) -> Result<T> {
        self.map_err(|e| Error::Windows(e).with_description(description))
    }
}

pub trait OkWithDescription<T> {
    fn ok_with_description(self, description: String) -> Result<T>;
}
impl OkWithDescription<()> for BOOL {
    fn ok_with_description(self, description: String) -> Result<()> {
        self.ok()
            .map_err(|e| Error::Windows(e).with_description(description))
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\ollama\src\ollama_inference_plugin.rs

````rust
use bevy::prelude::*;
use crossbeam_channel::bounded;
use crossbeam_channel::Receiver;
use crossbeam_channel::Sender;
use cursor_hero_inference_types::prelude::*;
use cursor_hero_text_asset_types::prelude::*;
use std::thread;

pub struct OllamaInferencePlugin;

impl Plugin for OllamaInferencePlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(Startup, create_worker_thread);
        app.add_systems(Update, bridge_generate_requests);
        app.add_systems(Update, bridge_generate_responses);
    }
}

#[derive(Debug)]
enum GameboundMessage {
    Response {
        session_id: Entity,
        prompt: MaterializedTextPrompt,
        response: String,
    },
}

#[derive(Debug)]
enum ThreadboundMessage {
    Generate {
        session_id: Entity,
        prompt: MaterializedTextPrompt,
    },
}

#[derive(Resource)]
struct Bridge {
    pub sender: Sender<ThreadboundMessage>,
    pub receiver: Receiver<GameboundMessage>,
}

fn create_worker_thread(mut commands: Commands) {
    let (game_tx, game_rx) = bounded::<_>(10);
    let (thread_tx, thread_rx) = bounded::<_>(10);
    commands.insert_resource(Bridge {
        sender: thread_tx,
        receiver: game_rx,
    });

    let game_tx_clone = game_tx.clone();
    thread::Builder::new()
        .name("Ollama thread".to_string())
        .spawn(move || {
            let rt = tokio::runtime::Runtime::new().unwrap();
            rt.block_on(async {
                let game_tx = game_tx_clone;
                loop {
                    let msg = match thread_rx.recv() {
                        Ok(msg) => msg,
                        Err(_) => {
                            error!("Threadbound channel failure, exiting");
                            break;
                        }
                    };
                    match msg {
                        ThreadboundMessage::Generate { session_id, prompt } => {
                            debug!("Worker received generate request for session {:?}, generating response", session_id);
                            let data = match crate::ollama::generate(&prompt.materialized, prompt.prompt.options()).await {
                                Ok(data) => data,
                                Err(e) => {
                                    error!("Failed to generate: {:?}", e);
                                    continue;
                                }
                            };
                            if let Err(e) = game_tx.send(GameboundMessage::Response {
                                session_id,
                                prompt: prompt.clone(),
                                response: data,
                            }) {
                                error!("Gamebound channel failure, exiting: {:?}", e);
                                break;
                            }
                        }
                    }
                    std::thread::sleep(std::time::Duration::from_millis(50));
                }
            });
        })
        .expect("Failed to spawn thread");
}

fn bridge_generate_requests(
    bridge: ResMut<Bridge>,
    mut events: EventReader<TextInferenceEvent>,
    prompts: Res<TextPromptHandles>,
    text_assets: Res<Assets<TextAsset>>,
) {
    for event in events.read() {
        if let TextInferenceEvent::Request { session_id, prompt } = event {
            debug!(
                "Received generate request for session {:?}, sending over bridge to worker thread",
                session_id
            );

            // we gotta load the prompt from the asset server to materialize it before we can send it
            let handle = match prompt {
                TextPrompt::Raw { .. } => &prompts.raw,
                TextPrompt::Chat { .. } => &prompts.chat,
            };
            let prompt_asset = match text_assets.get(handle) {
                Some(asset) => asset,
                None => {
                    error!(
                        "Failed to load prompt asset {:?} for prompt type {:?}",
                        handle,
                        std::any::type_name_of_val(&prompt)
                    );
                    continue;
                }
            };
            let materialized_prompt = MaterializedTextPrompt {
                prompt: prompt.clone(),
                materialized: match prompt {
                    TextPrompt::Raw { content, .. } => {
                        prompt_asset.value.replace("{{content}}", content)
                    }
                    TextPrompt::Chat { chat_history, .. } => {
                        prompt_asset.value.replace("{{chat_history}}", chat_history)
                    }
                },
            };

            info!(
                "Sending prompt to text generation worker:\n{}",
                materialized_prompt.materialized
            );

            if let Err(e) = bridge.sender.send(ThreadboundMessage::Generate {
                session_id: *session_id,
                prompt: materialized_prompt,
            }) {
                error!("Threadbound channel failure: {}", e);
            }
        }
    }
}

fn bridge_generate_responses(bridge: ResMut<Bridge>, mut events: EventWriter<TextInferenceEvent>) {
    for msg in bridge.receiver.try_iter() {
        match msg {
            GameboundMessage::Response {
                session_id,
                prompt,
                response,
            } => {
                let event = TextInferenceEvent::Response {
                    session_id,
                    response,
                    prompt,
                };
                debug!("Received bridge response, sending game event {:?}", event);
                events.send(event);
            }
        }
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\ui_automation_types\src\edge_ui_types.rs

````rust
use bevy::prelude::*;
use itertools::Itertools;
use serde::Deserialize;
use serde::Serialize;
use std::collections::VecDeque;
use std::fmt;
use std::fmt::Display;
use std::fmt::Formatter;
use uiautomation::UIElement;

pub enum EdgeResolveError {
    BadChildCount { tried_accessing: u32 },
    UI(uiautomation::Error),
    UnknownSideTabKind(String),
    UnknownState,
}
impl From<u32> for EdgeResolveError {
    fn from(tried_accessing: u32) -> Self {
        EdgeResolveError::BadChildCount { tried_accessing }
    }
}

impl From<uiautomation::Error> for EdgeResolveError {
    fn from(e: uiautomation::Error) -> Self {
        EdgeResolveError::UI(e)
    }
}
impl TryFrom<VecDeque<UIElement>> for EdgeCrawlState {
    type Error = EdgeResolveError;
    fn try_from(mut kids: VecDeque<UIElement>) -> Result<Self, Self::Error> {
        let state = match kids.len() {
            2 => EdgeCrawlState::LeftTabClosed {
                tabs: kids.pop_front().ok_or(0u32)?,
                editor: kids.pop_front().ok_or(1u32)?,
            },
            3 => EdgeCrawlState::LeftTabOpen {
                side_nav_tabs: kids.pop_front().ok_or(0u32)?,
                side_nav_view: kids.pop_front().ok_or(1u32)?,
                editor: kids.pop_front().ok_or(2u32)?,
            },
            _ => EdgeCrawlState::Unknown,
        };
        Ok(state)
    }
}

#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]
pub enum View {
    Explorer {
        sticky: Vec<ExplorerItem>,
        items: Vec<ExplorerItem>,
    },
    Unknown {},
}
impl Display for View {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        match self {
            View::Explorer { sticky, items } => {
                writeln!(f, "Explorer entries:")?;
                writeln!(f, "=== BEGIN STICKY ===")?;
                for item in sticky.iter().sorted_by_key(|x| x.bounds.min.y) {
                    writeln!(
                        f,
                        "{}- {} ({})",
                        " ".repeat(item.ui_level as usize),
                        item.label.clone()
                            + if matches!(item.kind, ExplorerItemKind::Directory { .. }) {
                                "/"
                            } else {
                                ""
                            },
                        item.path
                    )?;
                }
                writeln!(f, "=== END STICKY ===")?;
                for item in items.iter().sorted_by_key(|x| x.bounds.min.y) {
                    writeln!(
                        f,
                        "{}- {} ({})",
                        " ".repeat(item.ui_level as usize),
                        item.label.clone()
                            + if matches!(item.kind, ExplorerItemKind::Directory { .. }) {
                                "/"
                            } else {
                                ""
                            },
                        item.path
                    )?;
                }
                fmt::Result::Ok(())
            }
            View::Unknown {} => {
                writeln!(f, "Unknown view")?;
                fmt::Result::Ok(())
            }
        }
    }
}

pub enum EdgeCrawlState {
    LeftTabClosed {
        tabs: UIElement,
        editor: UIElement,
    },
    LeftTabOpen {
        side_nav_tabs: UIElement,
        side_nav_view: UIElement,
        editor: UIElement,
    },
    Unknown,
}
impl EdgeCrawlState {
    pub fn get_side_nav_tabs_root_elem(&self) -> Result<&UIElement, EdgeResolveError> {
        match self {
            EdgeCrawlState::LeftTabClosed { tabs, .. } => Ok(tabs),
            EdgeCrawlState::LeftTabOpen {
                side_nav_tabs: tabs,
                ..
            } => Ok(tabs),
            EdgeCrawlState::Unknown => Err(EdgeResolveError::UnknownState),
        }
    }
    pub fn get_side_nav_view_root_elem(&self) -> Result<&UIElement, EdgeResolveError> {
        match self {
            EdgeCrawlState::LeftTabClosed { tabs, .. } => Ok(tabs),
            EdgeCrawlState::LeftTabOpen {
                side_nav_view: view,
                ..
            } => Ok(view),
            EdgeCrawlState::Unknown => Err(EdgeResolveError::UnknownState),
        }
    }
    pub fn get_editor_root_elem(&self) -> Result<&UIElement, EdgeResolveError> {
        match self {
            EdgeCrawlState::LeftTabClosed { editor, .. } => Ok(editor),
            EdgeCrawlState::LeftTabOpen { editor, .. } => Ok(editor),
            EdgeCrawlState::Unknown => Err(EdgeResolveError::UnknownState),
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]
pub struct EdgeWindowHeader {}

#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]
pub struct EdgeWindowBody {
    pub editor_area: EditorArea,
    pub side_nav: Vec<SideTab>,
}

#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]
pub struct EdgeWindowFooter {
    pub cursor_position: IVec2,
}

#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]
pub struct EdgeWindow {
    pub focused: bool,
    pub header: EdgeWindowHeader,
    pub body: EdgeWindowBody,
    pub footer: EdgeWindowFooter,
}

impl Display for EdgeWindow {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        writeln!(
            f,
            ":D :D :D Visual Studio Code {} owo owo owo",
            if self.focused { "(focused)" } else { "" }
        )?;

        writeln!(f, "Side tabs:")?;
        for tab in self.body.side_nav.iter() {
            match tab {
                SideTab::Open { kind, view } => {
                    writeln!(f, "- (open) {:?} {{{{\n{}}}}}", kind, view)?;
                }
                SideTab::Closed { kind } => {
                    writeln!(f, "- {:?}", kind)?;
                }
            }
        }

        writeln!(f, "Editor groups:")?;
        for (i, group) in self.body.editor_area.groups.iter().enumerate() {
            writeln!(f, "Group {} tabs:", i + 1)?;
            for tab in group.tabs.iter() {
                if tab.active {
                    writeln!(f, "- (active) {}", tab.title)?;
                } else {
                    writeln!(f, "- {}", tab.title)?;
                }
            }
            if let Some(ref content) = group.content {
                writeln!(
                    f,
                    "Group {} buffer:\n=======\n{}\n=======",
                    i + 1,
                    content.content
                )?;
            }
        }

        writeln!(f, "Cursor position: {:?}", self.footer.cursor_position)?;

        fmt::Result::Ok(())
    }
}

#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]
pub enum SideTab {
    Closed { kind: SideTabKind },
    Open { kind: SideTabKind, view: View },
}

#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]
pub enum ExplorerItemKind {
    File,
    Directory { expanded: bool },
}

#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]
pub struct ExplorerItem {
    pub label: String,
    pub path: String,
    pub ui_position_in_set: u32,
    pub ui_size_of_set: u32,
    pub ui_level: u32,
    pub bounds: IRect,
    pub kind: ExplorerItemKind,
}

#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]
pub struct EditorArea {
    pub groups: Vec<EditorGroup>,
}
impl EditorArea {
    pub fn get_expected_automation_id() -> &'static str {
        "workbench.parts.editor"
    }
}

#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]
pub struct EditorGroup {
    pub tabs: Vec<EditorTab>,
    pub content: Option<EditorContent>,
}

#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]
pub struct EditorTab {
    pub title: String,
    pub active: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]
pub struct EditorContent {
    pub content: String,
}

#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]
pub enum SideTabKind {
    Explorer,
    Search,
    SourceControl,
    RunAndDebug,
    Extensions,
    GitLens,
    Azure,
    Jupyter,
    Chat,
    GitHubActions,
    Todo,
}
impl SideTabKind {
    pub fn variants() -> Vec<SideTabKind> {
        vec![
            SideTabKind::Explorer,
            SideTabKind::Search,
            SideTabKind::SourceControl,
            SideTabKind::RunAndDebug,
            SideTabKind::Extensions,
            SideTabKind::GitLens,
            SideTabKind::Azure,
            SideTabKind::Jupyter,
            SideTabKind::Chat,
            SideTabKind::GitHubActions,
            SideTabKind::Todo,
        ]
    }
    pub fn get_view_automation_id(&self) -> Option<&str> {
        match self {
            SideTabKind::Explorer => Some("workbench.view.explorer"),
            _ => None,
        }
    }
}
impl TryFrom<String> for SideTabKind {
    type Error = EdgeResolveError;
    fn try_from(s: String) -> Result<Self, Self::Error> {
        let before_first_lparen = s.split_once(" (").map(|x| x.0).unwrap_or(s.as_str());
        match before_first_lparen {
            "Explorer" => Ok(SideTabKind::Explorer),
            "Search" => Ok(SideTabKind::Search),
            "Source Control" => Ok(SideTabKind::SourceControl),
            "Run and Debug" => Ok(SideTabKind::RunAndDebug),
            "Extensions" => Ok(SideTabKind::Extensions),
            "GitLens" => Ok(SideTabKind::GitLens),
            "Azure" => Ok(SideTabKind::Azure),
            "Jupyter" => Ok(SideTabKind::Jupyter),
            "Chat" => Ok(SideTabKind::Chat),
            "GitHub Actions" => Ok(SideTabKind::GitHubActions),
            "TODOs" => Ok(SideTabKind::Todo),
            _ => Err(EdgeResolveError::UnknownSideTabKind(s)),
        }
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\glados_tts\src\glados_tts_button_plugin.rs

````rust
use bevy::prelude::*;
use bevy_xpbd_2d::prelude::*;
use cursor_hero_environment_types::prelude::*;
use cursor_hero_glados_tts_types::prelude::*;
use cursor_hero_math::prelude::Lerp;
use cursor_hero_pointer_types::prelude::*;

use crate::glados_tts;
pub struct GladosTtsButtonPlugin;

impl Plugin for GladosTtsButtonPlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(Update, populate_new_host_environments);
        app.add_systems(Update, update_visuals);
        app.add_systems(Update, status_button_click);
        app.add_systems(Update, vscode_button_click);
        app.add_systems(Update, handle_vscode_events);
    }
}

fn populate_new_host_environments(
    mut commands: Commands,
    mut environment_events: EventReader<PopulateEnvironmentEvent>,
    environment_query: Query<&HostEnvironment>,
    asset_server: Res<AssetServer>,
) {
    for event in environment_events.read() {
        if !environment_query.contains(event.environment_id) {
            continue;
        }
        info!(
            "Adding button to new host environment {:?}",
            event.environment_id
        );
        commands
            .entity(event.environment_id)
            .with_children(|parent| {
                parent
                    .spawn((
                        GladosTtsStatusButton::default(),
                        Name::new("GLaDOS TTS Button"),
                        SpriteBundle {
                            sprite: Sprite {
                                custom_size: Some(Vec2::new(200.0, 100.0)),
                                color: Color::PURPLE,
                                ..default()
                            },
                            transform: Transform::from_translation(Vec3::new(
                                1920.0 / 2.0 - 600.0,
                                -1080.0 - 200.0,
                                0.0,
                            )),
                            ..default()
                        },
                        Clickable,
                        Hoverable,
                        RigidBody::Static,
                        Sensor,
                        Collider::cuboid(200.0, 100.0),
                    ))
                    .with_children(|parent| {
                        parent.spawn((Text2dBundle {
                            text: Text::from_section(
                                "GLaDOS TTS Server Control".to_string(),
                                TextStyle {
                                    font: asset_server.load("fonts/FiraSans-Bold.ttf"),
                                    font_size: 32.0,
                                    color: Color::WHITE,
                                },
                            )
                            .with_alignment(TextAlignment::Center),
                            transform: Transform::from_xyz(0.0, 70.0, 1.0),
                            ..default()
                        },));
                    });
                parent
                    .spawn((
                        GladosTtsVscodeButton::default(),
                        Name::new("GLaDOS TTS VSCode Button"),
                        SpriteBundle {
                            sprite: Sprite {
                                custom_size: Some(Vec2::new(200.0, 100.0)),
                                color: Color::rgb(0.0, 0.6, 0.8),
                                ..default()
                            },
                            transform: Transform::from_translation(Vec3::new(
                                1920.0 / 2.0 - 600.0,
                                -1080.0 - 350.0,
                                0.0,
                            )),
                            ..default()
                        },
                        Clickable,
                        Hoverable,
                        RigidBody::Static,
                        Sensor,
                        Collider::cuboid(200.0, 100.0),
                    ))
                    .with_children(|parent| {
                        parent.spawn((Text2dBundle {
                            text: Text::from_section(
                                "open in vscode".to_string(),
                                TextStyle {
                                    font: asset_server.load("fonts/FiraSans-Bold.ttf"),
                                    font_size: 32.0,
                                    color: Color::WHITE,
                                },
                            )
                            .with_alignment(TextAlignment::Center),
                            transform: Transform::from_xyz(0.0, 0.0, 1.0),
                            ..default()
                        },));
                    });
            });
    }
}

fn update_visuals(
    mut events: EventReader<GladosTtsStatusEvent>,
    mut button_query: Query<(&mut Sprite, &Children, &mut GladosTtsStatusButton)>,
    mut button_text_query: Query<&mut Text>,
) {
    for event in events.read() {
        let GladosTtsStatusEvent::Changed { new_value: status } = event else {
            continue;
        };
        debug!("Updating GladosTts Server Control visuals to {:?}", status);
        for button in button_query.iter_mut() {
            let (mut button_sprite, button_children, mut button) = button;
            button.visual_state = match button.visual_state {
                GladosTtsStatusButtonVisualState::Default { .. } => {
                    GladosTtsStatusButtonVisualState::Default { status: *status }
                }
                GladosTtsStatusButtonVisualState::Hovered { .. } => {
                    GladosTtsStatusButtonVisualState::Hovered { status: *status }
                }
                GladosTtsStatusButtonVisualState::Pressed { .. } => {
                    GladosTtsStatusButtonVisualState::Pressed { status: *status }
                }
            };
            match status {
                GladosTtsStatus::Alive => {
                    button_sprite.color = Color::GREEN;
                }
                GladosTtsStatus::Dead => {
                    button_sprite.color = Color::RED;
                }
                GladosTtsStatus::Unknown => {
                    button_sprite.color = Color::PURPLE;
                }
                GladosTtsStatus::Starting { instant, timeout } => {
                    button_sprite.color = Color::YELLOW
                        * (1.0, 0.1).lerp(instant.elapsed().as_secs_f32() / timeout.as_secs_f32());
                }
            }
            for child in button_children.iter() {
                if let Ok(mut text) = button_text_query.get_mut(*child) {
                    match status {
                        GladosTtsStatus::Alive => {
                            text.sections[0].value =
                                "GLaDOS TTS Server Control (Alive)".to_string();
                        }
                        GladosTtsStatus::Dead => {
                            text.sections[0].value = "GLaDOS TTS Server Control (Dead)".to_string();
                        }
                        GladosTtsStatus::Unknown => {
                            text.sections[0].value =
                                "GLaDOS TTS Server Control (Unknown)".to_string();
                        }
                        GladosTtsStatus::Starting { instant, .. } => {
                            text.sections[0].value = format!(
                                "GLaDOS TTS Server Control (Starting {}s ago)",
                                instant.elapsed().as_secs()
                            );
                        }
                    }
                }
            }
        }
    }

    for button in button_query.iter_mut() {
        let (mut sprite, children, button) = button;
        // if the visual state status is starting, update the text to show the time elapsed
        let (GladosTtsStatusButtonVisualState::Default {
            status: GladosTtsStatus::Starting { instant, timeout },
        }
        | GladosTtsStatusButtonVisualState::Hovered {
            status: GladosTtsStatus::Starting { instant, timeout },
        }
        | GladosTtsStatusButtonVisualState::Pressed {
            status: GladosTtsStatus::Starting { instant, timeout },
        }) = button.visual_state
        else {
            continue;
        };
        sprite.color = Color::YELLOW
            * (1.0, 0.1).lerp(instant.elapsed().as_secs_f32() / timeout.as_secs_f32());
        for child in children.iter() {
            if let Ok(mut text) = button_text_query.get_mut(*child) {
                text.sections[0].value = format!(
                    "GladosTts Server Control (Starting {}s ago)",
                    instant.elapsed().as_secs()
                );
            }
        }
    }
}

fn status_button_click(
    mut click_events: EventReader<ClickEvent>,
    button_query: Query<&GladosTtsStatusButton>,
    mut status_events: EventWriter<GladosTtsStatusEvent>,
) {
    for event in click_events.read() {
        let ClickEvent::Clicked {
            target_id,
            pointer_id: _,
            way,
        } = event
        else {
            continue;
        };
        if way != &Way::Left {
            continue;
        }
        if let Ok(button) = button_query.get(*target_id) {
            info!("GladosTts Server Control clicked");
            // if the button visual status is alive, do nothing
            match button.visual_state {
                GladosTtsStatusButtonVisualState::Default {
                    status: GladosTtsStatus::Alive,
                }
                | GladosTtsStatusButtonVisualState::Hovered {
                    status: GladosTtsStatus::Alive,
                }
                | GladosTtsStatusButtonVisualState::Pressed {
                    status: GladosTtsStatus::Alive,
                } => {
                    warn!("GladosTts Server Control is already alive");
                    continue;
                }
                _ => {}
            }
            let event = GladosTtsStatusEvent::Startup;
            debug!("Sending event {:?}", event);
            status_events.send(event);
        }
    }
}

fn vscode_button_click(
    mut click_events: EventReader<ClickEvent>,
    button_query: Query<&GladosTtsVscodeButton>,
    mut vscode_events: EventWriter<GladosTtsVscodeEvent>,
) {
    for event in click_events.read() {
        let ClickEvent::Clicked {
            target_id,
            pointer_id: _,
            way,
        } = event
        else {
            continue;
        };
        if way != &Way::Left {
            continue;
        }
        if button_query.get(*target_id).is_ok() {
            info!("GladosTts vscode clicked");
            let event = GladosTtsVscodeEvent::Startup;
            debug!("Sending event {:?}", event);
            vscode_events.send(event);
        }
    }
}

fn handle_vscode_events(mut vscode_events: EventReader<GladosTtsVscodeEvent>) {
    let should_start = vscode_events
        .read()
        .any(|event| matches!(event, GladosTtsVscodeEvent::Startup));
    if should_start {
        info!("Opening vscode");
        if let Err(e) = glados_tts::start_vscode() {
            error!("Failed to start vscode: {:?}", e);
        }
    }
    vscode_events.clear();
}

````



## D:\Repos\Games\Cursor-Hero\crates\text_asset_types\src\text_asset_loader_types.rs

````rust
use bevy::prelude::*;

use bevy::asset::io::Reader;
use bevy::asset::AssetLoader;
use bevy::asset::AsyncReadExt;
use bevy::asset::LoadContext;
use bevy::utils::thiserror;
use bevy::utils::BoxedFuture;
use serde::Deserialize;
use thiserror::Error;

#[derive(Asset, Reflect, Debug, Deserialize)]
pub struct TextAsset {
    pub value: String,
}

#[derive(Default)]
pub struct TextAssetLoader;

/// Possible errors that can be produced by [`TextAssetLoader`]
#[non_exhaustive]
#[derive(Debug, Error)]
pub enum TextAssetLoaderError {
    /// An [IO](std::io) Error
    #[error("Could not load asset: {0}")]
    Io(#[from] std::io::Error),
}

impl AssetLoader for TextAssetLoader {
    type Asset = TextAsset;
    type Settings = ();
    type Error = TextAssetLoaderError;
    fn load<'a>(
        &'a self,
        reader: &'a mut Reader,
        _settings: &'a (),
        _load_context: &'a mut LoadContext,
    ) -> BoxedFuture<'a, Result<Self::Asset, Self::Error>> {
        Box::pin(async move {
            let mut bytes = Vec::new();
            reader.read_to_end(&mut bytes).await?;
            let custom_asset = TextAsset {
                value: String::from_utf8(bytes).unwrap(),
            };
            Ok(custom_asset)
        })
    }

    fn extensions(&self) -> &[&str] {
        &["txt"]
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\data\src\sounds.rs

````rust
/*
 * WARNING: THIS FILE IS AUTOGENERATED
 * DO NOT EDIT THIS FILE DIRECTLY
 *
 */
pub const PRESSURE_PLATE_ACTIVATION_DURATION: f32 = 1.84;

````



## D:\Repos\Games\Cursor-Hero\crates\agent\src\agent_spawning_plugin.rs

````rust
use bevy::prelude::*;

use bevy_xpbd_2d::components::Collider;
use bevy_xpbd_2d::components::RigidBody;
use cursor_hero_agent_types::prelude::*;
use cursor_hero_bevy::prelude::NegativeYVec2;
use cursor_hero_character_types::prelude::*;
use cursor_hero_environment_types::prelude::*;
use cursor_hero_floaty_nametag_types::prelude::*;
use cursor_hero_observation_types::prelude::*;
use cursor_hero_physics::damping_plugin::MovementDamping;

pub struct AgentSpawningPlugin;

impl Plugin for AgentSpawningPlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(Update, spawn_agent);
    }
}

fn spawn_agent(
    mut commands: Commands,
    mut environment_events: EventReader<PopulateEnvironmentEvent>,
    environment_query: Query<&GameEnvironment>,
    asset_server: Res<AssetServer>,
) {
    for event in environment_events.read() {
        if !environment_query.contains(event.environment_id) {
            continue;
        }
        info!("Spawning agent for game environment {:?}", event.environment_id);
        commands.entity(event.environment_id).with_children(|parent| {
            let spawn_position = Vec2::new(1920.0, 1080.0).neg_y() / 2.0;
            parent.spawn((
                SpriteBundle {
                    sprite: Sprite {
                        custom_size: Some(Vec2::new(64.0, 64.0)),
                        ..default()
                    },
                    texture: asset_server.load(AgentAppearance::Default.get_texture_path()),
                    transform: Transform::from_translation(spawn_position.extend(80.0)),
                    ..default()
                },
                Character,
                AgentCharacter,
                Name::new("Character - (Agent) Ithia Tig"),
                FloatyName {
                    text: "Ithia Tig".to_string(),
                    vertical_offset: 40.0,
                    appearance: NametagAppearance::Character,
                },
                Agent,
                RigidBody::Dynamic,
                ObservationBuffer {
                    log_level: ObservationLogLevel::All,
                    ..default()
                },
                Collider::capsule(25.0, 12.5),
                MovementDamping { factor: 0.90 },
            ));
        });
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\chat_types\src\chat_types_plugin.rs

````rust
use crate::prelude::*;
use bevy::prelude::*;
pub struct ChatTypesPlugin;

impl Plugin for ChatTypesPlugin {
    fn build(&self, app: &mut App) {
        app.register_type::<ChatWheelTool>();
        app.register_type::<ChatTool>();
        app.register_type::<ChatBubble>();
        app.register_type::<ChatInput>();
        app.add_event::<ChatEvent>();
        app.add_event::<ChatInputEvent>();
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\winutils\src\win_screen_capture.rs

````rust
#![allow(unused_imports)]
// most code from https://github.com/nashaofu/screenshots-rs/ commit 999faac06f85bd93638c2a9cda6cbb25ad9f5c73
// my changes are MPLv2, original code is Apache 2.0
// modifications aim to reduce redundant work for successive screen capture calls

// might also be interesting:
// https://github.com/rhinostream/win_desktop_duplication/tree/master
// https://github.com/rustdesk/rustdesk
// https://github.com/RustBuddies/desktop-sharing
// https://github.com/mira-screen-share/sharer/blob/main/src/capture/wgc/display.rs

#[cfg(target_arch = "x86")]
use std::arch::x86::_mm_shuffle_epi8;
use std::arch::x86_64::__m128i;
use std::arch::x86_64::_mm_loadu_si128;
use std::arch::x86_64::_mm_setr_epi8;
#[cfg(target_arch = "x86_64")]
use std::arch::x86_64::_mm_shuffle_epi8;
use std::arch::x86_64::_mm_storeu_si128;
use std::sync::Arc;

use anyhow::anyhow;
use anyhow::Result;
use bevy::math::IRect;
use cursor_hero_bevy::prelude::LeftI;
use cursor_hero_bevy::prelude::TopI;
use cursor_hero_bevy::prelude::TopLeftI;
use cursor_hero_bevy::prelude::TranslateIVec2;
use cursor_hero_math::prelude::bgra_to_rgba;
// use display_info::DisplayInfo;
// use fxhash::hash32;
use image::RgbaImage;
use std::mem;
use std::ops::Deref;
use std::ptr;
use std::rc::Rc;
use widestring::U16CString;
use windows::core::PCWSTR;
use windows::Win32::Foundation::BOOL;
use windows::Win32::Foundation::LPARAM;
use windows::Win32::Foundation::RECT;
use windows::Win32::Graphics::Gdi::BitBlt;
use windows::Win32::Graphics::Gdi::CreateCompatibleBitmap;
use windows::Win32::Graphics::Gdi::CreateCompatibleDC;
use windows::Win32::Graphics::Gdi::CreateDCW;
use windows::Win32::Graphics::Gdi::DeleteDC;
use windows::Win32::Graphics::Gdi::DeleteObject;
use windows::Win32::Graphics::Gdi::EnumDisplayMonitors;
use windows::Win32::Graphics::Gdi::GetDIBits;
use windows::Win32::Graphics::Gdi::GetMonitorInfoW;
use windows::Win32::Graphics::Gdi::GetObjectW;
use windows::Win32::Graphics::Gdi::SelectObject;
use windows::Win32::Graphics::Gdi::SetStretchBltMode;
use windows::Win32::Graphics::Gdi::StretchBlt;
use windows::Win32::Graphics::Gdi::BITMAP;
use windows::Win32::Graphics::Gdi::BITMAPINFO;
use windows::Win32::Graphics::Gdi::BITMAPINFOHEADER;
use windows::Win32::Graphics::Gdi::DIB_RGB_COLORS;
use windows::Win32::Graphics::Gdi::HBITMAP;
use windows::Win32::Graphics::Gdi::HDC;
use windows::Win32::Graphics::Gdi::HMONITOR;
use windows::Win32::Graphics::Gdi::MONITORINFOEXW;
use windows::Win32::Graphics::Gdi::RGBQUAD;
use windows::Win32::Graphics::Gdi::SRCCOPY;
use windows::Win32::Graphics::Gdi::STRETCH_HALFTONE;

use cursor_hero_metrics::Metrics;

use crate::ToBevyIRect;

//////////////////////
/// GET MONITOR INFOS
//////////////////////

#[derive(Debug)]
pub struct MonitorInfo {
    pub id: u32,
    pub name: String,
    pub rect: IRect,
    pub work_area: IRect, // the area of the monitor not covered by the taskbar
    pub is_primary: bool,
}

pub fn get_monitor_infos() -> Result<Vec<MonitorInfo>> {
    // box it up so we can pass it to the callback
    let results: *mut Vec<MONITORINFOEXW> = Box::into_raw(Box::default());

    // use proc method to iterate monitors and collect into results vec
    unsafe {
        EnumDisplayMonitors(
            HDC::default(),
            None,
            Some(monitor_enum_proc),
            LPARAM(results as isize),
        )
        .ok()?;
    };

    // convert results back into a vec
    let results = unsafe { &Box::from_raw(results) };

    // convert vec of MONITORINFOEXW into vec of MonitorInfo
    let results = results
        .iter()
        .map(|info| {
            let sz_device_ptr = info.szDevice.as_ptr();
            let sz_device_string =
                unsafe { U16CString::from_ptr_str(sz_device_ptr).to_string_lossy() };
            MonitorInfo {
                id: fxhash::hash32(sz_device_string.as_bytes()), // same algorithm as screen crate
                name: sz_device_string,
                rect: info.monitorInfo.rcMonitor.to_bevy_irect(),
                work_area: info.monitorInfo.rcWork.to_bevy_irect(),
                is_primary: info.monitorInfo.dwFlags == 1,
            }
        })
        .collect::<Vec<MonitorInfo>>();
    Ok(results)
}

extern "system" fn monitor_enum_proc(
    h_monitor: HMONITOR,
    _: HDC,
    _: *mut RECT,
    data: LPARAM,
) -> BOOL {
    let results = unsafe { Box::from_raw(data.0 as *mut Vec<MONITORINFOEXW>) };
    let results = Box::leak(results);

    match get_monitor_info_exw(h_monitor) {
        Ok(monitor_info_exw) => {
            results.push(monitor_info_exw);
            BOOL::from(true)
        }
        Err(_) => BOOL::from(false),
    }
}

fn get_monitor_info_exw(h_monitor: HMONITOR) -> Result<MONITORINFOEXW> {
    let mut monitor_info_exw: MONITORINFOEXW = unsafe { mem::zeroed() };
    monitor_info_exw.monitorInfo.cbSize = mem::size_of::<MONITORINFOEXW>() as u32;
    let monitor_info_exw_ptr = <*mut _>::cast(&mut monitor_info_exw);

    unsafe {
        GetMonitorInfoW(h_monitor, monitor_info_exw_ptr).ok()?;
    };
    Ok(monitor_info_exw)
}

//////////////////
/// GET MONITORS
//////////////////
pub struct Monitor {
    pub info: MonitorInfo,
    device_context: HDC,
}

pub fn get_all_monitors() -> Result<Vec<Monitor>> {
    let monitor_infos = get_monitor_infos()?;
    let mut monitors = Vec::new();

    for monitor_info in monitor_infos {
        // intermediate variables are required to ensure the pointer contents remain in scope
        let a = U16CString::from_str(&monitor_info.name)?;
        let b = a.as_ptr();
        let name_pcwstr = PCWSTR(b);
        let device_context =
            unsafe { CreateDCW(name_pcwstr, name_pcwstr, PCWSTR(ptr::null()), None) };

        monitors.push(Monitor {
            info: monitor_info,
            device_context,
        });
    }

    Ok(monitors)
}

/////////////////////////////
/// MONITOR REGION CAPTURER
/////////////////////////////

pub struct MonitorRegionCapturer {
    pub monitor: Arc<Monitor>,
    pub capture_region: IRect,
    device_context: HDC,
    bitmap: HBITMAP,
}

pub fn get_full_monitor_capturers() -> Result<Vec<MonitorRegionCapturer>> {
    let monitors = get_all_monitors()?;
    let mut capturers = Vec::new();

    for monitor in monitors {
        let region = monitor.info.rect;
        let capturer = get_monitor_capturer(Arc::new(monitor), region);
        capturers.push(capturer);
    }

    Ok(capturers)
}

pub fn get_monitor_capturer(monitor: Arc<Monitor>, capture_region: IRect) -> MonitorRegionCapturer {
    let capture_device_context = unsafe { CreateCompatibleDC(monitor.device_context) };
    let bitmap = unsafe {
        CreateCompatibleBitmap(
            monitor.device_context,
            capture_region.width(),
            capture_region.height(),
        )
    };

    unsafe {
        SelectObject(capture_device_context, bitmap);
        SetStretchBltMode(monitor.device_context, STRETCH_HALFTONE);
    };

    MonitorRegionCapturer {
        monitor,
        device_context: capture_device_context,
        bitmap,
        capture_region,
    }
}

impl Drop for MonitorRegionCapturer {
    fn drop(&mut self) {
        unsafe {
            DeleteObject(self.bitmap);
            DeleteDC(self.device_context);
        }
    }
}
impl MonitorRegionCapturer {
    // pub fn capture(&self) -> Result<RgbaImage> {
    pub fn capture(&self, metrics: &mut Option<Metrics>) -> Result<RgbaImage> {
        // todo: try https://learn.microsoft.com/en-us/windows/win32/api/dxgi1_2/nf-dxgi1_2-idxgioutputduplication-acquirenextframe
        unsafe {
            if let Some(metrics) = metrics {
                metrics.begin("blit");
            }
            StretchBlt(
                self.device_context,
                0,
                0,
                self.capture_region.width(),
                self.capture_region.height(),
                self.monitor.device_context,
                self.monitor.info.rect.left() - self.capture_region.left(),
                self.monitor.info.rect.top() - self.capture_region.top(),
                self.capture_region.width(),
                self.capture_region.height(),
                SRCCOPY,
            )
            .ok()?;
            if let Some(metrics) = metrics {
                metrics.end("blit");
            }
        };

        let mut bitmap_info = BITMAPINFO {
            bmiHeader: BITMAPINFOHEADER {
                biSize: mem::size_of::<BITMAPINFOHEADER>() as u32,
                biWidth: self.capture_region.width(),
                biHeight: -self.capture_region.height(),
                biPlanes: 1,
                biBitCount: 32,
                biCompression: 0,
                biSizeImage: 0,
                biXPelsPerMeter: 0,
                biYPelsPerMeter: 0,
                biClrUsed: 0,
                biClrImportant: 0,
            },
            bmiColors: [RGBQUAD::default(); 1],
        };

        let mut data =
            vec![0u8; (self.capture_region.width() * self.capture_region.height()) as usize * 4];
        let buf_prt = data.as_ptr() as *mut _;

        if let Some(metrics) = metrics {
            metrics.begin("getdibits");
        }
        let err = unsafe {
            GetDIBits(
                self.device_context,
                self.bitmap,
                0,
                self.capture_region.height() as u32,
                Some(buf_prt),
                &mut bitmap_info,
                DIB_RGB_COLORS,
            ) == 0
        };
        if let Some(metrics) = metrics {
            metrics.end("getdibits");
        }

        if err {
            return Err(anyhow!("Get RGBA data failed"));
        }

        let mut bitmap = BITMAP::default();
        let bitmap_ptr = <*mut _>::cast(&mut bitmap);

        if let Some(metrics) = metrics {
            metrics.begin("getobject");
        }
        unsafe {
            // Get the BITMAP from the HBITMAP.
            GetObjectW(
                self.bitmap,
                mem::size_of::<BITMAP>() as i32,
                Some(bitmap_ptr),
            );
        }
        if let Some(metrics) = metrics {
            metrics.end("getobject");
        }

        if let Some(metrics) = metrics {
            metrics.begin("shuffle");
        }
        bgra_to_rgba(data.as_mut_slice());
        if let Some(metrics) = metrics {
            metrics.end("shuffle");
        }

        let data = RgbaImage::from_vec(
            self.capture_region.width() as u32,
            self.capture_region.height() as u32,
            data,
        );
        data.ok_or_else(|| anyhow!("Invalid image data"))
    }
}

#[cfg(test)]
#[allow(unused_imports)]
mod tests {
    use bevy::math::IVec2;

    use super::*;

    #[test]
    fn names() {
        get_monitor_infos().unwrap().iter().for_each(|info| {
            println!("{:?}", info);
        });
    }

    #[test]
    fn full_screenshots() {
        let capturers = get_full_monitor_capturers().unwrap();
        std::fs::create_dir_all("target/capture").unwrap();

        capturers.iter().for_each(|capturer| {
            let capture = capturer.capture(&mut None).unwrap();
            let mon_name_good = capturer.monitor.info.name.replace(r"\\.\", "");
            let path = format!("target/capture/full-{}.png", mon_name_good);
            capture.save(path).unwrap();
        });
    }

    #[test]
    fn region_screenshots() {
        let monitors = get_all_monitors().unwrap();
        let mut capturers = Vec::new();

        for monitor in monitors {
            let p0 = monitor.info.rect.top_left();
            let p1 = p0 + IVec2::new(100, 100);
            let region = IRect::from_corners(p0, p1);
            let capturer = get_monitor_capturer(Arc::new(monitor), region);
            capturers.push(capturer);
        }
        std::fs::create_dir_all("target/capture").unwrap();

        capturers.iter().for_each(|capturer| {
            let capture = capturer.capture(&mut None).unwrap();
            let mon_name_good = capturer.monitor.info.name.replace(r"\\.\", "");
            let path = format!("target/capture/region-{}.png", mon_name_good);
            capture.save(path).unwrap();
        });
    }

    #[test]
    fn capture_avg() {
        let capturers = get_full_monitor_capturers().unwrap();
        std::fs::create_dir_all("target/capture").unwrap();

        for _ in 0..100 {
            capturers.iter().for_each(|capturer| {
                let capture = capturer.capture(&mut None).unwrap();
                let (mut tot_r, mut tot_g, mut tot_b) = (0, 0, 0);

                for pixel in capture.enumerate_pixels() {
                    let image::Rgba([r, g, b, _]) = pixel.2; // Destructure the Rgba struct
                    tot_r += *r as u64;
                    tot_g += *g as u64;
                    tot_b += *b as u64;
                }
                let size = capture.iter().count() as u64;
                print!(
                    "{} -- avg: {:?}\t",
                    capturer.monitor.info.name,
                    (tot_r / size, tot_g / size, tot_b / size)
                );
            });
            print!("\n");
            std::thread::sleep(std::time::Duration::from_millis(100));
        }
    }

    #[test]
    fn screenshot_speed() {
        let capturers = get_full_monitor_capturers().unwrap();
        let mut durations = Vec::new();
        for _ in 0..100 {
            capturers.iter().for_each(|capturer| {
                let start = std::time::Instant::now();
                let _ = capturer.capture(&mut None).unwrap();
                let duration = start.elapsed();
                durations.push(duration.as_millis());
            });
            std::thread::sleep(std::time::Duration::from_millis(1));
        }
        let avg = durations.iter().sum::<u128>() / durations.len() as u128;
        println!("avg: {:?}ms", avg);
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\chat_types\src\lib.rs

````rust
pub mod chat_types;
pub mod chat_types_plugin;

pub mod prelude {
    pub use crate::chat_types::*;
    pub use crate::chat_types_plugin::ChatTypesPlugin;
}

````



## D:\Repos\Games\Cursor-Hero\crates\worker_types\src\lib.rs

````rust
mod worker_types;
mod worker_types_plugin;

pub mod prelude {
    pub use crate::worker_types::*;
    pub use crate::worker_types_plugin::*;
}

````



## D:\Repos\Games\Cursor-Hero\crates\fullscreen_tool\src\lib.rs

````rust
pub mod fullscreen_tool_plugin;
pub mod fullscreen_tool_populate_plugin;
pub mod fullscreen_tool_tick_plugin;

pub mod prelude {
    pub use crate::fullscreen_tool_plugin::*;
}

````



## D:\Repos\Games\Cursor-Hero\crates\voice_to_text_types\src\lib.rs

````rust
#![feature(trivial_bounds)]
pub mod voice_to_text_types;
pub mod voice_to_text_types_plugin;

pub mod prelude {
    pub use crate::voice_to_text_types::*;
    pub use crate::voice_to_text_types_plugin::*;
}

````



## D:\Repos\Games\Cursor-Hero\crates\toolbelt\src\tool_visibility.rs

````rust
use cursor_hero_toolbelt_types::toolbelt_types::*;

use bevy::prelude::*;
use leafwing_input_manager::action_state::ActionState;

#[allow(clippy::type_complexity)]
pub fn tool_visibility(
    mut toolbelts: Query<
        (&ActionState<ToolbeltAction>, &mut Wheel, &Children),
        (Without<Tool>, With<Toolbelt>),
    >,
    mut tool_query: Query<(Entity, &mut Transform, &mut Visibility, &mut Sprite), With<Tool>>,
) {
    for (toolbelt_actions, wheel, toolbelt_kids) in toolbelts.iter_mut() {
        if toolbelt_actions.just_pressed(ToolbeltAction::Show) {
            debug!("Updating toolbelt visibility => visible");
            for child_id in toolbelt_kids.iter() {
                if let Ok((_, _, mut tool_visibility, _)) = tool_query.get_mut(*child_id) {
                    *tool_visibility = Visibility::Visible;
                }
            }
        } else if toolbelt_actions.just_released(ToolbeltAction::Show) {
            debug!("Updating toolbelt visibility => hidden");
            for child_id in toolbelt_kids.iter() {
                if let Ok((_, _, mut tool_visibility, _)) = tool_query.get_mut(*child_id) {
                    *tool_visibility = Visibility::Hidden;
                }
            }
        }
        if wheel.open {
            for child_id in toolbelt_kids.iter() {
                if let Ok((_, _, _, mut tool_sprite)) = tool_query.get_mut(*child_id) {
                    tool_sprite.color = tool_sprite.color.with_a(wheel.alpha);
                }
            }
        }
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\inference\src\prompt_asset_plugin.rs

````rust
use bevy::prelude::*;
use cursor_hero_inference_types::prelude::*;

pub struct PromptAssetPlugin;

impl Plugin for PromptAssetPlugin {
    fn build(&self, app: &mut App) {
        app.init_resource::<TextPromptHandles>();
        app.add_systems(Startup, load_prompt_assets);
    }
}

fn load_prompt_assets(mut commands: Commands, asset_server: Res<AssetServer>) {
    commands.insert_resource(TextPromptHandles {
        raw: asset_server.load("prompt_templates/raw.txt"),
        chat: asset_server.load("prompt_templates/chat.txt"),
    });
}

````



## D:\Repos\Games\Cursor-Hero\crates\taskbar_types\src\lib.rs

````rust
pub mod taskbar_types;
pub mod taskbar_types_plugin;

pub mod prelude {
    pub use crate::taskbar_types::*;
    pub use crate::taskbar_types_plugin::*;
}

````



## D:\Repos\Games\Cursor-Hero\crates\screen\src\screen_plugin.rs

````rust
use bevy::prelude::*;
use cursor_hero_bevy::prelude::IExpandable;
use cursor_hero_bevy::prelude::NegativeYIRect;
use cursor_hero_environment_types::prelude::*;
use cursor_hero_level_bounds::level_bounds_plugin::LevelBoundsEvent;
use cursor_hero_winutils::win_screen_capture::get_all_monitors;
use image::DynamicImage;
use screenshots::Screen as ScreenLib;
use std::collections::VecDeque;

use crate::ToBevyIRect;

pub struct ScreenPlugin;
impl Plugin for ScreenPlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(Update, spawn_screens_in_new_environments)
            .register_type::<Screen>()
            .register_type::<ScreenParent>();
    }
}

#[derive(Component, Default, Reflect)]
#[reflect(Component)]
pub struct Screen {
    pub id: u32,
    pub name: String,
    pub refresh_rate: Option<Timer>,
}
#[derive(Component, Default, Reflect)]
pub struct GameScreen;
#[derive(Component, Default, Reflect)]
pub struct HostScreen;

#[derive(Component, Reflect)]
pub struct ScreenParent;

fn spawn_screens_in_new_environments(
    mut populate_events: EventReader<PopulateEnvironmentEvent>,
    mut commands: Commands,
    mut textures: ResMut<Assets<Image>>,
    mut level_bounds_events: EventWriter<LevelBoundsEvent>,
    environment_query: Query<(Option<&HostEnvironment>,Option<&GameEnvironment>)>,
) {
    for event in populate_events.read() {
        let environment_id = event.environment_id;
        let Ok((is_host, is_game)) = environment_query.get(event.environment_id) else {
            continue;
        };
        match (is_host, is_game) {
            (Some(_), _) => {
                info!("Populating host environment with screens");
                commands.entity(environment_id).with_children(|parent| {
                    let mut screen_parent_commands = parent.spawn((
                        SpatialBundle::default(),
                        ScreenParent,
                        Name::new("Screens"),
                    ));

                    // create a Screen component for each screen
                    let mut screen_names = get_all_monitors()
                        .unwrap()
                        .iter()
                        .map(|monitor| monitor.info.name.clone())
                        .collect::<VecDeque<String>>();
                    // todo: remove this and use win_screen_capture

                    let mut level_bounds = vec![];

                    screen_parent_commands.with_children(|screen_parent| {
                        for screen in ScreenLib::all().unwrap().iter() {
                            let image_buf = screen.capture().unwrap();
                            let dynamic_image = DynamicImage::ImageRgba8(image_buf);
                            let image = Image::from_dynamic(dynamic_image, true);
                            let texture = textures.add(image);
                            let name = screen_names.pop_front().unwrap();
                            let region = screen.display_info.to_bevy_irect().neg_y();
                            screen_parent.spawn((
                                SpriteBundle {
                                    texture,
                                    transform: Transform::from_translation(
                                        region.center().extend(-1).as_vec3(),
                                    ),
                                    sprite: Sprite {
                                        custom_size: Some(region.size().as_vec2()),
                                        ..default()
                                    },
                                    ..Default::default()
                                },
                                Screen {
                                    name: name.clone(),
                                    id: screen.display_info.id,
                                    refresh_rate: Some(Timer::from_seconds(
                                        0.1,
                                        TimerMode::Repeating,
                                    )),
                                },
                                HostScreen,
                                Name::new(format!("Screen {}", name)),
                            ));

                            level_bounds.push(region.expand((400, 400).into()));
                        }
                    });
                    info!("Broadcasting {} level bounds events", level_bounds.len());
                    for area in level_bounds {
                        level_bounds_events.send(LevelBoundsEvent::AddPlayArea {
                            environment_id,
                            area: area.as_rect(),
                        });
                    }
                });
            }
            (_, Some(_)) => {
                commands.entity(environment_id).with_children(|parent| {
                    info!("Populating game environment with screens");
                    let mut screen_parent_commands = parent.spawn((
                        SpatialBundle::default(),
                        ScreenParent,
                        Name::new("Screens"),
                    ));

                    let mut level_bounds = vec![];

                    screen_parent_commands.with_children(|screen_parent| {
                        let region =
                            IRect::from_corners(IVec2::new(0, 0), IVec2::new(1920, 1080)).neg_y();
                        let name = "Primary Screen".to_string();
                        screen_parent.spawn((
                            SpriteBundle {
                                sprite: Sprite {
                                    custom_size: Some(region.size().as_vec2()),
                                    ..default()
                                },
                                transform: Transform::from_translation(
                                    region.center().extend(-1).as_vec3(),
                                ),
                                ..Default::default()
                            },
                            Screen {
                                name: name.to_string(),
                                id: 1,
                                refresh_rate: None,
                            },
                            GameScreen,
                            Name::new(name),
                        ));

                        level_bounds.push(region.expand((400, 400).into()));
                    });
                    info!("Broadcasting {} level bounds events", level_bounds.len());
                    for area in level_bounds {
                        level_bounds_events.send(LevelBoundsEvent::AddPlayArea {
                            environment_id: environment_id,
                            area: area.as_rect(),
                        });
                    }
                });
            },
            (None, None) => {
                error!("Environment {:?} is not a host or game environment", environment_id);
            }
        }
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\taskbar_types\src\taskbar_types.rs

````rust
use bevy::prelude::*;
use bevy::reflect::TypePath;
use bevy::render::render_resource::AsBindGroup;
use bevy::render::render_resource::ShaderRef;
use bevy::sprite::Material2d;

#[derive(Component, Debug, Reflect)]
pub struct AppWindow;

#[derive(Component, Debug, Reflect)]
pub struct Taskbar {
    pub size: Vec2,
}

#[derive(Event, Debug, Reflect)]
pub enum TaskbarEvent {
    Populate { taskbar_id: Entity },
}

#[derive(Asset, TypePath, AsBindGroup, Debug, Clone)]
pub struct TaskbarMaterial {
    #[uniform(0)]
    pub taskbar_height: f32,
    // pub taskbar_blur_radius: u32,
    // pub taskbar_blur_total_samples: u32,
    #[uniform(0)]
    pub taskbar_color: Color,
    #[texture(1)]
    #[sampler(2)]
    pub wallpaper_texture: Option<Handle<Image>>,
    #[uniform(0)]
    pub wallpaper_size: Vec2,
    pub alpha_mode: AlphaMode,
}

impl Material2d for TaskbarMaterial {
    fn fragment_shader() -> ShaderRef {
        "shaders/taskbar_material.wgsl".into()
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\pointer\src\pointer_positioning_plugin.rs

````rust
use bevy::prelude::*;
use bevy::transform::TransformSystem;
use bevy::window::PrimaryWindow;
use bevy_xpbd_2d::prelude::*;
use cursor_hero_bevy::prelude::NegativeYVec2;
use cursor_hero_camera::camera_plugin::MainCamera;
use cursor_hero_character_types::prelude::*;
use cursor_hero_environment_types::prelude::*;
use cursor_hero_input::active_input_state_plugin::InputMethod;
use cursor_hero_pointer_types::pointer_behaviour_types::PointerMovementBehaviour;
use cursor_hero_pointer_types::prelude::*;
use cursor_hero_winutils::win_mouse::set_cursor_position;
use cursor_hero_winutils::win_window::get_window_bounds;
use cursor_hero_winutils::win_window::get_window_inner_offset;
use leafwing_input_manager::prelude::*;

use bevy::window::RawHandleWrapper;

pub struct PointerPositioningPlugin;
impl Plugin for PointerPositioningPlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(
            PostUpdate,
            (update_pointer)
                .in_set(PointerSystemSet::Position)
                .after(PhysicsSet::Sync)
                .after(TransformSystem::TransformPropagate),
        );
    }
}

#[derive(Default, Debug)]
struct PointerUpdate {
    local_target: Option<Vec2>,
    global_target: Option<Vec2>,
    host_target: Option<IVec2>,
}

#[derive(Debug)]
struct DecisionInfo {
    current_behaviour: PointerMovementBehaviour,
    is_main_character: bool,
    in_host_environment: bool,
    stick_in_use: bool,
    active_input_method: InputMethod,
}

#[allow(clippy::type_complexity)]
#[allow(clippy::too_many_arguments)]
fn update_pointer(
    mut pointer_query: Query<
        (
            &mut Transform,
            &GlobalTransform,
            &mut Position,
            &ActionState<PointerAction>,
            &mut Pointer,
            Option<&EnvironmentTracker>,
            &Parent,
        ),
        (Without<Character>, With<Pointer>),
    >,
    mut character_query: Query<
        (Ref<GlobalTransform>, Option<&MainCharacter>),
        (With<Character>, Without<Pointer>, Without<MainCamera>),
    >,
    camera_query: Query<
        (&Camera, &GlobalTransform),
        (With<MainCamera>, Without<Character>, Without<Pointer>),
    >,
    window_query: Query<(&Window, &RawHandleWrapper), With<PrimaryWindow>>,
    input_method: Res<InputMethod>,
    environment_query: Query<(), With<HostEnvironment>>,
    mut last_known_cursor_position: Local<Option<Vec2>>,
    mut previous_update: Local<PointerUpdate>,
) {
    for pointer in pointer_query.iter_mut() {
        let (
            mut pointer_transform,
            pointer_global_transform,
            mut pointer_position,
            pointer_actions,
            mut pointer,
            pointer_environment,
            pointer_parent,
        ) = pointer;

        let stick_in_use = pointer_actions.pressed(PointerAction::Move);
        let in_host_environment = pointer_environment
            .map(|e| environment_query.contains(e.environment_id))
            .unwrap_or(false);

        let Ok(character) = character_query.get_mut(pointer_parent.get()) else {
            warn!("No character found");
            continue;
        };
        let (character_global_transform, is_main_character) = character;

        let Ok(camera) = camera_query.get_single() else {
            warn!("No camera found");
            return;
        };
        let (camera, camera_global_transform) = camera;

        let Ok(window) = window_query.get_single() else {
            warn!("No window found");
            return;
        };
        let (window, window_handle) = window;

        let decision_info = DecisionInfo {
            current_behaviour: pointer.movement_behaviour,
            is_main_character: is_main_character.is_some(),
            in_host_environment,
            stick_in_use,
            active_input_method: *input_method,
        };

        let next_behaviour = match decision_info {
            DecisionInfo {
                is_main_character: true,
                in_host_environment: true,
                stick_in_use: true,
                ..
            }
            | DecisionInfo {
                is_main_character: true,
                in_host_environment: true,
                active_input_method: InputMethod::Gamepad,
                ..
            }
            | DecisionInfo {
                is_main_character: true,
                in_host_environment: true,
                active_input_method: InputMethod::Keyboard,
                ..
            } => PointerMovementBehaviour::SetHostCursorFromPointerWorldCoords,
            DecisionInfo {
                is_main_character: true,
                stick_in_use: false,
                active_input_method: InputMethod::MouseAndKeyboard,
                ..
            } => PointerMovementBehaviour::SetPointerFromHostCursorWindowCoords,
            DecisionInfo {
                is_main_character: true,
                in_host_environment: false,
                stick_in_use: true,
                ..
            } => PointerMovementBehaviour::SetHostCursorFromWindowCoords,
            DecisionInfo {
                is_main_character: true,
                in_host_environment: false,
                stick_in_use: false,
                ..
            } => decision_info.current_behaviour,
            DecisionInfo {
                current_behaviour: PointerMovementBehaviour::None,
                ..
            } => PointerMovementBehaviour::None,
            _ => {
                warn!("Unhandled case: {:?}", decision_info);
                decision_info.current_behaviour
            }
        };

        if next_behaviour != pointer.movement_behaviour {
            info!(
                "Switching to {:?} given {:?}",
                next_behaviour, decision_info
            );
            pointer.movement_behaviour = next_behaviour;
        }

        let this_update = match pointer.movement_behaviour {
            PointerMovementBehaviour::None => {
                // sync physics to render
                PointerUpdate {
                    local_target: None,
                    global_target: Some(pointer_global_transform.translation().xy()),
                    host_target: None,
                }
            }
            PointerMovementBehaviour::SetPointerFromHostCursorWindowCoords => {
                // usual mode for mouse and keyboard input
                match window.cursor_position().or(*last_known_cursor_position) {
                    Some(host_cursor_xy) => {
                        // Cache to avoid jitter
                        *last_known_cursor_position = Some(host_cursor_xy);

                        // Calculate target positions
                        let Some(global_target) = camera
                            .viewport_to_world(camera_global_transform, host_cursor_xy)
                            .map(|ray| ray.origin.truncate())
                        else {
                            return;
                        };
                        let local_target =
                            global_target - character_global_transform.translation().xy();
                        PointerUpdate {
                            local_target: Some(local_target),
                            global_target: Some(global_target),
                            host_target: None,
                        }
                    }
                    None => {
                        if pointer.log_behaviour == PointerLogBehaviour::ErrorsAndPositionUpdates {
                            warn!("No cursor position found");
                        }
                        PointerUpdate::default()
                    }
                }
            }
            PointerMovementBehaviour::SetHostCursorFromPointerWorldCoords => {
                // host follows pointer, render and physics are the same
                if stick_in_use {
                    match pointer_actions.axis_pair(PointerAction::Move) {
                        Some(axis_pair) => {
                            let look = axis_pair.xy();
                            if look.x.is_nan() || look.y.is_nan() {
                                warn!("{} | look vector is unusable", pointer.movement_behaviour);
                                PointerUpdate::default()
                            } else {
                                let character_translation =
                                    character_global_transform.translation();
                                let local_target = look * pointer.reach;
                                let global_target = character_translation.xy() + local_target;
                                let host_target = global_target.neg_y().as_ivec2();
                                PointerUpdate {
                                    local_target: Some(local_target),
                                    global_target: Some(global_target),
                                    host_target: Some(host_target),
                                }
                            }
                        }
                        None => {
                            warn!("{}, No axis pair found?", pointer.movement_behaviour);
                            PointerUpdate::default()
                        }
                    }
                } else {
                    // pointer stick not in use, reset pointer to the origin of the character
                    let character_translation = character_global_transform.translation();
                    let local_target = Vec2::ZERO;
                    let global_target = character_translation.xy();
                    let host_target = character_translation.xy().neg_y().as_ivec2();
                    PointerUpdate {
                        local_target: Some(local_target),
                        global_target: Some(global_target),
                        host_target: Some(host_target),
                    }
                }
            }
            PointerMovementBehaviour::SetHostCursorFromWindowCoords => {
                if stick_in_use {
                    // stick in use
                    // the host cursor will go over the pointer's window position
                    match pointer_actions.axis_pair(PointerAction::Move) {
                        Some(axis_pair) => {
                            let look = axis_pair.xy();

                            // the look vector could be unusable
                            if look.x.is_nan() || look.y.is_nan() {
                                warn!("{} | look vector is unusable", pointer.movement_behaviour);
                                PointerUpdate::default()
                            } else {
                                // the spot you want to be is the character position + stick direction
                                let character_translation =
                                    character_global_transform.translation();
                                let local_target = look * pointer.reach;
                                let global_target =
                                    character_translation + local_target.extend(0.0);

                                // update the host cursor
                                let window_bounds = match window_handle.window_handle {
                                    raw_window_handle::RawWindowHandle::Win32(handle) => {
                                        match get_window_bounds(handle.hwnd as _) {
                                            Ok(bounds) => bounds,
                                            Err(e) => {
                                                error!("Failed to get window bounds: {:?}", e);
                                                return;
                                            }
                                        }
                                    }
                                    _ => panic!("Unsupported window handle"),
                                };
                                let host_target = camera
                                    .world_to_viewport(camera_global_transform, global_target)
                                    .map(|viewport| {
                                        let mut host_target =
                                            viewport.as_ivec2() + window_bounds.min;
                                        // accomodate window decorations
                                        let mut offset = get_window_inner_offset();
                                        offset.x *= 2;
                                        host_target += offset;
                                        host_target
                                    });

                                PointerUpdate {
                                    local_target: Some(local_target.xy()),
                                    global_target: Some(global_target.xy()),
                                    host_target,
                                }
                            }
                        }
                        None => {
                            warn!("{} | No axis pair found?", pointer.movement_behaviour);
                            PointerUpdate::default()
                        }
                    }
                } else {
                    // stick not in use
                    // reset pointer to the origin of the character
                    let character_translation = character_global_transform.translation();
                    let local_target = Vec2::ZERO;
                    let global_target = character_translation.xy().neg_y();

                    // update the host cursor
                    let window_bounds = match window_handle.window_handle {
                        raw_window_handle::RawWindowHandle::Win32(handle) => {
                            match get_window_bounds(handle.hwnd as _) {
                                Ok(bounds) => bounds,
                                Err(e) => {
                                    error!("Failed to get window bounds: {:?}", e);
                                    return;
                                }
                            }
                        }
                        _ => panic!("Unsupported window handle"),
                    };
                    let host_target = camera
                        .world_to_viewport(camera_global_transform, character_translation)
                        .map(|viewport| {
                            let mut host_target = viewport.as_ivec2() + window_bounds.min;
                            // accomodate window decorations
                            let mut offset = get_window_inner_offset();
                            offset.x *= 2;
                            // debug!("host_target={:?} offset={:?}", host_target, offset);
                            host_target += offset;
                            host_target
                        });

                    PointerUpdate {
                        local_target: Some(local_target),
                        global_target: Some(global_target),
                        host_target,
                    }
                }
            }
        };

        // Update render body
        let mut render_updated = false;
        if this_update.local_target != previous_update.local_target
            && let Some(local_target) = this_update.local_target
        {
            let target_distance = local_target - pointer_transform.translation.xy();
            if target_distance != Vec2::ZERO {
                // Not at destination, update render body (which physics will follow)
                if pointer.log_behaviour == PointerLogBehaviour::ErrorsAndPositionUpdates {
                    debug!(
                        "{} stick={:?} | target_distance={:?}, updating render body to local_target={:?}",
                        pointer.movement_behaviour, stick_in_use, target_distance, local_target
                    );
                }
                pointer_transform.translation.x = local_target.x;
                pointer_transform.translation.y = local_target.y;
                render_updated = true;
            }
        }

        // Update physics body
        if !render_updated
            && this_update.global_target != previous_update.global_target
            && let Some(global_target) = this_update.global_target
        {
            let target_distance = global_target - pointer_position.xy();
            if target_distance != Vec2::ZERO {
                // Not at destination, update physics body
                if pointer.log_behaviour == PointerLogBehaviour::ErrorsAndPositionUpdates {
                    debug!(
                        "{} stick={:?} | target_distance={:?}, updating physics body to global_target={:?}",
                        pointer.movement_behaviour, stick_in_use, target_distance, global_target
                    );
                }
                // prevent feedback loop
                let pointer_position = pointer_position.bypass_change_detection();

                // update physics body
                pointer_position.x = global_target.x;
                pointer_position.y = global_target.y;
            }
        }

        if this_update.host_target != previous_update.host_target
            && let Some(host_target) = this_update.host_target
        {
            match set_cursor_position(host_target) {
                Ok(_) => {
                    if pointer.log_behaviour == PointerLogBehaviour::ErrorsAndPositionUpdates {
                        debug!(
                            "{} | set host cursor to {:?}",
                            pointer.movement_behaviour, host_target
                        );
                    }
                }
                Err(e) => {
                    warn!(
                        "{} | host cursor update failed, tried setting to {:?}, error={:?}",
                        pointer.movement_behaviour, host_target, e
                    );
                }
            }
        }

        *previous_update = this_update;
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\taskbar_types\src\taskbar_types_plugin.rs

````rust
use crate::prelude::*;
use bevy::prelude::*;
use bevy::sprite::Material2dPlugin;

pub struct TaskbarTypesPlugin;

impl Plugin for TaskbarTypesPlugin {
    fn build(&self, app: &mut App) {
        app.register_type::<Taskbar>();
        app.add_event::<TaskbarEvent>();
        app.add_plugins(Material2dPlugin::<TaskbarMaterial>::default());
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\version\src\lib.rs

````rust
pub mod version_plugin;

````



## D:\Repos\Games\Cursor-Hero\crates\environment\src\lib.rs

````rust
pub mod environment_plugin;
pub mod environment_tracker_plugin;

````



## D:\Repos\Games\Cursor-Hero\crates\tools\src\talk_tool.rs

````rust
use std::thread;

use bevy::prelude::*;
use cursor_hero_voice_to_text_types::voice_to_text_types::VoiceToTextCommandEvent;
use cursor_hero_voice_to_text_types::voice_to_text_types::VoiceToTextStatus;
use cursor_hero_voice_to_text_types::voice_to_text_types::VoiceToTextStatusEvent;
use leafwing_input_manager::prelude::*;

use crossbeam_channel::bounded;
use crossbeam_channel::Sender;
use cursor_hero_winutils::win_mouse::press_f23_key;
use cursor_hero_winutils::win_mouse::release_f23_key;

use cursor_hero_toolbelt_types::prelude::*;

use crate::prelude::*;

pub struct TalkToolPlugin;

impl Plugin for TalkToolPlugin {
    fn build(&self, app: &mut App) {
        app.register_type::<TalkTool>();
        app.add_plugins(InputManagerPlugin::<TalkToolAction>::default());
        app.add_systems(Startup, spawn_worker_thread);
        app.add_systems(Update, toolbelt_events);
        app.add_systems(Update, handle_input);
    }
}

#[derive(Component, Reflect, Default)]
struct TalkTool;

fn toolbelt_events(
    mut commands: Commands,
    asset_server: Res<AssetServer>,
    mut reader: EventReader<ToolbeltPopulateEvent>,
) {
    for event in reader.read() {
        let (ToolbeltLoadout::Keyboard | ToolbeltLoadout::Default) = event.loadout else {
            continue;
        };
        {
            ToolSpawnConfig::<TalkTool, TalkToolAction>::new(TalkTool, event.id, event)
                .with_src_path(file!().into())
                .guess_name(file!())
                .guess_image(file!(), &asset_server, "png")
                .with_description("Presses F23")
                .spawn(&mut commands);
        }
    }
}

#[derive(Actionlike, PartialEq, Eq, Clone, Copy, Hash, Debug, Reflect)]
enum TalkToolAction {
    PushToTalk,
    ToggleAlwaysOn,
}

#[derive(Debug)]
enum Motion {
    Up,
    Down,
}

#[derive(Debug)]
enum ThreadMessage {
    ListenButton(Motion),
}

#[derive(Resource)]
struct Bridge {
    pub sender: Sender<ThreadMessage>,
}

impl TalkToolAction {
    fn default_wheel_gamepad_binding(&self) -> UserInput {
        match self {
            Self::PushToTalk => GamepadButtonType::Select.into(),
            Self::ToggleAlwaysOn => GamepadButtonType::Start.into(),
        }
    }

    fn default_wheel_mkb_binding(&self) -> UserInput {
        match self {
            Self::PushToTalk => KeyCode::ShiftRight.into(),
            Self::ToggleAlwaysOn => KeyCode::Scroll.into(),
        }
    }
    fn talk_wheel_gamepad_binding(&self) -> UserInput {
        match self {
            Self::PushToTalk => GamepadButtonType::Select.into(),
            Self::ToggleAlwaysOn => GamepadButtonType::Start.into(),
        }
    }

    fn talk_wheel_mkb_binding(&self) -> UserInput {
        match self {
            Self::PushToTalk => KeyCode::ShiftRight.into(),
            Self::ToggleAlwaysOn => KeyCode::Scroll.into(),
        }
    }
}
impl ToolAction for TalkToolAction {
    fn default_input_map(event: &ToolbeltPopulateEvent) -> Option<InputMap<TalkToolAction>> {
        match event.loadout {
            ToolbeltLoadout::Default => Some(Self::with_defaults(
                Self::default_wheel_gamepad_binding,
                Self::default_wheel_mkb_binding,
            )),
            ToolbeltLoadout::Keyboard => Some(Self::with_defaults(
                Self::talk_wheel_gamepad_binding,
                Self::talk_wheel_mkb_binding,
            )),
            _ => None,
        }
    }
}

fn spawn_worker_thread(mut commands: Commands) {
    let (tx, rx) = bounded::<_>(10);
    commands.insert_resource(Bridge { sender: tx });
    thread::spawn(move || loop {
        let action = match rx.recv() {
            Ok(action) => action,
            Err(e) => {
                error!("Failed to receive thread message, exiting: {:?}", e);
                break;
            }
        };
        debug!("Worker received thread message: {:?}", action);
        match match action {
            ThreadMessage::ListenButton(Motion::Down) => press_f23_key(),
            ThreadMessage::ListenButton(Motion::Up) => release_f23_key(),
        } {
            Ok(_) => {}
            Err(e) => {
                error!("Failed to handle event {:?}: {:?}", action, e);
            }
        }
    });
}

fn handle_input(
    tools: Query<&ActionState<TalkToolAction>, With<ActiveTool>>,
    bridge: ResMut<Bridge>,
    mut voice_command_events: EventWriter<VoiceToTextCommandEvent>,
    mut voice_status_events: EventWriter<VoiceToTextStatusEvent>,
    mut voice_status: ResMut<VoiceToTextStatus>,
) {
    for t_act in tools.iter() {
        if t_act.just_pressed(TalkToolAction::PushToTalk) {
            info!("Listen button pressed");
            match bridge
                .sender
                .send(ThreadMessage::ListenButton(Motion::Down))
            {
                Ok(_) => {}
                Err(e) => {
                    error!("Failed to send thread message: {:?}", e);
                }
            }
        }
        if t_act.just_released(TalkToolAction::PushToTalk) {
            info!("Listen button released");
            match bridge.sender.send(ThreadMessage::ListenButton(Motion::Up)) {
                Ok(_) => {}
                Err(e) => {
                    error!("Failed to send thread message: {:?}", e);
                }
            }
        }
        if t_act.just_pressed(TalkToolAction::ToggleAlwaysOn) {
            let VoiceToTextStatus::Alive { api_key, listening } = voice_status.clone() else {
                warn!("VoiceToTextStatus not Alive, ignoring event");
                continue;
            };
            let new_status = VoiceToTextStatus::Alive {
                api_key: api_key.clone(),
                listening: !listening,
            };

            let event = VoiceToTextCommandEvent::SetListening {
                listening: !listening,
                api_key,
            };
            info!("Sending event: {:?}", event);
            voice_command_events.send(event);

            let event = VoiceToTextStatusEvent::Changed {
                old_status: voice_status.clone(),
                new_status: new_status.clone(),
            };
            info!("Sending event: {:?}", event);
            voice_status_events.send(event);

            *voice_status = new_status;
        }
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\character\src\character_spawning_plugin.rs

````rust
use bevy::prelude::*;

use bevy_xpbd_2d::prelude::*;

use cursor_hero_bevy::prelude::NegativeYVec2;
use cursor_hero_camera::camera_plugin::CameraEvent;
use cursor_hero_character_types::prelude::*;
use cursor_hero_environment_types::prelude::*;
use cursor_hero_physics::damping_plugin::MovementDamping;
use cursor_hero_toolbelt_types::toolbelt_types::ToolbeltBundle;
use cursor_hero_toolbelt_types::toolbelt_types::ToolbeltLoadout;
use cursor_hero_toolbelt_types::toolbelt_types::ToolbeltPopulateEvent;
use cursor_hero_winutils::win_mouse::get_cursor_position;
pub struct CharacterSpawningPlugin;

impl Plugin for CharacterSpawningPlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(Startup, spawn_character);
    }
}

fn spawn_character(
    mut commands: Commands,
    asset_server: Res<AssetServer>,
    mut camera_events: EventWriter<CameraEvent>,
    mut writer: EventWriter<ToolbeltPopulateEvent>,
) {
    let os_cursor_pos = match get_cursor_position() {
        Ok(pos) => pos,
        Err(e) => {
            error!(
                "Failed to get cursor position, spawning character at (0,0): {}",
                e
            );
            IVec2::ZERO
        }
    };
    let mut character = commands.spawn((
        SpriteBundle {
            texture: asset_server.load(CharacterAppearance::Focused.get_texture_path()),
            sprite: Sprite {
                custom_size: Some(Vec2::new(50.0, 50.0)),
                ..default()
            },
            transform: Transform::from_translation(os_cursor_pos.as_vec2().neg_y().extend(100.0)),
            ..default()
        },
        Character,
        MainCharacter,
        MovementDamping { factor: 0.90 },
        Name::new("Character - (Human) Tume Eena"),
        // FloatyName {
        //     text: "Tume Eena".to_string(),
        //     vertical_offset: 40.0,
        //     appearance: NametagAppearance::Character,
        // },
        RigidBody::Kinematic,
        Collider::capsule(15.0, 12.5),
        TrackEnvironmentTag,
    ));
    camera_events.send(CameraEvent::BeginFollowing {
        target_id: character.id(),
    });
    let character_id = character.id();
    character.with_children(|c_commands| {
        let toolbelt = c_commands.spawn(ToolbeltBundle::default());
        writer.send(ToolbeltPopulateEvent {
            id: toolbelt.id(),
            loadout: ToolbeltLoadout::default(),
        });
        info!(
            "Sent populate default toolbelt event to fresh main character {:?}",
            character_id
        );
    });

    info!("Spawned character");
}

````



## D:\Repos\Games\Cursor-Hero\crates\observation\src\observation_tool_plugin.rs

````rust
use bevy::prelude::*;
use cursor_hero_character_types::character_types::AgentCharacter;
use cursor_hero_chat_types::chat_types::ChatEvent;
use cursor_hero_inference_types::prelude::*;
use cursor_hero_observation_types::prelude::*;
use cursor_hero_toolbelt_types::prelude::*;
use cursor_hero_tools::prelude::*;

pub struct ObservationToolPlugin;

impl Plugin for ObservationToolPlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(Update, toolbelt_events);
        app.add_systems(Update, tool_tick);
        app.add_systems(Update, handle_text_inference_response);
        app.add_systems(Update, handle_tts_inference_response);
    }
}

fn toolbelt_events(
    mut commands: Commands,
    asset_server: Res<AssetServer>,
    mut reader: EventReader<ToolbeltPopulateEvent>,
) {
    for event in reader.read() {
        if event.loadout == ToolbeltLoadout::Agent {
            ToolSpawnConfig::<ObservationTool, NoInputs>::new(
                ObservationTool::default(),
                event.id,
                event,
            )
            .with_src_path(file!().into())
            .guess_name(file!())
            .guess_image(file!(), &asset_server, "png")
            .with_description("Logs information about the environment to the console.")
            .with_starting_state(StartingState::Inactive)
            .spawn(&mut commands);
        }
    }
}

#[allow(clippy::type_complexity)]
fn tool_tick(
    mut tool_query: Query<(&Parent, &mut ObservationTool), With<ActiveTool>>,
    toolbelt_query: Query<&Parent, With<Toolbelt>>,
    mut character_query: Query<&mut ObservationBuffer>,
    mut events: EventWriter<TextInferenceEvent>,
) {
    for tool in tool_query.iter_mut() {
        let (tool_parent, mut tool) = tool;

        let Ok(toolbelt) = toolbelt_query.get(tool_parent.get()) else {
            warn!("Failed to get toolbelt");
            continue;
        };
        let toolbelt_parent = toolbelt;

        let character_id = toolbelt_parent.get();
        let Ok(character) = character_query.get_mut(character_id) else {
            warn!("Failed to get character");
            continue;
        };

        let character_observation_buffer = character;
        let whats_new = tool
            .last_inference
            .map(|last_inference| {
                character_observation_buffer
                    .observations
                    .iter()
                    .filter(|entry| entry.datetime > last_inference)
                    .map(|entry| entry.origin.into_whats_new(character_id))
                    .fold(WhatsNew::Nothing, |acc, new| acc.max(new))
            })
            .unwrap_or_else(|| {
                character_observation_buffer
                    .observations
                    .iter()
                    .map(|entry| entry.origin.into_whats_new(character_id))
                    .fold(WhatsNew::Nothing, |acc, new| acc.max(new))
            });

        // Update the field for debug viewing in the inspector
        tool._whats_new = Some(whats_new);

        // the agent will observe its own chats
        // so this check doesn't prevent all forms of loops
        if let WhatsNew::Nothing = whats_new {
            continue;
        }

        if let Some(last_inference) = tool.last_inference {
            if last_inference + whats_new.reply_delay() > chrono::Local::now() {
                continue;
            }
        }

        let mut chat_history = String::new();
        for entry in character_observation_buffer.observations.iter() {
            // let timestamp = entry.datetime.format("%Y-%m-%d %H:%M:%S").to_string();
            chat_history.push_str(entry.origin.to_string().as_str());
            chat_history.push('\n');
        }

        events.send(TextInferenceEvent::Request {
            session_id: character_id,
            prompt: TextPrompt::Chat {
                chat_history,
                options: Some(TextInferenceOptions {
                    stop: Some(vec![
                        "\n".to_string(),
                        "(Human)".to_string(),
                        "(Tume Eena)".to_string(),
                        "(Ithia Tig)".to_string(),
                    ]),
                    ..default()
                }),
            },
        });
        debug!("ObservationToolPlugin: Sent observation event");

        tool.last_inference = Some(chrono::Local::now());
    }
}

fn handle_text_inference_response(
    mut inference_events: EventReader<TextInferenceEvent>,
    mut chat_events: EventWriter<ChatEvent>,
    mut tts_events: EventWriter<SpeechInferenceEvent>,
    agent_query: Query<(), With<AgentCharacter>>,
) {
    for event in inference_events.read() {
        let TextInferenceEvent::Response {
            response,
            session_id,
            ..
        } = event
        else {
            continue;
        };
        if agent_query.get(*session_id).is_err() {
            // Only inference responses for agent sessions are to be converted to chat messages and spoken
            continue;
        }

        if response.is_empty() {
            debug!("Received empty response, skipping");
            continue;
        }

        let event = ChatEvent::Chat {
            character_id: *session_id,
            message: response.clone(),
        };
        debug!("Sending event: {:?}", event);
        chat_events.send(event);

        let event = SpeechInferenceEvent::Request {
            session_id: *session_id,
            prompt: SpeechPrompt::Raw {
                content: response.clone(),
            },
        };
        debug!("Sending event: {:?}", event);
        tts_events.send(event);
    }
}

fn handle_tts_inference_response(
    mut commands: Commands,
    mut tts_events: EventReader<SpeechInferenceEvent>,
    agent_query: Query<(), With<AgentCharacter>>,
    mut audio_assets: ResMut<Assets<AudioSource>>,
) {
    for event in tts_events.read() {
        if let SpeechInferenceEvent::Response {
            session_id, wav, ..
        } = event
        {
            if agent_query.get(*session_id).is_ok() {
                info!(
                    "Received TTS response for session {:?}, playing",
                    session_id
                );
                let audio = audio_assets.add(AudioSource {
                    bytes: wav.clone().into(),
                });
                commands.entity(*session_id).insert({
                    AudioBundle {
                        source: audio,
                        settings: PlaybackSettings::REMOVE.with_spatial(true),
                    }
                });
            }
        }
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\bevy\src\rect_scaled.rs

````rust
use bevy::math::IRect;
use bevy::math::Rect;
use bevy::math::URect;
use bevy::math::Vec2;

pub trait RectScale {
    fn scale(&self, scale: Vec2) -> Rect;
}
impl RectScale for Rect {
    fn scale(&self, scale: Vec2) -> Rect {
        Rect {
            min: self.min * scale,
            max: self.max * scale,
        }
    }
}

pub trait IRectScale {
    fn scale(&self, scale: Vec2) -> IRect;
}
impl IRectScale for IRect {
    fn scale(&self, scale: Vec2) -> IRect {
        IRect {
            min: (self.min.as_vec2() * scale).as_ivec2(),
            max: (self.max.as_vec2() * scale).as_ivec2(),
        }
    }
}

pub trait URectScale {
    fn scale(&self, scale: Vec2) -> URect;
}
impl URectScale for URect {
    fn scale(&self, scale: Vec2) -> URect {
        URect {
            min: (self.min.as_vec2() * scale).as_uvec2(),
            max: (self.max.as_vec2() * scale).as_uvec2(),
        }
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\chat_types\src\chat_types.rs

````rust
use bevy::prelude::*;
use bevy::utils::HashSet;
use cursor_hero_toolbelt_types::prelude::*;
use leafwing_input_manager::prelude::*;

#[derive(Component, Debug, Reflect, Default)]
pub struct ChatTool {
    pub focused: bool,
    pub buffer: String,
    pub tools_disabled_during_focus: HashSet<Entity>,
    pub state: ChatToolState,
}

#[derive(PartialEq, Reflect, Debug, Default, Clone)]
pub enum ChatToolState {
    #[default]
    Idle,
    InitialRepeatDelay(Timer),
    RepeatDelay(Timer),
}

#[derive(Component, Reflect, Default)]
pub struct ChatWheelTool;

#[derive(Actionlike, PartialEq, Eq, Clone, Copy, Hash, Debug, Reflect)]
pub enum ChatToolAction {
    Focus,
    Unfocus,
    Submit,
    WordModifier,
    Backspace,
}

impl ChatToolAction {
    fn default_gamepad_binding(&self) -> UserInput {
        match self {
            Self::Focus => GamepadButtonType::North.into(),
            Self::Unfocus => GamepadButtonType::East.into(),
            Self::Submit => GamepadButtonType::South.into(),
            Self::WordModifier => GamepadButtonType::LeftTrigger.into(),
            Self::Backspace => GamepadButtonType::West.into(),
        }
    }

    fn default_mkb_binding(&self) -> UserInput {
        match self {
            Self::Focus => KeyCode::Return.into(),
            Self::Unfocus => KeyCode::Escape.into(),
            Self::Submit => KeyCode::Return.into(),
            Self::WordModifier => KeyCode::ControlLeft.into(),
            Self::Backspace => KeyCode::Back.into(),
        }
    }
}
impl ToolAction for ChatToolAction {
    fn default_input_map(_event: &ToolbeltPopulateEvent) -> Option<InputMap<ChatToolAction>> {
        let mut input_map = InputMap::default();

        for variant in ChatToolAction::variants() {
            input_map.insert(variant.default_mkb_binding(), variant);
            input_map.insert(variant.default_gamepad_binding(), variant);
        }
        Some(input_map)
    }
}

#[derive(Event, PartialEq, Eq, Clone, Hash, Debug, Reflect)]
pub enum ChatEvent {
    Chat {
        character_id: Entity,
        message: String,
    },
}

#[derive(Event, PartialEq, Eq, Clone, Hash, Debug, Reflect)]
pub enum ChatInputEvent {
    Focus {
        tool_id: Entity,
        toolbelt_id: Entity,
        character_id: Entity,
    },
    Unfocus {
        tool_id: Entity,
        toolbelt_id: Entity,
        character_id: Entity,
    },
    TextChanged {
        character_id: Entity,
        toolbelt_id: Entity,
        tool_id: Entity,
    },
}

#[derive(Component, Reflect, Debug, Default)]
pub struct ChatInput;

#[derive(Component, Reflect, Debug, Default)]
pub struct ChatBubble {
    pub lifetime: Timer,
}

````



## D:\Repos\Games\Cursor-Hero\crates\winutils\examples\win_events_example.rs

````rust
use cursor_hero_winutils::win_events::create_os_event_listener;
use cursor_hero_winutils::win_events::ProcMessage;

fn main() {
    let args: Vec<String> = std::env::args().collect();
    if args.len() != 2 {
        eprintln!("Usage: <command> [all|events|mouse|keyboard]");
        std::process::exit(1);
    }

    let result = match args[1].as_str() {
        "all" => listen_all(),
        "events" => listen_events(),
        "mouse" => listen_mouse(),
        "keyboard" => listen_keyboard(),
        _ => {
            eprintln!("Invalid argument: choose from [all|events|mouse|keyboard]");
            std::process::exit(1);
        }
    };

    if let Err(e) = result {
        eprintln!("Error occurred: {:?}", e);
        std::process::exit(1);
    }
}

pub fn listen_all() -> Result<(), windows::core::Error> {
    let rx = create_os_event_listener()?;
    while let Ok(msg) = rx.recv() {
        println!("Received message: {:?}", msg);
    }
    Ok(())
}

pub fn listen_events() -> Result<(), windows::core::Error> {
    let rx = create_os_event_listener()?;
    while let Ok(msg) = rx.recv() {
        if !matches!(msg, ProcMessage::Event { .. }) {
            continue;
        }
        println!("Received message: {:?}", msg);
    }
    Ok(())
}

pub fn listen_mouse() -> Result<(), windows::core::Error> {
    let rx = create_os_event_listener()?;
    while let Ok(msg) = rx.recv() {
        if !matches!(msg, ProcMessage::MouseMoved { .. }) {
            continue;
        }
        println!("Received message: {:?}", msg);
    }
    Ok(())
}

pub fn listen_keyboard() -> Result<(), windows::core::Error> {
    let rx = create_os_event_listener()?;
    while let Ok(msg) = rx.recv() {
        if !matches!(msg, ProcMessage::KeyDown { .. }) {
            continue;
        }
        println!("Received message: {:?}", msg);
    }
    Ok(())
}

````



## D:\Repos\Games\Cursor-Hero\crates\ui_automation\src\resolve_app.rs

````rust
use cursor_hero_ui_automation_types::prelude::*;
use uiautomation::controls::ControlType;
use uiautomation::UIAutomation;
use uiautomation::UIElement;

use crate::resolve_calculator::resolve_calculator;
use crate::resolve_vscode::resolve_vscode;

pub(crate) fn resolve_app(
    elem: &UIElement,
    automation: &UIAutomation,
    focused: bool,
) -> Result<AppWindow, AppResolveError> {
    match (
        elem.get_name(),
        elem.get_control_type(),
        elem.get_classname(),
    ) {
        (Ok(name), Ok(ControlType::Pane), Ok(class_name))
            if name.ends_with("Visual Studio Code") && class_name == "Chrome_WidgetWin_1" =>
        {
            resolve_vscode(elem, automation, focused)
        }
        (Ok(name), Ok(ControlType::Window), Ok(class_name))
            if name == "Calculator" && class_name == "ApplicationFrameWindow" =>
        {
            resolve_calculator(elem, automation, focused)
        }
        _ => Err(AppResolveError::NoMatch),
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\toolbelt\src\tool_help_activate.rs

````rust
use cursor_hero_toolbelt_types::toolbelt_types::*;

use bevy::prelude::*;
use bevy_xpbd_2d::components::Collider;
use bevy_xpbd_2d::components::RigidBody;
use cursor_hero_pointer_types::prelude::*;

use cursor_hero_xelu_prompts::texture_path_for_input;
use leafwing_input_manager::prelude::*;

pub fn tool_help_activation(
    mut commands: Commands,
    toolbelt_query: Query<(&ActionState<ToolbeltAction>, &Children, &GlobalTransform)>,
    tool_query: Query<(&Tool, &Children)>,
    hovered_query: Query<&GlobalTransform, (With<Hovered>, With<ToolHelpTrigger>)>,
    asset_server: Res<AssetServer>,
) {
    for (toolbelt_actions, toolbelt_children, toolbelt_transform) in toolbelt_query.iter() {
        if toolbelt_actions.just_released(ToolbeltAction::Show) {
            // check all the toolbelt children
            for tool_id in toolbelt_children {
                // if the child is a tool
                if let Ok((tool, tool_children)) = tool_query.get(*tool_id) {
                    // and the tool has children
                    for tool_child_id in tool_children.iter() {
                        // and the hovered child is a tool help trigger
                        if let Ok(hovered_transform) = hovered_query.get(*tool_child_id) {
                            let toolbelt_position = toolbelt_transform.translation();
                            let hovered_position = hovered_transform.translation();
                            let look = hovered_position - toolbelt_position;
                            let position = hovered_position + look;
                            spawn_help_for_tool(&mut commands, position, tool, &asset_server);
                        }
                    }
                }
            }
        }
    }
}

pub fn spawn_help_for_tool(
    commands: &mut Commands,
    position: Vec3,
    tool: &Tool,
    asset_server: &Res<AssetServer>,
) {
    info!("Spawning help for tool: {:?}", tool.name);
    let mut parent_commands = commands.spawn((
        Name::new(format!("Help for {}", tool.name)),
        SpriteBundle {
            sprite: Sprite {
                custom_size: Some(Vec2::new(100.0, 100.0)),
                color: Color::rgba(0.5, 0.5, 1.0, 0.8),
                ..default()
            },
            transform: Transform::from_translation(position),
            ..default()
        },
        ToolHelp {
            timer: Timer::from_seconds(25.0, TimerMode::Once),
        },
        RigidBody::Dynamic,
        Collider::cuboid(100.0, 100.0),
    ));
    parent_commands.with_children(|parent| {
        // image
        parent.spawn(SpriteBundle {
            sprite: Sprite {
                custom_size: Some(Vec2::new(100.0, 100.0)),
                ..default()
            },
            texture: tool.texture.clone(),
            transform: Transform::from_xyz(0.0, 0.0, 1.0),
            ..default()
        });
        // name
        parent.spawn(Text2dBundle {
            text: Text::from_section(
                tool.name.clone(),
                TextStyle {
                    font_size: 20.0,
                    color: Color::WHITE,
                    ..default()
                },
            )
            .with_alignment(TextAlignment::Center),
            transform: Transform::from_xyz(0.0, 60.0, 1.0),
            ..default()
        });
        // description
        parent.spawn(Text2dBundle {
            text: Text::from_section(
                tool.description.clone(),
                TextStyle {
                    font_size: 20.0,
                    color: Color::WHITE,
                    ..default()
                },
            )
            .with_alignment(TextAlignment::Center),
            transform: Transform::from_xyz(0.0, -60.0, 1.0),
            ..default()
        });

        // actions
        let action_start_y = -100.0; // Starting y position for actions
        let action_spacing_y = 40.0; // Space between each action
        let action_name_x = -150.0;
        let key_size = 50.0; // Size of each key
        let key_spacing_x = key_size + 15.0; // Space between each key
        for (i, (action_name, action_inputs)) in tool.actions.iter().enumerate() {
            let action_y = action_start_y - (i as f32 * action_spacing_y);

            // Action name text
            parent.spawn(Text2dBundle {
                text: Text::from_section(
                    format!("{:?}", action_name),
                    TextStyle {
                        font_size: 20.0,
                        color: Color::WHITE,
                        ..default()
                    },
                )
                .with_alignment(TextAlignment::Center),
                transform: Transform::from_xyz(action_name_x, action_y, 0.2), // Place text to the left
                ..default()
            });

            // Keys for action
            let mut key_x = 25.0; // Starting x position for keys
            for action in action_inputs.iter() {
                let key_position = Vec3::new(key_x, action_y, 0.2); // Calculate the position for the key
                key_x += key_spacing_x; // Move the x position for the next key

                match action {
                    UserInput::Single(kind) => match texture_path_for_input(kind) {
                        Some(path) => {
                            parent.spawn(SpriteBundle {
                                sprite: Sprite {
                                    custom_size: Some(Vec2::new(key_size, key_size)),
                                    ..default()
                                },
                                texture: asset_server.load(path),
                                transform: Transform::from_translation(key_position),
                                ..default()
                            });
                        }
                        None => {
                            warn!("No texture for input: {:?}", kind);
                        }
                    },
                    _ => {
                        warn!(
                            "Only single inputs are supported for tool help, got {:?}",
                            action
                        );
                    }
                }
            }
        }
    });
}

````



## D:\Repos\Games\Cursor-Hero\crates\start_menu_types\src\start_menu_types.rs

````rust
use bevy::prelude::*;

#[derive(Component, Debug, Reflect)]
pub struct StartMenuButton;

#[derive(Component, Debug, Reflect)]
pub struct StartMenu;

#[derive(Event, Debug, Reflect)]
pub enum StartMenuEvent {
    Open { start_menu_button_id: Entity },
    Close { start_menu_button_id: Entity },
}

````



## D:\Repos\Games\Cursor-Hero\crates\window_position_types\src\window_position_types.rs

````rust
use bevy::prelude::*;
use bevy::window::WindowMode;
use bevy::window::WindowResolution;

#[derive(Debug, Reflect)]
pub enum HostWindowPosition {
    Fullscreen {
        monitor: u32,
    },
    Corner {
        corner: cursor_hero_math::prelude::Corner,
        monitor: u32,
    },
}

#[derive(Component, Reflect, Default)]
pub struct WindowPositionLoadoutSwitcherTool;

#[derive(Component, Reflect)]
pub struct WindowPositionTool {
    pub window_position: HostWindowPosition,
}

#[derive(Event, Reflect, Debug, Clone)]
pub struct WindowPositionCommand {
    pub window: Entity,
    pub mode: Option<WindowMode>,
    pub resolution: Option<WindowResolution>,
    pub position: Option<WindowPosition>,
}

````



## D:\Repos\Games\Cursor-Hero\crates\bevy\src\rect_expand.rs

````rust
use bevy::math::IRect;
use bevy::math::IVec2;

use cursor_hero_math::prelude::Corner;
pub trait IExpandable {
    fn expand(&self, amount: IVec2) -> IRect;
    fn expand_from(&self, corner: Corner, amount: IVec2) -> IRect;
}
impl IExpandable for IRect {
    fn expand(&self, amount: IVec2) -> IRect {
        IRect::from_center_size(self.center(), self.size() + amount)
    }
    fn expand_from(&self, corner: Corner, amount: IVec2) -> IRect {
        match corner {
            Corner::TopLeft => IRect {
                min: self.min - amount,
                max: self.max,
            },
            Corner::TopRight => IRect {
                min: self.min - IVec2::new(0, amount.y),
                max: self.max + IVec2::new(amount.x, 0),
            },
            Corner::BottomLeft => IRect {
                min: self.min - IVec2::new(amount.x, 0),
                max: self.max + IVec2::new(0, amount.y),
            },
            Corner::BottomRight => IRect {
                min: self.min,
                max: self.max + amount,
            },
        }
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\host_fs_types\src\lib.rs

````rust
pub mod host_fs_types;
pub mod host_fs_types_plugin;

pub mod prelude {
    pub use crate::host_fs_types::*;
    pub use crate::host_fs_types_plugin::*;
}

````



## D:\Repos\Games\Cursor-Hero\crates\ui\src\position_text_plugin.rs

````rust
use bevy::prelude::*;
use bevy::window::PrimaryWindow;
use cursor_hero_camera::camera_plugin::MainCamera;
use cursor_hero_character_types::prelude::*;

pub struct PositionTextPlugin;

impl Plugin for PositionTextPlugin {
    fn build(&self, app: &mut App) {
        app.register_type::<CharacterPositionText>();
        app.register_type::<MouseWorldPositionText>();
        app.register_type::<MouseScreenPositionText>();
        app.add_systems(Startup, setup_position_text);
        app.add_systems(Update, update_position_text);
    }
}

#[derive(Component, Reflect)]
struct CharacterPositionText;
#[derive(Component, Reflect)]
struct MouseWorldPositionText;
#[derive(Component, Reflect)]
struct MouseScreenPositionText;

fn setup_position_text(mut commands: Commands, asset_server: Res<AssetServer>) {
    commands.spawn((
        TextBundle::from_section(
            "Character: ",
            TextStyle {
                font: asset_server.load("fonts/FiraSans-Bold.ttf"),
                font_size: 16.0,
                ..default()
            },
        )
        .with_style(Style {
            position_type: PositionType::Absolute,
            bottom: Val::Px(5.0),
            left: Val::Px(5.0),
            ..default()
        }),
        CharacterPositionText,
        Name::new("Character Position Text"),
    ));
    commands.spawn((
        TextBundle::from_section(
            "Mouse Cursor: ",
            TextStyle {
                font: asset_server.load("fonts/FiraSans-Bold.ttf"),
                font_size: 16.0,
                ..default()
            },
        )
        .with_style(Style {
            position_type: PositionType::Absolute,
            bottom: Val::Px(15.0),
            left: Val::Px(5.0),
            ..default()
        }),
        MouseWorldPositionText,
        Name::new("Mouse Cursor Position Text"),
    ));
    commands.spawn((
        TextBundle::from_section(
            "Mouse Screen: ",
            TextStyle {
                font: asset_server.load("fonts/FiraSans-Bold.ttf"),
                font_size: 16.0,
                ..default()
            },
        )
        .with_style(Style {
            position_type: PositionType::Absolute,
            bottom: Val::Px(25.0),
            left: Val::Px(5.0),
            ..default()
        }),
        MouseScreenPositionText,
        Name::new("Mouse Screen Position Text"),
    ));
}

#[allow(clippy::type_complexity)]
fn update_position_text(
    character_query: Query<(&Character, &Transform), With<Character>>,
    camera_query: Query<(&Camera, &GlobalTransform), With<MainCamera>>,
    window_query: Query<&Window, With<PrimaryWindow>>,
    mut character_position_text_query: Query<
        &mut Text,
        (
            With<CharacterPositionText>,
            Without<MouseWorldPositionText>,
            Without<MouseScreenPositionText>,
        ),
    >,
    mut mouse_world_position_text_query: Query<
        &mut Text,
        (
            With<MouseWorldPositionText>,
            Without<CharacterPositionText>,
            Without<MouseScreenPositionText>,
        ),
    >,
    mut mouse_screen_position_text_query: Query<
        &mut Text,
        (
            With<MouseScreenPositionText>,
            Without<CharacterPositionText>,
            Without<MouseWorldPositionText>,
        ),
    >,
    // mut text_query: Query<&mut Text, With<CharacterPositionText>>,
) {
    for (_character, transform) in character_query.iter() {
        character_position_text_query.single_mut().sections[0].value = format!(
            "Character: {:.2}, {:.2}, {:.2}",
            transform.translation.x, transform.translation.y, transform.translation.z
        );
    }

    let (camera, camera_transform) = camera_query.single();
    let window = window_query.single();
    // check if the cursor is inside the window and get its position
    // then, ask bevy to convert into world coordinates, and truncate to discard Z
    if let Some(world_position) = window
        .cursor_position()
        .and_then(|cursor| camera.viewport_to_world(camera_transform, cursor))
        .map(|ray| ray.origin.truncate())
    {
        mouse_world_position_text_query.single_mut().sections[0].value = format!(
            "Mouse world: {:.2}, {:.2}",
            world_position.x, world_position.y,
        );
    } else {
        mouse_world_position_text_query.single_mut().sections[0].value =
            "Mouse world: None".to_string();
    }
    if let Some(cursor_position) = window.cursor_position() {
        mouse_screen_position_text_query.single_mut().sections[0].value = format!(
            "Mouse screen: {:.2}, {:.2}",
            cursor_position.x, cursor_position.y,
        );
    } else {
        mouse_screen_position_text_query.single_mut().sections[0].value =
            "Mouse screen: None".to_string();
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\inference_types\src\inference_types_plugin.rs

````rust
use crate::prelude::*;
use bevy::prelude::*;
pub struct InferenceTypesPlugin;

impl Plugin for InferenceTypesPlugin {
    fn build(&self, app: &mut App) {
        app.register_type::<TextPrompt>();
        app.register_type::<MaterializedTextPrompt>();
        app.register_type::<TextInferenceEvent>();
        app.add_event::<TextInferenceEvent>();

        app.register_type::<SpeechPrompt>();
        app.register_type::<SpeechInferenceEvent>();
        app.add_event::<SpeechInferenceEvent>();

        app.register_type::<TranscriptionPrompt>();
        app.register_type::<TranscriptionInferenceEvent>();
        app.add_event::<TranscriptionInferenceEvent>();
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\window_position\src\window_position_command_plugin.rs

````rust
use bevy::prelude::*;
use cursor_hero_window_position_types::window_position_types::WindowPositionCommand;

pub struct WindowPositionCommandPlugin;

impl Plugin for WindowPositionCommandPlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(Update, handle_commands);
    }
}

fn handle_commands(
    mut command_queue: EventReader<WindowPositionCommand>,
    mut window_query: Query<&mut Window>,
) {
    for command in command_queue.read() {
        let Ok(window) = window_query.get_mut(command.window) else {
            warn!("Window {:?} not found", command.window);
            continue;
        };
        debug!("Handling command {:?}", command);
        let mut window = window;
        if let Some(position) = command.position {
            window.position = position;
        }
        if let Some(resolution) = &command.resolution {
            window.resolution = resolution.clone();
        }
        if let Some(mode) = command.mode {
            window.mode = mode;
        }
        // only handle one command a tick
        break;
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\input\src\lib.rs

````rust
pub mod active_input_state_plugin;
pub mod input_plugin;
pub mod update_gamepad_settings;

pub use input_plugin::InputPlugin;

````



## D:\Repos\Games\Cursor-Hero\crates\plugins\src\lib.rs

````rust
use cursor_hero_input::active_input_state_plugin::InputMethod;
use bevy::input::common_conditions::input_toggle_active;
use bevy::prelude::*;

use bevy::audio::AudioPlugin;
use bevy::audio::SpatialScale;
use bevy::diagnostic::FrameTimeDiagnosticsPlugin;
use bevy::log::LogPlugin;
use bevy_embedded_assets::EmbeddedAssetPlugin;
use bevy_inspector_egui::quick::StateInspectorPlugin;
use bevy_inspector_egui::quick::WorldInspectorPlugin;
use cursor_hero_agent::agent_plugin::AgentPlugin;
use cursor_hero_camera::camera_plugin::CameraPlugin;
use cursor_hero_character::character_plugin::CharacterPlugin;
use cursor_hero_cursor_mirror::cursor_mirroring_plugin::CursorMirroringPlugin;
use cursor_hero_environment::environment_plugin::EnvironmentPlugin;
use cursor_hero_environment_nametag::environment_nametag_plugin::EnvironmentNametagPlugin;
use cursor_hero_hover::hover_tool::HoverToolPlugin;
use cursor_hero_hover::hover_ui_automation_plugin::HoverUiAutomationPlugin;
use cursor_hero_hover::inspect_wheel_tool::InspectWheelToolPlugin;
use cursor_hero_hover::screenshot_tool::ScreenshotToolPlugin;
use cursor_hero_icon::IconPlugin;
use cursor_hero_input::InputPlugin;
use cursor_hero_level_bounds::level_bounds_plugin::LevelBoundsPlugin;
use cursor_hero_math::prelude::MathPlugin;
use cursor_hero_physics::damping_plugin::DampingPlugin;
use cursor_hero_physics::physics_plugin::PhysicsPlugin;
use cursor_hero_physics_debug::physics_debug_plugin::PhysicsDebugPlugin;
use cursor_hero_pointer::pointer_plugin::PointerPlugin;
use cursor_hero_pointer_types::pointer_types_plugin::PointerTypesPlugin;
use cursor_hero_pressure_plate::pressure_plate_plugin::PressurePlatePlugin;
use cursor_hero_screen::screen_plugin::ScreenPlugin;
use cursor_hero_screen::screen_update_plugin::ScreenUpdatePlugin;
use cursor_hero_sprint_tool::sprint_tool_plugin::SprintToolPlugin;
use cursor_hero_sprint_tool_types::sprint_tool_types_plugin::SprintToolTypesPlugin;
use cursor_hero_taskbar::taskbar_plugin::TaskbarPlugin;
use cursor_hero_toolbelt::toolbelt_plugin::ToolbeltPlugin;
use cursor_hero_toolbelt_types::toolbelt_types_plugin::ToolbeltTypesPlugin;
use cursor_hero_tools::ToolPlugin;
use cursor_hero_ui::about_text_plugin::AboutTextPlugin;
use cursor_hero_ui::fps_text_plugin::FpsTextPlugin;
use cursor_hero_version::version_plugin::Version;
use cursor_hero_wallpaper::wallpaper_plugin::WallpaperPlugin;

use cursor_hero_agent_types::agent_types_plugin::AgentTypesPlugin;
use cursor_hero_app::prelude::*;
use cursor_hero_app_types::prelude::*;
use cursor_hero_brick::prelude::*;
use cursor_hero_brick_types::prelude::*;
use cursor_hero_calculator_app::prelude::*;
use cursor_hero_calculator_app_types::prelude::*;
use cursor_hero_character_types::character_types_plugin::CharacterTypesPlugin;
use cursor_hero_chat::chat_plugin::ChatPlugin;
use cursor_hero_chat_types::chat_types_plugin::ChatTypesPlugin;
use cursor_hero_environment_types::environment_types_plugin::EnvironmentTypesPlugin;
use cursor_hero_floaty_nametag::prelude::*;
use cursor_hero_floaty_nametag_types::prelude::*;
use cursor_hero_fullscreen_tool::prelude::*;
use cursor_hero_fullscreen_tool_types::prelude::*;
use cursor_hero_glados_tts::prelude::*;
use cursor_hero_glados_tts_types::prelude::*;
use cursor_hero_host_event::prelude::*;
use cursor_hero_host_event_types::prelude::*;
use cursor_hero_host_fs::prelude::*;
use cursor_hero_host_fs_types::prelude::*;
use cursor_hero_inference::inference_plugin::InferencePlugin;
use cursor_hero_inference_types::inference_types_plugin::InferenceTypesPlugin;
use cursor_hero_memory::prelude::*;
use cursor_hero_memory_types::prelude::*;
use cursor_hero_movement_tool::movement_tool_plugin::MovementToolPlugin;
use cursor_hero_movement_tool_types::movement_tool_types_plugin::MovementToolTypesPlugin;
use cursor_hero_observation::observation_plugin::ObservationPlugin;
use cursor_hero_observation_types::observation_types_plugin::ObservationTypesPlugin;
use cursor_hero_ollama::prelude::*;
use cursor_hero_ollama_types::prelude::*;
use cursor_hero_secret::prelude::*;
use cursor_hero_secret_types::prelude::*;
use cursor_hero_start_menu::prelude::*;
use cursor_hero_start_menu_types::prelude::*;
use cursor_hero_taskbar_tool::prelude::*;
use cursor_hero_taskbar_types::prelude::TaskbarTypesPlugin;
use cursor_hero_text_asset::prelude::*;
use cursor_hero_text_asset_types::prelude::*;
use cursor_hero_ui_automation::prelude::*;
use cursor_hero_ui_watcher::prelude::*;
use cursor_hero_ui_watcher_types::prelude::*;
use cursor_hero_voice_to_text::prelude::*;
use cursor_hero_voice_to_text_types::prelude::*;
use cursor_hero_window_position::prelude::*;
use cursor_hero_window_position_types::prelude::*;
use cursor_hero_window_swap_tool::prelude::*;
use cursor_hero_window_swap_tool_types::prelude::*;
pub struct MyPlugin;

impl Plugin for MyPlugin {
    fn build(&self, app: &mut App) {
        app.add_plugins(MemoryTypesPlugin);
        app.add_plugins(MemoryPlugin);
        app.add_plugins(WindowSwapToolPlugin);
        app.add_plugins(WindowSwapToolTypesPlugin);
        app.add_plugins(HostFsTypesPlugin);
        app.add_plugins(HostFsPlugin);
        app.add_plugins(WindowPositionTypesPlugin);
        app.add_plugins(WindowPositionPlugin);
        app.add_plugins(UiAutomationTypesPlugin);
        app.add_plugins(UiAutomationPlugin);
        app.add_plugins(BrickTypesPlugin);
        app.add_plugins(BrickPlugin);
        app.add_plugins(FullscreenToolPlugin);
        app.add_plugins(FullscreenToolTypesPlugin);
        app.add_plugins(UiWatcherTypesPlugin);
        app.add_plugins(UiWatcherPlugin);
        app.add_plugins(FloatyNametagTypesPlugin);
        app.add_plugins(FloatyNametagPlugin);
        app.add_plugins(HostEventTypesPlugin);
        app.add_plugins(HostEventPlugin);
        app.add_plugins(TaskbarToolPlugin);
        app.add_plugins(StartMenuTypesPlugin);
        app.add_plugins(StartMenuPlugin);
        app.add_plugins(CalculatorAppTypesPlugin);
        app.add_plugins(CalculatorAppPlugin);
        app.add_plugins(AppTypesPlugin);
        app.add_plugins(AppPlugin);
        app.add_plugins(SecretsTypesPlugin);
        app.add_plugins(SecretsPlugin);
        app.add_plugins(VoiceToTextTypesPlugin);
        app.add_plugins(VoiceToTextPlugin);
        app.add_plugins(GladosTtsTypesPlugin);
        app.add_plugins(GladosTtsPlugin);
        app.add_plugins(OllamaTypesPlugin);
        app.add_plugins(OllamaPlugin);
        app.add_plugins(EnvironmentTypesPlugin);
        app.add_plugins(ChatTypesPlugin);
        app.add_plugins(ChatPlugin);
        app.add_plugins(ObservationTypesPlugin);
        app.add_plugins(ObservationPlugin);
        app.add_plugins(InferenceTypesPlugin);
        app.add_plugins(InferencePlugin);
        app.add_plugins(MovementToolTypesPlugin);
        app.add_plugins(MovementToolPlugin);
        app.add_plugins(CharacterTypesPlugin);
        app.add_plugins(AgentTypesPlugin);
        app.add_plugins(AgentPlugin);
        app.add_plugins(AboutTextPlugin);
        app.add_plugins(CameraPlugin);
        app.add_plugins(CharacterPlugin);
        app.add_plugins(CursorMirroringPlugin);
        app.add_plugins(DampingPlugin);
        app.add_plugins(EnvironmentNametagPlugin);
        app.add_plugins(EnvironmentPlugin);
        app.add_plugins(FpsTextPlugin);
        app.add_plugins(HoverToolPlugin);
        app.add_plugins(HoverUiAutomationPlugin);
        app.add_plugins(IconPlugin);
        app.add_plugins(InputPlugin);
        app.add_plugins(ScreenshotToolPlugin);
        app.add_plugins(InspectWheelToolPlugin);
        app.add_plugins(LevelBoundsPlugin);
        app.add_plugins(MathPlugin);
        app.add_plugins(PhysicsDebugPlugin);
        app.add_plugins(PhysicsPlugin);
        app.add_plugins(PointerPlugin);
        app.add_plugins(PointerTypesPlugin);
        app.add_plugins(PressurePlatePlugin);
        app.add_plugins(ScreenPlugin);
        app.add_plugins(ScreenUpdatePlugin);
        app.add_plugins(SprintToolPlugin);
        app.add_plugins(SprintToolTypesPlugin);
        app.add_plugins(TaskbarPlugin);
        app.add_plugins(ToolbeltPlugin);
        app.add_plugins(ToolbeltTypesPlugin);
        app.add_plugins(ToolPlugin);
        app.add_plugins(WallpaperPlugin);

        // must be before the default plugins
        app.add_plugins(EmbeddedAssetPlugin {
            mode: bevy_embedded_assets::PluginMode::ReplaceDefault,
        });

        #[cfg(debug_assertions)]
        let log_plugin = LogPlugin {
            level: bevy::log::Level::DEBUG,
            filter: "
info,
wgpu_core=warn,
wgpu_hal=warn,
bevy_ecs=info,
cursor_hero=debug,
cursor_hero_pointer::pointer_hover_plugin=info,
cursor_hero_ollama::ollama_status_worker_plugin=info,
cursor_hero_voice_to_text::voice_to_text_ping_plugin=info,
cursor_hero_voice_to_text::voice_to_text_worker_plugin=info,
cursor_hero_glados_tts::glados_tts_status_worker_plugin=info,
cursor_hero_tools::click_tool=info,
cursor_hero_memory=info
            "
            .replace('\n', "")
            .trim()
            .into(),
            // TODO: fix warnings when minimized
        };
        //         #[cfg(debug_assertions)]
        //         let log_plugin = LogPlugin {
        //             level: bevy::log::Level::DEBUG,
        //             filter: "
        // debug
        //             ".replace('\n',"").trim().into(),
        //             // TODO: fix warnings when minimized
        //         };
        #[cfg(not(debug_assertions))]
        let log_plugin = LogPlugin {
            level: bevy::log::Level::INFO,
            filter: "info,wgpu_core=warn,wgpu_hal=warn".into(),
        };
        const AUDIO_SCALE: f32 = 1. / 100.0;
        let version = match app.world.get_resource::<Version>() {
            Some(version) => version.0.clone(),
            None => {
                warn!("Version resource not found");
                "Unknown".to_string()
            }
        };
        app.add_plugins(
            DefaultPlugins
                .set(ImagePlugin::default_nearest())
                .set(AudioPlugin {
                    spatial_scale: SpatialScale::new_2d(AUDIO_SCALE),
                    ..default()
                })
                .set(WindowPlugin {
                    primary_window: Some(Window {
                        transparent: true,
                        title: format!("Cursor Hero v{}", version),
                        resizable: true,
                        ..default()
                    }),
                    ..default()
                })
                .set(log_plugin)
                .build(),
        );

        // must be after the default plugins (relies on assetserver existing)
        app.add_plugins(TextAssetTypesPlugin);
        app.add_plugins(TextAssetPlugin);
        app.add_plugins(TaskbarTypesPlugin);

        // must be after the default plugins
        app.add_plugins(
            WorldInspectorPlugin::default().run_if(input_toggle_active(false, KeyCode::Grave)),
        );
        app.add_plugins(
            StateInspectorPlugin::<InputMethod>::default().run_if(input_toggle_active(false, KeyCode::Grave)),
        );
        app.add_plugins(FrameTimeDiagnosticsPlugin);
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\window_position_types\src\lib.rs

````rust
pub mod window_position_types;
pub mod window_position_types_plugin;

pub mod prelude {
    pub use crate::window_position_types::*;
    pub use crate::window_position_types_plugin::*;
}

````



## D:\Repos\Games\Cursor-Hero\crates\movement_tool_types\src\lib.rs

````rust
pub mod movement_tool_types;
pub mod movement_tool_types_plugin;

pub mod prelude {
    pub use crate::movement_tool_types::*;
    pub use crate::movement_tool_types_plugin::*;
}

````



## D:\Repos\Games\Cursor-Hero\crates\floaty_nametag_types\src\lib.rs

````rust
pub mod floaty_nametag_types;
pub mod floaty_nametag_types_plugin;

pub mod prelude {
    pub use crate::floaty_nametag_types::*;
    pub use crate::floaty_nametag_types_plugin::*;
}

````



## D:\Repos\Games\Cursor-Hero\crates\taskbar_tool\src\taskbar_wheel_tool.rs

````rust
use bevy::prelude::*;
use bevy_xpbd_2d::components::Position;
use cursor_hero_bevy::prelude::NegativeYVec2;
use cursor_hero_screen::get_image::get_image;
use cursor_hero_screen::get_image::ScreensToImageParam;
use cursor_hero_toolbelt_types::prelude::*;
use cursor_hero_tools::prelude::*;
use cursor_hero_ui_automation::prelude::find_element_at;
use cursor_hero_ui_automation::prelude::get_taskbar;
use cursor_hero_ui_automation::prelude::TaskbarEntry;

pub struct TaskbarWheelToolPlugin;

impl Plugin for TaskbarWheelToolPlugin {
    fn build(&self, app: &mut App) {
        app.register_type::<TaskbarWheelTool>();
        app.register_type::<TaskbarEntryTool>();
        app.add_systems(Update, toolbelt_events);
        app.add_systems(Update, tick_wheel_switcher);
        app.add_systems(Update, tick_taskbar_switcher);
    }
}

#[derive(Component, Reflect, Default)]
struct TaskbarWheelTool;

#[derive(Component, Reflect)]
struct TaskbarEntryTool {
    entry: TaskbarEntry,
}

fn toolbelt_events(
    mut commands: Commands,
    asset_server: Res<AssetServer>,
    mut reader: EventReader<ToolbeltPopulateEvent>,
    access: ScreensToImageParam,
) {
    for event in reader.read() {
        match event.loadout {
            ToolbeltLoadout::Default => {
                ToolSpawnConfig::<TaskbarWheelTool, NoInputs>::new(
                    TaskbarWheelTool,
                    event.id,
                    event,
                )
                .with_src_path(file!().into())
                .guess_name(file!())
                .guess_image(file!(), &asset_server, "png")
                .with_description("Swaps to taskbar tools")
                .with_starting_state(StartingState::Inactive)
                .spawn(&mut commands);
            }
            ToolbeltLoadout::Taskbar => {
                let Ok(taskbar) = get_taskbar() else {
                    continue;
                };
                for entry in taskbar.entries {
                    let Ok(image) = get_image(entry.bounds.as_rect(), &access) else {
                        warn!("Failed to get image for {:?}", &entry);
                        continue;
                    };
                    ToolSpawnConfig::<TaskbarEntryTool, NoInputs>::new(
                        TaskbarEntryTool {
                            entry: entry.clone(),
                        },
                        event.id,
                        event,
                    )
                    .with_src_path(file!().into())
                    .with_name(entry.name)
                    .with_description("Swaps to taskbar tools")
                    .with_image(asset_server.add(image))
                    .with_size(entry.bounds.size().as_vec2())
                    .with_starting_state(StartingState::Inactive)
                    .spawn(&mut commands);
                }
            }
            _ => {}
        }
    }
}

fn tick_wheel_switcher(
    mut commands: Commands,
    tool_query: Query<&Parent, (Added<ActiveTool>, With<TaskbarWheelTool>)>,
    mut toolbelt_events: EventWriter<ToolbeltPopulateEvent>,
) {
    for toolbelt_id in tool_query.iter() {
        let toolbelt_id = toolbelt_id.get();
        commands.entity(toolbelt_id).despawn_descendants();
        toolbelt_events.send(ToolbeltPopulateEvent {
            id: toolbelt_id,
            loadout: ToolbeltLoadout::Taskbar,
        });
    }
}

fn tick_taskbar_switcher(
    mut commands: Commands,
    tool_query: Query<(&Parent, &TaskbarEntryTool), Added<ActiveTool>>,
    toolbelt_query: Query<&Parent, With<Toolbelt>>,
    mut character_query: Query<&mut Position>,
    mut toolbelt_events: EventWriter<ToolbeltPopulateEvent>,
) {
    for (toolbelt_id, tool) in tool_query.iter() {
        let toolbelt_id = toolbelt_id.get();
        if let Ok(character_id) = toolbelt_query.get(toolbelt_id) {
            info!("Switching toolbelt {:?} to default tools", toolbelt_id);
            let character_id = character_id.get();
            commands.entity(toolbelt_id).despawn_descendants();
            toolbelt_events.send(ToolbeltPopulateEvent {
                id: toolbelt_id,
                loadout: ToolbeltLoadout::Default,
            });
            if let Ok(mut position) = character_query.get_mut(character_id) {
                let center = tool.entry.bounds.center();
                position.0 = center.as_vec2().neg_y();
                if let Ok(elem) = find_element_at(center) {
                    if let Err(e) = elem.click() {
                        warn!("Failed to click taskbar entry: {:?}", e);
                    }
                }
            }
        }
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\movement_tool\src\movement_tool_tick_plugin.rs

````rust
use bevy::prelude::*;
use cursor_hero_character_types::prelude::*;
use cursor_hero_movement_tool_types::prelude::*;
use cursor_hero_physics::damping_plugin::DampingSystemSet;
use cursor_hero_toolbelt_types::prelude::*;
use leafwing_input_manager::prelude::*;

use bevy_xpbd_2d::math::*;
use bevy_xpbd_2d::prelude::*;

pub struct MovementToolTickPlugin;

impl Plugin for MovementToolTickPlugin {
    fn build(&self, app: &mut App) {
        app.add_plugins(InputManagerPlugin::<MovementToolAction>::default());
        app.add_systems(Update, handle_inputs.after(DampingSystemSet::Dampen));
    }
}

fn handle_inputs(
    time: Res<Time<Physics>>,
    tool_query: Query<(&ActionState<MovementToolAction>, &MovementTool, &Parent), With<ActiveTool>>,
    toolbelt_query: Query<&Parent, With<Toolbelt>>,
    mut character_query: Query<&mut LinearVelocity, (With<Character>, Without<Camera>)>,
    mut camera_query: Query<&mut LinearVelocity, (With<Camera>, Without<Character>)>,
) {
    let delta_time = time.delta_seconds_f64().adjust_precision();
    for tool in tool_query.iter() {
        let (tool_actions, tool, tool_parent) = tool;
        if !tool_actions.pressed(MovementToolAction::Move) {
            continue;
        }
        let Ok(toolbelt_parent) = toolbelt_query.get(tool_parent.get()) else {
            continue;
        };
        let move_delta = delta_time
            * tool_actions
                .clamped_axis_pair(MovementToolAction::Move)
                .unwrap()
                .xy();
        match tool.target {
            MovementTarget::Character => {
                let Ok(character) = character_query.get_mut(toolbelt_parent.get()) else {
                    warn!("Character {:?} does not exist", toolbelt_parent);
                    continue;
                };
                let mut character_velocity = character;
                character_velocity.x += move_delta.x * tool.speed;
                character_velocity.y += move_delta.y * tool.speed;
            }
            MovementTarget::Camera(camera_id) => {
                let Ok(camera) = camera_query.get_mut(camera_id) else {
                    warn!("Camera {:?} does not exist", camera_id);
                    continue;
                };
                let mut camera_velocity = camera;
                camera_velocity.x += move_delta.x * tool.speed;
                camera_velocity.y += move_delta.y * tool.speed;
            }
        }
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\app_types\src\lib.rs

````rust
pub mod app_types;
pub mod app_types_plugin;

pub mod prelude {
    pub use crate::app_types::*;
    pub use crate::app_types_plugin::*;
}

````



## D:\Repos\Games\Cursor-Hero\crates\bevy\src\translate.rs

````rust
use bevy::math::IRect;
use bevy::math::IVec2;
use bevy::math::IVec3;
use bevy::math::Rect;
use bevy::math::Vec2;
use bevy::math::Vec3;

pub trait TranslateVec2 {
    fn translate(&self, translation: &Vec2) -> Self;
}
pub trait TranslateIVec2 {
    fn translate(&self, translation: &IVec2) -> Self;
}
pub trait TranslateVec3 {
    fn translate(&self, translation: &Vec3) -> Self;
}
pub trait TranslateIVec3 {
    fn translate(&self, translation: &IVec3) -> Self;
}

impl TranslateVec2 for Rect {
    fn translate(&self, translation: &Vec2) -> Rect {
        Rect {
            min: self.min + *translation,
            max: self.max + *translation,
        }
    }
}
impl TranslateIVec2 for IRect {
    fn translate(&self, translation: &IVec2) -> IRect {
        IRect {
            min: self.min + *translation,
            max: self.max + *translation,
        }
    }
}

impl TranslateVec2 for Vec2 {
    fn translate(&self, translation: &Vec2) -> Vec2 {
        *self + *translation
    }
}
impl TranslateIVec2 for IVec2 {
    fn translate(&self, translation: &IVec2) -> IVec2 {
        *self + *translation
    }
}

impl TranslateVec3 for Vec3 {
    fn translate(&self, translation: &Vec3) -> Vec3 {
        *self + *translation
    }
}
impl TranslateIVec3 for IVec3 {
    fn translate(&self, translation: &IVec3) -> IVec3 {
        *self + *translation
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\character_types\src\lib.rs

````rust
pub mod character_types;
pub mod character_types_plugin;

pub mod prelude {
    pub use crate::character_types::*;
    pub use crate::character_types_plugin::CharacterTypesPlugin;
}

````



## D:\Repos\Games\Cursor-Hero\crates\secret\src\lib.rs

````rust
pub mod secrets_plugin;

pub mod prelude {
    pub use crate::secrets_plugin::*;
}

````



## D:\Repos\Games\Cursor-Hero\crates\memory\src\memory_plugin.rs

````rust
use bevy::prelude::*;

use crate::agent_observation_memory_plugin::AgentObservationMemoryPlugin;
use crate::main_camera_memory_plugin::MainCameraMemoryPlugin;
use crate::main_character_memory_plugin::MainCharacterMemoryPlugin;
use crate::primary_window_memory_plugin::PrimaryWindowMemoryPlugin;
use crate::voice_to_text_memory_plugin::VoiceToTextMemoryPlugin;

pub struct MemoryPlugin;

impl Plugin for MemoryPlugin {
    fn build(&self, app: &mut App) {
        app.add_plugins((
            MainCharacterMemoryPlugin,
            PrimaryWindowMemoryPlugin,
            MainCameraMemoryPlugin,
            VoiceToTextMemoryPlugin,
            AgentObservationMemoryPlugin,
        ));
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\movement_tool\src\movement_target_plugin.rs

````rust
use bevy::prelude::*;
use cursor_hero_movement_tool_types::prelude::*;

pub struct MovementTargetPlugin;

impl Plugin for MovementTargetPlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(Update, handle_set_movement_events);
    }
}

fn handle_set_movement_events(
    mut movement_target_events: EventReader<MovementTargetEvent>,
    mut tool_query: Query<&mut MovementTool>,
) {
    for event in movement_target_events.read() {
        match event {
            MovementTargetEvent::SetTarget { tool_id, target } => {
                let Ok(mut tool) = tool_query.get_mut(*tool_id) else {
                    warn!("Tool {:?} does not exist", tool_id);
                    continue;
                };
                tool.target = *target;
            }
        }
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\observation_types\src\observation_types_plugin.rs

````rust
use crate::prelude::*;
use bevy::prelude::*;
pub struct ObservationTypesPlugin;

impl Plugin for ObservationTypesPlugin {
    fn build(&self, app: &mut App) {
        app.register_type::<ObservationTool>();
        app.register_type::<ObservationBuffer>();
        app.register_type::<ObservationBufferEntry>();
        app.register_type::<WhatsNew>();
        app.add_event::<SomethingObservableHappenedEvent>();
        app.add_event::<ObservationBufferEvent>();
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\tools\src\focus_tool.rs

````rust
use bevy::prelude::*;
use bevy::window::PrimaryWindow;
use bevy::window::RawHandleWrapper;
use cursor_hero_camera::camera_plugin::FollowWithMainCamera;
use cursor_hero_camera::camera_plugin::MainCamera;
use cursor_hero_winutils::win_mouse::set_cursor_position;
use cursor_hero_winutils::win_window::get_window_title_bar_center_position;
use leafwing_input_manager::prelude::*;

use cursor_hero_camera::camera_plugin::CameraEvent;
use cursor_hero_character_types::prelude::*;
use cursor_hero_winutils::win_window::focus_window;

use cursor_hero_toolbelt_types::prelude::*;

use crate::prelude::*;
use cursor_hero_movement_tool_types::prelude::*;

pub struct FocusToolPlugin;

impl Plugin for FocusToolPlugin {
    fn build(&self, app: &mut App) {
        app.register_type::<FocusTool>();
        app.add_plugins(InputManagerPlugin::<FocusToolAction>::default());
        app.add_systems(Update, toolbelt_events);
        app.add_systems(Update, handle_input);
    }
}
#[derive(Component, Reflect, Default)]
struct FocusTool;

fn toolbelt_events(
    mut commands: Commands,
    asset_server: Res<AssetServer>,
    mut reader: EventReader<ToolbeltPopulateEvent>,
) {
    for event in reader.read() {
        let (ToolbeltLoadout::Inspector | ToolbeltLoadout::Default) = event.loadout else {
            continue;
        };
        {
            ToolSpawnConfig::<FocusTool, FocusToolAction>::new(FocusTool, event.id, event)
                .with_src_path(file!().into())
                .guess_name(file!())
                .guess_image(file!(), &asset_server, "png")
                .with_description("Camera follows the character")
                .spawn(&mut commands);
        }
    }
}

#[derive(Actionlike, PartialEq, Eq, Clone, Copy, Hash, Debug, Reflect)]
enum FocusToolAction {
    ToggleFollowCharacter,
    FocusMainWindow,
}
// TODO: add an action to focus the character without teleporting it to the camera.

impl FocusToolAction {
    fn default_gamepad_binding(&self) -> UserInput {
        match self {
            Self::ToggleFollowCharacter => GamepadButtonType::LeftThumb.into(),
            Self::FocusMainWindow => GamepadButtonType::RightThumb.into(),
        }
    }

    fn default_mkb_binding(&self) -> UserInput {
        match self {
            Self::ToggleFollowCharacter => KeyCode::Space.into(),
            Self::FocusMainWindow => KeyCode::Home.into(),
        }
    }
}
impl ToolAction for FocusToolAction {
    fn default_input_map(_event: &ToolbeltPopulateEvent) -> Option<InputMap<FocusToolAction>> {
        let mut input_map = InputMap::default();

        for variant in FocusToolAction::variants() {
            input_map.insert(variant.default_mkb_binding(), variant);
            input_map.insert(variant.default_gamepad_binding(), variant);
        }
        Some(input_map)
    }
}

#[allow(clippy::type_complexity)]
#[allow(clippy::too_many_arguments)]
fn handle_input(
    focus_tool_query: Query<(&ActionState<FocusToolAction>, &Parent), With<ActiveTool>>,
    movement_tool_query: Query<Entity, With<MovementTool>>,
    toolbelt_query: Query<(&Parent, &Children), With<Toolbelt>>,
    mut character_query: Query<
        (Entity, &mut Transform, Option<&FollowWithMainCamera>),
        (With<Character>, Without<MainCamera>),
    >,
    camera_query: Query<(Entity, &Transform), (With<MainCamera>, Without<Character>)>,
    window_query: Query<&RawHandleWrapper, With<PrimaryWindow>>,
    mut camera_events: EventWriter<CameraEvent>,
    mut movement_target_events: EventWriter<MovementTargetEvent>,
) {
    for tool in focus_tool_query.iter() {
        let (tool_actions, tool_parent) = tool;

        if tool_actions.just_pressed(FocusToolAction::ToggleFollowCharacter) {
            info!("Toggle follow character");
            let Ok(toolbelt) = toolbelt_query.get(tool_parent.get()) else {
                warn!("Toolbelt should have a parent");
                continue;
            };

            let (toolbelt_parent, toolbelt_children) = toolbelt;
            let movement_tool_ids = toolbelt_children
                .iter()
                .filter_map(|child| movement_tool_query.get(*child).ok());

            let Ok(character) = character_query.get_mut(toolbelt_parent.get()) else {
                warn!("Toolbelt should have a character");
                continue;
            };
            let (character_id, mut character_transform, character_is_followed) = character;

            let camera = camera_query.single();
            let (camera_id, camera_transform) = camera;
            if character_is_followed.is_none() {
                camera_events.send(CameraEvent::BeginFollowing {
                    target_id: character_id,
                });
                movement_tool_ids.for_each(|id| {
                    movement_target_events.send(MovementTargetEvent::SetTarget {
                        tool_id: id,
                        target: MovementTarget::Character,
                    });
                });
                info!("Sent follow events");
                info!("Updating character to be at camera position");
                character_transform.translation = camera_transform.translation;
            } else {
                camera_events.send(CameraEvent::StopFollowing {
                    target_id: character_id,
                });
                movement_tool_ids.for_each(|id| {
                    movement_target_events.send(MovementTargetEvent::SetTarget {
                        tool_id: id,
                        target: MovementTarget::Camera(camera_id),
                    });
                });
                info!("Sent unfollow events");
            }
        }
        if tool_actions.just_pressed(FocusToolAction::FocusMainWindow) {
            info!("Focus main window");
            let Ok(window_handle) = window_query.get_single() else {
                error!("No primary window found");
                return;
            };
            let win32handle = match window_handle.window_handle {
                raw_window_handle::RawWindowHandle::Win32(handle) => handle,
                _ => panic!("Unsupported window handle"),
            };
            focus_window(win32handle.hwnd as isize);
            if let Ok(position) = get_window_title_bar_center_position(win32handle.hwnd as isize) {
                match set_cursor_position(position) {
                    Ok(_) => info!("Moved cursor to window title bar"),
                    Err(e) => error!("Failed to move cursor to window title bar: {:?}", e),
                }
            }
        }
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\brick_types\src\brick_types_plugin.rs

````rust
use crate::prelude::*;
use bevy::prelude::*;

pub struct BrickTypesPlugin;

impl Plugin for BrickTypesPlugin {
    fn build(&self, app: &mut App) {
        app.register_type::<Brick>();
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\hover\src\hover_ui_automation_plugin.rs

````rust
use std::thread;

use bevy::prelude::*;
use bevy::window::PrimaryWindow;
use crossbeam_channel::bounded;
use crossbeam_channel::Receiver;
use crossbeam_channel::Sender;
use cursor_hero_ui_automation::prelude::find_element_at;
use cursor_hero_ui_automation::prelude::gather_single_element_info;
use cursor_hero_ui_automation::prelude::ElementInfo;
use cursor_hero_winutils::win_mouse::get_cursor_position;

use cursor_hero_camera::camera_plugin::MainCamera;

pub struct HoverUiAutomationPlugin;

impl Plugin for HoverUiAutomationPlugin {
    fn build(&self, app: &mut App) {
        info!("Adding HoverInfo resource");
        app.insert_resource(HoverInfo::default());
        app.register_type::<HoveredElement>();
        app.add_systems(Startup, setup);
        app.add_systems(
            Update,
            (
                update_game_mouse_position,
                update_hover_info,
                show_hovered_rect,
            )
                .chain(),
        );
    }
}

#[derive(Debug)]
enum GameboundMessage {
    ScreenHoverInfo(ElementInfo),
    ScreenHoverInfoNone,
    GameHoverInfo(ElementInfo),
    GameHoverInfoNone,
}

#[derive(Debug)]
enum ThreadboundMessage {
    CursorPosition(IVec2),
    CursorPositionNone,
}

#[derive(Resource)]
struct Bridge {
    pub sender: Sender<ThreadboundMessage>,
    pub receiver: Receiver<GameboundMessage>,
}

#[derive(Resource, Default)]
pub struct HoverInfo {
    screen_element: Option<ElementInfo>,
    game_element: Option<ElementInfo>,
    enabled: bool,
}
impl HoverInfo {
    pub fn set_enabled(&mut self, enabled: bool) {
        self.enabled = enabled;
        if !enabled {
            self.screen_element = None;
            self.game_element = None;
        }
    }
    pub fn is_enabled(&self) -> bool {
        self.enabled
    }
}

#[derive(Component, Reflect)]
pub struct HoveredElement {
    pub info: ElementInfo,
}

fn setup(mut commands: Commands) {
    let (game_tx, game_rx) = bounded::<_>(10);
    let (thread_tx, thread_rx) = bounded::<_>(10);
    commands.insert_resource(Bridge {
        sender: thread_tx,
        receiver: game_rx,
    });

    let game_tx_clone = game_tx.clone();
    thread::Builder::new()
        .name("Screen element hover info thread".to_string())
        .spawn(move || {
            let game_tx = game_tx_clone;
            loop {
                if let Ok(cursor_pos) = get_cursor_position() {
                    if let Ok(root) = find_element_at(cursor_pos) {
                        let info = gather_single_element_info(&root);
                        match info {
                            Ok(info) => {
                                game_tx
                                    .send(GameboundMessage::ScreenHoverInfo(info))
                                    .unwrap();
                            }
                            Err(_) => {
                                game_tx.send(GameboundMessage::ScreenHoverInfoNone).unwrap();
                            }
                        }
                    }
                }
                std::thread::sleep(std::time::Duration::from_millis(50));
            }
        })
        .expect("Failed to spawn screen element hover info thread");

    thread::Builder::new()
        .name("Game element hover info thread".to_string())
        .spawn(move || {
            loop {
                // Block until at least one message is available
                let mut msg = match thread_rx.recv() {
                    Ok(msg) => msg,
                    Err(e) => {
                        error!("Failed to receive thread message, exiting: {:?}", e);
                        break;
                    }
                };

                // Check for and use the latest message available
                while let Ok(newer_msg) = thread_rx.try_recv() {
                    msg = newer_msg;
                }
                match msg {
                    ThreadboundMessage::CursorPositionNone => {
                        game_tx.send(GameboundMessage::GameHoverInfoNone).unwrap();
                        continue;
                    }
                    ThreadboundMessage::CursorPosition(cursor_pos) => {
                        if let Ok(root) = find_element_at(cursor_pos) {
                            let info = gather_single_element_info(&root);
                            match info {
                                Ok(info) => {
                                    game_tx.send(GameboundMessage::GameHoverInfo(info)).unwrap();
                                }
                                Err(_) => {
                                    game_tx.send(GameboundMessage::GameHoverInfoNone).unwrap();
                                }
                            }
                        }
                    }
                }
                std::thread::sleep(std::time::Duration::from_millis(50));
            }
        })
        .expect("Failed to spawn game element hover info thread");
}

fn update_game_mouse_position(
    bridge: ResMut<Bridge>,
    camera_query: Query<(&Camera, &GlobalTransform), With<MainCamera>>,
    window_query: Query<&Window, With<PrimaryWindow>>,
    mut debounce: Local<Option<IVec2>>,
    hover_info: Res<HoverInfo>,
) {
    if !hover_info.enabled {
        return;
    }
    let (camera, camera_transform) = camera_query.single();
    let window = window_query.single();
    let value = window
        .cursor_position()
        .and_then(|cursor| camera.viewport_to_world(camera_transform, cursor))
        .map(|ray| ray.origin.truncate())
        .map(|world_position| IVec2::new(world_position.x as i32, -world_position.y as i32));
    if *debounce != value {
        *debounce = value;
        match value {
            Some(value) => bridge
                .sender
                .send(ThreadboundMessage::CursorPosition(value))
                .unwrap(),
            None => bridge
                .sender
                .send(ThreadboundMessage::CursorPositionNone)
                .unwrap(),
        }
    }
}

fn update_hover_info(mut hovered: ResMut<HoverInfo>, bridge: Res<Bridge>) {
    if !hovered.enabled {
        bridge.receiver.try_iter().for_each(drop);
        return;
    }
    if let Ok(msg) = bridge.receiver.try_recv() {
        match msg {
            GameboundMessage::ScreenHoverInfo(info) => {
                hovered.screen_element = Some(info);
            }
            GameboundMessage::ScreenHoverInfoNone => {
                hovered.screen_element = None;
            }
            GameboundMessage::GameHoverInfo(info) => {
                hovered.game_element = Some(info);
            }
            GameboundMessage::GameHoverInfoNone => {
                hovered.game_element = None;
            }
        }
    }
}

#[derive(Component, Reflect, Debug)]
struct ScreenHoveredIndicatorTag;
#[derive(Component, Reflect, Debug)]
struct GameHoveredIndicatorTag;

#[allow(clippy::type_complexity)]
fn show_hovered_rect(
    mut screen_indicator: Query<
        (Entity, &mut Sprite, &mut Transform, &mut HoveredElement),
        (
            With<ScreenHoveredIndicatorTag>,
            Without<GameHoveredIndicatorTag>,
        ),
    >,
    mut game_indicator: Query<
        (Entity, &mut Sprite, &mut Transform, &mut HoveredElement),
        (
            With<GameHoveredIndicatorTag>,
            Without<ScreenHoveredIndicatorTag>,
        ),
    >,
    hovered: Res<HoverInfo>,
    mut commands: Commands,
) {
    if let Ok((entity, mut sprite, mut transform, mut element)) = screen_indicator.get_single_mut()
    {
        if let Some(info) = &hovered.screen_element {
            sprite.custom_size = Some(Vec2::new(
                info.bounding_rect.width(),
                info.bounding_rect.height(),
            ));
            transform.translation = Vec3::new(
                info.bounding_rect.min.x + info.bounding_rect.width() / 2.,
                -info.bounding_rect.min.y - info.bounding_rect.height() / 2.,
                0.,
            );
            element.info = info.clone();
        } else {
            commands.entity(entity).despawn_recursive();
        }
    } else if let Some(info) = &hovered.screen_element {
        commands.spawn((
            SpriteBundle {
                transform: Transform::from_xyz(
                    info.bounding_rect.min.x + info.bounding_rect.width() / 2.,
                    -info.bounding_rect.min.y - info.bounding_rect.height() / 2.,
                    0.,
                ),
                sprite: Sprite {
                    custom_size: Some(Vec2::new(
                        info.bounding_rect.width(),
                        info.bounding_rect.height(),
                    )),
                    color: Color::rgba(0.141, 0.675, 0.949, 0.05),
                    ..default()
                },
                ..default()
            },
            Name::new("Screen Hovered Indicator"),
            ScreenHoveredIndicatorTag,
            HoveredElement { info: info.clone() },
        ));
    }

    if let Ok((entity, mut sprite, mut transform, mut element)) = game_indicator.get_single_mut() {
        if let Some(info) = &hovered.game_element {
            sprite.custom_size = Some(Vec2::new(
                info.bounding_rect.width(),
                info.bounding_rect.height(),
            ));
            transform.translation = Vec3::new(
                info.bounding_rect.min.x + info.bounding_rect.width() / 2.,
                -info.bounding_rect.min.y - info.bounding_rect.height() / 2.,
                0.,
            );
            element.info = info.clone();
        } else {
            commands.entity(entity).despawn_recursive();
        }
    } else if let Some(info) = &hovered.game_element {
        commands.spawn((
            SpriteBundle {
                transform: Transform::from_xyz(
                    info.bounding_rect.min.x + info.bounding_rect.width() / 2.,
                    -info.bounding_rect.min.y - info.bounding_rect.height() / 2.,
                    0.,
                ),
                sprite: Sprite {
                    custom_size: Some(Vec2::new(
                        info.bounding_rect.width(),
                        info.bounding_rect.height(),
                    )),
                    color: Color::rgba(0.641, 0.275, 0.649, 0.05),
                    ..default()
                },
                ..default()
            },
            Name::new("Game Hovered Indicator"),
            GameHoveredIndicatorTag,
            HoveredElement { info: info.clone() },
        ));
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\xelu_prompts\src\lib.rs

````rust
// https://thoseawesomeguys.com/prompts/
use bevy::input::gamepad::GamepadButtonType;
use bevy::input::keyboard::KeyCode;
use leafwing_input_manager::user_input::InputKind;

pub fn texture_path_for_input(kind: &InputKind) -> Option<&'static str> {
    match kind {
        InputKind::Keyboard(key) => {
            match key {
                KeyCode::Key0 => Some("textures/xelu_prompts/Keyboard & Mouse/Dark/0_Key_Dark.png"),
                KeyCode::Key1 => Some("textures/xelu_prompts/Keyboard & Mouse/Dark/1_Key_Dark.png"),
                KeyCode::Key2 => Some("textures/xelu_prompts/Keyboard & Mouse/Dark/2_Key_Dark.png"),
                KeyCode::Key3 => Some("textures/xelu_prompts/Keyboard & Mouse/Dark/3_Key_Dark.png"),
                KeyCode::Key4 => Some("textures/xelu_prompts/Keyboard & Mouse/Dark/4_Key_Dark.png"),
                KeyCode::Key5 => Some("textures/xelu_prompts/Keyboard & Mouse/Dark/5_Key_Dark.png"),
                KeyCode::Key6 => Some("textures/xelu_prompts/Keyboard & Mouse/Dark/6_Key_Dark.png"),
                KeyCode::Key7 => Some("textures/xelu_prompts/Keyboard & Mouse/Dark/7_Key_Dark.png"),
                KeyCode::Key8 => Some("textures/xelu_prompts/Keyboard & Mouse/Dark/8_Key_Dark.png"),
                KeyCode::Key9 => Some("textures/xelu_prompts/Keyboard & Mouse/Dark/9_Key_Dark.png"),

                KeyCode::Numpad0 => {
                    Some("textures/xelu_prompts/Keyboard & Mouse/Dark/0_Key_Dark.png")
                }
                KeyCode::Numpad1 => {
                    Some("textures/xelu_prompts/Keyboard & Mouse/Dark/1_Key_Dark.png")
                }
                KeyCode::Numpad2 => {
                    Some("textures/xelu_prompts/Keyboard & Mouse/Dark/2_Key_Dark.png")
                }
                KeyCode::Numpad3 => {
                    Some("textures/xelu_prompts/Keyboard & Mouse/Dark/3_Key_Dark.png")
                }
                KeyCode::Numpad4 => {
                    Some("textures/xelu_prompts/Keyboard & Mouse/Dark/4_Key_Dark.png")
                }
                KeyCode::Numpad5 => {
                    Some("textures/xelu_prompts/Keyboard & Mouse/Dark/5_Key_Dark.png")
                }
                KeyCode::Numpad6 => {
                    Some("textures/xelu_prompts/Keyboard & Mouse/Dark/6_Key_Dark.png")
                }
                KeyCode::Numpad7 => {
                    Some("textures/xelu_prompts/Keyboard & Mouse/Dark/7_Key_Dark.png")
                }
                KeyCode::Numpad8 => {
                    Some("textures/xelu_prompts/Keyboard & Mouse/Dark/8_Key_Dark.png")
                }
                KeyCode::Numpad9 => {
                    Some("textures/xelu_prompts/Keyboard & Mouse/Dark/9_Key_Dark.png")
                }

                KeyCode::F1 => Some("textures/xelu_prompts/Keyboard & Mouse/Dark/F1_Key_Dark.png"),
                KeyCode::F2 => Some("textures/xelu_prompts/Keyboard & Mouse/Dark/F2_Key_Dark.png"),
                KeyCode::F3 => Some("textures/xelu_prompts/Keyboard & Mouse/Dark/F3_Key_Dark.png"),
                KeyCode::F4 => Some("textures/xelu_prompts/Keyboard & Mouse/Dark/F4_Key_Dark.png"),
                KeyCode::F5 => Some("textures/xelu_prompts/Keyboard & Mouse/Dark/F5_Key_Dark.png"),
                KeyCode::F6 => Some("textures/xelu_prompts/Keyboard & Mouse/Dark/F6_Key_Dark.png"),
                KeyCode::F7 => Some("textures/xelu_prompts/Keyboard & Mouse/Dark/F7_Key_Dark.png"),
                KeyCode::F8 => Some("textures/xelu_prompts/Keyboard & Mouse/Dark/F8_Key_Dark.png"),
                KeyCode::F9 => Some("textures/xelu_prompts/Keyboard & Mouse/Dark/F9_Key_Dark.png"),
                KeyCode::F10 => {
                    Some("textures/xelu_prompts/Keyboard & Mouse/Dark/F10_Key_Dark.png")
                }
                KeyCode::F11 => {
                    Some("textures/xelu_prompts/Keyboard & Mouse/Dark/F11_Key_Dark.png")
                }
                KeyCode::F12 => {
                    Some("textures/xelu_prompts/Keyboard & Mouse/Dark/F12_Key_Dark.png")
                }
                KeyCode::F13 => {
                    Some("textures/xelu_prompts/Keyboard & Mouse/Dark/F13_Key_Dark.png")
                }
                KeyCode::F14 => {
                    Some("textures/xelu_prompts/Keyboard & Mouse/Dark/F14_Key_Dark.png")
                }
                KeyCode::F15 => {
                    Some("textures/xelu_prompts/Keyboard & Mouse/Dark/F15_Key_Dark.png")
                }
                KeyCode::F16 => {
                    Some("textures/xelu_prompts/Keyboard & Mouse/Dark/F16_Key_Dark.png")
                }
                KeyCode::F17 => {
                    Some("textures/xelu_prompts/Keyboard & Mouse/Dark/F17_Key_Dark.png")
                }
                KeyCode::F18 => {
                    Some("textures/xelu_prompts/Keyboard & Mouse/Dark/F18_Key_Dark.png")
                }
                KeyCode::F19 => {
                    Some("textures/xelu_prompts/Keyboard & Mouse/Dark/F19_Key_Dark.png")
                }
                KeyCode::F20 => {
                    Some("textures/xelu_prompts/Keyboard & Mouse/Dark/F20_Key_Dark.png")
                }
                KeyCode::F21 => {
                    Some("textures/xelu_prompts/Keyboard & Mouse/Dark/F21_Key_Dark.png")
                }
                KeyCode::F22 => {
                    Some("textures/xelu_prompts/Keyboard & Mouse/Dark/F22_Key_Dark.png")
                }
                KeyCode::F23 => {
                    Some("textures/xelu_prompts/Keyboard & Mouse/Dark/F23_Key_Dark.png")
                }
                KeyCode::F24 => {
                    Some("textures/xelu_prompts/Keyboard & Mouse/Dark/F24_Key_Dark.png")
                }

                // Alt_Key_Dark.png
                KeyCode::AltLeft => {
                    Some("textures/xelu_prompts/Keyboard & Mouse/Dark/Alt_Key_Dark.png")
                }
                KeyCode::AltRight => {
                    Some("textures/xelu_prompts/Keyboard & Mouse/Dark/Alt_Key_Dark.png")
                }
                // Arrow_Down_Key_Dark.png
                KeyCode::Down => {
                    Some("textures/xelu_prompts/Keyboard & Mouse/Dark/Down_Key_Dark.png")
                }
                // Arrow_Left_Key_Dark.png
                KeyCode::Left => {
                    Some("textures/xelu_prompts/Keyboard & Mouse/Dark/Left_Key_Dark.png")
                }
                // Arrow_Right_Key_Dark.png
                KeyCode::Right => {
                    Some("textures/xelu_prompts/Keyboard & Mouse/Dark/Right_Key_Dark.png")
                }
                // Arrow_Up_Key_Dark.png
                KeyCode::Up => Some("textures/xelu_prompts/Keyboard & Mouse/Dark/Up_Key_Dark.png"),
                // Asterisk_Key_Dark.png
                KeyCode::Asterisk => {
                    Some("textures/xelu_prompts/Keyboard & Mouse/Dark/Asterisk_Key_Dark.png")
                }
                // Backspace_Alt_Key_Dark.png
                // Backspace_Key_Dark.png
                // KeyCode::Back => Some("textures/xelu_prompts/Keyboard & Mouse/Dark/Backspace_Alt_Key_Dark.png"),
                KeyCode::Back => {
                    Some("textures/xelu_prompts/Keyboard & Mouse/Dark/Backspace_Key_Dark.png")
                }
                // Bracket_Left_Key_Dark.png
                KeyCode::BracketLeft => {
                    Some("textures/xelu_prompts/Keyboard & Mouse/Dark/Bracket_Left_Key_Dark.png")
                }
                // Bracket_Right_Key_Dark.png
                KeyCode::BracketRight => {
                    Some("textures/xelu_prompts/Keyboard & Mouse/Dark/Bracket_Right_Key_Dark.png")
                }
                // Caps_Lock_Key_Dark.png
                KeyCode::Capital => {
                    Some("textures/xelu_prompts/Keyboard & Mouse/Dark/Caps_Lock_Key_Dark.png")
                }
                // Command_Key_Dark.png
                KeyCode::SuperLeft => {
                    Some("textures/xelu_prompts/Keyboard & Mouse/Dark/Command_Key_Dark.png")
                }
                // Ctrl_Key_Dark.png
                KeyCode::ControlLeft => {
                    Some("textures/xelu_prompts/Keyboard & Mouse/Dark/Ctrl_Key_Dark.png")
                }
                KeyCode::ControlRight => {
                    Some("textures/xelu_prompts/Keyboard & Mouse/Dark/Ctrl_Key_Dark.png")
                }
                // Del_Key_Dark.png
                KeyCode::Delete => {
                    Some("textures/xelu_prompts/Keyboard & Mouse/Dark/Del_Key_Dark.png")
                }
                // End_Key_Dark.png
                KeyCode::End => {
                    Some("textures/xelu_prompts/Keyboard & Mouse/Dark/End_Key_Dark.png")
                }
                // Enter_Alt_Key_Dark.png
                // KeyCode::Return => Some("textures/xelu_prompts/Keyboard & Mouse/Dark/Enter_Alt_Key_Dark.png"),
                // Enter_Tall_Key_Dark.png
                // KeyCode::Return => Some("textures/xelu_prompts/Keyboard & Mouse/Dark/Enter_Tall_Key_Dark.png"),
                // Enter_Key_Dark.png
                KeyCode::Return => {
                    Some("textures/xelu_prompts/Keyboard & Mouse/Dark/Enter_Key_Dark.png")
                }

                // Esc_Key_Dark.png
                KeyCode::Escape => {
                    Some("textures/xelu_prompts/Keyboard & Mouse/Dark/Esc_Key_Dark.png")
                }
                // Home_Key_Dark.png
                KeyCode::Home => {
                    Some("textures/xelu_prompts/Keyboard & Mouse/Dark/Home_Key_Dark.png")
                }
                // Insert_Key_Dark.png
                KeyCode::Insert => {
                    Some("textures/xelu_prompts/Keyboard & Mouse/Dark/Insert_Key_Dark.png")
                }
                // Mark_Left_Key_Dark.png "<"
                // Mark_Right_Key_Dark.png ">"
                // Minus_Key_Dark.png
                KeyCode::Minus => {
                    Some("textures/xelu_prompts/Keyboard & Mouse/Dark/Minus_Key_Dark.png")
                }
                // Mouse_Left_Key_Dark.png
                // Mouse_Middle_Key_Dark.png
                // Mouse_Right_Key_Dark.png
                // Mouse_Simple_Key_Dark.png
                // Num_Lock_Key_Dark.png
                KeyCode::Numlock => {
                    Some("textures/xelu_prompts/Keyboard & Mouse/Dark/Num_Lock_Key_Dark.png")
                }
                // Page_Down_Key_Dark.png
                KeyCode::PageDown => {
                    Some("textures/xelu_prompts/Keyboard & Mouse/Dark/Page_Down_Key_Dark.png")
                }
                // Page_Up_Key_Dark.png
                KeyCode::PageUp => {
                    Some("textures/xelu_prompts/Keyboard & Mouse/Dark/Page_Up_Key_Dark.png")
                }
                // Plus_Key_Dark.png
                KeyCode::Plus => {
                    Some("textures/xelu_prompts/Keyboard & Mouse/Dark/Plus_Key_Dark.png")
                }
                // Plus_Tall_Key_Dark.png
                KeyCode::NumpadAdd => {
                    Some("textures/xelu_prompts/Keyboard & Mouse/Dark/Plus_Tall_Key_Dark.png")
                }
                // Print_Screen_Key_Dark.png
                KeyCode::Snapshot => {
                    Some("textures/xelu_prompts/Keyboard & Mouse/Dark/Print_Screen_Key_Dark.png")
                }
                // Question_Key_Dark.png
                KeyCode::Slash => {
                    Some("textures/xelu_prompts/Keyboard & Mouse/Dark/Question_Key_Dark.png")
                }
                // Quote_Key_Dark.png
                KeyCode::Apostrophe => {
                    Some("textures/xelu_prompts/Keyboard & Mouse/Dark/Quote_Key_Dark.png")
                }
                // Semicolon_Key_Dark.png
                KeyCode::Semicolon => {
                    Some("textures/xelu_prompts/Keyboard & Mouse/Dark/Semicolon_Key_Dark.png")
                }
                // Shift_Alt_Key_Dark.png
                KeyCode::ShiftLeft => {
                    Some("textures/xelu_prompts/Keyboard & Mouse/Dark/Shift_Alt_Key_Dark.png")
                }
                // Shift_Key_Dark.png
                KeyCode::ShiftRight => {
                    Some("textures/xelu_prompts/Keyboard & Mouse/Dark/Shift_Key_Dark.png")
                }
                // Slash_Key_Dark.png
                KeyCode::Backslash => {
                    Some("textures/xelu_prompts/Keyboard & Mouse/Dark/Slash_Key_Dark.png")
                }
                // Space_Key_Dark.png
                KeyCode::Space => {
                    Some("textures/xelu_prompts/Keyboard & Mouse/Dark/Space_Key_Dark.png")
                }
                // Tab_Key_Dark.png
                KeyCode::Tab => {
                    Some("textures/xelu_prompts/Keyboard & Mouse/Dark/Tab_Key_Dark.png")
                }
                // Tilda_Key_Dark.png
                KeyCode::Grave => {
                    Some("textures/xelu_prompts/Keyboard & Mouse/Dark/Tilda_Key_Dark.png")
                }
                // Win_Key_Dark.png
                KeyCode::SuperRight => {
                    Some("textures/xelu_prompts/Keyboard & Mouse/Dark/Win_Key_Dark.png")
                }

                KeyCode::A => Some("textures/xelu_prompts/Keyboard & Mouse/Dark/A_Key_Dark.png"),
                KeyCode::B => Some("textures/xelu_prompts/Keyboard & Mouse/Dark/B_Key_Dark.png"),
                KeyCode::C => Some("textures/xelu_prompts/Keyboard & Mouse/Dark/C_Key_Dark.png"),
                KeyCode::D => Some("textures/xelu_prompts/Keyboard & Mouse/Dark/D_Key_Dark.png"),
                KeyCode::E => Some("textures/xelu_prompts/Keyboard & Mouse/Dark/E_Key_Dark.png"),
                KeyCode::F => Some("textures/xelu_prompts/Keyboard & Mouse/Dark/F_Key_Dark.png"),
                KeyCode::G => Some("textures/xelu_prompts/Keyboard & Mouse/Dark/G_Key_Dark.png"),
                KeyCode::H => Some("textures/xelu_prompts/Keyboard & Mouse/Dark/H_Key_Dark.png"),
                KeyCode::I => Some("textures/xelu_prompts/Keyboard & Mouse/Dark/I_Key_Dark.png"),
                KeyCode::J => Some("textures/xelu_prompts/Keyboard & Mouse/Dark/J_Key_Dark.png"),
                KeyCode::K => Some("textures/xelu_prompts/Keyboard & Mouse/Dark/K_Key_Dark.png"),
                KeyCode::L => Some("textures/xelu_prompts/Keyboard & Mouse/Dark/L_Key_Dark.png"),
                KeyCode::M => Some("textures/xelu_prompts/Keyboard & Mouse/Dark/M_Key_Dark.png"),
                KeyCode::N => Some("textures/xelu_prompts/Keyboard & Mouse/Dark/N_Key_Dark.png"),
                KeyCode::O => Some("textures/xelu_prompts/Keyboard & Mouse/Dark/O_Key_Dark.png"),
                KeyCode::P => Some("textures/xelu_prompts/Keyboard & Mouse/Dark/P_Key_Dark.png"),
                KeyCode::Q => Some("textures/xelu_prompts/Keyboard & Mouse/Dark/Q_Key_Dark.png"),
                KeyCode::R => Some("textures/xelu_prompts/Keyboard & Mouse/Dark/R_Key_Dark.png"),
                KeyCode::S => Some("textures/xelu_prompts/Keyboard & Mouse/Dark/S_Key_Dark.png"),
                KeyCode::T => Some("textures/xelu_prompts/Keyboard & Mouse/Dark/T_Key_Dark.png"),
                KeyCode::U => Some("textures/xelu_prompts/Keyboard & Mouse/Dark/U_Key_Dark.png"),
                KeyCode::V => Some("textures/xelu_prompts/Keyboard & Mouse/Dark/V_Key_Dark.png"),
                KeyCode::W => Some("textures/xelu_prompts/Keyboard & Mouse/Dark/W_Key_Dark.png"),
                KeyCode::X => Some("textures/xelu_prompts/Keyboard & Mouse/Dark/X_Key_Dark.png"),
                KeyCode::Y => Some("textures/xelu_prompts/Keyboard & Mouse/Dark/Y_Key_Dark.png"),
                KeyCode::Z => Some("textures/xelu_prompts/Keyboard & Mouse/Dark/Z_Key_Dark.png"),
                _ => None,
            }
        }
        InputKind::Mouse(button) => match button {
            bevy::input::mouse::MouseButton::Left => {
                Some("textures/xelu_prompts/Keyboard & Mouse/Dark/Mouse_Left_Key_Dark.png")
            }
            bevy::input::mouse::MouseButton::Right => {
                Some("textures/xelu_prompts/Keyboard & Mouse/Dark/Mouse_Right_Key_Dark.png")
            }
            bevy::input::mouse::MouseButton::Middle => {
                Some("textures/xelu_prompts/Keyboard & Mouse/Dark/Mouse_Middle_Key_Dark.png")
            }
            bevy::input::mouse::MouseButton::Other(_) => None,
        },
        InputKind::GamepadButton(button) => {
            match button {
                // XboxSeriesX_A.png
                GamepadButtonType::South => {
                    Some("textures/xelu_prompts/Xbox Series/XboxSeriesX_A.png")
                }
                // XboxSeriesX_B.png
                GamepadButtonType::East => {
                    Some("textures/xelu_prompts/Xbox Series/XboxSeriesX_B.png")
                }
                // XboxSeriesX_Diagram.png
                // XboxSeriesX_Diagram_Simple.png
                // XboxSeriesX_Dpad.png
                // XboxSeriesX_Dpad_Down.png
                GamepadButtonType::DPadDown => {
                    Some("textures/xelu_prompts/Xbox Series/XboxSeriesX_Dpad_Down.png")
                }
                // XboxSeriesX_Dpad_Left.png
                GamepadButtonType::DPadLeft => {
                    Some("textures/xelu_prompts/Xbox Series/XboxSeriesX_Dpad_Left.png")
                }
                // XboxSeriesX_Dpad_Right.png
                GamepadButtonType::DPadRight => {
                    Some("textures/xelu_prompts/Xbox Series/XboxSeriesX_Dpad_Right.png")
                }
                // XboxSeriesX_Dpad_Up.png
                GamepadButtonType::DPadUp => {
                    Some("textures/xelu_prompts/Xbox Series/XboxSeriesX_Dpad_Up.png")
                }
                // XboxSeriesX_LB.png
                GamepadButtonType::LeftTrigger => {
                    Some("textures/xelu_prompts/Xbox Series/XboxSeriesX_LB.png")
                }
                // XboxSeriesX_Left_Stick.png
                // GamepadButtonType::LeftStick => Some("textures/xelu_prompts/Xbox Series/XboxSeriesX_Left_Stick.png"),
                // XboxSeriesX_Left_Stick_Click.png
                GamepadButtonType::LeftThumb => {
                    Some("textures/xelu_prompts/Xbox Series/XboxSeriesX_Left_Stick_Click.png")
                }
                // XboxSeriesX_LT.png
                GamepadButtonType::LeftTrigger2 => {
                    Some("textures/xelu_prompts/Xbox Series/XboxSeriesX_LT.png")
                }
                // XboxSeriesX_Menu.png
                GamepadButtonType::Start => {
                    Some("textures/xelu_prompts/Xbox Series/XboxSeriesX_Menu.png")
                }
                // XboxSeriesX_RB.png
                GamepadButtonType::RightTrigger => {
                    Some("textures/xelu_prompts/Xbox Series/XboxSeriesX_RB.png")
                }
                // XboxSeriesX_Right_Stick.png
                // GamepadButtonType::RightStick => Some("textures/xelu_prompts/Xbox Series/XboxSeriesX_Right_Stick.png"),
                // XboxSeriesX_Right_Stick_Click.png
                GamepadButtonType::RightThumb => {
                    Some("textures/xelu_prompts/Xbox Series/XboxSeriesX_Right_Stick_Click.png")
                }
                // XboxSeriesX_RT.png
                GamepadButtonType::RightTrigger2 => {
                    Some("textures/xelu_prompts/Xbox Series/XboxSeriesX_RT.png")
                }
                // XboxSeriesX_Share.png
                // XboxSeriesX_View.png
                GamepadButtonType::Select => {
                    Some("textures/xelu_prompts/Xbox Series/XboxSeriesX_View.png")
                }
                // XboxSeriesX_X.png
                GamepadButtonType::West => {
                    Some("textures/xelu_prompts/Xbox Series/XboxSeriesX_X.png")
                }
                // XboxSeriesX_Y.png
                GamepadButtonType::North => {
                    Some("textures/xelu_prompts/Xbox Series/XboxSeriesX_Y.png")
                }
                _ => None,
            }
        }
        _ => None,
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\chat\src\chat_tool_plugin.rs

````rust
use bevy::prelude::*;
use cursor_hero_character_types::prelude::*;
use cursor_hero_chat_types::prelude::*;
use cursor_hero_toolbelt_types::prelude::*;
use cursor_hero_tools::prelude::*;
use cursor_hero_voice_to_text_types::voice_to_text_types::VoiceToTextTranscriptionEvent;
use leafwing_input_manager::prelude::*;

pub struct ChatToolPlugin;

impl Plugin for ChatToolPlugin {
    fn build(&self, app: &mut App) {
        app.add_plugins(InputManagerPlugin::<ChatToolAction>::default());
        app.add_systems(Update, toolbelt_events);
        app.add_systems(Update, handle_input);
        app.add_systems(Update, handle_voice_events);
    }
}

fn toolbelt_events(
    mut commands: Commands,
    asset_server: Res<AssetServer>,
    mut reader: EventReader<ToolbeltPopulateEvent>,
) {
    for event in reader.read() {
        let (ToolbeltLoadout::Chat | ToolbeltLoadout::Default) = event.loadout else {
            continue;
        };
        {
            ToolSpawnConfig::<ChatTool, ChatToolAction>::new(ChatTool::default(), event.id, event)
                .with_src_path(file!().into())
                .guess_name(file!())
                .guess_image(file!(), &asset_server, "webp")
                .with_description("Send chat messages into the world")
                .spawn(&mut commands);
        }
    }
}

fn handle_input(
    mut tool_query: Query<
        (Entity, &ActionState<ChatToolAction>, &Parent, &mut ChatTool),
        With<ActiveTool>,
    >,
    toolbelt_query: Query<&Parent, With<Toolbelt>>,
    mut character_query: Query<Entity, With<Character>>,
    mut chat_events: EventWriter<ChatEvent>,
    mut chat_input_events: EventWriter<ChatInputEvent>,
) {
    for tool in tool_query.iter_mut() {
        let (tool_id, tool_actions, tool_parent, mut tool) = tool;

        let Ok(toolbelt) = toolbelt_query.get(tool_parent.get()) else {
            warn!("Tool not inside a toolbelt?");
            continue;
        };
        let toolbelt_parent = toolbelt;
        let Ok(character) = character_query.get_mut(toolbelt_parent.get()) else {
            warn!("Toolbelt parent not a character?");
            continue;
        };
        let character_id = character;

        if tool_actions.just_pressed(ChatToolAction::Focus) && !tool.focused {
            let event = ChatInputEvent::Focus {
                tool_id,
                toolbelt_id: tool_parent.get(),
                character_id,
            };
            info!("Sending focus event {:?}", event);
            chat_input_events.send(event);
        } else if tool_actions.just_pressed(ChatToolAction::Unfocus) && tool.focused {
            let event = ChatInputEvent::Unfocus {
                tool_id,
                toolbelt_id: tool_parent.get(),
                character_id,
            };
            info!("Sending unfocus event {:?}", event);
            chat_input_events.send(event);
        } else if tool_actions.just_pressed(ChatToolAction::Submit) && tool.focused {
            let message = tool.buffer.clone();
            if !message.is_empty() {
                tool.buffer.clear();

                let event = ChatEvent::Chat {
                    character_id,
                    message,
                };
                info!("Sending chat event {:?}", event);
                chat_events.send(event);
            }
            let event = ChatInputEvent::Unfocus {
                tool_id,
                toolbelt_id: tool_parent.get(),
                character_id,
            };
            info!("Sending unfocus event {:?}", event);
            chat_input_events.send(event);
        }
    }
}

fn handle_voice_events(
    mut voice_events: EventReader<VoiceToTextTranscriptionEvent>,
    mut chat_events: EventWriter<ChatEvent>,
    character_query: Query<Entity, With<MainCharacter>>,
) {
    let character_id = match character_query.get_single() {
        Ok(character_id) => character_id,
        Err(e) => {
            warn!("Failed to get main character: {:?}", e);
            return;
        }
    };

    for event in voice_events.read() {
        let VoiceToTextTranscriptionEvent::Received { transcription } = event;
        if transcription.is_empty() {
            continue;
        }
        let event = ChatEvent::Chat {
            character_id,
            message: transcription.clone(),
        };
        info!("Sending chat event {:?}", event);
        chat_events.send(event);
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\observation\src\observation_plugin.rs

````rust
use bevy::prelude::*;

use crate::observation_buffer_plugin::ObservationBufferPlugin;
use crate::observation_log_plugin::ObservationLogPlugin;
use crate::observation_tool_plugin::ObservationToolPlugin;
use crate::observe_chat_plugin::ObserveChatPlugin;

pub struct ObservationPlugin;

impl Plugin for ObservationPlugin {
    fn build(&self, app: &mut App) {
        app.add_plugins(ObservationLogPlugin);
        app.add_plugins(ObservationToolPlugin);
        app.add_plugins(ObservationBufferPlugin);
        app.add_plugins(ObserveChatPlugin);
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\environment_types\src\lib.rs

````rust
pub mod environment_types;
pub mod environment_types_plugin;

pub mod prelude {
    pub use crate::environment_types::*;
    pub use crate::environment_types_plugin::*;
}

````



## D:\Repos\Games\Cursor-Hero\crates\chat\src\chat_bubble_plugin.rs

````rust
use bevy::prelude::*;
use bevy::text::Text2dBounds;
use bevy_xpbd_2d::prelude::*;
use cursor_hero_character_types::prelude::*;
use cursor_hero_chat_types::prelude::*;
pub struct ChatBubblePlugin;

impl Plugin for ChatBubblePlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(Update, handle_chat_input_events);
        app.add_systems(Update, handle_chat_events);
        app.add_systems(Update, chat_bubble_lifetime);
    }
}
fn handle_chat_input_events(
    mut commands: Commands,
    tool_query: Query<&mut ChatTool>,
    character_query: Query<&Children, With<Character>>,
    chat_input_query: Query<&Children, With<ChatInput>>,
    mut text_query: Query<&mut Text>,
    mut chat_input_events: EventReader<ChatInputEvent>,
) {
    for event in chat_input_events.read() {
        match event {
            ChatInputEvent::Focus {
                character_id,
                tool_id,
                ..
            } => {
                if let Ok(character_children) = character_query.get(*character_id) {
                    for child in character_children.iter() {
                        if chat_input_query.get(*child).is_ok() {
                            warn!("Chat input entity already exists?");
                            continue;
                        }
                    }
                }
                let starting_text = match tool_query.get(*tool_id) {
                    Ok(tool) => tool.buffer.clone(),
                    Err(_) => {
                        warn!(
                            "Chat tool {:?} not found? Skipping chat bubble creation.",
                            tool_id
                        );
                        continue;
                    }
                };
                debug!(
                    "Creating chat input entity for character {:?}",
                    character_id
                );
                commands.entity(*character_id).with_children(|parent| {
                    let size = Vec2::new(300.0, 100.0);
                    let resolution = 3.0;
                    let padding = Vec2::new(10.0, 10.0);
                    parent
                        .spawn((
                            SpriteBundle {
                                sprite: Sprite {
                                    color: Color::ALICE_BLUE,
                                    custom_size: Some(size),
                                    ..default()
                                },
                                transform: Transform::from_translation(Vec3::new(0.0, 100.0, -1.0)),
                                ..default()
                            },
                            ChatInput,
                            Name::new("Chat Input Bubble"),
                        ))
                        .with_children(|parent| {
                            parent.spawn((Text2dBundle {
                                text: Text::from_section(
                                    starting_text,
                                    TextStyle {
                                        font_size: 20.0 * resolution,
                                        color: Color::MIDNIGHT_BLUE,
                                        ..default()
                                    },
                                ),
                                text_2d_bounds: Text2dBounds {
                                    size: size * resolution - padding,
                                },
                                transform: Transform::from_translation(Vec3::new(0.0, 0.0, 1.0))
                                    .with_scale(Vec3::new(1.0 / resolution, 1.0 / resolution, 1.0)),
                                ..default()
                            },));
                        });
                });
            }
            ChatInputEvent::Unfocus { character_id, .. } => {
                debug!(
                    "Removing chat input entity for character {:?}",
                    character_id
                );
                if let Ok(character_children) = character_query.get(*character_id) {
                    for child in character_children.iter() {
                        if chat_input_query.get(*child).is_ok() {
                            commands.entity(*child).despawn_recursive();
                            commands.entity(*character_id).remove_children(&[*child]);
                        }
                    }
                }
            }
            ChatInputEvent::TextChanged {
                character_id,
                tool_id,
                ..
            } => {
                let new_text = match tool_query.get(*tool_id) {
                    Ok(tool) => tool.buffer.clone(),
                    Err(_) => {
                        warn!(
                            "Chat tool {:?} not found? Skipping chat bubble update.",
                            tool_id
                        );
                        continue;
                    }
                };
                debug!(
                    "Updating chat input entity for character {:?}",
                    character_id
                );
                if let Ok(character_children) = character_query.get(*character_id) {
                    for child in character_children.iter() {
                        if let Ok(chat_input) = chat_input_query.get(*child) {
                            let chat_input_children = chat_input;
                            for child in chat_input_children.iter() {
                                if let Ok(mut text) = text_query.get_mut(*child) {
                                    text.sections[0].value = new_text.clone();
                                }
                            }
                        }
                    }
                } else {
                    warn!(
                        "Character {:?} not found? Skipping chat bubble update.",
                        character_id
                    );
                }
            }
        }
    }
}

fn handle_chat_events(
    mut events: EventReader<ChatEvent>,
    mut commands: Commands,
    character_query: Query<&GlobalTransform, With<Character>>,
) {
    for event in events.read() {
        match event {
            ChatEvent::Chat {
                character_id,
                message,
            } => {
                if let Ok(character) = character_query.get(*character_id) {
                    let character_transform = character;
                    info!(
                        "Creating chat bubble for character {:?} at position {:?}",
                        character_id,
                        character_transform.translation()
                    );
                    let size = Vec2::new(300.0, 100.0);
                    let resolution = 3.0;
                    let padding = Vec2::new(10.0, 10.0);
                    let mut transform = character_transform.compute_transform();
                    transform.translation -= Vec3::new(0.0, 100.0, 10.0);
                    commands
                        .spawn((
                            SpriteBundle {
                                sprite: Sprite {
                                    color: Color::BLACK,
                                    custom_size: Some(size),
                                    ..default()
                                },
                                transform,
                                ..default()
                            },
                            ChatBubble {
                                lifetime: Timer::from_seconds(25.0, TimerMode::Once),
                            },
                            RigidBody::Dynamic,
                            LinearVelocity(Vec2::new(0.0, -30.0)),
                            Collider::cuboid(size.x, size.y),
                            Name::new("Chat Bubble"),
                        ))
                        .with_children(|parent| {
                            parent.spawn((Text2dBundle {
                                text: Text::from_section(
                                    message.clone(),
                                    TextStyle {
                                        font_size: 20.0 * resolution,
                                        color: Color::WHITE,
                                        ..default()
                                    },
                                ),
                                text_2d_bounds: Text2dBounds {
                                    size: size * resolution - padding,
                                },
                                transform: Transform::from_translation(Vec3::new(0.0, 0.0, 1.0))
                                    .with_scale(Vec3::new(1.0 / resolution, 1.0 / resolution, 1.0)),
                                ..default()
                            },));
                        });
                } else {
                    warn!(
                        "Character {:?} not found? Skipping chat bubble creation.",
                        character_id
                    );
                }
            }
        }
    }
}

fn chat_bubble_lifetime(
    mut commands: Commands,
    time: Res<Time>,
    mut query: Query<(Entity, &mut ChatBubble)>,
) {
    for (entity, mut chat_bubble) in query.iter_mut() {
        chat_bubble.lifetime.tick(time.delta());
        if chat_bubble.lifetime.finished() {
            commands.entity(entity).despawn_recursive();
        }
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\pointer\src\pointer_hover_plugin.rs

````rust
use bevy::prelude::*;
use bevy_xpbd_2d::components::CollidingEntities;
use cursor_hero_pointer_types::prelude::*;

pub struct PointerHoverPlugin;

impl Plugin for PointerHoverPlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(Update, hover_detection);
    }
}

#[allow(clippy::type_complexity)]
pub fn hover_detection(
    mut commands: Commands,
    mut pointer_query: Query<(Entity, &CollidingEntities, Option<&mut Hovering>), With<Pointer>>,
    target_query: Query<(Entity, &Visibility, Option<&Hovered>), With<Hoverable>>,
    mut events: EventWriter<HoverEvent>,
) {
    for (pointer_id, pointer_touching, pointer_hovering) in pointer_query.iter_mut() {
        // find out what the pointer is touching
        let mut still_touching = vec![];
        for touching_id in pointer_touching.iter() {
            let Ok((target_id, target_visible, target_hovered)) = target_query.get(*touching_id)
            else {
                continue;
            };
            if target_visible == Visibility::Hidden {
                continue;
            }
            if target_hovered.is_none() {
                commands.entity(target_id).insert(Hovered);
                debug!("HoverStart: {:?}", target_id);
                events.send(HoverEvent::Start {
                    target_id,
                    pointer_id,
                });
            }
            still_touching.push(target_id);
        }
        // update the pointer tracker
        match pointer_hovering {
            Some(mut pointer_hovering) => {
                for entry in pointer_hovering.hovering.iter() {
                    if !still_touching.contains(entry) {
                        if let Some(mut target_commands) = commands.get_entity(*entry) {
                            target_commands.remove::<Hovered>();
                            debug!("HoverEnd: {:?}", entry);
                            events.send(HoverEvent::End {
                                target_id: *entry,
                                pointer_id,
                            });
                        }
                    }
                }
                if still_touching.is_empty() {
                    commands.entity(pointer_id).remove::<Hovering>();
                } else {
                    pointer_hovering.hovering = still_touching;
                }
            }
            None => {
                if !still_touching.is_empty() {
                    commands.entity(pointer_id).insert(Hovering {
                        hovering: still_touching,
                    });
                }
            }
        }
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\app\src\app_plugin.rs

````rust
use bevy::prelude::*;

pub struct AppPlugin;

impl Plugin for AppPlugin {
    fn build(&self, _app: &mut App) {}
}

````



## D:\Repos\Games\Cursor-Hero\crates\math\src\math_plugin.rs

````rust
use bevy::prelude::*;

use crate::prelude::Corner;

pub struct MathPlugin;

impl Plugin for MathPlugin {
    fn build(&self, app: &mut App) {
        app.register_type::<Corner>();
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\bevy\src\rect_extents.rs

````rust
use bevy::math::IRect;
use bevy::math::IVec2;
use bevy::math::Rect;
use bevy::math::Vec2;
use cursor_hero_math::prelude::Corner;

pub trait CornerOfRect {
    fn of(&self, rect: &Rect) -> Vec2;
}
impl CornerOfRect for Corner {
    fn of(&self, rect: &Rect) -> Vec2 {
        match self {
            Corner::TopLeft => rect.top_left(),
            Corner::TopRight => rect.top_right(),
            Corner::BottomLeft => rect.bottom_left(),
            Corner::BottomRight => rect.bottom_right(),
        }
    }
}

pub trait CornerOfIRect {
    fn of(&self, rect: &IRect) -> IVec2;
}
impl CornerOfIRect for Corner {
    fn of(&self, rect: &IRect) -> IVec2 {
        match self {
            Corner::TopLeft => rect.top_left(),
            Corner::TopRight => rect.top_right(),
            Corner::BottomLeft => rect.bottom_left(),
            Corner::BottomRight => rect.bottom_right(),
        }
    }
}

pub trait TopRight {
    fn top_right(&self) -> Vec2;
}
impl TopRight for Rect {
    fn top_right(&self) -> Vec2 {
        Vec2::new(self.max.x, self.min.y)
    }
}

pub trait TopRightI {
    fn top_right(&self) -> IVec2;
}
impl TopRightI for IRect {
    fn top_right(&self) -> IVec2 {
        IVec2::new(self.max.x, self.min.y)
    }
}

pub trait BottomLeft {
    fn bottom_left(&self) -> Vec2;
}
impl BottomLeft for Rect {
    fn bottom_left(&self) -> Vec2 {
        Vec2::new(self.min.x, self.max.y)
    }
}

pub trait BottomLeftI {
    fn bottom_left(&self) -> IVec2;
}
impl BottomLeftI for IRect {
    fn bottom_left(&self) -> IVec2 {
        IVec2::new(self.min.x, self.max.y)
    }
}

pub trait BottomRight {
    fn bottom_right(&self) -> Vec2;
}
impl BottomRight for Rect {
    fn bottom_right(&self) -> Vec2 {
        self.max
    }
}

pub trait BottomRightI {
    fn bottom_right(&self) -> IVec2;
}
impl BottomRightI for IRect {
    fn bottom_right(&self) -> IVec2 {
        self.max
    }
}

pub trait TopLeft {
    fn top_left(&self) -> Vec2;
}
impl TopLeft for Rect {
    fn top_left(&self) -> Vec2 {
        self.min
    }
}

pub trait TopLeftI {
    fn top_left(&self) -> IVec2;
}
impl TopLeftI for IRect {
    fn top_left(&self) -> IVec2 {
        self.min
    }
}

pub trait Left {
    fn left(&self) -> f32;
}
impl Left for Rect {
    fn left(&self) -> f32 {
        self.min.x
    }
}

pub trait LeftI {
    fn left(&self) -> i32;
}
impl LeftI for IRect {
    fn left(&self) -> i32 {
        self.min.x
    }
}

pub trait Right {
    fn right(&self) -> f32;
}
impl Right for Rect {
    fn right(&self) -> f32 {
        self.max.x
    }
}

pub trait RightI {
    fn right(&self) -> i32;
}
impl RightI for IRect {
    fn right(&self) -> i32 {
        self.max.x
    }
}

pub trait Bottom {
    fn bottom(&self) -> f32;
}
impl Bottom for Rect {
    fn bottom(&self) -> f32 {
        self.min.y
    }
}

pub trait BottomI {
    fn bottom(&self) -> i32;
}
impl BottomI for IRect {
    fn bottom(&self) -> i32 {
        self.min.y
    }
}

pub trait Top {
    fn top(&self) -> f32;
}
impl Top for Rect {
    fn top(&self) -> f32 {
        self.max.y
    }
}

pub trait TopI {
    fn top(&self) -> i32;
}
impl TopI for IRect {
    fn top(&self) -> i32 {
        self.max.y
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\bevy\src\lib.rs

````rust
mod neg_y;
mod rect_expand;
mod rect_extents;
mod rect_in_rect;
mod rect_scaled;
mod rect_with_properties;
mod translate;
mod vec_into_rect;

pub mod prelude {
    pub use crate::neg_y::*;
    pub use crate::rect_expand::*;
    pub use crate::rect_extents::*;
    pub use crate::rect_in_rect::*;
    pub use crate::rect_scaled::*;
    pub use crate::rect_with_properties::*;
    pub use crate::translate::*;
    pub use crate::vec_into_rect::*;
}

````



## D:\Repos\Games\Cursor-Hero\crates\pointer_types\src\pointer_hover_types.rs

````rust
use bevy::prelude::*;

#[derive(Event, Debug, Reflect)]
pub enum HoverEvent {
    Start {
        target_id: Entity,
        pointer_id: Entity,
    },
    End {
        target_id: Entity,
        pointer_id: Entity,
    },
}

#[derive(Component, Reflect, Debug)]
pub struct Hovered;
#[derive(Component, Reflect, Debug)]
pub struct Hoverable;
#[derive(Component, Reflect, Debug)]
pub struct Hovering {
    pub hovering: Vec<Entity>,
}

````



## D:\Repos\Games\Cursor-Hero\crates\physics_debug\src\physics_debug_plugin.rs

````rust
use bevy::prelude::*;

pub struct PhysicsDebugPlugin;

impl Plugin for PhysicsDebugPlugin {
    #[allow(unused_variables)]
    fn build(&self, app: &mut App) {
        // side effect: enabling this will cause tools to spawn visible instead of hidden
        // app.add_plugins(bevy_xpbd_2d::plugins::PhysicsDebugPlugin::default());
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\bevy\src\rect_in_rect.rs

````rust
use bevy::math::Rect;
use bevy::math::Vec2;

pub trait AtInsideBottom {
    fn at_inside_bottom(&self, other: &Rect) -> Rect;
}
impl AtInsideBottom for Rect {
    fn at_inside_bottom(&self, other: &Rect) -> Rect {
        Rect::from_center_size(
            Vec2::new(
                other.center().x,
                other.center().y - other.height() / 2.0 + self.height() / 2.0,
            ),
            self.size(),
        )
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\inference\src\inference_plugin.rs

````rust
use bevy::prelude::*;

use crate::prompt_asset_plugin::PromptAssetPlugin;

pub struct InferencePlugin;

impl Plugin for InferencePlugin {
    fn build(&self, app: &mut App) {
        app.add_plugins(PromptAssetPlugin);
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\toolbelt\src\toolbelt_opening_plugin.rs

````rust
use bevy::prelude::*;
use cursor_hero_toolbelt_types::toolbelt_types::*;
use leafwing_input_manager::action_state::ActionState;

pub struct ToolbeltOpeningPlugin;

impl Plugin for ToolbeltOpeningPlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(Update, opening);
    }
}

#[allow(clippy::type_complexity)]
pub fn opening(
    mut toolbelt_query: Query<(Entity, &mut Toolbelt, &ActionState<ToolbeltAction>), Without<Tool>>,
    mut toolbelt_events: EventWriter<ToolbeltOpeningEvent>,
) {
    for toolbelt in toolbelt_query.iter_mut() {
        let (toolbelt_id, mut toolbelt, toolbelt_actions) = toolbelt;
        match (
            toolbelt.open,
            toolbelt_actions.pressed(ToolbeltAction::Show),
        ) {
            (false, true) => {
                // Not open but we are holding the open button
                toolbelt_events.send(ToolbeltOpeningEvent::Opened { toolbelt_id });
                toolbelt.open = true;
            }
            (true, false) => {
                // Open but we are not holding the open button
                toolbelt_events.send(ToolbeltOpeningEvent::Closed { toolbelt_id });
                toolbelt.open = false;
            }
            _ => {}
        }
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\math\src\shuffle.rs

````rust
#[cfg(target_arch = "x86")]
use std::arch::x86::_mm_shuffle_epi8;
use std::arch::x86_64::__m128i;
use std::arch::x86_64::_mm_loadu_si128;
use std::arch::x86_64::_mm_setr_epi8;
#[cfg(target_arch = "x86_64")]
use std::arch::x86_64::_mm_shuffle_epi8;
use std::arch::x86_64::_mm_storeu_si128;

/// Convert BGRA to RGBA
///
/// Uses SIMD to go fast
pub fn bgra_to_rgba(data: &mut [u8]) {
    // The shuffle mask for converting BGRA -> RGBA
    let mask: __m128i = unsafe {
        _mm_setr_epi8(
            2, 1, 0, 3, // First pixel
            6, 5, 4, 7, // Second pixel
            10, 9, 8, 11, // Third pixel
            14, 13, 12, 15, // Fourth pixel
        )
    };
    // For each 16-byte chunk in your data
    for chunk in data.chunks_exact_mut(16) {
        let mut vector = unsafe { _mm_loadu_si128(chunk.as_ptr() as *const __m128i) };
        vector = unsafe { _mm_shuffle_epi8(vector, mask) };
        unsafe { _mm_storeu_si128(chunk.as_mut_ptr() as *mut __m128i, vector) };
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\text_asset\src\lib.rs

````rust
pub mod text_asset_plugin;

pub mod prelude {
    pub use crate::text_asset_plugin::*;
}

````



## D:\Repos\Games\Cursor-Hero\crates\sprint_tool\src\lib.rs

````rust
pub mod sprint_tool_plugin;

````



## D:\Repos\Games\Cursor-Hero\crates\ui\src\fps_text_plugin.rs

````rust
use bevy::diagnostic::DiagnosticsStore;
use bevy::diagnostic::FrameTimeDiagnosticsPlugin;
use bevy::prelude::*;
pub struct FpsTextPlugin;
impl Plugin for FpsTextPlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(Startup, setup);
        app.add_systems(Update, update_fps_text);
    }
}

#[derive(Component)]
struct FpsText;

fn setup(mut commands: Commands) {
    commands.spawn((
        TextBundle::from_section(
            "FPS: ",
            TextStyle {
                font: default(),
                font_size: 20.0,
                color: Color::TOMATO,
            },
        )
        .with_style(Style {
            position_type: PositionType::Absolute,
            top: Val::Px(5.0),
            left: Val::Px(5.0),
            ..default()
        }),
        FpsText,
    ));
}

fn update_fps_text(diagnostics: Res<DiagnosticsStore>, mut query: Query<&mut Text, With<FpsText>>) {
    for mut text in &mut query {
        if let Some(fps) = diagnostics.get(FrameTimeDiagnosticsPlugin::FPS) {
            if let Some(value) = fps.smoothed() {
                // Update the value of the second section
                text.sections[0].value = format!("FPS: {value:.2}");
            }
        }
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\tools\src\placeholder_tool.rs

````rust
use bevy::prelude::*;
use leafwing_input_manager::action_state::ActionState;
use leafwing_input_manager::input_map::InputMap;
use leafwing_input_manager::prelude::*;
use leafwing_input_manager::user_input::UserInput;
use leafwing_input_manager::Actionlike;

use cursor_hero_toolbelt_types::prelude::*;

use crate::prelude::*;
pub struct PlaceholderToolPlugin;

impl Plugin for PlaceholderToolPlugin {
    fn build(&self, app: &mut App) {
        app.register_type::<PlaceholderTool>();
        app.add_plugins(InputManagerPlugin::<PlaceholderToolAction>::default());
        app.add_systems(Update, toolbelt_events);
        app.add_systems(Update, handle_input);
    }
}

#[derive(Component, Reflect, Default)]
struct PlaceholderTool;

#[derive(Actionlike, PartialEq, Eq, Clone, Copy, Hash, Debug, Reflect)]
enum PlaceholderToolAction {
    Action1,
    Action2,
    Action3,
}

impl PlaceholderToolAction {
    fn default_gamepad_binding(&self) -> UserInput {
        match self {
            Self::Action1 => GamepadButtonType::South.into(),
            Self::Action2 => GamepadButtonType::East.into(),
            Self::Action3 => GamepadButtonType::West.into(),
        }
    }

    fn default_mkb_binding(&self) -> UserInput {
        match self {
            Self::Action1 => KeyCode::ControlLeft.into(),
            Self::Action2 => KeyCode::ControlRight.into(),
            Self::Action3 => KeyCode::AltRight.into(),
        }
    }
}
impl ToolAction for PlaceholderToolAction {
    fn default_input_map(
        _event: &ToolbeltPopulateEvent,
    ) -> Option<InputMap<PlaceholderToolAction>> {
        let mut input_map = InputMap::default();

        for variant in PlaceholderToolAction::variants() {
            input_map.insert(variant.default_mkb_binding(), variant);
            input_map.insert(variant.default_gamepad_binding(), variant);
        }
        Some(input_map)
    }
}

fn toolbelt_events(
    mut commands: Commands,
    asset_server: Res<AssetServer>,
    mut reader: EventReader<ToolbeltPopulateEvent>,
) {
    for event in reader.read() {
        let ToolbeltLoadout::Default = event.loadout else {
            continue;
        };
        for _ in 0..1 {
            // disabled for now
            ToolSpawnConfig::<PlaceholderTool, PlaceholderToolAction>::new(
                PlaceholderTool,
                event.id,
                event,
            )
            .with_src_path(file!().into())
            .guess_name(file!())
            .guess_image(file!(), &asset_server, "png")
            .with_description("Balances the wheel")
            .spawn(&mut commands);
        }
    }
}

fn handle_input(actors: Query<(&ActionState<PlaceholderToolAction>, Option<&ActiveTool>)>) {
    for (action_state, active_tool_tag) in actors.iter() {
        if active_tool_tag.is_none() {
            continue;
        }
        if action_state.just_pressed(PlaceholderToolAction::Action1) {
            info!("Just pressed Action1");
        }
        if action_state.just_pressed(PlaceholderToolAction::Action2) {
            info!("Just pressed Action2");
        }
        if action_state.just_pressed(PlaceholderToolAction::Action3) {
            info!("Just pressed Action3");
        }
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\ui_watcher_types\src\ui_watcher_types_plugin.rs

````rust
use bevy::prelude::*;
// use crate::prelude::*;

pub struct UiWatcherTypesPlugin;

impl Plugin for UiWatcherTypesPlugin {
    fn build(&self, _app: &mut App) {}
}

````



## D:\Repos\Games\Cursor-Hero\crates\voice_to_text\src\voice_to_text_button_plugin.rs

````rust
use bevy::prelude::*;
use bevy_xpbd_2d::prelude::*;
use cursor_hero_environment_types::prelude::*;
use cursor_hero_math::prelude::Lerp;
use cursor_hero_pointer_types::prelude::*;
use cursor_hero_voice_to_text_types::prelude::*;

pub struct VoiceToTextButtonPlugin;

impl Plugin for VoiceToTextButtonPlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(Update, populate_new_host_environments);
        app.add_systems(Update, update_visuals);
        app.add_systems(Update, status_button_click);
        app.add_systems(Update, vscode_button_click);
        app.add_systems(Update, handle_vscode_events);
    }
}

fn populate_new_host_environments(
    mut commands: Commands,
    mut environment_events: EventReader<PopulateEnvironmentEvent>,
    environment_query: Query<(), With<HostEnvironment>>,
    asset_server: Res<AssetServer>,
) {
    for event in environment_events.read() {
        if !environment_query.contains(event.environment_id) {
            continue;
        }
        let environment_id = event.environment_id;
        info!("Adding button to new host environment {:?}", environment_id);
        commands.entity(environment_id).with_children(|parent| {
            parent
                .spawn((
                    VoiceToTextStatusButton::default(),
                    Name::new("Voice2Text Button"),
                    SpriteBundle {
                        sprite: Sprite {
                            custom_size: Some(Vec2::new(200.0, 100.0)),
                            color: Color::PURPLE,
                            ..default()
                        },
                        transform: Transform::from_translation(Vec3::new(
                            1920.0 / 2.0 + 600.0,
                            -1080.0 - 200.0,
                            0.0,
                        )),
                        ..default()
                    },
                    Clickable,
                    Hoverable,
                    RigidBody::Static,
                    Sensor,
                    Collider::cuboid(200.0, 100.0),
                ))
                .with_children(|parent| {
                    parent.spawn((Text2dBundle {
                        text: Text::from_section(
                            "Voice2Text Server Control".to_string(),
                            TextStyle {
                                font: asset_server.load("fonts/FiraSans-Bold.ttf"),
                                font_size: 32.0,
                                color: Color::WHITE,
                            },
                        )
                        .with_alignment(TextAlignment::Center),
                        transform: Transform::from_xyz(0.0, 70.0, 1.0),
                        ..default()
                    },));
                });
            parent
                .spawn((
                    VoiceToTextVscodeButton::default(),
                    Name::new("Voice2Text VSCode Button"),
                    SpriteBundle {
                        sprite: Sprite {
                            custom_size: Some(Vec2::new(200.0, 100.0)),
                            color: Color::rgb(0.0, 0.6, 0.8),
                            ..default()
                        },
                        transform: Transform::from_translation(Vec3::new(
                            1920.0 / 2.0 + 600.0,
                            -1080.0 - 350.0,
                            0.0,
                        )),
                        ..default()
                    },
                    Clickable,
                    Hoverable,
                    RigidBody::Static,
                    Sensor,
                    Collider::cuboid(200.0, 100.0),
                ))
                .with_children(|parent| {
                    parent.spawn((Text2dBundle {
                        text: Text::from_section(
                            "open in vscode".to_string(),
                            TextStyle {
                                font: asset_server.load("fonts/FiraSans-Bold.ttf"),
                                font_size: 32.0,
                                color: Color::WHITE,
                            },
                        )
                        .with_alignment(TextAlignment::Center),
                        transform: Transform::from_xyz(0.0, 0.0, 1.0),
                        ..default()
                    },));
                });
        });
    }
}

fn update_visuals(
    mut events: EventReader<VoiceToTextStatusEvent>,
    mut button_query: Query<(&mut Sprite, &Children, &mut VoiceToTextStatusButton)>,
    mut button_text_query: Query<&mut Text>,
) {
    for event in events.read() {
        let VoiceToTextStatusEvent::Changed {
            new_status: status, ..
        } = event;
        debug!(
            "Updating VoiceToText Server Control visuals to {:?}",
            status
        );
        for button in button_query.iter_mut() {
            let (mut button_sprite, button_children, mut button) = button;
            button.visual_state = match button.visual_state {
                VoiceToTextStatusButtonVisualState::Default { .. } => {
                    VoiceToTextStatusButtonVisualState::Default {
                        status: status.clone(),
                    }
                }
                VoiceToTextStatusButtonVisualState::Hovered { .. } => {
                    VoiceToTextStatusButtonVisualState::Hovered {
                        status: status.clone(),
                    }
                }
                VoiceToTextStatusButtonVisualState::Pressed { .. } => {
                    VoiceToTextStatusButtonVisualState::Pressed {
                        status: status.clone(),
                    }
                }
            };
            match status {
                VoiceToTextStatus::Alive { .. } => {
                    button_sprite.color = Color::GREEN;
                }
                VoiceToTextStatus::AliveButWeDontKnowTheApiKey => {
                    button_sprite.color = Color::ORANGE_RED;
                }
                VoiceToTextStatus::Dead => {
                    button_sprite.color = Color::RED;
                }
                VoiceToTextStatus::Unknown | VoiceToTextStatus::UnknownWithCachedApiKey { .. } => {
                    button_sprite.color = Color::PURPLE;
                }
                VoiceToTextStatus::Starting {
                    instant, timeout, ..
                } => {
                    button_sprite.color = Color::YELLOW
                        * (1.0, 0.1).lerp(instant.elapsed().as_secs_f32() / timeout.as_secs_f32());
                }
            }
            for child in button_children.iter() {
                if let Ok(mut text) = button_text_query.get_mut(*child) {
                    match status {
                        VoiceToTextStatus::Alive { .. } => {
                            text.sections[0].value =
                                "VoiceToText Server Control (Alive)".to_string();
                        }
                        VoiceToTextStatus::AliveButWeDontKnowTheApiKey => {
                            text.sections[0].value =
                                "VoiceToText Server Control (Alive, but we don't know the API key)"
                                    .to_string();
                        }
                        VoiceToTextStatus::Dead => {
                            text.sections[0].value =
                                "VoiceToText Server Control (Dead)".to_string();
                        }
                        VoiceToTextStatus::Unknown => {
                            text.sections[0].value =
                                "VoiceToText Server Control (Unknown)".to_string();
                        }
                        VoiceToTextStatus::UnknownWithCachedApiKey { .. } => {
                            text.sections[0].value =
                                "VoiceToText Server Control (Unknown, api key present)".to_string();
                        }
                        VoiceToTextStatus::Starting { instant, .. } => {
                            text.sections[0].value = format!(
                                "VoiceToText Server Control (Starting {}s ago)",
                                instant.elapsed().as_secs()
                            );
                        }
                    }
                }
            }
        }
    }

    for button in button_query.iter_mut() {
        let (mut sprite, children, button) = button;
        // if the visual state status is starting, update the text to show the time elapsed
        let (VoiceToTextStatusButtonVisualState::Default {
            status: VoiceToTextStatus::Starting {
                instant, timeout, ..
            },
        }
        | VoiceToTextStatusButtonVisualState::Hovered {
            status: VoiceToTextStatus::Starting {
                instant, timeout, ..
            },
        }
        | VoiceToTextStatusButtonVisualState::Pressed {
            status: VoiceToTextStatus::Starting {
                instant, timeout, ..
            },
        }) = button.visual_state
        else {
            continue;
        };
        sprite.color = Color::YELLOW
            * (1.0, 0.1).lerp(instant.elapsed().as_secs_f32() / timeout.as_secs_f32());
        for child in children.iter() {
            if let Ok(mut text) = button_text_query.get_mut(*child) {
                text.sections[0].value = format!(
                    "VoiceToText Server Control (Starting {}s ago)",
                    instant.elapsed().as_secs()
                );
            }
        }
    }
}

fn status_button_click(
    mut click_events: EventReader<ClickEvent>,
    button_query: Query<&VoiceToTextStatusButton>,
    mut command_events: EventWriter<VoiceToTextCommandEvent>,
) {
    for event in click_events.read() {
        let ClickEvent::Clicked {
            target_id,
            pointer_id: _,
            way,
        } = event
        else {
            continue;
        };
        if way != &Way::Left {
            continue;
        }
        if let Ok(button) = button_query.get(*target_id) {
            info!("VoiceToText Server Control clicked");
            // if the button visual status is alive, do nothing
            match button.visual_state {
                VoiceToTextStatusButtonVisualState::Default {
                    status: VoiceToTextStatus::Alive { .. },
                }
                | VoiceToTextStatusButtonVisualState::Hovered {
                    status: VoiceToTextStatus::Alive { .. },
                }
                | VoiceToTextStatusButtonVisualState::Pressed {
                    status: VoiceToTextStatus::Alive { .. },
                } => {
                    warn!("VoiceToText Server Control is already alive");
                    continue;
                }
                _ => {}
            }
            let event = VoiceToTextCommandEvent::Startup;
            debug!("Sending event {:?}", event);
            command_events.send(event);
        }
    }
}

fn vscode_button_click(
    mut click_events: EventReader<ClickEvent>,
    button_query: Query<&VoiceToTextVscodeButton>,
    mut vscode_events: EventWriter<VoiceToTextVscodeEvent>,
) {
    for event in click_events.read() {
        let ClickEvent::Clicked {
            target_id,
            pointer_id: _,
            way,
        } = event
        else {
            continue;
        };
        if way != &Way::Left {
            continue;
        }
        if button_query.get(*target_id).is_ok() {
            info!("VoiceToText vscode clicked");
            let event = VoiceToTextVscodeEvent::Startup;
            debug!("Sending event {:?}", event);
            vscode_events.send(event);
        }
    }
}

fn handle_vscode_events(mut vscode_events: EventReader<VoiceToTextVscodeEvent>) {
    let should_start = vscode_events
        .read()
        .any(|event| matches!(event, VoiceToTextVscodeEvent::Startup));
    if should_start {
        info!("Opening vscode");
        if let Err(e) = crate::voice_to_text::start_vscode() {
            error!("Failed to start vscode: {:?}", e);
        }
    }
    vscode_events.clear();
}

````



## D:\Repos\Games\Cursor-Hero\crates\movement_tool\src\movement_tool_populate_plugin.rs

````rust
use bevy::prelude::*;
use cursor_hero_movement_tool_types::prelude::*;
use cursor_hero_toolbelt_types::prelude::*;
use cursor_hero_tools::tool_spawning::ToolSpawnConfig;

pub struct MovementToolPopulatePlugin;

impl Plugin for MovementToolPopulatePlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(Update, handle_toolbelt_events);
    }
}

fn handle_toolbelt_events(
    mut commands: Commands,
    asset_server: Res<AssetServer>,
    mut reader: EventReader<ToolbeltPopulateEvent>,
) {
    for event in reader.read() {
        match event.loadout {
            ToolbeltLoadout::Default
            | ToolbeltLoadout::Inspector
            | ToolbeltLoadout::Taskbar
            | ToolbeltLoadout::WindowPosition
            | ToolbeltLoadout::Keyboard => {
                ToolSpawnConfig::<_, MovementToolAction>::new(
                    MovementTool::default(),
                    event.id,
                    event,
                )
                .with_src_path(file!().into())
                .guess_name(file!())
                .guess_image(file!(), &asset_server, "png")
                .with_description("Go faster, reach further")
                .spawn(&mut commands);
            }
            ToolbeltLoadout::Agent => {
                ToolSpawnConfig::<_, MovementToolAction>::new(
                    MovementTool::default(),
                    event.id,
                    event,
                )
                .with_src_path(file!().into())
                .with_input_map(None)
                .guess_name(file!())
                .guess_image(file!(), &asset_server, "png")
                .with_description("Go faster, reach further")
                .spawn(&mut commands);
            }
            _ => {}
        }
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\tools\src\default_wheel_tool.rs

````rust
use crate::prelude::*;
use bevy::prelude::*;
use cursor_hero_toolbelt_types::prelude::*;

pub struct DefaultWheelToolPlugin;

impl Plugin for DefaultWheelToolPlugin {
    fn build(&self, app: &mut App) {
        app.register_type::<DefaultWheelTool>();
        app.add_systems(Update, toolbelt_events);
        app.add_systems(Update, tick);
    }
}

#[derive(Component, Reflect, Default)]
struct DefaultWheelTool;

fn toolbelt_events(
    mut commands: Commands,
    asset_server: Res<AssetServer>,
    mut reader: EventReader<ToolbeltPopulateEvent>,
) {
    for event in reader.read() {
        let (ToolbeltLoadout::Inspector
        | ToolbeltLoadout::Taskbar
        | ToolbeltLoadout::Chat
        | ToolbeltLoadout::Keyboard
        | ToolbeltLoadout::WindowPosition) = event.loadout
        else {
            continue;
        };
        ToolSpawnConfig::<DefaultWheelTool, NoInputs>::new(DefaultWheelTool, event.id, event)
            .with_src_path(file!().into())
            .guess_name(file!())
            .guess_image(file!(), &asset_server, "png")
            .with_description("Swaps to default tools")
            .with_starting_state(StartingState::Inactive)
            .spawn(&mut commands);
    }
}

fn tick(
    mut commands: Commands,
    tool_query: Query<&Parent, (Added<ActiveTool>, With<DefaultWheelTool>)>,
    mut toolbelt_events: EventWriter<ToolbeltPopulateEvent>,
) {
    for toolbelt_id in tool_query.iter() {
        info!("Switching toolbelt {:?} to default tools", toolbelt_id);
        let toolbelt_id = toolbelt_id.get();
        commands.entity(toolbelt_id).despawn_descendants();
        toolbelt_events.send(ToolbeltPopulateEvent {
            id: toolbelt_id,
            loadout: ToolbeltLoadout::Default,
        });
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\worker_types\src\worker_types.rs

````rust
use bevy::prelude::*;
pub use crossbeam_channel::Receiver;
pub use crossbeam_channel::Sender;
use std::marker::PhantomData;

#[derive(Resource)]
pub struct Bridge<T, G>
where
    T: Message,
    G: Message,
{
    pub sender: Sender<T>,
    pub receiver: Receiver<G>,
}

pub trait Message:
    std::fmt::Debug
    // + GetTypeRegistration
    + Event
    + Send
    + Sync
    + Clone
    // + Reflect
    // + TypePath
    // + FromReflect
    + 'static
{
}

pub type ThreadboundMessageHandler<T, G> =
    fn(msg: &T, reply_tx: &Sender<G>) -> Result<(), Box<dyn std::error::Error>>;

pub type ThreadboundMessageErrorHandler<T, G> =
    fn(msg: &T, reply_tx: &Sender<G>, error: &Box<dyn std::error::Error>) -> Result<(), Box<dyn std::error::Error>>;

#[derive(Resource, Reflect, Clone)]
pub struct WorkerConfig<T, G> {
    pub name: String,
    pub sleep_duration: std::time::Duration,
    pub is_ui_automation_thread: bool,
    pub handle_threadbound_message: ThreadboundMessageHandler<T, G>,
    pub handle_threadbound_message_error_handler: ThreadboundMessageErrorHandler<T, G>,
    pub _phantom_t: PhantomData<T>,
    pub _phantom_g: PhantomData<G>,
}
impl<T: Message, G: Message> Default for WorkerConfig<T, G> {
    fn default() -> Self {
        WorkerConfig {
            name: "Unknown Worker".to_string(),
            is_ui_automation_thread: false,
            sleep_duration: std::time::Duration::from_millis(100),
            handle_threadbound_message: |_, _| Ok(()),
            handle_threadbound_message_error_handler: |_, _, _| Ok(()),
            _phantom_t: PhantomData,
            _phantom_g: PhantomData,
        }
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\pointer\src\pointer_reach_plugin.rs

````rust
use bevy::prelude::*;
use cursor_hero_character_types::prelude::*;
use cursor_hero_math::prelude::Lerp;
use cursor_hero_pointer_types::prelude::*;

use cursor_hero_sprint_tool_types::sprint_tool_types_plugin::SprintEvent;
use cursor_hero_toolbelt_types::toolbelt_types::Wheel;

pub struct PointerReachPlugin;

impl Plugin for PointerReachPlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(Update, handle_reach_events);
        app.add_systems(Update, handle_sprint_events);
    }
}

fn handle_reach_events(
    mut reach_events: EventReader<PointerReachEvent>,
    character_query: Query<&Children, With<Character>>,
    mut pointer_query: Query<&mut Pointer>,
) {
    for event in reach_events.read() {
        match event {
            PointerReachEvent::SetPointer { pointer_id, reach } => {
                let Ok(mut pointer) = pointer_query.get_mut(*pointer_id) else {
                    warn!("Pointer not found processing {:?}", event);
                    continue;
                };
                pointer.reach = *reach;
            }
            PointerReachEvent::SetPointerPercent {
                pointer_id,
                percent,
            } => {
                let Ok(mut pointer) = pointer_query.get_mut(*pointer_id) else {
                    warn!("Pointer not found processing {:?}", event);
                    continue;
                };
                pointer.reach = (pointer.default_reach, pointer.sprint_reach).lerp(*percent);
            }

            PointerReachEvent::SetCharacter {
                character_id,
                reach,
            } => {
                let Ok(character) = character_query.get(*character_id) else {
                    warn!("Character not found processing {:?}", event);
                    continue;
                };
                let mut found = false;
                for kid in character.iter() {
                    let Ok(mut pointer) = pointer_query.get_mut(*kid) else {
                        continue;
                    };
                    pointer.reach = *reach;
                    found = true;
                }
                if !found {
                    warn!("Pointer not found processing {:?}", event);
                }
            }
            PointerReachEvent::SetCharacterPercent {
                character_id,
                percent,
            } => {
                let Ok(character) = character_query.get(*character_id) else {
                    warn!("Character not found processing {:?}", event);
                    continue;
                };
                let mut found = false;
                for kid in character.iter() {
                    let Ok(mut pointer) = pointer_query.get_mut(*kid) else {
                        continue;
                    };
                    pointer.reach = (pointer.default_reach, pointer.sprint_reach).lerp(*percent);
                    found = true;
                }
                if !found {
                    warn!("Pointer not found processing {:?}", event);
                }
            }

            PointerReachEvent::ResetPointer { pointer_id } => {
                let Ok(mut pointer) = pointer_query.get_mut(*pointer_id) else {
                    warn!("Pointer not found processing {:?}", event);
                    continue;
                };
                pointer.reach = pointer.default_reach;
            }
            PointerReachEvent::ResetCharacter { character_id } => {
                let Ok(character) = character_query.get(*character_id) else {
                    warn!("Character not found processing {:?}", event);
                    continue;
                };
                let mut found = false;
                for kid in character.iter() {
                    let Ok(mut pointer) = pointer_query.get_mut(*kid) else {
                        continue;
                    };
                    pointer.reach = pointer.default_reach;
                    found = true;
                }
                if !found {
                    warn!("Pointer not found processing {:?}", event);
                }
            }
        }
    }
}

fn handle_sprint_events(
    mut reach_events: EventWriter<PointerReachEvent>,
    mut sprint_events: EventReader<SprintEvent>,
    character_query: Query<&Children, With<Character>>,
    toolbelt_query: Query<&Wheel, With<Character>>,
) {
    for event in sprint_events.read() {
        let character_id = match event {
            SprintEvent::Active { character_id, .. } => character_id,
            SprintEvent::Stop { character_id } => character_id,
        };
        let Ok(character) = character_query.get(*character_id) else {
            warn!("Character not found processing {:?}", event);
            continue;
        };
        let toolbelt_open = character.iter().any(|kid| {
            let Ok(toolbelt) = toolbelt_query.get(*kid) else {
                return false;
            };
            toolbelt.open
        });
        if toolbelt_open {
            // Toolbelt reach updates take priority over sprint reach updates
            continue;
        }
        match event {
            SprintEvent::Active {
                character_id,
                throttle,
            } => {
                reach_events.send(PointerReachEvent::SetCharacterPercent {
                    character_id: *character_id,
                    percent: *throttle,
                });
            }
            SprintEvent::Stop { character_id } => {
                reach_events.send(PointerReachEvent::ResetCharacter {
                    character_id: *character_id,
                });
            }
        }
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\tools\src\level_bounds_visibility_tool.rs

````rust
use crate::prelude::*;
use bevy::prelude::*;
use cursor_hero_level_bounds::level_bounds_plugin::LevelBounds;
use cursor_hero_toolbelt_types::prelude::*;

pub struct LevelBoundsVisibilityToolPlugin;

impl Plugin for LevelBoundsVisibilityToolPlugin {
    fn build(&self, app: &mut App) {
        app.register_type::<LevelBoundsVisibilityTool>();
        app.add_systems(Update, toolbelt_events);
        app.add_systems(Update, tick);
    }
}

#[derive(Component, Reflect, Default)]
struct LevelBoundsVisibilityTool;

fn toolbelt_events(
    mut commands: Commands,
    asset_server: Res<AssetServer>,
    mut reader: EventReader<ToolbeltPopulateEvent>,
) {
    for event in reader.read() {
        let ToolbeltLoadout::Inspector = event.loadout else {
            continue;
        };
        ToolSpawnConfig::<LevelBoundsVisibilityTool, NoInputs>::new(
            LevelBoundsVisibilityTool,
            event.id,
            event,
        )
        .with_src_path(file!().into())
        .guess_name(file!())
        .guess_image(file!(), &asset_server, "png")
        .with_description("Shows the play area.")
        .with_starting_state(StartingState::Inactive)
        .spawn(&mut commands);
    }
}

fn tick(
    mut commands: Commands,
    tool_query: Query<Entity, (Added<ActiveTool>, With<LevelBoundsVisibilityTool>)>,
    mut level_bounds_query: Query<&mut Visibility, With<LevelBounds>>,
) {
    for tool_id in tool_query.iter() {
        commands.entity(tool_id).remove::<ActiveTool>();
        for mut visibility in level_bounds_query.iter_mut() {
            *visibility = match *visibility {
                Visibility::Visible => Visibility::Hidden,
                Visibility::Hidden => Visibility::Visible,
                Visibility::Inherited => Visibility::Visible,
            };
        }
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\environment_types\src\environment_types_plugin.rs

````rust
use crate::prelude::*;
use bevy::prelude::*;

pub struct EnvironmentTypesPlugin;

impl Plugin for EnvironmentTypesPlugin {
    fn build(&self, app: &mut App) {
        app.register_type::<TrackEnvironmentTag>();
        app.register_type::<EnvironmentTracker>();
        app.register_type::<EnvironmentKind>();
        app.register_type::<HostEnvironment>();
        app.register_type::<HostUIWatcherEnvironment>();
        app.register_type::<GameEnvironment>();
        app.register_type::<Nametag>();
        app.add_event::<CreateEnvironmentRequestEvent>();
        app.add_event::<PopulateEnvironmentEvent>();
        app.add_event::<NametagEvent>();
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\glados_tts\src\glados_tts_status_worker_plugin.rs

````rust
use bevy::prelude::*;
use crossbeam_channel::bounded;
use crossbeam_channel::Receiver;
use crossbeam_channel::Sender;
use cursor_hero_glados_tts_types::prelude::*;
use std::thread;

pub struct GladosTtsStatusWorkerPlugin;

impl Plugin for GladosTtsStatusWorkerPlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(Startup, create_worker_thread);
        app.add_systems(Update, events_to_bridge);
        app.add_systems(Update, bridge_to_events);
    }
}

#[derive(Debug)]
enum GameboundMessage {
    Pong { status: GladosTtsStatus },
}

#[derive(Debug)]
enum ThreadboundMessage {
    Ping,
    Startup,
}

#[derive(Resource)]
struct Bridge {
    pub sender: Sender<ThreadboundMessage>,
    pub receiver: Receiver<GameboundMessage>,
}

fn create_worker_thread(mut commands: Commands) {
    let (game_tx, game_rx) = bounded::<_>(10);
    let (thread_tx, thread_rx) = bounded::<_>(10);
    commands.insert_resource(Bridge {
        sender: thread_tx,
        receiver: game_rx,
    });

    let game_tx_clone = game_tx.clone();
    thread::Builder::new()
        .name("GLaDOS TTS status thread".to_string())
        .spawn(move || {
            let rt = tokio::runtime::Runtime::new().unwrap();
            rt.block_on(async {
                let game_tx = game_tx_clone;
                loop {
                    let msg = match thread_rx.recv() {
                        Ok(msg) => msg,
                        Err(_) => {
                            error!("Threadbound channel failure, exiting");
                            break;
                        }
                    };
                    match msg {
                        ThreadboundMessage::Ping => {
                            debug!("Worker received ping request, pinging GladosTts API");
                            let status = match crate::glados_tts::get_status().await {
                                Ok(status) => status,
                                Err(e) => {
                                    error!("Failed to get status: {:?}", e);
                                    GladosTtsStatus::Unknown
                                }
                            };
                            if let Err(e) = game_tx.send(GameboundMessage::Pong { status }) {
                                error!("Gamebound channel failure, exiting: {}", e);
                                break;
                            }
                        }
                        ThreadboundMessage::Startup => {
                            debug!("Worker received startup request, starting GladosTts API");
                            if let Err(e) = crate::glados_tts::start() {
                                error!("Failed to start: {:?}", e);
                            };
                        }
                    }
                    std::thread::sleep(std::time::Duration::from_millis(50));
                }
            });
        })
        .expect("Failed to spawn thread");
}

fn events_to_bridge(
    bridge: ResMut<Bridge>,
    mut ping_events: EventReader<GladosTtsPingEvent>,
    mut status_events: EventReader<GladosTtsStatusEvent>,
) {
    // Detect ping requests
    for event in ping_events.read() {
        let GladosTtsPingEvent::Ping = event else {
            continue;
        };
        let msg = ThreadboundMessage::Ping;
        debug!("Sending bridge message: {:?}", msg);
        if let Err(e) = bridge.sender.send(msg) {
            error!("Threadbound channel failure: {}", e);
        }
    }

    // Detect startup requests
    let starting = status_events
        .read()
        .any(|event| matches!(event, GladosTtsStatusEvent::Startup));
    if starting {
        status_events.clear();
        let msg = ThreadboundMessage::Startup;
        debug!("Sending bridge message: {:?}", msg);
        if let Err(e) = bridge.sender.send(msg) {
            error!("Threadbound channel failure: {}", e);
        }
    }
}

fn bridge_to_events(bridge: ResMut<Bridge>, mut events: EventWriter<GladosTtsPingEvent>) {
    for msg in bridge.receiver.try_iter() {
        match msg {
            GameboundMessage::Pong { status } => {
                let event = GladosTtsPingEvent::Pong { status };
                debug!("Received bridge response, sending game event {:?}", event);
                events.send(event);
            }
        }
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\ui_automation\src\lib.rs

````rust
mod elements_at_point;
mod formatting;
mod gather_children;
mod gather_element_info;
mod gather_root_children;
mod resolve_app;
mod resolve_vscode;
mod take_snapshot;
mod taskbar;
mod ui_automation_plugin;
mod resolve_calculator;

pub mod prelude {
    pub use crate::elements_at_point::*;
    pub use crate::formatting::*;
    pub use crate::gather_element_info::*;
    pub use crate::take_snapshot::*;
    pub use crate::taskbar::*;
    pub use crate::ui_automation_plugin::*;
    pub use crate::gather_children::*;
    pub use cursor_hero_ui_automation_types::prelude::*;
}

````



## D:\Repos\Games\Cursor-Hero\crates\secret\src\secrets_plugin.rs

````rust
use bevy::prelude::*;

pub struct SecretsPlugin;

impl Plugin for SecretsPlugin {
    fn build(&self, _app: &mut App) {}
}

````



## D:\Repos\Games\Cursor-Hero\crates\window_position_types\win_icons.rs

````rust

````



## D:\Repos\Games\Cursor-Hero\crates\worker\src\lib.rs

````rust
mod worker_plugin;

pub mod prelude {
    pub use crate::worker_plugin::*;
    pub use cursor_hero_worker_types::prelude::*;
}

````



## D:\Repos\Games\Cursor-Hero\crates\chat\src\chat_plugin.rs

````rust
use crate::chat_bubble_plugin::ChatBubblePlugin;
use crate::chat_focus_exclusivity_plugin::ChatFocusExclusivityPlugin;
use crate::chat_input_buffer_plugin::ChatInputBufferPlugin;
use crate::chat_sfx_plugin::ChatSfxPlugin;
use crate::chat_tool_plugin::ChatToolPlugin;
use bevy::prelude::*;
pub struct ChatPlugin;

impl Plugin for ChatPlugin {
    fn build(&self, app: &mut App) {
        app.add_plugins(ChatToolPlugin);
        app.add_plugins(ChatFocusExclusivityPlugin);
        app.add_plugins(ChatBubblePlugin);
        app.add_plugins(ChatInputBufferPlugin);
        app.add_plugins(ChatSfxPlugin);
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\pressure_plate\src\lib.rs

````rust
pub mod pressure_plate_plugin;

````



## D:\Repos\Games\Cursor-Hero\crates\tools\src\restart_tool.rs

````rust
use std::os::windows::process::CommandExt;
use std::path::PathBuf;

use bevy::prelude::*;
use leafwing_input_manager::prelude::*;

use windows::Win32::System::Threading::CREATE_NEW_PROCESS_GROUP;

use cursor_hero_data::paths::CURSOR_HERO_GIT_DIR;
use cursor_hero_toolbelt_types::prelude::*;

use crate::prelude::*;
pub struct RestartToolPlugin;

impl Plugin for RestartToolPlugin {
    fn build(&self, app: &mut App) {
        app.register_type::<RestartTool>();
        app.add_plugins(InputManagerPlugin::<RestartToolAction>::default());
        app.add_systems(Update, toolbelt_events);
        app.add_systems(Update, handle_input);
    }
}

#[derive(Component, Reflect, Default)]
struct RestartTool;

fn toolbelt_events(
    mut commands: Commands,
    asset_server: Res<AssetServer>,
    mut reader: EventReader<ToolbeltPopulateEvent>,
) {
    for event in reader.read() {
        let (ToolbeltLoadout::Inspector | ToolbeltLoadout::Default) = event.loadout else {
            continue;
        };
        {
            ToolSpawnConfig::<RestartTool, RestartToolAction>::new(RestartTool, event.id, event)
                .with_src_path(file!().into())
                .guess_name(file!())
                .guess_image(file!(), &asset_server, "png")
                .with_description("Send Ctrl+C, uparrow, enter")
                .spawn(&mut commands);
        }
    }
}

#[derive(Actionlike, PartialEq, Eq, Clone, Copy, Hash, Debug, Reflect)]
enum RestartToolAction {
    CancelAndRunPreviousTerminalCommand,
}

impl RestartToolAction {
    fn default_gamepad_binding(&self) -> UserInput {
        match self {
            Self::CancelAndRunPreviousTerminalCommand => GamepadButtonType::Start.into(),
        }
    }

    fn default_mkb_binding(&self) -> UserInput {
        match self {
            Self::CancelAndRunPreviousTerminalCommand => KeyCode::Plus.into(),
        }
    }
}
impl ToolAction for RestartToolAction {
    fn default_input_map(_event: &ToolbeltPopulateEvent) -> Option<InputMap<RestartToolAction>> {
        let mut input_map = InputMap::default();

        for variant in RestartToolAction::variants() {
            input_map.insert(variant.default_mkb_binding(), variant);
            input_map.insert(variant.default_gamepad_binding(), variant);
        }
        Some(input_map)
    }
}

#[allow(clippy::type_complexity)]
fn handle_input(tools: Query<&ActionState<RestartToolAction>, With<ActiveTool>>) {
    for t_act in tools.iter() {
        if t_act.just_pressed(RestartToolAction::CancelAndRunPreviousTerminalCommand) {
            // run target/release/uparrow-enter.exe

            let mut path = PathBuf::from(CURSOR_HERO_GIT_DIR);
            path.push("target/release/uparrow-enter.exe");

            // if it doesn't exist
            if !path.exists() {
                let mut other_project_path = PathBuf::from(CURSOR_HERO_GIT_DIR);
                other_project_path.push("other/uparrow-enter");
                // run cargo build --release
                match std::process::Command::new("cargo")
                    .arg("build")
                    .arg("--release")
                    .current_dir(other_project_path)
                    .spawn()
                {
                    Ok(_) => info!("Successfully ran cargo build --release"),
                    Err(e) => error!("Failed to run cargo build --release: {}", e),
                }
            }

            match std::process::Command::new(path)
                .creation_flags(CREATE_NEW_PROCESS_GROUP.0)
                .spawn()
            {
                Ok(_) => info!("Successfully ran uparrow-enter.exe"),
                Err(e) => error!("Failed to run uparrow-enter.exe: {}", e),
            }
        }
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\taskbar\src\taskbar_plugin.rs

````rust
use crate::taskbar_spawn_plugin::TaskbarSpawnPlugin;
use bevy::prelude::*;

pub struct TaskbarPlugin;

impl Plugin for TaskbarPlugin {
    fn build(&self, app: &mut App) {
        app.add_plugins(TaskbarSpawnPlugin);
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\movement_tool\src\movement_tool_plugin.rs

````rust
use bevy::prelude::*;

use crate::movement_speed_plugin::MovementSpeedPlugin;
use crate::movement_sprint_plugin::MovementSprintPlugin;
use crate::movement_target_plugin::MovementTargetPlugin;
use crate::movement_tool_populate_plugin::MovementToolPopulatePlugin;
use crate::movement_tool_tick_plugin::MovementToolTickPlugin;

pub struct MovementToolPlugin;

impl Plugin for MovementToolPlugin {
    fn build(&self, app: &mut App) {
        app.add_plugins(MovementSpeedPlugin);
        app.add_plugins(MovementSprintPlugin);
        app.add_plugins(MovementToolTickPlugin);
        app.add_plugins(MovementTargetPlugin);
        app.add_plugins(MovementToolPopulatePlugin);
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\ui_automation_types\src\vscode_ui_types.rs

````rust
use bevy::prelude::*;
use itertools::Itertools;
use serde::Deserialize;
use serde::Serialize;
use std::collections::VecDeque;
use std::fmt;
use std::fmt::Display;
use std::fmt::Formatter;
use uiautomation::UIElement;

pub enum VSCodeResolveError {
    BadChildCount { tried_accessing: u32 },
    UI(uiautomation::Error),
    UnknownSideTabKind(String),
    UnknownState,
}
impl From<u32> for VSCodeResolveError {
    fn from(tried_accessing: u32) -> Self {
        VSCodeResolveError::BadChildCount { tried_accessing }
    }
}

impl From<uiautomation::Error> for VSCodeResolveError {
    fn from(e: uiautomation::Error) -> Self {
        VSCodeResolveError::UI(e)
    }
}
impl TryFrom<VecDeque<UIElement>> for VSCodeCrawlState {
    type Error = VSCodeResolveError;
    fn try_from(mut kids: VecDeque<UIElement>) -> Result<Self, Self::Error> {
        let state = match kids.len() {
            2 => VSCodeCrawlState::LeftTabClosed {
                tabs: kids.pop_front().ok_or(0u32)?,
                editor: kids.pop_front().ok_or(1u32)?,
            },
            3 => VSCodeCrawlState::LeftTabOpen {
                side_nav_tabs: kids.pop_front().ok_or(0u32)?,
                side_nav_view: kids.pop_front().ok_or(1u32)?,
                editor: kids.pop_front().ok_or(2u32)?,
            },
            _ => VSCodeCrawlState::Unknown,
        };
        Ok(state)
    }
}

#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]
pub enum View {
    Explorer {
        sticky: Vec<ExplorerItem>,
        items: Vec<ExplorerItem>,
    },
    Unknown {},
}
impl Display for View {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        match self {
            View::Explorer { sticky, items } => {
                writeln!(f, "Explorer entries:")?;
                writeln!(f, "=== BEGIN STICKY ===")?;
                for item in sticky.iter().sorted_by_key(|x| x.bounds.min.y) {
                    writeln!(
                        f,
                        "{}- {} ({})",
                        " ".repeat(item.ui_level as usize),
                        item.label.clone()
                            + if matches!(item.kind, ExplorerItemKind::Directory { .. }) {
                                "/"
                            } else {
                                ""
                            },
                        item.path
                    )?;
                }
                writeln!(f, "=== END STICKY ===")?;
                for item in items.iter().sorted_by_key(|x| x.bounds.min.y) {
                    writeln!(
                        f,
                        "{}- {} ({})",
                        " ".repeat(item.ui_level as usize),
                        item.label.clone()
                            + if matches!(item.kind, ExplorerItemKind::Directory { .. }) {
                                "/"
                            } else {
                                ""
                            },
                        item.path
                    )?;
                }
                fmt::Result::Ok(())
            }
            View::Unknown {} => {
                writeln!(f, "Unknown view")?;
                fmt::Result::Ok(())
            }
        }
    }
}

pub enum VSCodeCrawlState {
    LeftTabClosed {
        tabs: UIElement,
        editor: UIElement,
    },
    LeftTabOpen {
        side_nav_tabs: UIElement,
        side_nav_view: UIElement,
        editor: UIElement,
    },
    Unknown,
}
impl VSCodeCrawlState {
    pub fn get_side_nav_tabs_root_elem(&self) -> Result<&UIElement, VSCodeResolveError> {
        match self {
            VSCodeCrawlState::LeftTabClosed { tabs, .. } => Ok(tabs),
            VSCodeCrawlState::LeftTabOpen {
                side_nav_tabs: tabs,
                ..
            } => Ok(tabs),
            VSCodeCrawlState::Unknown => Err(VSCodeResolveError::UnknownState),
        }
    }
    pub fn get_side_nav_view_root_elem(&self) -> Result<&UIElement, VSCodeResolveError> {
        match self {
            VSCodeCrawlState::LeftTabClosed { tabs, .. } => Ok(tabs),
            VSCodeCrawlState::LeftTabOpen {
                side_nav_view: view,
                ..
            } => Ok(view),
            VSCodeCrawlState::Unknown => Err(VSCodeResolveError::UnknownState),
        }
    }
    pub fn get_editor_root_elem(&self) -> Result<&UIElement, VSCodeResolveError> {
        match self {
            VSCodeCrawlState::LeftTabClosed { editor, .. } => Ok(editor),
            VSCodeCrawlState::LeftTabOpen { editor, .. } => Ok(editor),
            VSCodeCrawlState::Unknown => Err(VSCodeResolveError::UnknownState),
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]
pub struct VSCodeWindowHeader {}

#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]
pub struct VSCodeWindowBody {
    pub editor_area: EditorArea,
    pub side_nav: Vec<SideTab>,
}

#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]
pub struct VSCodeWindowFooter {
    pub cursor_position: IVec2,
}

#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]
pub struct VSCodeWindow {
    pub focused: bool,
    pub header: VSCodeWindowHeader,
    pub body: VSCodeWindowBody,
    pub footer: VSCodeWindowFooter,
}

impl Display for VSCodeWindow {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        writeln!(
            f,
            ":D :D :D Visual Studio Code {} owo owo owo",
            if self.focused { "(focused)" } else { "" }
        )?;

        writeln!(f, "Side tabs:")?;
        for tab in self.body.side_nav.iter() {
            match tab {
                SideTab::Open { kind, view } => {
                    writeln!(f, "- (open) {:?} {{{{\n{}}}}}", kind, view)?;
                }
                SideTab::Closed { kind } => {
                    writeln!(f, "- {:?}", kind)?;
                }
            }
        }

        writeln!(f, "Editor groups:")?;
        for (i, group) in self.body.editor_area.groups.iter().enumerate() {
            writeln!(f, "Group {} tabs:", i + 1)?;
            for tab in group.tabs.iter() {
                if tab.active {
                    writeln!(f, "- (active) {}", tab.title)?;
                } else {
                    writeln!(f, "- {}", tab.title)?;
                }
            }
            if let Some(ref content) = group.content {
                writeln!(
                    f,
                    "Group {} buffer:\n=======\n{}\n=======",
                    i + 1,
                    content.content
                )?;
            }
        }

        writeln!(f, "Cursor position: {:?}", self.footer.cursor_position)?;

        fmt::Result::Ok(())
    }
}

#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]
pub enum SideTab {
    Closed { kind: SideTabKind },
    Open { kind: SideTabKind, view: View },
}

#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]
pub enum ExplorerItemKind {
    File,
    Directory { expanded: bool },
}

#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]
pub struct ExplorerItem {
    pub label: String,
    pub path: String,
    pub ui_position_in_set: u32,
    pub ui_size_of_set: u32,
    pub ui_level: u32,
    pub bounds: IRect,
    pub kind: ExplorerItemKind,
}

#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]
pub struct EditorArea {
    pub groups: Vec<EditorGroup>,
}
impl EditorArea {
    pub fn get_expected_automation_id() -> &'static str {
        "workbench.parts.editor"
    }
}

#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]
pub struct EditorGroup {
    pub tabs: Vec<EditorTab>,
    pub content: Option<EditorContent>,
}

#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]
pub struct EditorTab {
    pub title: String,
    pub active: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]
pub struct EditorContent {
    pub content: String,
}

#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Reflect)]
pub enum SideTabKind {
    Explorer,
    Search,
    SourceControl,
    RunAndDebug,
    Extensions,
    GitLens,
    Azure,
    Jupyter,
    Chat,
    GitHubActions,
    Todo,
}
impl SideTabKind {
    pub fn variants() -> Vec<SideTabKind> {
        vec![
            SideTabKind::Explorer,
            SideTabKind::Search,
            SideTabKind::SourceControl,
            SideTabKind::RunAndDebug,
            SideTabKind::Extensions,
            SideTabKind::GitLens,
            SideTabKind::Azure,
            SideTabKind::Jupyter,
            SideTabKind::Chat,
            SideTabKind::GitHubActions,
            SideTabKind::Todo,
        ]
    }
    pub fn get_view_automation_id(&self) -> Option<&str> {
        match self {
            SideTabKind::Explorer => Some("workbench.view.explorer"),
            _ => None,
        }
    }
}
impl TryFrom<String> for SideTabKind {
    type Error = VSCodeResolveError;
    fn try_from(s: String) -> Result<Self, Self::Error> {
        let before_first_lparen = s.split_once(" (").map(|x| x.0).unwrap_or(s.as_str());
        match before_first_lparen {
            "Explorer" => Ok(SideTabKind::Explorer),
            "Search" => Ok(SideTabKind::Search),
            "Source Control" => Ok(SideTabKind::SourceControl),
            "Run and Debug" => Ok(SideTabKind::RunAndDebug),
            "Extensions" => Ok(SideTabKind::Extensions),
            "GitLens" => Ok(SideTabKind::GitLens),
            "Azure" => Ok(SideTabKind::Azure),
            "Jupyter" => Ok(SideTabKind::Jupyter),
            "Chat" => Ok(SideTabKind::Chat),
            "GitHub Actions" => Ok(SideTabKind::GitHubActions),
            "TODOs" => Ok(SideTabKind::Todo),
            _ => Err(VSCodeResolveError::UnknownSideTabKind(s)),
        }
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\math\src\lib.rs

````rust
mod corner;
mod lerp;
mod math_plugin;
mod shuffle;

pub mod prelude {
    pub use crate::corner::*;
    pub use crate::lerp::*;
    pub use crate::math_plugin::*;
    pub use crate::shuffle::*;
}

````



## D:\Repos\Games\Cursor-Hero\crates\bevy\src\vec_into_rect.rs

````rust
use bevy::math::Rect;
use bevy::math::Vec2;

pub trait Vec2ToRect {
    fn as_size_of_rect_with_center(&self, center: &Vec2) -> Rect;
}
impl Vec2ToRect for Vec2 {
    fn as_size_of_rect_with_center(&self, center: &Vec2) -> Rect {
        Rect::from_center_size(*center, *self)
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\input\src\input_plugin.rs

````rust
use bevy::prelude::*;

use crate::active_input_state_plugin::ActiveInputStatePlugin;
use crate::update_gamepad_settings::update_gamepad_settings;

pub struct InputPlugin;

impl Plugin for InputPlugin {
    fn build(&self, app: &mut App) {
        app.add_plugins(ActiveInputStatePlugin);
        app.add_systems(Update, update_gamepad_settings);
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\worker_types\src\worker_types_plugin.rs

````rust
use bevy::prelude::*;
// use crate::prelude::*;

pub struct WorkerTypesPlugin;

impl Plugin for WorkerTypesPlugin {
    fn build(&self, _app: &mut App) {
        // app.register_type::<MyComponent>();
        // app.add_event::<MyEvent>();
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\ui_automation\src\gather_root_children.rs

````rust
use std::collections::VecDeque;

use uiautomation::UIAutomation;
use uiautomation::UIElement;
use uiautomation::UITreeWalker;

use crate::gather_children::gather_children;
use crate::gather_children::StopBehaviour;

pub fn gather_root_children(
    automation: &UIAutomation,
    walker: &UITreeWalker,
) -> Result<VecDeque<UIElement>, uiautomation::Error> {
    let root = automation.get_root_element()?;
    // println!("Boutta gather top level children");
    let top_level_children = gather_children(walker, &root, &StopBehaviour::RootEndEncountered);
    // let condition = &automation.create_true_condition()?;
    // let found = root.find_all(TreeScope::Children, condition)?;
    // println!("Found {} top level children", top_level_children.len());
    Ok(top_level_children)
}

#[cfg(test)]
mod tests {
    use super::*;
    use uiautomation::UIAutomation;

    #[test]
    fn test_gather_root_children() {
        let automation = UIAutomation::new().unwrap();
        let walker = automation.create_tree_walker().unwrap();
        for _ in 0..100 {
            let start = std::time::Instant::now();
            let children = gather_root_children(&automation, &walker).unwrap();
            let end = std::time::Instant::now();
            let elapsed = end - start;
            println!("Gathered {} children in {:?}", children.len(), elapsed);
            assert!(!children.is_empty());
            assert!(elapsed.as_millis() < 1000);
        }
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\pressure_plate\src\pressure_plate_plugin.rs

````rust
use bevy::prelude::*;
use bevy_xpbd_2d::components::CollidingEntities;

pub struct PressurePlatePlugin;
impl Plugin for PressurePlatePlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(Update, update_plate)
            .add_event::<PressurePlateActivationEvent>()
            .register_type::<PressurePlate>();
    }
}

#[derive(Event)]
pub struct PressurePlateActivationEvent(pub Entity);

#[derive(Component, Reflect)]
pub struct PressurePlate {
    active_time: f32,
    debounce: bool,
    indicator: Entity,
}

#[derive(Component, Default, Reflect)]
pub struct PressurePlateProgressIndicator {
    visual_progress: f32,
}

impl PressurePlate {
    pub fn new(indicator: Entity) -> Self {
        Self {
            active_time: 0.0,
            debounce: false,
            indicator,
        }
    }
}

#[allow(clippy::type_complexity)]
fn update_plate(
    asset_server: Res<AssetServer>,
    mut commands: Commands,
    time: Res<Time>,
    mut query: Query<
        (
            Entity,
            &mut PressurePlate,
            &mut Sprite,
            &CollidingEntities,
            Option<&SpatialAudioSink>,
        ),
        Without<PressurePlateProgressIndicator>,
    >,
    mut indicator_query: Query<
        (&mut PressurePlateProgressIndicator, &mut Sprite),
        Without<PressurePlate>,
    >,
    mut activation_writer: EventWriter<PressurePlateActivationEvent>,
) {
    for (entity, mut plate, mut sprite, colliding_entities, sink) in &mut query {
        if colliding_entities.0.is_empty() {
            sprite.color = Color::rgb(0.2, 0.7, 0.9);
            plate.active_time = 0.0;
            sink.map(SpatialAudioSink::stop);
            plate.debounce = false;
        } else {
            if plate.debounce {
                continue;
            }
            sprite.color = Color::rgb(0.9, 0.7, 0.2);
            if plate.active_time == 0.0 {
                let bundle = AudioBundle {
                    source: asset_server.load("sounds/pressure plate activation.ogg"),
                    settings: PlaybackSettings::REMOVE.with_spatial(true),
                };
                commands.entity(entity).insert(bundle);
                plate.active_time += time.delta_seconds();
            } else {
                plate.active_time += time.delta_seconds();
                if plate.active_time > cursor_hero_data::sounds::PRESSURE_PLATE_ACTIVATION_DURATION
                {
                    plate.active_time = 0.0;
                    plate.debounce = true;
                    activation_writer.send(PressurePlateActivationEvent(entity));
                }
            }
        }
        if let Ok((mut indicator, mut indicator_sprite)) = indicator_query.get_mut(plate.indicator)
        {
            indicator.visual_progress =
                plate.active_time / cursor_hero_data::sounds::PRESSURE_PLATE_ACTIVATION_DURATION;
            indicator_sprite.color = Color::rgb(0.2, 0.7, 0.9) * indicator.visual_progress;
        }
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\tools\src\lib.rs

````rust
#![feature(let_chains)]

pub mod click_tool;
pub mod cube_tool;
pub mod default_wheel_tool;
pub mod focus_tool;
pub mod hello_tool;
pub mod keyboard_tool;
pub mod keyboard_wheel_tool;
pub mod level_bounds_visibility_tool;
pub mod placeholder_tool;
pub mod restart_tool;
pub mod scroll_tool;
pub mod talk_tool;
pub mod tool_plugin;
pub mod tool_spawning;
pub mod window_drag_tool;
pub mod zoom_tool;

pub use crate::tool_plugin::ToolPlugin;

pub mod prelude {
    pub use crate::tool_spawning::NoInputs;
    pub use crate::tool_spawning::StartingState;
    pub use crate::tool_spawning::ToolSpawnConfig;
}

````



## D:\Repos\Games\Cursor-Hero\crates\pointer\src\lib.rs

````rust
#![feature(let_chains)]

pub mod pointer_click_plugin;
pub mod pointer_hover_plugin;
pub mod pointer_plugin;
pub mod pointer_positioning_plugin;
pub mod pointer_reach_plugin;
pub mod pointer_spawning_plugin;

````



## D:\Repos\Games\Cursor-Hero\crates\app_types\src\app_types.rs

````rust
use bevy::prelude::*;

#[derive(Component, Debug, Reflect)]
pub struct MyComponent;

#[derive(Event, Debug, Reflect)]
pub enum MyEvent {
    Guh,
    Uh,
}

````



## D:\Repos\Games\Cursor-Hero\crates\host_fs_types\src\host_fs_types_plugin.rs

````rust
use crate::prelude::*;
use bevy::prelude::*;

pub struct HostFsTypesPlugin;

impl Plugin for HostFsTypesPlugin {
    fn build(&self, app: &mut App) {
        app.register_type::<HostPath>();
        app.add_event::<HostPathAction>();
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\character_types\src\character_types_plugin.rs

````rust
use crate::character_types::*;
use bevy::prelude::*;
pub struct CharacterTypesPlugin;

impl Plugin for CharacterTypesPlugin {
    fn build(&self, app: &mut App) {
        app.register_type::<Character>();
        app.register_type::<MainCharacter>();
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\window_position\src\window_position_plugin.rs

````rust
use bevy::prelude::*;

use crate::window_position_command_plugin::WindowPositionCommandPlugin;
use crate::window_position_loadout_switcher_tool_plugin::WindowPositionLoadoutSwitcherToolPlugin;
use crate::window_position_tool_plugin::WindowPositionToolPlugin;

pub struct WindowPositionPlugin;

impl Plugin for WindowPositionPlugin {
    fn build(&self, app: &mut App) {
        app.add_plugins(WindowPositionLoadoutSwitcherToolPlugin);
        app.add_plugins(WindowPositionToolPlugin);
        app.add_plugins(WindowPositionCommandPlugin);
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\app\src\lib.rs

````rust
pub mod app_plugin;

pub mod prelude {
    pub use crate::app_plugin::*;
}

````



## D:\Repos\Games\Cursor-Hero\crates\tools\src\keyboard_wheel_tool.rs

````rust
use crate::prelude::*;
use bevy::prelude::*;
use cursor_hero_toolbelt_types::prelude::*;

pub struct KeyboardWheelToolPlugin;

impl Plugin for KeyboardWheelToolPlugin {
    fn build(&self, app: &mut App) {
        app.register_type::<KeyboardWheelTool>();
        app.add_systems(Update, toolbelt_events);
        app.add_systems(Update, tick);
    }
}

#[derive(Component, Reflect, Default)]
struct KeyboardWheelTool;

fn toolbelt_events(
    mut commands: Commands,
    asset_server: Res<AssetServer>,
    mut reader: EventReader<ToolbeltPopulateEvent>,
) {
    for event in reader.read() {
        let ToolbeltLoadout::Default = event.loadout else {
            continue;
        };
        ToolSpawnConfig::<KeyboardWheelTool, NoInputs>::new(KeyboardWheelTool, event.id, event)
            .with_src_path(file!().into())
            .guess_name(file!())
            .guess_image(file!(), &asset_server, "png")
            .with_description("Swaps to keyboard tools")
            .with_starting_state(StartingState::Inactive)
            .spawn(&mut commands);
    }
}

fn tick(
    mut commands: Commands,
    tool_query: Query<&Parent, (Added<ActiveTool>, With<KeyboardWheelTool>)>,
    mut toolbelt_events: EventWriter<ToolbeltPopulateEvent>,
) {
    for toolbelt_id in tool_query.iter() {
        info!("Switching toolbelt {:?} to keyboard tools", toolbelt_id);
        let toolbelt_id = toolbelt_id.get();
        commands.entity(toolbelt_id).despawn_descendants();
        toolbelt_events.send(ToolbeltPopulateEvent {
            id: toolbelt_id,
            loadout: ToolbeltLoadout::Keyboard,
        });
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\glados_tts\src\glados_tts_plugin.rs

````rust
use bevy::prelude::*;

use crate::glados_tts_button_plugin::GladosTtsButtonPlugin;
use crate::glados_tts_inference_plugin::GladosTtsInferencePlugin;
use crate::glados_tts_status_plugin::GladosTtsStatusPlugin;
use crate::glados_tts_status_worker_plugin::GladosTtsStatusWorkerPlugin;

pub struct GladosTtsPlugin;

impl Plugin for GladosTtsPlugin {
    fn build(&self, app: &mut App) {
        app.add_plugins(GladosTtsInferencePlugin);
        app.add_plugins(GladosTtsButtonPlugin);
        app.add_plugins(GladosTtsStatusPlugin);
        app.add_plugins(GladosTtsStatusWorkerPlugin);
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\fullscreen_tool_types\src\fullscreen_tool_types_plugin.rs

````rust
use crate::prelude::*;
use bevy::prelude::*;

pub struct FullscreenToolTypesPlugin;

impl Plugin for FullscreenToolTypesPlugin {
    fn build(&self, app: &mut App) {
        app.register_type::<FullscreenTool>();
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\ui_watcher\src\lib.rs

````rust
pub mod ui_watcher_plugin;

pub mod prelude {
    pub use crate::ui_watcher_plugin::*;
}

````



## D:\Repos\Games\Cursor-Hero\crates\observation_types\src\lib.rs

````rust
#![feature(trivial_bounds)]
pub mod observation_types;
pub mod observation_types_plugin;

pub mod prelude {
    pub use crate::observation_types::*;
    pub use crate::observation_types_plugin::ObservationTypesPlugin;
}

````



## D:\Repos\Games\Cursor-Hero\crates\glados_tts_types\src\glados_tts_types.rs

````rust
use std::time::Duration;

use bevy::prelude::*;
use bevy::utils::Instant;

#[derive(Reflect, Resource, Default, Debug, Eq, PartialEq, Clone, Copy)]
#[reflect(Resource)]
pub enum GladosTtsStatus {
    #[default]
    Unknown,
    Alive,
    Dead,
    Starting {
        instant: Instant,
        timeout: Duration,
    },
}

#[derive(Component, Debug, Reflect, Default)]
pub struct GladosTtsStatusButton {
    pub visual_state: GladosTtsStatusButtonVisualState,
}

#[derive(Debug, Reflect, Eq, PartialEq)]
pub enum GladosTtsStatusButtonVisualState {
    Default { status: GladosTtsStatus },
    Hovered { status: GladosTtsStatus },
    Pressed { status: GladosTtsStatus },
}
impl Default for GladosTtsStatusButtonVisualState {
    fn default() -> Self {
        GladosTtsStatusButtonVisualState::Default {
            status: GladosTtsStatus::Unknown,
        }
    }
}

#[derive(Component, Debug, Reflect, Default)]
pub struct GladosTtsVscodeButton {
    pub visual_state: GladosTtsVscodeButtonVisualState,
}
#[derive(Debug, Reflect, Eq, PartialEq, Default)]
pub enum GladosTtsVscodeButtonVisualState {
    #[default]
    Default,
}
#[derive(Event, Debug, Reflect)]
pub enum GladosTtsVscodeEvent {
    Startup,
}

#[derive(Event, Debug, Reflect)]
pub enum GladosTtsPingEvent {
    Ping,
    Pong { status: GladosTtsStatus },
}

#[derive(Event, Debug, Reflect)]
pub enum GladosTtsStatusEvent {
    Changed { new_value: GladosTtsStatus },
    Startup,
}

````



## D:\Repos\Games\Cursor-Hero\crates\agent\src\agent_movement_plugin.rs

````rust
use bevy::prelude::*;
use bevy_xpbd_2d::components::AngularVelocity;
use bevy_xpbd_2d::components::Rotation;
use cursor_hero_agent_types::prelude::*;
use cursor_hero_character_types::prelude::*;
use cursor_hero_movement_tool_types::prelude::*;
use cursor_hero_toolbelt_types::prelude::*;
use leafwing_input_manager::axislike::DualAxisData;
use leafwing_input_manager::prelude::*;

pub struct AgentMovementPlugin;

impl Plugin for AgentMovementPlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(Update, agent_tool_movement);
        app.add_systems(Update, keep_upright);
    }
}

#[allow(clippy::type_complexity)]
fn agent_tool_movement(
    character_query: Query<(&Children, &Transform), (With<Character>, With<Agent>)>,
    toolbelt_query: Query<&Children, With<Toolbelt>>,
    mut tool_query: Query<&mut ActionState<MovementToolAction>>,
    time: Res<Time>,
) {
    for character in character_query.iter() {
        let (character_children, character_transform) = character;
        for character_child_id in character_children.iter() {
            let Ok(toolbelt) = toolbelt_query.get(*character_child_id) else {
                continue;
            };
            let toolbelt_children = toolbelt;
            for tool in toolbelt_children.iter() {
                let Ok(mut tool) = tool_query.get_mut(*tool) else {
                    continue;
                };
                let data = tool.action_data_mut(MovementToolAction::Move);
                let center = Vec2::new(1920.0, -1080.0) / 2.0;
                // walk in a circle around the center
                let desired_position = center + Vec2::from_angle(time.elapsed_seconds()) * 100.0;
                let direction = desired_position - character_transform.translation.xy();
                data.axis_pair = Some(DualAxisData::from_xy(direction.clamp_length_max(1.0)));
                tool.press(MovementToolAction::Move);
            }
        }
    }
}

#[allow(clippy::type_complexity)]
fn keep_upright(
    mut character_query: Query<(&Rotation, &mut AngularVelocity), (With<Character>, With<Agent>)>,
) {
    for (rotation, mut angular_velocity) in character_query.iter_mut() {
        *angular_velocity = AngularVelocity(rotation.sin() * -1.0);
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\host_event_types\src\host_event_types.rs

````rust
use bevy::prelude::*;

#[derive(Event, Debug, Reflect, Eq, PartialEq)]
pub enum HostEvent {
    MousePhysicallyMoved,
}

````



## D:\Repos\Games\Cursor-Hero\crates\taskbar\src\lib.rs

````rust
pub mod taskbar_plugin;
pub mod taskbar_spawn_plugin;

````



## D:\Repos\Games\Cursor-Hero\crates\taskbar_tool\src\lib.rs

````rust
pub mod taskbar_tool_plugin;
pub mod taskbar_wheel_tool;

pub mod prelude {
    pub use crate::taskbar_tool_plugin::*;
}

````



## D:\Repos\Games\Cursor-Hero\crates\brick_types\src\brick_types.rs

````rust
use bevy::prelude::*;

#[derive(Component, Debug, Reflect)]
pub struct Brick;

````



## D:\Repos\Games\Cursor-Hero\crates\input\src\update_gamepad_settings.rs

````rust
use bevy::input::gamepad::ButtonSettings;
use bevy::input::gamepad::GamepadConnectionEvent;
use bevy::input::gamepad::GamepadSettings;
use bevy::prelude::*;

pub const PRESS_THRESHOLD: f32 = 0.1;
pub const RELEASE_THRESHOLD: f32 = 0.08;

/// Responsible for updating the trigger thresholds for Mining Laser
/// https://github.com/Leafwing-Studios/leafwing-input-manager/issues/405
pub fn update_gamepad_settings(
    mut gamepad_events: EventReader<GamepadConnectionEvent>,
    mut gamepad_settings: ResMut<GamepadSettings>,
) {
    gamepad_events.read().for_each(|event| {
        info!("Updating Gamepad Settings");

        gamepad_settings.button_settings.insert(
            GamepadButton {
                gamepad: event.gamepad,
                button_type: GamepadButtonType::RightTrigger2,
            },
            ButtonSettings::new(PRESS_THRESHOLD, RELEASE_THRESHOLD).unwrap(), //Ok because this would be programmer error
        );

        gamepad_settings.button_settings.insert(
            GamepadButton {
                gamepad: event.gamepad,
                button_type: GamepadButtonType::LeftTrigger2,
            },
            ButtonSettings::new(PRESS_THRESHOLD, RELEASE_THRESHOLD).unwrap(), //Ok because this would be programmer error
        );
    });
}

````



## D:\Repos\Games\Cursor-Hero\crates\pointer_types\src\pointer_reach_types.rs

````rust
use bevy::prelude::*;

#[derive(Event, Debug, Reflect)]
pub enum PointerReachEvent {
    SetPointer { pointer_id: Entity, reach: f32 },
    SetPointerPercent { pointer_id: Entity, percent: f32 },
    SetCharacter { character_id: Entity, reach: f32 },
    SetCharacterPercent { character_id: Entity, percent: f32 },
    ResetPointer { pointer_id: Entity },
    ResetCharacter { character_id: Entity },
}

````



## D:\Repos\Games\Cursor-Hero\crates\pointer_types\src\pointer_types_plugin.rs

````rust
use bevy::prelude::*;

use crate::prelude::*;

pub struct PointerTypesPlugin;
impl Plugin for PointerTypesPlugin {
    fn build(&self, app: &mut App) {
        app.register_type::<Pointer>();
        app.register_type::<MainPointer>();
        app.configure_sets(Update, PointerSystemSet::Position);

        app.add_event::<PointerReachEvent>();

        app.register_type::<Hovered>();
        app.register_type::<Hoverable>();
        app.register_type::<Hovering>();
        app.add_event::<HoverEvent>();

        app.register_type::<Clickable>();
        app.register_type::<Pressed>();
        app.register_type::<Pressing>();
        app.add_event::<ClickEvent>();
        app.add_event::<ToolClickEvent>();
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\voice_to_text\src\voice_to_text_plugin.rs

````rust
use bevy::prelude::*;
use cursor_hero_voice_to_text_types::voice_to_text_types::VoiceToTextStatus;

use crate::voice_to_text_button_plugin::VoiceToTextButtonPlugin;
use crate::voice_to_text_ping_plugin::VoiceToTextPingPlugin;
use crate::voice_to_text_worker_plugin::VoiceToTextWorkerPlugin;

pub struct VoiceToTextPlugin;

impl Plugin for VoiceToTextPlugin {
    fn build(&self, app: &mut App) {
        app.init_resource::<VoiceToTextStatus>();
        app.add_plugins(VoiceToTextButtonPlugin);
        app.add_plugins(VoiceToTextPingPlugin);
        app.add_plugins(VoiceToTextWorkerPlugin);
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\brick\src\lib.rs

````rust
pub mod brick_plugin;

pub mod prelude {
    pub use crate::brick_plugin::*;
}

````



## D:\Repos\Games\Cursor-Hero\crates\start_menu_types\src\lib.rs

````rust
pub mod start_menu_types;
pub mod start_menu_types_plugin;

pub mod prelude {
    pub use crate::start_menu_types::*;
    pub use crate::start_menu_types_plugin::*;
}

````



## D:\Repos\Games\Cursor-Hero\crates\version\src\version_plugin.rs

````rust
use bevy::prelude::*;

pub struct VersionPlugin(pub String);

impl Plugin for VersionPlugin {
    fn build(&self, app: &mut App) {
        app.insert_resource(Version(self.0.clone()));
    }
}

#[derive(Resource, Reflect, Default)]
#[reflect(Resource)]
pub struct Version(pub String);

````



## D:\Repos\Games\Cursor-Hero\crates\physics\src\damping_plugin.rs

````rust
use bevy::prelude::*;
use bevy_xpbd_2d::math::*;
use bevy_xpbd_2d::prelude::*;

pub struct DampingPlugin;

#[derive(SystemSet, Clone, Hash, Debug, PartialEq, Eq)]
pub enum DampingSystemSet {
    Dampen,
}

impl Plugin for DampingPlugin {
    fn build(&self, app: &mut App) {
        app.register_type::<MovementDamping>();
        app.configure_sets(Update, DampingSystemSet::Dampen);
        app.add_systems(
            Update,
            apply_movement_damping.in_set(DampingSystemSet::Dampen),
        );
    }
}

#[derive(Component, Reflect, Debug)]
pub struct MovementDamping {
    pub factor: Scalar,
}

impl Default for MovementDamping {
    fn default() -> Self {
        Self { factor: 0.95 }
    }
}

#[allow(clippy::type_complexity)]
fn apply_movement_damping(
    mut query: Query<
        (&MovementDamping, &mut LinearVelocity, &mut AngularVelocity),
        Without<Sleeping>,
    >,
    time: Res<Time<Physics>>,
) {
    if time.is_paused() {
        return;
    }
    for (damping, mut linear_velocity, mut angular_velocity) in &mut query {
        linear_velocity.x *= damping.factor;
        if linear_velocity.x.abs() < 10.0 {
            linear_velocity.x = 0.0;
        }
        linear_velocity.y *= damping.factor;
        if linear_velocity.y.abs() < 10.0 {
            linear_velocity.y = 0.0;
        }
        angular_velocity.0 *= damping.factor;
        if angular_velocity.0.abs() < 10.0 {
            angular_velocity.0 = 0.0;
        }
        // if linear_velocity.x != 0.0 && linear_velocity.y != 0.0 {
        //     debug!("linear_velocity: {:?}", linear_velocity);
        // }
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\screen\src\screen_update_plugin.rs

````rust
use std::sync::Arc;
use std::sync::Mutex;
use std::thread;

use crate::screen_plugin::Screen;
use bevy::prelude::*;
use bevy::utils::HashMap;
use bevy::window::PrimaryWindow;
use bevy::winit::WinitWindows;
use cursor_hero_metrics::Metrics;
use cursor_hero_winutils::win_screen_capture::get_full_monitor_capturers;
use cursor_hero_winutils::win_screen_capture::MonitorRegionCapturer;

pub struct CapturerHolderResource {
    pub capturers: Vec<MonitorRegionCapturer>,
}

// Define a struct to hold captured frames
struct CapturedFrame {
    data: Vec<u8>,
}

// Shared resource for captured frames
#[derive(Resource)]
struct FrameHolderResource {
    frames: Arc<Mutex<HashMap<u32, CapturedFrame>>>,
    enabled: Arc<Mutex<bool>>,
}

pub struct ScreenUpdatePlugin;

impl Plugin for ScreenUpdatePlugin {
    fn build(&self, app: &mut App) {
        // Create a shared resource for captured frames
        let frames = Arc::new(Mutex::new(HashMap::new()));

        // Clone the Arc to move into the capture thread
        let frames_pointer = Arc::clone(&frames);

        let capturer_holder = Arc::new(Mutex::new(CapturerHolderResource {
            capturers: get_full_monitor_capturers().unwrap(),
        }));

        let enabled = Arc::new(Mutex::new(true));
        let enabled_pointer = Arc::clone(&enabled);

        let captured_frames = FrameHolderResource { frames, enabled };

        // Spawn a separate thread for capturing frames
        let ch = Arc::clone(&capturer_holder);
        thread::spawn(move || loop {
            if !*enabled_pointer.lock().unwrap() {
                thread::sleep(std::time::Duration::from_millis(100));
                continue;
            }
            let frames = capture_frames(ch.clone());
            let mut shared_frames = frames_pointer.lock().unwrap();
            *shared_frames = frames;
        });

        app.add_systems(Update, update_screens)
            .insert_resource(captured_frames)
            .insert_non_send_resource(CapturerHolderResource {
                capturers: get_full_monitor_capturers().unwrap(),
            });
    }
}

fn capture_frames(capturers: Arc<Mutex<CapturerHolderResource>>) -> HashMap<u32, CapturedFrame> {
    capturers
        .lock()
        .unwrap()
        .capturers
        .iter_mut()
        .map(|capturer| {
            // let mut metrics = Metrics::default();
            // let frame = capturer.capture(&mut Some(metrics)).unwrap();
            let frame = capturer.capture(&mut None).unwrap();
            let frame = CapturedFrame {
                data: frame.to_vec(),
            };
            (capturer.monitor.info.id, frame)
        })
        .collect::<HashMap<u32, CapturedFrame>>()
}

fn update_screens(
    mut query: Query<(&mut Screen, &Handle<Image>)>,
    mut textures: ResMut<Assets<Image>>,
    time: Res<Time>,
    frames: Res<FrameHolderResource>,
    window_query: Query<Entity, With<PrimaryWindow>>,
    winit_windows: NonSend<WinitWindows>,
) {
    let window_id = window_query.single();
    let Some(winit_window) = winit_windows.get_window(window_id) else {
        error!("Window not found");
        return;
    };
    if winit_window.is_minimized().unwrap_or(false) {
        *frames.enabled.lock().unwrap() = false;
        return;
    } else {
        *frames.enabled.lock().unwrap() = true;
    }

    let monitor_frames = frames.frames.lock().unwrap();
    for (mut screen, texture) in &mut query {
        if let Some(refresh_rate) = screen.refresh_rate.as_mut() {
            // tick the refresh rate timer
            refresh_rate.tick(time.delta());
            // skip if not time to refresh
            if !refresh_rate.finished() {
                continue;
            }
        } else {
            // skip if no refresh rate
            continue;
        }

        // find the frame captured in the other thread
        let mut metrics = Metrics::default();
        metrics.begin("lookup");
        let frame = monitor_frames.get(&screen.id).unwrap();
        metrics.end("lookup");

        // update the texture
        metrics.begin("texture");
        textures.get_mut(texture).unwrap().data = frame.data.clone();
        metrics.end("texture");

        // report metrics
        // println!("{}", metrics.report());
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\taskbar\src\taskbar_spawn_plugin.rs

````rust
use bevy::prelude::*;
use bevy::sprite::MaterialMesh2dBundle;
use cursor_hero_screen::screen_plugin::GameScreen;
use cursor_hero_taskbar_types::prelude::*;
use cursor_hero_winutils::win_colors::get_start_color;

pub struct TaskbarSpawnPlugin;

impl Plugin for TaskbarSpawnPlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(Update, spawn_taskbar);
        app.add_systems(Update, populate_taskbar);
    }
}

fn spawn_taskbar(
    mut commands: Commands,
    screen_query: Query<(Entity, &Sprite), Added<GameScreen>>,
    mut materials: ResMut<Assets<TaskbarMaterial>>,
    mut meshes: ResMut<Assets<Mesh>>,
    asset_server: Res<AssetServer>,
) {
    for screen in screen_query.iter() {
        let (screen_id, screen_sprite) = screen;
        let Some(screen_size) = screen_sprite.custom_size else {
            warn!("Screen {:?} has no custom size", screen_id);
            continue;
        };
        // let taskbar_size = Vec3::new(screen_size.x, 40.0, 1.0);
        let taskbar_size = Vec3::new(screen_size.x, 40.0, 1.0);
        let taskbar_translation = Vec3::new(0.0, -screen_size.y / 2.0 + taskbar_size.y / 2.0, 5.0);

        let taskbar_color = match get_start_color() {
            Ok(color) => color,
            Err(err) => {
                warn!("Couldn't get accent color: {:?}", err);
                Color::rgba(0.0, 0.0, 0.0, 1.0)
            }
        };
        // color *= Vec3::new(1.0 / 2.5, 2.0, 0.5);
        // color.set_a(0.9);
        // let taskbar_blur_radius = 5;
        // let taskbar_blur_total_samples = ((taskbar_blur_radius * 2 + 1) * (taskbar_blur_radius * 2 + 1));
        commands.entity(screen_id).with_children(|parent| {
            parent.spawn((
                Taskbar {
                    size: taskbar_size.xy(),
                },
                Name::new("Taskbar"),
                // SpriteBundle {
                //     sprite: Sprite {
                //         custom_size: Some(taskbar_size.xy()),
                //         color,
                //         ..default()
                //     },
                //     transform: Transform::from_translation(taskbar_translation),
                //     ..default()
                // },
                MaterialMesh2dBundle {
                    mesh: meshes.add(Mesh::from(shape::Cube::default())).into(),
                    transform: Transform::from_translation(taskbar_translation)
                        .with_scale(taskbar_size),
                    material: materials.add(TaskbarMaterial {
                        // taskbar_blur_radius,
                        // taskbar_blur_total_samples,
                        taskbar_height: taskbar_size.y,
                        taskbar_color,
                        wallpaper_size: screen_size.xy(),
                        wallpaper_texture: Some(
                            asset_server.load("textures/environment/game/wallpaper.png"),
                        ),
                        alpha_mode: AlphaMode::Opaque,
                    }),
                    ..default()
                },
            ));
        });
    }
}

fn populate_taskbar(
    taskbar_query: Query<Entity, Added<Taskbar>>,
    mut taskbar_events: EventWriter<TaskbarEvent>,
) {
    for taskbar_id in taskbar_query.iter() {
        let event = TaskbarEvent::Populate { taskbar_id };
        debug!("Sending taskbar event: {:?}", event);
        taskbar_events.send(event);
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\chat\src\chat_focus_exclusivity_plugin.rs

````rust
use bevy::prelude::*;
use cursor_hero_chat_types::prelude::*;
use cursor_hero_toolbelt_types::prelude::*;

pub struct ChatFocusExclusivityPlugin;

impl Plugin for ChatFocusExclusivityPlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(Update, handle_focus_changed);
    }
}

fn handle_focus_changed(
    mut commands: Commands,
    mut events: EventReader<ChatInputEvent>,
    mut tool_query: Query<&mut ChatTool, With<ChatTool>>,
    toolbelt_query: Query<&Children, With<Toolbelt>>,
    active_tool_query: Query<(), (With<ActiveTool>, Without<ChatTool>)>,
) {
    for event in events.read() {
        let (ChatInputEvent::Focus {
            tool_id,
            toolbelt_id,
            ..
        }
        | ChatInputEvent::Unfocus {
            tool_id,
            toolbelt_id,
            ..
        }) = event
        else {
            continue;
        };
        let focusing = matches!(event, ChatInputEvent::Focus { .. });

        let Ok(tool) = tool_query.get_mut(*tool_id) else {
            warn!("Tool {:?} not found for event {:?}", tool_id, event);
            continue;
        };
        let mut tool = tool;

        let Ok(toolbelt) = toolbelt_query.get(*toolbelt_id) else {
            warn!("Toolbelt {:?} not found for event {:?}", toolbelt_id, event);
            continue;
        };
        let toolbelt_children = toolbelt;
        if focusing {
            tool.focused = true;
            for tool_id in toolbelt_children.iter() {
                if active_tool_query.contains(*tool_id) {
                    tool.tools_disabled_during_focus.insert(*tool_id);
                    commands.entity(*tool_id).remove::<ActiveTool>();
                    debug!("Disabled tool {:?} while focused", tool_id);
                }
            }
            debug!("Set tool {:?} as focused", tool_id);
        } else {
            tool.focused = false;
            for tool_id in tool.tools_disabled_during_focus.iter() {
                match commands.get_entity(*tool_id) {
                    Some(mut entity) => {
                        entity.insert(ActiveTool);
                    }
                    None => {
                        warn!("Error re-enabling tool {:?}, does not exist", tool_id);
                    }
                }
                debug!("Re-enabled tool {:?} after unfocusing", tool_id);
            }
            tool.tools_disabled_during_focus.clear();
            debug!("Set tool {:?} as unfocused", tool_id);
        }
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\window_swap_tool\src\window_swap_tool_plugin.rs

````rust
use crate::window_swap_tool_populate_plugin::WindowSwapToolPopulatePlugin;
use bevy::prelude::*;

pub struct WindowSwapToolPlugin;

impl Plugin for WindowSwapToolPlugin {
    fn build(&self, app: &mut App) {
        app.add_plugins(WindowSwapToolPopulatePlugin);
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\metrics\src\lib.rs

````rust
use indexmap::IndexMap;
use std::time::Duration;
use std::time::Instant;

#[derive(Debug, Clone)]
pub struct Metric {
    pub name: String,
    pub duration: Duration,
}

#[derive(Default, Debug)]
pub struct Metrics {
    ongoing: IndexMap<String, Instant>,
    completed: IndexMap<String, Duration>,
}

impl Metrics {
    pub fn begin(&mut self, name: &str) {
        self.ongoing.insert(name.to_string(), Instant::now());
    }

    pub fn end(&mut self, name: &str) {
        if let Some(start_time) = self.ongoing.remove(name) {
            let duration = start_time.elapsed();
            self.completed.insert(name.to_string(), duration);
        }
    }

    #[allow(dead_code)]
    pub fn report(&self) -> String {
        format!(
            "{} | total {:?}",
            self.completed
                .iter()
                .map(|(name, duration)| format!("{} {:?}", name, duration))
                .collect::<Vec<_>>()
                .join(" | "),
            &self.total()
        )
    }

    pub fn total(&self) -> Duration {
        self.completed.values().sum()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_metrics_tracking() {
        let mut metrics = Metrics::default();

        metrics.begin("z first");
        std::thread::sleep(Duration::from_millis(10));
        metrics.end("z first");

        metrics.begin("a second");
        std::thread::sleep(Duration::from_millis(20));
        metrics.end("a second");

        let report = metrics.report();
        println!("{}", report);
        assert!(report.contains("z first"));
        assert!(report.contains("a second"));
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\winutils\src\win_icons.rs

````rust
use crate::win_errors::*;
use bevy::prelude::default;
use cursor_hero_math::prelude::bgra_to_rgba;
use image::ImageBuffer;
use image::RgbaImage;
use itertools::Itertools;
use widestring::U16CString;
use windows::core::PCWSTR;
use windows::Win32::Graphics::Gdi::CreateCompatibleDC;
use windows::Win32::Graphics::Gdi::DeleteDC;
use windows::Win32::Graphics::Gdi::DeleteObject;
use windows::Win32::Graphics::Gdi::GetDIBits;
use windows::Win32::Graphics::Gdi::SelectObject;
use windows::Win32::Graphics::Gdi::BITMAPINFO;
use windows::Win32::Graphics::Gdi::BITMAPINFOHEADER;
use windows::Win32::Graphics::Gdi::DIB_RGB_COLORS;
use windows::Win32::UI::Shell::ExtractIconExW;
use windows::Win32::UI::WindowsAndMessaging::CopyIcon;
use windows::Win32::UI::WindowsAndMessaging::DestroyIcon;
use windows::Win32::UI::WindowsAndMessaging::GetIconInfoExW;
use windows::Win32::UI::WindowsAndMessaging::HCURSOR;
use windows::Win32::UI::WindowsAndMessaging::HICON;
use windows::Win32::UI::WindowsAndMessaging::ICONINFOEXW;

pub fn get_images_from_exe(executable_path: &str) -> Result<Vec<RgbaImage>> {
    unsafe {
        let path_cstr = U16CString::from_str(executable_path)?;
        let path_pcwstr = PCWSTR(path_cstr.as_ptr());
        let num_icons_total = ExtractIconExW(path_pcwstr, -1, None, None, 0);
        if num_icons_total == 0 {
            return Ok(Vec::new()); // No icons extracted
        }

        let mut large_icons = vec![HICON::default(); num_icons_total as usize];
        let mut small_icons = vec![HICON::default(); num_icons_total as usize];
        let num_icons_fetched = ExtractIconExW(
            path_pcwstr,
            0,
            Some(large_icons.as_mut_ptr()),
            Some(small_icons.as_mut_ptr()),
            num_icons_total,
        );

        if num_icons_fetched == 0 {
            return Ok(Vec::new()); // No icons extracted
        }

        let images = large_icons
            .iter()
            .chain(small_icons.iter())
            .map(convert_hicon_to_rgba_image)
            .filter_map(|r| match r {
                Ok(img) => Some(img),
                Err(e) => {
                    eprintln!("Failed to convert HICON to RgbaImage: {:?}", e);
                    None
                }
            })
            .collect_vec();

        large_icons
            .iter()
            .chain(small_icons.iter())
            .filter(|icon| !icon.is_invalid())
            .map(|icon| DestroyIcon(*icon))
            .filter_map(|r| r.err())
            .for_each(|e| eprintln!("Failed to destroy icon: {:?}", e));

        Ok(images)
    }
}

pub fn convert_hicon_to_rgba_image(hicon: &HICON) -> Result<RgbaImage> {
    unsafe {
        let mut icon_info = ICONINFOEXW {
            cbSize: std::mem::size_of::<ICONINFOEXW>() as u32,
            ..default()
        };

        if !GetIconInfoExW(*hicon, &mut icon_info).as_bool() {
            return Err(Error::from_win32().with_description(format!(
                "icon  GetIconInfoExW: {} {}:{}",
                file!(),
                line!(),
                column!()
            )));
        }
        let hdc_screen = CreateCompatibleDC(None);
        let hdc_mem = CreateCompatibleDC(hdc_screen);
        let hbm_old = SelectObject(hdc_mem, icon_info.hbmColor);

        let mut bmp_info = BITMAPINFO {
            bmiHeader: BITMAPINFOHEADER {
                biSize: std::mem::size_of::<BITMAPINFOHEADER>() as u32,
                biWidth: icon_info.xHotspot as i32 * 2,
                biHeight: -(icon_info.yHotspot as i32 * 2),
                biPlanes: 1,
                biBitCount: 32,
                biCompression: DIB_RGB_COLORS.0,
                ..Default::default()
            },
            ..Default::default()
        };

        let mut buffer: Vec<u8> =
            vec![0; (icon_info.xHotspot * 2 * icon_info.yHotspot * 2 * 4) as usize];

        if GetDIBits(
            hdc_mem,
            icon_info.hbmColor,
            0,
            icon_info.yHotspot * 2,
            Some(buffer.as_mut_ptr() as *mut _),
            &mut bmp_info,
            DIB_RGB_COLORS,
        ) == 0
        {
            return Err(Error::from_win32().with_description(format!(
                "GetDIBits: {} {}:{}",
                file!(),
                line!(),
                column!()
            )));
        }
        // Clean up
        SelectObject(hdc_mem, hbm_old);
        DeleteDC(hdc_mem);
        DeleteDC(hdc_screen);
        DeleteObject(icon_info.hbmColor);
        DeleteObject(icon_info.hbmMask);

        bgra_to_rgba(buffer.as_mut_slice());

        let image = ImageBuffer::from_raw(icon_info.xHotspot * 2, icon_info.yHotspot * 2, buffer)
            .ok_or_else(|| Error::ImageContainerNotBigEnough)?;
        Ok(image)
    }
}


pub fn convert_hcursor_to_rgba_image(hcursor: &HCURSOR) -> Result<RgbaImage> {
    unsafe {
        // Convert HCURSOR to HICON
        let hicon = CopyIcon(*hcursor)?;

        // Use the existing convert_hicon_to_rgba_image function
        let image = convert_hicon_to_rgba_image(&hicon)?;

        // Destroy the HICON (since it was copied)
        DestroyIcon(hicon)?;

        Ok(image)
    }
}

#[cfg(test)]
mod tests {
    use bevy::math::IVec4;
    use std::path::PathBuf;

    #[test]
    fn test_convert_hicon_to_rgba_image() {
        let exe_path = r"C:\Program Files (x86)\Microsoft\Edge\Application\msedge.exe";
        let icons = super::get_images_from_exe(exe_path).unwrap();

        // Ensure the expected amount is present
        assert_eq!(icons.len(), 30);

        // Save icons
        let mut path = PathBuf::from("target/app_icons");
        path.push("msedge.exe");
        std::fs::create_dir_all(&path).unwrap();
        for (i, icon) in icons.iter().enumerate() {
            let mut icon_path = path.clone();
            icon_path.push(format!("{}.png", i));
            icon.save(icon_path).unwrap();
        }

        // Assert all icons are more than just transparent images
        // Also count rgb totals
        let mut passed = vec![false; icons.len()];
        for (i, icon) in icons.iter().enumerate() {
            let mut rgb_count = IVec4::ZERO;
            for pixel in icon.pixels() {
                let pixel = IVec4::new(
                    pixel[0] as i32,
                    pixel[1] as i32,
                    pixel[2] as i32,
                    pixel[3] as i32,
                );
                rgb_count += pixel;
            }
            if rgb_count != IVec4::ZERO {
                passed[i] = true;
            }
        }
        println!("{:?}", passed);
        assert!(passed.iter().all(|&x| x));
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\glados_tts_types\src\lib.rs

````rust
pub mod glados_tts_types;
pub mod glados_tts_types_plugin;

pub mod prelude {
    pub use crate::glados_tts_types::*;
    pub use crate::glados_tts_types_plugin::*;
}

````



## D:\Repos\Games\Cursor-Hero\crates\calculator_app_types\src\calculator_app_types.rs

````rust
use bevy::prelude::*;

#[derive(Component, Debug, Reflect)]
pub struct AppWindow;

````



## D:\Repos\Games\Cursor-Hero\crates\pointer\src\pointer_click_plugin.rs

````rust
use bevy::prelude::*;
use bevy::utils::HashMap;
use bevy::utils::HashSet;
use bevy_xpbd_2d::components::CollidingEntities;
use cursor_hero_pointer_types::prelude::*;

pub struct PointerClickPlugin;

impl Plugin for PointerClickPlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(Update, press_detection);
        app.add_systems(Update, release_detection);
    }
}

#[allow(clippy::type_complexity)]
pub fn press_detection(
    mut commands: Commands,
    mut tool_click_events: EventReader<ToolClickEvent>,
    mut click_events: EventWriter<ClickEvent>,
    mut pointer_query: Query<(&CollidingEntities, Option<&mut Pressing>), With<Pointer>>,
    mut target_query: Query<(Entity, &Visibility, Option<&mut Pressed>), With<Clickable>>,
) {
    let mut pointer_target_ways: Vec<(Entity, Entity, Way)> = vec![];
    let mut target_pointer_ways: Vec<(Entity, Entity, Way)> = vec![];
    for tool_click_event in tool_click_events.read() {
        // only check pressed events
        let ToolClickEvent::Pressed { pointer_id, way } = tool_click_event else {
            continue;
        };

        // find the pointer for the event
        let Ok((pointer_touching, pointer_pressing)) = pointer_query.get_mut(*pointer_id) else {
            warn!("Pointer {:?} not found", pointer_id);
            continue;
        };

        let mut pressed = vec![];

        // for each element the pointer is touching
        for touching_id in pointer_touching.iter() {
            // debug!("Pointer {:?} touching {:?}", pointer_id, touching_id);
            // ensure it is a clickable element
            let Ok((target_id, target_visible, target_pressed)) =
                target_query.get_mut(*touching_id)
            else {
                // debug!("Target {:?} not valid", touching_id);
                continue;
            };
            // ensure the element is visible
            if target_visible == Visibility::Hidden {
                continue;
            }

            // track in the element what is pressing it
            if target_pressed.is_none() {
                // nothing is pressing this element yet
                target_pointer_ways.push((*touching_id, *pointer_id, *way));
            } else if let Some(mut target_pressed) = target_pressed {
                // something is already pressing this element
                if target_pressed
                    .presses
                    .iter()
                    .any(|press| press.pointer_id == *pointer_id && press.way == *way)
                {
                    warn!("Pointer {:?} already pressing {:?}", pointer_id, target_id);
                } else {
                    target_pressed.presses.push(PointerPress {
                        pointer_id: *pointer_id,
                        way: *way,
                    });
                }
            }

            // send pressed event
            click_events.send(ClickEvent::Pressed {
                target_id,
                pointer_id: *pointer_id,
                way: *way,
            });

            pressed.push(target_id);
        }

        match pointer_pressing {
            Some(mut pointer_pressing) => {
                for target_id in pressed.into_iter() {
                    if pointer_pressing
                        .pressing
                        .iter()
                        .any(|p| p.target_id == target_id && p.way == *way)
                    {
                        warn!("Pointer {:?} already pressing {:?}", pointer_id, target_id);
                    } else {
                        pointer_pressing.pressing.push(TargetPress {
                            target_id,
                            way: *way,
                        });
                    }
                }
            }
            None => {
                for target_id in pressed.into_iter() {
                    pointer_target_ways.push((*pointer_id, target_id, *way));
                }
            }
        }
    }

    // We have deferred the insertion of the Pressed and Pressing components
    // This is because doing it in the event loop causes clobbering when simultaneous events occur
    let pointer_target_ways = group_by_entity(pointer_target_ways);
    for (pointer_id, target_presses) in pointer_target_ways {
        commands.entity(pointer_id).insert(Pressing {
            pressing: target_presses
                .into_iter()
                .map(|(target_id, way)| TargetPress { target_id, way })
                .collect(),
        });
    }
    let target_pointer_ways = group_by_entity(target_pointer_ways);
    for (target_id, pointer_presses) in target_pointer_ways {
        commands.entity(target_id).insert(Pressed {
            presses: pointer_presses
                .into_iter()
                .map(|(pointer_id, way)| PointerPress { pointer_id, way })
                .collect(),
        });
    }
}

fn group_by_entity(ways: Vec<(Entity, Entity, Way)>) -> HashMap<Entity, Vec<(Entity, Way)>> {
    let mut groups: HashMap<Entity, Vec<(Entity, Way)>> = HashMap::new();

    for (pointer, target, way) in ways {
        groups
            .entry(pointer)
            .or_insert_with(Vec::new)
            .push((target, way));
    }

    groups
}

#[allow(clippy::type_complexity)]
fn release_detection(
    mut commands: Commands,
    mut tool_click_events: EventReader<ToolClickEvent>,
    mut click_events: EventWriter<ClickEvent>,
    mut pointer_query: Query<(&CollidingEntities, Option<&mut Pressing>), With<Pointer>>,
    mut target_query: Query<(Entity, &Visibility, Option<&mut Pressed>), With<Clickable>>,
) {
    for tool_click_event in tool_click_events.read() {
        // only check released events
        let ToolClickEvent::Released { pointer_id, way } = tool_click_event else {
            continue;
        };

        // find the pointer for the event
        let Ok((pointer_touching, pointer_pressing)) = pointer_query.get_mut(*pointer_id) else {
            warn!("Pointer {:?} not found", pointer_id);
            continue;
        };

        // each element the pointer has tracked as pressing now needs to be released
        // if the pointer is still touching that element, also send a click event

        // for each element the pointer is touching
        let mut clicked: Vec<Entity> = vec![];
        for touching_id in pointer_touching.iter() {
            // ensure it is a clickable element
            let Ok((target_id, target_visible, target_pressed)) =
                target_query.get_mut(*touching_id)
            else {
                continue;
            };
            // ensure the element is visible
            if target_visible == Visibility::Hidden {
                continue;
            }

            // update the tracker in the target
            if let Some(mut pressed) = target_pressed {
                if let Some(press_index) = pressed
                    .presses
                    .iter()
                    .position(|press| press.pointer_id == *pointer_id && press.way == *way)
                {
                    if pressed.presses.len() == 1 {
                        // this is the last press, remove the tracker
                        commands.entity(target_id).remove::<Pressed>();
                    } else {
                        // remove the press from the tracker
                        pressed.presses.remove(press_index);
                    }
                } else {
                    warn!("Pointer {:?} not pressing {:?}", pointer_id, target_id);
                }
            } else {
                warn!(
                    "Target {:?} didn't know it was pressed by pointer {:?}. Did you press elsewhere and release here?",
                    target_id, pointer_id
                );
            }

            clicked.push(target_id);
        }

        match pointer_pressing {
            Some(mut pressing) => {
                // send release events
                let mut remove = HashSet::new();
                pressing
                    .pressing
                    .iter()
                    .filter(|press| press.way == *way)
                    .for_each(|press: &TargetPress| {
                        click_events.send(ClickEvent::Released {
                            target_id: press.target_id,
                            pointer_id: *pointer_id,
                            way: *way,
                        });
                        remove.insert(*press);
                    });
                pressing.pressing.retain(|press| !remove.contains(press));
                if pressing.pressing.is_empty() {
                    commands.entity(*pointer_id).remove::<Pressing>();
                }
                // ensure all clicked are present in remove
                for target_id in clicked.iter() {
                    if !remove.contains(&TargetPress {
                        target_id: *target_id,
                        way: *way,
                    }) {
                        warn!(
                            "Pointer {:?} didn't know it was clicking {:?}",
                            pointer_id, target_id
                        );
                    } else {
                        click_events.send(ClickEvent::Clicked {
                            target_id: *target_id,
                            pointer_id: *pointer_id,
                            way: *way,
                        });
                    }
                }
            }
            None => {
                debug!("Pointer {:?} wasn't pressing anything", pointer_id);
            }
        }
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\text_asset\src\text_asset_plugin.rs

````rust
use bevy::prelude::*;
use cursor_hero_text_asset_types::prelude::*;
pub struct TextAssetPlugin;

impl Plugin for TextAssetPlugin {
    fn build(&self, app: &mut App) {
        app.init_asset::<TextAsset>();
        app.init_asset_loader::<TextAssetLoader>();
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\ui_automation_types\src\calculator_ui_types.rs

````rust
use bevy::prelude::*;
use serde::{Deserialize, Serialize};

#[derive(Component, Debug, Reflect, Default, Clone, Serialize, Deserialize, PartialEq)]
pub struct Calculator {
    pub memory: CalculatorMemory,
}
impl std::fmt::Display for Calculator {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "Calculator (value={})", self.memory.buffer)
    }
}

#[derive(Component, Debug, Reflect, Default)]
pub struct NumberDisplayPanel;

#[derive(Component, Debug, Reflect, Default)]
pub struct DigitInputButton(u8);

#[derive(Component, Debug, Reflect, Default)]
pub struct EqualsButton;

#[derive(Component, Debug, Reflect, Default)]
pub struct PlusButton;

#[derive(Component, Debug, Reflect, Default, Clone, Serialize, Deserialize, PartialEq)]
pub struct CalculatorMemory {
    pub buffer: f64,
}

#[derive(Event, Debug, Reflect, Default)]
pub struct SpawnCalculatorRequest {
    calculator: Calculator,
}
#[derive(Event, Debug, Reflect)]
pub struct CalculatorRequestDefaultPositioningRequest {
    calculator: Entity,
}

````



## D:\Repos\Games\Cursor-Hero\crates\winutils\src\lib.rs

````rust
#![feature(let_chains)]

use bevy::math::IRect;

pub mod win_colors;
pub mod win_errors;
pub mod win_events;
pub mod win_icons;
pub mod win_keyboard;
pub mod win_mouse;
pub mod win_process;
pub mod win_screen_capture;
pub mod win_wallpaper;
pub mod win_window;
pub mod win_cursor;

pub trait ToBevyIRect {
    fn to_bevy_irect(&self) -> IRect;
}

pub use widestring;

````



## D:\Repos\Games\Cursor-Hero\crates\calculator_app\src\lib.rs

````rust
pub mod calculator_app_plugin;

pub mod prelude {
    pub use crate::calculator_app_plugin::*;
}

````



## D:\Repos\Games\Cursor-Hero\crates\chat\src\chat_sfx_plugin.rs

````rust
use bevy::prelude::*;
use cursor_hero_character_types::prelude::*;
use cursor_hero_chat_types::prelude::*;
use rand::prelude::SliceRandom;
pub struct ChatSfxPlugin;

impl Plugin for ChatSfxPlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(Update, play_sound_for_new_chat_messages);
        app.add_systems(Update, play_sound_for_keystrokes);
    }
}
fn play_sound_for_new_chat_messages(
    mut commands: Commands,
    mut events: EventReader<ChatEvent>,
    character_query: Query<&Transform, With<Character>>,
    asset_server: Res<AssetServer>,
) {
    for event in events.read() {
        let ChatEvent::Chat { character_id, .. } = event;
        let Ok(character) = character_query.get(*character_id) else {
            warn!("Character not found for event {:?}", event);
            continue;
        };
        let character_transform = character;
        commands.spawn((
            AudioBundle {
                source: asset_server.load("sounds/kenny_bong_001.ogg"),
                settings: PlaybackSettings::DESPAWN.with_spatial(true),
            },
            SpatialBundle {
                transform: *character_transform,
                ..default()
            },
        ));
    }
}

fn play_sound_for_keystrokes(
    mut commands: Commands,
    mut events: EventReader<ChatInputEvent>,
    character_query: Query<&Transform, With<Character>>,
    asset_server: Res<AssetServer>,
) {
    for event in events.read() {
        let ChatInputEvent::TextChanged { character_id, .. } = event else {
            continue;
        };
        let Ok(character) = character_query.get(*character_id) else {
            warn!("Character not found for event {:?}", event);
            continue;
        };
        let character_transform = character;

        // optimization opportunity: avoid unnecessary allocations
        let choices = ["sounds/kenny_click_002.ogg", "sounds/kenny_click_003.ogg"];
        let Some(choice) = choices.choose(&mut rand::thread_rng()) else {
            continue;
        };

        commands.spawn((
            AudioBundle {
                source: asset_server.load(*choice),
                settings: PlaybackSettings::DESPAWN.with_spatial(true),
            },
            SpatialBundle {
                transform: *character_transform,
                ..default()
            },
        ));
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\ui_automation\examples\ui_snapshot_example.rs

````rust
use bevy::log::LogPlugin;
use bevy::prelude::*;
use bevy::window::ExitCondition;
use cursor_hero_memory_types::prelude::get_persist_file;
use cursor_hero_memory_types::prelude::Usage;
use cursor_hero_ui_automation::prelude::*;
use cursor_hero_worker::prelude::*;
use std::io::Write;
fn main() {
    let mut app = App::new();
    app.add_plugins(
        DefaultPlugins
            .set(LogPlugin {
                level: bevy::log::Level::DEBUG,
                filter: "
info,
wgpu_core=warn,
wgpu_hal=warn,
ui_snapshot_example=trace,
cursor_hero_worker=debug,
"
                .replace('\n', "")
                .trim()
                .into(),
            })
            .set(WindowPlugin {
                primary_window: None,
                exit_condition: ExitCondition::DontExit,
                ..default()
            })
            .build(),
    );
    app.add_plugins(WorkerPlugin {
        config: WorkerConfig::<ThreadboundUISnapshotMessage, GameboundUISnapshotMessage> {
            name: "ui_snapshot".to_string(),
            is_ui_automation_thread: true,
            handle_threadbound_message: handle_threadbound_message,
            ..default()
        },
    });
    app.add_systems(Update, trigger);
    app.add_systems(Update, receive);
    app.run();
}

#[derive(Debug, Reflect, Clone, Event)]
enum ThreadboundUISnapshotMessage {
    TakeSnapshot,
}
impl Message for ThreadboundUISnapshotMessage {}

#[derive(Debug, Reflect, Clone, Event)]
enum GameboundUISnapshotMessage {
    Snapshot(UISnapshot),
}
impl Message for GameboundUISnapshotMessage {}

fn handle_threadbound_message(
    msg: &ThreadboundUISnapshotMessage,
    reply_tx: &Sender<GameboundUISnapshotMessage>,
) -> Result<(), Box<dyn std::error::Error>> {
    let ThreadboundUISnapshotMessage::TakeSnapshot = msg;
    debug!("taking snapshot");
    let snapshot = take_snapshot()?;
    if let Err(e) = reply_tx.send(GameboundUISnapshotMessage::Snapshot(snapshot)) {
        error!("Failed to send snapshot: {:?}", e);
    }
    Ok(())
}

fn trigger(
    mut cooldown: Local<Option<Timer>>,
    time: Res<Time>,
    mut events: EventWriter<ThreadboundUISnapshotMessage>,
) {
    let should_tick = if let Some(cooldown) = cooldown.as_mut() {
        if cooldown.tick(time.delta()).just_finished() {
            cooldown.reset();
            true
        } else {
            false
        }
    } else {
        cooldown.replace(Timer::from_seconds(3.0, TimerMode::Repeating));
        true
    };
    if !should_tick {
        return;
    }
    events.send(ThreadboundUISnapshotMessage::TakeSnapshot);
}

fn receive(mut snapshot: EventReader<GameboundUISnapshotMessage>) {
    for msg in snapshot.read() {
        match msg {
            GameboundUISnapshotMessage::Snapshot(snapshot) => {
                debug!("received snapshot, writing to file");
                match get_persist_file(file!(), "ui_snapshot.txt", Usage::Persist) {
                    Ok(mut file) => {
                        if let Err(e) = file.write_all(snapshot.to_string().as_bytes()) {
                            debug!("Failed to write to file: {:?}", e);
                        }
                    }
                    Err(e) => {
                        error!("Failed to open file: {:?}", e);
                    }
                }
            }
        }
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\ui_automation_types\src\ui_automation_types.rs

````rust
use crate::prelude::Calculator;
use crate::vscode_ui_types::*;
use bevy::prelude::*;
use serde::Deserialize;
use serde::Serialize;
use std::collections::VecDeque;
use std::fmt;
use std::fmt::Display;
use std::fmt::Formatter;
use uiautomation::core::UICondition;
use uiautomation::UIAutomation;


pub trait HexList {
    fn to_hex_list(&self) -> String;
}
impl HexList for Vec<i32> {
    fn to_hex_list(&self) -> String {
        format!(
            "[{}]",
            self.iter()
                .map(|x| format!("{:X}", x).to_string())
                .collect::<Vec<String>>()
                .join(",")
        )
    }
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Reflect)]
pub struct UISnapshot {
    pub app_windows: Vec<AppWindow>,
}

impl Display for UISnapshot {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        writeln!(f, "!!! UISnapshot !!!")?;
        for window in self.app_windows.iter() {
            write!(f, "{}", window)?;
        }
        fmt::Result::Ok(())
    }
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Reflect)]
pub enum AppWindow {
    VSCode(VSCodeWindow),
    Calculator(Calculator),
}

impl Display for AppWindow {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        match self {
            AppWindow::VSCode(window) => write!(f, "{}", window),
            AppWindow::Calculator(window) => write!(f, "{}", window), 
        }
    }
}

pub fn all_of(
    automation: &UIAutomation,
    conditions: Vec<UICondition>,
) -> Result<UICondition, uiautomation::Error> {
    let iter = conditions.into_iter();
    let mut current = automation.create_true_condition()?;

    for condition in iter {
        current = automation.create_and_condition(current, condition)?;
    }

    Ok(current)
}

pub trait ToBevyIRect {
    fn to_bevy_irect(&self) -> IRect;
}
impl ToBevyIRect for uiautomation::types::Rect {
    fn to_bevy_irect(&self) -> IRect {
        IRect {
            min: IVec2::new(self.get_left(), self.get_top()),
            max: IVec2::new(self.get_right(), self.get_bottom()),
        }
    }
}

/// Defines enum for `windows::Win32::UI::Accessibility::UIA_CONTROLTYPE_ID`.
///
/// Contains the named constants used to identify Microsoft UI Automation control types.
#[repr(u32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Reflect)]
pub enum ControlType {
    /// Identifies theButtoncontrol type.
    Button = 50000u32,
    /// Identifies theCalendarcontrol type.
    Calendar = 50001u32,
    /// Identifies theCheckBoxcontrol type.
    CheckBox = 50002u32,
    /// Identifies theComboBoxcontrol type.
    ComboBox = 50003u32,
    /// Identifies theEditcontrol type.
    Edit = 50004u32,
    /// Identifies theHyperlinkcontrol type.
    Hyperlink = 50005u32,
    /// Identifies theImagecontrol type.
    Image = 50006u32,
    /// Identifies theListItemcontrol type.
    ListItem = 50007u32,
    /// Identifies theListcontrol type.
    List = 50008u32,
    /// Identifies theMenucontrol type.
    Menu = 50009u32,
    /// Identifies theMenuBarcontrol type.
    MenuBar = 50010u32,
    /// Identifies theMenuItemcontrol type.
    MenuItem = 50011u32,
    /// Identifies theProgressBarcontrol type.
    ProgressBar = 50012u32,
    /// Identifies theRadioButtoncontrol type.
    RadioButton = 50013u32,
    /// Identifies theScrollBarcontrol type.
    ScrollBar = 50014u32,
    /// Identifies theSlidercontrol type.
    Slider = 50015u32,
    /// Identifies theSpinnercontrol type.
    Spinner = 50016u32,
    /// Identifies theStatusBarcontrol type.
    StatusBar = 50017u32,
    /// Identifies theTabcontrol type.
    Tab = 50018u32,
    /// Identifies theTabItemcontrol type.
    TabItem = 50019u32,
    /// Identifies theTextcontrol type.
    Text = 50020u32,
    /// Identifies theToolBarcontrol type.
    ToolBar = 50021u32,
    /// Identifies theToolTipcontrol type.
    ToolTip = 50022u32,
    /// Identifies theTreecontrol type.
    Tree = 50023u32,
    /// Identifies theTreeItemcontrol type.
    TreeItem = 50024u32,
    /// Identifies the Custom control type. For more information, seeCustom Properties, Events, and Control Patterns.
    Custom = 50025u32,
    /// Identifies theGroupcontrol type.
    Group = 50026u32,
    /// Identifies theThumbcontrol type.
    Thumb = 50027u32,
    /// Identifies theDataGridcontrol type.
    DataGrid = 50028u32,
    /// Identifies theDataItemcontrol type.
    DataItem = 50029u32,
    /// Identifies theDocumentcontrol type.
    Document = 50030u32,
    /// Identifies theSplitButtoncontrol type.
    SplitButton = 50031u32,
    /// Identifies theWindowcontrol type.
    Window = 50032u32,
    /// Identifies thePanecontrol type.
    Pane = 50033u32,
    /// Identifies theHeadercontrol type.
    Header = 50034u32,
    /// Identifies theHeaderItemcontrol type.
    HeaderItem = 50035u32,
    /// Identifies theTablecontrol type.
    Table = 50036u32,
    /// Identifies theTitleBarcontrol type.
    TitleBar = 50037u32,
    /// Identifies theSeparatorcontrol type.
    Separator = 50038u32,
    /// Identifies theSemanticZoomcontrol type. Supported starting with Windows 8.
    SemanticZoom = 50039u32,
    /// Identifies theAppBarcontrol type. Supported starting with Windows 8.1.
    AppBar = 50040u32,
}
impl From<uiautomation::controls::ControlType> for ControlType {
    fn from(value: uiautomation::controls::ControlType) -> Self {
        match value {
            uiautomation::controls::ControlType::Button => ControlType::Button,
            uiautomation::controls::ControlType::Calendar => ControlType::Calendar,
            uiautomation::controls::ControlType::CheckBox => ControlType::CheckBox,
            uiautomation::controls::ControlType::ComboBox => ControlType::ComboBox,
            uiautomation::controls::ControlType::Edit => ControlType::Edit,
            uiautomation::controls::ControlType::Hyperlink => ControlType::Hyperlink,
            uiautomation::controls::ControlType::Image => ControlType::Image,
            uiautomation::controls::ControlType::ListItem => ControlType::ListItem,
            uiautomation::controls::ControlType::List => ControlType::List,
            uiautomation::controls::ControlType::Menu => ControlType::Menu,
            uiautomation::controls::ControlType::MenuBar => ControlType::MenuBar,
            uiautomation::controls::ControlType::MenuItem => ControlType::MenuItem,
            uiautomation::controls::ControlType::ProgressBar => ControlType::ProgressBar,
            uiautomation::controls::ControlType::RadioButton => ControlType::RadioButton,
            uiautomation::controls::ControlType::ScrollBar => ControlType::ScrollBar,
            uiautomation::controls::ControlType::Slider => ControlType::Slider,
            uiautomation::controls::ControlType::Spinner => ControlType::Spinner,
            uiautomation::controls::ControlType::StatusBar => ControlType::StatusBar,
            uiautomation::controls::ControlType::Tab => ControlType::Tab,
            uiautomation::controls::ControlType::TabItem => ControlType::TabItem,
            uiautomation::controls::ControlType::Text => ControlType::Text,
            uiautomation::controls::ControlType::ToolBar => ControlType::ToolBar,
            uiautomation::controls::ControlType::ToolTip => ControlType::ToolTip,
            uiautomation::controls::ControlType::Tree => ControlType::Tree,
            uiautomation::controls::ControlType::TreeItem => ControlType::TreeItem,
            uiautomation::controls::ControlType::Custom => ControlType::Custom,
            uiautomation::controls::ControlType::Group => ControlType::Group,
            uiautomation::controls::ControlType::Thumb => ControlType::Thumb,
            uiautomation::controls::ControlType::DataGrid => ControlType::DataGrid,
            uiautomation::controls::ControlType::DataItem => ControlType::DataItem,
            uiautomation::controls::ControlType::Document => ControlType::Document,
            uiautomation::controls::ControlType::SplitButton => ControlType::SplitButton,
            uiautomation::controls::ControlType::Window => ControlType::Window,
            uiautomation::controls::ControlType::Pane => ControlType::Pane,
            uiautomation::controls::ControlType::Header => ControlType::Header,
            uiautomation::controls::ControlType::HeaderItem => ControlType::HeaderItem,
            uiautomation::controls::ControlType::Table => ControlType::Table,
            uiautomation::controls::ControlType::TitleBar => ControlType::TitleBar,
            uiautomation::controls::ControlType::Separator => ControlType::Separator,
            uiautomation::controls::ControlType::SemanticZoom => ControlType::SemanticZoom,
            uiautomation::controls::ControlType::AppBar => ControlType::AppBar,
        }
    }
}

pub type RuntimeId = Vec<i32>;

#[derive(Debug, Eq, PartialEq, Clone, Reflect, Default, Hash)]
pub enum DrillId {
    Root,
    Child(VecDeque<usize>),
    #[default]
    Unknown,
}
impl From<Vec<usize>> for DrillId {
    fn from(value: Vec<usize>) -> Self {
        DrillId::Child(value.into())
    }
}
impl From<VecDeque<usize>> for DrillId {
    fn from(value: VecDeque<usize>) -> Self {
        DrillId::Child(value)
    }
}
impl From<Vec<i32>> for DrillId {
    fn from(value: Vec<i32>) -> Self {
        DrillId::Child(value.into_iter().map(|x| x as usize).collect())
    }
}
impl From<VecDeque<i32>> for DrillId {
    fn from(value: VecDeque<i32>) -> Self {
        DrillId::Child(value.into_iter().map(|x| x as usize).collect())
    }
}
impl std::fmt::Display for DrillId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            DrillId::Root => write!(f, "Root"),
            DrillId::Child(drill_id) => write!(
                f,
                "{}",
                drill_id
                    .iter()
                    .map(|x| x.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
            ),
            DrillId::Unknown => write!(f, "Unknown"),
        }
    }
}

#[derive(Debug, Clone, Reflect, PartialEq)]
// #[reflect(no_field_bounds)] //https://github.com/bevyengine/bevy/issues/8965
pub struct ElementInfo {
    pub name: String,
    pub bounding_rect: Rect,
    pub control_type: ControlType,
    pub localized_control_type: String,
    pub class_name: String,
    pub automation_id: String,
    #[reflect(ignore)]
    pub runtime_id: Vec<i32>,
    #[reflect(ignore)]
    pub drill_id: DrillId,
    #[reflect(ignore)]
    pub children: Option<Vec<ElementInfo>>,
}
impl Default for ElementInfo {
    fn default() -> Self {
        ElementInfo {
            name: "".to_string(),
            bounding_rect: Rect::new(0.0, 0.0, 0.0, 0.0),
            control_type: ControlType::Pane,
            localized_control_type: "".to_string(),
            class_name: "".to_string(),
            automation_id: "".to_string(),
            runtime_id: vec![],
            drill_id: DrillId::Unknown,
            children: None,
        }
    }
}
impl ElementInfo {
    pub fn lookup_drill_id(&self, drill_id: DrillId) -> Option<&ElementInfo> {
        self.lookup_drill_id_inner(drill_id, 0)
    }
    fn lookup_drill_id_inner(&self, drill_id: DrillId, skip: usize) -> Option<&ElementInfo> {
        // println!("Looking in {} for {:?} ({:?})", self.name, drill_id.map(|x| x.iter().skip(skip).collect::<Vec<&usize>>()), drill_id);
        if self.drill_id == drill_id {
            return Some(self);
        }
        let DrillId::Child(drill_id) = drill_id else {
            return None;
        };
        if drill_id.is_empty() {
            return None;
        }
        let Some(children) = &self.children else {
            return None;
        };
        // println!("found children {:?}", children.children.iter().map(|x| x.drill_id.clone()).collect_vec());
        for child in children {
            let DrillId::Child(child_drill_id) = &child.drill_id else {
                continue;
            };
            if child_drill_id.back() == drill_id.iter().skip(skip).next() {
                if skip == drill_id.len() - 1 {
                    return Some(child);
                } else {
                    return child.lookup_drill_id_inner(DrillId::Child(drill_id.clone()), skip + 1);
                }
            }
        }
        None
    }
    pub fn lookup_drill_id_mut(&mut self, drill_id: DrillId) -> Option<&mut ElementInfo> {
        self.lookup_drill_id_mut_inner(drill_id, 0)
    }
    
    fn lookup_drill_id_mut_inner(&mut self, drill_id: DrillId, skip: usize) -> Option<&mut ElementInfo> {
        // println!("Looking in {} for {:?} ({:?})", self.name, drill_id.map(|x| x.iter().skip(skip).collect::<Vec<&usize>>()), drill_id);
        if self.drill_id == drill_id {
            return Some(self);
        }
        let DrillId::Child(drill_id) = drill_id else {
            return None;
        };
        if drill_id.is_empty() {
            return None;
        }
        let Some(ref mut children) = self.children else {
            return None;
        };
        // println!("found children {:?}", children.children.iter().map(|x| x.drill_id.clone()).collect_vec());
        for child in children.iter_mut() {
            let DrillId::Child(child_drill_id) = &child.drill_id else {
                continue;
            };
            if child_drill_id.back() == drill_id.iter().skip(skip).next() {
                if skip == drill_id.len() - 1 {
                    return Some(child);
                } else {
                    return child.lookup_drill_id_mut_inner(DrillId::Child(drill_id.clone()), skip + 1);
                }
            }
        }
        None
    }
    pub fn get_descendents(&self) -> Vec<&ElementInfo> {
        let mut descendents = vec![];
        if let Some(children) = &self.children {
            for child in children {
                descendents.push(child);
                descendents.extend(child.get_descendents());
            }
        }
        descendents
    }
}
// test lookup_drill_id
#[cfg(test)]
mod tests {
    #[test]
    fn test_lookup_drill_id() {
        use super::*;
        fn new_elem(name: &str, drill_id: Vec<usize>) -> ElementInfo {
            ElementInfo {
                name: name.to_string(),
                bounding_rect: Rect::new(0.0, 0.0, 100.0, 100.0),
                control_type: ControlType::Button,
                localized_control_type: "Button".to_string(),
                class_name: "Button".to_string(),
                automation_id: "Button".to_string(),
                runtime_id: vec![],
                drill_id: match drill_id.is_empty() {
                    true => DrillId::Root,
                    false => DrillId::Child(drill_id.into()),
                },
                children: None,
            }
        }
        let mut root = new_elem("root", vec![]);

        let mut a = new_elem("a", vec![0]);
        let a_a = new_elem("a_a", vec![0, 0]);
        let a_b = new_elem("a_b", vec![0, 1]);
        a.children = Some(vec![a_a.clone(), a_b.clone()]);

        let mut b = new_elem("b", vec![1]);
        let mut b_a = new_elem("b_a", vec![1, 0]);
        let b_a_a = new_elem("b_a_a", vec![1, 0, 0]);
        let b_a_b = new_elem("b_a_b", vec![1, 0, 1]);
        b_a.children = Some(vec![b_a_a.clone(), b_a_b.clone()]);
        let b_b = new_elem("b_b", vec![1, 1]);
        b.children = Some(vec![b_a.clone(), b_b.clone()]);

        root.children = Some(vec![a.clone(), b.clone()]);

        let items = vec![&root, &a, &a_a, &a_b, &b, &b_a, &b_a_a, &b_a_b, &b_b];
        for item in items {
            println!("Looking for {}", item.name);
            let found = root.lookup_drill_id(item.drill_id.clone());
            assert_eq!(found, Some(item));
            println!();
        }
    }
}
````



## D:\Repos\Games\Cursor-Hero\crates\winutils\src\win_cursor.rs

````rust
use crate::win_errors::*;
use crate::win_icons::convert_hcursor_to_rgba_image;
use image::RgbaImage;
use windows::Win32::UI::WindowsAndMessaging::LoadCursorW;
use windows::Win32::UI::WindowsAndMessaging::IDC_APPSTARTING;
use windows::Win32::UI::WindowsAndMessaging::IDC_ARROW;
use windows::Win32::UI::WindowsAndMessaging::IDC_CROSS;
use windows::Win32::UI::WindowsAndMessaging::IDC_HAND;
use windows::Win32::UI::WindowsAndMessaging::IDC_HELP;
use windows::Win32::UI::WindowsAndMessaging::IDC_IBEAM;
use windows::Win32::UI::WindowsAndMessaging::IDC_NO;
use windows::Win32::UI::WindowsAndMessaging::IDC_SIZEALL;
use windows::Win32::UI::WindowsAndMessaging::IDC_SIZENESW;
use windows::Win32::UI::WindowsAndMessaging::IDC_SIZENS;
use windows::Win32::UI::WindowsAndMessaging::IDC_SIZENWSE;
use windows::Win32::UI::WindowsAndMessaging::IDC_SIZEWE;
use windows::Win32::UI::WindowsAndMessaging::IDC_UPARROW;
use windows::Win32::UI::WindowsAndMessaging::IDC_WAIT;

pub fn get_all_cursor_icons() -> Result<Vec<RgbaImage>> {
    let mut icons = Vec::new();

    // Load each cursor and convert it to an RgbaImage
    for cursor_id in [
        IDC_ARROW,
        IDC_IBEAM,
        IDC_WAIT,
        IDC_CROSS,
        IDC_UPARROW,
        IDC_SIZEALL,
        IDC_SIZENESW,
        IDC_SIZENS,
        IDC_SIZENWSE,
        IDC_SIZEWE,
        IDC_HAND,
        IDC_HELP,
        IDC_NO,
        IDC_APPSTARTING,
    ] {
        let hcursor = unsafe { LoadCursorW(None, cursor_id)? };
        if hcursor.is_invalid() {
            return Err(Error::from_win32().with_description(format!(
                "Failed to load cursor with ID {:?}",
                cursor_id.0
            )));
        }
        let image = convert_hcursor_to_rgba_image(&hcursor)?;
        icons.push(image);
    }

    Ok(icons)
}

#[cfg(test)]
mod tests {
    use std::path::PathBuf;

    #[test]
    fn test_get_all_cursor_icons() {
        let icons = super::get_all_cursor_icons().unwrap();

        // Ensure the expected amount is present
        assert_eq!(icons.len(), 14);

        // Save icons
        let mut path = PathBuf::from("target/cursor_icons");
        std::fs::create_dir_all(&path).unwrap();
        for (i, icon) in icons.iter().enumerate() {
            let mut icon_path = path.clone();
            icon_path.push(format!("{}.png", i));
            icon.save(icon_path).unwrap();
        }
    }
}
````



## D:\Repos\Games\Cursor-Hero\crates\voice_to_text\src\voice_to_text.rs

````rust
use bevy::log::debug;
use bevy::log::error;
use bevy::log::info;
use crossbeam_channel::Sender;
use cursor_hero_secret_types::secrets_types::SecretString;
use cursor_hero_voice_to_text_types::prelude::*;
use futures_util::stream::StreamExt;
use futures_util::SinkExt;
use rand::distributions::Alphanumeric;
use rand::Rng;
use reqwest::Client;
use std::error::Error;
use std::process::Command;
use tokio_tungstenite::connect_async;
use tokio_tungstenite::tungstenite::client::IntoClientRequest;
use tokio_tungstenite::tungstenite::http::header::AUTHORIZATION;
use tokio_tungstenite::tungstenite::http::HeaderValue;
use tokio_tungstenite::tungstenite::protocol::Message;

use crate::voice_to_text_worker_plugin::GameboundMessage;

pub(crate) const URL: &str = "https://localhost:9127";

pub(crate) async fn get_status() -> Result<VoiceToTextStatus, Box<dyn Error>> {
    let client = Client::new();
    match client.get(format!("{}/", URL)).send().await {
        Ok(res) => match res.status().is_success() {
            true => Ok(VoiceToTextStatus::AliveButWeDontKnowTheApiKey),
            false => Ok(VoiceToTextStatus::Dead),
        },
        Err(_) => Ok(VoiceToTextStatus::Dead),
    }
}

fn generate_api_key(len: usize) -> SecretString {
    let rng = rand::thread_rng();
    let inner = rng
        .sample_iter(&Alphanumeric)
        .take(len)
        .map(char::from)
        .collect();
    SecretString::new(inner)
}

pub(crate) fn start() -> Result<SecretString, Box<dyn Error>> {
    let port = 9127;
    let api_key = generate_api_key(32);
    match std::process::Command::new("wt")
        .args([
            "--window",
            "0",
            "--profile",
            "PowerShell",
            "--title",
            "Voice2Text",
            "--",
            "pwsh",
            "-Command",
            r"cd D:\Repos\ml\voice2text && conda activate whisperx && python .\transcribe_hotkey_typer.py $env:port $env:api_key",
        ])
        .env("port", port.to_string())
        .env("api_key", api_key.expose_secret())
        .spawn()
    {
        Ok(_) => Ok(api_key),
        Err(e) => Err(Box::new(e)),
    }
}

pub(crate) fn start_vscode() -> Result<(), Box<dyn Error>> {
    match Command::new(r"C:\Program Files\Microsoft VS Code\Code.exe")
        .args([r"D:\Repos\ml\voice2text"])
        .spawn()
    {
        Ok(_) => Ok(()),
        Err(e) => Err(Box::new(e)),
    }
}

pub(crate) async fn set_listening(
    listening: bool,
    api_key: SecretString,
) -> Result<(), Box<dyn Error>> {
    let client = Client::new();
    let endpoint = match listening {
        true => format!("{}/start_listening", URL),
        false => format!("{}/stop_listening", URL),
    };
    match client
        .post(endpoint)
        .header(reqwest::header::AUTHORIZATION, api_key.expose_secret())
        .send()
        .await
    {
        Ok(res) => match res.status().is_success() {
            true => Ok(()),
            false => Err(Box::new(std::io::Error::new(
                std::io::ErrorKind::Other,
                format!(
                    "Failed to set listening: {:?}",
                    match res.text().await {
                        Ok(text) => text,
                        Err(e) =>
                            format!("Failed to get response text during failure handler: {}", e),
                    }
                ),
            )))?,
        },
        Err(e) => Err(Box::new(e)),
    }
}

use serde::Deserialize;
#[derive(Debug, Deserialize)]
struct TranscriptionResponse {
    segments: Vec<Segment>,
    // language: String,
}

#[derive(Debug, Deserialize)]
struct Segment {
    text: String,
    // start: f64,
    // end: f64,
}

pub(crate) async fn connect_receiver(
    game_tx: Sender<GameboundMessage>,
    api_key: SecretString,
) -> Result<(), Box<dyn Error>> {
    // Assuming the WebSocket endpoint is similar to HTTP but with ws(s) protocol
    let url = format!("{URL}/results").replace("http", "ws");

    // Add our auth header
    let mut req = url.into_client_request()?;
    let val = HeaderValue::from_str(api_key.expose_secret().as_str())?;
    req.headers_mut().insert(AUTHORIZATION, val);

    // Start worker to listen to responses without blocking the main thread
    tokio::spawn(async move {
        let (ws_stream, _) = match connect_async(req).await {
            Ok(conn) => {
                info!("Connected to WebSocket");
                conn
            }
            Err(e) => {
                error!("Failed to connect to WebSocket: {:?}", e);
                return;
            }
        };

        let (mut write, mut read) = ws_stream.split();
        debug!("Starting keepalive thread");
        tokio::spawn(async move {
            debug!("Keepalive thread started, entering main loop");
            loop {
                tokio::time::sleep(tokio::time::Duration::from_secs(5)).await;
                if let Err(e) = write.send(Message::text("keepalive")).await {
                    error!("Failed to send keepalive: {:?}", e);
                    break;
                }
            }
        });

        // Listening for messages
        while let Some(message) = read.next().await {
            match message {
                Ok(msg) => {
                    if let Message::Text(text) = msg {
                        // Deserialize the JSON text into TranscriptionResponse
                        debug!("Received message: {}", text);
                        match serde_json::from_str::<TranscriptionResponse>(&text) {
                            Ok(transcription) => {
                                // Concatenate the text of all segments
                                let concatenated_text = transcription
                                    .segments
                                    .iter()
                                    .map(|s| s.text.as_str())
                                    .collect::<Vec<&str>>()
                                    .join(" ");
                                let msg = GameboundMessage::TranscriptionReceived {
                                    transcription: concatenated_text,
                                };
                                debug!("Sending transcription to game: {:?}", msg);
                                if let Err(e) = game_tx.send(msg) {
                                    error!("Failed to send transcription to game: {:?}", e);
                                }
                            }
                            Err(e) => error!("Failed to deserialize message: {:?}", e),
                        }
                    }
                }
                Err(e) => {
                    error!("WebSocket error: {:?}", e);
                    break;
                }
            }
        }
    });

    Ok(())
}

````



## D:\Repos\Games\Cursor-Hero\crates\observation\src\observation_buffer_plugin.rs

````rust
use bevy::prelude::*;
use cursor_hero_environment_types::prelude::*;
use cursor_hero_observation_types::prelude::*;

/// Responsible for storing observations inside ObservationBuckets of those who are able to observe them.
pub struct ObservationBufferPlugin;

impl Plugin for ObservationBufferPlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(Update, update_buffers);
    }
}

fn update_buffers(
    mut observation_events: EventReader<SomethingObservableHappenedEvent>,
    mut buffer_query: Query<(Entity, &mut ObservationBuffer, Option<&EnvironmentTracker>)>,
    mut buffer_events: EventWriter<ObservationBufferEvent>,
) {
    for event in observation_events.read() {
        for buffer in buffer_query.iter_mut() {
            let (buffer_id, mut buffer, buffer_environment_tag) = buffer;

            // Determine if the buffer can see the event
            let can_see = match (buffer_environment_tag, event) {
                (
                    Some(EnvironmentTracker {
                        environment_id: buffer_environment_id,
                    }),
                    SomethingObservableHappenedEvent::Chat {
                        environment_id: Some(event_environment_id),
                        ..
                    },
                ) => *buffer_environment_id == *event_environment_id,
                (
                    _,
                    SomethingObservableHappenedEvent::MemoryRestored {
                        observation_buffer_id,
                    },
                ) => buffer_id == *observation_buffer_id,
                (
                    Some(EnvironmentTracker {
                        environment_id: buffer_environment_id,
                    }),
                    SomethingObservableHappenedEvent::UISnapshot {
                        environment_id: Some(event_environment_id),
                        ..
                    },
                ) => *buffer_environment_id == *event_environment_id,
                // A buffer outside all environments will observe all environments
                (None, _) => true,
                _ => false,
            };
            if !can_see {
                if buffer.log_level == ObservationLogLevel::All {
                    debug!("Buffer {:?} cannot see event {:?}", buffer_id, event)
                }
                continue;
            }

            let entry = ObservationBufferEntry {
                datetime: chrono::Local::now(),
                origin: event.clone(),
            };
            if buffer.log_level == ObservationLogLevel::All {
                debug!("Buffer {:?} observed event {:?}", buffer_id, &entry)
            }
            buffer.observations.push(entry);

            let event = ObservationBufferEvent::Updated { buffer_id };
            buffer_events.send(event);
        }
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\pointer_types\src\pointer_behaviour_types.rs

````rust
use bevy::prelude::*;
use std::fmt::Display;
use std::fmt::Formatter;

#[derive(Eq, PartialEq, Debug, Reflect, Clone, Copy)]
pub enum PointerMovementBehaviour {
    None,
    SetHostCursorFromPointerWorldCoords,
    SetHostCursorFromWindowCoords,
    SetPointerFromHostCursorWindowCoords,
}

impl Display for PointerMovementBehaviour {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "{}",
            match self {
                PointerMovementBehaviour::None => "None",
                PointerMovementBehaviour::SetHostCursorFromPointerWorldCoords =>
                    "SetHostCursorFromPointerWorldCoords",
                PointerMovementBehaviour::SetHostCursorFromWindowCoords =>
                    "SetHostCursorFromWindowCoords",
                PointerMovementBehaviour::SetPointerFromHostCursorWindowCoords =>
                    "SetPointerFromHostCursorWindowCoords",
            }
        )
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\glados_tts_types\src\glados_tts_types_plugin.rs

````rust
use crate::prelude::*;
use bevy::prelude::*;

pub struct GladosTtsTypesPlugin;

impl Plugin for GladosTtsTypesPlugin {
    fn build(&self, app: &mut App) {
        app.register_type::<GladosTtsStatus>();
        app.register_type::<GladosTtsStatusButton>();
        app.register_type::<GladosTtsStatusButtonVisualState>();
        app.register_type::<GladosTtsStatusEvent>();
        app.add_event::<GladosTtsStatusEvent>();

        app.register_type::<GladosTtsPingEvent>();
        app.add_event::<GladosTtsPingEvent>();

        app.register_type::<GladosTtsVscodeButton>();
        app.register_type::<GladosTtsVscodeButtonVisualState>();
        app.register_type::<GladosTtsVscodeEvent>();
        app.add_event::<GladosTtsVscodeEvent>();
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\window_swap_tool\src\window_swap_tool_tick_plugin.rs

````rust
use bevy::prelude::*;
use cursor_hero_WindowSwap_tool_types::prelude::*;
use cursor_hero_toolbelt_types::prelude::*;
use leafwing_input_manager::prelude::*;

pub struct WindowSwapToolTickPlugin;

impl Plugin for WindowSwapToolTickPlugin {
    fn build(&self, app: &mut App) {
        app.add_plugins(InputManagerPlugin::<WindowSwapToolAction>::default());
        app.add_systems(Update, tick);
    }
}

fn tick(
    tool_query: Query<(&ActionState<WindowSwapToolAction>, &WindowSwapTool), With<ActiveTool>>,
) {
    for tool in tool_query.iter() {
        let (tool_actions, tool) = tool;
        if !tool_actions.pressed(WindowSwapToolAction::Use) {
            continue;
        }
        info!("WindowSwapTool used!");
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\physics\src\physics_plugin.rs

````rust
use bevy::prelude::*;

use bevy_xpbd_2d::math::Vector;
use bevy_xpbd_2d::plugins::setup::Physics;
use bevy_xpbd_2d::plugins::sync::SyncConfig;
use bevy_xpbd_2d::plugins::PhysicsPlugins;
use bevy_xpbd_2d::resources::Gravity;

pub struct PhysicsPlugin;

impl Plugin for PhysicsPlugin {
    fn build(&self, app: &mut App) {
        app.add_plugins(PhysicsPlugins::default())
            .insert_resource(Gravity(Vector::ZERO))
            .insert_resource(Time::new_with(Physics::fixed_hz(144.0)))
            .insert_resource(SyncConfig {
                position_to_transform: true,
                transform_to_position: true,
            });
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\ui_automation\src\formatting.rs

````rust
use uiautomation::UIAutomation;
use uiautomation::UIElement;

pub fn get_tree_string(element: &UIElement) -> Result<String, uiautomation::Error> {
    let automation = UIAutomation::new()?;
    format_tree_recursive(element, &automation, 0)
}
fn format_tree_recursive(
    element: &UIElement,
    automation: &UIAutomation,
    depth: usize,
) -> Result<String, uiautomation::Error> {
    // Format the current element's label.
    let mut result = format!(
        "{}{}\n",
        " ".repeat(depth * 2), // Increase indentation with depth.
        format_tree_label(element)
    );

    // Use the TreeWalker to navigate the children.
    let walker = automation.create_tree_walker()?;
    if let Ok(child) = walker.get_first_child(element) {
        // Recursively format the child and any siblings.
        result.push_str(&format_tree_recursive(&child, automation, depth + 1)?);
        let mut next_sibling = child;
        while let Ok(sibling) = walker.get_next_sibling(&next_sibling) {
            result.push_str(&format_tree_recursive(&sibling, automation, depth + 1)?);
            next_sibling = sibling;
        }
    }
    Ok(result)
}
fn format_tree_label(element: &UIElement) -> String {
    format!(
        "name={} control_type={} class_name={} runtime_id={} rect={}",
        element
            .get_name()
            .map(|name| format!("{:?}", name))
            .unwrap_or_else(|_| "(null)".to_string()),
        element
            .get_control_type()
            .map(|ct| format!("{:?}", ct))
            .unwrap_or_else(|_| "unknown control type".to_string()),
        element
            .get_classname()
            .map(|name| format!("{:?}", name))
            .unwrap_or_else(|_| "(null)".to_string()),
        element
            .get_runtime_id()
            .map(|id| format!("{:?}", id))
            .unwrap_or_else(|_| "(null)".to_string()),
        element
            .get_bounding_rectangle()
            .map(|rect| format!("{:?}", rect))
            .unwrap_or_else(|_| "(null)".to_string()),
    )
}

````



## D:\Repos\Games\Cursor-Hero\crates\observation_types\src\observation_types.rs

````rust
use std::fmt;
use std::fmt::Display;
use std::fmt::Formatter;
use std::time::Duration;

use bevy::prelude::*;
use chrono::DateTime;
use chrono::Local;
use cursor_hero_ui_automation_types::prelude::UISnapshot;
use serde::Deserialize;
use serde::Serialize;
#[derive(Component, Reflect, Default)]
pub struct ObservationTool {
    #[reflect(ignore)]
    pub last_inference: Option<DateTime<Local>>,
    pub _whats_new: Option<WhatsNew>, // latest value for visual inspection
}

#[derive(Debug, Reflect, PartialEq, Eq, Clone, Copy)]
pub enum WhatsNew {
    Nothing,
    SelfChat,
    ChatReceived,
    ChatReceivedButTheyProbablyStillThinking,
    MemoryRestored,
    UISnapshot,
}

impl WhatsNew {
    /// When the agent replies, it sends a chat, which becomes its own observation
    /// Letting this trigger the inference again is a loop
    /// We want to allow this loop, but only after a longer period of inactivity compared
    /// to if a chat was received from another entity.
    pub fn reply_delay(&self) -> Duration {
        match self {
            WhatsNew::SelfChat => Duration::from_secs(60),
            WhatsNew::Nothing => Duration::MAX,
            WhatsNew::ChatReceived => Duration::ZERO,
            WhatsNew::ChatReceivedButTheyProbablyStillThinking => Duration::from_secs(25),
            WhatsNew::MemoryRestored => Duration::from_secs(5),
            WhatsNew::UISnapshot => Duration::from_secs(60 * 2),
        }
    }
}

impl Ord for WhatsNew {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        // In-declaration order of importance, higher is more important
        (*self as u32).cmp(&(*other as u32))
    }
}
impl PartialOrd for WhatsNew {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        Some(self.cmp(other))
    }
}

#[derive(Component, Reflect, Default, Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct ObservationBuffer {
    pub observations: Vec<ObservationBufferEntry>,
    pub log_level: ObservationLogLevel, // TODO: investigate always logging but updating the log filter instead of not logging based on level
}

#[derive(Debug, Reflect, Default, PartialEq, Eq, Serialize, Deserialize, Clone)]
pub enum ObservationLogLevel {
    #[default]
    Default,
    All,
}

#[derive(Component, Reflect, Debug, Serialize, Deserialize, PartialEq, Clone)]
pub struct ObservationBufferEntry {
    #[reflect(ignore)]
    pub datetime: DateTime<Local>,
    pub origin: SomethingObservableHappenedEvent,
}

#[derive(Event, Debug, Clone, Reflect)]
pub enum ObservationBufferEvent {
    Updated { buffer_id: Entity },
}

#[derive(Event, Debug, Clone, Reflect, Serialize, Deserialize, PartialEq)]
pub enum SomethingObservableHappenedEvent {
    Chat {
        environment_id: Option<Entity>,
        character_id: Entity,
        character_name: String,
        message: String,
    },
    MemoryRestored {
        observation_buffer_id: Entity,
    },
    UISnapshot {
        environment_id: Option<Entity>,
        snapshot: UISnapshot,
    },
    // BrickEnteredEnvironment {

    // }
}
impl Display for SomethingObservableHappenedEvent {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        match self {
            SomethingObservableHappenedEvent::Chat {
                character_name,
                message,
                ..
            } => {
                write!(f, "{}: {}", character_name, message)
            }
            SomethingObservableHappenedEvent::MemoryRestored { .. } => {
                write!(
                    f,
                    "The game has restarted and the agent memory has been restored."
                )
            }
            SomethingObservableHappenedEvent::UISnapshot { snapshot, .. } => {
                write!(f, "Snapshot of an app window: {:?}", snapshot)
            }
        }
    }
}
impl SomethingObservableHappenedEvent {
    pub fn into_whats_new(&self, observation_buffer_id: Entity) -> WhatsNew {
        match self {
            SomethingObservableHappenedEvent::Chat {
                character_id: event_character_id,
                ..
            } if *event_character_id == observation_buffer_id => WhatsNew::SelfChat,
            SomethingObservableHappenedEvent::Chat { message, .. }
                if message.ends_with("...")
                    || !message.ends_with('.')
                        && !message.ends_with('!')
                        && !message.ends_with('?') =>
            {
                WhatsNew::ChatReceivedButTheyProbablyStillThinking
            }
            SomethingObservableHappenedEvent::Chat { .. } => WhatsNew::ChatReceived,
            SomethingObservableHappenedEvent::MemoryRestored { .. } => WhatsNew::MemoryRestored,
            SomethingObservableHappenedEvent::UISnapshot { .. } => WhatsNew::UISnapshot,
        }
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\window_position\src\window_position_loadout_switcher_tool_plugin.rs

````rust
use bevy::prelude::*;
use cursor_hero_toolbelt_types::prelude::ToolbeltPopulateEvent;
use cursor_hero_toolbelt_types::toolbelt_types::ActiveTool;
use cursor_hero_toolbelt_types::toolbelt_types::ToolbeltLoadout;
use cursor_hero_tools::prelude::NoInputs;
use cursor_hero_tools::prelude::ToolSpawnConfig;
use cursor_hero_tools::tool_spawning::StartingState;
use cursor_hero_window_position_types::window_position_types::WindowPositionLoadoutSwitcherTool;

pub struct WindowPositionLoadoutSwitcherToolPlugin;

impl Plugin for WindowPositionLoadoutSwitcherToolPlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(Update, populate_toolbelts);
        app.add_systems(Update, do_switch);
    }
}

fn populate_toolbelts(
    mut commands: Commands,
    asset_server: Res<AssetServer>,
    mut reader: EventReader<ToolbeltPopulateEvent>,
) {
    for event in reader.read() {
        if event.loadout != ToolbeltLoadout::Default {
            continue;
        }
        ToolSpawnConfig::<WindowPositionLoadoutSwitcherTool, NoInputs>::new(
            WindowPositionLoadoutSwitcherTool,
            event.id,
            event,
        )
        .with_src_path(file!().into())
        .guess_name(file!())
        .with_image(asset_server.load("textures/tools/window_position.webp"))
        .with_description("Swaps to taskbar tools")
        .with_starting_state(StartingState::Inactive)
        .spawn(&mut commands);
    }
}

fn do_switch(
    mut commands: Commands,
    tool_query: Query<&Parent, (Added<ActiveTool>, With<WindowPositionLoadoutSwitcherTool>)>,
    mut toolbelt_events: EventWriter<ToolbeltPopulateEvent>,
) {
    for toolbelt_id in tool_query.iter() {
        let toolbelt_id = toolbelt_id.get();
        commands.entity(toolbelt_id).despawn_descendants();
        toolbelt_events.send(ToolbeltPopulateEvent {
            id: toolbelt_id,
            loadout: ToolbeltLoadout::WindowPosition,
        });
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\toolbelt\src\toolbelt_plugin.rs

````rust
use bevy::prelude::*;
use leafwing_input_manager::prelude::*;

use crate::hover_frame::insert_hover_frame;
use crate::hover_frame::remove_hover_frame;
use crate::tool_activation::tool_activation;
use crate::tool_color::tool_color;
use crate::tool_help_activate::tool_help_activation;
use crate::tool_help_cleanup::tool_help_cleanup;
use crate::tool_help_click::help_click_listener;
use crate::tool_help_populate::tool_help_lifecycle;
use crate::tool_visibility::tool_visibility;
use crate::toolbelt_circle_layout_plugin::ToolbeltCircleLayoutPlugin;
use crate::toolbelt_opening_plugin::ToolbeltOpeningPlugin;
use crate::toolbelt_properties_plugin::ToolbeltPropertiesPlugin;
use crate::toolbelt_taskbar_layout_plugin::ToolbeltTaskbarLayoutPlugin;
use crate::wheel_audio::wheel_audio;
use cursor_hero_toolbelt_types::toolbelt_types::*;
pub struct ToolbeltPlugin;

impl Plugin for ToolbeltPlugin {
    fn build(&self, app: &mut App) {
        app.add_plugins(ToolbeltOpeningPlugin);
        app.add_plugins(ToolbeltPropertiesPlugin);
        app.add_plugins(ToolbeltCircleLayoutPlugin);
        app.add_plugins(ToolbeltTaskbarLayoutPlugin);
        app.add_plugins(InputManagerPlugin::<ToolbeltAction>::default());
        app.add_systems(Update, help_click_listener);
        app.add_systems(Update, insert_hover_frame);
        app.add_systems(Update, remove_hover_frame);
        app.add_systems(Update, tool_color);
        app.add_systems(Update, tool_activation);
        app.add_systems(Update, tool_help_cleanup);
        app.add_systems(
            Update,
            (
                wheel_audio,
                tool_visibility,
                tool_help_activation,
                tool_help_lifecycle,
            )
                .chain(),
        );
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\secret_types\src\secrets_types_plugin.rs

````rust
use crate::prelude::*;
use bevy::prelude::*;

pub struct SecretsTypesPlugin;

impl Plugin for SecretsTypesPlugin {
    fn build(&self, app: &mut App) {
        app.register_type::<SecretString>();
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\window_position_types\src\window_position_types_plugin.rs

````rust
use crate::prelude::*;
use bevy::prelude::*;

pub struct WindowPositionTypesPlugin;

impl Plugin for WindowPositionTypesPlugin {
    fn build(&self, app: &mut App) {
        app.register_type::<crate::window_position_types::HostWindowPosition>();
        app.register_type::<WindowPositionLoadoutSwitcherTool>();
        app.register_type::<WindowPositionTool>();
        app.register_type::<WindowPositionCommand>();
        app.add_event::<WindowPositionCommand>();
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\movement_tool\src\movement_sprint_plugin.rs

````rust
use bevy::prelude::*;
use cursor_hero_character_types::prelude::*;
use cursor_hero_math::prelude::Lerp;
use cursor_hero_movement_tool_types::prelude::*;
use cursor_hero_sprint_tool_types::sprint_tool_types_plugin::SprintEvent;
use cursor_hero_toolbelt_types::prelude::*;
use itertools::Itertools;
pub struct MovementSprintPlugin;

impl Plugin for MovementSprintPlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(Update, handle_sprint_events);
    }
}

fn handle_sprint_events(
    mut sprint_events: EventReader<SprintEvent>,
    character_query: Query<&Children, With<Character>>,
    toolbelt_query: Query<&Children, With<Toolbelt>>,
    mut tool_query: Query<&mut MovementTool>,
) {
    for event in sprint_events.read() {
        let character_id = match event {
            SprintEvent::Active { character_id, .. } => character_id,
            SprintEvent::Stop { character_id } => character_id,
        };
        let Ok(character) = character_query.get(*character_id) else {
            warn!("Character {:?} does not exist", character_id);
            continue;
        };
        let character_kids = character;

        let tool_ids = character_kids
            .iter()
            .filter_map(|kid| toolbelt_query.get(*kid).ok())
            .flat_map(|toolbelt| toolbelt.iter())
            .filter(|kid| tool_query.contains(**kid))
            .cloned()
            .collect_vec();

        match event {
            SprintEvent::Active { throttle, .. } => {
                let mut iter = tool_query.iter_many_mut(&tool_ids);
                while let Some(mut tool) = iter.fetch_next() {
                    tool.speed = (tool.default_speed, tool.sprint_speed).lerp(*throttle);
                }
            }
            SprintEvent::Stop { .. } => {
                let mut iter = tool_query.iter_many_mut(&tool_ids);
                while let Some(mut tool) = iter.fetch_next() {
                    tool.speed = tool.default_speed;
                }
            }
        }
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\agent\src\lib.rs

````rust
pub mod agent_movement_plugin;
pub mod agent_plugin;
pub mod agent_spawning_plugin;
pub mod insert_agent_toolbelt;

````



## D:\Repos\Games\Cursor-Hero\crates\character\src\lib.rs

````rust
pub mod character_appearance_plugin;
pub mod character_plugin;
pub mod character_spawning_plugin;

````



## D:\Repos\Games\Cursor-Hero\crates\memory_types\src\memory_types.rs

````rust
use std::fs::File;
use std::fs::OpenOptions;
use std::io::Read;
use std::io::Write;
use std::path::Path;
use std::path::PathBuf;

#[derive(Debug)]
#[allow(dead_code)]
pub enum PersistError {
    Io(std::io::Error),
    WindowBounds(cursor_hero_winutils::win_window::WindowBoundsError),
    Query,
    Json(serde_json::Error),
}

#[derive(Debug)]
pub enum PersistSuccess {
    WritePerformed,
    Debounce,
    Cooldown,
    NoAction,
}

#[derive(Debug)]
#[allow(dead_code)]
pub enum RestoreError {
    Io(std::io::Error),
    Json(serde_json::Error),
    Query,
}

#[derive(Debug)]
pub enum RestoreSuccess {
    Performed,
    NoAction,
}
pub enum Usage {
    Persist,
    Restore,
}

pub fn get_persist_file(
    current_path: &str,
    file_name: &str,
    usage: Usage,
) -> Result<std::fs::File, std::io::Error> {
    let mut file_path = PathBuf::new();

    #[cfg(debug_assertions)]
    {
        let dir = Path::new(current_path).parent().ok_or(std::io::Error::new(
            std::io::ErrorKind::NotFound,
            "Parent not found",
        ))?;
        file_path.push(dir);
    }

    file_path.push(file_name);

    let file = match usage {
        Usage::Persist => OpenOptions::new()
            .write(true)
            .truncate(true)
            .create(true)
            .open(file_path)?,
        Usage::Restore => OpenOptions::new().read(true).open(file_path)?,
    };
    Ok(file)
}

pub fn write_to_disk<T>(mut file: File, data: T) -> Result<PersistSuccess, PersistError>
where
    T: serde::Serialize,
{
    let serialized = serde_json::to_string_pretty(&data).map_err(PersistError::Json)?;
    file.write_all(serialized.as_bytes())
        .map_err(PersistError::Io)?;
    Ok(PersistSuccess::WritePerformed)
}

pub fn read_from_disk<T>(mut file: File) -> Result<T, RestoreError>
where
    T: serde::de::DeserializeOwned,
{
    let mut contents = String::new();
    file.read_to_string(&mut contents)
        .map_err(RestoreError::Io)?;
    let data = serde_json::from_str(&contents).map_err(RestoreError::Json)?;
    Ok(data)
}

````



## D:\Repos\Games\Cursor-Hero\crates\observation\src\lib.rs

````rust
pub mod observation_buffer_plugin;
pub mod observation_log_plugin;
pub mod observation_plugin;
pub mod observation_tool_plugin;
pub mod observe_chat_plugin;

````



## D:\Repos\Games\Cursor-Hero\crates\ollama\src\ollama_plugin.rs

````rust
use bevy::prelude::*;

use crate::ollama_button_plugin::OllamaButtonPlugin;
use crate::ollama_inference_plugin::OllamaInferencePlugin;
use crate::ollama_status_plugin::OllamaStatusPlugin;
use crate::ollama_status_worker_plugin::OllamaStatusWorkerPlugin;

pub struct OllamaPlugin;

impl Plugin for OllamaPlugin {
    fn build(&self, app: &mut App) {
        app.add_plugins(OllamaInferencePlugin);
        app.add_plugins(OllamaButtonPlugin);
        app.add_plugins(OllamaStatusPlugin);
        app.add_plugins(OllamaStatusWorkerPlugin);
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\ollama\src\ollama_button_plugin.rs

````rust
use bevy::prelude::*;
use bevy_xpbd_2d::prelude::*;
use cursor_hero_environment_types::prelude::*;
use cursor_hero_math::prelude::Lerp;
use cursor_hero_ollama_types::prelude::*;
use cursor_hero_pointer_types::prelude::*;
pub struct OllamaButtonPlugin;

impl Plugin for OllamaButtonPlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(Update, populate_new_host_environments);
        app.add_systems(Update, update_visuals);
        app.add_systems(Update, status_click_listener);
        app.add_systems(Update, terminal_click_listener);
        app.add_systems(Update, handle_terminal_events);
    }
}

fn populate_new_host_environments(
    mut commands: Commands,
    mut environment_events: EventReader<PopulateEnvironmentEvent>,
    environment_query: Query<(), With<HostEnvironment>>,
    asset_server: Res<AssetServer>,
) {
    for event in environment_events.read() {
        if !environment_query.contains(event.environment_id) {
            continue;
        };
        let environment_id = event.environment_id;
        info!(
            "Adding Ollama Server Control to new host environment {:?}",
            environment_id
        );
        commands.entity(environment_id).with_children(|parent| {
            parent
                .spawn((
                    OllamaStatusButton::default(),
                    Name::new("Ollama Server Control"),
                    SpriteBundle {
                        sprite: Sprite {
                            custom_size: Some(Vec2::new(200.0, 100.0)),
                            color: Color::PURPLE,
                            ..default()
                        },
                        transform: Transform::from_translation(Vec3::new(
                            1920.0 / 2.0,
                            -1080.0 - 200.0,
                            0.0,
                        )),
                        ..default()
                    },
                    Clickable,
                    Hoverable,
                    RigidBody::Static,
                    Sensor,
                    Collider::cuboid(200.0, 100.0),
                ))
                .with_children(|parent| {
                    parent.spawn((Text2dBundle {
                        text: Text::from_section(
                            "Ollama Server Control".to_string(),
                            TextStyle {
                                font: asset_server.load("fonts/FiraSans-Bold.ttf"),
                                font_size: 32.0,
                                color: Color::WHITE,
                            },
                        )
                        .with_alignment(TextAlignment::Center),
                        transform: Transform::from_xyz(0.0, 70.0, 1.0),
                        ..default()
                    },));
                });
            parent
                .spawn((
                    OllamaTerminalButton::default(),
                    Name::new("Ollama Terminal Button"),
                    SpriteBundle {
                        sprite: Sprite {
                            custom_size: Some(Vec2::new(200.0, 100.0)),
                            color: Color::rgb(0.0, 0.6, 0.8),
                            ..default()
                        },
                        transform: Transform::from_translation(Vec3::new(
                            1920.0 / 2.0,
                            -1080.0 - 350.0,
                            0.0,
                        )),
                        ..default()
                    },
                    Clickable,
                    Hoverable,
                    RigidBody::Static,
                    Sensor,
                    Collider::cuboid(200.0, 100.0),
                ))
                .with_children(|parent| {
                    parent.spawn((Text2dBundle {
                        text: Text::from_section(
                            "open terminal".to_string(),
                            TextStyle {
                                font: asset_server.load("fonts/FiraSans-Bold.ttf"),
                                font_size: 32.0,
                                color: Color::WHITE,
                            },
                        )
                        .with_alignment(TextAlignment::Center),
                        transform: Transform::from_xyz(0.0, 0.0, 1.0),
                        ..default()
                    },));
                });
        });
    }
}

fn update_visuals(
    mut events: EventReader<OllamaStatusEvent>,
    mut button_query: Query<(&mut Sprite, &Children, &mut OllamaStatusButton)>,
    mut button_text_query: Query<&mut Text>,
) {
    for event in events.read() {
        let OllamaStatusEvent::Changed { new_value: status } = event else {
            continue;
        };
        debug!("Updating Ollama Server Control visuals to {:?}", status);
        for button in button_query.iter_mut() {
            let (mut button_sprite, button_children, mut button) = button;
            button.visual_state = match button.visual_state {
                OllamaStatusButtonVisualState::Default { .. } => {
                    OllamaStatusButtonVisualState::Default { status: *status }
                }
                OllamaStatusButtonVisualState::Hovered { .. } => {
                    OllamaStatusButtonVisualState::Hovered { status: *status }
                }
                OllamaStatusButtonVisualState::Pressed { .. } => {
                    OllamaStatusButtonVisualState::Pressed { status: *status }
                }
            };
            match status {
                OllamaStatus::Alive => {
                    button_sprite.color = Color::GREEN;
                }
                OllamaStatus::Dead => {
                    button_sprite.color = Color::RED;
                }
                OllamaStatus::Unknown => {
                    button_sprite.color = Color::PURPLE;
                }
                OllamaStatus::Starting { instant, timeout } => {
                    button_sprite.color = Color::YELLOW
                        * (1.0, 0.1).lerp(instant.elapsed().as_secs_f32() / timeout.as_secs_f32());
                }
            }
            for child in button_children.iter() {
                if let Ok(mut text) = button_text_query.get_mut(*child) {
                    match status {
                        OllamaStatus::Alive => {
                            text.sections[0].value = "Ollama Server Control (Alive)".to_string();
                        }
                        OllamaStatus::Dead => {
                            text.sections[0].value = "Ollama Server Control (Dead)".to_string();
                        }
                        OllamaStatus::Unknown => {
                            text.sections[0].value = "Ollama Server Control (Unknown)".to_string();
                        }
                        OllamaStatus::Starting { instant, .. } => {
                            text.sections[0].value = format!(
                                "Ollama Server Control (Starting {}s ago)",
                                instant.elapsed().as_secs()
                            );
                        }
                    }
                }
            }
        }
    }

    for button in button_query.iter_mut() {
        let (mut sprite, children, button) = button;
        // if the visual state status is starting, update the text to show the time elapsed
        let (OllamaStatusButtonVisualState::Default {
            status: OllamaStatus::Starting { instant, timeout },
        }
        | OllamaStatusButtonVisualState::Hovered {
            status: OllamaStatus::Starting { instant, timeout },
        }
        | OllamaStatusButtonVisualState::Pressed {
            status: OllamaStatus::Starting { instant, timeout },
        }) = button.visual_state
        else {
            continue;
        };
        sprite.color = Color::YELLOW
            * (1.0, 0.1).lerp(instant.elapsed().as_secs_f32() / timeout.as_secs_f32());
        for child in children.iter() {
            if let Ok(mut text) = button_text_query.get_mut(*child) {
                text.sections[0].value = format!(
                    "Ollama Server Control (Starting {}s ago)",
                    instant.elapsed().as_secs()
                );
            }
        }
    }
}

fn status_click_listener(
    mut click_events: EventReader<ClickEvent>,
    button_query: Query<&OllamaStatusButton>,
    mut status_events: EventWriter<OllamaStatusEvent>,
) {
    for event in click_events.read() {
        let ClickEvent::Clicked {
            target_id,
            pointer_id: _,
            way,
        } = event
        else {
            continue;
        };
        if way != &Way::Left {
            continue;
        }
        if let Ok(button) = button_query.get(*target_id) {
            info!("Ollama Server Control clicked");
            // if the button visual status is alive, do nothing
            match button.visual_state {
                OllamaStatusButtonVisualState::Default {
                    status: OllamaStatus::Alive,
                }
                | OllamaStatusButtonVisualState::Hovered {
                    status: OllamaStatus::Alive,
                }
                | OllamaStatusButtonVisualState::Pressed {
                    status: OllamaStatus::Alive,
                } => {
                    warn!("Ollama Server Control is already alive");
                    continue;
                }
                _ => {}
            }
            let event = OllamaStatusEvent::Startup;
            debug!("Sending event {:?}", event);
            status_events.send(event);
        }
    }
}

fn terminal_click_listener(
    mut click_events: EventReader<ClickEvent>,
    button_query: Query<&OllamaTerminalButton>,
    mut terminal_events: EventWriter<OllamaTerminalEvent>,
) {
    for event in click_events.read() {
        let ClickEvent::Clicked {
            target_id,
            pointer_id: _,
            way,
        } = event
        else {
            continue;
        };
        if way != &Way::Left {
            continue;
        }
        if button_query.get(*target_id).is_ok() {
            info!("Ollama terminal clicked");
            let event = OllamaTerminalEvent::Startup;
            debug!("Sending event {:?}", event);
            terminal_events.send(event);
        }
    }
}

fn handle_terminal_events(mut terminal_events: EventReader<OllamaTerminalEvent>) {
    let should_start = terminal_events
        .read()
        .any(|event| matches!(event, OllamaTerminalEvent::Startup));
    if should_start {
        info!("Opening terminal");
        if let Err(e) = crate::ollama::start_terminal() {
            error!("Failed to start terminal: {:?}", e);
        }
    }
    terminal_events.clear();
}

````



## D:\Repos\Games\Cursor-Hero\crates\voice_to_text\src\lib.rs

````rust
#![feature(let_chains)]
pub mod voice_to_text;
pub mod voice_to_text_button_plugin;
pub mod voice_to_text_ping_plugin;
pub mod voice_to_text_plugin;
pub mod voice_to_text_worker_plugin;

pub mod prelude {
    pub use crate::voice_to_text_plugin::*;
}

````



## D:\Repos\Games\Cursor-Hero\crates\agent\src\insert_agent_toolbelt.rs

````rust
use bevy::prelude::*;
use cursor_hero_agent_types::agent_types::Agent;
use cursor_hero_character_types::prelude::*;
use cursor_hero_toolbelt_types::toolbelt_types::*;

pub struct InsertAgentToolbeltPlugin;

impl Plugin for InsertAgentToolbeltPlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(Update, insert_agent_toolbelt);
    }
}

pub fn insert_agent_toolbelt(
    mut commands: Commands,
    mut writer: EventWriter<ToolbeltPopulateEvent>,
    fresh_characters: Query<Entity, (Added<Agent>, With<Character>)>,
) {
    for character in fresh_characters.iter() {
        let character_id = character;
        commands.entity(character_id).with_children(|c_commands| {
            let toolbelt = c_commands.spawn(ToolbeltBundle::default());
            writer.send(ToolbeltPopulateEvent {
                id: toolbelt.id(),
                loadout: ToolbeltLoadout::Agent,
            });
            info!(
                "Sent populate agent toolbelt event for agent {:?}",
                character_id
            );
        });
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\memory\src\agent_observation_memory_plugin.rs

````rust
use bevy::prelude::*;
use bevy::utils::HashMap;
use cursor_hero_character_types::prelude::*;

use cursor_hero_memory_types::prelude::*;
use cursor_hero_observation_types::observation_types::ObservationBuffer;
use cursor_hero_observation_types::observation_types::SomethingObservableHappenedEvent;
use serde::Deserialize;
use serde::Serialize;

pub struct AgentObservationMemoryPlugin;

impl Plugin for AgentObservationMemoryPlugin {
    fn build(&self, app: &mut App) {
        app.insert_resource(MainCharacterMemoryConfig::default());
        app.add_systems(Update, persist.pipe(handle_persist_errors));
        app.add_systems(Update, restore.pipe(handle_restore_errors));
    }
}
const PERSIST_FILE_NAME: &str = "agent_memory.json";

// not moved to lib to ensure log contains this module name
fn handle_persist_errors(In(result): In<Result<PersistSuccess, PersistError>>) {
    if let Err(e) = result {
        error!("Persist error occurred: {:?}", e);
    } else if let Ok(PersistSuccess::WritePerformed) = result {
        debug!("Persisted succeeded");
    }
}

fn handle_restore_errors(In(result): In<Result<RestoreSuccess, RestoreError>>) {
    if let Err(e) = result {
        error!("Restore error occurred: {:?}", e);
    } else if let Ok(RestoreSuccess::Performed) = result {
        info!("Restore succeeded");
    }
}

#[derive(Debug, Resource, Reflect)]
#[reflect(Resource)]
struct MainCharacterMemoryConfig {
    pub persist_cooldown: Timer,
}
impl Default for MainCharacterMemoryConfig {
    fn default() -> Self {
        Self {
            persist_cooldown: Timer::from_seconds(10.0, TimerMode::Repeating),
        }
    }
}

#[derive(Debug, Serialize, Deserialize, PartialEq, Clone, Default)]
struct DiskData {
    observations_by_observer_name: HashMap<String, ObservationBuffer>,
}

fn persist(
    mut config: ResMut<MainCharacterMemoryConfig>,
    mut debounce: Local<Option<DiskData>>,
    time: Res<Time>,
    agent_query: Query<(&Name, &ObservationBuffer), With<AgentCharacter>>,
) -> Result<PersistSuccess, PersistError> {
    if !config.persist_cooldown.tick(time.delta()).just_finished() {
        return Ok(PersistSuccess::Cooldown);
    }

    let mut data = DiskData::default();
    for agent in agent_query.iter() {
        data.observations_by_observer_name
            .insert(agent.0.as_str().to_string(), agent.1.clone());
    }

    if debounce.is_none() || debounce.as_ref().unwrap() != &data {
        let file = get_persist_file(file!(), PERSIST_FILE_NAME, Usage::Persist)
            .map_err(PersistError::Io)?;
        write_to_disk(file, data.clone())?;
        *debounce = Some(data);
        Ok(PersistSuccess::WritePerformed)
    } else {
        Ok(PersistSuccess::Debounce)
    }
}

fn restore(
    mut agent_query: Query<(Entity, &Name, &mut ObservationBuffer), Added<AgentCharacter>>,
    mut observation_events: EventWriter<SomethingObservableHappenedEvent>,
) -> Result<RestoreSuccess, RestoreError> {
    if agent_query.is_empty() {
        return Ok(RestoreSuccess::NoAction);
    }

    let file =
        get_persist_file(file!(), PERSIST_FILE_NAME, Usage::Restore).map_err(RestoreError::Io)?;
    let mut data: DiskData = read_from_disk(file)?;
    info!(
        "Restoring agent memories, found {} entries",
        data.observations_by_observer_name.len()
    );
    for agent in agent_query.iter_mut() {
        let (agent_id, agent_name, mut agent_buffer) = agent;
        let agent_name = agent_name.as_str();
        // Each agent's observations is keyed by its name in the save file.
        if let Some(buffer) = data.observations_by_observer_name.remove(agent_name) {
            // Previous observations that reference entity IDs will have odd appearances in world inspectors because the IDs have been reused from restarts.

            *agent_buffer = buffer;

            let event = SomethingObservableHappenedEvent::MemoryRestored {
                observation_buffer_id: agent_id,
            };
            debug!("Sending event {:?}", event);
            observation_events.send(event);
        }
    }
    Ok(RestoreSuccess::Performed)
}

````



## D:\Repos\Games\Cursor-Hero\crates\bevy\src\neg_y.rs

````rust
use bevy::math::IRect;
use bevy::math::IVec2;
use bevy::math::IVec3;
use bevy::math::Rect;
use bevy::math::Vec2;
use bevy::math::Vec3;

pub trait NegativeYRect {
    fn neg_y(&self) -> Rect;
}
impl NegativeYRect for Rect {
    fn neg_y(&self) -> Rect {
        Rect::from_center_size(self.center().neg_y(), self.size())
    }
}

pub trait NegativeYIRect {
    fn neg_y(&self) -> IRect;
}
impl NegativeYIRect for IRect {
    fn neg_y(&self) -> IRect {
        IRect::from_center_size(self.center().neg_y(), self.size())
    }
}

pub trait NegativeYVec2 {
    fn neg_y(&self) -> Vec2;
}
impl NegativeYVec2 for Vec2 {
    fn neg_y(&self) -> Vec2 {
        Vec2::new(self.x, -self.y)
    }
}

pub trait NegativeYIVec2 {
    fn neg_y(&self) -> IVec2;
}
impl NegativeYIVec2 for IVec2 {
    fn neg_y(&self) -> IVec2 {
        IVec2::new(self.x, -self.y)
    }
}

pub trait NegativeYVec3 {
    fn neg_y(&self) -> Vec3;
}
impl NegativeYVec3 for Vec3 {
    fn neg_y(&self) -> Vec3 {
        Vec3::new(self.x, -self.y, self.z)
    }
}

pub trait NegativeYIVec3 {
    fn neg_y(&self) -> IVec3;
}
impl NegativeYIVec3 for IVec3 {
    fn neg_y(&self) -> IVec3 {
        IVec3::new(self.x, -self.y, self.z)
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\brick_types\src\lib.rs

````rust
pub mod brick_types;
pub mod brick_types_plugin;

pub mod prelude {
    pub use crate::brick_types::*;
    pub use crate::brick_types_plugin::*;
}

````



## D:\Repos\Games\Cursor-Hero\crates\screen\src\get_image.rs

````rust
use bevy::ecs::system::SystemParam;
use bevy::prelude::*;
use image::DynamicImage;
use image::RgbImage;

use crate::screen_plugin::Screen;

pub enum GetImageError {
    ElementEmpty,
}

#[derive(SystemParam)]
pub struct ScreensToImageParam<'w, 's> {
    pub images: Res<'w, Assets<Image>>,
    pub screens: Query<'w, 's, (&'static Handle<Image>, &'static GlobalTransform), With<Screen>>,
}

pub fn get_image(
    bounds: Rect,
    screen_access: &ScreensToImageParam,
) -> Result<Image, GetImageError> {
    if bounds.is_empty() {
        return Err(GetImageError::ElementEmpty);
    }
    let mut tex = RgbImage::new(bounds.width() as u32, bounds.height() as u32);

    // find out what parts of each screen are intersecting with the element
    for (screen_image_handle, screen_trans) in screen_access.screens.iter() {
        // find out the image size
        let screen_center_pos = screen_trans.translation();
        match screen_access.images.get(screen_image_handle) {
            None => {}
            Some(screen_image) => {
                // Calculate the overlapping area
                let screen_size = screen_image.texture_descriptor.size;
                let mut screen_origin = screen_center_pos.xy();
                screen_origin.y *= -1.0;
                let screen_rect = Rect::from_center_size(
                    screen_origin,
                    Vec2::new(screen_size.width as f32, screen_size.height as f32),
                );

                // find the overlap
                // debug!("screen_rect: {:?}", screen_rect);
                let intersection = screen_rect.intersect(bounds);
                // debug!("intersection rect: {:?}", intersection);

                // convert to monitor coordinates
                let origin = intersection.center() - screen_rect.min.xy();
                let tex_grab_rect = Rect::from_center_size(origin, intersection.size());
                // debug!("tex_grab_rect: {:?}", tex_grab_rect);

                if !tex_grab_rect.is_empty() {
                    // debug!(
                    //     "Copying pixel range {} by {}",
                    //     tex_grab_rect.size().x,
                    //     tex_grab_rect.size().y
                    // );

                    // Calculate where to start placing pixels in the element's texture
                    let texture_start_x = (intersection.min.x - bounds.min.x) as u32;
                    let texture_start_y = (intersection.min.y - bounds.min.y) as u32;
                    // debug!("Texture start: {} {}", texture_start_x, texture_start_y);
                    // Copy the overlapping part of the screen texture to the element's texture.
                    for y in tex_grab_rect.min.y as usize..tex_grab_rect.max.y as usize {
                        for x in tex_grab_rect.min.x as usize..tex_grab_rect.max.x as usize {
                            let start = (y * screen_size.width as usize + x) * 4;
                            if start + 4 <= screen_image.data.len() {
                                let pixel: [u8; 3] = [
                                    screen_image.data[start],
                                    screen_image.data[start + 1],
                                    screen_image.data[start + 2],
                                    // screen_image.data[start + 3],
                                ];
                                tex.put_pixel(
                                    texture_start_x + x as u32 - tex_grab_rect.min.x as u32,
                                    texture_start_y + y as u32 - tex_grab_rect.min.y as u32,
                                    image::Rgb(pixel),
                                );
                            }
                        }
                    }
                }
            }
        }
    }

    let dynamic_image = DynamicImage::ImageRgb8(tex);
    let image = Image::from_dynamic(dynamic_image, true);
    Ok(image)
    // let texture_handle = images.add(image);
}

````



## D:\Repos\Games\Cursor-Hero\crates\toolbelt_types\src\toolbelt_types_plugin.rs

````rust
use crate::toolbelt_types::*;
use bevy::prelude::*;

pub struct ToolbeltTypesPlugin;

impl Plugin for ToolbeltTypesPlugin {
    fn build(&self, app: &mut App) {
        app.register_type::<Toolbelt>();
        app.register_type::<Wheel>();
        app.register_type::<Tool>();
        app.register_type::<ActiveTool>();
        app.add_event::<ToolbeltPopulateEvent>();
        app.add_event::<ToolbeltOpeningEvent>();
        app.add_event::<ToolActivationEvent>();
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\window_position\src\window_position_tool_plugin.rs

````rust
use bevy::prelude::*;
use bevy::window::PrimaryWindow;
use bevy::window::WindowMode;
use bevy::window::WindowResolution;
use cursor_hero_bevy::prelude::BottomRightI;
use cursor_hero_bevy::prelude::CornerOfIRect;
use cursor_hero_bevy::prelude::IRectScale;
use cursor_hero_bevy::prelude::TopLeftI;
use cursor_hero_bevy::prelude::TranslateIVec2;
use cursor_hero_math::prelude::Corner;
use cursor_hero_toolbelt_types::prelude::ToolbeltPopulateEvent;
use cursor_hero_toolbelt_types::toolbelt_types::ActiveTool;
use cursor_hero_toolbelt_types::toolbelt_types::ToolbeltLoadout;
use cursor_hero_tools::prelude::NoInputs;
use cursor_hero_tools::prelude::ToolSpawnConfig;
use cursor_hero_tools::tool_spawning::StartingState;
use cursor_hero_window_position_types::prelude::HostWindowPosition;
use cursor_hero_window_position_types::prelude::WindowPositionTool;
use cursor_hero_window_position_types::window_position_types::WindowPositionCommand;
use cursor_hero_winutils::win_mouse::set_cursor_position;
use cursor_hero_winutils::win_screen_capture::get_all_monitors;
use cursor_hero_winutils::win_screen_capture::get_monitor_infos;
use cursor_hero_winutils::win_screen_capture::Monitor;
use image::ImageBuffer;
use image::Rgba;
pub struct WindowPositionToolPlugin;

impl Plugin for WindowPositionToolPlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(Update, populate_toolbelts);
        app.add_systems(Update, do_position);
    }
}

fn populate_toolbelts(
    mut commands: Commands,
    mut reader: EventReader<ToolbeltPopulateEvent>,
    mut textures: ResMut<Assets<Image>>,
) {
    for event in reader.read() {
        if event.loadout != ToolbeltLoadout::WindowPosition {
            continue;
        }
        let Ok(monitors) = get_all_monitors() else {
            warn!("No monitors found");
            continue;
        };
        let icon_size = UVec2::new(500, 500);

        let mut world = IRect::from_corners(
            monitors
                .iter()
                .map(|monitor| monitor.info.rect.top_left())
                .reduce(|a, b| a.min(b))
                .unwrap_or_default(),
            monitors
                .iter()
                .map(|monitor| monitor.info.rect.bottom_right())
                .reduce(|a, b| a.max(b))
                .unwrap_or_default(),
        );

        // expand it to be square aspect ratio
        if world.size().x > world.size().y {
            world = world.scale(Vec2::new(
                1.0,
                world.size().x as f32 / world.size().y as f32,
            ));
        } else {
            world = world.scale(Vec2::new(
                world.size().y as f32 / world.size().x as f32,
                1.0,
            ));
        }

        for monitor in monitors.iter() {
            for corner in Corner::variants() {
                let name = format!("{:?} Monitor {}", corner, monitor.info.name);

                let image = image_for_monitor_corner(icon_size, world, monitor, &corner);
                let texture = textures.add(image);

                ToolSpawnConfig::<WindowPositionTool, NoInputs>::new(
                    WindowPositionTool {
                        window_position: HostWindowPosition::Corner {
                            corner,
                            monitor: monitor.info.id,
                        },
                    },
                    event.id,
                    event,
                )
                .with_src_path(file!().into())
                .with_name(name.clone())
                .with_image(texture)
                .with_description("Moves the game window")
                .with_size(Vec2::new(100.0, 100.0))
                .with_starting_state(StartingState::Inactive)
                .spawn(&mut commands);
            }
            let name = format!("fullscreen_monitor_{}", monitor.info.id);
            ToolSpawnConfig::<WindowPositionTool, NoInputs>::new(
                WindowPositionTool {
                    window_position: HostWindowPosition::Fullscreen {
                        monitor: monitor.info.id,
                    },
                },
                event.id,
                event,
            )
            .with_src_path(file!().into())
            .with_name(name.clone())
            .with_image(textures.add(image_for_monitor(icon_size, world, monitor)))
            .with_description("Moves the game window")
            .with_size(Vec2::new(100.0, 100.0))
            .with_starting_state(StartingState::Inactive)
            .spawn(&mut commands);
        }
    }
}

fn image_for_monitor_corner(
    icon_size: UVec2,
    world: IRect,
    monitor: &Monitor,
    corner: &Corner,
) -> Image {
    let mut imgbuf =
        ImageBuffer::from_pixel(icon_size.x, icon_size.y, Rgba([173u8, 216u8, 230u8, 255u8])); // Light blue background

    let scale = icon_size.as_vec2() / world.size().as_vec2();
    let monitor_icon_region = monitor.info.rect.translate(&-world.min).scale(scale);
    debug!(
        "Monitor icon region: {:?}, scale: {:?}",
        monitor_icon_region, scale
    );

    let dest_icon_region = IRect::from_corners(
        monitor_icon_region.center(),
        corner.of(&monitor_icon_region),
    );
    for (x, y, pixel) in imgbuf.enumerate_pixels_mut() {
        if monitor_icon_region.contains(IVec2::new(x as i32, y as i32)) {
            *pixel = Rgba([255u8, 0u8, 0u8, 255u8]);
        }
        if dest_icon_region.contains(IVec2::new(x as i32, y as i32)) {
            *pixel = Rgba([0u8, 255u8, 0u8, 255u8]);
        }
    }
    Image::from_dynamic(imgbuf.into(), true)
}

fn image_for_monitor(icon_size: UVec2, world: IRect, monitor: &Monitor) -> Image {
    let mut imgbuf =
        ImageBuffer::from_pixel(icon_size.x, icon_size.y, Rgba([173u8, 216u8, 230u8, 255u8])); // Light blue background

    let scale = icon_size.as_vec2() / world.size().as_vec2();
    let monitor_icon_region = monitor.info.rect.translate(&-world.min).scale(scale);
    debug!(
        "Monitor icon region: {:?}, scale: {:?}",
        monitor_icon_region, scale
    );
    for (x, y, pixel) in imgbuf.enumerate_pixels_mut() {
        if monitor_icon_region.contains(IVec2::new(x as i32, y as i32)) {
            *pixel = Rgba([0u8, 0u8, 255u8, 255u8]);
        }
    }
    Image::from_dynamic(imgbuf.into(), true)
}

fn do_position(
    mut commands: Commands,
    tool_query: Query<(Entity, &WindowPositionTool), With<ActiveTool>>,
    mut window_query: Query<Entity, With<PrimaryWindow>>,
    mut window_commands: EventWriter<WindowPositionCommand>,
) {
    let Ok(monitor_infos) = get_monitor_infos() else {
        return;
    };

    for tool in tool_query.iter() {
        let (tool_id, tool) = tool;
        let Ok(window) = window_query.get_single_mut() else {
            error!("No primary window found");
            return;
        };
        let window_id = window;
        match tool.window_position {
            HostWindowPosition::Corner {
                ref corner,
                monitor,
            } => {
                let Some(monitor) = monitor_infos.iter().find(|info| info.id == monitor) else {
                    warn!("No monitor found with id: {}", monitor);
                    continue;
                };
                debug!(
                    "Activating corner: {:?} on monitor: {}",
                    corner, monitor.name
                );
                let dest_bounds = IRect::from_corners(
                    monitor.work_area.center(),
                    corner.of(&monitor.work_area)
                        - ((corner.of(&monitor.work_area) - monitor.work_area.center())
                            .as_vec2()
                            .normalize()
                            * 100.0)
                            .as_ivec2(),
                );
                window_commands.send(WindowPositionCommand {
                    window: window_id,
                    position: Some(WindowPosition::At(dest_bounds.top_left())),
                    resolution: Some(WindowResolution::new(
                        dest_bounds.width() as f32,
                        dest_bounds.height() as f32,
                    )),
                    mode: Some(WindowMode::Windowed),
                });
                if let Err(e) = set_cursor_position(dest_bounds.center()) {
                    warn!("Failed to set cursor position: {}", e);
                }
                commands.entity(tool_id).remove::<ActiveTool>();
            }
            HostWindowPosition::Fullscreen { monitor } => {
                let Some(monitor) = monitor_infos.iter().find(|info| info.id == monitor) else {
                    warn!("No monitor found with id: {}", monitor);
                    continue;
                };
                debug!("Activating fullscreen on monitor: {}", monitor.name);
                let margin = 50;
                window_commands.send(WindowPositionCommand {
                    window: window_id,
                    position: Some(WindowPosition::At(
                        monitor.work_area.top_left() + IVec2::splat(margin),
                    )),
                    resolution: Some(WindowResolution::new(
                        (monitor.work_area.width() + margin * 2) as f32,
                        (monitor.work_area.height() + margin * 2) as f32,
                    )),
                    mode: Some(WindowMode::Windowed),
                });
                // send second command to ensure fullscreen applies over the taskbar properly
                let cmd = WindowPositionCommand {
                    window: window_id,
                    // position: Some(WindowPosition::At(monitor.work_area.top_left())),
                    // resolution: Some(WindowResolution::new(
                    //     monitor.work_area.width() as f32,
                    //     monitor.work_area.height() as f32,
                    // )),
                    mode: Some(WindowMode::BorderlessFullscreen),
                    position: None,
                    resolution: None,
                };
                window_commands.send(cmd);

                if let Err(e) = set_cursor_position(monitor.work_area.center()) {
                    warn!("Failed to set cursor position: {}", e);
                }
                commands.entity(tool_id).remove::<ActiveTool>();
            }
        }
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\physics\src\lib.rs

````rust
pub mod damping_plugin;
pub mod physics_plugin;

````



## D:\Repos\Games\Cursor-Hero\crates\brick\src\brick_plugin.rs

````rust
use bevy::prelude::*;

pub struct BrickPlugin;

impl Plugin for BrickPlugin {
    fn build(&self, _app: &mut App) {}
}

````



## D:\Repos\Games\Cursor-Hero\crates\pointer_types\src\pointer_click_types.rs

````rust
use bevy::prelude::*;

#[derive(Component, Reflect, Debug)]
pub struct Clickable;

#[derive(Reflect, Debug)]
pub struct PointerPress {
    pub pointer_id: Entity,
    pub way: Way,
}
#[derive(Component, Reflect, Debug)]
pub struct Pressed {
    pub presses: Vec<PointerPress>,
}

#[derive(Reflect, Debug, Hash, PartialEq, Eq, Copy, Clone)]
pub struct TargetPress {
    pub target_id: Entity,
    pub way: Way,
}
#[derive(Component, Reflect, Debug)]
pub struct Pressing {
    pub pressing: Vec<TargetPress>,
}

#[derive(Reflect, Debug, Clone, Copy, Eq, PartialEq, Hash)]
pub enum Way {
    Left,
    Right,
    Middle,
}

#[derive(Event, Debug, Reflect)]
pub enum ClickEvent {
    Pressed {
        target_id: Entity,
        pointer_id: Entity,
        way: Way,
    },
    Released {
        target_id: Entity,
        pointer_id: Entity,
        way: Way,
    },
    Clicked {
        target_id: Entity,
        pointer_id: Entity,
        way: Way,
    },
}
#[derive(Event, Debug, Reflect)]
pub enum ToolClickEvent {
    Pressed { pointer_id: Entity, way: Way },
    Released { pointer_id: Entity, way: Way },
}

````



## D:\Repos\Games\Cursor-Hero\crates\fullscreen_tool\src\fullscreen_tool_tick_plugin.rs

````rust
use bevy::prelude::*;
use bevy::window::PrimaryWindow;
use cursor_hero_fullscreen_tool_types::prelude::*;
use cursor_hero_toolbelt_types::prelude::*;
use cursor_hero_tools::tool_spawning::StartingState;

pub struct FullscreenToolTickPlugin;

impl Plugin for FullscreenToolTickPlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(Update, handle_toggle);
        app.add_systems(Update, match_window_state);
    }
}

fn match_window_state(
    mut commands: Commands,
    tool_query: Query<(Entity, Option<&ActiveTool>), With<FullscreenTool>>,
    window_query: Query<&Window, With<PrimaryWindow>>,
) {
    let Some(mode) = window_query.iter().map(|w| w.mode).next() else {
        warn!("No window found");
        return;
    };
    for tool in tool_query.iter() {
        let (tool_id, tool_active) = tool;
        let desired_state = FullscreenTool::state_for_mode(mode);
        if tool_active == desired_state.as_active().as_ref() {
            continue;
        }
        match desired_state {
            StartingState::Active => {
                info!("Activating FullscreenTool without event to match window state");
                commands.entity(tool_id).insert(ActiveTool);
            }
            StartingState::Inactive => {
                info!("Deactivating FullscreenTool without event to match window state");
                commands.entity(tool_id).remove::<ActiveTool>();
            }
        }
    }
}

fn handle_toggle(
    tool_query: Query<(), With<FullscreenTool>>,
    mut window_query: Query<&mut Window, With<PrimaryWindow>>,
    mut tool_events: EventReader<ToolActivationEvent>,
) {
    for event in tool_events.read() {
        match event {
            ToolActivationEvent::Activate(tool_id) if tool_query.contains(*tool_id) => {
                info!("FullscreenTool activated, setting window to fullscreen.");
                if window_query.is_empty() {
                    warn!("No window found");
                    continue;
                }
                for mut window in window_query.iter_mut() {
                    window.mode = bevy::window::WindowMode::BorderlessFullscreen;
                }
            }
            ToolActivationEvent::Deactivate(tool_id) if tool_query.contains(*tool_id) => {
                info!("FullscreenTool deactivated, setting window to windowed.");
                if window_query.is_empty() {
                    warn!("No window found");
                    continue;
                }
                for mut window in window_query.iter_mut() {
                    window.mode = bevy::window::WindowMode::Windowed;
                }
            }
            _ => {}
        }
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\bevy\src\rect_with_properties.rs

````rust
use bevy::math::Rect;
use bevy::math::Vec2;

pub trait RectWithHeight {
    fn with_height(&self, height: f32) -> Rect;
}
impl RectWithHeight for Rect {
    fn with_height(&self, height: f32) -> Rect {
        Rect::from_center_size(self.center(), Vec2::new(self.width(), height))
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\agent_types\src\agent_types_plugin.rs

````rust
use bevy::prelude::*;

use crate::prelude::*;

pub struct AgentTypesPlugin;

impl Plugin for AgentTypesPlugin {
    fn build(&self, app: &mut App) {
        app.register_type::<Agent>();
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\pointer_types\src\pointer_action_types.rs

````rust
use bevy::prelude::*;
use leafwing_input_manager::prelude::*;
use leafwing_input_manager::user_input::InputKind;

pub struct PointerActionPlugin;

impl Plugin for PointerActionPlugin {
    fn build(&self, app: &mut App) {
        app.add_plugins(InputManagerPlugin::<PointerAction>::default());
    }
}

#[derive(Actionlike, PartialEq, Eq, Clone, Copy, Hash, Debug, Reflect)]
pub enum PointerAction {
    Move,
}

impl PointerAction {
    fn default_gamepad_binding(&self) -> UserInput {
        match self {
            Self::Move => UserInput::Single(InputKind::DualAxis(DualAxis::right_stick())),
        }
    }

    fn default_mkb_binding(&self) -> UserInput {
        match self {
            Self::Move => UserInput::VirtualDPad(VirtualDPad::arrow_keys()),
        }
    }

    pub fn default_input_map() -> InputMap<PointerAction> {
        let mut input_map = InputMap::default();

        for variant in PointerAction::variants() {
            input_map.insert(variant.default_mkb_binding(), variant);
            input_map.insert(variant.default_gamepad_binding(), variant);
        }
        input_map
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\physics_debug\src\lib.rs

````rust
pub mod physics_debug_plugin;

````



## D:\Repos\Games\Cursor-Hero\crates\ui_automation\examples\calculator_example.rs

````rust
#![feature(let_chains)]
use bevy::input::common_conditions::input_toggle_active;
use bevy::log::LogPlugin;
use bevy::prelude::*;
use bevy::window::PrimaryWindow;
use bevy_egui::egui;
use bevy_egui::EguiContexts;
use bevy_egui::EguiSet;
use bevy_inspector_egui::quick::WorldInspectorPlugin;
use bevy_inspector_egui::reflect_inspector::Context;
use bevy_inspector_egui::reflect_inspector::InspectorUi;
use cursor_hero_memory::primary_window_memory_plugin::PrimaryWindowMemoryPlugin;
use cursor_hero_ui_automation::prelude::*;
use cursor_hero_winutils::win_mouse::get_cursor_position;
use cursor_hero_worker::prelude::Message;
use cursor_hero_worker::prelude::Sender;
use cursor_hero_worker::prelude::WorkerConfig;
use cursor_hero_worker::prelude::WorkerPlugin;
fn main() {
    let mut app = App::new();
    app.add_plugins(
        DefaultPlugins
            .set(LogPlugin {
                level: bevy::log::Level::DEBUG,
                filter: "
info,
wgpu_core=warn,
wgpu_hal=warn,
calculator_example=trace,
cursor_hero_worker=debug,
"
                .replace('\n', "")
                .trim()
                .into(),
            })
            .build(),
    );
    app.add_plugins(WorkerPlugin {
        config: WorkerConfig::<ThreadboundUISnapshotMessage, GameboundUISnapshotMessage> {
            name: "calculator".to_string(),
            is_ui_automation_thread: true,
            handle_threadbound_message: handle_threadbound_message,
            ..default()
        },
    });
    app.add_plugins(
        WorldInspectorPlugin::default().run_if(input_toggle_active(false, KeyCode::Grave)),
    );
    app.add_plugins(PrimaryWindowMemoryPlugin);
    app.insert_resource(ClearColor(Color::rgb(0.992, 0.714, 0.69)));
    app.add_systems(Startup, spawn_camera);
    app.add_systems(
        Update,
        step_1_of_making_the_calculators_in_the_game_match_the_calculator_apps_running_in_the_host,
    );
    app.add_systems(
        Update,
        step_2_of_making_the_calculators_in_the_game_match_the_calculator_apps_running_in_the_host,
    );
    app.run();
}

fn spawn_camera(mut commands: Commands) {
    commands.spawn(Camera2dBundle::default());
}

#[derive(Debug, Reflect, Clone, Event)]
enum ThreadboundUISnapshotMessage {
    RequestUISnapshot,
}
impl Message for ThreadboundUISnapshotMessage {}

#[derive(Debug, Reflect, Clone, Event)]
enum GameboundUISnapshotMessage {
    UISnapshot(UISnapshot),
}
impl Message for GameboundUISnapshotMessage {}

fn handle_threadbound_message(
    msg: &ThreadboundUISnapshotMessage,
    reply_tx: &Sender<GameboundUISnapshotMessage>,
) -> Result<(), Box<dyn std::error::Error>> {
    let ThreadboundUISnapshotMessage::RequestUISnapshot = msg;
    debug!("getting state of host calculators");
    let snapshot = take_snapshot()?;
    if let Err(e) = reply_tx.send(GameboundUISnapshotMessage::UISnapshot(snapshot)) {
        error!("Failed to send snapshot: {:?}", e);
    }
    Ok(())
}

fn step_1_of_making_the_calculators_in_the_game_match_the_calculator_apps_running_in_the_host(
    // mut data: ResMut<UIData>,
    mut cooldown: Local<Option<Timer>>,
    time: Res<Time>,
    mut events: EventWriter<ThreadboundUISnapshotMessage>,
    window: Query<&Window, With<PrimaryWindow>>,
) {
    let Ok(window) = window.get_single() else {
        return;
    };
    if window.cursor_position().is_some() {
        return;
    }
    let cooldown_over = if let Some(cooldown) = cooldown.as_mut() {
        if cooldown.tick(time.delta()).just_finished() {
            cooldown.reset();
            true
        } else {
            false
        }
    } else {
        cooldown.replace(Timer::from_seconds(0.5, TimerMode::Repeating));
        true
    };
    if !cooldown_over {
        return;
    }

    // if data.in_flight {
    //     warn!("Too fast!");
    //     return;
    // }

    events.send(ThreadboundUISnapshotMessage::RequestUISnapshot);
    // data.in_flight = true;
}

fn step_2_of_making_the_calculators_in_the_game_match_the_calculator_apps_running_in_the_host(
    mut snapshot: EventReader<GameboundUISnapshotMessage>,
    calculator_query: Query<&Calculator>,
    mut commands: Commands,
) {
    for msg in snapshot.read() {
        let GameboundUISnapshotMessage::UISnapshot(snapshot) = msg;
        // debug!("Received snapshot: {:?}", snapshot);
        for app in snapshot.app_windows.iter() {
            let AppWindow::Calculator(calculator) = app else {
                continue;
            };
            debug!("Received calculator: {:?}", calculator);
        }
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\hover\src\lib.rs

````rust
#![feature(let_chains)]
pub mod hover_tool;
pub mod hover_ui_automation_plugin;
pub mod inspect_wheel_tool;
pub mod screenshot_tool;

````



## D:\Repos\Games\Cursor-Hero\crates\ollama\src\ollama.rs

````rust
use cursor_hero_inference_types::inference_types::TextInferenceOptions;
use cursor_hero_ollama_types::ollama_types::OllamaStatus;
use reqwest::Client;
use std::error::Error;

use serde::Deserialize;

#[derive(Debug, Deserialize)]
struct ApiResponse {
    response: String,
}

pub async fn generate(
    prompt: &str,
    options: Option<TextInferenceOptions>,
) -> Result<String, Box<dyn Error>> {
    let mut payload = serde_json::json!({
        "model": "whatevs",
        "prompt": prompt,
        "stream": false
    });
    if let Some(options) = options {
        // create empty object
        let mut options_json = serde_json::json!({});

        if let Some(num_predict) = options.num_predict {
            options_json["num_predict"] = serde_json::json!(num_predict);
        }

        if let Some(stop) = options.stop {
            options_json["stop"] = serde_json::json!(stop);
        }

        payload["options"] = options_json;
    }

    let client = Client::new();

    let res = client
        .post("http://localhost:11434/api/generate")
        .json(&payload)
        .send()
        .await?;

    if res.status().is_success() {
        let api_response = res.json::<ApiResponse>().await?;
        let mut text = api_response.response.as_str();
        text = text.trim_end_matches("<dummy32000>");
        text = text.trim();
        Ok(text.to_string())
    } else {
        let status = res.status();
        let body = res.text().await?;
        Err(Box::new(std::io::Error::new(
            std::io::ErrorKind::Other,
            format!("Failed to call API. Status: {} Body: {}", status, body),
        )))
    }
}

pub async fn get_status() -> Result<OllamaStatus, Box<dyn Error>> {
    let client = Client::new();
    match client.get("http://localhost:11434/").send().await {
        Ok(res) => match res.status().is_success() {
            true => Ok(OllamaStatus::Alive),
            false => Ok(OllamaStatus::Dead),
        },
        Err(_) => Ok(OllamaStatus::Dead),
    }
}

pub fn start() -> Result<(), Box<dyn Error>> {
    // wt --window 0 --profile "Ubuntu-22.04" --colorScheme "Ubuntu-22.04-ColorScheme" --title "Ollama Serve" wsl -d Ubuntu-22.04 -- ollama serve
    match std::process::Command::new("wt")
        .args([
            "--window",
            "0",
            "--profile",
            "Ubuntu 22.04.3 LTS",
            "--colorScheme",
            "Ubuntu-22.04-ColorScheme",
            "--title",
            "Ollama Serve",
            "wsl",
            "-d",
            "Ubuntu-22.04",
            "--",
            "ollama",
            "serve",
        ])
        .spawn()
    {
        Ok(_) => Ok(()),
        Err(e) => Err(Box::new(e)),
    }
}

pub fn start_terminal() -> Result<(), Box<dyn Error>> {
    match std::process::Command::new("wt")
        .args([
            "--window",
            "0",
            "--profile",
            "Ubuntu 22.04.3 LTS",
            "--colorScheme",
            "Ubuntu-22.04-ColorScheme",
            "--title",
            "Ollama",
            "wsl",
            "-d",
            "Ubuntu-22.04",
            "--",
            "bash",
            "-l",
            "-c",
            "cd ~ && exec pwsh",
        ])
        .spawn()
    {
        Ok(_) => Ok(()),
        Err(e) => Err(Box::new(e)),
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\wallpaper\src\lib.rs

````rust
pub mod wallpaper_plugin;

````



## D:\Repos\Games\Cursor-Hero\crates\memory_types\src\memory_types_plugin.rs

````rust
use bevy::prelude::*;
// use crate::prelude::*;

pub struct MemoryTypesPlugin;

impl Plugin for MemoryTypesPlugin {
    fn build(&self, _app: &mut App) {}
}

````



## D:\Repos\Games\Cursor-Hero\crates\ui_automation\src\gather_element_info.rs

````rust
use bevy::math::Rect;
use cursor_hero_ui_automation_types::prelude::DrillId;
use cursor_hero_ui_automation_types::prelude::ElementInfo;
use itertools::Itertools;
use std::collections::VecDeque;
use uiautomation::Error;
use uiautomation::UIAutomation;
use uiautomation::UIElement;
use uiautomation::UITreeWalker;

use crate::gather_children::GatherChildrenable;
use crate::gather_children::StopBehaviour;

pub struct GatherUITreeOkResult {
    pub ui_tree: ElementInfo,
    pub start_info: ElementInfo,
}
pub fn gather_incomplete_ui_tree_starting_deep(
    start_element: UIElement,
) -> Result<GatherUITreeOkResult, Error> {
    let automation = UIAutomation::new()?;
    let walker = automation.create_tree_walker()?;
    let ancestors = collect_ancestors(&start_element, &walker)?;
    // println!("ancestors: {:?}", ancestors);

    let root_element = ancestors
        .front()
        .ok_or(Error::new(-1, "No root element found"))?
        .clone();
    let mut root_info = gather_tree(&root_element, &walker, &ancestors, 0)?;
    root_info.drill_id = DrillId::Root;

    update_drill_ids(root_info.children.as_mut(), &DrillId::Root);

    let start_info = root_info
        .get_descendents()
        .into_iter()
        .find(|info| Ok(&info.runtime_id) == start_element.get_runtime_id().as_ref())
        .cloned();
    let Some(start_info) = start_info else {
        return Err(Error::new(
            -1,
            format!(
                "Start element {:?} (id: {:?}) not found in tree: {:?}",
                start_element,
                start_element.get_runtime_id(),
                root_info
            )
            .as_str(),
        ));
    };
    // let start_info = start_info.unwrap_or_else(|| root_info.clone());

    Ok(GatherUITreeOkResult {
        ui_tree: root_info,
        start_info,
    })
}

fn collect_ancestors(
    element: &UIElement,
    walker: &UITreeWalker,
) -> Result<VecDeque<UIElement>, Error> {
    let mut ancestors = VecDeque::new();
    let mut current_element = Some(element.clone());
    while let Some(elem) = current_element {
        ancestors.push_front(elem.clone());
        current_element = walker.get_parent(&elem).ok();
    }
    Ok(ancestors)
}

fn gather_tree(
    element: &UIElement,
    walker: &UITreeWalker,
    ancestors: &VecDeque<UIElement>,
    depth: usize,
) -> Result<ElementInfo, Error> {
    let is_ancestor = |element: &UIElement| {
        ancestors
            .iter()
            .any(|ancestor| ancestor.get_runtime_id() == element.get_runtime_id())
    };
    let on_ancestor = is_ancestor(element);
    let mut element_info = gather_single_element_info(element)?;

    if on_ancestor {
        let children = element
            .gather_children(
                walker,
                if depth == 0 {
                    &StopBehaviour::RootEndEncountered
                } else {
                    &StopBehaviour::EndOfSiblings
                },
            )
            .into_iter()
            .enumerate()
            .filter_map(|(i, child)| {
                if is_ancestor(&child) {
                    gather_tree(&child, walker, ancestors, depth + 1).ok()
                } else {
                    gather_single_element_info(&child).ok()
                }
                .map(|mut child_info| {
                    child_info.drill_id = DrillId::Child(vec![i].into_iter().collect());
                    child_info
                })
            })
            .collect_vec();

        element_info.children = Some(children);
    }

    Ok(element_info)
}

pub fn update_drill_ids(children: Option<&mut Vec<ElementInfo>>, ancestor_path: &DrillId) {
    if let Some(children) = children {
        for child_info in children.iter_mut() {
            // Check if the child has a base drill_id set
            if let DrillId::Child(base_drill_id) = &child_info.drill_id {
                let mut new_path = ancestor_path.clone();
                if let Some(&child_position) = base_drill_id.back() {
                    new_path = match new_path {
                        DrillId::Root | DrillId::Unknown => {
                            DrillId::Child(vec![child_position].into())
                        }
                        DrillId::Child(ref mut path) => {
                            let mut new_path = path.clone();
                            new_path.push_back(child_position);
                            DrillId::Child(new_path)
                        }
                    };

                    // Update the child's drill_id by concatenating the ancestor_path with its own position
                    child_info.drill_id = new_path.clone();
                }

                // Recursively update this child's children
                update_drill_ids(child_info.children.as_mut(), &new_path);
            }
        }
    }
}

pub fn gather_single_element_info(element: &UIElement) -> Result<ElementInfo, uiautomation::Error> {
    let name = element.get_name()?;
    let bb = element.get_bounding_rectangle()?;
    let class_name = element.get_classname()?;
    let control_type = element.get_control_type()?.into();
    let localized_control_type = element.get_localized_control_type()?;
    let automation_id = element.get_automation_id()?;
    let runtime_id = element.get_runtime_id()?;

    let info = ElementInfo {
        name,
        bounding_rect: Rect::new(
            bb.get_left() as f32,
            bb.get_top() as f32,
            bb.get_right() as f32,
            bb.get_bottom() as f32,
        ),
        control_type,
        localized_control_type,
        class_name,
        automation_id,
        runtime_id,
        children: None,
        drill_id: DrillId::Unknown,
    };
    Ok(info)
}

#[cfg(test)]
mod tests {
    use super::*;
    use uiautomation::UIAutomation;

    /// Discord doesn't play nice with new UIAutomaion
    ///
    /// Element children aren't shown like they are in the MSAA tree
    #[test]
    fn test_gather_discord_element_info() {
        let automation = UIAutomation::new().unwrap();
        let walker = automation.create_tree_walker().unwrap();
        let start = automation
            .element_from_point(uiautomation::types::Point::new(2359, 959))
            .unwrap();
        println!("start {:#?}", start);
        let info = gather_single_element_info(&start).unwrap();
        println!("info {:#?}", info);

        // let parent = walker.get_parent(&start).unwrap();
        // let parent_info = gather_single_element_info(&parent).unwrap();
        // println!("parent_info {:#?}", parent_info);

        let ancestors = collect_ancestors(&start, &walker).unwrap();
        println!("got {} ancestors", ancestors.len());
        // println!("ancestors {:#?}", ancestors);
        for ancestor in ancestors.iter().skip(1) {
            print!(
                "ancestor {:?} (runtimeid={:?})\t",
                ancestor,
                ancestor.get_runtime_id()
            );
            for behaviour in vec![
                StopBehaviour::EndOfSiblings,
                // StopBehaviour::LastChildEncountered,
                // StopBehaviour::TaskbarEndEncountered,
                // StopBehaviour::RootEndEncountered,
            ] {
                let children = ancestor
                    .gather_children(&walker, &behaviour)
                    .into_iter()
                    .map(|child| gather_single_element_info(&child).unwrap())
                    .collect::<Vec<_>>();
                if children.is_empty() {
                    eprintln!("No children found using {:?}", behaviour);
                }
                println!("children using {:?} {:#?}", behaviour, children.len());
            }
        }

        let gathered = gather_incomplete_ui_tree_starting_deep(start).unwrap();
        // println!("tree {:#?}", gathered.ui_tree);
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\winutils\examples\app_icons_bevy_example.rs

````rust
use bevy::input::common_conditions::input_toggle_active;
use bevy::log::LogPlugin;
use bevy::prelude::*;
use bevy::utils::HashMap;
use bevy_inspector_egui::quick::WorldInspectorPlugin;
use cursor_hero_winutils::win_errors::*;
use cursor_hero_winutils::win_icons::get_images_from_exe;
use cursor_hero_winutils::win_process::*;
use cursor_hero_worker::prelude::*;
use image::DynamicImage;
use image::RgbaImage;
use windows::core::PWSTR;
use windows::Win32::Foundation::E_ACCESSDENIED;
fn main() {
    let mut app = App::new();
    app.add_plugins(
        DefaultPlugins
            .set(LogPlugin {
                level: bevy::log::Level::DEBUG,
                filter: "
info,
wgpu_core=warn,
wgpu_hal=warn,
cursor_hero=debug,
app_icons_bevy_example=trace,
"
                .replace('\n', "")
                .trim()
                .into(),
            })
            .build(),
    );
    app.add_plugins(WorkerPlugin {
        config: WorkerConfig::<ThreadboundMessage, GameboundMessage> {
            name: "ui_snapshot".to_string(),
            is_ui_automation_thread: true,
            handle_threadbound_message: |msg, reply_tx| {
                handle_threadbound_message(msg, reply_tx).map_err(|e| Box::new(e) as _)
            },
            ..default()
        },
    });
    app.add_systems(Update, receive);
    app.add_systems(Startup, trigger);
    app.add_systems(Startup, camera_setup);
    app.add_plugins(
        WorldInspectorPlugin::default().run_if(input_toggle_active(false, KeyCode::Grave)),
    );
    app.run();
}

#[derive(Debug, Reflect, Clone, Event)]
enum ThreadboundMessage {
    GatherRunningProcessIcons,
}
impl Message for ThreadboundMessage {}

#[derive(Debug, Clone, Event)]
enum GameboundMessage {
    RunningProcessIcons(HashMap<String, Vec<RgbaImage>>),
}
impl Message for GameboundMessage {}

fn handle_threadbound_message(
    msg: &ThreadboundMessage,
    reply_tx: &Sender<GameboundMessage>,
) -> Result<()> {
    let ThreadboundMessage::GatherRunningProcessIcons = msg;
    let process_iter = ProcessIterator::new()?;
    let mut result = HashMap::new();
    unsafe {
        for mut process in process_iter {
            let exe_name_pwstr = PWSTR(process.szExeFile.as_mut_ptr());
            let exe_name = exe_name_pwstr.to_string()?;
            let exe_path = match get_process_full_name(process.th32ProcessID) {
                Ok(s) => s,
                Err(e) => {
                    if matches!(
                        e,
                        Error::Windows(ref e) if e.code() == E_ACCESSDENIED
                    ) {
                        continue;
                    }
                    warn!(
                        "Failed to get full process name for PID {:05} ({}): {:?}",
                        process.th32ProcessID, exe_name, e
                    );
                    continue;
                }
            };
            if result.contains_key(&exe_path) {
                continue;
            }
            let icons = get_images_from_exe(exe_path.as_str())?;
            result.insert(exe_path, icons);
        }
    }
    if let Err(e) = reply_tx.send(GameboundMessage::RunningProcessIcons(result)) {
        error!("Failed to send snapshot: {:?}", e);
    }

    Ok(())
}

fn camera_setup(mut commands: Commands) {
    commands.spawn(Camera2dBundle::default());
    // commands.spawn((
    //     SpriteBundle {
    //         transform: Transform::from_translation(Vec3::new(0.0, 0.0, 0.0)),
    //         sprite: Sprite {
    //             color: Color::WHITE,
    //             custom_size: Some(Vec2::new(100.0, 100.0)),
    //             ..default()
    //         },
    //         ..default()
    //     },
    // ));
}

fn trigger(mut events: EventWriter<ThreadboundMessage>) {
    events.send(ThreadboundMessage::GatherRunningProcessIcons);
}

fn receive(
    mut commands: Commands,
    mut bridge: EventReader<GameboundMessage>,
    mut icons_so_far: Local<usize>,
    mut textures: ResMut<Assets<Image>>,
) {
    for msg in bridge.read() {
        match msg {
            GameboundMessage::RunningProcessIcons(icons) => {
                info!("Received icons: {:?}", icons.len());
                for (exe_path, images) in icons {
                    for image in images {
                        debug!("{}x{}", image.width(), image.height());
                        let dynamic = DynamicImage::ImageRgba8(image.clone());
                        let handle = textures.add(Image::from_dynamic(dynamic, true));
                        let icons_per_row = 5;
                        let icon_size = 100.0;
                        let margin = 10.0;
                        commands.spawn((
                            SpriteBundle {
                                texture: handle,
                                transform: Transform::from_translation(Vec3::new(
                                    (*icons_so_far % icons_per_row) as f32 * (icon_size + margin),
                                    (*icons_so_far / icons_per_row) as f32 * (icon_size + margin),
                                    0.0,
                                )),
                                sprite: Sprite {
                                    color: Color::hsl(
                                        *icons_so_far as f32 / icons.len() as f32 * 360.0,
                                        1.0,
                                        0.5,
                                    ),
                                    custom_size: Some(Vec2::splat(icon_size)),
                                    ..default()
                                },
                                ..default()
                            },
                            Name::new(exe_path.clone()),
                        ));
                        *icons_so_far += 1;
                    }
                }
            }
        }
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\ollama_types\src\ollama_types.rs

````rust
use std::time::Duration;

use bevy::prelude::*;
use bevy::utils::Instant;

#[derive(Reflect, Resource, Default, Debug, Eq, PartialEq, Clone, Copy)]
#[reflect(Resource)]
pub enum OllamaStatus {
    #[default]
    Unknown,
    Alive,
    Dead,
    Starting {
        instant: Instant,
        timeout: Duration,
    },
}

#[derive(Component, Debug, Reflect, Default)]
pub struct OllamaStatusButton {
    pub visual_state: OllamaStatusButtonVisualState,
}

#[derive(Debug, Reflect, Eq, PartialEq)]
pub enum OllamaStatusButtonVisualState {
    Default { status: OllamaStatus },
    Hovered { status: OllamaStatus },
    Pressed { status: OllamaStatus },
}
impl Default for OllamaStatusButtonVisualState {
    fn default() -> Self {
        OllamaStatusButtonVisualState::Default {
            status: OllamaStatus::Unknown,
        }
    }
}

#[derive(Event, Debug, Reflect)]
pub enum OllamaPingEvent {
    Ping,
    Pong { status: OllamaStatus },
}

#[derive(Event, Debug, Reflect)]
pub enum OllamaStatusEvent {
    Changed { new_value: OllamaStatus },
    Startup,
}

#[derive(Component, Debug, Reflect, Default)]
pub struct OllamaTerminalButton {
    pub visual_state: OllamaTerminalButtonVisualState,
}
#[derive(Debug, Reflect, Eq, PartialEq, Default)]
pub enum OllamaTerminalButtonVisualState {
    #[default]
    Default,
}
#[derive(Event, Debug, Reflect)]
pub enum OllamaTerminalEvent {
    Startup,
}

````



## D:\Repos\Games\Cursor-Hero\crates\sprint_tool\src\sprint_tool_plugin.rs

````rust
use bevy::prelude::*;
use cursor_hero_character_types::prelude::*;
use cursor_hero_sprint_tool_types::sprint_tool_types_plugin::SprintEvent;
use cursor_hero_toolbelt_types::prelude::*;
use cursor_hero_tools::prelude::*;
use leafwing_input_manager::prelude::*;

pub struct SprintToolPlugin;

impl Plugin for SprintToolPlugin {
    fn build(&self, app: &mut App) {
        // TODO: move to sprint_tool_types crate
        app.register_type::<SprintTool>();
        app.register_type::<SpawnedCube>();
        app.add_plugins(InputManagerPlugin::<SprintToolAction>::default());
        app.add_systems(Update, (toolbelt_events, handle_input));
    }
}

#[derive(Component, Reflect, Default)]
struct SprintTool;
#[derive(Actionlike, PartialEq, Eq, Clone, Copy, Hash, Debug, Reflect)]
enum SprintToolAction {
    Sprint,
}

impl SprintToolAction {
    fn default_gamepad_binding(&self) -> UserInput {
        match self {
            Self::Sprint => GamepadButtonType::LeftTrigger2.into(),
        }
    }

    fn default_mkb_binding(&self) -> UserInput {
        match self {
            Self::Sprint => KeyCode::ShiftLeft.into(),
        }
    }
}
impl ToolAction for SprintToolAction {
    fn default_input_map(_event: &ToolbeltPopulateEvent) -> Option<InputMap<SprintToolAction>> {
        let mut input_map = InputMap::default();

        for variant in SprintToolAction::variants() {
            input_map.insert(variant.default_mkb_binding(), variant);
            input_map.insert(variant.default_gamepad_binding(), variant);
        }
        Some(input_map)
    }
}

fn toolbelt_events(
    mut commands: Commands,
    asset_server: Res<AssetServer>,
    mut reader: EventReader<ToolbeltPopulateEvent>,
) {
    for event in reader.read() {
        let (ToolbeltLoadout::Default | ToolbeltLoadout::Inspector | ToolbeltLoadout::Keyboard) =
            event.loadout
        else {
            continue;
        };
        ToolSpawnConfig::<SprintTool, SprintToolAction>::new(SprintTool, event.id, event)
            .with_src_path(file!().into())
            .guess_name(file!())
            .guess_image(file!(), &asset_server, "png")
            .with_description("Go faster, reach further")
            .spawn(&mut commands);
    }
}

#[derive(Component, Reflect)]
pub struct SpawnedCube;

fn handle_input(
    sprint_tool_query: Query<(&ActionState<SprintToolAction>, &Parent), With<ActiveTool>>,
    toolbelt_query: Query<&Parent, With<Toolbelt>>,
    mut character_query: Query<Entity, With<Character>>,
    mut sprint_events: EventWriter<SprintEvent>,
) {
    for sprint_tool in sprint_tool_query.iter() {
        let (tool_actions, tool_parent) = sprint_tool;

        let Ok(toolbelt) = toolbelt_query.get(tool_parent.get()) else {
            warn!("Tool not inside a toolbelt?");
            continue;
        };
        let toolbelt_parent = toolbelt;
        let Ok(character) = character_query.get_mut(toolbelt_parent.get()) else {
            warn!("Toolbelt parent not a character?");
            continue;
        };
        let character_id = character;

        if tool_actions.pressed(SprintToolAction::Sprint) {
            if tool_actions.just_pressed(SprintToolAction::Sprint) {
                debug!("Sprint tool action just pressed");
            }
            let mut throttle = tool_actions.value(SprintToolAction::Sprint);
            throttle = throttle.powf(2.0);
            sprint_events.send(SprintEvent::Active {
                character_id,
                throttle,
            });
        } else if tool_actions.just_released(SprintToolAction::Sprint) {
            debug!("Sprint tool action released");
            sprint_events.send(SprintEvent::Stop { character_id });
        }
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\pointer\src\pointer_spawning_plugin.rs

````rust
use bevy::prelude::*;
use bevy::sprite::Anchor;
use bevy_xpbd_2d::prelude::*;
use cursor_hero_character_types::prelude::*;
use cursor_hero_environment_types::environment_types::TrackEnvironmentTag;
use cursor_hero_pointer_types::prelude::*;
use leafwing_input_manager::prelude::*;

pub struct PointerSpawningPlugin;

impl Plugin for PointerSpawningPlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(Update, insert_pointer);
    }
}

#[allow(clippy::type_complexity)]
fn insert_pointer(
    mut commands: Commands,
    asset_server: Res<AssetServer>,
    character: Query<(Entity, Option<&MainCharacter>, Option<&AgentCharacter>), Added<Character>>,
) {
    for character in character.iter() {
        let (character_id, is_main_character, is_agent_character) = character;
        info!("Creating pointer for character '{:?}'", character_id);
        commands.entity(character_id).with_children(|parent| {
            let mut p = parent.spawn((
                Name::new("Pointer"),
                SpriteBundle {
                    texture: asset_server.load("textures/cursor.png"),
                    transform: Transform::from_xyz(0.0, 0.0, 2.0),
                    sprite: Sprite {
                        color: Color::rgb(0.149, 0.549, 0.184),
                        anchor: Anchor::TopLeft,
                        ..default()
                    },
                    ..Default::default()
                },
                TrackEnvironmentTag,
                RigidBody::Dynamic,
                Collider::cuboid(10.0, 10.0),
                Sensor,
            ));
            match (is_main_character.is_some(), is_agent_character.is_some()) {
                (true, false) => {
                    p.insert((
                        MainPointer,
                        Pointer::new_host_pointer(),
                        InputManagerBundle::<PointerAction> {
                            input_map: PointerAction::default_input_map(),
                            action_state: ActionState::default(),
                        },
                    ));
                }
                (false, true) => {
                    p.insert((
                        Pointer::new_agent_pointer(),
                        InputManagerBundle::<PointerAction> {
                            input_map: InputMap::default(),
                            action_state: ActionState::default(),
                        },
                    ));
                }
                (is_main, is_agent) => {
                    error!(
                        "Character '{:?}' isn't exclusively main or agent: main: {:?}, agent: {:?}",
                        character_id, is_main, is_agent
                    );
                    p.insert((
                        Pointer::new_unknown_pointer(),
                        InputManagerBundle::<PointerAction> {
                            input_map: InputMap::default(),
                            action_state: ActionState::default(),
                        },
                    ));
                }
            }
        });
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\host_event_types\src\host_event_types_plugin.rs

````rust
use crate::prelude::*;
use bevy::prelude::*;

pub struct HostEventTypesPlugin;

impl Plugin for HostEventTypesPlugin {
    fn build(&self, app: &mut App) {
        app.add_event::<HostEvent>();
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\voice_to_text\src\voice_to_text_worker_plugin.rs

````rust
use bevy::prelude::*;
use crossbeam_channel::bounded;
use crossbeam_channel::Receiver;
use crossbeam_channel::Sender;
use cursor_hero_secret_types::secrets_types::SecretString;
use cursor_hero_voice_to_text_types::prelude::*;
use std::thread;
use std::time::Duration;
use std::time::Instant;

pub struct VoiceToTextWorkerPlugin;

impl Plugin for VoiceToTextWorkerPlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(Startup, create_worker_thread);
        app.add_systems(Update, events_to_bridge);
        app.add_systems(Update, bridge_to_events);
    }
}

#[derive(Debug)]
pub(crate) enum GameboundMessage {
    Pong { status: VoiceToTextStatus },
    Starting { api_key: SecretString },
    TranscriptionReceived { transcription: String },
}

#[derive(Debug)]
enum ThreadboundMessage {
    Ping,
    Startup,
    SetListening {
        listening: bool,
        api_key: SecretString,
    },
    ConnectReceiver {
        api_key: SecretString,
    },
}

#[derive(Resource)]
struct Bridge {
    pub sender: Sender<ThreadboundMessage>,
    pub receiver: Receiver<GameboundMessage>,
}

fn create_worker_thread(mut commands: Commands) {
    let (game_tx, game_rx) = bounded::<_>(10);
    let (thread_tx, thread_rx) = bounded::<_>(10);
    commands.insert_resource(Bridge {
        sender: thread_tx,
        receiver: game_rx,
    });

    let game_tx_clone = game_tx.clone();
    thread::Builder::new()
        .name("Voice2Text status thread".to_string())
        .spawn(move || {
            let rt = tokio::runtime::Runtime::new().unwrap();
            rt.block_on(async {
                let game_tx = game_tx_clone;
                loop {
                    let msg = match thread_rx.recv() {
                        Ok(msg) => msg,
                        Err(_) => {
                            error!("Threadbound channel failure, exiting");
                            break;
                        }
                    };
                    match msg {
                        ThreadboundMessage::Ping => {
                            debug!("Worker received ping request, pinging VoiceToText API");
                            let status = match crate::voice_to_text::get_status().await {
                                Ok(status) => status,
                                Err(e) => {
                                    error!("Failed to get status: {:?}", e);
                                    VoiceToTextStatus::Unknown
                                }
                            };
                            if let Err(e) = game_tx.send(GameboundMessage::Pong { status }) {
                                error!("Gamebound channel failure, exiting: {}", e);
                                break;
                            }
                        }
                        ThreadboundMessage::Startup => {
                            debug!("Worker received startup request, starting VoiceToText API");
                            match crate::voice_to_text::start() {
                                Ok(api_key) => {
                                    debug!("VoiceToText API started successfully");
                                    if let Err(e) =
                                        game_tx.send(GameboundMessage::Starting { api_key })
                                    {
                                        error!("Gamebound channel failure, exiting: {}", e);
                                        break;
                                    }
                                }
                                Err(e) => {
                                    error!("Failed to start: {:?}", e);
                                }
                            };
                        }
                        ThreadboundMessage::SetListening { listening, api_key } => {
                            debug!("Worker received set listening request: {}", listening);
                            match crate::voice_to_text::set_listening(listening, api_key).await {
                                Ok(()) => {
                                    info!(
                                        "VoiceToText API set listening={} successfully",
                                        listening
                                    );
                                }
                                Err(e) => {
                                    error!("Failed to set listening: {:?}", e);
                                }
                            }
                        }
                        ThreadboundMessage::ConnectReceiver { api_key } => {
                            info!("Worker received connect receiver request");
                            match crate::voice_to_text::connect_receiver(game_tx.clone(), api_key)
                                .await
                            {
                                Ok(()) => {
                                    info!("VoiceToText API connected receiver successfully");
                                }
                                Err(e) => {
                                    error!("Failed to connect receiver: {:?}", e);
                                }
                            }
                        }
                    }
                    std::thread::sleep(std::time::Duration::from_millis(50));
                }
            });
        })
        .expect("Failed to spawn thread");
}

fn events_to_bridge(
    bridge: ResMut<Bridge>,
    mut ping_events: EventReader<VoiceToTextPingEvent>,
    mut command_events: EventReader<VoiceToTextCommandEvent>,
) {
    // Detect ping requests
    for event in ping_events.read() {
        let VoiceToTextPingEvent::Ping = event else {
            continue;
        };
        let msg = ThreadboundMessage::Ping;
        debug!("Sending bridge message: {:?}", msg);
        if let Err(e) = bridge.sender.send(msg) {
            error!("Threadbound channel failure: {}", e);
        }
    }

    for event in command_events.read() {
        let msg = match event {
            VoiceToTextCommandEvent::Startup => ThreadboundMessage::Startup,
            VoiceToTextCommandEvent::SetListening { listening, api_key } => {
                ThreadboundMessage::SetListening {
                    listening: *listening,
                    api_key: api_key.clone(),
                }
            }
            VoiceToTextCommandEvent::ConnectReceiver { api_key } => {
                ThreadboundMessage::ConnectReceiver {
                    api_key: api_key.clone(),
                }
            }
        };
        debug!("Sending bridge message: {:?}", msg);
        if let Err(e) = bridge.sender.send(msg) {
            error!("Threadbound channel failure: {}", e);
        }
    }
}

fn bridge_to_events(
    bridge: ResMut<Bridge>,
    mut ping_events: EventWriter<VoiceToTextPingEvent>,
    mut status_events: EventWriter<VoiceToTextStatusEvent>,
    mut transcription_events: EventWriter<VoiceToTextTranscriptionEvent>,
    mut current_status: ResMut<VoiceToTextStatus>,
) {
    for msg in bridge.receiver.try_iter() {
        match msg {
            GameboundMessage::Pong { status } => {
                let event = VoiceToTextPingEvent::Pong { status };
                debug!("Received bridge response, sending game event {:?}", event);
                ping_events.send(event);
            }
            GameboundMessage::Starting { api_key } => {
                let new_status = VoiceToTextStatus::Starting {
                    instant: Instant::now(),
                    timeout: Duration::from_secs(60),
                    api_key: api_key.clone(),
                };
                let event = VoiceToTextStatusEvent::Changed {
                    old_status: current_status.clone(),
                    new_status: new_status.clone(),
                };
                debug!("Received bridge response, sending game event {:?}", event);
                status_events.send(event);

                *current_status = new_status;
            }
            GameboundMessage::TranscriptionReceived { transcription } => {
                let event = VoiceToTextTranscriptionEvent::Received { transcription };
                debug!("Received bridge response, sending game event {:?}", event);
                transcription_events.send(event);
            }
        }
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\math\src\lerp.rs

````rust
pub trait Lerp {
    fn lerp(self, open: f32) -> f32;
}

impl Lerp for (f32, f32) {
    fn lerp(self, open: f32) -> f32 {
        let (start, end) = self;
        start + (end - start) * open.clamp(0.0, 1.0)
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\host_event\src\lib.rs

````rust
pub mod host_event_plugin;

pub mod prelude {
    pub use crate::host_event_plugin::*;
}

````



## D:\Repos\Games\Cursor-Hero\crates\inference_types\src\lib.rs

````rust
pub mod inference_types;
pub mod inference_types_plugin;
pub mod prompt_types;

pub mod prelude {
    pub use crate::inference_types::*;
    pub use crate::inference_types_plugin::InferenceTypesPlugin;
    pub use crate::prompt_types::*;
}

````



## D:\Repos\Games\Cursor-Hero\crates\chat\src\chat_input_buffer_plugin.rs

````rust
use bevy::prelude::*;
use cursor_hero_character_types::character_types::Character;
use cursor_hero_chat_types::prelude::*;
use cursor_hero_toolbelt_types::prelude::*;
use leafwing_input_manager::action_state::ActionState;

pub struct ChatInputBufferPlugin;

impl Plugin for ChatInputBufferPlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(Update, handle_char);
        app.add_systems(Update, handle_input);
    }
}

fn handle_char(
    mut tool_query: Query<(Entity, &mut ChatTool, &Parent), With<ActiveTool>>,
    toolbelt_query: Query<&Parent, With<Toolbelt>>,
    character_query: Query<Entity, With<Character>>,
    mut chat_input_events: EventWriter<ChatInputEvent>,
    mut character_events: EventReader<ReceivedCharacter>,
) {
    for event in character_events.read() {
        if event.char.is_control() {
            continue;
        }
        for tool in tool_query.iter_mut() {
            let (tool_id, mut tool, tool_parent) = tool;
            if !tool.focused {
                continue;
            }
            let Ok(toolbelt) = toolbelt_query.get(tool_parent.get()) else {
                warn!("Tool not inside a toolbelt?");
                continue;
            };
            let toolbelt_parent = toolbelt;
            let Ok(character) = character_query.get(toolbelt_parent.get()) else {
                warn!("Toolbelt parent not a character?");
                continue;
            };
            let character_id = character;
            tool.buffer.push(event.char);
            chat_input_events.send(ChatInputEvent::TextChanged {
                tool_id,
                toolbelt_id: tool_parent.get(),
                character_id,
            });
            debug!(
                "Appended char '{}' ({}) to chat buffer. New: {}",
                event.char, event.char as u32, tool.buffer
            );
        }
    }
}

fn handle_input(
    mut tool_query: Query<
        (Entity, &mut ChatTool, &ActionState<ChatToolAction>, &Parent),
        With<ActiveTool>,
    >,
    toolbelt_query: Query<&Parent, With<Toolbelt>>,
    character_query: Query<Entity, With<Character>>,
    mut chat_input_events: EventWriter<ChatInputEvent>,
    time: Res<Time>,
) {
    for tool in tool_query.iter_mut() {
        let (tool_id, mut tool, tool_actions, tool_parent) = tool;
        if !tool.focused {
            continue;
        }
        let input_active = tool_actions.pressed(ChatToolAction::Backspace);
        match (input_active, &mut tool.state) {
            // no input is active, return to default state
            (false, state) => {
                if *state != ChatToolState::Idle {
                    tool.state = ChatToolState::Idle;
                }
                continue;
            }
            // first input, start initial delay
            (true, ChatToolState::Idle) => {
                tool.state =
                    ChatToolState::InitialRepeatDelay(Timer::from_seconds(0.5, TimerMode::Once));
            }
            // check initial delay finished, start repeat delay
            (true, ChatToolState::InitialRepeatDelay(ref mut timer)) => {
                if timer.tick(time.delta()).just_finished() {
                    tool.state =
                        ChatToolState::RepeatDelay(Timer::from_seconds(0.03, TimerMode::Repeating));
                } else {
                    continue;
                }
            }
            // been held, continue repeat delay
            (true, ChatToolState::RepeatDelay(ref mut timer)) => {
                if !timer.tick(time.delta()).just_finished() {
                    continue;
                }
            }
        }

        let Ok(toolbelt) = toolbelt_query.get(tool_parent.get()) else {
            warn!("Tool not inside a toolbelt?");
            continue;
        };
        let toolbelt_parent = toolbelt;
        let Ok(character) = character_query.get(toolbelt_parent.get()) else {
            warn!("Toolbelt parent not a character?");
            continue;
        };
        let character_id = character;
        let original_buffer = tool.buffer.clone();
        if tool_actions.pressed(ChatToolAction::Backspace) {
            if tool_actions.pressed(ChatToolAction::WordModifier) {
                // delete word
                while let Some(c) = tool.buffer.pop() {
                    if c.is_whitespace() {
                        break;
                    }
                }
            } else {
                tool.buffer.pop();
            }
        }
        if original_buffer == tool.buffer {
            continue;
        }
        chat_input_events.send(ChatInputEvent::TextChanged {
            tool_id,
            toolbelt_id: tool_parent.get(),
            character_id,
        });
        debug!("Updated chat buffer. New: {}", tool.buffer);
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\start_menu\src\start_menu_button_plugin.rs

````rust
use bevy::prelude::*;
use bevy_xpbd_2d::components::Collider;
use bevy_xpbd_2d::components::RigidBody;
use bevy_xpbd_2d::components::Sensor;
use cursor_hero_pointer_types::prelude::*;
use cursor_hero_start_menu_types::prelude::*;
use cursor_hero_taskbar_types::prelude::*;

pub struct StartMenuButtonPlugin;

impl Plugin for StartMenuButtonPlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(Update, add_start_menu_button_to_new_taskbars);
        app.add_systems(Update, click_listener);
        app.add_systems(Update, visuals);
    }
}

fn add_start_menu_button_to_new_taskbars(
    asset_server: Res<AssetServer>,
    mut commands: Commands,
    mut taskbar_events: EventReader<TaskbarEvent>,
    taskbar_query: Query<(&Taskbar, &Transform, &Parent)>,
) {
    for event in taskbar_events.read() {
        let TaskbarEvent::Populate { taskbar_id } = event;
        let Ok(taskbar) = taskbar_query.get(*taskbar_id) else {
            warn!("Taskbar {:?} not found", taskbar_id);
            continue;
        };
        let (taskbar, taskbar_transform, taskbar_parent) = taskbar;
        let taskbar_size = taskbar.size;
        let start_menu_button_size = Vec2::new(48.0, 40.0);
        let start_menu_button_translation = Vec3::new(
            -taskbar_size.x / 2.0 + start_menu_button_size.x / 2.0,
            0.0,
            1.0,
        ) + taskbar_transform.translation;
        info!("Adding start menu button for taskbar {:?}", taskbar_id);
        commands
            .entity(taskbar_parent.get())
            .with_children(|parent| {
                parent.spawn((
                    SpriteBundle {
                        sprite: Sprite {
                            custom_size: Some(start_menu_button_size),
                            ..default()
                        },
                        texture: asset_server
                            .load("textures/environment/game/start_menu_button.png"),
                        transform: Transform::from_translation(start_menu_button_translation),
                        ..Default::default()
                    },
                    RigidBody::Static,
                    Collider::cuboid(start_menu_button_size.x, start_menu_button_size.y),
                    Sensor,
                    Name::new("Start Menu Button"),
                    StartMenuButton,
                    Hoverable,
                    Clickable,
                ));
            });
    }
}

fn click_listener(
    mut click_events: EventReader<ClickEvent>,
    start_menu_button_query: Query<&Children, With<StartMenuButton>>,
    start_menu_query: Query<(), With<StartMenu>>,
    mut start_menu_events: EventWriter<StartMenuEvent>,
) {
    for event in click_events.read() {
        let ClickEvent::Clicked {
            target_id,
            pointer_id: _,
            way,
        } = event
        else {
            continue;
        };
        if way != &Way::Left {
            continue;
        }
        if let Ok(children) = start_menu_button_query.get(*target_id) {
            info!("Start menu button clicked");
            let open = children
                .iter()
                .any(|child| start_menu_query.get(*child).is_ok());
            if open {
                start_menu_events.send(StartMenuEvent::Close {
                    start_menu_button_id: *target_id,
                });
            } else {
                start_menu_events.send(StartMenuEvent::Open {
                    start_menu_button_id: *target_id,
                });
            }
        }
    }
}

enum VisualState {
    Normal,
    Hovered,
    Pressed,
}

#[allow(clippy::type_complexity)]
fn visuals(
    mut start_menu_button_query: Query<
        (&mut Sprite, Option<&Pressed>, Option<&Hovered>),
        With<StartMenuButton>,
    >,
) {
    for (mut sprite, pressed, hovered) in start_menu_button_query.iter_mut() {
        let mut visual_state = VisualState::Normal;
        if pressed.is_some() {
            visual_state = VisualState::Pressed;
        } else if hovered.is_some() {
            visual_state = VisualState::Hovered;
        }
        match visual_state {
            VisualState::Normal => {
                sprite.color = Color::WHITE;
            }
            VisualState::Hovered => {
                sprite.color = Color::ORANGE_RED;
            }
            VisualState::Pressed => {
                sprite.color = Color::RED;
            }
        }
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\fullscreen_tool_types\src\fullscreen_tool_types.rs

````rust
use bevy::prelude::*;
use bevy::window::WindowMode;
use bevy_inspector_egui::prelude::ReflectInspectorOptions;
use bevy_inspector_egui::InspectorOptions;
use cursor_hero_tools::tool_spawning::StartingState;

#[derive(Component, Reflect, Debug, InspectorOptions, Default)]
#[reflect(Component, InspectorOptions)]
pub struct FullscreenTool;

impl FullscreenTool {
    pub fn state_for_mode(mode: WindowMode) -> StartingState {
        match mode {
            WindowMode::Windowed => StartingState::Inactive,
            _ => StartingState::Active,
        }
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\voice_to_text_types\src\voice_to_text_types_plugin.rs

````rust
use crate::prelude::*;
use bevy::prelude::*;

pub struct VoiceToTextTypesPlugin;

impl Plugin for VoiceToTextTypesPlugin {
    fn build(&self, app: &mut App) {
        app.register_type::<VoiceToTextStatus>();
        app.register_type::<VoiceToTextStatusButton>();
        app.register_type::<VoiceToTextStatusButtonVisualState>();
        app.register_type::<VoiceToTextStatusEvent>();
        app.add_event::<VoiceToTextStatusEvent>();

        app.register_type::<VoiceToTextPingEvent>();
        app.add_event::<VoiceToTextPingEvent>();

        app.register_type::<VoiceToTextTranscriptionEvent>();
        app.add_event::<VoiceToTextTranscriptionEvent>();

        app.register_type::<VoiceToTextCommandEvent>();
        app.add_event::<VoiceToTextCommandEvent>();

        app.register_type::<VoiceToTextVscodeButton>();
        app.register_type::<VoiceToTextVscodeButtonVisualState>();
        app.register_type::<VoiceToTextVscodeEvent>();
        app.add_event::<VoiceToTextVscodeEvent>();
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\start_menu\src\lib.rs

````rust
pub mod start_menu_button_plugin;
pub mod start_menu_plugin;

pub mod prelude {
    pub use crate::start_menu_plugin::*;
}

````



## D:\Repos\Games\Cursor-Hero\crates\winutils\src\win_wallpaper.rs

````rust
use std::env;
use std::ffi::OsString;
use std::os::raw::c_void;
use std::os::windows::ffi::OsStringExt;
use std::path::PathBuf;
use windows::Win32::UI::WindowsAndMessaging::SystemParametersInfoW;
use windows::Win32::UI::WindowsAndMessaging::SPIF_UPDATEINIFILE;
use windows::Win32::UI::WindowsAndMessaging::SPI_GETDESKWALLPAPER;
/// This gets the path to the file at the time the user set the wallpaper.
/// The file may have moved since then.
pub fn get_wallpaper_path() -> Result<OsString, windows::core::Error> {
    let mut buffer = vec![0u16; 32768]; // theoretical max path after increase
    unsafe {
        SystemParametersInfoW(
            SPI_GETDESKWALLPAPER,
            buffer.len() as u32,
            Some(buffer.as_mut_ptr() as *mut c_void),
            SPIF_UPDATEINIFILE,
        )
    }?;

    // Find the position of the first null character
    let len = buffer.iter().position(|&c| c == 0).unwrap_or(buffer.len());

    // Create a slice of the buffer up to the found position
    let trimmed_buffer = &buffer[..len];

    Ok(OsString::from_wide(trimmed_buffer))
}

pub fn get_transcoded_wallpaper_path() -> Result<PathBuf, env::VarError> {
    let app_data = env::var("APPDATA")?; // Get the value of the APPDATA environment variable
    let themes_path =
        PathBuf::from(app_data).join("Microsoft\\Windows\\Themes\\TranscodedWallpaper");
    Ok(themes_path)
}

#[cfg(test)]
mod tests {
    #[test]
    fn test_get_wallpaper_path() {
        let path = super::get_wallpaper_path();
        println!("Wallpaper path: {:?}", path);
        assert!(path.is_ok());
    }

    #[test]
    fn test_get_transcoded_wallpaper_path() {
        let path = super::get_transcoded_wallpaper_path();
        println!("Transcoded wallpaper path: {:?}", path);
        assert!(path.is_ok());
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\toolbelt\src\tool_help_cleanup.rs

````rust
use bevy::prelude::*;

use cursor_hero_toolbelt_types::toolbelt_types::ToolHelp;

pub fn tool_help_cleanup(
    mut commands: Commands,
    mut tool_help_query: Query<(Entity, &mut ToolHelp)>,
    time: Res<Time>,
) {
    for (tool_help_id, mut tool_help) in &mut tool_help_query {
        if tool_help.timer.tick(time.delta()).just_finished() {
            commands.entity(tool_help_id).despawn_recursive();
        }
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\agent_types\src\agent_types.rs

````rust
use bevy::prelude::*;

#[derive(Component, Reflect, Debug)]
pub struct Agent;

#[derive(Reflect, Eq, PartialEq, Debug)]
pub enum AgentAppearance {
    Default,
}
impl AgentAppearance {
    pub fn get_texture_path(&self) -> &'static str {
        match self {
            Self::Default => "textures/agent/default_agent.png",
        }
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\glados_tts\src\glados_tts_status_plugin.rs

````rust
use std::time::Duration;

use bevy::prelude::*;
use bevy::utils::Instant;
use cursor_hero_glados_tts_types::prelude::*;

pub struct GladosTtsStatusPlugin;

impl Plugin for GladosTtsStatusPlugin {
    fn build(&self, app: &mut App) {
        app.init_resource::<GladosTtsStatus>();
        app.add_systems(Update, handle_startup_event);
        app.add_systems(Update, periodic_ping);
        app.add_systems(Update, handle_pong);
    }
}

fn handle_startup_event(
    mut status_events: ParamSet<(
        EventReader<GladosTtsStatusEvent>,
        EventWriter<GladosTtsStatusEvent>,
    )>,
    mut glados_tts_status: ResMut<GladosTtsStatus>,
) {
    let starting = status_events
        .p0()
        .read()
        .any(|event| matches!(event, GladosTtsStatusEvent::Startup));
    if !starting {
        return;
    }
    status_events.p0().clear();

    *glados_tts_status = GladosTtsStatus::Starting {
        instant: Instant::now(),
        timeout: Duration::from_secs(60),
    };
    let event = GladosTtsStatusEvent::Changed {
        new_value: *glados_tts_status,
    };
    debug!("Sending event {:?}", event);
    status_events.p1().send(event);
}

fn periodic_ping(
    mut ping_events: EventWriter<GladosTtsPingEvent>,
    mut last_ping: Local<Option<Instant>>,
) {
    if let Some(instant) = *last_ping {
        if instant.elapsed().as_secs() > 5 {
            ping_events.send(GladosTtsPingEvent::Ping);
            *last_ping = Some(Instant::now());
        }
    } else {
        ping_events.send(GladosTtsPingEvent::Ping);
        *last_ping = Some(Instant::now());
    }
}

fn handle_pong(
    mut ping_events: EventReader<GladosTtsPingEvent>,
    mut status_events: EventWriter<GladosTtsStatusEvent>,
    mut glados_tts_status: ResMut<GladosTtsStatus>,
) {
    for event in ping_events.read() {
        let GladosTtsPingEvent::Pong { status } = event else {
            continue;
        };
        // identify the new state based on the pong
        let new_status = match (*glados_tts_status, *status) {
            // if starting, only change to dead if the timeout has been exceeded
            (GladosTtsStatus::Starting { instant, timeout }, status) => {
                if status == GladosTtsStatus::Alive {
                    GladosTtsStatus::Alive
                } else if instant.elapsed() > timeout {
                    GladosTtsStatus::Dead
                } else {
                    GladosTtsStatus::Starting { instant, timeout }
                }
            }
            // respect the new status if it's not starting
            _ => *status,
        };

        if *glados_tts_status != new_status {
            *glados_tts_status = new_status;
            let event = GladosTtsStatusEvent::Changed {
                new_value: new_status,
            };
            debug!("Sending event {:?}", event);
            status_events.send(event);
        }
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\movement_tool\src\movement_speed_plugin.rs

````rust
use bevy::prelude::*;
use cursor_hero_character_types::prelude::*;
use cursor_hero_input::active_input_state_plugin::InputMethod;
use cursor_hero_movement_tool_types::prelude::*;
use cursor_hero_toolbelt_types::prelude::*;

pub struct MovementSpeedPlugin;

impl Plugin for MovementSpeedPlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(OnEnter(InputMethod::MouseAndKeyboard), set_mnk_speed);
        app.add_systems(OnEnter(InputMethod::Gamepad), set_gamepad_speed);
    }
}

fn set_mnk_speed(
    mut tool_query: Query<(&mut MovementTool, &Parent), With<MovementTool>>,
    toolbelt_query: Query<&Parent, With<Toolbelt>>,
    character_query: Query<(), With<MainCharacter>>,
) {
    for tool in tool_query.iter_mut() {
        let (mut tool, tool_parent) = tool;
        let Ok(toolbelt) = toolbelt_query.get(tool_parent.get()) else {
            continue;
        };
        if character_query.get(toolbelt.get()).is_err() {
            continue;
        }
        *tool = MovementTool {
            target: tool.target,
            ..MovementTool::default_mnk()
        };
    }
}

fn set_gamepad_speed(
    mut tool_query: Query<(&mut MovementTool, &Parent), With<MovementTool>>,
    toolbelt_query: Query<&Parent, With<Toolbelt>>,
    character_query: Query<(), With<MainCharacter>>,
) {
    for tool in tool_query.iter_mut() {
        let (mut tool, tool_parent) = tool;
        let Ok(toolbelt) = toolbelt_query.get(tool_parent.get()) else {
            continue;
        };
        if character_query.get(toolbelt.get()).is_err() {
            continue;
        }
        *tool = MovementTool {
            target: tool.target,
            ..MovementTool::default_gamepad()
        };
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\tools\src\cube_tool.rs

````rust
use bevy::prelude::*;
use bevy_xpbd_2d::prelude::*;
use leafwing_input_manager::prelude::*;

use cursor_hero_character_types::prelude::*;
use cursor_hero_physics::damping_plugin::MovementDamping;
use cursor_hero_pointer_types::prelude::*;

use cursor_hero_toolbelt_types::prelude::*;

use crate::prelude::*;

pub struct CubeToolPlugin;

impl Plugin for CubeToolPlugin {
    fn build(&self, app: &mut App) {
        app.register_type::<CubeTool>();
        app.register_type::<CubeToolInteractable>();
        app.add_plugins(InputManagerPlugin::<CubeToolAction>::default());
        app.add_systems(Update, (toolbelt_events, handle_input));
    }
}

#[derive(Component, Reflect, Default)]
struct CubeTool;

fn toolbelt_events(
    mut commands: Commands,
    asset_server: Res<AssetServer>,
    mut reader: EventReader<ToolbeltPopulateEvent>,
) {
    for event in reader.read() {
        let ToolbeltLoadout::Inspector = event.loadout else {
            continue;
        };
        ToolSpawnConfig::<CubeTool, CubeToolAction>::new(CubeTool, event.id, event)
            .with_src_path(file!().into())
            .guess_name(file!())
            .guess_image(file!(), &asset_server, "png")
            .with_description("Spawn and attract cubes")
            .spawn(&mut commands);
    }
}

#[derive(Actionlike, PartialEq, Eq, Clone, Copy, Hash, Debug, Reflect)]
enum CubeToolAction {
    Spawn,
    Remove,
    Attract,
    KillAll,
}

impl CubeToolAction {
    fn default_gamepad_binding(&self) -> UserInput {
        match self {
            Self::Spawn => GamepadButtonType::South.into(),
            Self::Remove => GamepadButtonType::East.into(),
            Self::Attract => GamepadButtonType::LeftTrigger.into(),
            Self::KillAll => GamepadButtonType::West.into(),
        }
    }

    fn default_mkb_binding(&self) -> UserInput {
        match self {
            Self::Spawn => KeyCode::Q.into(),
            Self::Remove => KeyCode::R.into(),
            Self::Attract => KeyCode::F.into(),
            Self::KillAll => KeyCode::X.into(),
        }
    }
}
impl ToolAction for CubeToolAction {
    fn default_input_map(_event: &ToolbeltPopulateEvent) -> Option<InputMap<CubeToolAction>> {
        let mut input_map = InputMap::default();

        for variant in CubeToolAction::variants() {
            input_map.insert(variant.default_mkb_binding(), variant);
            input_map.insert(variant.default_gamepad_binding(), variant);
        }
        Some(input_map)
    }
}

#[derive(Component, Reflect)]
pub struct CubeToolInteractable;

fn handle_input(
    mut commands: Commands,
    tools: Query<(&ActionState<CubeToolAction>, &Parent), With<ActiveTool>>,
    toolbelts: Query<&Parent, With<Toolbelt>>,
    characters: Query<&Children, With<Character>>,
    pointers: Query<&GlobalTransform, With<Pointer>>,
    mut cubes: Query<(Entity, &GlobalTransform, &mut LinearVelocity), With<CubeToolInteractable>>,
) {
    for tool in tools.iter() {
        let (tool_actions, tool_parent) = tool;

        let Ok(toolbelt) = toolbelts.get(tool_parent.get()) else {
            warn!("Tool not inside a toolbelt?");
            continue;
        };
        let toolbelt_parent = toolbelt;

        let Ok(character) = characters.get(toolbelt_parent.get()) else {
            warn!("Toolbelt parent not a character?");
            continue;
        };
        let character_children = character;

        let Some(pointer) = character_children
            .iter()
            .filter_map(|x| pointers.get(*x).ok())
            .next()
        else {
            //TODO: warn if more than one pointer found
            warn!("Character {:?} missing a pointer?", toolbelt_parent.get());
            debug!("Character children: {:?}", character_children);
            continue;
        };
        let pointer_transform = pointer;

        if tool_actions.just_pressed(CubeToolAction::Spawn) {
            info!("Spawn Cube");
            commands.spawn((
                CubeToolInteractable,
                MovementDamping { factor: 0.98 },
                SpriteBundle {
                    sprite: Sprite {
                        custom_size: Some(Vec2::new(15.0, 15.0)),
                        ..default()
                    },
                    transform: Transform::from_translation(pointer_transform.translation()),
                    ..default()
                },
                RigidBody::Dynamic,
                Collider::cuboid(15.0, 15.0),
                Name::new("Cube"),
            ));
        }
        if tool_actions.just_pressed(CubeToolAction::Remove) {
            info!("Remove Cube");
            // remove the cube closest to the pointer
            let mut closest_cube = None;
            let mut closest_dist = f32::MAX;
            for (c_e, c_t, _) in cubes.iter() {
                let dist = c_t.translation().distance(pointer_transform.translation());
                if dist < closest_dist {
                    closest_cube = Some(c_e);
                    closest_dist = dist;
                }
            }
            if let Some(cube) = closest_cube {
                commands.entity(cube).despawn_recursive();
            }
        }
        if tool_actions.just_pressed(CubeToolAction::KillAll) {
            info!("Kill All Cubes");
            // remove all cubes
            for (c_e, _, _) in cubes.iter() {
                commands.entity(c_e).despawn_recursive();
            }
        }
        if tool_actions.pressed(CubeToolAction::Attract) {
            if tool_actions.just_pressed(CubeToolAction::Attract) {
                info!("Attract Cube");
            }
            // add a force to all cubes towards the pointer
            for (_, c_t, mut c_v) in cubes.iter_mut() {
                let diff = pointer.translation() - c_t.translation();
                let force = diff.normalize() * 100.0;
                c_v.x += force.x;
                c_v.y += force.y;
            }
        }
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\ui_automation_types\src\ui_automation_drill.rs

````rust
use std::collections::VecDeque;
use uiautomation::UIElement;
use uiautomation::UITreeWalker;

use crate::prelude::DrillId;

#[derive(Debug)]
pub enum DrillError {
    UI(uiautomation::Error),
    EmptyPath,
    BadPath,
    OutOfBounds {
        given: u32,
        max: u32,
        error: uiautomation::Error,
    },
}
impl std::error::Error for DrillError {}
impl std::fmt::Display for DrillError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            DrillError::UI(e) => write!(f, "UIAutomation error: {}", e),
            DrillError::EmptyPath => write!(f, "Empty path"),
            DrillError::BadPath => write!(f, "Bad path"),
            DrillError::OutOfBounds { given, max, error } => write!(
                f,
                "Out of bounds: given {}, max {}, error: {}",
                given, max, error
            ),
        }
    }
}
impl From<uiautomation::Error> for DrillError {
    fn from(e: uiautomation::Error) -> Self {
        DrillError::UI(e)
    }
}
pub trait Drillable {
    fn drill<T: Into<DrillId>>(
        &self,
        walker: &UITreeWalker,
        path: T,
    ) -> Result<UIElement, DrillError>;
}
impl Drillable for UIElement {
    fn drill<T: Into<DrillId>>(
        &self,
        walker: &UITreeWalker,
        path: T,
    ) -> Result<UIElement, DrillError> {
        let drill_id: DrillId = path.into();
        match drill_id {
            DrillId::Child(path) => {
                let mut path = path
                    .into_iter()
                    .map(|x| x as u32)
                    .collect::<VecDeque<u32>>();
                if path.iter().any(|x| (*x as i32) < 0) {
                    return Err(DrillError::BadPath);
                }
                drill_inner(self, walker, &mut path)
            }
            DrillId::Root | DrillId::Unknown => {
                return Err(DrillError::BadPath);
            }
        }
    }
}
fn drill_inner(
    start: &UIElement,
    walker: &UITreeWalker,
    path: &mut VecDeque<u32>,
) -> Result<UIElement, DrillError> {
    let target_index = match path.pop_front() {
        Some(x) => x,
        None => return Err(DrillError::EmptyPath),
    };
    let mut child = walker.get_first_child(start)?;
    let mut i = 0;
    while i < target_index {
        i += 1;
        child = match walker.get_next_sibling(&child) {
            Ok(x) => x,
            Err(e) => {
                return Err(DrillError::OutOfBounds {
                    given: i,
                    max: target_index,
                    error: e,
                })
            }
        };
    }
    if path.is_empty() {
        Ok(child)
    } else {
        drill_inner(&child, walker, path)
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\movement_tool_types\src\movement_tool_types_plugin.rs

````rust
use crate::prelude::*;
use bevy::prelude::*;

pub struct MovementToolTypesPlugin;

impl Plugin for MovementToolTypesPlugin {
    fn build(&self, app: &mut App) {
        app.register_type::<MovementTool>();
        app.add_event::<MovementTargetEvent>();
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\data\src\paths.rs

````rust
pub const CURSOR_HERO_GIT_DIR: &str = "D:/Repos/Games/Cursor-Hero/";

````



## D:\Repos\Games\Cursor-Hero\crates\ui_automation\src\ui_automation_plugin.rs

````rust
use bevy::prelude::*;

pub struct UiAutomationPlugin;

impl Plugin for UiAutomationPlugin {
    fn build(&self, _app: &mut App) {}
}

````



## D:\Repos\Games\Cursor-Hero\crates\toolbelt\src\toolbelt_taskbar_layout_plugin.rs

````rust
use std::f32::consts::PI;

use bevy::prelude::*;
use bevy::transform::TransformSystem;
use bevy::utils::HashSet;
use bevy_xpbd_2d::components::Position;
use bevy_xpbd_2d::components::Rotation;
use bevy_xpbd_2d::PhysicsSet;
use cursor_hero_math::prelude::Corner;
use cursor_hero_toolbelt_types::toolbelt_types::Tool;
use cursor_hero_toolbelt_types::toolbelt_types::ToolHelpTrigger;
use cursor_hero_toolbelt_types::toolbelt_types::Toolbelt;
use cursor_hero_toolbelt_types::toolbelt_types::ToolbeltLayout;
use cursor_hero_window_position_types::prelude::WindowPositionTool;
use cursor_hero_window_position_types::window_position_types::HostWindowPosition;
use itertools::Itertools;

pub struct ToolbeltTaskbarLayoutPlugin;

impl Plugin for ToolbeltTaskbarLayoutPlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(
            PostUpdate,
            position_tools
                .after(PhysicsSet::Sync)
                .after(TransformSystem::TransformPropagate),
        );
    }
}

#[allow(clippy::type_complexity)]
pub fn position_tools(
    toolbelt_query: Query<(Ref<Toolbelt>, &Children, &Parent), Without<Tool>>,
    character_query: Query<&GlobalTransform>,
    mut tool_query: Query<
        (
            Entity,
            Option<&WindowPositionTool>,
            &mut Transform,
            &mut Position,
            &mut Rotation,
            &Children,
        ),
        (With<Tool>, Without<ToolHelpTrigger>),
    >,
    mut tool_help_query: Query<
        (&mut Transform, &mut Position, &mut Rotation),
        (With<ToolHelpTrigger>, Without<Tool>),
    >,
) {
    for toolbelt in toolbelt_query.iter() {
        let (toolbelt, toolbelt_kids, toolbelt_parent) = toolbelt;
        if !toolbelt.is_changed() {
            continue;
        }
        let ToolbeltLayout::Taskbar { wheel, .. } = toolbelt.layout else {
            continue;
        };
        if let Ok(character_position) = character_query.get(**toolbelt_parent) {
            let sorted_window_tools = toolbelt_kids
                .iter()
                .filter(|e| tool_query.contains(**e))
                .filter_map(|e| tool_query.get(*e).ok())
                .filter_map(|(entity, window_position_tool, ..)| {
                    window_position_tool.map(|window_position_tool| (entity, window_position_tool))
                })
                .sorted_by_key(|(_, window_position_tool)| {
                    match window_position_tool.window_position {
                        HostWindowPosition::Corner {
                            ref corner,
                            monitor,
                        } => {
                            monitor * 100
                                + match corner {
                                    Corner::TopLeft => 0,
                                    Corner::TopRight => 1,
                                    Corner::BottomLeft => 2,
                                    Corner::BottomRight => 3,
                                }
                        }
                        HostWindowPosition::Fullscreen { monitor } => 100000 + monitor,
                    }
                })
                .map(|(entity, _)| entity)
                .collect_vec();
            let window_tools = sorted_window_tools.iter().collect::<HashSet<_>>();
            let remaining_tools = toolbelt_kids
                .iter()
                .filter(|e| tool_query.contains(**e))
                .filter(|e| !window_tools.contains(e))
                .collect_vec();

            let count = remaining_tools.len();
            for (i, tool_id) in remaining_tools.iter().enumerate() {
                let Ok(tool) = tool_query.get_mut(**tool_id) else {
                    continue;
                };

                let (
                    _tool_id,
                    _position_tool,
                    mut tool_transform,
                    mut tool_position,
                    mut tool_rotation,
                    tool_children,
                ) = tool;
                let angle = 2.0 * PI / (count as f32) * i as f32;
                let x = angle.cos();
                let y = angle.sin();
                tool_transform.scale = Vec2::splat(wheel.scale).extend(1.0);
                let character_position = character_position.translation().xy();
                tool_position.0 =
                    character_position + Vec2::new(x * wheel.radius, y * wheel.radius);
                *tool_rotation = Rotation::from_degrees(wheel.spin);
                for tool_child in tool_children.iter() {
                    if let Ok((
                        mut tool_help_transform,
                        mut tool_help_position,
                        mut tool_help_rotation,
                    )) = tool_help_query.get_mut(*tool_child)
                    {
                        tool_help_transform.scale = Vec2::splat(wheel.scale).extend(1.0);
                        tool_help_position.0 = tool_position.xy()
                            + Vec2::new(x * -wheel.radius * 0.5, y * -wheel.radius * 0.5);
                        *tool_help_rotation = Rotation::from_degrees(wheel.spin);
                    }
                }
            }
        }
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\environment\src\environment_plugin.rs

````rust
use bevy::prelude::*;
use cursor_hero_environment_types::prelude::*;

use crate::environment_tracker_plugin::EnvironmentTrackerPlugin;

pub struct EnvironmentPlugin;

impl Plugin for EnvironmentPlugin {
    fn build(&self, app: &mut App) {
        app.add_plugins(EnvironmentTrackerPlugin);
        app.add_systems(Startup, send_create_host_event);
        app.add_systems(Startup, send_create_game_event);
        app.add_systems(Update, handle_create_events);
        app.add_systems(Update, send_populate_events);
    }
}

fn send_create_host_event(mut events: EventWriter<CreateEnvironmentRequestEvent>) {
    events.send(CreateEnvironmentRequestEvent {
        kind: EnvironmentKind::Host,
        origin: Vec2::new(0.0, 0.0),
        name: "Host Environment".to_string(),
    });
}

fn send_create_game_event(mut events: EventWriter<CreateEnvironmentRequestEvent>) {
    events.send(CreateEnvironmentRequestEvent {
        kind: EnvironmentKind::Game,
        origin: Vec2::new(0.0, -3000.0),
        name: "Game Environment".to_string(),
    });
}

#[allow(clippy::type_complexity)]
fn send_populate_events(
    environment_query: Query<Entity, Added<EnvironmentKind>>,
    mut populate_events: EventWriter<PopulateEnvironmentEvent>,
) {
    for environment in environment_query.iter() {
        let environment_id = environment;
        let event = PopulateEnvironmentEvent { environment_id };
        debug!("Sending populate event: {:?}", event);
        populate_events.send(event);
    }
}

fn handle_create_events(
    mut commands: Commands,
    mut create_events: EventReader<CreateEnvironmentRequestEvent>,
) {
    for event in create_events.read() {
        info!("Creating host environment at {:?}", event.origin);
        let mut c = commands.spawn((
            SpatialBundle {
                transform: Transform::from_translation(event.origin.extend(0.0)),
                ..default()
            },
            event.kind,
            Name::new(event.name.clone()),
        ));
        match event.kind {
            EnvironmentKind::Host => {
                c.insert(HostEnvironment);
            }
            EnvironmentKind::Game => {
                c.insert(GameEnvironment);
            }
            EnvironmentKind::HostUIWatcher => {
                c.insert(HostUIWatcherEnvironment);
            }
        }
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\taskbar_tool\src\taskbar_tool_plugin.rs

````rust
use crate::taskbar_wheel_tool::TaskbarWheelToolPlugin;
use bevy::prelude::*;
pub struct TaskbarToolPlugin;

impl Plugin for TaskbarToolPlugin {
    fn build(&self, app: &mut App) {
        app.add_plugins(TaskbarWheelToolPlugin);
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\toolbelt\src\toolbelt_circle_layout_plugin.rs

````rust
use std::f32::consts::PI;

use bevy_xpbd_2d::components::Position;
use bevy_xpbd_2d::components::Rotation;
use bevy_xpbd_2d::PhysicsSet;
use cursor_hero_toolbelt_types::toolbelt_types::*;

use bevy::prelude::*;
use bevy::transform::TransformSystem;
use cursor_hero_input::update_gamepad_settings::PRESS_THRESHOLD;
use cursor_hero_pointer_types::prelude::*;

use itertools::Itertools;
use leafwing_input_manager::action_state::ActionState;

pub struct ToolbeltCircleLayoutPlugin;

impl Plugin for ToolbeltCircleLayoutPlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(Update, update_render_data);
        app.add_systems(Update, reset_reach);
        app.add_systems(
            PostUpdate,
            position_tools
                .after(PhysicsSet::Sync)
                .after(TransformSystem::TransformPropagate),
        );
    }
}

#[allow(clippy::type_complexity)]
pub fn update_render_data(
    mut toolbelt_query: Query<
        (
            &mut Toolbelt,
            &ActionState<ToolbeltAction>,
            &Parent,
            &Children,
        ),
        Without<Tool>,
    >,
    tool_query: Query<Entity, With<Tool>>,
    mut pointer_reach_events: EventWriter<PointerReachEvent>,
) {
    for toolbelt in toolbelt_query.iter_mut() {
        let (mut toolbelt, toolbelt_actions, toolbelt_parent, toolbelt_children) = toolbelt;
        if !toolbelt.open {
            continue;
        }
        let ToolbeltLayout::Circle { wheel, .. } = &mut toolbelt.layout else {
            continue;
        };
        let tool_count = toolbelt_children
            .iter()
            .filter(|e| tool_query.get(**e).is_ok())
            .count();
        let open = ((toolbelt_actions.value(ToolbeltAction::Show) - PRESS_THRESHOLD)
            / (1.0 - PRESS_THRESHOLD)
            * 1.01)
            .min(1.0);
        wheel.radius = wheel.radius_start
            + ((wheel.radius_end
                + wheel.radius_end_bonus_per_tool_after_8
                    * (tool_count as isize - 8).max(0) as f32)
                - wheel.radius_start)
                * open;
        wheel.spin = wheel.spin_start + (wheel.spin_end - wheel.spin_start) * open;
        wheel.scale = wheel.scale_start + (wheel.scale_end - wheel.scale_start) * open;
        wheel.alpha = wheel.alpha_start + (wheel.alpha_end - wheel.alpha_start) * open;
        pointer_reach_events.send(PointerReachEvent::SetCharacter {
            character_id: toolbelt_parent.get(),
            reach: wheel.radius,
        });
    }
}

fn reset_reach(
    mut pointer_reach_events: EventWriter<PointerReachEvent>,
    mut toolbelt_opening_events: EventReader<ToolbeltOpeningEvent>,
    toolbelt_query: Query<&Parent, With<Toolbelt>>,
) {
    for event in toolbelt_opening_events.read() {
        let ToolbeltOpeningEvent::Closed { toolbelt_id } = event else {
            continue;
        };
        let Ok(toolbelt) = toolbelt_query.get(*toolbelt_id) else {
            continue;
        };
        let character_id = toolbelt.get();
        pointer_reach_events.send(PointerReachEvent::ResetCharacter { character_id });
    }
}

#[allow(clippy::type_complexity)]
pub fn position_tools(
    toolbelt_query: Query<(Ref<Toolbelt>, &Children, &Parent), Without<Tool>>,
    character_query: Query<&GlobalTransform>,
    mut tool_query: Query<
        (&mut Transform, &mut Position, &mut Rotation, &Children),
        (With<Tool>, Without<ToolHelpTrigger>),
    >,
    mut tool_help_query: Query<
        (&mut Transform, &mut Position, &mut Rotation),
        (With<ToolHelpTrigger>, Without<Tool>),
    >,
) {
    for (toolbelt, toolbelt_kids, toolbelt_parent) in toolbelt_query.iter() {
        if !toolbelt.is_changed() {
            continue;
        }
        let ToolbeltLayout::Circle { wheel } = toolbelt.layout else {
            continue;
        };
        if let Ok(character_position) = character_query.get(**toolbelt_parent) {
            let tool_ids = toolbelt_kids
                .iter()
                .filter(|e| tool_query.contains(**e))
                .collect_vec();
            position_tools_helper(
                character_position,
                tool_ids,
                &mut tool_query,
                &mut tool_help_query,
                &wheel,
            );
        }
    }
}

#[allow(clippy::type_complexity)]
fn position_tools_helper(
    character_position: &GlobalTransform,
    tool_ids: Vec<&Entity>,
    tool_query: &mut Query<
        (&mut Transform, &mut Position, &mut Rotation, &Children),
        (With<Tool>, Without<ToolHelpTrigger>),
    >,
    tool_help_query: &mut Query<
        (&mut Transform, &mut Position, &mut Rotation),
        (With<ToolHelpTrigger>, Without<Tool>),
    >,
    wheel: &Wheel,
) {
    let count = tool_ids.len();
    for (i, tool_id) in tool_ids.iter().enumerate() {
        if let Ok((mut tool_transform, mut tool_position, mut tool_rotation, tool_children)) =
            tool_query.get_mut(**tool_id)
        {
            let angle = 2.0 * PI / (count as f32) * i as f32;
            let x = angle.cos();
            let y = angle.sin();
            tool_transform.scale = Vec2::splat(wheel.scale).extend(1.0);
            let character_position = character_position.translation().xy();
            tool_position.0 = character_position + Vec2::new(x * wheel.radius, y * wheel.radius);
            *tool_rotation = Rotation::from_degrees(wheel.spin);
            for tool_child in tool_children.iter() {
                if let Ok((
                    mut tool_help_transform,
                    mut tool_help_position,
                    mut tool_help_rotation,
                )) = tool_help_query.get_mut(*tool_child)
                {
                    tool_help_transform.scale = Vec2::splat(wheel.scale).extend(1.0);
                    tool_help_position.0 = tool_position.xy()
                        + Vec2::new(x * -wheel.radius * 0.5, y * -wheel.radius * 0.5);
                    *tool_help_rotation = Rotation::from_degrees(wheel.spin);
                }
            }
        }
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\text_asset_types\src\text_asset_types_plugin.rs

````rust
use crate::prelude::*;
use bevy::prelude::*;

pub struct TextAssetTypesPlugin;

impl Plugin for TextAssetTypesPlugin {
    fn build(&self, app: &mut App) {
        app.register_type::<TextAsset>();
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\ui\src\lib.rs

````rust
pub mod about_text_plugin;
pub mod fps_text_plugin;
pub mod position_text_plugin;

````



## D:\Repos\Games\Cursor-Hero\crates\pointer_types\src\lib.rs

````rust
pub mod pointer_action_types;
pub mod pointer_behaviour_types;
pub mod pointer_click_types;
pub mod pointer_hover_types;
pub mod pointer_reach_types;
pub mod pointer_types;
pub mod pointer_types_plugin;

pub mod prelude {
    pub use crate::pointer_action_types::*;
    pub use crate::pointer_click_types::*;
    pub use crate::pointer_hover_types::*;
    pub use crate::pointer_reach_types::*;
    pub use crate::pointer_types::*;
}

````



## D:\Repos\Games\Cursor-Hero\crates\host_fs_types\src\host_fs_types.rs

````rust
use std::path::PathBuf;

use bevy::prelude::*;

#[derive(Component, Debug, Reflect, Clone, Eq, PartialEq)]
pub struct HostPath {
    pub path: PathBuf,
}

#[derive(Event, Debug, Reflect)]
pub enum HostPathAction {
    OpenWithCode { path: HostPath },
}

````



## D:\Repos\Games\Cursor-Hero\crates\fullscreen_tool_types\src\lib.rs

````rust
pub mod fullscreen_tool_types;
pub mod fullscreen_tool_types_plugin;

pub mod prelude {
    pub use crate::fullscreen_tool_types::*;
    pub use crate::fullscreen_tool_types_plugin::*;
}

````



## D:\Repos\Games\Cursor-Hero\crates\memory\src\voice_to_text_memory_plugin.rs

````rust
use std::time::Duration;

use bevy::prelude::*;
use bevy::utils::Instant;

use cursor_hero_memory_types::prelude::*;
use cursor_hero_secret_types::secrets_types::SecretString;
use cursor_hero_voice_to_text_types::voice_to_text_types::VoiceToTextStatus;
use cursor_hero_voice_to_text_types::voice_to_text_types::VoiceToTextStatusEvent;
use serde::Deserialize;
use serde::Serialize;

pub struct VoiceToTextMemoryPlugin;

impl Plugin for VoiceToTextMemoryPlugin {
    fn build(&self, app: &mut App) {
        app.insert_resource(VoiceToTextMemoryConfig::default());
        app.add_systems(Update, persist.pipe(handle_persist_errors));
        app.add_systems(Update, restore.pipe(handle_restore_errors));
    }
}
const PERSIST_FILE_NAME: &str = "voice_to_text.json";

// not moved to lib to ensure log contains this module name
fn handle_persist_errors(In(result): In<Result<PersistSuccess, PersistError>>) {
    if let Err(e) = result {
        error!("Persist error occurred: {:?}", e);
    } else if let Ok(PersistSuccess::WritePerformed) = result {
        debug!("Persisted succeeded");
    }
}

fn handle_restore_errors(In(result): In<Result<RestoreSuccess, RestoreError>>) {
    if let Err(e) = result {
        error!("Restore error occurred: {:?}", e);
    } else if let Ok(RestoreSuccess::Performed) = result {
        info!("Restore succeeded");
    }
}

#[derive(Debug, Resource, Reflect)]
#[reflect(Resource)]
struct VoiceToTextMemoryConfig {
    pub persist_cooldown: Timer,
    pub restore_retry_cooldown: Duration,
}
impl Default for VoiceToTextMemoryConfig {
    fn default() -> Self {
        Self {
            persist_cooldown: Timer::from_seconds(10.0, TimerMode::Repeating),
            restore_retry_cooldown: Duration::from_secs(60),
        }
    }
}

#[derive(Debug, Serialize, Deserialize, PartialEq, Clone)]
struct DiskData {
    api_key: Option<SecretString>,
}

fn persist(
    mut config: ResMut<VoiceToTextMemoryConfig>,
    mut debounce: Local<Option<DiskData>>,
    time: Res<Time>,
    voice_status: Res<VoiceToTextStatus>,
) -> Result<PersistSuccess, PersistError> {
    if !config.persist_cooldown.tick(time.delta()).just_finished() {
        return Ok(PersistSuccess::Cooldown);
    }
    let api_key = match &*voice_status {
        VoiceToTextStatus::Alive { api_key, .. } | VoiceToTextStatus::Starting { api_key, .. } => {
            Some(api_key.clone())
        }
        VoiceToTextStatus::Dead => None,
        _ => {
            return Ok(PersistSuccess::NoAction);
        }
    };
    let data = DiskData { api_key };
    if debounce.is_none() || debounce.as_ref().unwrap() != &data {
        let file = get_persist_file(file!(), PERSIST_FILE_NAME, Usage::Persist)
            .map_err(PersistError::Io)?;
        write_to_disk(file, data.clone())?;
        *debounce = Some(data);
        Ok(PersistSuccess::WritePerformed)
    } else {
        Ok(PersistSuccess::Debounce)
    }
}

fn restore(
    config: Res<VoiceToTextMemoryConfig>,
    mut current_status: ResMut<VoiceToTextStatus>,
    mut status_events: EventWriter<VoiceToTextStatusEvent>,
    mut attempted_at: Local<Option<Instant>>,
) -> Result<RestoreSuccess, RestoreError> {
    if matches!(
        *current_status,
        VoiceToTextStatus::Alive { .. }
            | VoiceToTextStatus::Starting { .. }
            | VoiceToTextStatus::UnknownWithCachedApiKey { .. }
            | VoiceToTextStatus::Dead
    ) {
        return Ok(RestoreSuccess::NoAction);
    }
    let file = match get_persist_file(file!(), PERSIST_FILE_NAME, Usage::Restore) {
        Ok(file) => Ok(file),
        Err(e) => {
            if let Some(attempt) = *attempted_at {
                if attempt.elapsed() > config.restore_retry_cooldown {
                    *attempted_at = Some(Instant::now());
                    return Err(RestoreError::Io(e));
                } else {
                    // Silently ignore the error and retry later
                    return Ok(RestoreSuccess::NoAction);
                }
            } else {
                *attempted_at = Some(Instant::now());
                return Err(RestoreError::Io(e));
            }
        }
    }?;
    let data: DiskData = read_from_disk(file)?;
    let Some(api_key) = data.api_key else {
        return Ok(RestoreSuccess::NoAction);
    };

    info!("Restoring api key");

    let new_status = match *current_status {
        VoiceToTextStatus::Unknown
        | VoiceToTextStatus::AliveButWeDontKnowTheApiKey
        | VoiceToTextStatus::UnknownWithCachedApiKey { .. } => {
            VoiceToTextStatus::UnknownWithCachedApiKey { api_key }
        }
        ref current => current.clone(),
    };
    if new_status != *current_status {
        let event = VoiceToTextStatusEvent::Changed {
            old_status: current_status.clone(),
            new_status: new_status.clone(),
        };
        debug!("Sending event: {:?}", event);
        status_events.send(event);
        *current_status = new_status;
        Ok(RestoreSuccess::Performed)
    } else {
        Ok(RestoreSuccess::NoAction)
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\toolbelt\src\toolbelt_properties_plugin.rs

````rust
use bevy::prelude::*;
use cursor_hero_toolbelt_types::toolbelt_types::Toolbelt;
use cursor_hero_toolbelt_types::toolbelt_types::ToolbeltPopulateEvent;

pub struct ToolbeltPropertiesPlugin;

impl Plugin for ToolbeltPropertiesPlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(Update, switch_layout);
    }
}
pub fn switch_layout(
    mut toolbelt_events: EventReader<ToolbeltPopulateEvent>,
    mut toolbelt_query: Query<&mut Toolbelt>,
) {
    for event in toolbelt_events.read() {
        let ToolbeltPopulateEvent { id, loadout } = event;
        if let Ok(mut toolbelt) = toolbelt_query.get_mut(*id) {
            toolbelt.loadout = *loadout;
            toolbelt.layout = loadout.layout();
        }
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\cursor_mirror\src\cursor_mirroring_plugin.rs

````rust
use bevy::prelude::*;
use bevy::sprite::Anchor;

use cursor_hero_winutils::win_mouse::get_cursor_position;

pub struct CursorMirroringPlugin;
impl Plugin for CursorMirroringPlugin {
    fn build(&self, app: &mut App) {
        app.register_type::<CursorMirror>();
        app.add_systems(Startup, setup);
        app.add_systems(Update, (update_cursor_position, update_visuals).chain());
        app.insert_resource(CursorPosition::default());
    }
}

#[derive(Component, Reflect)]
pub struct CursorMirror;

#[derive(Resource, Deref, Default, Reflect)]
#[reflect(Resource)]
pub struct CursorPosition(pub IVec2);

fn setup(mut commands: Commands, asset_server: Res<AssetServer>) {
    commands.spawn((
        SpriteBundle {
            transform: Transform::from_xyz(0.0, 0.0, 20.0),
            sprite: Sprite {
                // custom_size: Some(Vec2::new(20.0, 20.0)),
                anchor: Anchor::TopLeft,
                ..default()
            },

            texture: asset_server.load("textures/cursor.png"),
            ..default()
        },
        CursorMirror,
        Name::new("Cursor Mirror"),
    ));
}

fn update_cursor_position(mut res: ResMut<CursorPosition>) {
    if let Ok(pos) = get_cursor_position() {
        res.0 = pos;
    }
}

fn update_visuals(
    mut cursor_mirrors: Query<(&mut Transform, &CursorMirror)>,
    cursor_position: Res<CursorPosition>,
) {
    for (mut transform, _) in &mut cursor_mirrors.iter_mut() {
        transform.translation.x = cursor_position.x as f32;
        transform.translation.y = -cursor_position.y as f32;
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\fullscreen_tool\src\fullscreen_tool_plugin.rs

````rust
use crate::fullscreen_tool_populate_plugin::FullscreenToolPopulatePlugin;
use crate::fullscreen_tool_tick_plugin::FullscreenToolTickPlugin;
use bevy::prelude::*;

pub struct FullscreenToolPlugin;

impl Plugin for FullscreenToolPlugin {
    fn build(&self, app: &mut App) {
        app.add_plugins(FullscreenToolPopulatePlugin);
        app.add_plugins(FullscreenToolTickPlugin);
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\camera\src\lib.rs

````rust
#![feature(let_chains)]
pub mod camera_plugin;

````



## D:\Repos\Games\Cursor-Hero\crates\toolbelt\src\hover_frame.rs

````rust
use bevy::prelude::*;
use cursor_hero_pointer_types::prelude::*;

#[derive(Component, Debug)]
pub struct ToolFrame;

#[allow(clippy::type_complexity)]
pub fn insert_hover_frame(
    mut reader: EventReader<HoverEvent>,
    mut commands: Commands,
    asset_server: Res<AssetServer>,
    hovered_query: Query<&Sprite>,
) {
    for event in reader.read() {
        if let HoverEvent::Start {
            target_id,
            pointer_id: _,
        } = event
        {
            // Ensure the entity hasn't despawned since the event was sent
            if commands.get_entity(*target_id).is_none() {
                warn!("Hovered entity {:?} has despawned", target_id);
                continue;
            }
            let mut size = Vec2::new(200.0, 200.0);
            if let Ok(hovered_sprite) = hovered_query.get(*target_id)
                && let Some(hovered_size) = hovered_sprite.custom_size
            {
                size = hovered_size * 2.0;
            }

            commands.entity(*target_id).with_children(|hovered| {
                hovered.spawn((
                    SpriteBundle {
                        sprite: Sprite {
                            custom_size: Some(size),
                            ..default()
                        },
                        texture: asset_server.load("textures/wood frame.png"),
                        ..default()
                    },
                    ToolFrame,
                ));
            });
        }
    }
}
#[allow(clippy::type_complexity)]
pub fn remove_hover_frame(
    mut reader: EventReader<HoverEvent>,
    mut commands: Commands,
    tool_query: Query<&Children>,
    frame_query: Query<Entity, With<ToolFrame>>,
) {
    for event in reader.read() {
        if let HoverEvent::End {
            target_id,
            pointer_id: _,
        } = event
        {
            if let Ok(tool_children) = tool_query.get(*target_id) {
                for tool_child in tool_children.iter() {
                    if let Ok(frame_id) = frame_query.get(*tool_child) {
                        commands.entity(*target_id).remove_children(&[frame_id]);
                        commands.entity(frame_id).despawn();
                    }
                }
            }
        }
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\app_types\src\app_types_plugin.rs

````rust
use crate::prelude::*;
use bevy::prelude::*;

pub struct AppTypesPlugin;

impl Plugin for AppTypesPlugin {
    fn build(&self, app: &mut App) {
        app.register_type::<MyComponent>();
        app.add_event::<MyEvent>();
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\environment_nametag\src\lib.rs

````rust
pub mod environment_nametag_plugin;

````



## D:\Repos\Games\Cursor-Hero\crates\fullscreen_tool\src\fullscreen_tool_populate_plugin.rs

````rust
use bevy::prelude::*;
use bevy::window::PrimaryWindow;
use cursor_hero_fullscreen_tool_types::prelude::*;
use cursor_hero_toolbelt_types::prelude::*;
use cursor_hero_tools::tool_spawning::NoInputs;
use cursor_hero_tools::tool_spawning::ToolSpawnConfig;

pub struct FullscreenToolPopulatePlugin;

impl Plugin for FullscreenToolPopulatePlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(Update, handle_toolbelt_events);
    }
}

fn handle_toolbelt_events(
    mut commands: Commands,
    asset_server: Res<AssetServer>,
    mut reader: EventReader<ToolbeltPopulateEvent>,
    window_query: Query<&Window, With<PrimaryWindow>>,
) {
    for event in reader.read() {
        let ToolbeltLoadout::WindowPosition = event.loadout else {
            continue;
        };

        let mode = window_query
            .iter()
            .map(|w| w.mode)
            .next()
            .unwrap_or_default();
        let state = FullscreenTool::state_for_mode(mode);
        debug!("Window: {:?}, tool: {:?}", mode, state);
        ToolSpawnConfig::<_, NoInputs>::new(FullscreenTool, event.id, event)
            .with_src_path(file!().into())
            .guess_name(file!())
            .guess_image(file!(), &asset_server, "webp")
            .with_description("Toggles fullscreen mode.")
            .with_starting_state(state)
            .spawn(&mut commands);
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\memory\src\lib.rs

````rust
mod agent_observation_memory_plugin;
mod main_camera_memory_plugin;
mod main_character_memory_plugin;
mod memory_plugin;
pub mod primary_window_memory_plugin;
mod voice_to_text_memory_plugin;

pub mod prelude {
    pub use crate::memory_plugin::*;
    pub use cursor_hero_memory_types;
}

````



## D:\Repos\Games\Cursor-Hero\crates\tools\src\hello_tool.rs

````rust
use crate::prelude::*;
use bevy::prelude::*;
use cursor_hero_inference_types::inference_types::SpeechInferenceEvent;
use cursor_hero_inference_types::inference_types::TextInferenceEvent;
use cursor_hero_inference_types::inference_types::TextInferenceOptions;
use cursor_hero_inference_types::prompt_types::SpeechPrompt;
use cursor_hero_inference_types::prompt_types::TextPrompt;
use cursor_hero_toolbelt_types::prelude::*;

pub struct HelloToolPlugin;

impl Plugin for HelloToolPlugin {
    fn build(&self, app: &mut App) {
        app.register_type::<HelloTool>();
        app.add_systems(Update, toolbelt_events);
        app.add_systems(Update, activation);
        app.add_systems(Update, inference_response);
        app.add_systems(Update, tts_response);
    }
}

#[derive(Component, Reflect, Default)]
struct HelloTool;

fn toolbelt_events(
    mut commands: Commands,
    asset_server: Res<AssetServer>,
    mut reader: EventReader<ToolbeltPopulateEvent>,
) {
    for event in reader.read() {
        if event.loadout == ToolbeltLoadout::Inspector {
            ToolSpawnConfig::<HelloTool, NoInputs>::new(HelloTool, event.id, event)
                .with_src_path(file!().into())
                .guess_name(file!())
                .guess_image(file!(), &asset_server, "png")
                .with_description("Prints hello.")
                .with_starting_state(StartingState::Inactive)
                .spawn(&mut commands);
        }
    }
}

fn activation(
    mut commands: Commands,
    tool_query: Query<Entity, (Added<ActiveTool>, With<HelloTool>)>,
    mut inference_events: EventWriter<TextInferenceEvent>,
) {
    for tool_id in tool_query.iter() {
        commands.entity(tool_id).remove::<ActiveTool>();
        info!("Hello, world!");
        inference_events.send(TextInferenceEvent::Request {
            session_id: tool_id,
            prompt: TextPrompt::Raw {
                content: "Here is a random word:".to_string(),
                options: Some(TextInferenceOptions {
                    num_predict: Some(7),
                    ..default()
                }),
            },
        });
    }
}

fn inference_response(
    mut llm_events: EventReader<TextInferenceEvent>,
    mut tts_events: EventWriter<SpeechInferenceEvent>,
    tool_query: Query<Entity, With<HelloTool>>,
) {
    for event in llm_events.read() {
        if let TextInferenceEvent::Response {
            session_id,
            response,
            prompt: _,
        } = event
        {
            if tool_query.get(*session_id).is_ok() {
                tts_events.send(SpeechInferenceEvent::Request {
                    session_id: *session_id,
                    prompt: SpeechPrompt::Raw {
                        content: response.clone(),
                    },
                });
            }
        }
    }
}

fn tts_response(
    mut commands: Commands,
    mut tts_events: EventReader<SpeechInferenceEvent>,
    tool_query: Query<Entity, With<HelloTool>>,
    mut audio_assets: ResMut<Assets<AudioSource>>,
) {
    for event in tts_events.read() {
        if let SpeechInferenceEvent::Response {
            session_id, wav, ..
        } = event
        {
            if tool_query.get(*session_id).is_ok() {
                info!(
                    "Received TTS response for session {:?}, playing",
                    session_id
                );
                let audio = audio_assets.add(AudioSource {
                    bytes: wav.clone().into(),
                });
                commands.entity(*session_id).insert({
                    AudioBundle {
                        source: audio,
                        settings: PlaybackSettings::REMOVE.with_spatial(true),
                    }
                });
            }
        }
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\camera\src\camera_plugin.rs

````rust
use bevy::ecs::query::QuerySingleError::MultipleEntities;
use bevy::ecs::query::QuerySingleError::NoEntities;
use bevy::input::mouse::MouseWheel;
use bevy::prelude::*;
use bevy::transform::TransformSystem;
use bevy::window::PrimaryWindow;
use bevy_egui::EguiContext;
use bevy_xpbd_2d::prelude::*;
use cursor_hero_physics::damping_plugin::MovementDamping;
pub struct CameraPlugin;
impl Plugin for CameraPlugin {
    fn build(&self, app: &mut App) {
        app.register_type::<MainCamera>();
        app.add_event::<CameraEvent>();
        app.add_systems(Startup, spawn_camera);
        app.add_systems(Update, (update_camera_zoom, handle_events));
        app.add_systems(
            PostUpdate,
            follow
                .in_set(CameraSystemSet::Follow)
                .after(PhysicsSet::Sync)
                .before(TransformSystem::TransformPropagate),
        );
    }
}

#[derive(SystemSet, Clone, Hash, Debug, PartialEq, Eq)]
pub enum CameraSystemSet {
    Follow,
}

#[derive(Component, Reflect)]
pub struct MainCamera;

fn spawn_camera(mut commands: Commands) {
    commands.spawn((
        Camera2dBundle::default(),
        MainCamera,
        MovementDamping { factor: 0.90 },
        MassPropertiesBundle::new_computed(&Collider::ball(10.0), 1.0),
        RigidBody::Dynamic,
        SpatialListener::new(-7.0),
    ));
}

#[derive(Component)]
pub struct FollowWithMainCamera;

#[derive(Event, Debug, Reflect)]
pub enum CameraEvent {
    BeginFollowing { target_id: Entity },
    StopFollowing { target_id: Entity },
}

pub fn update_camera_zoom(
    mut cam: Query<&mut Transform, With<MainCamera>>,
    mut scroll: EventReader<MouseWheel>,
    egui_context_query: Query<&EguiContext, With<PrimaryWindow>>,
) {
    let Ok(egui_context) = egui_context_query.get_single() else {
        return;
    };
    let hovering_over_egui = egui_context.clone().get_mut().is_pointer_over_area();
    if hovering_over_egui {
        scroll.clear();
        return;
    }
    for event in scroll.read() {
        let mut scale = cam.single_mut().scale;
        scale *= Vec2::splat(1.0 - event.y / 10.0).extend(1.0);
        scale = scale.clamp(Vec3::splat(0.1), Vec3::splat(10.0));
        cam.single_mut().scale = scale;
    }
}

fn handle_events(
    mut commands: Commands,
    mut camera_events: EventReader<CameraEvent>,
    character_query: Query<&GlobalTransform, Without<MainCamera>>,
    mut camera_query: Query<&mut Transform, With<MainCamera>>,
) {
    for event in camera_events.read() {
        match event {
            CameraEvent::BeginFollowing { target_id } => {
                info!("Camera following character '{:?}'", target_id);
                // tag character to mark it as being followed
                commands.entity(*target_id).insert(FollowWithMainCamera);
                if let Ok(mut camera_transform) = camera_query.get_single_mut()
                    && let Ok(character_transform) = character_query.get_single()
                {
                    camera_transform.translation = character_transform.translation();
                }
            }
            CameraEvent::StopFollowing { target_id } => {
                info!("Camera stopped following character '{:?}'", target_id);
                // remove tag from character
                commands.entity(*target_id).remove::<FollowWithMainCamera>();
            }
        }
    }
}

fn follow(
    follow_query: Query<&GlobalTransform, With<FollowWithMainCamera>>,
    mut cam_query: Query<&mut Transform, With<MainCamera>>,
) {
    let follow = match follow_query.get_single() {
        Ok(follow) => follow,
        Err(NoEntities(_)) => return,
        Err(MultipleEntities(e)) => {
            error!("Multiple entities are being followed: {:?}", e);
            return;
        }
    };
    let follow_global_transform = follow;

    let camera = match cam_query.get_single_mut() {
        Ok(camera) => camera,
        Err(NoEntities(_)) => return,
        Err(MultipleEntities(e)) => {
            error!("Multiple cameras found: {:?}", e);
            return;
        }
    };
    let mut camera_transform = camera;

    // update transform
    let follow_translation = follow_global_transform.translation();
    camera_transform.translation = follow_translation;
}

````



## D:\Repos\Games\Cursor-Hero\crates\pointer_types\src\pointer_types.rs

````rust
use bevy::prelude::*;

use bevy_inspector_egui::prelude::ReflectInspectorOptions;
use bevy_inspector_egui::InspectorOptions;

use crate::pointer_behaviour_types::PointerMovementBehaviour;

#[derive(SystemSet, Clone, Hash, Debug, PartialEq, Eq)]
pub enum PointerSystemSet {
    Position,
}

#[derive(Reflect, Debug, PartialEq, Eq, Clone)]
pub enum PointerLogBehaviour {
    Errors,
    ErrorsAndPositionUpdates,
}

#[derive(Component, Debug, Reflect)]
pub struct MainPointer;

#[derive(Component, InspectorOptions, Debug, Reflect)]
#[reflect(InspectorOptions)]
pub struct Pointer {
    #[inspector(min = 0.0)]
    pub reach: f32,
    #[inspector(min = 0.0)]
    pub default_reach: f32,
    #[inspector(min = 0.0)]
    pub sprint_reach: f32,
    pub movement_behaviour: PointerMovementBehaviour,
    pub log_behaviour: PointerLogBehaviour,
}
impl Default for Pointer {
    fn default() -> Self {
        Pointer::new_unknown_pointer()
    }
}
impl Pointer {
    pub fn new_host_pointer() -> Self {
        Self {
            reach: 50.0,
            default_reach: 50.0,
            sprint_reach: 2000.0,
            movement_behaviour: PointerMovementBehaviour::None,
            log_behaviour: PointerLogBehaviour::Errors,
            // log_behaviour: PointerLogBehaviour::ErrorsAndPositionUpdates,
        }
    }
    pub fn new_agent_pointer() -> Self {
        Self {
            reach: 50.0,
            default_reach: 50.0,
            sprint_reach: 2000.0,
            movement_behaviour: PointerMovementBehaviour::None,
            log_behaviour: PointerLogBehaviour::Errors,
            // log_behaviour: PointerLogBehaviour::ErrorsAndPositionUpdates,
        }
    }
    pub fn new_unknown_pointer() -> Self {
        Self {
            reach: 0.0,
            default_reach: 0.0,
            sprint_reach: 0.0,
            movement_behaviour: PointerMovementBehaviour::None,
            log_behaviour: PointerLogBehaviour::Errors,
            // log_behaviour: PointerLogBehaviour::ErrorsAndPositionUpdates,
        }
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\start_menu\src\start_menu_plugin.rs

````rust
use crate::start_menu_button_plugin::StartMenuButtonPlugin;
use bevy::prelude::*;
use cursor_hero_start_menu_types::prelude::*;
use cursor_hero_winutils::win_colors::get_accent_color;

pub struct StartMenuPlugin;

impl Plugin for StartMenuPlugin {
    fn build(&self, app: &mut App) {
        app.add_plugins(StartMenuButtonPlugin);
        app.add_systems(Update, handle_open_events);
        app.add_systems(Update, handle_close_events);
    }
}
fn handle_open_events(
    mut commands: Commands,
    mut start_menu_events: EventReader<StartMenuEvent>,
    start_menu_button_query: Query<&Sprite, With<StartMenuButton>>,
) {
    for event in start_menu_events.read() {
        let StartMenuEvent::Open {
            start_menu_button_id,
        } = event
        else {
            continue;
        };
        info!("Opening start menu for button {:?}", start_menu_button_id);
        let Ok(Sprite {
            custom_size: Some(start_menu_button_size),
            ..
        }) = start_menu_button_query.get(*start_menu_button_id)
        else {
            warn!(
                "Couldn't find start menu button sprite for {:?}",
                start_menu_button_id
            );
            continue;
        };
        let size = Vec2::new(400.0, 400.0);
        let start_menu_pos = ((size / 2.0)
            + Vec2::new(
                -start_menu_button_size.x / 2.0,
                start_menu_button_size.y / 2.0,
            ))
        .extend(3.0);
        commands
            .entity(*start_menu_button_id)
            .with_children(|parent| {
                parent.spawn((
                    SpriteBundle {
                        sprite: Sprite {
                            custom_size: Some(size),
                            color: match get_accent_color() {
                                Ok(color) => color,
                                Err(err) => {
                                    warn!("Couldn't get start color: {}", err);
                                    Color::rgb(0.0, 0.0, 0.0)
                                }
                            },
                            ..default()
                        },
                        transform: Transform::from_translation(start_menu_pos),
                        ..Default::default()
                    },
                    StartMenu,
                ));
            });
    }
}

fn handle_close_events(
    mut commands: Commands,
    mut start_menu_events: EventReader<StartMenuEvent>,
    start_menu_button_query: Query<&Children, With<StartMenuButton>>,
    start_menu_query: Query<(), With<StartMenu>>,
) {
    for event in start_menu_events.read() {
        let StartMenuEvent::Close {
            start_menu_button_id,
        } = event
        else {
            continue;
        };
        info!("Closing start menu for button {:?}", start_menu_button_id);
        let Ok(start_menu_button_children) = start_menu_button_query.get(*start_menu_button_id)
        else {
            warn!(
                "Couldn't find start menu button children for {:?}",
                start_menu_button_id
            );
            continue;
        };
        let mut removed = vec![];
        for child in start_menu_button_children.iter() {
            if start_menu_query.get(*child).is_ok() {
                commands.entity(*child).despawn_recursive();
                removed.push(*child);
            }
        }
        commands
            .entity(*start_menu_button_id)
            .remove_children(&removed);
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\window_swap_tool\src\window_swap_tool_populate_plugin.rs

````rust
use bevy::prelude::*;
use cursor_hero_toolbelt_types::prelude::*;
use cursor_hero_tools::tool_spawning::ToolSpawnConfig;
use cursor_hero_window_swap_tool_types::prelude::*;

pub struct WindowSwapToolPopulatePlugin;

impl Plugin for WindowSwapToolPopulatePlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(Update, handle_toolbelt_events);
    }
}

fn handle_toolbelt_events(
    mut commands: Commands,
    asset_server: Res<AssetServer>,
    mut reader: EventReader<ToolbeltPopulateEvent>,
) {
    for event in reader.read() {
        let ToolbeltPopulateEvent {
            loadout: ToolbeltLoadout::WindowPosition,
            ..
        } = event
        else {
            continue;
        };
        ToolSpawnConfig::<_, WindowSwapToolAction>::new(WindowSwapTool, event.id, event)
            .with_src_path(file!().into())
            .guess_name(file!())
            .guess_image(file!(), &asset_server, "webp")
            .with_description("Swap the positions of windows.")
            .spawn(&mut commands);
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\glados_tts\src\lib.rs

````rust
pub mod glados_tts;
pub mod glados_tts_button_plugin;
pub mod glados_tts_inference_plugin;
pub mod glados_tts_plugin;
pub mod glados_tts_status_plugin;
pub mod glados_tts_status_worker_plugin;

pub mod prelude {
    pub use crate::glados_tts_plugin::*;
}

````



## D:\Repos\Games\Cursor-Hero\crates\sprint_tool_types\src\lib.rs

````rust
pub mod sprint_tool_types_plugin;

````



## D:\Repos\Games\Cursor-Hero\crates\window_swap_tool_types\src\lib.rs

````rust
pub mod window_swap_tool_types;
pub mod window_swap_tool_types_plugin;

pub mod prelude {
    pub use crate::window_swap_tool_types::*;
    pub use crate::window_swap_tool_types_plugin::*;
}

````



## D:\Repos\Games\Cursor-Hero\crates\ui\src\about_text_plugin.rs

````rust
use bevy::prelude::*;
use cursor_hero_version::version_plugin::Version;

pub struct AboutTextPlugin;

impl Plugin for AboutTextPlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(Startup, spawn_text);
    }
}

fn spawn_text(mut commands: Commands, asset_server: Res<AssetServer>, version: Res<Version>) {
    commands.spawn((
        TextBundle::from_section(
            format!("Cursor Hero v{}\nby @TeamDman", version.0),
            TextStyle {
                font: asset_server.load("fonts/FiraSans-Bold.ttf"),
                font_size: 16.0,
                ..default()
            },
        )
        .with_style(Style {
            position_type: PositionType::Absolute,
            bottom: Val::Px(5.0),
            right: Val::Px(5.0),
            ..default()
        }),
        Name::new("About Text"),
    ));
}

````



## D:\Repos\Games\Cursor-Hero\crates\window_swap_tool\src\lib.rs

````rust
pub mod window_swap_tool_plugin;
pub mod window_swap_tool_populate_plugin;

pub mod prelude {
    pub use crate::window_swap_tool_plugin::*;
}

````



## D:\Repos\Games\Cursor-Hero\crates\screen\src\lib.rs

````rust
use bevy::math::IRect;
use bevy::math::IVec2;
use screenshots::display_info::DisplayInfo;

pub mod get_image;
pub mod screen_plugin;
pub mod screen_update_plugin;

pub trait ToBevyIRect {
    fn to_bevy_irect(&self) -> IRect;
}
impl ToBevyIRect for DisplayInfo {
    fn to_bevy_irect(&self) -> IRect {
        IRect {
            min: IVec2::new(self.x, self.y),
            max: IVec2::new(self.x + self.width as i32, self.y + self.height as i32),
        }
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\agent_types\src\lib.rs

````rust
pub mod agent_types;
pub mod agent_types_plugin;

pub mod prelude {
    pub use crate::agent_types::*;
}

````



## D:\Repos\Games\Cursor-Hero\crates\text_asset_types\src\lib.rs

````rust
pub mod text_asset_loader_types;
pub mod text_asset_types_plugin;

pub mod prelude {
    pub use crate::text_asset_loader_types::*;
    pub use crate::text_asset_types_plugin::*;
}

````



## D:\Repos\Games\Cursor-Hero\crates\secret_types\src\secrets_types.rs

````rust
use std::fmt::Debug;
use zeroize::Zeroize;

use serde::Deserialize;
use serde::Serialize;

// shout out to the secrecy crate
// ran into some issues with reflect so had to roll my own tho
// https://github.com/iqlusioninc/crates/issues/632

use bevy::prelude::*;

#[derive(Reflect, Clone, Default, Eq, PartialEq, Serialize, Deserialize)]
pub struct SecretString {
    inner: String,
}

impl SecretString {
    pub fn new(secret: String) -> Self {
        SecretString { inner: secret }
    }
    pub fn expose_secret(&self) -> &String {
        &self.inner
    }
}

impl Debug for SecretString {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "{}",
            match self.inner.len() {
                0 => "<empty>",
                _ => "<redacted>",
            }
        )
    }
}
impl Drop for SecretString {
    fn drop(&mut self) {
        self.inner.zeroize();
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\ui_automation\src\elements_at_point.rs

````rust
use bevy::math::IVec2;
use std::collections::VecDeque;
use uiautomation::types::Point;
use uiautomation::UIAutomation;
use uiautomation::UIElement;

pub fn find_element_at(pos: IVec2) -> Result<UIElement, uiautomation::Error> {
    let automation = UIAutomation::new()?;
    automation.element_from_point(Point::new(pos.x, pos.y))
}

pub fn gather_elements_at(pos: IVec2) -> Result<Vec<(UIElement, usize)>, uiautomation::Error> {
    let automation = UIAutomation::new()?;
    let walker = automation.create_tree_walker()?;
    let start = automation.element_from_point(Point::new(pos.x, pos.y))?;
    let mut rtn = vec![];
    let mut next = VecDeque::new();
    next.push_back((start, 0));
    while let Some((elem, depth)) = next.pop_front() {
        rtn.push((elem.clone(), depth));
        if let Ok(child) = walker.get_first_child(&elem) {
            next.push_back((child.clone(), depth + 1));
            let mut next_sibling = child;
            while let Ok(sibling) = walker.get_next_sibling(&next_sibling) {
                next.push_back((sibling.clone(), depth + 1));
                next_sibling = sibling;
            }
        }
    }
    Ok(rtn)
}

````



## D:\Repos\Games\Cursor-Hero\crates\wallpaper\src\main.rs

````rust
use cursor_hero_winutils::win_wallpaper::get_transcoded_wallpaper_path;
use cursor_hero_winutils::win_wallpaper::get_wallpaper_path;
use std::path::PathBuf;

/// Will update the wallpaper used in the game environment
fn main() {
    let wallpaper_path = get_wallpaper_path();
    if let Err(e) = wallpaper_path {
        panic!("Error: {:?}", e);
    }
    let mut wallpaper_path = PathBuf::from(wallpaper_path.unwrap());
    println!("Wallpaper path: {:?}", wallpaper_path);
    // check it exists
    if !wallpaper_path.exists() {
        println!("Wallpaper path does not exist, attempting transcoded path");
        wallpaper_path = match get_transcoded_wallpaper_path() {
            Ok(path) => {
                println!("Wallpaper path: {:?}", path);
                // check it exists
                if !path.exists() {
                    panic!("Wallpaper path does not exist");
                }
                path
            }
            Err(e) => panic!("Error: {:?}", e),
        };
    }
    // copy to assets/textures/environment/game/wallpaper.png
    let dest = std::path::Path::new("assets/textures/environment/game/wallpaper.png");
    std::fs::copy(wallpaper_path, dest).unwrap();
}

````



## D:\Repos\Games\Cursor-Hero\crates\winutils\src\win_window.rs

````rust
use bevy::math::IRect;
use bevy::math::IVec2;
use windows::core::PCSTR;
use windows::Win32::Foundation::HWND;
use windows::Win32::Foundation::LPARAM;
use windows::Win32::Foundation::RECT;
use windows::Win32::Foundation::WPARAM;
use windows::Win32::UI::Input::KeyboardAndMouse::ReleaseCapture;
use windows::Win32::UI::WindowsAndMessaging::FindWindowA;
use windows::Win32::UI::WindowsAndMessaging::GetClientRect;
use windows::Win32::UI::WindowsAndMessaging::GetForegroundWindow;
use windows::Win32::UI::WindowsAndMessaging::GetSystemMetrics;
use windows::Win32::UI::WindowsAndMessaging::GetWindowRect;
use windows::Win32::UI::WindowsAndMessaging::IsWindowVisible;
use windows::Win32::UI::WindowsAndMessaging::SendMessageW;
use windows::Win32::UI::WindowsAndMessaging::SetForegroundWindow;
use windows::Win32::UI::WindowsAndMessaging::ShowWindow;
use windows::Win32::UI::WindowsAndMessaging::HTCAPTION;
use windows::Win32::UI::WindowsAndMessaging::SM_CYCAPTION;
use windows::Win32::UI::WindowsAndMessaging::SM_CYFRAME;
use windows::Win32::UI::WindowsAndMessaging::SW_RESTORE;
use windows::Win32::UI::WindowsAndMessaging::WM_NCLBUTTONDOWN;

use crate::ToBevyIRect;

impl ToBevyIRect for RECT {
    fn to_bevy_irect(&self) -> IRect {
        IRect {
            min: IVec2::new(self.left, self.top),
            max: IVec2::new(self.right, self.bottom),
        }
    }
}

#[derive(Debug)]
pub enum WindowBoundsError {
    WindowNotFound,
    WindowsError(windows::core::Error),
}

#[allow(dead_code)]
pub fn get_window_bounds_from_title(title: &str) -> Result<IRect, WindowBoundsError> {
    unsafe {
        let hwnd = FindWindowA(PCSTR::null(), PCSTR(title.as_ptr() as _));
        if hwnd.0 == 0 {
            return Err(WindowBoundsError::WindowNotFound);
        }
        let mut rect = RECT::default();
        GetWindowRect(hwnd, &mut rect).map_err(WindowBoundsError::WindowsError)?;
        Ok(rect.to_bevy_irect())
    }
}

pub fn get_window_bounds(hwnd: isize) -> Result<IRect, WindowBoundsError> {
    unsafe {
        let mut rect = RECT::default();
        GetWindowRect(HWND(hwnd), &mut rect).map_err(WindowBoundsError::WindowsError)?;
        Ok(rect.to_bevy_irect())
    }
}

pub fn get_window_inner_bounds(hwnd: isize) -> Result<IRect, WindowBoundsError> {
    unsafe {
        let hwnd = HWND(hwnd);
        let mut rect = RECT::default();
        if GetClientRect(hwnd, &mut rect).is_ok() {
            Ok(rect.to_bevy_irect())
        } else {
            Err(WindowBoundsError::WindowsError(
                windows::core::Error::from_win32(),
            ))
        }
    }
}

pub fn begin_dragging(hwnd: isize) -> Result<(), windows::core::Error> {
    unsafe {
        let _join_handle = std::thread::Builder::new()
            .name("Begin move".to_string())
            .spawn(move || {
                if let Err(e) = ReleaseCapture() {
                    eprintln!("Failed to release capture: {:?}", e);
                }
                let hwnd = HWND(hwnd);
                SendMessageW(
                    hwnd,
                    WM_NCLBUTTONDOWN,
                    WPARAM(HTCAPTION as usize),
                    LPARAM(0),
                );
                println!("Sent message");
            });
        Ok(())
    }
}

pub fn get_window_title_bar_center_position(hwnd: isize) -> Result<IVec2, WindowBoundsError> {
    unsafe {
        let bounds = get_window_bounds(hwnd)?;

        // SM_CYCAPTION includes the height of the title bar
        let caption_height = GetSystemMetrics(SM_CYCAPTION);

        // SM_CYFRAME includes the height of the window frame (border)
        let frame_height = GetSystemMetrics(SM_CYFRAME);

        let pos =
            bounds.min + IVec2::new((bounds.width()) / 2, (caption_height / 2) + frame_height);
        Ok(pos)
    }
}

pub fn get_window_inner_offset() -> IVec2 {
    unsafe {
        // SM_CYCAPTION includes the height of the title bar
        let caption_height = GetSystemMetrics(SM_CYCAPTION);

        // SM_CYFRAME includes the height of the window frame (border)
        let frame_height = GetSystemMetrics(SM_CYFRAME);

        IVec2::new(frame_height, caption_height + frame_height * 2)
    }
}

pub fn focus_window(hwnd: isize) {
    unsafe {
        // Convert the isize to HWND
        let hwnd = HWND(hwnd);

        // If the window is minimized, restore it before setting it to the foreground.
        if !IsWindowVisible(hwnd).as_bool() {
            ShowWindow(hwnd, SW_RESTORE);
        }

        // Bring the window to the foreground
        SetForegroundWindow(hwnd);
    }
}

pub fn note_window_info(hwnd: isize) -> Result<IRect, WindowBoundsError> {
    unsafe {
        let hwnd = HWND(hwnd);

        // Get the window's size and location
        let mut rect = RECT::default();
        GetWindowRect(hwnd, &mut rect).map_err(WindowBoundsError::WindowsError)?;
        Ok(rect.to_bevy_irect())
    }
}

pub fn is_window_focused(hwnd: HWND) -> bool {
    unsafe {
        // Get the handle to the currently focused (foreground) window.
        let foreground_hwnd = GetForegroundWindow();

        // Compare it with the provided hwnd.
        foreground_hwnd == hwnd
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\winutils\src\win_process.rs

````rust
use crate::win_errors::*;
use windows::core::PWSTR;
use windows::Win32::Foundation::CloseHandle;
use windows::Win32::Foundation::HANDLE;
use windows::Win32::System::Diagnostics::ToolHelp::CreateToolhelp32Snapshot;
use windows::Win32::System::Diagnostics::ToolHelp::Process32FirstW;
use windows::Win32::System::Diagnostics::ToolHelp::Process32NextW;
use windows::Win32::System::Diagnostics::ToolHelp::PROCESSENTRY32W;
use windows::Win32::System::Diagnostics::ToolHelp::TH32CS_SNAPPROCESS;
use windows::Win32::System::Threading::OpenProcess;
use windows::Win32::System::Threading::QueryFullProcessImageNameW;
use windows::Win32::System::Threading::PROCESS_NAME_FORMAT;
use windows::Win32::System::Threading::PROCESS_QUERY_INFORMATION;

pub struct ProcessIterator {
    snapshot: HANDLE,
    process: PROCESSENTRY32W,
    first_done: bool,
}

impl ProcessIterator {
    pub fn new() -> Result<Self> {
        unsafe {
            let snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0)?;
            Ok(ProcessIterator {
                snapshot,
                process: PROCESSENTRY32W::default(),
                first_done: false,
            })
        }
    }
}

impl Iterator for ProcessIterator {
    type Item = PROCESSENTRY32W;

    fn next(&mut self) -> Option<Self::Item> {
        unsafe {
            self.process.dwSize = std::mem::size_of::<PROCESSENTRY32W>() as u32;
            if !self.first_done {
                self.first_done = true;
                match Process32FirstW(self.snapshot, &mut self.process) {
                    Ok(()) => Some(self.process),
                    Err(e) => {
                        eprintln!("Failed to get first process: {:?}", e);
                        None
                    }
                }
            } else {
                match Process32NextW(self.snapshot, &mut self.process) {
                    Ok(()) => Some(self.process),
                    Err(e) => {
                        if e.message() == "There are no more files." {
                            return None;
                        }
                        eprintln!("Failed to get next process: {:?}", e);
                        None
                    }
                }
            }
        }
    }
}

impl Drop for ProcessIterator {
    fn drop(&mut self) {
        unsafe {
            if let Err(e) = CloseHandle(self.snapshot) {
                eprintln!("Failed to close snapshot: {:?}", e);
            }
        };
    }
}

pub fn get_process_full_name(process_id: u32) -> Result<String> {
    unsafe {
        let process_handle: HANDLE = OpenProcess(PROCESS_QUERY_INFORMATION, false, process_id)?;
        let result = (|| {
            if process_handle.is_invalid() {
                eprintln!("Failed to open process handle");
                return Err(windows::core::Error::from_win32());
            }

            let mut buffer: Vec<u16> = Vec::with_capacity(512);
            let mut buffer_size = buffer.capacity() as u32;
            let full_name_pwstr = PWSTR(buffer.as_mut_ptr());

            QueryFullProcessImageNameW(
                process_handle,
                PROCESS_NAME_FORMAT(0),
                full_name_pwstr,
                &mut buffer_size,
            )?;
            buffer.set_len(buffer_size as usize);

            Ok(String::from_utf16_lossy(&buffer))
        })();
        if let Err(e) = CloseHandle(process_handle) {
            eprintln!("Failed to close process handle: {:?}", e);
        }
        Ok(result?)
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\hover\src\inspect_wheel_tool.rs

````rust
use bevy::prelude::*;
use cursor_hero_toolbelt_types::prelude::*;
use cursor_hero_tools::prelude::*;

pub struct InspectWheelToolPlugin;

impl Plugin for InspectWheelToolPlugin {
    fn build(&self, app: &mut App) {
        app.register_type::<InspectWheelTool>();
        app.add_systems(Update, toolbelt_events);
        app.add_systems(Update, tick);
    }
}

#[derive(Component, Reflect, Default)]
struct InspectWheelTool;

fn toolbelt_events(
    mut commands: Commands,
    asset_server: Res<AssetServer>,
    mut reader: EventReader<ToolbeltPopulateEvent>,
) {
    for event in reader.read() {
        let ToolbeltLoadout::Default = event.loadout else {
            continue;
        };
        ToolSpawnConfig::<InspectWheelTool, NoInputs>::new(InspectWheelTool, event.id, event)
            .with_src_path(file!().into())
            .guess_name(file!())
            .guess_image(file!(), &asset_server, "png")
            .with_description("Swaps to inspection tools")
            .with_starting_state(StartingState::Inactive)
            .spawn(&mut commands);
    }
}

fn tick(
    mut commands: Commands,
    tool_query: Query<&Parent, (Added<ActiveTool>, With<InspectWheelTool>)>,
    mut toolbelt_events: EventWriter<ToolbeltPopulateEvent>,
) {
    for toolbelt_id in tool_query.iter() {
        let toolbelt_id = toolbelt_id.get();
        commands.entity(toolbelt_id).despawn_descendants();
        toolbelt_events.send(ToolbeltPopulateEvent {
            id: toolbelt_id,
            loadout: ToolbeltLoadout::Inspector,
        });
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\environment\src\environment_tracker_plugin.rs

````rust
use bevy::prelude::*;
use bevy::utils::HashSet;
use bevy_xpbd_2d::components::CollidingEntities;
use cursor_hero_environment_types::prelude::*;
use cursor_hero_level_bounds::level_bounds_plugin::LevelBounds;
use cursor_hero_level_bounds::level_bounds_plugin::LevelBoundsHolder;

pub struct EnvironmentTrackerPlugin;

impl Plugin for EnvironmentTrackerPlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(Update, track);
    }
}

fn track(
    mut commands: Commands,
    mut thing_query: Query<(Entity, Option<&mut EnvironmentTracker>, &CollidingEntities)>,
    level_bounds_query: Query<&Parent, With<LevelBounds>>,
    level_bounds_holder_query: Query<&Parent, With<LevelBoundsHolder>>,
) {
    for (thing_id, thing_environment_tag, thing_colliding_entities) in thing_query.iter_mut() {
        // find out what level bounds the pointer is touching
        // find those bounds' parent
        // find the parent of the parent to get the environment ID
        let environment_ids = thing_colliding_entities
            .0
            .iter()
            .filter_map(|entity| {
                if let Ok(level_bounds_holder_id) = level_bounds_query.get(*entity) {
                    if let Ok(environment_id) =
                        level_bounds_holder_query.get(level_bounds_holder_id.get())
                    {
                        return Some(environment_id.get());
                    }
                }
                None
            })
            .collect::<HashSet<Entity>>();
        if environment_ids.len() > 1 {
            warn!(
                "Thing {:?} is touching multiple environments: {:?}",
                thing_id, environment_ids
            );
        }
        if let Some(environment_id) = environment_ids.iter().next() {
            if let Some(mut tag) = thing_environment_tag {
                tag.environment_id = *environment_id;
            } else {
                commands.entity(thing_id).insert(EnvironmentTracker {
                    environment_id: *environment_id,
                });
            }
        } else if thing_environment_tag.is_some() {
            commands.entity(thing_id).remove::<EnvironmentTracker>();
        }
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\glados_tts\src\glados_tts_inference_plugin.rs

````rust
use bevy::prelude::*;
use crossbeam_channel::bounded;
use crossbeam_channel::Receiver;
use crossbeam_channel::Sender;
use cursor_hero_inference_types::prelude::*;
use std::thread;

pub struct GladosTtsInferencePlugin;

impl Plugin for GladosTtsInferencePlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(Startup, create_worker_thread);
        app.add_systems(Update, bridge_requests);
        app.add_systems(Update, bridge_responses);
    }
}

#[derive(Debug)]
enum GameboundMessage {
    Response {
        session_id: Entity,
        prompt: SpeechPrompt,
        response: Vec<u8>,
    },
}

#[derive(Debug)]
enum ThreadboundMessage {
    Generate {
        session_id: Entity,
        prompt: SpeechPrompt,
    },
}

#[derive(Resource)]
struct Bridge {
    pub sender: Sender<ThreadboundMessage>,
    pub receiver: Receiver<GameboundMessage>,
}

fn create_worker_thread(mut commands: Commands) {
    let (game_tx, game_rx) = bounded::<_>(10);
    let (thread_tx, thread_rx) = bounded::<_>(10);
    commands.insert_resource(Bridge {
        sender: thread_tx,
        receiver: game_rx,
    });

    let game_tx_clone = game_tx.clone();
    thread::Builder::new()
        .name("GLaDOSTTS thread".to_string())
        .spawn(move || {
            let rt = tokio::runtime::Runtime::new().unwrap();
            rt.block_on(async {
                let game_tx = game_tx_clone;
                loop {
                    let msg = match thread_rx.recv() {
                        Ok(msg) => msg,
                        Err(_) => {
                            error!("Threadbound channel failure, exiting");
                            break;
                        }
                    };
                    match msg {
                        ThreadboundMessage::Generate { session_id, prompt } => {
                            debug!("Worker received generate request for session {:?}, generating response", session_id);
                            let prompt_str = match &prompt {
                                SpeechPrompt::Raw { content } => content,
                            };
                            let data = match crate::glados_tts::generate(prompt_str).await {
                                Ok(data) => data,
                                Err(e) => {
                                    error!("Failed to generate TTS: {:?}", e);
                                    continue;
                                }
                            };
                            if let Err(e) = game_tx.send(GameboundMessage::Response {
                                session_id,
                                prompt: prompt.clone(),
                                response: data,
                            }) {
                                error!("Gamebound channel failure, exiting: {:?}", e);
                                break;
                            }
                        }
                    }
                    std::thread::sleep(std::time::Duration::from_millis(50));
                }
            });
        })
        .expect("Failed to spawn thread");
}

fn bridge_requests(bridge: ResMut<Bridge>, mut events: EventReader<SpeechInferenceEvent>) {
    for event in events.read() {
        if let SpeechInferenceEvent::Request { session_id, prompt } = event {
            debug!(
                "Received generate request for session {:?}, sending over bridge to worker thread",
                session_id
            );
            if let Err(e) = bridge.sender.send(ThreadboundMessage::Generate {
                session_id: *session_id,
                prompt: prompt.clone(),
            }) {
                error!("Threadbound channel failure: {:?}", e);
            }
        }
    }
}

fn bridge_responses(bridge: ResMut<Bridge>, mut events: EventWriter<SpeechInferenceEvent>) {
    for msg in bridge.receiver.try_iter() {
        match msg {
            GameboundMessage::Response {
                session_id,
                prompt,
                response,
            } => {
                debug!(
                    "Received bridge response for session {:?}, sending game event",
                    session_id
                );
                events.send(SpeechInferenceEvent::Response {
                    session_id,
                    prompt,
                    wav: response,
                });
            }
        }
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\voice_to_text_types\src\voice_to_text_types.rs

````rust
use std::fmt::Debug;
use std::time::Duration;

use bevy::prelude::*;
use bevy::utils::Instant;
use cursor_hero_secret_types::prelude::*;

#[derive(Reflect, Resource, Default, Debug, Clone, Eq, PartialEq)]
#[reflect(Resource)]
pub enum VoiceToTextStatus {
    #[default]
    Unknown,
    UnknownWithCachedApiKey {
        api_key: SecretString,
    },
    Alive {
        api_key: SecretString,
        listening: bool,
    },
    AliveButWeDontKnowTheApiKey,
    Dead,
    Starting {
        instant: Instant,
        timeout: Duration,
        api_key: SecretString,
    },
}

#[derive(Event, Debug, Reflect)]
pub enum VoiceToTextPingEvent {
    Ping,
    Pong { status: VoiceToTextStatus },
}

#[derive(Event, Debug, Reflect)]
pub enum VoiceToTextStatusEvent {
    Changed {
        old_status: VoiceToTextStatus,
        new_status: VoiceToTextStatus,
    },
}

#[derive(Event, Debug, Reflect)]
pub enum VoiceToTextTranscriptionEvent {
    Received { transcription: String },
}

#[derive(Event, Debug, Reflect)]
pub enum VoiceToTextCommandEvent {
    Startup,
    SetListening {
        listening: bool,
        api_key: SecretString,
    },
    ConnectReceiver {
        api_key: SecretString,
    },
}

#[derive(Component, Debug, Reflect, Default)]
pub struct VoiceToTextStatusButton {
    pub visual_state: VoiceToTextStatusButtonVisualState,
}

#[derive(Debug, Reflect, Eq, PartialEq)]
pub enum VoiceToTextStatusButtonVisualState {
    Default { status: VoiceToTextStatus },
    Hovered { status: VoiceToTextStatus },
    Pressed { status: VoiceToTextStatus },
}
impl Default for VoiceToTextStatusButtonVisualState {
    fn default() -> Self {
        VoiceToTextStatusButtonVisualState::Default {
            status: VoiceToTextStatus::Unknown,
        }
    }
}

#[derive(Component, Debug, Reflect, Default)]
pub struct VoiceToTextVscodeButton {
    pub visual_state: VoiceToTextVscodeButtonVisualState,
}
#[derive(Debug, Reflect, Eq, PartialEq, Default)]
pub enum VoiceToTextVscodeButtonVisualState {
    #[default]
    Default,
}
#[derive(Event, Debug, Reflect)]
pub enum VoiceToTextVscodeEvent {
    Startup,
}

````



## D:\Repos\Games\Cursor-Hero\crates\memory_types\src\lib.rs

````rust
mod memory_types;
mod memory_types_plugin;

pub mod prelude {
    pub use crate::memory_types::*;
    pub use crate::memory_types_plugin::*;
}

````



## D:\Repos\Games\Cursor-Hero\crates\host_fs\src\host_fs_plugin.rs

````rust
use bevy::prelude::*;
use cursor_hero_host_fs_types::host_fs_types::HostPathAction;

pub struct HostFsPlugin;

impl Plugin for HostFsPlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(Update, handle_host_path_events);
    }
}

fn handle_host_path_events(mut host_path_events: EventReader<HostPathAction>) {
    for event in host_path_events.read() {
        match event {
            HostPathAction::OpenWithCode { path } => {
                println!("Open with code: {:?}", path);
                let Some(x) = path.path.to_str() else {
                    continue;
                };
                if let Err(e) = std::process::Command::new("code.cmd").arg(x).spawn() {
                    error!("Failed to open with code: {:?}", e);
                }
            }
        }
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\tools\src\window_drag_tool.rs

````rust
use bevy::prelude::*;
use bevy::window::PrimaryWindow;
use bevy::winit::WinitWindows;
use bevy_inspector_egui::bevy_egui::EguiContext;
use cursor_hero_toolbelt_types::prelude::*;
use leafwing_input_manager::prelude::*;

use crate::prelude::*;

pub struct WindowDragToolPlugin;

impl Plugin for WindowDragToolPlugin {
    fn build(&self, app: &mut App) {
        app.register_type::<WindowDragTool>();
        app.register_type::<WindowDragToolInteractable>();
        app.add_plugins(InputManagerPlugin::<WindowDragToolAction>::default());
        app.add_systems(Update, toolbelt_events);
        app.add_systems(Update, handle_input);
    }
}

#[derive(Component, Reflect, Default)]
struct WindowDragTool;

fn toolbelt_events(
    mut commands: Commands,
    asset_server: Res<AssetServer>,
    mut reader: EventReader<ToolbeltPopulateEvent>,
) {
    for event in reader.read() {
        let ToolbeltLoadout::Default = event.loadout else {
            continue;
        };
        ToolSpawnConfig::<WindowDragTool, WindowDragToolAction>::new(
            WindowDragTool,
            event.id,
            event,
        )
        .with_src_path(file!().into())
        .guess_name(file!())
        .guess_image(file!(), &asset_server, "png")
        .with_description("Drag the window from its body")
        .spawn(&mut commands);
    }
}

#[derive(Actionlike, PartialEq, Eq, Clone, Copy, Hash, Debug, Reflect)]
enum WindowDragToolAction {
    Drag,
}

impl WindowDragToolAction {
    fn default_gamepad_binding(&self) -> UserInput {
        match self {
            Self::Drag => GamepadButtonType::LeftThumb.into(),
        }
    }

    fn default_mkb_binding(&self) -> UserInput {
        match self {
            Self::Drag => MouseButton::Left.into(),
        }
    }
}
impl ToolAction for WindowDragToolAction {
    fn default_input_map(_event: &ToolbeltPopulateEvent) -> Option<InputMap<WindowDragToolAction>> {
        let mut input_map = InputMap::default();

        for variant in WindowDragToolAction::variants() {
            input_map.insert(variant.default_mkb_binding(), variant);
            input_map.insert(variant.default_gamepad_binding(), variant);
        }
        Some(input_map)
    }
}

#[derive(Component, Reflect)]
pub struct WindowDragToolInteractable;

fn handle_input(
    tool_query: Query<&ActionState<WindowDragToolAction>, With<ActiveTool>>,
    window_query: Query<Entity, With<PrimaryWindow>>,
    winit_windows: NonSend<WinitWindows>,
    egui_context_query: Query<&EguiContext, With<PrimaryWindow>>,
) {
    let Ok(egui_context) = egui_context_query.get_single() else {
        return;
    };
    let hovering_over_egui = egui_context.clone().get_mut().is_pointer_over_area();
    for action_state in tool_query.iter() {
        if action_state.just_pressed(WindowDragToolAction::Drag) {
            if hovering_over_egui {
                continue;
            }
            let Ok(window_id) = window_query.get_single() else {
                error!("No primary window found");
                return;
            };
            if let Some(winit_window) = winit_windows.get_window(window_id) {
                // winit_window.window_state_lock
                if let Err(x) = winit_window.drag_window() {
                    error!("Failed to drag window: {:?}", x);
                }
            }
            return;
        }
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\ui_automation\examples\ui_hover_example.rs

````rust
#![feature(let_chains, trivial_bounds)]
use std::collections::VecDeque;

use bevy::input::common_conditions::input_toggle_active;
use bevy::log::LogPlugin;
use bevy::prelude::*;
use bevy::utils::HashMap;
use bevy::window::PrimaryWindow;
use bevy_egui::egui;
use bevy_egui::egui::Align2;
use bevy_egui::EguiContexts;
use bevy_egui::EguiSet;
use bevy_inspector_egui::quick::WorldInspectorPlugin;
use bevy_inspector_egui::reflect_inspector::Context;
use bevy_inspector_egui::reflect_inspector::InspectorUi;
use cursor_hero_memory::primary_window_memory_plugin::PrimaryWindowMemoryPlugin;
use cursor_hero_ui_automation::prelude::*;
use cursor_hero_winutils::win_mouse::get_cursor_position;
use cursor_hero_worker::prelude::Message;
use cursor_hero_worker::prelude::Sender;
use cursor_hero_worker::prelude::WorkerConfig;
use cursor_hero_worker::prelude::WorkerPlugin;
use itertools::Itertools;
use uiautomation::UIAutomation;
fn main() {
    let mut app = App::new();
    app.add_plugins(
        DefaultPlugins
            .set(LogPlugin {
                level: bevy::log::Level::DEBUG,
                filter: "
info,
wgpu_core=warn,
wgpu_hal=warn,
ui_hover_example=trace,
cursor_hero_worker=debug,
"
                .replace('\n', "")
                .trim()
                .into(),
            })
            .build(),
    );
    app.add_plugins(WorkerPlugin {
        config: WorkerConfig::<ThreadboundUISnapshotMessage, GameboundUISnapshotMessage> {
            name: "ui_hover".to_string(),
            is_ui_automation_thread: true,
            handle_threadbound_message: handle_threadbound_message,
            handle_threadbound_message_error_handler: handle_threadbound_message_error_handler,
            ..default()
        },
    });
    app.add_plugins(
        WorldInspectorPlugin::default().run_if(input_toggle_active(false, KeyCode::Grave)),
    );
    app.add_plugins(PrimaryWindowMemoryPlugin);
    app.insert_resource(ClearColor(Color::rgb(0.992, 0.714, 0.69)));
    app.add_systems(Startup, spawn_camera);
    app.add_systems(Update, periodic_snapshot);
    app.add_systems(Update, fetch_requested);
    app.add_systems(Update, receive);
    app.add_systems(Update, gui.after(EguiSet::InitContexts));
    app.init_resource::<UIData>();
    app.register_type::<UIData>();
    app.run();
}

fn spawn_camera(mut commands: Commands) {
    commands.spawn(Camera2dBundle::default());
}

#[derive(Debug, Reflect, Clone, Event)]
enum ThreadboundUISnapshotMessage {
    CaptureHovered,
    ChildrenFetchRequest {
        drill_id: DrillId,
        runtime_id: RuntimeId,
    },
}
impl Message for ThreadboundUISnapshotMessage {}

#[derive(Debug, Reflect, Clone, Event)]
enum GameboundUISnapshotMessage {
    Hovered {
        ui_tree: ElementInfo,
        start: ElementInfo,
        hovered: ElementInfo,
    },
    ChildrenFetchResponse {
        drill_id: DrillId,
        runtime_id: RuntimeId,
        children: Vec<ElementInfo>,
    },
    Error,
}
impl Message for GameboundUISnapshotMessage {}

#[derive(Debug, Reflect)]
enum FetchingState {
    FetchRequest,
    FetchDispatched,
    Fetched(Vec<ElementInfo>),
}

#[derive(Resource, Debug, Reflect, Default)]
#[reflect(Resource)]
struct UIData {
    pub start: ElementInfo,
    pub hovered: ElementInfo,
    pub ui_tree: ElementInfo,
    pub selected: Option<DrillId>,
    pub expanded: Vec<DrillId>,
    pub fresh: bool,
    pub in_flight: bool,
    pub paused: bool,
    // Include runtime id in case tree changes and we quickly fetch something with the same drill_id before the first request comes back
    pub fetching: HashMap<(DrillId, RuntimeId), FetchingState>,
}

fn handle_threadbound_message_error_handler(
    _msg: &ThreadboundUISnapshotMessage,
    reply_tx: &Sender<GameboundUISnapshotMessage>,
    error: &Box<dyn std::error::Error>,
) -> Result<(), Box<dyn std::error::Error>> {
    reply_tx.send(GameboundUISnapshotMessage::Error)?;
    Ok(())
}
fn handle_threadbound_message(
    msg: &ThreadboundUISnapshotMessage,
    reply_tx: &Sender<GameboundUISnapshotMessage>,
) -> Result<(), Box<dyn std::error::Error>> {
    match msg {
        ThreadboundUISnapshotMessage::CaptureHovered => {
            debug!("taking snapshot");
            let cursor_pos = get_cursor_position()?;
            let hovered = find_element_at(cursor_pos)?;
            let hovered_info = gather_single_element_info(&hovered)?;
            let gathered = gather_incomplete_ui_tree_starting_deep(hovered)?;
            if let Err(e) = reply_tx.send(GameboundUISnapshotMessage::Hovered {
                ui_tree: gathered.ui_tree,
                start: gathered.start_info,
                hovered: hovered_info,
            }) {
                error!("Failed to send snapshot: {:?}", e);
            }
        }
        ThreadboundUISnapshotMessage::ChildrenFetchRequest {
            drill_id,
            runtime_id,
        } => {
            debug!("fetching children for {:?}", drill_id);
            let automation = UIAutomation::new()?;
            let walker = automation.create_tree_walker()?;
            let root = automation.get_root_element()?;
            let found = root.drill(&walker, drill_id.clone())?;
            let mut children = found
                .gather_children(&walker, &StopBehaviour::EndOfSiblings)
                .into_iter()
                .enumerate()
                .filter_map(|(i, child)| {
                    gather_single_element_info(&child)
                        .ok()
                        .map(|mut child_info| {
                            child_info.drill_id = DrillId::Child(vec![i].into_iter().collect());
                            child_info
                        })
                })
                .collect_vec();

            update_drill_ids(Some(&mut children), &drill_id);
            if let Err(e) = reply_tx.send(GameboundUISnapshotMessage::ChildrenFetchResponse {
                drill_id: drill_id.clone(),
                runtime_id: runtime_id.clone(),
                children,
            }) {
                error!("Failed to send ChildrenFetchResponse: {:?}", e);
            }
        }
    }
    Ok(())
}

fn fetch_requested(
    mut data: ResMut<UIData>,
    mut events: EventWriter<ThreadboundUISnapshotMessage>,
) {
    for (key, state) in data.fetching.iter_mut() {
        if let FetchingState::FetchRequest = state {
            *state = FetchingState::FetchDispatched;
            events.send(ThreadboundUISnapshotMessage::ChildrenFetchRequest {
                drill_id: key.0.clone(),
                runtime_id: key.1.clone(),
            });
        }
    }
}

fn periodic_snapshot(
    mut data: ResMut<UIData>,
    mut cooldown: Local<Option<Timer>>,
    time: Res<Time>,
    mut events: EventWriter<ThreadboundUISnapshotMessage>,
    window: Query<&Window, With<PrimaryWindow>>,
) {
    let Ok(window) = window.get_single() else {
        return;
    };
    if window.cursor_position().is_some() {
        return;
    }
    let cooldown_over = if let Some(cooldown) = cooldown.as_mut() {
        if cooldown.tick(time.delta()).just_finished() {
            cooldown.reset();
            true
        } else {
            false
        }
    } else {
        cooldown.replace(Timer::from_seconds(0.5, TimerMode::Repeating));
        true
    };
    if !cooldown_over {
        return;
    }

    if data.paused {
        return;
    }

    if data.in_flight {
        warn!("Too fast!");
        return;
    }

    events.send(ThreadboundUISnapshotMessage::CaptureHovered);
    data.in_flight = true;
}

fn receive(mut snapshot: EventReader<GameboundUISnapshotMessage>, mut ui_data: ResMut<UIData>) {
    for msg in snapshot.read() {
        match msg {
            GameboundUISnapshotMessage::Error => {
                ui_data.in_flight = false;
            }
            GameboundUISnapshotMessage::Hovered {
                ui_tree,
                start,
                hovered,
            } => {
                ui_data.in_flight = false;
                ui_data.ui_tree = ui_tree.clone();
                ui_data.start = start.clone();
                ui_data.hovered = hovered.clone();
                ui_data.selected = Some(start.drill_id.clone());
                ui_data.expanded = ui_tree
                    .get_descendents()
                    .iter()
                    .chain([ui_tree].iter())
                    .filter(|x| x.children.is_some())
                    .map(|x| x.drill_id.clone())
                    .collect();
                ui_data.fresh = true;
                debug!("Received snapshot");
            }
            GameboundUISnapshotMessage::ChildrenFetchResponse {
                drill_id,
                runtime_id,
                children,
            } => {
                let key = (drill_id.clone(), runtime_id.clone());
                if let Some(FetchingState::FetchDispatched) = ui_data.fetching.get(&key) {
                    ui_data
                        .fetching
                        .insert(key, FetchingState::Fetched(children.clone()));
                }
            }
        }
    }
}

fn gui(
    mut contexts: EguiContexts,
    mut ui_data: ResMut<UIData>,
    type_registry: Res<AppTypeRegistry>,
) {
    let ctx = contexts.ctx_mut();

    let mut cx = Context {
        world: None,
        queue: None,
    };

    let type_registry = type_registry.0.clone();
    let type_registry = type_registry.read();
    let mut inspector = InspectorUi::for_bevy(&type_registry, &mut cx);

    let id = egui::Id::new("Inspector");
    egui::Window::new("Inspector")
        .title_bar(false)
        .id(id)
        .default_pos((5.0, 5.0))
        .default_width(1200.0)
        .default_height(1000.0)
        .show(ctx, |ui| {
            egui::SidePanel::left(id.with("tree"))
                .resizable(true)
                .width_range(100.0..=4000.0)
                .default_width(600.0)
                .show_inside(ui, |ui| {
                    ui.vertical_centered(|ui| {
                        ui.heading("UI Tree");
                    });
                    egui::ScrollArea::both().show(ui, |ui| {
                        let id = id.with(ui_data.ui_tree.runtime_id.clone());
                        let mut elem = ui_data.ui_tree.clone();
                        ui_for_element_info(id, ui, &mut ui_data, &mut elem, &mut inspector);
                        ui_data.ui_tree = elem;
                        ui.allocate_space(ui.available_size());
                    });
                });

            egui::TopBottomPanel::bottom(id.with("invisible bottom panel"))
                .show_separator_line(false)
                .show_inside(ui, |_| ());

            egui::CentralPanel::default().show_inside(ui, |ui| {
                ui.vertical_centered(|ui| {
                    ui.heading("Properties");
                });
                let id = ui_data.selected.clone();
                if let Some(id) = id
                    && let Some(x) = ui_data.ui_tree.lookup_drill_id_mut(id)
                {
                    inspector.ui_for_reflect_readonly(x, ui);
                    ui.separator();
                    ui.label("drill_id");
                    let drill_id = x.drill_id.to_string();
                    inspector.ui_for_reflect_readonly(&drill_id, ui);
                    if ui.button("copy").clicked() {
                        ui.output_mut(|out| {
                            out.copied_text = drill_id.clone();
                        });
                        info!("Copied drill_id {} to clipboard", drill_id);
                    }
                }
                // inspector.ui_for_reflect_readonly(&data, ui);
            });
        });

    let id = egui::Id::new("Paused");
    egui::Window::new("Paused")
        .id(id)
        .title_bar(false)
        .anchor(Align2::RIGHT_TOP, (5.0, 5.0))
        .show(ctx, |ui| {
            ui.checkbox(&mut ui_data.paused, "Paused");
        });
    ui_data.fresh = false;
}

#[allow(clippy::too_many_arguments)]
fn ui_for_element_info(
    id: egui::Id,
    ui: &mut egui::Ui,
    data: &mut UIData,
    element_info: &mut ElementInfo,
    _inspector: &mut InspectorUi,
) {
    let default_open = data.expanded.contains(&element_info.drill_id);
    let mut expando = egui::collapsing_header::CollapsingState::load_with_default_open(
        ui.ctx(),
        id,
        default_open,
    );
    if data.fresh {
        expando.set_open(default_open);
        data.fetching.clear();
    }
    if expando.is_open() && element_info.children.is_none() {
        let key = (
            element_info.drill_id.clone(),
            element_info.runtime_id.clone(),
        );
        let found = data.fetching.get_mut(&key);
        if !found.is_some() {
            data.fetching.insert(key, FetchingState::FetchRequest);
        } else if let Some(FetchingState::Fetched(ref mut children)) = found {
            element_info.children = Some(std::mem::take(children));
            data.fetching.remove(&key);
        } else {
            ui.label("fetching...");
        }
    }
    expando
        .show_header(ui, |ui| {
            let mut selected = data.selected == Some(element_info.drill_id.clone());
            if selected && data.fresh {
                ui.scroll_to_cursor(Some(egui::Align::Center));
            }
            if ui
                .toggle_value(
                    &mut selected,
                    format!(
                        "{:?} | {}",
                        element_info.name, element_info.localized_control_type
                    ),
                )
                .changed()
            {
                data.selected = if selected {
                    Some(element_info.drill_id.clone())
                } else {
                    None
                };
            };
        })
        .body(|ui| {
            if let Some(ref mut children) = element_info.children {
                for child in children.iter_mut() {
                    ui_for_element_info(
                        id.with(child.runtime_id.clone()),
                        ui,
                        data,
                        child,
                        _inspector,
                    );
                }
            }
        });
}

````



## D:\Repos\Games\Cursor-Hero\crates\chat\src\lib.rs

````rust
pub mod chat_bubble_plugin;
pub mod chat_focus_exclusivity_plugin;
pub mod chat_input_buffer_plugin;
pub mod chat_plugin;
pub mod chat_sfx_plugin;
pub mod chat_tool_plugin;

````



## D:\Repos\Games\Cursor-Hero\crates\memory\src\main_camera_memory_plugin.rs

````rust
use bevy::prelude::*;
use cursor_hero_camera::camera_plugin::MainCamera;
use cursor_hero_memory_types::prelude::*;
use serde::Deserialize;
use serde::Serialize;

pub struct MainCameraMemoryPlugin;

impl Plugin for MainCameraMemoryPlugin {
    fn build(&self, app: &mut App) {
        app.insert_resource(MainCameraMemoryConfig::default());
        app.add_systems(Update, persist.pipe(handle_persist_errors));
        app.add_systems(Update, restore.pipe(handle_restore_errors));
    }
}
const PERSIST_FILE_NAME: &str = "main_camera.json";

// not moved to lib to ensure log contains this module name
fn handle_persist_errors(In(result): In<Result<PersistSuccess, PersistError>>) {
    if let Err(e) = result {
        error!("Persist error occurred: {:?}", e);
    } else if let Ok(PersistSuccess::WritePerformed) = result {
        debug!("Persisted succeeded");
    }
}

fn handle_restore_errors(In(result): In<Result<RestoreSuccess, RestoreError>>) {
    if let Err(e) = result {
        error!("Restore error occurred: {:?}", e);
    } else if let Ok(RestoreSuccess::Performed) = result {
        info!("Restore succeeded");
    }
}

#[derive(Debug, Resource, Reflect)]
#[reflect(Resource)]
struct MainCameraMemoryConfig {
    pub debounce_timer: Timer,
}
impl Default for MainCameraMemoryConfig {
    fn default() -> Self {
        Self {
            debounce_timer: Timer::from_seconds(10.0, TimerMode::Repeating),
        }
    }
}

#[derive(Debug, Serialize, Deserialize, PartialEq, Clone, Copy)]
struct DiskData {
    scale: Vec3,
}

fn persist(
    mut config: ResMut<MainCameraMemoryConfig>,
    mut debounce: Local<Option<DiskData>>,
    time: Res<Time>,
    camera_query: Query<&Transform, With<MainCamera>>,
) -> Result<PersistSuccess, PersistError> {
    if !config.debounce_timer.tick(time.delta()).just_finished() {
        return Ok(PersistSuccess::Cooldown);
    }

    let camera_transform = camera_query.get_single().map_err(|_| PersistError::Query)?;

    let data = DiskData {
        scale: camera_transform.scale,
    };
    if debounce.is_none() || debounce.as_ref().unwrap() != &data {
        let file = get_persist_file(file!(), PERSIST_FILE_NAME, Usage::Persist)
            .map_err(PersistError::Io)?;
        write_to_disk(file, data)?;
        *debounce = Some(data);
        Ok(PersistSuccess::WritePerformed)
    } else {
        Ok(PersistSuccess::Debounce)
    }
}

fn restore(
    mut camera_query: Query<&mut Transform, Added<MainCamera>>,
) -> Result<RestoreSuccess, RestoreError> {
    let Ok(mut camera_transform) = camera_query.get_single_mut() else {
        return Ok(RestoreSuccess::NoAction);
    };
    let file =
        get_persist_file(file!(), PERSIST_FILE_NAME, Usage::Restore).map_err(RestoreError::Io)?;
    let data: DiskData = read_from_disk(file)?;
    info!("Restoring main camera scale to {:?}", data.scale);
    camera_transform.scale = data.scale;
    Ok(RestoreSuccess::Performed)
}

````



## D:\Repos\Games\Cursor-Hero\crates\memory\src\primary_window_memory_plugin.rs

````rust
use bevy::prelude::*;
use bevy::window::PrimaryWindow;
use bevy::window::RawHandleWrapper;
use bevy::window::WindowMode;
use bevy::window::WindowResolution;
use bevy::winit::WinitWindows;
use cursor_hero_memory_types::prelude::*;
use cursor_hero_winutils::win_window::get_window_inner_bounds;
use serde::Deserialize;
use serde::Serialize;

pub struct PrimaryWindowMemoryPlugin;

// TODO: remember maximized status

impl Plugin for PrimaryWindowMemoryPlugin {
    fn build(&self, app: &mut App) {
        app.insert_resource(PrimaryWindowMemoryConfig::default());
        app.add_systems(Update, persist.pipe(handle_persist_errors));
        app.add_systems(Update, restore.pipe(handle_restore_errors));
    }
}

const PERSIST_FILE_NAME: &str = "primary_window.json";

// not moved to lib to ensure log contains this module name
fn handle_persist_errors(In(result): In<Result<PersistSuccess, PersistError>>) {
    if let Err(e) = result {
        error!("Persist error occurred: {:?}", e);
    } else if let Ok(PersistSuccess::WritePerformed) = result {
        debug!("Persisted succeeded");
    }
}

fn handle_restore_errors(In(result): In<Result<RestoreSuccess, RestoreError>>) {
    if let Err(e) = result {
        error!("Restore error occurred: {:?}", e);
    } else if let Ok(RestoreSuccess::Performed) = result {
        info!("Restore succeeded");
    }
}

#[derive(Debug, Resource, Reflect)]
#[reflect(Resource)]
struct PrimaryWindowMemoryConfig {
    pub debounce_timer: Timer,
}
impl Default for PrimaryWindowMemoryConfig {
    fn default() -> Self {
        Self {
            debounce_timer: Timer::from_seconds(10.0, TimerMode::Repeating),
        }
    }
}

#[derive(Debug, Serialize, Deserialize, PartialEq, Clone, Copy)]
struct DiskData {
    resolution: Vec2,
    position: IVec2,
    mode: WindowMode,
}

fn persist(
    mut config: ResMut<PrimaryWindowMemoryConfig>,
    time: Res<Time>,
    window_query: Query<(Entity, &RawHandleWrapper, &Window), With<PrimaryWindow>>,
    winit_windows: NonSend<WinitWindows>,
    mut debounce: Local<Option<DiskData>>,
) -> Result<PersistSuccess, PersistError> {
    if !config.debounce_timer.tick(time.delta()).just_finished() {
        return Ok(PersistSuccess::Cooldown);
    }

    let (window_id, window_handle, window) =
        window_query.get_single().map_err(|_| PersistError::Query)?;

    let winit_window = winit_windows
        .get_window(window_id)
        .ok_or(PersistError::Query)?;

    if winit_window.is_minimized().unwrap_or(false) {
        return Ok(PersistSuccess::NoAction);
    }
    let resolution = Vec2::new(
        window.resolution.physical_width() as f32,
        window.resolution.physical_height() as f32,
    );
    let position = match window.position {
        WindowPosition::At(position) => position,
        _ => {
            let hwnd = match window_handle.window_handle {
                raw_window_handle::RawWindowHandle::Win32(handle) => handle.hwnd as isize,
                _ => return Ok(PersistSuccess::NoAction),
            };
            get_window_inner_bounds(hwnd)
                .map_err(PersistError::WindowBounds)?
                .size()
        }
    };

    let data = DiskData {
        resolution,
        position,
        mode: window.mode,
    };
    if debounce.is_none() || debounce.as_ref().unwrap() != &data {
        let minimized = position.x == -32000 || position.y == -32000;
        if minimized {
            return Ok(PersistSuccess::NoAction);
        }
        let file = get_persist_file(file!(), PERSIST_FILE_NAME, Usage::Persist)
            .map_err(PersistError::Io)?;
        write_to_disk(file, data)?;
        *debounce = Some(data);
        Ok(PersistSuccess::WritePerformed)
    } else {
        Ok(PersistSuccess::Debounce)
    }
}

fn restore(
    mut window_query: Query<&mut Window, Added<PrimaryWindow>>,
) -> Result<RestoreSuccess, RestoreError> {
    let Ok(mut window) = window_query.get_single_mut() else {
        return Ok(RestoreSuccess::NoAction);
    };
    let file =
        get_persist_file(file!(), PERSIST_FILE_NAME, Usage::Restore).map_err(RestoreError::Io)?;
    let data = read_from_disk::<DiskData>(file)?;
    window.resolution = WindowResolution::from(data.resolution);
    window.position = WindowPosition::At(data.position);
    window.mode = data.mode;

    Ok(RestoreSuccess::Performed)
}

````



## D:\Repos\Games\Cursor-Hero\crates\observation\src\observation_log_plugin.rs

````rust
use bevy::prelude::*;
use cursor_hero_observation_types::prelude::*;

pub struct ObservationLogPlugin;

impl Plugin for ObservationLogPlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(Update, log_observations);
    }
}

fn log_observations(mut observation_event_reader: EventReader<SomethingObservableHappenedEvent>) {
    for event in observation_event_reader.read() {
        info!("{:?}", event);
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\calculator_app\src\calculator_app_plugin.rs

````rust
use bevy::prelude::*;

pub struct CalculatorAppPlugin;

impl Plugin for CalculatorAppPlugin {
    fn build(&self, _app: &mut App) {}
}

````



## D:\Repos\Games\Cursor-Hero\crates\start_menu_types\src\start_menu_types_plugin.rs

````rust
use crate::prelude::*;
use bevy::prelude::*;

pub struct StartMenuTypesPlugin;

impl Plugin for StartMenuTypesPlugin {
    fn build(&self, app: &mut App) {
        app.register_type::<StartMenuButton>();

        app.register_type::<StartMenu>();
        app.add_event::<StartMenuEvent>();
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\cursor_mirror\src\lib.rs

````rust
pub mod cursor_mirroring_plugin;

````



## D:\Repos\Games\Cursor-Hero\crates\calculator_app_types\src\lib.rs

````rust
pub mod calculator_app_types;
pub mod calculator_app_types_plugin;

pub mod prelude {
    pub use crate::calculator_app_types::*;
    pub use crate::calculator_app_types_plugin::*;
}

````



## D:\Repos\Games\Cursor-Hero\crates\toolbelt\src\tool_activation.rs

````rust
use cursor_hero_toolbelt_types::toolbelt_types::*;

use bevy::prelude::*;
use cursor_hero_pointer_types::prelude::*;

use leafwing_input_manager::action_state::ActionState;

#[allow(clippy::type_complexity)]
pub fn tool_activation(
    mut commands: Commands,
    hovered_query: Query<(Entity, Option<&ActiveTool>, Option<&Name>), With<Hovered>>,
    toolbelt_query: Query<(&ActionState<ToolbeltAction>, &Children)>,
    mut events: EventWriter<ToolActivationEvent>,
) {
    for (toolbelt_actions, toolbelt_kids) in toolbelt_query.iter() {
        if toolbelt_actions.just_released(ToolbeltAction::Show) {
            for (hovered_id, hovered_active, hovered_name) in toolbelt_kids
                .iter()
                .filter_map(|h| hovered_query.get(*h).ok())
            {
                if hovered_active.is_some() {
                    commands.entity(hovered_id).remove::<ActiveTool>();
                    events.send(ToolActivationEvent::Deactivate(hovered_id));
                    info!("Deactivating tool: {:?} ({:?})", hovered_name, hovered_id);
                } else {
                    commands.entity(hovered_id).insert(ActiveTool);
                    events.send(ToolActivationEvent::Activate(hovered_id));
                    info!("Activating tool: {:?} ({:?})", hovered_name, hovered_id);
                }
            }
        }
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\voice_to_text\src\voice_to_text_ping_plugin.rs

````rust
use bevy::prelude::*;
use bevy::utils::Instant;
use cursor_hero_voice_to_text_types::prelude::*;

pub struct VoiceToTextPingPlugin;

impl Plugin for VoiceToTextPingPlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(Update, periodic_ping);
        app.add_systems(Update, handle_pong);
        app.add_systems(Update, init_receiver_once_alive);
    }
}

fn periodic_ping(
    mut ping_events: EventWriter<VoiceToTextPingEvent>,
    mut last_ping: Local<Option<Instant>>,
) {
    if let Some(instant) = *last_ping {
        if instant.elapsed().as_secs() > 5 {
            ping_events.send(VoiceToTextPingEvent::Ping);
            *last_ping = Some(Instant::now());
        }
    } else {
        ping_events.send(VoiceToTextPingEvent::Ping);
        *last_ping = Some(Instant::now());
    }
}

fn handle_pong(
    mut ping_events: EventReader<VoiceToTextPingEvent>,
    mut status_events: EventWriter<VoiceToTextStatusEvent>,
    mut current_status: ResMut<VoiceToTextStatus>,
) {
    for event in ping_events.read() {
        let VoiceToTextPingEvent::Pong { status: new_status } = event else {
            continue;
        };
        // identify the new state based on the pong
        // if the pong says dead and the current state is starting, only change to dead if the timeout has been exceeded
        let new_status = match (&*current_status, new_status) {
            (
                VoiceToTextStatus::Starting {
                    instant,
                    timeout,
                    api_key,
                },
                status,
            ) => {
                if let VoiceToTextStatus::Alive {
                    api_key: other_api_key,
                    listening,
                } = status
                {
                    // Unlikely branch, but lets be safe
                    if other_api_key != api_key {
                        warn!("Received pong with Alive status with an api key different from the one we tracked when starting the program, overwriting api key")
                    }
                    VoiceToTextStatus::Alive {
                        api_key: other_api_key.clone(),
                        listening: *listening,
                    }
                } else if *status == VoiceToTextStatus::AliveButWeDontKnowTheApiKey {
                    // A server has responded to our ping, assume the API key is the one we tracked when we started the program
                    VoiceToTextStatus::Alive {
                        api_key: api_key.clone(),
                        listening: false,
                    }
                } else if instant.elapsed() > *timeout {
                    // Only accept the dead status if the timeout has been exceeded
                    VoiceToTextStatus::Dead
                } else {
                    // Timeout not exceeded, keep the current status (starting)
                    current_status.clone()
                }
            }
            (VoiceToTextStatus::Alive { .. }, VoiceToTextStatus::AliveButWeDontKnowTheApiKey) => {
                // Ping is alive, retain the api key
                current_status.clone()
            }
            (
                VoiceToTextStatus::UnknownWithCachedApiKey { api_key },
                VoiceToTextStatus::AliveButWeDontKnowTheApiKey,
            ) => {
                // Ping is alive, use the cached api key
                VoiceToTextStatus::Alive {
                    api_key: api_key.clone(),
                    listening: false,
                }
            }
            (a, b) => {
                debug!(
                    "Received pong with status {:?} but the current status is {:?}",
                    b, a
                );
                new_status.clone()
            }
        };

        if *current_status != new_status {
            let event = VoiceToTextStatusEvent::Changed {
                old_status: current_status.clone(),
                new_status: new_status.clone(),
            };
            debug!("Sending event {:?}", event);
            status_events.send(event);

            *current_status = new_status;
        }
    }
}

fn init_receiver_once_alive(
    mut command_events: EventWriter<VoiceToTextCommandEvent>,
    mut status_events: EventReader<VoiceToTextStatusEvent>,
) {
    for event in status_events.read() {
        let VoiceToTextStatusEvent::Changed {
            new_status,
            old_status,
        } = event;
        if !matches!(
            old_status,
            VoiceToTextStatus::Starting { .. } | VoiceToTextStatus::UnknownWithCachedApiKey { .. }
        ) {
            continue;
        }
        let VoiceToTextStatus::Alive { api_key, .. } = new_status else {
            continue;
        };
        let event = VoiceToTextCommandEvent::ConnectReceiver {
            api_key: api_key.clone(),
        };
        debug!("Now alive, sending event: {:?}", event);
        command_events.send(event);
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\toolbelt\src\lib.rs

````rust
#![feature(let_chains)]

pub mod hover_frame;
pub mod tool_activation;
pub mod tool_color;
pub mod tool_help_activate;
pub mod tool_help_cleanup;
pub mod tool_help_click;
pub mod tool_help_populate;
pub mod tool_visibility;
pub mod toolbelt_circle_layout_plugin;
pub mod toolbelt_opening_plugin;
pub mod toolbelt_plugin;
pub mod toolbelt_properties_plugin;
pub mod toolbelt_taskbar_layout_plugin;
pub mod wheel_audio;

````



## D:\Repos\Games\Cursor-Hero\crates\tools\src\tool_plugin.rs

````rust
use bevy::prelude::*;

use crate::click_tool::ClickToolPlugin;
use crate::cube_tool::CubeToolPlugin;
use crate::default_wheel_tool::DefaultWheelToolPlugin;
use crate::focus_tool::FocusToolPlugin;
use crate::hello_tool::HelloToolPlugin;
use crate::keyboard_tool::KeyboardToolPlugin;
use crate::keyboard_wheel_tool::KeyboardWheelToolPlugin;
use crate::level_bounds_visibility_tool::LevelBoundsVisibilityToolPlugin;
// use crate::placeholder_tool::PlaceholderToolPlugin;
#[cfg(debug_assertions)]
use crate::restart_tool::RestartToolPlugin;
use crate::scroll_tool::ScrollToolPlugin;
use crate::talk_tool::TalkToolPlugin;
// use crate::window_drag_tool::WindowDragToolPlugin;
use crate::zoom_tool::ZoomToolPlugin;

pub struct ToolPlugin;
impl Plugin for ToolPlugin {
    fn build(&self, app: &mut App) {
        app.add_plugins(CubeToolPlugin);
        // app.add_plugins(PlaceholderToolPlugin);
        app.add_plugins(ClickToolPlugin);
        app.add_plugins(ScrollToolPlugin);
        app.add_plugins(TalkToolPlugin);
        app.add_plugins(ZoomToolPlugin);
        app.add_plugins(FocusToolPlugin);
        app.add_plugins(DefaultWheelToolPlugin);
        // app.add_plugins(WindowDragToolPlugin);
        app.add_plugins(KeyboardToolPlugin);
        app.add_plugins(KeyboardWheelToolPlugin);
        app.add_plugins(HelloToolPlugin);
        app.add_plugins(LevelBoundsVisibilityToolPlugin);
        #[cfg(debug_assertions)]
        app.add_plugins(RestartToolPlugin);
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\toolbelt\src\tool_color.rs

````rust
use cursor_hero_toolbelt_types::toolbelt_types::*;

use bevy::prelude::*;
use cursor_hero_pointer_types::prelude::*;

enum ToolColor {
    Active,
    Hovered,
    HoveredActive,
    Disabled,
}

impl ToolColor {
    fn color(&self) -> Color {
        match self {
            ToolColor::Active => Color::WHITE,
            ToolColor::Hovered => Color::YELLOW,
            ToolColor::HoveredActive => Color::ORANGE,
            ToolColor::Disabled => Color::GRAY,
        }
    }

    fn from(hovered: bool, active: bool) -> Self {
        match (hovered, active) {
            (true, true) => ToolColor::HoveredActive,
            (true, false) => ToolColor::Hovered,
            (false, true) => ToolColor::Active,
            (false, false) => ToolColor::Disabled,
        }
    }
}

#[allow(clippy::type_complexity)]
pub fn tool_color(
    mut query: Query<(&mut Sprite, Option<&Hovered>, Option<&ActiveTool>), With<Tool>>,
) {
    for (mut sprite, hovered, active) in query.iter_mut() {
        let color = ToolColor::from(hovered.is_some(), active.is_some()).color();
        sprite.color = color;
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\ui_automation\src\taskbar.rs

````rust
use crate::gather_children::gather_children;
use crate::gather_children::StopBehaviour;
use crate::prelude::*;
use uiautomation::controls::ControlType;
use uiautomation::UIAutomation;

pub fn get_taskbar() -> Result<Taskbar, uiautomation::Error> {
    let automation = UIAutomation::new()?;
    let root = automation.get_root_element()?;
    let taskbar_matcher = automation
        .create_matcher()
        .from(root)
        .classname("MSTaskListWClass")
        .control_type(ControlType::ToolBar);
    let taskbar = taskbar_matcher.find_first()?;
    let taskbar_entry_walker = automation.create_tree_walker()?;
    let taskbar_entries = gather_children(
        &taskbar_entry_walker,
        &taskbar,
        &StopBehaviour::TaskbarEndEncountered,
    );
    let entries = taskbar_entries
        .into_iter()
        .map(|entry| TaskbarEntry {
            name: entry.get_name().unwrap_or_default(),
            bounds: entry
                .get_bounding_rectangle()
                .unwrap_or_default()
                .to_bevy_irect(),
        })
        .collect();
    Ok(Taskbar { entries })
}

#[cfg(test)]
mod tests {
    use crate::prelude::get_taskbar;

    #[test]
    fn test_get_taskbar() {
        let taskbar = get_taskbar().unwrap();
        assert!(taskbar.entries.len() > 0);
        // print the entries
        for entry in taskbar.entries {
            println!("entry: {:?}", entry);
        }
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\host_event\src\host_event_plugin.rs

````rust
use bevy::prelude::*;

use crossbeam_channel::Receiver;
use cursor_hero_host_event_types::prelude::HostEvent;
use cursor_hero_winutils::win_events::create_os_event_listener;
use cursor_hero_winutils::win_events::ProcMessage;

pub struct HostEventPlugin;

impl Plugin for HostEventPlugin {
    #![allow(unused_variables)]
    fn build(&self, app: &mut App) {
        app.add_systems(Startup, start_worker);
        app.add_systems(Update, process_events);
    }
}

#[derive(Resource)]
struct EventBridge {
    receiver: Receiver<ProcMessage>,
}

fn start_worker(mut commands: Commands) {
    info!("Starting worker thread");
    let Ok(rx) = create_os_event_listener() else {
        error!("Failed to create OS event listener");
        return;
    };
    commands.insert_resource(EventBridge { receiver: rx });
}

fn process_events(bridge: ResMut<EventBridge>, mut host_events: EventWriter<HostEvent>) {
    for event in bridge.receiver.try_iter() {
        if let ProcMessage::MouseMoved { .. } = event {
            host_events.send(HostEvent::MousePhysicallyMoved);
        }
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\floaty_nametag\src\floaty_nametag_plugin.rs

````rust
use bevy::prelude::*;
use bevy::transform::TransformSystem;
use bevy_xpbd_2d::prelude::*;
use cursor_hero_floaty_nametag_types::prelude::*;

pub struct FloatyNametagPlugin;

impl Plugin for FloatyNametagPlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(Update, spawn_nametags);
        app.add_systems(
            PostUpdate,
            update_nametags
                .after(PhysicsSet::Sync)
                .before(TransformSystem::TransformPropagate),
        );
    }
}

fn spawn_nametags(
    mut commands: Commands,
    query: Query<(Entity, &GlobalTransform, &FloatyName), Added<FloatyName>>,
    asset_server: Res<AssetServer>,
) {
    for entry in query.iter() {
        let (owner, transform, name) = entry;
        debug!("Spawning nametag for {:?}", name.text.clone());
        let ratio = 2.0;
        commands.spawn((
            Name::new(format!("FloatyNametag: {}", name.text.clone())),
            FloatyNametag { owner },
            Text2dBundle {
                text: Text::from_section(
                    name.text.clone(),
                    TextStyle {
                        font: asset_server.load(name.appearance.get_font_path()),
                        font_size: 18.0 * ratio,
                        color: name.appearance.get_text_color(),
                    },
                )
                .with_alignment(TextAlignment::Center),
                transform: Transform::from_translation(
                    transform.translation() + Vec3::new(0.0, name.vertical_offset, 0.0),
                )
                .with_scale(Vec3::new(1.0 / ratio, 1.0 / ratio, 1.0)),
                ..default()
            },
        ));
    }
}

fn update_nametags(
    mut commands: Commands,
    owner_query: Query<(Ref<GlobalTransform>, Ref<FloatyName>), Without<FloatyNametag>>,
    mut floaty_query: Query<
        (Entity, &mut Text, &mut Transform, &FloatyNametag),
        Without<FloatyName>,
    >,
) {
    for floaty in floaty_query.iter_mut() {
        let (entity, mut text, mut transform, nametag) = floaty;
        let Ok(owner) = owner_query.get(nametag.owner) else {
            debug!("Owner of nametag {:?} not found, despawning", nametag.owner);
            commands.entity(entity).despawn_recursive();
            continue;
        };
        let (owner_transform, owner_floaty_name) = owner;
        if !owner_transform.is_changed() && !owner_floaty_name.is_changed() {
            continue;
        }
        text.sections[0].value = owner_floaty_name.text.clone();
        transform.translation =
            owner_transform.translation() + Vec3::new(0.0, owner_floaty_name.vertical_offset, 0.0);
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\ui_automation_types\src\ui_automation_types_plugin.rs

````rust
use crate::prelude::*;
use bevy::prelude::*;

pub struct UiAutomationTypesPlugin;

impl Plugin for UiAutomationTypesPlugin {
    fn build(&self, app: &mut App) {
        app.register_type::<ElementInfo>();
        app.register_type::<DrillId>();
        app.register_type::<ControlType>();
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\inference\src\lib.rs

````rust
pub mod inference_plugin;
pub mod prompt_asset_plugin;

````



## D:\Repos\Games\Cursor-Hero\crates\tools\src\click_tool.rs

````rust
use std::thread;

use bevy::audio::Volume;
use bevy::audio::VolumeLevel;
use bevy::prelude::*;
use bevy::window::PrimaryWindow;
use bevy_inspector_egui::bevy_egui::EguiContext;
use cursor_hero_pointer_types::prelude::*;

use leafwing_input_manager::prelude::*;

use crossbeam_channel::bounded;
use crossbeam_channel::Sender;
use cursor_hero_character_types::prelude::*;

use cursor_hero_winutils::win_mouse::left_mouse_down;
use cursor_hero_winutils::win_mouse::left_mouse_up;
use cursor_hero_winutils::win_mouse::right_mouse_down;
use cursor_hero_winutils::win_mouse::right_mouse_up;

use cursor_hero_toolbelt_types::prelude::*;

use crate::prelude::*;

pub struct ClickToolPlugin;

impl Plugin for ClickToolPlugin {
    fn build(&self, app: &mut App) {
        app.register_type::<ClickTool>();
        app.add_plugins(InputManagerPlugin::<ClickToolAction>::default());
        app.add_systems(Startup, spawn_worker_thread);
        app.add_systems(Update, (toolbelt_events, handle_input));
    }
}

#[derive(Component, Reflect, Default)]
struct ClickTool;

fn toolbelt_events(
    mut commands: Commands,
    asset_server: Res<AssetServer>,
    mut reader: EventReader<ToolbeltPopulateEvent>,
) {
    for event in reader.read() {
        if let ToolbeltLoadout::Default | ToolbeltLoadout::Keyboard = event.loadout {
            ToolSpawnConfig::<ClickTool, ClickToolAction>::new(ClickTool, event.id, event)
                .with_src_path(file!().into())
                .guess_name(file!())
                .guess_image(file!(), &asset_server, "png")
                .with_description("Send mouse clicks")
                .spawn(&mut commands);
        }
    }
}

#[derive(Actionlike, PartialEq, Eq, Clone, Copy, Hash, Debug, Reflect)]
enum ClickToolAction {
    LeftClick,
    RightClick,
}
impl ClickToolAction {
    fn get_audio_path(&self, motion: Motion) -> &'static str {
        match (self, motion) {
            (Self::LeftClick, Motion::Down) => "sounds/mouse1down.ogg",
            (Self::LeftClick, Motion::Up) => "sounds/mouse1up.ogg",
            (Self::RightClick, Motion::Down) => "sounds/mouse2down.ogg",
            (Self::RightClick, Motion::Up) => "sounds/mouse2up.ogg",
        }
    }
    fn get_thread_message(&self, motion: Motion) -> ClickThreadMessage {
        match (self, motion) {
            (Self::LeftClick, Motion::Down) => ClickThreadMessage::LeftMouse(Motion::Down),
            (Self::LeftClick, Motion::Up) => ClickThreadMessage::LeftMouse(Motion::Up),
            (Self::RightClick, Motion::Down) => ClickThreadMessage::RightMouse(Motion::Down),
            (Self::RightClick, Motion::Up) => ClickThreadMessage::RightMouse(Motion::Up),
        }
    }
}
impl From<ClickToolAction> for Way {
    fn from(action: ClickToolAction) -> Self {
        match action {
            ClickToolAction::LeftClick => Way::Left,
            ClickToolAction::RightClick => Way::Right,
        }
    }
}

#[derive(Debug)]
enum Motion {
    Up,
    Down,
}

#[derive(Debug)]
enum ClickThreadMessage {
    LeftMouse(Motion),
    RightMouse(Motion),
}

#[derive(Resource)]
struct ClickBridge {
    pub sender: Sender<(ClickThreadMessage, i32, i32)>,
}

impl ClickToolAction {
    fn default_wheel_gamepad_binding(&self) -> UserInput {
        match self {
            Self::LeftClick => GamepadButtonType::RightTrigger.into(),
            Self::RightClick => GamepadButtonType::LeftTrigger.into(),
        }
    }

    fn default_wheel_keyboard_binding(&self) -> UserInput {
        match self {
            Self::LeftClick => MouseButton::Left.into(),
            Self::RightClick => MouseButton::Right.into(),
        }
    }
    fn keyboard_wheel_gamepad_binding(&self) -> UserInput {
        match self {
            Self::LeftClick => GamepadButtonType::RightThumb.into(),
            Self::RightClick => GamepadButtonType::LeftThumb.into(),
        }
    }

    fn keyboard_wheel_keyboard_binding(&self) -> UserInput {
        match self {
            Self::LeftClick => MouseButton::Left.into(),
            Self::RightClick => MouseButton::Right.into(),
        }
    }
}

impl ToolAction for ClickToolAction {
    fn default_input_map(event: &ToolbeltPopulateEvent) -> Option<InputMap<ClickToolAction>> {
        match event.loadout {
            ToolbeltLoadout::Default => Some(Self::with_defaults(
                Self::default_wheel_gamepad_binding,
                Self::default_wheel_keyboard_binding,
            )),
            ToolbeltLoadout::Keyboard => Some(Self::with_defaults(
                Self::keyboard_wheel_gamepad_binding,
                Self::keyboard_wheel_keyboard_binding,
            )),
            _ => None,
        }
    }
}

fn spawn_worker_thread(mut commands: Commands) {
    let (tx, rx) = bounded::<_>(10);
    commands.insert_resource(ClickBridge { sender: tx });
    thread::spawn(move || loop {
        let (action, x, y) = match rx.recv() {
            Ok(v) => v,
            Err(e) => {
                error!("Failed to receive thread message, exiting: {:?}", e);
                break;
            }
        };
        debug!("Worker received click: {:?} {} {}", action, x, y);
        match match action {
            ClickThreadMessage::LeftMouse(Motion::Down) => left_mouse_down(),
            ClickThreadMessage::LeftMouse(Motion::Up) => left_mouse_up(),
            ClickThreadMessage::RightMouse(Motion::Down) => right_mouse_down(),
            ClickThreadMessage::RightMouse(Motion::Up) => right_mouse_up(),
        } {
            Ok(_) => {}
            Err(e) => {
                error!("Failed to handle event {:?}: {:?}", action, e);
            }
        }
    });
}

#[allow(clippy::too_many_arguments)]
#[allow(clippy::type_complexity)]
fn handle_input(
    mut commands: Commands,
    tools: Query<(&ActionState<ClickToolAction>, &Parent), (With<ActiveTool>, With<ClickTool>)>,
    toolbelts: Query<&Parent, With<Toolbelt>>,
    characters: Query<&Children, With<Character>>,
    pointers: Query<(Entity, &GlobalTransform), With<Pointer>>,
    bridge: ResMut<ClickBridge>,
    asset_server: Res<AssetServer>,
    mut tool_click_event_writer: EventWriter<ToolClickEvent>,
    window_query: Query<&Window, With<PrimaryWindow>>,
    egui_context_query: Query<&EguiContext, With<PrimaryWindow>>,
) {
    for tool in tools.iter() {
        let (tool_actions, tool_parent) = tool;

        if !ClickToolAction::variants()
            .any(|action| tool_actions.just_pressed(action) || tool_actions.just_released(action))
        {
            continue;
        }

        let Ok(toolbelt) = toolbelts.get(tool_parent.get()) else {
            warn!("Tool not inside a toolbelt?");
            continue;
        };
        let toolbelt_parent = toolbelt;

        let Ok(character) = characters.get(toolbelt_parent.get()) else {
            warn!("Toolbelt parent not a character?");
            continue;
        };
        let character_children = character;

        let Some(pointer) = character_children
            .iter()
            .filter_map(|x| pointers.get(*x).ok())
            .next()
        else {
            //TODO: warn if more than one pointer found
            warn!("Character {:?} missing a pointer?", toolbelt_parent.get());
            debug!("Character children: {:?}", character_children);
            continue;
        };
        let (pointer_id, pointer_transform) = pointer;
        let pointer_pos = pointer_transform.translation();

        let window = window_query.get_single().expect("Need a single window");

        let Ok(egui_context) = egui_context_query.get_single() else {
            return;
        };
        let disable_sfx = egui_context.clone().get_mut().is_pointer_over_area();
        if window.cursor_position().is_some() {
            // The host cursor is over the window
            // Perform virtual click instead of sending a message to the worker thread
            // debug!("Performing virtual click");
            for action in ClickToolAction::variants() {
                if tool_actions.just_pressed(action) {
                    debug!("{:?} pressed", action);
                    if !disable_sfx {
                        commands.spawn((
                            SpatialBundle {
                                transform: Transform::from_translation(pointer_pos),
                                ..default()
                            },
                            Name::new("Click sound"),
                            AudioBundle {
                                source: asset_server.load(action.get_audio_path(Motion::Down)),
                                settings: PlaybackSettings::DESPAWN
                                    .with_spatial(true)
                                    .with_volume(Volume::Relative(VolumeLevel::new(0.5))),
                            },
                        ));
                    }
                    tool_click_event_writer.send(ToolClickEvent::Pressed {
                        pointer_id,
                        way: action.into(),
                    });
                }
                if tool_actions.just_released(action) {
                    debug!("{:?} released", action);
                    if !disable_sfx {
                        commands.spawn((
                            SpatialBundle {
                                transform: Transform::from_translation(pointer_pos),
                                ..default()
                            },
                            Name::new("Click sound"),
                            AudioBundle {
                                source: asset_server.load(action.get_audio_path(Motion::Up)),
                                settings: PlaybackSettings::DESPAWN
                                    .with_spatial(true)
                                    .with_volume(Volume::Relative(VolumeLevel::new(0.5))),
                            },
                        ));
                    }
                    tool_click_event_writer.send(ToolClickEvent::Released {
                        pointer_id,
                        way: action.into(),
                    });
                }
            }
        } else {
            // The host cursor is outside the window
            // Send a message to the worker thread
            // debug!("Performing host click");
            for action in ClickToolAction::variants() {
                if tool_actions.just_pressed(action) {
                    debug!("{:?} pressed", action);
                    match bridge.sender.send((
                        action.get_thread_message(Motion::Down),
                        pointer_pos.x as i32,
                        -pointer_pos.y as i32,
                    )) {
                        Ok(_) => {
                            commands.spawn((
                                SpatialBundle {
                                    transform: Transform::from_translation(pointer_pos),
                                    ..default()
                                },
                                Name::new("Click sound"),
                                AudioBundle {
                                    source: asset_server.load(action.get_audio_path(Motion::Down)),
                                    settings: PlaybackSettings::DESPAWN
                                        .with_spatial(true)
                                        .with_volume(Volume::Relative(VolumeLevel::new(0.5))),
                                },
                            ));
                        }
                        Err(e) => {
                            error!("Failed to send click: {:?}", e);
                        }
                    }
                }
                if tool_actions.just_released(action) {
                    debug!("{:?} released", action);
                    match bridge.sender.send((
                        action.get_thread_message(Motion::Up),
                        pointer_pos.x as i32,
                        -pointer_pos.y as i32,
                    )) {
                        Ok(_) => {
                            commands.spawn((
                                SpatialBundle {
                                    transform: Transform::from_translation(pointer_pos),
                                    ..default()
                                },
                                Name::new("Click sound"),
                                AudioBundle {
                                    source: asset_server.load(action.get_audio_path(Motion::Up)),
                                    settings: PlaybackSettings::DESPAWN
                                        .with_spatial(true)
                                        .with_volume(Volume::Relative(VolumeLevel::new(0.5))),
                                },
                            ));
                        }

                        Err(e) => {
                            error!("Failed to send click: {:?}", e);
                        }
                    }
                }
            }
        }
    }
}

````



## D:\Repos\Games\Cursor-Hero\crates\floaty_nametag\src\lib.rs

````rust
pub mod floaty_nametag_plugin;

pub mod prelude {
    pub use crate::floaty_nametag_plugin::*;
}

````



## D:\Repos\Games\Cursor-Hero\src\main.rs

````rust
use bevy::prelude::*;
use cursor_hero_plugins::MyPlugin;
use cursor_hero_version::version_plugin::VersionPlugin;

fn main() {
    let mut app = App::new();
    app.add_plugins(VersionPlugin(env!("CARGO_PKG_VERSION").to_string()));
    app.add_plugins(MyPlugin);
    // .insert_resource(ClearColor(Color::NONE))
    app.run();
}

````



## D:\Repos\Games\Cursor-Hero\README.md

````markdown
# Cursor Hero

[![Visitors](https://api.visitorbadge.io/api/visitors?path=github.com%2FTeamDman%2FCursor-Hero&countColor=%23263759)](https://visitorbadge.io/status?path=github.com%2FTeamDman%2FCursor-Hero)

## Video demo

[![yt thumbnail](https://img.youtube.com/vi/t1PYks0UTL8/0.jpg)](https://youtu.be/t1PYks0UTL8)

## Regarding DualShock controllers

Try [DS4Windows](https://ds4windows.dev/).

## Integrations

- [TeamDman/voice2text: Local speech recognition](https://github.com/teamdman/voice2text)
- [ollama/ollama: Local LLM inference](https://github.com/ollama/ollama)
- [R2D2FISH/glados-tts: GLaDOS speech synthesis](https://github.com/TeamDman/glados-tts.git)

## Project description

Cursor Hero is a thing built using Rust and the Bevy game engine.

Cursor Hero, when launched, presents you with a character that has a pointer. You can move the character and pointer independently using the mouse and keyboard, or using both sticks on a gamepad.

In the game world, you can see a scale representation of your monitors. I have three monitors, so when I launch the game I see the left, center, and right monitor, usually containing VSCode, Discord, and the Cursor Hero window itself.

Cursor Hero uses the `windows` crate to integrate tightly with the Windows operating system. It reads and writes the host cursor position, with integrations with the game to do things like position the host mouse "cursor" over the in-game "pointer", or updating the cursor so that it matches the game world position of the pointer, letting the player interact with the OS using the game representation of the screens.

This includes integrating with Windows UI automation to grab the locations of UI elements, copying the texture of the screen onto bricks in the game world that are physics objects.

UI information is attached to the bricks, using `bevy-egui` to render UI elements with screen coordinates updated to correspond with world-coordinates of the bricks.

Using `egui`, the tree hierarchy of the UI is shown for the bricks created by clicking on UI elements in the screen texture. The tree could potentially grow to something like inspect.exe, where the properties of the UI element can be explored. Currently, the tree folding and selectable labels is working, but the properties panel on the right is not yet implemented.

In addition to showing the host environment, a game environment is also constructed. The game environment contains a virtual agent and a mimicry of the host OS. The mimicry extends to include a copy of the desktop background, a taskbar that pulls the colour from the OS preferences, and a start menu button that toggles visibility of an empty panel.

The virtual agent walks in circles. It has an observation buffer which other systems can publish events for something happening, and the buffer will conditionally append such events which are used in the construction of prompts for a local LLM ran using `ollama`.

In response to player chat messages, or in response to a period of inactivity, the agent will prompt the LLM in a chat format. With the response, it publishes its own chat message, and it invokes the `glados-tts` to speak the response to the player.

This agent behaviour, combined with integration to `voice2text`, allows the human to converse to the agent entirely locally using `whisper-x` to speak with the addition of a push-to-talk button and a toggle-active-listening button.

Given that the host cursor is being updated by the game pointer when in gamepad input mode, the game takes care to listen for raw mouse input events to determine when the player is trying to use mouse and keyboard input mode, avoiding holding the pointer captive since traditional input detection is not suitable. After all, if the pointer is programmatically controlled by the game, "mouse moved events" become less reliable when aiming for physical movement detection.

Again using the `windows` crate, the game is able to identify running processes and programmatically detect the exe path and extract the icons of the process from it.
Opportunity exists to detect dynamic icons from process windows as well.

The game has a radial menu for enabling/disabling "tools", some of which start disabled and upon enabling will clear and repopulate the tools in the toolbelt with a different loadout.

The tool system has been used to show a radial menu of programs in the taskbar, using UI automation to grab the texture at the rect of each item to be displayed radially.

There is a tool loadout that lets you snap the game window to any corner or fullscreen of any monitors detected.

The default tool loadout starts you in click mode, letting you move your character and its pointer, with the ability to send click events to the OS, and to send click events to game objects using the ECS fundamentals. 

The game has its own model system for the UI hierarchy, with support for detecting the details of running VSCode windows, including tabs on the left, open tab, contents of the explorer tab if open, editor groups open and involved tabs and file contents, current cursor line and position displayed in the bottom corner.

## Where do we go from here

I am continuously exploring many different trajectories for this project.

See [`./todo.md`](./todo.md) for brainstorming on potential features to add.

See [`./research_notes.md`](./research_notes.md) for links to internet resources that could be helpful.

````


Suggest how I can use the anyhow crate to give more information when diagnosing AppResolveErrors in the UI automation portion.
Right now, I just know there's a UI error that's getting caught but there's many spots it could be happening.
