# Summary


## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\cablenetwork\ICableBlock.java

````java
package ca.teamdman.sfm.common.cablenetwork;

public interface ICableBlock {
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\client\render\FormItemExtensions.java

````java
package ca.teamdman.sfm.client.render;

import net.minecraft.client.renderer.BlockEntityWithoutLevelRenderer;
import net.minecraftforge.client.extensions.common.IClientItemExtensions;

public class FormItemExtensions implements IClientItemExtensions {
    private final BlockEntityWithoutLevelRenderer RENDERER = new FormItemRenderer();

    @Override
    public BlockEntityWithoutLevelRenderer getCustomRenderer() {
        return RENDERER;
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\client\gui\screen\ProgramEditScreen.java

````java
package ca.teamdman.sfm.client.gui.screen;

import ca.teamdman.sfm.client.ProgramSyntaxHighlightingHelper;
import ca.teamdman.sfm.client.ProgramTokenContextActions;
import ca.teamdman.sfm.client.gui.EditorUtils;
import ca.teamdman.sfm.common.Constants;
import com.mojang.blaze3d.vertex.PoseStack;
import com.mojang.blaze3d.vertex.Tesselator;
import com.mojang.math.Matrix4f;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.GuiComponent;
import net.minecraft.client.gui.components.Button;
import net.minecraft.client.gui.components.MultiLineEditBox;
import net.minecraft.client.gui.components.MultilineTextField;
import net.minecraft.client.gui.screens.ConfirmScreen;
import net.minecraft.client.gui.screens.Screen;
import net.minecraft.client.renderer.LightTexture;
import net.minecraft.client.renderer.MultiBufferSource;
import net.minecraft.network.chat.CommonComponents;
import net.minecraft.network.chat.Component;
import net.minecraft.network.chat.MutableComponent;
import net.minecraft.network.chat.Style;
import org.lwjgl.glfw.GLFW;

import java.util.Collections;
import java.util.List;
import java.util.Optional;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.Consumer;

import static ca.teamdman.sfm.common.Constants.LocalizationKeys.PROGRAM_EDIT_SCREEN_DONE_BUTTON_TOOLTIP;

public class ProgramEditScreen extends Screen {
    private final String INITIAL_CONTENT;
    private final Consumer<String> CALLBACK;
    @SuppressWarnings("NotNullFieldNotInitialized")
    private MyMultiLineEditBox textarea;
    private String lastProgram = "";
    private List<MutableComponent> lastProgramWithSyntaxHighlighting = Collections.emptyList();

    public ProgramEditScreen(String initialContent, Consumer<String> callback) {
        super(Constants.LocalizationKeys.PROGRAM_EDIT_SCREEN_TITLE.getComponent());
        this.INITIAL_CONTENT = initialContent;
        this.CALLBACK = callback;
    }

    public static MutableComponent substring(MutableComponent component, int start, int end) {
        var rtn = Component.empty();
        AtomicInteger seen = new AtomicInteger(0);
        component.visit((style, content) -> {
            int contentStart = Math.max(start - seen.get(), 0);
            int contentEnd = Math.min(end - seen.get(), content.length());

            if (contentStart < contentEnd) {
                rtn.append(Component.literal(content.substring(contentStart, contentEnd)).withStyle(style));
            }
            seen.addAndGet(content.length());
            return Optional.empty();
        }, Style.EMPTY);
        return rtn;
    }

    @Override
    protected void init() {
        super.init();
        assert this.minecraft != null;
        this.minecraft.keyboardHandler.setSendRepeatsToGui(true);
        this.textarea = this.addRenderableWidget(new MyMultiLineEditBox());
        textarea.setValue(INITIAL_CONTENT);
        this.setInitialFocus(textarea);

        this.addRenderableWidget(new Button(
                this.width / 2 - 2 - 150,
                this.height / 2 - 100 + 195,
                300,
                20,
                CommonComponents.GUI_DONE,
                (p_97691_) -> this.onClosePerformCallback(),
                (btn, pose, mx, my) -> renderTooltip(
                        pose,
                        font.split(
                                PROGRAM_EDIT_SCREEN_DONE_BUTTON_TOOLTIP.getComponent(),
                                Math.max(
                                        width
                                        / 2
                                        - 43,
                                        170
                                )
                        ),
                        mx,
                        my
                )
        ));
    }

    public void onClosePerformCallback() {
        CALLBACK.accept(textarea.getValue());

        assert this.minecraft != null;
        this.minecraft.popGuiLayer();
    }

    @Override
    public void onClose() {
        if (!INITIAL_CONTENT.equals(textarea.getValue())) {
            // if content changed => ask to save
            assert this.minecraft != null;
            // push confirm screen
            this.minecraft.pushGuiLayer(new ConfirmScreen(
                    doSave -> {
                        this.minecraft.popGuiLayer();
                        if (doSave) {
                            onClosePerformCallback();
                        } else {
                            this.minecraft.popGuiLayer();
                        }
                    },
                    Constants.LocalizationKeys.SAVE_CHANGES_CONFIRM_SCREEN_TITLE.getComponent(),
                    Constants.LocalizationKeys.SAVE_CHANGES_CONFIRM_SCREEN_MESSAGE.getComponent(),
                    Constants.LocalizationKeys.SAVE_CHANGES_CONFIRM_SCREEN_YES_BUTTON.getComponent(),
                    Constants.LocalizationKeys.SAVE_CHANGES_CONFIRM_SCREEN_NO_BUTTON.getComponent()
            ));
        } else {
            super.onClose();
        }
    }

    @Override
    public boolean keyReleased(int pKeyCode, int pScanCode, int pModifiers) {
        if (pKeyCode == GLFW.GLFW_KEY_LEFT_CONTROL || pKeyCode == GLFW.GLFW_KEY_RIGHT_CONTROL) {
            // if control released => update syntax highlighting
            textarea.rebuild(Screen.hasControlDown());
            return true;
        }
        return false;
    }

    @Override
    public boolean charTyped(char pCodePoint, int pModifiers) {
        if (Screen.hasControlDown() && pCodePoint == ' ') {
            return true;
        }
        return super.charTyped(pCodePoint, pModifiers);
    }

    public void scrollToTop() {
        textarea.setScrollAmount(0d);
    }

    @Override
    public boolean keyPressed(int pKeyCode, int pScanCode, int pModifiers) {
        if ((pKeyCode == GLFW.GLFW_KEY_ENTER || pKeyCode == GLFW.GLFW_KEY_KP_ENTER) && Screen.hasShiftDown()) {
            onClosePerformCallback();
            return true;
        }
        if (pKeyCode == GLFW.GLFW_KEY_TAB) {
            // if tab pressed with no selection and not holding shift => insert 4 spaces
            // if tab pressed with no selection and holding shift => de-indent current line
            // if tab pressed with selection and not holding shift => de-indent lines containing selection 4 spaces
            // if tab pressed with selection and holding shift => indent lines containing selection 4 spaces
            String content = textarea.getValue();
            int cursor = textarea.getCursorPosition();
            int selectionCursor = textarea.getSelectionCursorPosition();
            EditorUtils.ManipulationResult result;
            if (Screen.hasShiftDown()) { // de-indent
                result = EditorUtils.deindent(content, cursor, selectionCursor);
            } else { // indent
                result = EditorUtils.indent(content, cursor, selectionCursor);
            }
            textarea.setValue(result.content());
            textarea.setCursorPosition(result.cursorPosition());
            textarea.setSelectionCursorPosition(result.selectionCursorPosition());
            return true;
        }
        if (pKeyCode == GLFW.GLFW_KEY_LEFT_CONTROL || pKeyCode == GLFW.GLFW_KEY_RIGHT_CONTROL) {
            // if control pressed => update syntax highlighting
            textarea.rebuild(Screen.hasControlDown());
            return true;
        }
        if (pKeyCode == GLFW.GLFW_KEY_SLASH && Screen.hasControlDown()) {
            // toggle line comments for selected lines
            String content = textarea.getValue();
            int cursor = textarea.getCursorPosition();
            int selectionCursor = textarea.getSelectionCursorPosition();
            EditorUtils.ManipulationResult result = EditorUtils.toggleComments(content, cursor, selectionCursor);
            textarea.setValue(result.content());
            textarea.setCursorPosition(result.cursorPosition());
            textarea.setSelectionCursorPosition(result.selectionCursorPosition());
            return true;
        }
        if (pKeyCode == GLFW.GLFW_KEY_SPACE && Screen.hasControlDown()) {
            ProgramTokenContextActions.getContextAction(
                            textarea.getValue(),
                            textarea.getCursorPosition()
                    )
                    .ifPresent(Runnable::run);

            // disable the underline since it doesn't refresh when the context action closes
            textarea.rebuild(false);
            return true;
        }
        return super.keyPressed(pKeyCode, pScanCode, pModifiers);
    }

    @Override
    public void resize(Minecraft mc, int x, int y) {
        var prev = this.textarea.getValue();
        init(mc, x, y);
        super.resize(mc, x, y);
        this.textarea.setValue(prev);
    }

    @Override
    public void render(PoseStack poseStack, int mx, int my, float partialTicks) {
        this.renderBackground(poseStack);
        super.render(poseStack, mx, my, partialTicks);
    }

    private class MyMultiLineEditBox extends MultiLineEditBox {
        public MyMultiLineEditBox() {
            super(
                    ProgramEditScreen.this.font,
                    ProgramEditScreen.this.width / 2 - 200,
                    ProgramEditScreen.this.height / 2 - 110,
                    400,
                    200,
                    Component.literal(""),
                    Component.literal("")
            );
        }

        public int getCursorPosition() {
            return this.textField.cursor;
        }

        public void setCursorPosition(int cursor) {
            this.textField.cursor = cursor;
        }

        @Override
        public boolean mouseClicked(double p_239101_, double p_239102_, int p_239103_) {
            try {
                return super.mouseClicked(p_239101_, p_239102_, p_239103_);
            } catch (Exception e) {
                e.printStackTrace();
                return false;
            }
        }

        public int getSelectionCursorPosition() {
            return this.textField.selectCursor;
        }

        public void setSelectionCursorPosition(int cursor) {
            this.textField.selectCursor = cursor;
        }

        private void rebuild(boolean showContextActionHints) {
            lastProgram = this.textField.value();
            lastProgramWithSyntaxHighlighting = ProgramSyntaxHighlightingHelper.withSyntaxHighlighting(
                    lastProgram,
                    showContextActionHints
            );
        }

        @Override
        protected void renderContents(PoseStack poseStack, int mx, int my, float partialTicks) {
            Matrix4f matrix4f = poseStack.last().pose();
            if (!lastProgram.equals(this.textField.value())) {
                rebuild(Screen.hasControlDown());
            }
            List<MutableComponent> lines = lastProgramWithSyntaxHighlighting;
            boolean isCursorVisible = this.isFocused() && this.frame / 6 % 2 == 0;
            boolean isCursorAtEndOfLine = false;
            int cursorIndex = textField.cursor();
            int lineX = this.x + this.innerPadding();
            int lineY = this.y + this.innerPadding();
            int charCount = 0;
            int cursorX = 0;
            int cursorY = 0;
            MultilineTextField.StringView selectedRange = this.textField.getSelected();
            int selectionStart = selectedRange.beginIndex();
            int selectionEnd = selectedRange.endIndex();

            for (int line = 0; line < lines.size(); ++line) {
                var componentColoured = lines.get(line);
                int lineLength = componentColoured.getString().length();
                int lineHeight = this.font.lineHeight + (line == 0 ? 2 : 0);
                boolean cursorOnThisLine = isCursorVisible
                                           && cursorIndex >= charCount
                                           && cursorIndex <= charCount + lineLength;
                var buffer = MultiBufferSource.immediate(Tesselator.getInstance().getBuilder());

                if (cursorOnThisLine) {
                    isCursorAtEndOfLine = cursorIndex == charCount + lineLength;
                    cursorY = lineY;
                    // we draw the raw before coloured in case of token recognition errors
                    // draw before cursor
                    cursorX = this.font.drawInBatch(
                            substring(componentColoured, 0, cursorIndex - charCount),
                            lineX,
                            lineY,
                            -1,
                            true,
                            matrix4f,
                            buffer,
                            false,
                            0,
                            LightTexture.FULL_BRIGHT
                    ) - 1;
                    this.font.drawInBatch(
                            substring(componentColoured, cursorIndex - charCount, lineLength),
                            cursorX,
                            lineY,
                            -1,
                            true,
                            matrix4f,
                            buffer,
                            false,
                            0,
                            LightTexture.FULL_BRIGHT
                    );
                } else {
                    this.font.drawInBatch(
                            componentColoured,
                            lineX,
                            lineY,
                            -1,
                            true,
                            matrix4f,
                            buffer,
                            false,
                            0,
                            LightTexture.FULL_BRIGHT
                    );
                }
                buffer.endBatch();

                // Check if the selection is within the current line
                if (selectionStart <= charCount + lineLength && selectionEnd > charCount) {
                    int lineSelectionStart = Math.max(selectionStart - charCount, 0);
                    int lineSelectionEnd = Math.min(selectionEnd - charCount, lineLength);

                    int highlightStartX = this.font.width(substring(componentColoured, 0, lineSelectionStart));
                    int highlightEndX = this.font.width(substring(componentColoured, 0, lineSelectionEnd));

                    this.renderHighlight(
                            poseStack,
                            lineX + highlightStartX,
                            lineY,
                            lineX + highlightEndX,
                            lineY + lineHeight
                    );
                }

                lineY += lineHeight;
                charCount += lineLength + 1;
            }

            if (isCursorAtEndOfLine) {
                this.font.drawShadow(poseStack, "_", cursorX, cursorY, -1);
            } else {
                GuiComponent.fill(poseStack, cursorX, cursorY - 1, cursorX + 1, cursorY + 1 + 9, -1);
            }
        }

    }
}


````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\resourcetype\ItemResourceType.java

````java
package ca.teamdman.sfm.common.resourcetype;

import net.minecraft.world.item.Item;
import net.minecraft.world.item.ItemStack;
import net.minecraftforge.common.capabilities.ForgeCapabilities;
import net.minecraftforge.items.IItemHandler;
import net.minecraftforge.registries.ForgeRegistries;
import net.minecraftforge.registries.IForgeRegistry;

public class ItemResourceType extends ResourceType<ItemStack, Item, IItemHandler> {
    public ItemResourceType() {
        super(ForgeCapabilities.ITEM_HANDLER);
    }

    @Override
    public IForgeRegistry<Item> getRegistry() {
        return ForgeRegistries.ITEMS;
    }


    @Override
    public Item getItem(ItemStack itemStack) {
        return itemStack.getItem();
    }

    @Override
    public ItemStack copy(ItemStack stack) {
        return stack.copy();
    }

    @Override
    protected ItemStack setCount(ItemStack stack, long amount) {
        int finalAmount = amount > Integer.MAX_VALUE ? Integer.MAX_VALUE : (int) amount;
        stack.setCount(finalAmount);
        return stack;
    }

    @Override
    public long getAmount(ItemStack stack) {
        return stack.getCount();
    }

    @Override
    public ItemStack getStackInSlot(IItemHandler cap, int slot) {
        return cap.getStackInSlot(slot);
    }

    @Override
    public ItemStack extract(IItemHandler handler, int slot, long amount, boolean simulate) {
        int finalAmount = amount > Integer.MAX_VALUE ? Integer.MAX_VALUE : (int) amount;
        // Mekanism bin intentionally only returns 64x stacks without going past the max stack size
        // https://github.com/mekanism/Mekanism/blob/f92b48a49e0766cd3aa78e95c9c4a47ba90402f5/src/main/java/mekanism/common/inventory/slot/BasicInventorySlot.java#L174-L175
        return handler.extractItem(slot, finalAmount, simulate);
    }

    @Override
    public boolean matchesStackType(Object o) {
        return o instanceof ItemStack;
    }

    @Override
    public boolean matchesCapabilityType(Object o) {
        return o instanceof IItemHandler;
    }

    @Override
    public int getSlots(IItemHandler handler) {
        return handler.getSlots();
    }

    @Override
    public long getMaxStackSize(ItemStack itemStack) {
        return itemStack.getMaxStackSize();
    }

    @Override
    public long getMaxStackSize(IItemHandler handler, int slot) {
        return handler.getSlotLimit(slot);
    }

    /**
     * @return remaining stack that was not inserted
     */
    @Override
    public ItemStack insert(IItemHandler handler, int slot, ItemStack stack, boolean simulate) {
        return handler.insertItem(slot, stack, simulate);
    }

    @Override
    public boolean isEmpty(ItemStack stack) {
        return stack.isEmpty();
    }

    @Override
    public ItemStack getEmptyStack() {
        return ItemStack.EMPTY;
    }

}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\net\ServerboundLabelGunClearPacket.java

````java
package ca.teamdman.sfm.common.net;

import ca.teamdman.sfm.common.item.LabelGunItem;
import ca.teamdman.sfm.common.program.LabelPositionHolder;
import net.minecraft.network.FriendlyByteBuf;
import net.minecraft.world.InteractionHand;
import net.minecraftforge.network.NetworkEvent;

import java.util.function.Supplier;

public record ServerboundLabelGunClearPacket(
        InteractionHand hand
) {
    public static void encode(ServerboundLabelGunClearPacket msg, FriendlyByteBuf buf) {
        buf.writeEnum(msg.hand);
    }

    public static ServerboundLabelGunClearPacket decode(
            FriendlyByteBuf buf
    ) {
        return new ServerboundLabelGunClearPacket(buf.readEnum(InteractionHand.class));
    }

    public static void handle(
            ServerboundLabelGunClearPacket msg, Supplier<NetworkEvent.Context> ctx
    ) {
        ctx.get().enqueueWork(() -> {
            var sender = ctx.get().getSender();
            if (sender == null) {
                return;
            }
            var stack = sender.getItemInHand(msg.hand);
            if (stack.getItem() instanceof LabelGunItem) {
                LabelPositionHolder.empty().save(stack);
            }
        });
        ctx.get().setPacketHandled(true);
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfml\ast\BoolExpr.java

````java
package ca.teamdman.sfml.ast;

import ca.teamdman.sfm.common.program.ProgramContext;

import java.util.function.Predicate;

public record BoolExpr(
        Predicate<ProgramContext> pred,
        String sourceCode
) implements Predicate<ProgramContext>, ASTNode {

    @Override
    public boolean test(ProgramContext context) {
        return pred.test(context);
    }

    public BoolExpr negate() {
        return new BoolExpr(pred.negate(), "NOT " + sourceCode);
    }

    @Override
    public String toString() {
        return sourceCode;
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\block\CableBlock.java

````java
package ca.teamdman.sfm.common.block;

import ca.teamdman.sfm.common.cablenetwork.CableNetworkManager;
import ca.teamdman.sfm.common.cablenetwork.ICableBlock;
import net.minecraft.core.BlockPos;
import net.minecraft.server.level.ServerLevel;
import net.minecraft.world.level.Level;
import net.minecraft.world.level.block.Block;
import net.minecraft.world.level.block.SoundType;
import net.minecraft.world.level.block.state.BlockState;
import net.minecraft.world.level.material.Material;

public class CableBlock extends Block implements ICableBlock {

    public CableBlock() {
        super(Block.Properties
                      .of(Material.METAL)
                      .destroyTime(1f)
                      .sound(SoundType.METAL));
    }

    @SuppressWarnings("deprecation")
    @Override
    public void neighborChanged(
            BlockState state,
            Level level,
            BlockPos pos,
            Block block,
            BlockPos fromPos,
            boolean movedByPiston
    ) {
        if (!(level instanceof ServerLevel)) return;
        // reassess neighbours of the CABLE's position
        CableNetworkManager
                .getOrRegisterNetworkFromCablePosition(level, pos)
                .ifPresent(network -> network.rebuildAdjacentInventories(pos));
    }

    @SuppressWarnings("deprecation")
    @Override
    public void onPlace(BlockState state, Level world, BlockPos pos, BlockState oldState, boolean isMoving) {
        CableNetworkManager.getOrRegisterNetworkFromCablePosition(world, pos);
    }

    @SuppressWarnings("deprecation")
    @Override
    public void onRemove(BlockState state, Level level, BlockPos pos, BlockState newState, boolean isMoving) {
        CableNetworkManager.removeCable(level, pos);
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\block\TestBarrelBlock.java

````java
package ca.teamdman.sfm.common.block;

import net.minecraft.core.BlockPos;
import net.minecraft.world.level.Level;
import net.minecraft.world.level.block.BarrelBlock;
import net.minecraft.world.level.block.SoundType;
import net.minecraft.world.level.block.state.BlockBehaviour;
import net.minecraft.world.level.block.state.BlockState;
import net.minecraft.world.level.material.Material;

public class TestBarrelBlock extends BarrelBlock {
    public TestBarrelBlock() {
        super(BlockBehaviour.Properties.of(Material.WOOD).strength(2.5F).sound(SoundType.WOOD));
    }

    @Override
    public void onRemove(BlockState pState, Level pLevel, BlockPos pPos, BlockState pNewState, boolean pIsMoving) {
//        var container = (Container) pLevel.getBlockEntity(pPos);
//        int stacks = IntStream.range(0, container.getContainerSize()).mapToObj(container::getItem).mapToInt(ItemStack::getCount).sum();
//        System.out.println("test barrel removed " + stacks/64);
        if (!pState.is(pNewState.getBlock())) {
            pLevel.removeBlockEntity(pPos);
            super.onRemove(pState, pLevel, pPos, pNewState, pIsMoving);
        }
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\resourcetype\ForgeEnergyResourceType.java

````java
package ca.teamdman.sfm.common.resourcetype;

import net.minecraft.resources.ResourceLocation;
import net.minecraftforge.common.capabilities.ForgeCapabilities;
import net.minecraftforge.energy.IEnergyStorage;
import net.minecraftforge.registries.IForgeRegistry;
import org.apache.commons.lang3.NotImplementedException;

public class ForgeEnergyResourceType extends ResourceType<Integer, Class<Integer>, IEnergyStorage> {
    public ForgeEnergyResourceType() {
        super(ForgeCapabilities.ENERGY);
    }

    @Override
    public long getAmount(Integer integer) {
        return integer;
    }

    @Override
    public Integer getStackInSlot(IEnergyStorage iEnergyStorage, int slot) {
        return iEnergyStorage.getEnergyStored();
    }

    @Override
    public Integer extract(IEnergyStorage iEnergyStorage, int slot, long amount, boolean simulate) {
        int finalAmount = amount > Integer.MAX_VALUE ? Integer.MAX_VALUE : (int) amount;
        return iEnergyStorage.extractEnergy(finalAmount, simulate);
    }

    @Override
    public int getSlots(IEnergyStorage handler) {
        return 1;
    }

    @Override
    public long getMaxStackSize(Integer integer) {
        return Long.MAX_VALUE;
    }

    @Override
    public long getMaxStackSize(IEnergyStorage iEnergyStorage, int slot) {
        return iEnergyStorage.getMaxEnergyStored();
    }

    @Override
    public Integer insert(IEnergyStorage iEnergyStorage, int slot, Integer integer, boolean simulate) {
        return integer - iEnergyStorage.receiveEnergy(integer, simulate);
    }

    @Override
    public boolean isEmpty(Integer integer) {
        return integer == 0;
    }

    @Override
    public boolean matchesStackType(Object o) {
        return o instanceof Integer;
    }

    @Override
    public boolean matchesCapabilityType(Object o) {
        return o instanceof IEnergyStorage;
    }

    @Override
    public Integer getEmptyStack() {
        return 0;
    }

    public static final ResourceLocation REGISTRY_KEY = new ResourceLocation("forge", "energy");

    @Override
    public ResourceLocation getRegistryKey(Integer integer) {
        return REGISTRY_KEY;
    }

    @Override
    public IForgeRegistry<Class<Integer>> getRegistry() {
        throw new NotImplementedException();
    }

    @Override
    public boolean registryKeyExists(ResourceLocation location) {
        return location.equals(REGISTRY_KEY);
    }

    @Override
    public Class<Integer> getItem(Integer integer) {
        return Integer.class;
    }

    @Override
    public Integer copy(Integer integer) {
        return integer;
    }

    @Override
    protected Integer setCount(Integer integer, long amount) {
        return amount > Integer.MAX_VALUE ? Integer.MAX_VALUE : (int) amount;
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\SFM.java

````java
package ca.teamdman.sfm;

import ca.teamdman.sfm.client.registry.SFMMenuScreens;
import ca.teamdman.sfm.common.registry.*;
import net.minecraftforge.fml.common.Mod;
import net.minecraftforge.fml.event.lifecycle.FMLClientSetupEvent;
import net.minecraftforge.fml.event.lifecycle.FMLCommonSetupEvent;
import net.minecraftforge.fml.javafmlmod.FMLJavaModLoadingContext;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

@Mod("sfm")
public class SFM {
    public static final String MOD_ID = "sfm";
    public static final Logger LOGGER = LogManager.getLogger(SFM.MOD_ID);

    public SFM() {
        var bus = FMLJavaModLoadingContext
                .get()
                .getModEventBus();
        SFMBlocks.register(bus);
        SFMItems.register(bus);
        SFMResourceTypes.register(bus);
        SFMBlockEntities.register(bus);
        SFMCapabilityProviderMappers.register(bus);
        SFMMenus.register(bus);
        SFMRecipeTypes.register(bus);
        SFMRecipeSerializers.register(bus);
        bus.addListener((FMLClientSetupEvent e) -> SFMMenuScreens.register());
        bus.addListener((FMLCommonSetupEvent e) -> SFMPackets.register());
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\cablenetwork\CableNetwork.java

````java
package ca.teamdman.sfm.common.cablenetwork;

import ca.teamdman.sfm.common.util.SFMUtils;
import com.mojang.datafixers.util.Pair;
import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
import it.unimi.dsi.fastutil.longs.LongSet;
import net.minecraft.core.BlockPos;
import net.minecraft.core.Direction;
import net.minecraft.world.level.Level;
import net.minecraftforge.common.capabilities.ICapabilityProvider;

import javax.annotation.Nullable;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Optional;
import java.util.stream.Stream;

public class CableNetwork {

    protected final Level LEVEL;
    protected final LongSet CABLE_POSITIONS = new LongOpenHashSet();
    protected final Long2ObjectMap<ICapabilityProvider> CAPABILITY_PROVIDER_BY_POSITION = new Long2ObjectOpenHashMap<>();

    public CableNetwork(Level level) {
        this.LEVEL = level;
    }

    /**
     * Only cable blocks are valid network members
     */
    public static boolean isCable(@Nullable Level world, BlockPos cablePos) {
        if (world == null) return false;
        return world
                .getBlockState(cablePos)
                .getBlock() instanceof ICableBlock;
    }

    public void rebuildNetwork(BlockPos start) {
        CABLE_POSITIONS.clear();
        CAPABILITY_PROVIDER_BY_POSITION.clear();
        discoverCables(start).forEach(this::addCable);
    }

    public void rebuildNetworkFromCache(BlockPos start, CableNetwork cache) {
        CABLE_POSITIONS.clear();
        CAPABILITY_PROVIDER_BY_POSITION.clear();

        // discover existing cables
        var cables = SFMUtils.getRecursiveStream((current, next, results) -> {
            results.accept(current);
            for (Direction d : Direction.values()) {
                BlockPos offset = current.offset(d.getNormal());
                if (cache.containsCablePosition(offset)) {
                    next.accept(offset);
                }
            }
        }, start).toList();
        for (BlockPos cablePos : cables) {
            CABLE_POSITIONS.add(cablePos.asLong());
        }
        // discover existing capability providers
        cables
                .stream()
                .flatMap(cablePos -> Arrays.stream(Direction.values()).map(Direction::getNormal).map(cablePos::offset))
                .distinct()
                .filter(pos -> cache.CAPABILITY_PROVIDER_BY_POSITION.containsKey(pos.asLong()))
                .map(capPos -> Pair.of(capPos, cache.CAPABILITY_PROVIDER_BY_POSITION.get(capPos.asLong())))
                .forEach(pair -> CAPABILITY_PROVIDER_BY_POSITION.put(pair.getFirst().asLong(), pair.getSecond()));
    }

    public Stream<BlockPos> discoverCables(BlockPos startPos) {
        return SFMUtils.getRecursiveStream((current, next, results) -> {
            results.accept(current);
            for (Direction d : Direction.values()) {
                BlockPos offset = current.offset(d.getNormal());
                if (isCable(getLevel(), offset)) {
                    next.accept(offset);
                }
            }
        }, startPos);
    }

    public void addCable(BlockPos pos) {
        boolean isNewMember = CABLE_POSITIONS.add(pos.asLong());
        if (isNewMember) {
            rebuildAdjacentInventories(pos);
        }
    }

    public Level getLevel() {
        return LEVEL;
    }

    /**
     * Collects the capability providers of blocks neighbouring the cable
     *
     * @param cablePos position of the cable
     */
    public void rebuildAdjacentInventories(BlockPos cablePos) {
        Arrays
                .stream(Direction.values())
                .map(Direction::getNormal)
                .map(cablePos::offset)
                .distinct()
                .peek(pos -> CAPABILITY_PROVIDER_BY_POSITION.remove(pos.asLong())) // Bust the cache
                .filter(this::isAdjacentToCable) // Verify if should [re]join network
                .map(pos -> SFMUtils
                        .discoverCapabilityProvider(LEVEL, pos)
                        .map(prov -> Pair.of(pos, prov))) // Check if we can get capabilities from this block
                .filter(Optional::isPresent)
                .map(Optional::get)
                .forEach(prov -> CAPABILITY_PROVIDER_BY_POSITION.put(
                        prov.getFirst().asLong(),
                        prov.getSecond()
                )); // track it
    }

    @Override
    public String toString() {
        return "CableNetwork{level="
               + getLevel().dimension().location()
               + ", #cables="
               + getCableCount()
               + ", #capabilityProviders="
               + CAPABILITY_PROVIDER_BY_POSITION.size()
               + "}";
    }

    /**
     * Cables should only join the network if they would be touching a cable already in the network
     *
     * @param pos Candidate cable position
     * @return {@code true} if adjacent to cable in network
     */
    public boolean isAdjacentToCable(BlockPos pos) {
        for (Direction direction : Direction.values()) {
            if (containsCablePosition(pos.offset(direction.getNormal()))) {
                return true;
            }
        }
        return false;
    }

    public boolean containsCablePosition(BlockPos pos) {
        return CABLE_POSITIONS.contains(pos.asLong());
    }

    public boolean isInNetwork(BlockPos pos) {
        return CAPABILITY_PROVIDER_BY_POSITION.containsKey(pos.asLong());
    }


    public Optional<ICapabilityProvider> getCapabilityProvider(BlockPos pos) {
        return Optional.ofNullable(CAPABILITY_PROVIDER_BY_POSITION.get(pos.asLong()));
    }

    public int getCableCount() {
        return CABLE_POSITIONS.size();
    }

    /**
     * Merges a network into this one, such as when a cable connects two networks
     *
     * @param other Foreign network
     */
    public void mergeNetwork(CableNetwork other) {
        CABLE_POSITIONS.addAll(other.CABLE_POSITIONS);
        CAPABILITY_PROVIDER_BY_POSITION.putAll(other.CAPABILITY_PROVIDER_BY_POSITION);
    }

    public boolean isEmpty() {
        return CABLE_POSITIONS.isEmpty();
    }

    public Stream<BlockPos> getCablePositions() {
        return CABLE_POSITIONS.longStream().mapToObj(BlockPos::of);
    }

    public Stream<BlockPos> getCapabilityProviderPositions() {
        return CAPABILITY_PROVIDER_BY_POSITION.keySet().longStream().mapToObj(BlockPos::of);
    }

    /**
     * Discover what networks would exist if this network did not have a cable at {@code cablePos}.
     * @param cablePos cable position to be removed
     * @return resulting networks to replace this network
     */
    protected List<CableNetwork> withoutCable(BlockPos cablePos) {
        CABLE_POSITIONS.remove(cablePos.asLong());
        List<CableNetwork> branches = new ArrayList<>();
        for (var direction : Direction.values()) {
            var offsetPos = cablePos.offset(direction.getNormal());
            if (!containsCablePosition(offsetPos)) continue;
            // make sure that a branch network doesn't already contain this cable
            if (branches.stream().anyMatch(n -> n.containsCablePosition(offsetPos))) continue;
            var branchNetwork = new CableNetwork(this.getLevel());
            branchNetwork.rebuildNetworkFromCache(offsetPos, this);
            branches.add(branchNetwork);
        }
        return branches;
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\util\OpenContainerTracker.java

````java
package ca.teamdman.sfm.common.util;

import ca.teamdman.sfm.SFM;
import net.minecraft.server.level.ServerPlayer;
import net.minecraft.world.inventory.AbstractContainerMenu;
import net.minecraftforge.eventbus.api.SubscribeEvent;
import net.minecraftforge.fml.common.Mod;

import java.util.Map;
import java.util.WeakHashMap;
import java.util.stream.Stream;

import static net.minecraftforge.event.entity.player.PlayerContainerEvent.Close;
import static net.minecraftforge.event.entity.player.PlayerContainerEvent.Open;

@Mod.EventBusSubscriber(bus = Mod.EventBusSubscriber.Bus.FORGE, modid = SFM.MOD_ID)
public class OpenContainerTracker {
    private static final Map<ServerPlayer, AbstractContainerMenu> OPEN_CONTAINERS = new WeakHashMap<>();

    @SuppressWarnings("unchecked")
    public static <T extends AbstractContainerMenu> Stream<Map.Entry<ServerPlayer, T>> getPlayersWithOpenContainer(Class<T> menuClass) {
        return OPEN_CONTAINERS.entrySet().stream()
                .filter(e -> menuClass.isInstance(e.getValue()))
                .map(e -> (Map.Entry<ServerPlayer, T>) e);
    }

    @SubscribeEvent
    public static void onOpenContainer(Open event) {
        if (event.getEntity() instanceof ServerPlayer serverPlayer) {
            OPEN_CONTAINERS.put(serverPlayer, event.getContainer());
        }
    }

    @SubscribeEvent
    public static void onCloseContainer(Close event) {
        if (event.getEntity() instanceof ServerPlayer serverPlayer) {
            OPEN_CONTAINERS.remove(serverPlayer);
        }
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\net\ClientboundInputInspectionResultsPacket.java

````java
package ca.teamdman.sfm.common.net;

import ca.teamdman.sfm.client.ClientStuff;
import net.minecraft.network.FriendlyByteBuf;
import net.minecraftforge.network.NetworkEvent;

import java.util.function.Supplier;

public record ClientboundInputInspectionResultsPacket(
        String results
) {
    public static final int MAX_RESULTS_LENGTH = 20480;

    public static void encode(
            ClientboundInputInspectionResultsPacket msg, FriendlyByteBuf friendlyByteBuf
    ) {
        friendlyByteBuf.writeUtf(msg.results(), MAX_RESULTS_LENGTH);
    }

    public static ClientboundInputInspectionResultsPacket decode(FriendlyByteBuf friendlyByteBuf) {
        return new ClientboundInputInspectionResultsPacket(
                friendlyByteBuf.readUtf(MAX_RESULTS_LENGTH)
        );
    }

    public static void handle(
            ClientboundInputInspectionResultsPacket msg, Supplier<NetworkEvent.Context> contextSupplier
    ) {
        contextSupplier.get().enqueueWork(() -> ClientStuff.showProgramEditScreen(msg.results, next -> {
        }));
        contextSupplier.get().setPacketHandled(true);
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfml\ast\Limit.java

````java
package ca.teamdman.sfml.ast;

import static ca.teamdman.sfml.ast.ResourceQuantity.IdExpansionBehaviour.NO_EXPAND;

public record Limit(
        ResourceQuantity quantity,
        ResourceQuantity retention
) implements ASTNode {
    public static final Limit MAX_QUANTITY_NO_RETENTION = new Limit(
            new ResourceQuantity(new Number(Long.MAX_VALUE), NO_EXPAND),
            new ResourceQuantity(new Number(0), NO_EXPAND)
    );
    public static final Limit MAX_QUANTITY_MAX_RETENTION = new Limit(
            new ResourceQuantity(new Number(Long.MAX_VALUE), NO_EXPAND),
            new ResourceQuantity(new Number(Long.MAX_VALUE), NO_EXPAND)
    );

    public static final Limit UNSET = new Limit(
            ResourceQuantity.UNSET,
            ResourceQuantity.UNSET
    );

    public Limit withDefaults(Limit limit) {
        if (quantity() == ResourceQuantity.UNSET && retention() == ResourceQuantity.UNSET) {
            return limit;
        } else if (quantity() == ResourceQuantity.UNSET) {
            return new Limit(
                    limit.quantity(),
                    retention()
            );
        } else if (retention() == ResourceQuantity.UNSET) {
            return new Limit(
                    quantity(),
                    limit.retention()
            );
        }
        return this;
    }

    @Override
    public String toString() {
        return quantity + " RETAIN " + retention;
    }

    public String toStringCondensed(Limit defaults) {
        StringBuilder sb = new StringBuilder();
        if (!quantity.number().equals(defaults.quantity().number())) {
            sb.append(quantity);
        }
        if (!retention.number().equals(defaults.retention().number())) {
            if (!sb.isEmpty()) sb.append(" ");
            sb.append("RETAIN ").append(retention);
        }
        return sb.toString();
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfml\ast\ResourceIdSet.java

````java
package ca.teamdman.sfml.ast;

import java.util.Set;
import java.util.function.Predicate;

public record ResourceIdSet(
        Set<ResourceIdentifier<?, ?, ?>> resourceIds
) implements ASTNode, Predicate<Object> {
    public static final ResourceIdSet EMPTY = new ResourceIdSet(Set.of());

    public boolean test(Object stack) {
        for (ResourceIdentifier<?, ?, ?> exclude : resourceIds) {
            if (exclude.test(stack)) {
                return true;
            }
        }
        return false;
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\client\package-info.java

````java
@ParametersAreNonnullByDefault
@MethodsReturnNonnullByDefault
@FieldsAreNonnullByDefault
package ca.teamdman.sfm.client;

import net.minecraft.FieldsAreNonnullByDefault;
import net.minecraft.MethodsReturnNonnullByDefault;

import javax.annotation.ParametersAreNonnullByDefault;
````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\net\ClientboundManagerGuiPacket.java

````java
package ca.teamdman.sfm.common.net;

import ca.teamdman.sfm.client.ClientStuff;
import ca.teamdman.sfm.common.blockentity.ManagerBlockEntity;
import ca.teamdman.sfml.ast.Program;
import net.minecraft.network.FriendlyByteBuf;
import net.minecraftforge.network.NetworkEvent;

import java.util.function.Supplier;

public record ClientboundManagerGuiPacket(
        int windowId,
        String program,
        ManagerBlockEntity.State state,
        long[] tickTimes
) {

    public static void encode(
            ClientboundManagerGuiPacket msg, FriendlyByteBuf friendlyByteBuf
    ) {
        friendlyByteBuf.writeVarInt(msg.windowId());
        friendlyByteBuf.writeUtf(msg.program(), Program.MAX_PROGRAM_LENGTH);
        friendlyByteBuf.writeEnum(msg.state());
        friendlyByteBuf.writeLongArray(msg.tickTimes());
    }

    public static ClientboundManagerGuiPacket decode(FriendlyByteBuf friendlyByteBuf) {
        return new ClientboundManagerGuiPacket(
                friendlyByteBuf.readVarInt(),
                friendlyByteBuf.readUtf(Program.MAX_PROGRAM_LENGTH),
                friendlyByteBuf.readEnum(ManagerBlockEntity.State.class),
                friendlyByteBuf.readLongArray()
        );
    }

    public static void handle(
            ClientboundManagerGuiPacket msg, Supplier<NetworkEvent.Context> contextSupplier
    ) {
        contextSupplier.get().enqueueWork(() -> ClientStuff.updateMenu(msg));
        contextSupplier.get().setPacketHandled(true);
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfml\ast\NumberRangeSet.java

````java
package ca.teamdman.sfml.ast;

public record NumberRangeSet(NumberRange[] ranges) implements ASTNode {
    public static NumberRangeSet MAX_RANGE = new NumberRangeSet(new NumberRange[]{NumberRange.MAX_RANGE});
    public boolean contains(int value) {
        for (NumberRange range : ranges) {
            if (range.contains(value)) {
                return true;
            }
        }
        return false;
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\client\jei\package-info.java

````java
@ParametersAreNonnullByDefault
@MethodsReturnNonnullByDefault
@FieldsAreNonnullByDefault
package ca.teamdman.sfm.client.jei;

import net.minecraft.FieldsAreNonnullByDefault;
import net.minecraft.MethodsReturnNonnullByDefault;

import javax.annotation.ParametersAreNonnullByDefault;
````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\client\registry\SFMMenuScreens.java

````java
package ca.teamdman.sfm.client.registry;

import ca.teamdman.sfm.client.gui.screen.ManagerScreen;
import ca.teamdman.sfm.common.registry.SFMMenus;
import net.minecraft.client.gui.screens.MenuScreens;

public class SFMMenuScreens {
    public static void register() {
        MenuScreens.register(SFMMenus.MANAGER_MENU.get(), ManagerScreen::new);
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\client\render\package-info.java

````java
@ParametersAreNonnullByDefault
@MethodsReturnNonnullByDefault
@FieldsAreNonnullByDefault
package ca.teamdman.sfm.client.render;

import net.minecraft.FieldsAreNonnullByDefault;
import net.minecraft.MethodsReturnNonnullByDefault;

import javax.annotation.ParametersAreNonnullByDefault;
````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\capabilityprovidermapper\CapabilityProviderMapper.java

````java
package ca.teamdman.sfm.common.capabilityprovidermapper;

import net.minecraft.core.BlockPos;
import net.minecraft.world.level.LevelAccessor;
import net.minecraftforge.common.capabilities.ICapabilityProvider;

import java.util.Optional;

public interface CapabilityProviderMapper {
    Optional<ICapabilityProvider> getProviderFor(LevelAccessor level, BlockPos pos);
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfml\ast\ResourceLimit.java

````java
package ca.teamdman.sfml.ast;

import ca.teamdman.sfm.common.program.InputResourceTracker;
import ca.teamdman.sfm.common.program.OutputResourceTracker;

import java.util.concurrent.atomic.AtomicLong;
import java.util.function.Consumer;
import java.util.function.Predicate;

import static ca.teamdman.sfml.ast.ResourceQuantity.IdExpansionBehaviour.EXPAND;
import static ca.teamdman.sfml.ast.ResourceQuantity.IdExpansionBehaviour.NO_EXPAND;

public record ResourceLimit<STACK, ITEM, CAP>(
        ResourceIdentifier<STACK, ITEM, CAP> resourceId,
        Limit limit
) implements ASTNode, Predicate<Object> {
    public static final ResourceLimit<?, ?, ?> TAKE_ALL_LEAVE_NONE = new ResourceLimit<>(
            ResourceIdentifier.MATCH_ALL, Limit.MAX_QUANTITY_NO_RETENTION
    );
    public static final ResourceLimit<?, ?, ?> ACCEPT_ALL_WITHOUT_RESTRAINT = new ResourceLimit<>(
            ResourceIdentifier.MATCH_ALL, Limit.MAX_QUANTITY_MAX_RETENTION
    );

    public ResourceLimit<STACK, ITEM, CAP> withDefaults(Limit defaults) {
        return new ResourceLimit<>(resourceId, limit.withDefaults(defaults));
    }

    public ResourceLimit<STACK, ITEM, CAP> withLimit(Limit limit) {
        return new ResourceLimit<>(resourceId, limit);
    }

    public void gatherInputTrackers(Consumer<InputResourceTracker<?, ?, ?>> gatherer, ResourceIdSet exclusions) {
        if (limit.quantity().idExpansionBehaviour() == NO_EXPAND) {
            if (limit.retention().idExpansionBehaviour() == NO_EXPAND) {
                // no sharing, single tracker
                gatherer.accept(new InputResourceTracker<>(
                        this,
                        exclusions,
                        new AtomicLong(0),
                        new AtomicLong(0)
                ));
            } else if (limit.retention().idExpansionBehaviour() == EXPAND) {
                // expand retention
                // share quantity
                AtomicLong quantity = new AtomicLong(0);
                resourceId
                        .expand()
                        .forEach(rid -> gatherer.accept(new InputResourceTracker<>(
                                new ResourceLimit<>(rid, limit),
                                exclusions,
                                quantity,
                                new AtomicLong(0)
                        )));
            }
        } else if (limit.quantity().idExpansionBehaviour() == EXPAND) {
            if (limit.retention().idExpansionBehaviour() == NO_EXPAND) {
                // expand quantity
                // share retention
                AtomicLong retention = new AtomicLong(0);
                resourceId
                        .expand()
                        .forEach(rid -> gatherer.accept(new InputResourceTracker<>(
                                new ResourceLimit<>(rid, limit),
                                exclusions,
                                new AtomicLong(0),
                                retention
                        )));
            } else if (limit.retention().idExpansionBehaviour() == EXPAND) {
                // no sharing, multiple trackers
                resourceId
                        .expand()
                        .forEach(rid -> gatherer.accept(new InputResourceTracker<>(
                                new ResourceLimit<>(rid, limit),
                                exclusions,
                                new AtomicLong(0),
                                new AtomicLong(0)
                        )));
            }
        }
    }

    public void gatherOutputTrackers(Consumer<OutputResourceTracker<?, ?, ?>> gatherer, ResourceIdSet exclusions) {
        if (limit.quantity().idExpansionBehaviour() == NO_EXPAND) {
            if (limit.retention().idExpansionBehaviour() == NO_EXPAND) {
                // single tracker
                gatherer.accept(new OutputResourceTracker<>(this, exclusions, new AtomicLong(0), new AtomicLong(0)));
            } else if (limit.retention().idExpansionBehaviour() == EXPAND) {
                // tracker for each retention, sharing quantity
                AtomicLong quantity = new AtomicLong(0);
                resourceId
                        .expand()
                        .forEach(rid -> gatherer.accept(new OutputResourceTracker<>(
                                new ResourceLimit<>(rid, limit),
                                exclusions,
                                quantity,
                                new AtomicLong(0)
                        )));
            }
        } else if (limit.quantity().idExpansionBehaviour() == EXPAND) {
            if (limit.retention().idExpansionBehaviour() == NO_EXPAND) {
                // tracker for each quantity, sharing retention
                AtomicLong retained = new AtomicLong(0);
                resourceId
                        .expand()
                        .forEach(rid -> gatherer.accept(new OutputResourceTracker<>(
                                new ResourceLimit<>(rid, limit),
                                exclusions,
                                new AtomicLong(0),
                                retained
                        )));
            } else if (limit.retention().idExpansionBehaviour() == EXPAND) {
                // expand both quantity and retention, no sharing
                resourceId
                        .expand()
                        .forEach(rid -> gatherer.accept(new OutputResourceTracker<>(
                                new ResourceLimit<>(rid, limit),
                                exclusions,
                                new AtomicLong(0),
                                new AtomicLong(0)
                        )));
            }
        }
    }

    public boolean test(Object stack) {
        return resourceId.test(stack);
    }

    @Override
    public String toString() {
        return limit + " " + resourceId;
    }

    public String toStringCondensed(Limit defaults) {
        return (limit.toStringCondensed(defaults) + " " + resourceId.toStringCondensed()).trim();
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\registry\SFMItems.java

````java
package ca.teamdman.sfm.common.registry;

import ca.teamdman.sfm.SFM;
import ca.teamdman.sfm.common.item.*;
import net.minecraft.world.item.BlockItem;
import net.minecraft.world.item.CreativeModeTab;
import net.minecraft.world.item.Item;
import net.minecraft.world.item.ItemStack;
import net.minecraft.world.level.block.Block;
import net.minecraftforge.eventbus.api.IEventBus;
import net.minecraftforge.registries.DeferredRegister;
import net.minecraftforge.registries.ForgeRegistries;
import net.minecraftforge.registries.RegistryObject;

public class SFMItems {
    public static final CreativeModeTab TAB = new CreativeModeTab(SFM.MOD_ID) {
        @Override
        public ItemStack makeIcon() {
            return new ItemStack(SFMBlocks.MANAGER_BLOCK.get());
        }
    };
    private static final DeferredRegister<Item> ITEMS = DeferredRegister.create(ForgeRegistries.ITEMS, SFM.MOD_ID);
    public static final RegistryObject<Item> MANAGER_ITEM = register("manager", SFMBlocks.MANAGER_BLOCK);
    public static final RegistryObject<Item> CABLE_ITEM = register("cable", SFMBlocks.CABLE_BLOCK);
    public static final RegistryObject<Item> PRINTING_PRESS_ITEM = ITEMS.register(
            "printing_press",
            PrintingPressBlockItem::new
    );
    //    public static final  RegistryObject<Item>   BATTERY_ITEM    = register("battery", SFMBlocks.BATTERY_BLOCK);
    public static final RegistryObject<Item> WATER_TANK_ITEM = register("water_tank", SFMBlocks.WATER_TANK_BLOCK);
    public static final RegistryObject<Item> DISK_ITEM = ITEMS.register("disk", DiskItem::new);
    public static final RegistryObject<Item> LABEL_GUN_ITEM = ITEMS.register(
            "labelgun",
            LabelGunItem::new
    ); // TODO: rename on a major version update to label_gun
    public static final RegistryObject<Item> NETWORK_TOOL_ITEM = ITEMS.register("network_tool", NetworkToolItem::new);

    public static final RegistryObject<Item> FORM_ITEM = ITEMS.register("form", FormItem::new);
    public static final RegistryObject<Item> EXPERIENCE_SHARD_ITEM = ITEMS.register("xp_shard", ExperienceShard::new);
    public static final RegistryObject<Item> EXPERIENCE_GOOP_ITEM = ITEMS.register("xp_goop", ExperienceGoop::new);

    public static void register(IEventBus bus) {
        ITEMS.register(bus);
    }

    private static RegistryObject<Item> register(String name, RegistryObject<Block> block) {
        return ITEMS.register(name, () -> new BlockItem(block.get(), new Item.Properties().tab(TAB)));
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\block\BatteryBlock.java

````java
package ca.teamdman.sfm.common.block;

import ca.teamdman.sfm.SFM;
import ca.teamdman.sfm.common.blockentity.BatteryBlockEntity;
import ca.teamdman.sfm.common.registry.SFMBlockEntities;
import net.minecraft.core.BlockPos;
import net.minecraft.world.InteractionHand;
import net.minecraft.world.InteractionResult;
import net.minecraft.world.entity.player.Player;
import net.minecraft.world.level.Level;
import net.minecraft.world.level.block.Block;
import net.minecraft.world.level.block.EntityBlock;
import net.minecraft.world.level.block.entity.BlockEntity;
import net.minecraft.world.level.block.state.BlockBehaviour;
import net.minecraft.world.level.block.state.BlockState;
import net.minecraft.world.level.block.state.StateDefinition;
import net.minecraft.world.level.block.state.properties.IntegerProperty;
import net.minecraft.world.level.material.Material;
import net.minecraft.world.phys.BlockHitResult;
import net.minecraftforge.common.capabilities.ForgeCapabilities;

public class BatteryBlock extends Block implements EntityBlock {
    public static final IntegerProperty LEVEL = IntegerProperty.create("level", 0, 10);

    public BatteryBlock() {
        super(BlockBehaviour.Properties.of(Material.METAL).strength(5.0F, 6.0F));
        this.registerDefaultState(this.getStateDefinition().any().setValue(LEVEL, 0));
    }

    @Override
    public BlockEntity newBlockEntity(BlockPos pos, BlockState state) {
        return SFMBlockEntities.BATTERY_BLOCK_ENTITY
                .get()
                .create(pos, state);
    }

    @Override
    protected void createBlockStateDefinition(StateDefinition.Builder<Block, BlockState> builder) {
        builder.add(LEVEL);
    }

    @SuppressWarnings("deprecation")
    @Override
    public InteractionResult use(
            BlockState pState,
            Level pLevel,
            BlockPos pPos,
            Player pPlayer,
            InteractionHand pHand,
            BlockHitResult pHit
    ) {
        BlockEntity be = pLevel.getBlockEntity(pPos);
        if (be instanceof BatteryBlockEntity bbe) {
            var cap = bbe.getCapability(ForgeCapabilities.ENERGY, pHit.getDirection());
            cap.ifPresent(c -> {
                if (pPlayer.isShiftKeyDown()) {
                    c.extractEnergy(1000, false);
                } else {
                    c.receiveEnergy(1000, false);
                }
                SFM.LOGGER.info("Energy stored: {}", c.getEnergyStored());
            });
        }
        return InteractionResult.SUCCESS;
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\blockentity\ManagerBlockEntity.java

````java
package ca.teamdman.sfm.common.blockentity;

import ca.teamdman.sfm.common.Constants;
import ca.teamdman.sfm.common.containermenu.ManagerContainerMenu;
import ca.teamdman.sfm.common.item.DiskItem;
import ca.teamdman.sfm.common.net.ClientboundManagerGuiPacket;
import ca.teamdman.sfm.common.registry.SFMBlockEntities;
import ca.teamdman.sfm.common.registry.SFMPackets;
import ca.teamdman.sfm.common.util.OpenContainerTracker;
import ca.teamdman.sfm.common.util.SFMContainerUtil;
import ca.teamdman.sfml.ast.Program;
import net.minecraft.ChatFormatting;
import net.minecraft.core.BlockPos;
import net.minecraft.core.NonNullList;
import net.minecraft.nbt.CompoundTag;
import net.minecraft.network.chat.Component;
import net.minecraft.world.ContainerHelper;
import net.minecraft.world.entity.player.Inventory;
import net.minecraft.world.entity.player.Player;
import net.minecraft.world.inventory.AbstractContainerMenu;
import net.minecraft.world.item.ItemStack;
import net.minecraft.world.level.Level;
import net.minecraft.world.level.block.entity.BaseContainerBlockEntity;
import net.minecraft.world.level.block.state.BlockState;
import net.minecraftforge.network.PacketDistributor;

import javax.annotation.Nullable;
import java.util.Collections;
import java.util.Optional;
import java.util.Set;

public class ManagerBlockEntity extends BaseContainerBlockEntity {
    public static final int TICK_TIME_HISTORY_SIZE = 20;
    private final NonNullList<ItemStack> ITEMS = NonNullList.withSize(1, ItemStack.EMPTY);
    private final long[] tickTimeNanos = new long[TICK_TIME_HISTORY_SIZE];
    private @Nullable Program program = null;
    private int tick = 0;
    private int unprocessedRedstonePulses = 0; // used by redstone trigger
    private boolean shouldRebuildProgram = false;
    private int tickIndex = 0;

    public ManagerBlockEntity(BlockPos blockPos, BlockState blockState) {
        super(SFMBlockEntities.MANAGER_BLOCK_ENTITY.get(), blockPos, blockState);
    }

    public static void serverTick(
            @SuppressWarnings("unused") Level level,
            @SuppressWarnings("unused") BlockPos pos,
            @SuppressWarnings("unused") BlockState state,
            ManagerBlockEntity tile
    ) {
        long start = System.nanoTime();
        tile.tick++;
        if (tile.shouldRebuildProgram) {
            tile.rebuildProgramAndUpdateDisk();
            tile.shouldRebuildProgram = false;
        }
        if (tile.program != null) {
            boolean didSomething = tile.program.tick(tile);
            if (didSomething) {
                long nanoTimePassed = Long.min(System.nanoTime() - start, Integer.MAX_VALUE);
                tile.tickTimeNanos[tile.tickIndex] = (int) nanoTimePassed;
                tile.tickIndex = (tile.tickIndex + 1) % tile.tickTimeNanos.length;
                tile.sendUpdatePacket();
            }
        }
    }

    private void sendUpdatePacket() {
        OpenContainerTracker.getPlayersWithOpenContainer(ManagerContainerMenu.class)
                .filter(entry -> entry.getValue().MANAGER_POSITION.equals(getBlockPos()))
                .forEach(entry -> SFMPackets.MANAGER_CHANNEL.send(
                        PacketDistributor.PLAYER.with(entry::getKey),
                        new ClientboundManagerGuiPacket(
                                entry.getValue().containerId,
                                getProgramString().orElse(""),
                                getState(),
                                getTickTimeNanos()
                        )
                ));
    }

    public int getTick() {
        return tick;
    }

    public Optional<Program> getProgram() {
        return Optional.ofNullable(program);
    }

    public void setProgram(String program) {
        getDisk().ifPresent(disk -> {
            DiskItem.setProgram(disk, program);
            rebuildProgramAndUpdateDisk();
            setChanged();
        });
    }

    public void trackRedstonePulseUnprocessed() {
        unprocessedRedstonePulses++;
    }

    public void clearRedstonePulseQueue() {
        unprocessedRedstonePulses = 0;
    }

    public int getUnprocessedRedstonePulseCount() {
        return unprocessedRedstonePulses;
    }

    public State getState() {
        if (getDisk().isEmpty()) return State.NO_DISK;
        if (getProgramString().isEmpty()) return State.NO_PROGRAM;
        if (program == null) return State.INVALID_PROGRAM;
        return State.RUNNING;
    }

    public Optional<String> getProgramString() {
        return getDisk().map(DiskItem::getProgram).filter(prog -> !prog.isBlank());
    }

    public Set<String> getReferencedLabels() {
        if (program == null) return Collections.emptySet();
        return program.referencedLabels();
    }

    public Optional<ItemStack> getDisk() {
        var item = getItem(0);
        if (item.getItem() instanceof DiskItem) return Optional.of(item);
        return Optional.empty();
    }

    public void rebuildProgramAndUpdateDisk() {
        if (level != null && level.isClientSide()) return;
        this.program = getDisk()
                .flatMap(itemStack -> DiskItem.updateDetails(itemStack, this))
                .orElse(null);
        sendUpdatePacket();
    }

    @Override
    protected Component getDefaultName() {
        return Constants.LocalizationKeys.MANAGER_CONTAINER.getComponent();
    }

    @Override
    protected AbstractContainerMenu createMenu(int windowId, Inventory inv) {
        return new ManagerContainerMenu(windowId, inv, this);
    }

    @Override
    public int getContainerSize() {
        return ITEMS.size();
    }

    @Override
    public boolean isEmpty() {
        return ITEMS.isEmpty();
    }

    @Override
    public ItemStack getItem(int slot) {
        if (slot < 0 || slot >= ITEMS.size()) return ItemStack.EMPTY;
        return ITEMS.get(slot);
    }

    @Override
    public ItemStack removeItem(int slot, int amount) {
        var result = ContainerHelper.removeItem(ITEMS, slot, amount);
        if (slot == 0) rebuildProgramAndUpdateDisk();
        setChanged();
        return result;
    }

    @Override
    public ItemStack removeItemNoUpdate(int slot) {
        var result = ContainerHelper.takeItem(ITEMS, slot);
        if (slot == 0) rebuildProgramAndUpdateDisk();
        setChanged();
        return result;
    }

    @Override
    public void setItem(int slot, ItemStack stack) {
        if (slot < 0 || slot >= ITEMS.size()) return;
        ITEMS.set(slot, stack);
        if (slot == 0) rebuildProgramAndUpdateDisk();
        setChanged();
    }

    @Override
    public int getMaxStackSize() {
        return 1;
    }

    @Override
    public boolean canPlaceItem(int slot, ItemStack stack) {
        return stack.getItem() instanceof DiskItem;
    }

    @Override
    public boolean stillValid(Player player) {
        return SFMContainerUtil.stillValid(this, player);
    }

    @Override
    public void load(CompoundTag tag) {
        super.load(tag);
        ContainerHelper.loadAllItems(tag, ITEMS);
        this.shouldRebuildProgram = true;
    }

    @Override
    protected void saveAdditional(CompoundTag tag) {
        super.saveAdditional(tag);
        ContainerHelper.saveAllItems(tag, ITEMS);
    }


    @Override
    public void clearContent() {
        ITEMS.clear();
    }

    public void reset() {
        getDisk().ifPresent(disk -> {
            disk.setTag(null);
            setItem(0, disk);
            setChanged();
        });
    }

    public long[] getTickTimeNanos() {
        // tickTimeNanos is used as a cyclical buffer, transform it to have the first index be the most recent tick
        long[] result = new long[tickTimeNanos.length];
        System.arraycopy(tickTimeNanos, tickIndex, result, 0, tickTimeNanos.length - tickIndex);
        System.arraycopy(tickTimeNanos, 0, result, tickTimeNanos.length - tickIndex, tickIndex);
        return result;
    }

    public enum State {
        NO_PROGRAM(
                ChatFormatting.RED,
                Constants.LocalizationKeys.MANAGER_GUI_STATE_NO_PROGRAM
        ), NO_DISK(
                ChatFormatting.RED,
                Constants.LocalizationKeys.MANAGER_GUI_STATE_NO_DISK
        ), RUNNING(ChatFormatting.GREEN, Constants.LocalizationKeys.MANAGER_GUI_STATE_RUNNING), INVALID_PROGRAM(
                ChatFormatting.DARK_RED,
                Constants.LocalizationKeys.MANAGER_GUI_STATE_INVALID_PROGRAM
        );

        public final ChatFormatting COLOR;
        public final Constants.LocalizationKeys.LocalizationEntry LOC;

        State(ChatFormatting color, Constants.LocalizationKeys.LocalizationEntry loc) {
            COLOR = color;
            LOC = loc;
        }
    }

}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\client\ProgramSyntaxHighlightingHelper.java

````java
package ca.teamdman.sfm.client;

import ca.teamdman.sfml.SFMLLexer;
import net.minecraft.ChatFormatting;
import net.minecraft.network.chat.Component;
import net.minecraft.network.chat.MutableComponent;
import net.minecraft.network.chat.Style;
import org.antlr.v4.runtime.CharStreams;
import org.antlr.v4.runtime.CommonTokenStream;
import org.antlr.v4.runtime.Token;

import java.util.ArrayList;
import java.util.List;

public class ProgramSyntaxHighlightingHelper {

    public static List<MutableComponent> withSyntaxHighlighting(String programString, boolean showContextActionHints) {
        SFMLLexer lexer = new SFMLLexer(CharStreams.fromString(programString));
        lexer.INCLUDE_UNUSED = true;
        CommonTokenStream tokens = new CommonTokenStream(lexer) {
            // This is a hack to make hidden tokens show up in the token stream
            @Override
            public List<Token> getHiddenTokensToRight(int tokenIndex, int channel) {
                if (channel == Token.DEFAULT_CHANNEL) {
                    return getHiddenTokensToRight(tokenIndex, Token.HIDDEN_CHANNEL);
                } else {
                    return super.getHiddenTokensToRight(tokenIndex, channel);
                }
            }

            @Override
            public List<Token> getHiddenTokensToLeft(int tokenIndex, int channel) {
                if (channel == Token.DEFAULT_CHANNEL) {
                    return getHiddenTokensToLeft(tokenIndex, Token.HIDDEN_CHANNEL);
                } else {
                    return super.getHiddenTokensToLeft(tokenIndex, channel);
                }
            }
        };
        List<MutableComponent> textComponents = new ArrayList<>();
        MutableComponent lineComponent = Component.empty();
        tokens.fill();
        for (Token token : tokens.getTokens()) {
            if (token.getType() == SFMLLexer.EOF) break;
            // the token may contain newlines in it, so we need to split it up
            String[] lines = token.getText().split("\n", -1);
            for (int i = 0; i < lines.length; i++) {
                if (i != 0) {
                    textComponents.add(lineComponent);
                    lineComponent = Component.empty();
                }
                String line = lines[i];
                if (!line.isEmpty()) {
                    var text = Component.literal(line).withStyle(getStyle(token, showContextActionHints));
                    lineComponent = lineComponent.append(text);
                }
            }
        }
        textComponents.add(lineComponent);

        return textComponents;
    }

    private static Style getStyle(Token token, boolean showContextActionHints) {
        Style style = Style.EMPTY;
        style = style.withColor(getColour(token));
        if (showContextActionHints && ProgramTokenContextActions.hasContextAction(token)) {
            style = style.withUnderlined(true);
        }
        return style;
    }

    private static ChatFormatting getColour(Token token) {
        //noinspection EnhancedSwitchMigration
        switch (token.getType()) {
            case SFMLLexer.SIDE:
            case SFMLLexer.TOP:
            case SFMLLexer.BOTTOM:
            case SFMLLexer.NORTH:
            case SFMLLexer.SOUTH:
            case SFMLLexer.EAST:
            case SFMLLexer.WEST:
            case SFMLLexer.EACH:
                return ChatFormatting.DARK_PURPLE;
            case SFMLLexer.LINE_COMMENT:
                return ChatFormatting.GRAY;
            case SFMLLexer.INPUT:
            case SFMLLexer.FROM:
            case SFMLLexer.TO:
            case SFMLLexer.OUTPUT:
            case SFMLLexer.FORGET:
                return ChatFormatting.LIGHT_PURPLE;
            case SFMLLexer.NAME:
            case SFMLLexer.EVERY:
            case SFMLLexer.END:
            case SFMLLexer.DO:
            case SFMLLexer.IF:
            case SFMLLexer.ELSE:
            case SFMLLexer.THEN:
            case SFMLLexer.HAS:
            case SFMLLexer.TRUE:
            case SFMLLexer.FALSE:
            case SFMLLexer.NOT:
                return ChatFormatting.BLUE;
            case SFMLLexer.IDENTIFIER:
            case SFMLLexer.STRING:
                return ChatFormatting.GREEN;
            case SFMLLexer.TICKS:
            case SFMLLexer.SLOTS:
            case SFMLLexer.EXCEPT:
            case SFMLLexer.RETAIN:
            case SFMLLexer.LONE:
            case SFMLLexer.ONE:
            case SFMLLexer.OVERALL:
            case SFMLLexer.SOME:
            case SFMLLexer.AND:
                return ChatFormatting.GOLD;
            case SFMLLexer.NUMBER:
            case SFMLLexer.GT:
            case SFMLLexer.LT:
            case SFMLLexer.EQ:
            case SFMLLexer.GE:
            case SFMLLexer.LE:
            case SFMLLexer.GT_SYMBOL:
            case SFMLLexer.LT_SYMBOL:
            case SFMLLexer.EQ_SYMBOL:
            case SFMLLexer.GE_SYMBOL:
            case SFMLLexer.LE_SYMBOL:
                return ChatFormatting.AQUA;
            case SFMLLexer.UNUSED:
            case SFMLLexer.REDSTONE:
            case SFMLLexer.PULSE:
                return ChatFormatting.RED;
            case SFMLLexer.ROUND:
            case SFMLLexer.ROBIN:
            case SFMLLexer.BY:
            case SFMLLexer.BLOCK:
            case SFMLLexer.LABEL:
                return ChatFormatting.YELLOW;
            default:
                return ChatFormatting.WHITE;
        }
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\net\ServerboundManagerFixPacket.java

````java
package ca.teamdman.sfm.common.net;

import ca.teamdman.sfm.common.blockentity.ManagerBlockEntity;
import ca.teamdman.sfm.common.containermenu.ManagerContainerMenu;
import ca.teamdman.sfm.common.registry.SFMPackets;
import net.minecraft.core.BlockPos;
import net.minecraft.network.FriendlyByteBuf;
import net.minecraftforge.network.NetworkEvent;

import java.util.function.Supplier;

public record ServerboundManagerFixPacket(
        int windowId,
        BlockPos pos
) {
    public static void encode(ServerboundManagerFixPacket msg, FriendlyByteBuf friendlyByteBuf) {
        friendlyByteBuf.writeVarInt(msg.windowId());
        friendlyByteBuf.writeBlockPos(msg.pos());
    }

    public static ServerboundManagerFixPacket decode(FriendlyByteBuf friendlyByteBuf) {
        return new ServerboundManagerFixPacket(
                friendlyByteBuf.readVarInt(),
                friendlyByteBuf.readBlockPos()
        );
    }

    public static void handle(ServerboundManagerFixPacket msg, Supplier<NetworkEvent.Context> contextSupplier) {
        SFMPackets.handleServerboundContainerPacket(
                contextSupplier,
                ManagerContainerMenu.class,
                ManagerBlockEntity.class,
                msg.pos,
                msg.windowId,
                (menu, manager) -> manager
                        .getDisk()
                        .ifPresent(disk -> manager
                                .getProgram()
                                .ifPresent(program -> program.fixWarnings(disk, manager)))
        );
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\Constants.java

````java
package ca.teamdman.sfm.common;

import ca.teamdman.sfm.SFM;
import ca.teamdman.sfm.common.registry.SFMBlocks;
import ca.teamdman.sfm.common.registry.SFMItems;
import ca.teamdman.sfm.common.util.SFMUtils;
import net.minecraft.ChatFormatting;
import net.minecraft.client.resources.language.I18n;
import net.minecraft.network.chat.Component;
import net.minecraft.network.chat.MutableComponent;
import net.minecraft.network.chat.contents.TranslatableContents;

import java.util.ArrayList;
import java.util.List;
import java.util.function.Supplier;

public class Constants {
    public static final class LocalizationKeys {
        public static final LocalizationEntry PROGRAM_EDIT_SCREEN_TITLE = new LocalizationEntry(
                "gui.sfm.text_editor.title",
                "Text Editor"
        );
        public static final LocalizationEntry PROGRAM_EDIT_SCREEN_DONE_BUTTON_TOOLTIP = new LocalizationEntry(
                "gui.sfm.text_editor.done_button.tooltip",
                "Shift+Enter to submit"
        );
        public static final LocalizationEntry SAVE_CHANGES_CONFIRM_SCREEN_TITLE = new LocalizationEntry(
                "gui.sfm.save_changes_confirm.title",
                "Save changes"
        );
        public static final LocalizationEntry SAVE_CHANGES_CONFIRM_SCREEN_MESSAGE = new LocalizationEntry(
                "gui.sfm.save_changes_confirm.message",
                "Do you want to save before exiting?"
        );
        public static final LocalizationEntry SAVE_CHANGES_CONFIRM_SCREEN_YES_BUTTON = new LocalizationEntry(
                "gui.sfm.save_changes_confirm.yes_button",
                "Save changes"
        );
        public static final LocalizationEntry SAVE_CHANGES_CONFIRM_SCREEN_NO_BUTTON = new LocalizationEntry(
                "gui.sfm.save_changes_confirm.no_button",
                "Don't save"
        );

        @SuppressWarnings("unused") // used by minecraft without us having to directly reference
        public static LocalizationEntry MOD_NAME = new LocalizationEntry(
                "mod.name",
                "Super Factory Manager"
        );

        @SuppressWarnings("unused") // used by minecraft without us having to directly reference
        public static LocalizationEntry ITEM_GROUP = new LocalizationEntry(
                "itemGroup.sfm",
                "Super Factory Manager"
        );

        @SuppressWarnings("unused") // used by minecraft without us having to directly reference
        public static LocalizationEntry CABLE_BLOCK = new LocalizationEntry(
                () -> SFMBlocks.CABLE_BLOCK.get().getDescriptionId(),
                () -> "Inventory Cable"
        );

        @SuppressWarnings("unused") // used by minecraft without us having to directly reference
        public static LocalizationEntry MANAGER_BLOCK = new LocalizationEntry(
                () -> SFMBlocks.MANAGER_BLOCK.get().getDescriptionId(),
                () -> "Factory Manager"
        );
        @SuppressWarnings("unused") // used by minecraft without us having to directly reference
        public static LocalizationEntry PRINTING_PRESS_BLOCK = new LocalizationEntry(
                () -> SFMBlocks.PRINTING_PRESS_BLOCK.get().getDescriptionId(),
                () -> "Printing Press"
        );

        public static final LocalizationEntry PRINTING_PRESS_JEI_CATEGORY_TITLE = new LocalizationEntry(
                "gui.jei.category.sfm.printing_press",
                "Printing Press"
        );

        public static final LocalizationEntry FALLING_ANVIL_JEI_CATEGORY_TITLE = new LocalizationEntry(
                "gui.jei.category.sfm.falling_anvil",
                "Falling Anvil"
        );

        public static final LocalizationEntry FALLING_ANVIL_JEI_CONSUMED = new LocalizationEntry(
                "gui.jei.category.sfm.falling_anvil.consumed",
                "Gets consumed"
        );
        public static final LocalizationEntry FALLING_ANVIL_JEI_NOT_CONSUMED = new LocalizationEntry(
                "gui.jei.category.sfm.falling_anvil.not_consumed",
                "Not consumed"
        );

        public static final LocalizationEntry PRINTING_PRESS_TOOLTIP = new LocalizationEntry(
                () -> SFMItems.PRINTING_PRESS_ITEM.get().getDescriptionId() + ".tooltip",
                () -> "Place with an air gap below a downward facing piston. Extend the piston to use."
        );

        @SuppressWarnings("unused") // used by minecraft without us having to directly reference
        public static LocalizationEntry TEST_BARREL_BLOCK = new LocalizationEntry(
                () -> SFMBlocks.TEST_BARREL_BLOCK.get().getDescriptionId(),
                () -> "Test Barrel"
        );

        @SuppressWarnings("unused") // used by minecraft without us having to directly reference
        public static LocalizationEntry WATER_TANK_BLOCK = new LocalizationEntry(
                () -> SFMBlocks.WATER_TANK_BLOCK.get().getDescriptionId(),
                () -> "Water Tank"
        );
        @SuppressWarnings("unused") // used by minecraft without us having to directly reference
        public static LocalizationEntry BATTERY_BLOCK = new LocalizationEntry(
                () -> SFMBlocks.BATTERY_BLOCK.get().getDescriptionId(),
                () -> "Battery (WIP)"
        );
        @SuppressWarnings("unused") // used by minecraft without us having to directly reference
        public static LocalizationEntry DISK_ITEM = new LocalizationEntry(
                () -> SFMItems.DISK_ITEM.get().getDescriptionId(),
                () -> "Factory Manager Program Disk"
        );

        @SuppressWarnings("unused") // used by minecraft without us having to directly reference
        public static LocalizationEntry EXPERIENCE_GOOP_ITEM = new LocalizationEntry(
                () -> SFMItems.EXPERIENCE_GOOP_ITEM.get().getDescriptionId(),
                () -> "Experience Goop"
        );
        @SuppressWarnings("unused") // used by minecraft without us having to directly reference
        public static LocalizationEntry EXPERIENCE_SHARD_ITEM = new LocalizationEntry(
                () -> SFMItems.EXPERIENCE_SHARD_ITEM.get().getDescriptionId(),
                () -> "Experience Shard"
        );

        @SuppressWarnings("unused") // used by minecraft without us having to directly reference
        public static LocalizationEntry FORM_ITEM = new LocalizationEntry(
                () -> SFMItems.FORM_ITEM.get().getDescriptionId(),
                () -> "Printing Form"
        );

        public static final LocalizationEntry DISK_ITEM_TOOLTIP_LABEL_HEADER = new LocalizationEntry(
                () -> SFMItems.DISK_ITEM.get().getDescriptionId() + ".tooltip.label_section.header",
                () -> "Labels"
        );
        public static final LocalizationEntry DISK_ITEM_TOOLTIP_LABEL = new LocalizationEntry(
                () -> SFMItems.DISK_ITEM.get().getDescriptionId() + ".tooltip.label_section.entry",
                () -> " - %s: %d blocks"
        );
        @SuppressWarnings("unused") // used by minecraft without us having to directly reference
        public static LocalizationEntry LABEL_GUN_ITEM = new LocalizationEntry(
                () -> SFMItems.LABEL_GUN_ITEM.get().getDescriptionId(),
                () -> "Label Gun"
        );
        public static final LocalizationEntry LABEL_GUN_CHAT_PULLED = new LocalizationEntry(
                () -> SFMItems.LABEL_GUN_ITEM.get().getDescriptionId() + ".chat.pulled",
                () -> "Pulled labels from the manager."
        );
        public static final LocalizationEntry LABEL_GUN_CHAT_PUSHED = new LocalizationEntry(
                () -> SFMItems.LABEL_GUN_ITEM.get().getDescriptionId() + ".chat.pushed",
                () -> "Pushed labels to the manager."
        );

        @SuppressWarnings("unused") // used by minecraft without us having to directly reference
        public static LocalizationEntry NETWORK_TOOL_ITEM = new LocalizationEntry(
                () -> SFMItems.NETWORK_TOOL_ITEM.get().getDescriptionId(),
                () -> "Network Tool"
        );

        public static final LocalizationEntry NETWORK_TOOL_ITEM_TOOLTIP_1 = new LocalizationEntry(
                () -> SFMItems.NETWORK_TOOL_ITEM.get().getDescriptionId() + ".tooltip.1",
                () -> "Shows cables through walls when held."
        );
        public static final LocalizationEntry NETWORK_TOOL_ITEM_TOOLTIP_2 = new LocalizationEntry(
                () -> SFMItems.NETWORK_TOOL_ITEM.get().getDescriptionId() + ".tooltip.2",
                () -> "Right click a block face to view diagnostic info."
        );
        public static final LocalizationEntry NETWORK_TOOL_ITEM_TOOLTIP_3 = new LocalizationEntry(
                () -> SFMItems.NETWORK_TOOL_ITEM.get().getDescriptionId() + ".tooltip.3",
                () -> ChatFormatting.GRAY
                      + "You might not need this, don't forget you can press "
                      + ChatFormatting.AQUA
                      + "%s"
                      + ChatFormatting.GRAY
                      + " in an inventory to toggle the inspector."
        );
        public static final LocalizationEntry LABEL_GUN_ITEM_TOOLTIP_1 = new LocalizationEntry(
                () -> SFMItems.LABEL_GUN_ITEM.get().getDescriptionId() + ".tooltip.1",
                () -> "Right click a Factory Manager to push labels."
        );
        public static final LocalizationEntry LABEL_GUN_ITEM_TOOLTIP_2 = new LocalizationEntry(
                () -> SFMItems.LABEL_GUN_ITEM.get().getDescriptionId() + ".tooltip.2",
                () -> "Right click a Factory Manager while sneaking to pull labels."
        );
        public static final LocalizationEntry LABEL_GUN_ITEM_TOOLTIP_3 = new LocalizationEntry(
                () -> SFMItems.LABEL_GUN_ITEM.get().getDescriptionId() + ".tooltip.3",
                () -> "Hold control to apply labels to blocks of the same type adjacent to cables."
        );
        public static final LocalizationEntry LABEL_GUN_ITEM_NAME_WITH_LABEL = new LocalizationEntry(
                () -> SFMItems.LABEL_GUN_ITEM.get().getDescriptionId() + ".with_label",
                () -> "Label Gun: \"%s\""
        );
        public static final LocalizationEntry WATER_TANK_ITEM_TOOLTIP_1 = new LocalizationEntry(
                () -> SFMBlocks.WATER_TANK_BLOCK.get().getDescriptionId() + ".tooltip.1",
                () -> "Requires two adjacent water sources"
        );
        public static final LocalizationEntry WATER_TANK_ITEM_TOOLTIP_2 = new LocalizationEntry(
                () -> SFMBlocks.WATER_TANK_BLOCK.get().getDescriptionId() + ".tooltip.2",
                () -> "More effective when also adjacent to other water tanks"
        );
        public static final LocalizationEntry LABEL_GUN_GUI_TITLE = new LocalizationEntry(
                "gui.sfm.title.labelgun",
                "Label Gun"
        );
        public static final LocalizationEntry PROGRAM_TEMPLATE_PICKER_GUI_WARNING_1 = new LocalizationEntry(
                "gui.sfm.program_template_picker.warning1",
                "Hitting \"Done\" will on the next screen will overwrite your existing program!"
        );
        public static final LocalizationEntry PROGRAM_TEMPLATE_PICKER_GUI_WARNING_2 = new LocalizationEntry(
                "gui.sfm.program_template_picker.warning2",
                "Hit <esc> to cancel instead."
        );
        public static final LocalizationEntry PROGRAM_TEMPLATE_PICKER_GUI_TITLE = new LocalizationEntry(
                "gui.sfm.title.program_template_picker",
                "Program Template Picker"
        );
        public static final LocalizationEntry LABEL_GUN_GUI_LABEL_PLACEHOLDER = new LocalizationEntry(
                "gui.sfm.label_gun.placeholder",
                "Label"
        );
        public static final LocalizationEntry LABEL_GUN_GUI_LABEL_BUTTON = new LocalizationEntry(
                "gui.sfm.label_gun.label_button",
                "%s (%d)"
        );

        public static final LocalizationEntry LABEL_GUN_GUI_PRUNE_BUTTON = new LocalizationEntry(
                "gui.sfm.label_gun.prune_button",
                "Prune"
        );
        public static final LocalizationEntry LABEL_GUN_GUI_CLEAR_BUTTON = new LocalizationEntry(
                "gui.sfm.label_gun.clear_button",
                "Clear"
        );


        public static final LocalizationEntry MANAGER_GUI_PASTE_FROM_CLIPBOARD_BUTTON_TOOLTIP = new LocalizationEntry(
                "gui.sfm.manager.tooltip.paste",
                "Press Ctrl+V to paste."
        );
        public static final LocalizationEntry MANAGER_GUI_EDIT_BUTTON_TOOLTIP = new LocalizationEntry(
                "gui.sfm.manager.edit_button.tooltip",
                "Press Ctrl+E to edit."
        );
        public static final LocalizationEntry MANAGER_GUI_EDIT_BUTTON = new LocalizationEntry(
                "gui.sfm.manager.edit_button",
                "Edit"
        );
        public static final LocalizationEntry MANAGER_GUI_RESET_BUTTON_TOOLTIP = new LocalizationEntry(
                "gui.sfm.manager.tooltip.reset",
                "Wipes ALL disk data."
        );
        public static final LocalizationEntry MANAGER_CONTAINER = new LocalizationEntry(
                "container.sfm.manager",
                "Factory Manager"
        );

        public static final LocalizationEntry PROGRAM_WARNING_UNUSED_LABEL = new LocalizationEntry(
                "program.sfm.warnings.unused_label",
                "Label \"%s\" is used in code but not assigned in the world."
        );
        public static final LocalizationEntry PROGRAM_WARNING_UNKNOWN_RESOURCE_TYPE = new LocalizationEntry(
                "program.sfm.warnings.unknown_resource_type",
                "The resource type \"%s\" in \"%s\" is not supported."
        );
        public static final LocalizationEntry PROGRAM_WARNING_UNKNOWN_RESOURCE_ID = new LocalizationEntry(
                "program.sfm.warnings.unknown_resource_id",
                "Resource \"%s\" was not found."
        );
        public static final LocalizationEntry PROGRAM_WARNING_UNDEFINED_LABEL = new LocalizationEntry(
                "program.sfm.warnings.undefined_label",
                "Label \"%s\" is assigned in the world but not defined in code."
        );
        public static final LocalizationEntry PROGRAM_WARNING_DISCONNECTED_LABEL = new LocalizationEntry(
                "program.sfm.warnings.disconnected_label",
                "Label \"%s\" is assigned in the world at %s but not connected by cables."
        );
        public static final LocalizationEntry PROGRAM_WARNING_ADJACENT_BUT_DISCONNECTED_LABEL = new LocalizationEntry(
                "program.sfm.warnings.adjacent_but_disconnected_label",
                "Label \"%s\" is assigned in the world at %s and is connected by cables but is not detected as a valid inventory."
        );
        public static final LocalizationEntry PROGRAM_ERROR_COMPILE_FAILED = new LocalizationEntry(
                "program.sfm.error.compile_failed",
                "Failed to compile."
        );
        public static final LocalizationEntry PROGRAM_ERROR_LITERAL = new LocalizationEntry(
                "program.sfm.error.literal",
                "%s"
        );
        public static final LocalizationEntry PROGRAM_ERROR_MALFORMED_RESOURCE_TYPE = new LocalizationEntry(
                "program.sfm.error.malformed_resource_type",
                "Program has a malformed resource type \"%s\".\nReminder: Resource types must be literals, not wildcards."
        );
        public static final LocalizationEntry MANAGER_GUI_STATE_NO_PROGRAM = new LocalizationEntry(
                "gui.sfm.manager.state.no_program",
                "no program"
        );
        public static final LocalizationEntry MANAGER_GUI_STATE = new LocalizationEntry(
                "gui.sfm.manager.state",
                "State: %s"
        );

        public static final LocalizationEntry CONTAINER_INSPECTOR_SHOW_EXPORTS_BUTTON = new LocalizationEntry(
                "gui.sfm.container_inspector.show_exports_button",
                "Export Inspector"
        );
        public static final LocalizationEntry CONTAINER_INSPECTOR_MEKANISM_NULL_DIRECTION_WARNING = new LocalizationEntry(
                "gui.sfm.container_inspector.mekanism_null_direction_warning",
                "MEKANISM BLOCKS ARE READ-ONLY FROM THE NULL DIRECTION!!!!!!"
        );
        public static final LocalizationEntry CONTAINER_INSPECTOR_MEKANISM_MACHINE_INPUTS = new LocalizationEntry(
                "gui.sfm.container_inspector.mekanism_machine_inputs",
                "The following are based on the MACHINE'S input config"
        );
        public static final LocalizationEntry CONTAINER_INSPECTOR_MEKANISM_MACHINE_OUTPUTS = new LocalizationEntry(
                "gui.sfm.container_inspector.mekanism_machine_outputs",
                "The following are based on the MACHINE'S output config"
        );

        public static final LocalizationEntry CONTAINER_INSPECTOR_CONTAINER_SLOT_COUNT = new LocalizationEntry(
                "gui.sfm.container_inspector.container_slot_count",
                "Container Slots: %d"
        );
        public static final LocalizationEntry CONTAINER_INSPECTOR_INVENTORY_SLOT_COUNT = new LocalizationEntry(
                "gui.sfm.container_inspector.inventory_slot_count",
                "Inventory Slots: %d"
        );


        public static final LocalizationEntry MANAGER_GUI_PEAK_TICK_TIME = new LocalizationEntry(
                "gui.sfm.manager.peak_tick_time",
                "Peak tick time: %s ms"
        );
        public static final LocalizationEntry MANAGER_GUI_HOVERED_TICK_TIME = new LocalizationEntry(
                "gui.sfm.manager.hovered_tick_time",
                "Hovered tick time: %s ms"
        );
        public static final LocalizationEntry MANAGER_GUI_STATE_NO_DISK = new LocalizationEntry(
                "gui.sfm.manager.state.no_disk",
                "missing disk"
        );
        public static final LocalizationEntry MANAGER_GUI_STATE_RUNNING = new LocalizationEntry(
                "gui.sfm.manager.state.running",
                "running"
        );
        public static final LocalizationEntry MANAGER_GUI_STATE_INVALID_PROGRAM = new LocalizationEntry(
                "gui.sfm.manager.state.invalid_program",
                "invalid program"
        );
        public static final LocalizationEntry MANAGER_GUI_PASTE_FROM_CLIPBOARD_BUTTON = new LocalizationEntry(
                "gui.sfm.manager.button.paste_clipboard",
                "Paste from clipboard"
        );
        public static final LocalizationEntry MANAGER_GUI_COPY_TO_CLIPBOARD_BUTTON = new LocalizationEntry(
                "gui.sfm.manager.button.copy_to_clipboard",
                "Copy to clipboard"
        );
        public static final LocalizationEntry MANAGER_GUI_VIEW_EXAMPLES_BUTTON = new LocalizationEntry(
                "gui.sfm.manager.button.view_examples",
                "View examples"
        );
        public static final LocalizationEntry MANAGER_GUI_VIEW_EXAMPLES_BUTTON_TOOLTIP = new LocalizationEntry(
                "gui.sfm.manager.button.view_examples.tooltip",
                "Press Ctrl+Shift+E to view examples."
        );
        public static final LocalizationEntry MANAGER_GUI_RESET_BUTTON = new LocalizationEntry(
                "gui.sfm.manager.button.reset",
                "Reset"
        );

        public static final LocalizationEntry MANAGER_GUI_WARNING_BUTTON_TOOLTIP = new LocalizationEntry(
                "gui.sfm.manager.button.warning.tooltip",
                "Click to copy code with warnings and errors.\nShift-click to attempt to fix warnings."
        );

        public static final LocalizationEntry MANAGER_GUI_WARNING_BUTTON_TOOLTIP_READ_ONLY = new LocalizationEntry(
                "gui.sfm.manager.button.warning.tooltip.read_only",
                "Click to copy code with warnings and errors."
        );

        public static final LocalizationEntry MANAGER_GUI_STATUS_LOADED_CLIPBOARD = new LocalizationEntry(
                "gui.sfm.manager.status.loaded_clipboard",
                "Loaded from clipboard!"
        );
        public static final LocalizationEntry MANAGER_GUI_STATUS_SAVED_CLIPBOARD = new LocalizationEntry(
                "gui.sfm.manager.status.saved_clipboard",
                "Saved to clipboard!"
        );
        public static final LocalizationEntry MANAGER_GUI_STATUS_RESET = new LocalizationEntry(
                "gui.sfm.manager.status.reset",
                "Reset program and labels!"
        );
        public static final LocalizationEntry MANAGER_GUI_STATUS_FIX = new LocalizationEntry(
                "gui.sfm.manager.status.fix",
                "Cleaning up labels!"
        );

        public static final LocalizationEntry GUI_ADVANCED_TOOLTIP_HINT = new LocalizationEntry(
                "gui.sfm.advanced.tooltip.hint",
                ChatFormatting.GRAY + "Hold " + ChatFormatting.AQUA + "%s" + ChatFormatting.GRAY + " for more info"
        );

        public static final LocalizationEntry MORE_HOVER_INFO_KEY = new LocalizationEntry(
                "key.sfm.more_info",
                "Show More Item Hover Info"
        );

        public static final LocalizationEntry CONTAINER_INSPECTOR_TOGGLE_KEY = new LocalizationEntry(
                "key.sfm.container_inspector.activation_key",
                "Toggle Container Inspector"
        );

        public static final LocalizationEntry SFM_KEY_CATEGORY = new LocalizationEntry(
                "key.categories.sfm",
                "Super Factory Manager"
        );

        public static List<LocalizationEntry> getEntries() {
            // use reflection to get all the public static LocalizationEntry fields
            var rtn = new ArrayList<LocalizationEntry>();
            for (var field : Constants.LocalizationKeys.class.getFields()) {
                if (field.getType() == LocalizationEntry.class) {
                    try {
                        rtn.add((LocalizationEntry) field.get(null));
                    } catch (IllegalAccessException e) {
                        SFM.LOGGER.error("Failed reading entry field", e);
                    }
                }
            }
            return rtn;
        }

        public record LocalizationEntry(
                Supplier<String> key,
                Supplier<String> value
        ) {
            public LocalizationEntry(String key, String value) {
                this(() -> key, () -> value);
            }

            public TranslatableContents get(Object... args) {
                return SFMUtils.getTranslatableContents(key.get(), args);
            }

            public TranslatableContents get() {
                return SFMUtils.getTranslatableContents(key.get());
            }

            public String getString() {
                return I18n.get(key.get());
            }

            public String getString(Object... args) {
                return I18n.get(key.get(), args);
            }

            public MutableComponent getComponent() {
                return Component.translatable(key.get());
            }

            public MutableComponent getComponent(Object... args) {
                return Component.translatable(key.get(), args);
            }
        }
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfml\ast\TimerTrigger.java

````java
package ca.teamdman.sfml.ast;

import ca.teamdman.sfm.common.program.ProgramContext;

import java.util.List;

public record TimerTrigger(
        Interval interval,
        Block block
) implements Trigger {
    @Override
    public Block getBlock() {
        return block;
    }

    @Override
    public boolean shouldTick(ProgramContext context) {
        if (context.getExecutionPolicy() == ProgramContext.ExecutionPolicy.EXPLORE_BRANCHES) return true;
        return context.getManager().getTick() % interval.getTicks() == 0;
    }

    @Override
    public void tick(ProgramContext context) {
        block.tick(context);
    }

    @Override
    public List<Statement> getStatements() {
        return List.of(block);
    }

    @Override
    public String toString() {
        String rtn = "EVERY " + interval + " DO\n"
                     + block.toString().indent(1).stripTrailing()
                     + "\nEND";
        return rtn;
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\recipe\PrintingPressRecipe.java

````java
package ca.teamdman.sfm.common.recipe;

import ca.teamdman.sfm.common.blockentity.PrintingPressBlockEntity;
import ca.teamdman.sfm.common.item.FormItem;
import ca.teamdman.sfm.common.registry.SFMRecipeSerializers;
import ca.teamdman.sfm.common.registry.SFMRecipeTypes;
import com.google.gson.JsonObject;
import net.minecraft.network.FriendlyByteBuf;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.world.item.ItemStack;
import net.minecraft.world.item.crafting.Ingredient;
import net.minecraft.world.item.crafting.Recipe;
import net.minecraft.world.item.crafting.RecipeSerializer;
import net.minecraft.world.item.crafting.RecipeType;
import net.minecraft.world.level.Level;
import org.jetbrains.annotations.Nullable;

import java.util.Objects;

/**
 * Printing press copies a form using ink and paper.
 */
public class PrintingPressRecipe implements Recipe<PrintingPressBlockEntity> {
    public final ResourceLocation ID;
    public final Ingredient FORM;
    public final Ingredient INK;
    public final Ingredient PAPER;

    /**
     *
     */
    public PrintingPressRecipe(
            ResourceLocation id,
            Ingredient form,
            Ingredient ink,
            Ingredient paper
    ) {
        this.ID = id;
        this.FORM = form;
        this.INK = ink;
        this.PAPER = paper;
    }

    @Override
    public boolean matches(PrintingPressBlockEntity pContainer, Level pLevel) {
        return PAPER.test(pContainer.getPaper()) && INK.test(pContainer.getInk()) && FORM.test(FormItem.getReference(
                pContainer.getForm()));
    }

    @Override
    public ItemStack assemble(PrintingPressBlockEntity pContainer) {
        ItemStack rtn = FormItem.getReference(pContainer.getForm());
        rtn.setCount(pContainer.getPaper().getCount());
        return rtn;
    }

    @Override
    public boolean canCraftInDimensions(int pWidth, int pHeight) {
        return true;
    }

    @Override
    public ItemStack getResultItem() {
        return ItemStack.EMPTY;
    }

    @Override
    public ResourceLocation getId() {
        return ID;
    }

    @Override
    public RecipeSerializer<?> getSerializer() {
        return SFMRecipeSerializers.PRINTING_PRESS.get();
    }

    @Override
    public RecipeType<?> getType() {
        return SFMRecipeTypes.PRINTING_PRESS.get();
    }

    @Override
    public boolean equals(Object obj) {
        if (obj == this) return true;
        if (obj == null || obj.getClass() != this.getClass()) return false;
        var that = (PrintingPressRecipe) obj;
        return Objects.equals(this.ID, that.ID) &&
               Objects.equals(this.FORM, that.FORM) &&
               Objects.equals(this.INK, that.INK) &&
               Objects.equals(this.PAPER, that.PAPER);
    }

    @Override
    public int hashCode() {
        return Objects.hash(ID, FORM, INK, PAPER);
    }

    @Override
    public String toString() {
        return "PrintingPressRecipe[" +
               "id=" + ID + ", " +
               "form=" + FORM + ", " +
               "ink=" + INK + ", " +
               "paper=" + PAPER + ']';
    }

    public static class Serializer implements RecipeSerializer<PrintingPressRecipe> {
        @Override
        public PrintingPressRecipe fromJson(ResourceLocation pRecipeId, JsonObject pSerializedRecipe) {
            Ingredient form = Ingredient.fromJson(pSerializedRecipe.get("form"));
            Ingredient ink = Ingredient.fromJson(pSerializedRecipe.get("ink"));
            Ingredient paper = Ingredient.fromJson(pSerializedRecipe.get("paper"));
            return new PrintingPressRecipe(pRecipeId, form, ink, paper);
        }

        @Override
        public @Nullable PrintingPressRecipe fromNetwork(ResourceLocation pRecipeId, FriendlyByteBuf pBuffer) {
            Ingredient form = Ingredient.fromNetwork(pBuffer);
            Ingredient ink = Ingredient.fromNetwork(pBuffer);
            Ingredient paper = Ingredient.fromNetwork(pBuffer);
            return new PrintingPressRecipe(pRecipeId, form, ink, paper);
        }

        @Override
        public void toNetwork(FriendlyByteBuf pBuffer, PrintingPressRecipe pRecipe) {
            pRecipe.FORM.toNetwork(pBuffer);
            pRecipe.INK.toNetwork(pBuffer);
            pRecipe.PAPER.toNetwork(pBuffer);
        }
    }

}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\package-info.java

````java


@ParametersAreNonnullByDefault
@MethodsReturnNonnullByDefault
@FieldsAreNonnullByDefault
package ca.teamdman.sfm;

import net.minecraft.FieldsAreNonnullByDefault;
import net.minecraft.MethodsReturnNonnullByDefault;

import javax.annotation.ParametersAreNonnullByDefault;
````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\util\SFMUtils.java

````java
package ca.teamdman.sfm.common.util;

import ca.teamdman.sfm.SFM;
import ca.teamdman.sfm.common.capabilityprovidermapper.CapabilityProviderMapper;
import ca.teamdman.sfm.common.program.LimitedInputSlot;
import ca.teamdman.sfm.common.registry.SFMCapabilityProviderMappers;
import ca.teamdman.sfm.common.registry.SFMResourceTypes;
import ca.teamdman.sfm.common.resourcetype.ResourceType;
import ca.teamdman.sfml.ast.Number;
import ca.teamdman.sfml.ast.*;
import net.minecraft.core.BlockPos;
import net.minecraft.core.Direction;
import net.minecraft.nbt.CompoundTag;
import net.minecraft.nbt.ListTag;
import net.minecraft.nbt.StringTag;
import net.minecraft.nbt.Tag;
import net.minecraft.network.chat.contents.TranslatableContents;
import net.minecraft.resources.ResourceKey;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.world.level.LevelAccessor;
import net.minecraftforge.common.capabilities.CapabilityProvider;
import net.minecraftforge.common.capabilities.ICapabilityProvider;

import javax.annotation.Nullable;
import java.util.*;
import java.util.function.Consumer;
import java.util.stream.Stream;

public class SFMUtils {

    /**
     * Gets a stream using a self-feeding mapping function. Prevents the
     * re-traversal of elements that have been visited before.
     *
     * @param operator Consumes queue elements to build the result set and
     *                 append the next queue elements
     * @param first    Initial value, not checked against the filter
     * @param <T>      Type that the mapper consumes and produces
     * @return Stream result after termination of the recursive mapping process
     */
    public static <T> Stream<T> getRecursiveStream(
            RecursiveBuilder<T> operator, T first
    ) {
        Stream.Builder<T> builder = Stream.builder();
        Set<T> debounce = new HashSet<>();
        Deque<T> toVisit = new ArrayDeque<>();
        toVisit.add(first);
        debounce.add(first);
        while (!toVisit.isEmpty()) {
            T current = toVisit.pop();
            operator.accept(current, next -> {
                if (!debounce.contains(next)) {
                    debounce.add(next);
                    toVisit.add(next);
                }
            }, builder::add);
        }
        return builder.build();
    }

    public static TranslatableContents deserializeTranslation(CompoundTag tag) {
        var key = tag.getString("key");
        var args = tag
                .getList("args", Tag.TAG_STRING)
                .stream()
                .map(StringTag.class::cast)
                .map(StringTag::getAsString)
                .toArray();
        return getTranslatableContents(key, args);
    }

    public static CompoundTag serializeTranslation(TranslatableContents contents) {
        CompoundTag tag = new CompoundTag();
        tag.putString("key", contents.getKey());
        ListTag args = new ListTag();
        for (var arg : contents.getArgs()) {
            args.add(StringTag.valueOf(arg.toString()));
        }
        tag.put("args", args);
        return tag;
    }

    /**
     * Helper method to avoid noisy git merges between versions
     */
    public static TranslatableContents getTranslatableContents(String key, Object... args) {
        return new TranslatableContents(key, args);
    }

    /**
     * Helper method to avoid noisy git merges between versions
     */
    public static TranslatableContents getTranslatableContents(String key) {
        return getTranslatableContents(key, new Object[]{});
    }

    public interface RecursiveBuilder<T> {

        void accept(T current, Consumer<T> next, Consumer<T> results);
    }

    public static <STACK, ITEM, CAP> Optional<InputStatement> getInputStatementForSlot(
            LimitedInputSlot<STACK, ITEM, CAP> slot,
            LabelAccess labelAccess
    ) {
        STACK potential = slot.peekExtractPotential();
        if (slot.type.isEmpty(potential)) return Optional.empty();
        long toMove = slot.type.getAmount(potential);
        toMove = Long.min(toMove, slot.tracker.getResourceLimit().limit().quantity().number().value());
        long remainingObligation = slot.tracker.getRemainingRetentionObligation();
        toMove -= Long.min(toMove, remainingObligation);
        potential = slot.type.withCount(potential, toMove);
        STACK stack = potential;

        return SFMResourceTypes.DEFERRED_TYPES
                .get()
                .getResourceKey(slot.type)
                .map(x -> {
                    //noinspection unchecked,rawtypes
                    return (ResourceKey<ResourceType<STACK, ITEM, CAP>>) (ResourceKey) x;
                })
                .map((ResourceKey<ResourceType<STACK, ITEM, CAP>> resourceTypeResourceKey) -> SFMUtils.getInputStatementForStack(
                        resourceTypeResourceKey,
                        slot.type,
                        stack,
                        "temp",
                        slot.slot,
                        false,
                        null
                ))
                // update the labels
                .map(inputStatement -> new InputStatement(new LabelAccess(
                        labelAccess.labels(),
                        labelAccess.directions(),
                        inputStatement.labelAccess()
                                .slots(),
                        RoundRobin.disabled()
                ), inputStatement.resourceLimits(), inputStatement.each()));
    }


    public static <STACK, ITEM, CAP> InputStatement getInputStatementForStack(
            ResourceKey<ResourceType<STACK, ITEM, CAP>> resourceTypeResourceKey,
            ResourceType<STACK, ITEM, CAP> resourceType,
            STACK stack,
            String label,
            int slot,
            boolean each,
            @Nullable Direction direction
    ) {
        LabelAccess labelAccess = new LabelAccess(
                List.of(new Label(label)),
                new DirectionQualifier(
                        direction == null
                        ? EnumSet.noneOf(Direction.class)
                        : EnumSet.of(direction)),
                new NumberRangeSet(
                        new NumberRange[]{new NumberRange(slot, slot)}
                ),
                RoundRobin.disabled()
        );
        Limit limit = new Limit(
                new ResourceQuantity(
                        new Number(resourceType.getAmount(stack)),
                        ResourceQuantity.IdExpansionBehaviour.NO_EXPAND
                ),
                new ResourceQuantity(
                        new Number(0),
                        ResourceQuantity.IdExpansionBehaviour.NO_EXPAND
                )
        );
        ResourceLocation stackId = resourceType.getRegistryKey(stack);
        ResourceIdentifier<STACK, ITEM, CAP> resourceIdentifier = new ResourceIdentifier<>(
                resourceTypeResourceKey.location().getNamespace(),
                resourceTypeResourceKey.location().getPath(),
                stackId.getNamespace(),
                stackId.getPath()
        );
        ResourceLimit<STACK, ITEM, CAP> resourceLimit = new ResourceLimit<>(
                resourceIdentifier, limit
        );
        ResourceLimits resourceLimits = new ResourceLimits(
                List.of(resourceLimit),
                ResourceIdSet.EMPTY
        );
        return new InputStatement(
                labelAccess,
                resourceLimits,
                each
        );
    }

    public static String truncate(String input, int maxLength) {
        if (input.length() > maxLength) {
            SFM.LOGGER.warn(
                    "input too big, truncation has occurred! (len={}, max={}, over={})",
                    input.length(),
                    maxLength,
                    maxLength - input.length()
            );
            String truncationWarning = "\n...truncated";
            return input.substring(0, maxLength - truncationWarning.length()) + truncationWarning;
        }
        return input;
    }

    /**
     * Find a {@link CapabilityProvider} as provided by the registered capability provider mappers.
     * If multiple {@link CapabilityProviderMapper}s match, the first one is returned.
     */
    @SuppressWarnings("UnstableApiUsage") // for the javadoc lol
    public static Optional<ICapabilityProvider> discoverCapabilityProvider(LevelAccessor level, BlockPos pos) {
        return SFMCapabilityProviderMappers.DEFERRED_MAPPERS
                .get()
                .getValues()
                .stream()
                .map(mapper -> mapper.getProviderFor(level, pos))
                .filter(Optional::isPresent)
                .map(Optional::get)
                .findFirst();
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\registry\SFMCapabilityProviderMappers.java

````java
package ca.teamdman.sfm.common.registry;

import ca.teamdman.sfm.SFM;
import ca.teamdman.sfm.common.capabilityprovidermapper.BlockEntityCapabilityProviderMapper;
import ca.teamdman.sfm.common.capabilityprovidermapper.CapabilityProviderMapper;
import ca.teamdman.sfm.common.capabilityprovidermapper.CauldronCapabilityProviderMapper;
import net.minecraft.resources.ResourceLocation;
import net.minecraftforge.eventbus.api.IEventBus;
import net.minecraftforge.registries.DeferredRegister;
import net.minecraftforge.registries.IForgeRegistry;
import net.minecraftforge.registries.RegistryBuilder;
import net.minecraftforge.registries.RegistryObject;

import java.util.function.Supplier;

public class SFMCapabilityProviderMappers {
    public static final  ResourceLocation                                   REGISTRY_ID      = new ResourceLocation(
            SFM.MOD_ID,
            "capability_provider_mappers"
    );
    private static final DeferredRegister<CapabilityProviderMapper>         MAPPERS          = DeferredRegister.create(
            REGISTRY_ID,
            SFM.MOD_ID
    );
    public static final  Supplier<IForgeRegistry<CapabilityProviderMapper>> DEFERRED_MAPPERS = MAPPERS.makeRegistry(() -> new RegistryBuilder<CapabilityProviderMapper>().setName(
            REGISTRY_ID));

    public static final RegistryObject<BlockEntityCapabilityProviderMapper> BLOCK_ENTITY_MAPPER = MAPPERS.register(
            "block_entity",
            BlockEntityCapabilityProviderMapper::new
    );

    public static final RegistryObject<CauldronCapabilityProviderMapper> CAULDRON_MAPPER = MAPPERS.register(
            "cauldron",
            CauldronCapabilityProviderMapper::new
    );

    public static void register(IEventBus bus) {
        MAPPERS.register(bus);
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\client\handler\package-info.java

````java
@ParametersAreNonnullByDefault
@MethodsReturnNonnullByDefault
@FieldsAreNonnullByDefault
package ca.teamdman.sfm.client.handler;

import net.minecraft.FieldsAreNonnullByDefault;
import net.minecraft.MethodsReturnNonnullByDefault;

import javax.annotation.ParametersAreNonnullByDefault;
````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\block\WaterTankBlock.java

````java
package ca.teamdman.sfm.common.block;

import ca.teamdman.sfm.common.Constants;
import ca.teamdman.sfm.common.blockentity.WaterTankBlockEntity;
import ca.teamdman.sfm.common.registry.SFMBlockEntities;
import ca.teamdman.sfm.common.util.SFMUtils;
import net.minecraft.ChatFormatting;
import net.minecraft.core.BlockPos;
import net.minecraft.core.Direction;
import net.minecraft.network.chat.Component;
import net.minecraft.sounds.SoundEvent;
import net.minecraft.tags.FluidTags;
import net.minecraft.world.item.ItemStack;
import net.minecraft.world.item.TooltipFlag;
import net.minecraft.world.item.context.BlockPlaceContext;
import net.minecraft.world.level.BlockGetter;
import net.minecraft.world.level.Level;
import net.minecraft.world.level.LevelAccessor;
import net.minecraft.world.level.block.*;
import net.minecraft.world.level.block.entity.BlockEntity;
import net.minecraft.world.level.block.state.BlockBehaviour;
import net.minecraft.world.level.block.state.BlockState;
import net.minecraft.world.level.block.state.StateDefinition;
import net.minecraft.world.level.block.state.properties.BooleanProperty;
import net.minecraft.world.level.material.Fluid;
import net.minecraft.world.level.material.FluidState;
import net.minecraft.world.level.material.Fluids;
import net.minecraft.world.level.material.Material;
import org.jetbrains.annotations.Nullable;

import java.util.List;
import java.util.Optional;

@SuppressWarnings("deprecation")

public class WaterTankBlock extends BaseEntityBlock implements EntityBlock, BucketPickup, LiquidBlockContainer {
    public static final BooleanProperty      IN_WATER = BooleanProperty.create("in_water");


    public WaterTankBlock() {
        super(BlockBehaviour.Properties.of(Material.PISTON).destroyTime(2).sound(SoundType.WOOD));
        registerDefaultState(getStateDefinition().any().setValue(IN_WATER, false));
    }


    @Override
    @SuppressWarnings("deprecation")
    public void onPlace(BlockState pState, Level pLevel, BlockPos pPos, BlockState pOldState, boolean pIsMoving) {
        super.onPlace(pState, pLevel, pPos, pOldState, pIsMoving);
        for (Direction direction : Direction.values()) {
            recount(pLevel, pPos.offset(direction.getNormal()));
        }
    }

    @Override
    @SuppressWarnings("deprecation")
    public void onRemove(BlockState pState, Level pLevel, BlockPos pPos, BlockState pNewState, boolean pIsMoving) {
        super.onRemove(pState, pLevel, pPos, pNewState, pIsMoving);
        for (Direction direction : Direction.values()) {
            recount(pLevel, pPos.offset(direction.getNormal()));
        }
    }

    @Override
    public void appendHoverText(
            ItemStack pStack,
            @Nullable BlockGetter pLevel,
            List<Component> pTooltip,
            TooltipFlag pFlag
    ) {
        pTooltip.add(Constants.LocalizationKeys.WATER_TANK_ITEM_TOOLTIP_1
                             .getComponent()
                             .withStyle(ChatFormatting.GRAY));
        pTooltip.add(Constants.LocalizationKeys.WATER_TANK_ITEM_TOOLTIP_2
                             .getComponent()
                             .withStyle(ChatFormatting.GRAY));
    }

    public void recount(Level level, BlockPos pos) {
        if (!(level.getBlockEntity(pos) instanceof WaterTankBlockEntity be)) return;
        var tanks = SFMUtils.getRecursiveStream((current, next, results) -> {
            results.accept(current);
            for (var d : Direction.values()) {
                var offset = current.getBlockPos().offset(d.getNormal());
                if (!(level.getBlockEntity(offset) instanceof WaterTankBlockEntity blockEntity)) continue;
                next.accept(blockEntity);
            }
        }, be).toList();
        tanks.forEach(t -> t.setConnectedCount(tanks.size()));
    }

    @Override
    public RenderShape getRenderShape(BlockState state) {
        return RenderShape.MODEL;
    }

    @Override
    protected void createBlockStateDefinition(StateDefinition.Builder<Block, BlockState> builder) {
        builder.add(IN_WATER);
    }

    @Nullable
    @Override
    public BlockEntity newBlockEntity(BlockPos pos, BlockState state) {
        return SFMBlockEntities.WATER_TANK_BLOCK_ENTITY.get().create(pos, state);
    }

    @Nullable
    @Override
    public BlockState getStateForPlacement(BlockPlaceContext context) {
        return defaultBlockState().setValue(
                IN_WATER,
                isActive(context.getLevel(), context.getClickedPos())
        );
    }

    public boolean isActive(LevelAccessor level, BlockPos pos) {
        int neighbourWaterCount = 0;
        for (Direction direction : Direction.values()) {
            FluidState state = level.getFluidState(pos.relative(direction));
            if (state.isSource() && state.is(FluidTags.WATER)) {
                if (++neighbourWaterCount == 2) {
                    return true;
                }
            }
        }
        return false;
    }

    @Override
    @SuppressWarnings("deprecation")
    public void neighborChanged(
            BlockState state,
            Level level,
            BlockPos pos,
            Block blockIn,
            BlockPos fromPos,
            boolean isMoving
    ) {
        if (level.isClientSide) return;
        boolean isActive = isActive(level, pos);
        if (state.getValue(IN_WATER) != isActive) {
            BlockState newState = defaultBlockState().setValue(IN_WATER, isActive);
            level.setBlock(
                    pos,
                    newState,
                    1 | 2
            );
        }
    }

    @Override
    public ItemStack pickupBlock(LevelAccessor level, BlockPos pos, BlockState state) {
        return state.getValue(IN_WATER) ? new ItemStack(Fluids.WATER.getBucket()) : ItemStack.EMPTY;
    }

    @Override
    public Optional<SoundEvent> getPickupSound() {
        return Fluids.WATER.getPickupSound();
    }

    @Override
    public boolean canPlaceLiquid(BlockGetter level, BlockPos pos, BlockState state, Fluid fluid) {
        return fluid.isSame(Fluids.WATER);
    }

    @Override
    public boolean placeLiquid(LevelAccessor level, BlockPos pos, BlockState state, FluidState fluid) {
        return fluid.getType().isSame(Fluids.WATER);
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\handler\package-info.java

````java


@ParametersAreNonnullByDefault
@MethodsReturnNonnullByDefault
@FieldsAreNonnullByDefault
package ca.teamdman.sfm.common.handler;

import net.minecraft.FieldsAreNonnullByDefault;
import net.minecraft.MethodsReturnNonnullByDefault;

import javax.annotation.ParametersAreNonnullByDefault;
````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\program\InputResourceTracker.java

````java
package ca.teamdman.sfm.common.program;

import ca.teamdman.sfm.common.resourcetype.ResourceType;
import ca.teamdman.sfml.ast.ResourceIdSet;
import ca.teamdman.sfml.ast.ResourceLimit;
import it.unimi.dsi.fastutil.ints.Int2LongArrayMap;

import java.util.concurrent.atomic.AtomicLong;
import java.util.function.Predicate;

public class InputResourceTracker<STACK, ITEM, CAP> implements Predicate<Object> {

    private final ResourceLimit<STACK, ITEM, CAP> RESOURCE_LIMIT;
    private final ResourceIdSet EXCLUSIONS;
    private final Int2LongArrayMap RETENTION_OBLIGATIONS = new Int2LongArrayMap();
    private final AtomicLong TRANSFERRED;
    private final AtomicLong RETENTION_OBLIGATION_PROGRESS;

    public InputResourceTracker(
            ResourceLimit<STACK, ITEM, CAP> limit,
            ResourceIdSet exclusions,
            AtomicLong transferred,
            AtomicLong retentionObligationProgress
    ) {
        this.RESOURCE_LIMIT = limit;
        this.EXCLUSIONS = exclusions;
        this.TRANSFERRED = transferred;
        this.RETENTION_OBLIGATION_PROGRESS = retentionObligationProgress;
    }

    public boolean isDone() {
        return TRANSFERRED.get() >= RESOURCE_LIMIT.limit().quantity().number().value();
    }

    public long getExistingRetentionObligation(int slot) {
        return RETENTION_OBLIGATIONS.getOrDefault(slot, 0);
    }

    public long getRemainingRetentionObligation() {
        return RESOURCE_LIMIT.limit().retention().number().value() - RETENTION_OBLIGATION_PROGRESS.get();
    }

    public void trackRetentionObligation(int slot, long promise) {
        this.RETENTION_OBLIGATION_PROGRESS.accumulateAndGet(promise, Long::sum);
        this.RETENTION_OBLIGATIONS.merge(slot, promise, Long::sum);
    }

    public ResourceLimit<STACK, ITEM, CAP> getResourceLimit() {
        return RESOURCE_LIMIT;
    }

    public long getMaxTransferable() {
        return RESOURCE_LIMIT.limit().quantity().number().value() - TRANSFERRED.get();
    }

    public void trackTransfer(long amount) {
        TRANSFERRED.accumulateAndGet(amount, Long::sum);
    }

    @Override
    public boolean test(Object stack) {
        return RESOURCE_LIMIT.test(stack) && !EXCLUSIONS.test(stack);
    }

    public boolean matchesCapabilityType(Object capability) {
        ResourceType<STACK, ITEM, CAP> resourceType = RESOURCE_LIMIT.resourceId().getResourceType();
        return resourceType != null && resourceType.matchesCapabilityType(capability);
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\program\LimitedOutputSlotObjectPool.java

````java
package ca.teamdman.sfm.common.program;

import java.util.Arrays;
import java.util.List;

/**
 * A pool of {@link LimitedOutputSlot} objects to avoid the garbage collector
 * <p>
 * This assumes that the pool will be used in a single thread.
 */
public class LimitedOutputSlotObjectPool {
    public static final LimitedOutputSlotObjectPool INSTANCE = new LimitedOutputSlotObjectPool();
    @SuppressWarnings("rawtypes")
    private LimitedOutputSlot[] pool = new LimitedOutputSlot[1];
    private int index = -1;

    /**
     * Acquire a {@link LimitedOutputSlot} from the pool, or creates a new one if none available
     */
    public <STACK, ITEM, CAP> LimitedOutputSlot<STACK, ITEM, CAP> acquire(
            CAP handler,
            int slot,
            OutputResourceTracker<STACK, ITEM, CAP> tracker
    ) {
        if (index == -1) {
            return new LimitedOutputSlot<>(handler, slot, tracker);
        } else {
            @SuppressWarnings("unchecked") LimitedOutputSlot<STACK, ITEM, CAP> obj = pool[index];
            index--;
            obj.init(handler, slot, tracker);
            return obj;
        }
    }

    /**
     * Release a {@link LimitedOutputSlot} back into the pool for it to be reused instead of garbage collected
     */
    public void release(LimitedOutputSlot<?, ?, ?> obj) {
        if (index == pool.length - 1) {
            // we need to grow the array
            pool = Arrays.copyOf(pool, pool.length * 2);
        }
        pool[++index] = obj;
    }

    /**
     * Release a {@link LimitedOutputSlot} back into the pool for it to be reused instead of garbage collected
     */
    @SuppressWarnings("rawtypes")
    public void release(List<LimitedOutputSlot> slots) {
        // handle resizing
        if (index + slots.size() >= pool.length) {
            int slotsFree = pool.length - index - 1;
            int newLength = pool.length + slots.size() - slotsFree;
            pool = Arrays.copyOf(pool, newLength);
        }
        // add to pool
        for (LimitedOutputSlot<?, ?, ?> slot : slots) {
            index++;
            pool[index] = slot;
        }
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfml\ast\Label.java

````java
package ca.teamdman.sfml.ast;

public record Label(String name) implements ASTNode {
    @Override
    public String toString() {
        return name;
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfml\ast\ASTNode.java

````java
package ca.teamdman.sfml.ast;

import java.util.List;

public interface ASTNode {
    default List<Statement> getStatements() {
        return List.of();
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfml\ast\ResourceComparer.java

````java
package ca.teamdman.sfml.ast;

import ca.teamdman.sfm.common.resourcetype.ResourceType;

import java.util.ArrayList;
import java.util.List;

public record ResourceComparer<STACK, ITEM, CAP>(
        ComparisonOperator op,
        ResourceQuantity quantity,
        ResourceIdentifier<STACK, ITEM, CAP> res
) implements ASTNode {
    public BoolExpr toBooleanExpression(SetOperator setOp, LabelAccess labelAccess, String sourceCode) {
        return new BoolExpr(
                context -> {
                    ResourceType<STACK, ITEM, CAP> type = res.getResourceType();
                    if (type == null) return false;
                    // get the inventories to check

                    var handlers = type.getCapabilities(context, labelAccess);

                    // track how many items seen
                    long overallCount = 0;
                    // track how many inventories satisfied the condition
                    List<Boolean> satisfiedSet = new ArrayList<>();

                    for (var cap : (Iterable<CAP>) handlers::iterator) {
                        long invCount = 0;
                        for (var stack : (Iterable<STACK>) type.collect(cap, labelAccess)::iterator) {
                            if (this.res.test(stack)) {
                                invCount += type.getAmount(stack);
                                overallCount += type.getAmount(stack);
                            }
                        }
                        satisfiedSet.add(this.op.test(invCount, this.quantity.number().value()));
                    }
                    var isOverallSatisfied = this.op.test(overallCount, this.quantity.number().value());
                    return setOp.test(isOverallSatisfied, satisfiedSet);
                },
                labelAccess + " HAS " + sourceCode
        );
    }

    @Override
    public String toString() {
        return op().getSourceCode() + " " + quantity() + " " + res().toStringCondensed();
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\net\ClientboundLabelInspectionResultsPacket.java

````java
package ca.teamdman.sfm.common.net;

import ca.teamdman.sfm.client.ClientStuff;
import net.minecraft.network.FriendlyByteBuf;
import net.minecraftforge.network.NetworkEvent;

import java.util.function.Supplier;

public record ClientboundLabelInspectionResultsPacket(
        String results
) {
    public static final int MAX_RESULTS_LENGTH = 50_000;

    public static void encode(
            ClientboundLabelInspectionResultsPacket msg, FriendlyByteBuf friendlyByteBuf
    ) {
        friendlyByteBuf.writeUtf(msg.results(), MAX_RESULTS_LENGTH);
    }

    public static ClientboundLabelInspectionResultsPacket decode(FriendlyByteBuf friendlyByteBuf) {
        return new ClientboundLabelInspectionResultsPacket(
                friendlyByteBuf.readUtf(MAX_RESULTS_LENGTH)
        );
    }

    public static void handle(
            ClientboundLabelInspectionResultsPacket msg, Supplier<NetworkEvent.Context> contextSupplier
    ) {
        contextSupplier.get().enqueueWork(() -> ClientStuff.showProgramEditScreen(msg.results, next -> {
        }));
        contextSupplier.get().setPacketHandled(true);
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\net\ServerboundLabelInspectionRequestPacket.java

````java
package ca.teamdman.sfm.common.net;

import ca.teamdman.sfm.SFM;
import ca.teamdman.sfm.common.containermenu.ManagerContainerMenu;
import ca.teamdman.sfm.common.program.LabelPositionHolder;
import ca.teamdman.sfm.common.registry.SFMItems;
import ca.teamdman.sfm.common.registry.SFMPackets;
import ca.teamdman.sfml.ast.Program;
import net.minecraft.core.BlockPos;
import net.minecraft.network.FriendlyByteBuf;
import net.minecraft.server.level.ServerPlayer;
import net.minecraftforge.network.NetworkEvent;
import net.minecraftforge.network.PacketDistributor;

import java.util.Set;
import java.util.function.Supplier;

public record ServerboundLabelInspectionRequestPacket(
        String label
) {
    public static void encode(ServerboundLabelInspectionRequestPacket msg, FriendlyByteBuf friendlyByteBuf) {
        friendlyByteBuf.writeUtf(msg.label(), Program.MAX_LABEL_LENGTH);
    }

    public static ServerboundLabelInspectionRequestPacket decode(FriendlyByteBuf friendlyByteBuf) {
        return new ServerboundLabelInspectionRequestPacket(
                friendlyByteBuf.readUtf(Program.MAX_LABEL_LENGTH)
        );
    }

    public static void handle(
            ServerboundLabelInspectionRequestPacket msg,
            Supplier<NetworkEvent.Context> contextSupplier
    ) {
        contextSupplier.get().enqueueWork(() -> {
            // we don't know if the player has the program edit screen open from a manager or a disk in hand
            ServerPlayer player = contextSupplier.get().getSender();
            if (player == null) return;
            SFM.LOGGER.info("Received label inspection request packet from player " + player.getStringUUID());
            LabelPositionHolder labelPositionHolder;
            if (player.containerMenu instanceof ManagerContainerMenu mcm) {
                SFM.LOGGER.info("Player is using a manager container menu - will append additional info to payload");
                labelPositionHolder = LabelPositionHolder.from(mcm.CONTAINER.getItem(0));
            } else {
                if (player.getMainHandItem().is(SFMItems.DISK_ITEM.get())) {
                    labelPositionHolder = LabelPositionHolder.from(player.getMainHandItem());
                } else if (player.getOffhandItem().is(SFMItems.DISK_ITEM.get())) {
                    labelPositionHolder = LabelPositionHolder.from(player.getOffhandItem());
                } else {
                    labelPositionHolder = null;
                }
            }
            if (labelPositionHolder == null) {
                SFM.LOGGER.info("Label holder wasn't found - aborting");
                return;
            }
            SFM.LOGGER.info("building payload");
            StringBuilder payload = new StringBuilder();
            payload.append("-- Positions for label \"").append(msg.label()).append("\" --\n");
            payload.append(labelPositionHolder.getPositions(msg.label()).size()).append(" assignments\n");
            payload.append("-- Summary --\n");
            labelPositionHolder.get().getOrDefault(msg.label(), Set.of()).forEach(pos -> {
                payload
                        .append(pos.getX())
                        .append(",")
                        .append(pos.getY())
                        .append(",")
                        .append(pos.getZ());
                if (player.getLevel().isLoaded(pos)) {
                    payload
                            .append(" -- ")
                            .append(player.getLevel().getBlockState(pos).getBlock().getName().getString());
                } else {
                    payload
                            .append(" -- chunk not loaded");
                }
                payload
                        .append("\n");
            });

            payload.append("\n\n\n-- Detailed --\n");
            for (BlockPos pos : labelPositionHolder.get().getOrDefault(msg.label(), Set.of())) {
                if (payload.length() > 20_000) {
                    payload.append("... (truncated)");
                    break;
                }
                payload
                        .append(pos.getX())
                        .append(",")
                        .append(pos.getY())
                        .append(",")
                        .append(pos.getZ());
                if (player.getLevel().isLoaded(pos)) {
                    payload
                            .append(" -- ")
                            .append(player.getLevel().getBlockState(pos).getBlock().getName().getString());

                    payload.append("\n").append(ServerboundContainerExportsInspectionRequestPacket
                                                        .buildInspectionResults(player.getLevel(), pos)
                                                        .indent(1));
                } else {
                    payload
                            .append(" -- chunk not loaded");
                }
                payload
                        .append("\n");
            }
            SFM.LOGGER.info("Sending payload response length="
                            + payload.length()
                            + " to player "
                            + player.getStringUUID());
            SFMPackets.INSPECTION_CHANNEL.send(
                    PacketDistributor.PLAYER.with(() -> player),
                    new ClientboundLabelInspectionResultsPacket(
                            payload.toString()
                    )
            );
        });
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\client\gui\screen\package-info.java

````java
@ParametersAreNonnullByDefault
@MethodsReturnNonnullByDefault
@FieldsAreNonnullByDefault
package ca.teamdman.sfm.client.gui.screen;

import net.minecraft.FieldsAreNonnullByDefault;
import net.minecraft.MethodsReturnNonnullByDefault;

import javax.annotation.ParametersAreNonnullByDefault;
````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\client\handler\ItemWorldRenderer.java

````java
package ca.teamdman.sfm.client.handler;

import ca.teamdman.sfm.SFM;
import ca.teamdman.sfm.common.item.LabelGunItem;
import ca.teamdman.sfm.common.item.NetworkToolItem;
import ca.teamdman.sfm.common.program.LabelPositionHolder;
import com.google.common.collect.HashMultimap;
import com.mojang.blaze3d.platform.GlStateManager;
import com.mojang.blaze3d.systems.RenderSystem;
import com.mojang.blaze3d.vertex.*;
import net.minecraft.client.Camera;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.Font;
import net.minecraft.client.renderer.GameRenderer;
import net.minecraft.client.renderer.MultiBufferSource;
import net.minecraft.client.renderer.RenderStateShard;
import net.minecraft.client.renderer.RenderType;
import net.minecraft.client.renderer.texture.TextureAtlas;
import net.minecraft.core.BlockPos;
import net.minecraft.nbt.CompoundTag;
import net.minecraft.nbt.NbtUtils;
import net.minecraft.nbt.Tag;
import net.minecraftforge.api.distmarker.Dist;
import net.minecraftforge.client.event.RenderLevelStageEvent;
import net.minecraftforge.eventbus.api.SubscribeEvent;
import net.minecraftforge.fml.common.Mod;
import org.jetbrains.annotations.Nullable;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

@Mod.EventBusSubscriber(modid = SFM.MOD_ID, bus = Mod.EventBusSubscriber.Bus.FORGE, value = Dist.CLIENT)
/*
 * This class uses code from tasgon's "observable" mod, also using MPLv2
 * https://github.com/tasgon/observable/blob/master/common/src/main/kotlin/observable/client/Overlay.kt
 */
public class ItemWorldRenderer {
    private static final int BUFFER_SIZE = 256;
    @SuppressWarnings("deprecation")
    private static final RenderType RENDER_TYPE = RenderType.create(
            "sfmlabels",
            DefaultVertexFormat.POSITION_COLOR,
            VertexFormat.Mode.QUADS,
            BUFFER_SIZE,
            false,
            false,
            RenderType.CompositeState
                    .builder()
                    .setTextureState(new RenderStateShard.TextureStateShard(TextureAtlas.LOCATION_BLOCKS, false, false))
                    .setDepthTestState(new RenderStateShard.DepthTestStateShard("always", 519))
                    .setTransparencyState(
                            new RenderStateShard.TransparencyStateShard(
                                    "src_to_one",
                                    () -> {
                                        RenderSystem.enableBlend();
                                        RenderSystem.blendFunc(
                                                GlStateManager.SourceFactor.SRC_ALPHA,
                                                GlStateManager.DestFactor.ONE
                                        );
                                    },
                                    () -> {
                                        RenderSystem.disableBlend();
                                        RenderSystem.defaultBlendFunc();
                                    }
                            )
                    )
                    .createCompositeState(true)
    );
    @Nullable
    private static VertexBuffer capabilityProviderVBO;
    @Nullable
    private static VertexBuffer cableVBO;

    @SubscribeEvent
    public static void renderLabelHighlights(RenderLevelStageEvent event) {
        if (event.getStage() != RenderLevelStageEvent.Stage.AFTER_TRANSLUCENT_BLOCKS) return;
        var player = Minecraft.getInstance().player;
        if (player == null) return;

        var labelGun = player.getMainHandItem();
        if (!(labelGun.getItem() instanceof LabelGunItem)) labelGun = player.getOffhandItem();
        if (labelGun.getItem() instanceof LabelGunItem) {
            var labels = LabelPositionHolder.from(labelGun);
            var labelPositions = HashMultimap.<BlockPos, String>create();
            labels.forEach((label, pos1) -> labelPositions.put(pos1, label));

            var poseStack = event.getPoseStack();
            var camera = Minecraft.getInstance().gameRenderer.getMainCamera();
            var bufferSource = Minecraft.getInstance().renderBuffers().bufferSource();

            RenderSystem.disableDepthTest();

            poseStack.pushPose();
            poseStack.translate(-camera.getPosition().x, -camera.getPosition().y, -camera.getPosition().z);

            { // draw labels
                for (var entry : labelPositions.asMap().entrySet()) {
                    drawLabel(poseStack, camera, entry.getKey(), bufferSource, entry.getValue());
                }
            }
            { // draw highlights
                RENDER_TYPE.setupRenderState();
                RenderSystem.disableTexture();

                if (capabilityProviderVBO == null) {
                    capabilityProviderVBO = new VertexBuffer();
                    capabilityProviderVBO.bind();
                    capabilityProviderVBO.upload(createCapabilityProviderVBO());
                } else {
                    capabilityProviderVBO.bind();
                }

                for (var pos : labelPositions.keySet()) {
                    poseStack.pushPose();
                    poseStack.translate(pos.getX(), pos.getY(), pos.getZ());

                    //noinspection DataFlowIssue
                    capabilityProviderVBO.drawWithShader(
                            poseStack.last().pose(),
                            event.getProjectionMatrix(),
                            GameRenderer.getPositionColorShader()
                    );
                    poseStack.popPose();
                }

                VertexBuffer.unbind();
                RENDER_TYPE.clearRenderState();
                RenderSystem.enableTexture();
            }
            bufferSource.endBatch();
            poseStack.popPose();
            RenderSystem.enableDepthTest();
        }

        var networkTool = player.getMainHandItem();
        if (!(networkTool.getItem() instanceof NetworkToolItem)) networkTool = player.getOffhandItem();
        if (networkTool.getItem() instanceof NetworkToolItem) {
            List<BlockPos> cablePositions = new ArrayList<>();
            List<BlockPos> capabilityProviderPositions = new ArrayList<>();
            // gather network positions from item
            networkTool.getOrCreateTag().getList("networks", Tag.TAG_COMPOUND).forEach(networkTag -> {
                ((CompoundTag) networkTag).getList("cable_positions", Tag.TAG_COMPOUND)
                        .stream()
                        .map(CompoundTag.class::cast)
                        .map(NbtUtils::readBlockPos)
                        .forEach(cablePositions::add);
                ((CompoundTag) networkTag)
                        .getList("capability_provider_positions", Tag.TAG_COMPOUND)
                        .stream()
                        .map(CompoundTag.class::cast)
                        .map(NbtUtils::readBlockPos)
                        .forEach(capabilityProviderPositions::add);
            });

            var poseStack = event.getPoseStack();
            var camera = Minecraft.getInstance().gameRenderer.getMainCamera();
            var bufferSource = Minecraft.getInstance().renderBuffers().bufferSource();

            RenderSystem.disableDepthTest();

            poseStack.pushPose();
            poseStack.translate(
                    -camera.getPosition().x,
                    -camera.getPosition().y,
                    -camera.getPosition().z
            );

            { // draw highlights
                RENDER_TYPE.setupRenderState();
                RenderSystem.disableTexture();

                if (capabilityProviderVBO == null) {
                    capabilityProviderVBO = new VertexBuffer();
                    capabilityProviderVBO.bind();
                    capabilityProviderVBO.upload(createCapabilityProviderVBO());
                } else {
                    capabilityProviderVBO.bind();
                }

                for (var blockPos : capabilityProviderPositions) {
                    poseStack.pushPose();
                    poseStack.translate(blockPos.getX(), blockPos.getY(), blockPos.getZ());

                    //noinspection DataFlowIssue
                    capabilityProviderVBO.drawWithShader(
                            poseStack.last().pose(),
                            event.getProjectionMatrix(),
                            GameRenderer.getPositionColorShader()
                    );
                    poseStack.popPose();
                }


                if (cableVBO == null) {
                    cableVBO = new VertexBuffer();
                    cableVBO.bind();
                    cableVBO.upload(createCableVBO());
                } else {
                    cableVBO.bind();
                }

                for (var blockPos : cablePositions) {
                    poseStack.pushPose();
                    poseStack.translate(blockPos.getX(), blockPos.getY(), blockPos.getZ());

                    //noinspection DataFlowIssue
                    cableVBO.drawWithShader(
                            poseStack.last().pose(),
                            event.getProjectionMatrix(),
                            GameRenderer.getPositionColorShader()
                    );
                    poseStack.popPose();
                }

                VertexBuffer.unbind();
                RENDER_TYPE.clearRenderState();
                RenderSystem.enableTexture();
            }
            bufferSource.endBatch();
            poseStack.popPose();
            RenderSystem.enableDepthTest();
        }
    }

    private static void drawLabel(
            PoseStack poseStack,
            Camera camera,
            BlockPos pos,
            MultiBufferSource mbs,
            Collection<String> labels
    ) {
        poseStack.pushPose();
        poseStack.translate(pos.getX() + 0.5, pos.getY() + 0.5, pos.getZ() + 0.5);
        poseStack.mulPose(camera.rotation());
        poseStack.scale(-0.025f, -0.025f, 0.025f);
        Font font = Minecraft.getInstance().font;
        poseStack.translate(0, labels.size() * (font.lineHeight + 0.1) / -2f, 0);
        for (var label : labels) {
            font.drawInBatch(
                    label,
                    -font.width(label) / 2f,
                    0,
                    -0x1,
                    false,
                    poseStack.last().pose(),
                    mbs,
                    true,
                    0,
                    0xF000F0
            );
            poseStack.translate(0, font.lineHeight + 0.1, 0);
        }
        poseStack.popPose();
    }

    public static BufferBuilder.RenderedBuffer createCapabilityProviderVBO() {
        return createShape(100, 0, 255, 100);
    }

    public static BufferBuilder.RenderedBuffer createCableVBO() {
        return createShape(100, 255, 0, 100);
    }

    public static BufferBuilder.RenderedBuffer createShape(int r, int g, int b, int a) {
        var builder = new BufferBuilder(4 * 6 * 8);
        builder.begin(VertexFormat.Mode.QUADS, DefaultVertexFormat.POSITION_COLOR);

        builder.vertex(0F, 1F, 0F).color(r, g, b, a).endVertex();
        builder.vertex(0F, 1F, 1F).color(r, g, b, a).endVertex();
        builder.vertex(1F, 1F, 1F).color(r, g, b, a).endVertex();
        builder.vertex(1F, 1F, 0F).color(r, g, b, a).endVertex();

        builder.vertex(0F, 1F, 0F).color(r, g, b, a).endVertex();
        builder.vertex(1F, 1F, 0F).color(r, g, b, a).endVertex();
        builder.vertex(1F, 0F, 0F).color(r, g, b, a).endVertex();
        builder.vertex(0F, 0F, 0F).color(r, g, b, a).endVertex();

        builder.vertex(1F, 1F, 1F).color(r, g, b, a).endVertex();
        builder.vertex(0F, 1F, 1F).color(r, g, b, a).endVertex();
        builder.vertex(0F, 0F, 1F).color(r, g, b, a).endVertex();
        builder.vertex(1F, 0F, 1F).color(r, g, b, a).endVertex();

        builder.vertex(0F, 1F, 1F).color(r, g, b, a).endVertex();
        builder.vertex(0F, 1F, 0F).color(r, g, b, a).endVertex();
        builder.vertex(0F, 0F, 0F).color(r, g, b, a).endVertex();
        builder.vertex(0F, 0F, 1F).color(r, g, b, a).endVertex();

        builder.vertex(1F, 0F, 1F).color(r, g, b, a).endVertex();
        builder.vertex(1F, 0F, 0F).color(r, g, b, a).endVertex();
        builder.vertex(1F, 1F, 0F).color(r, g, b, a).endVertex();
        builder.vertex(1F, 1F, 1F).color(r, g, b, a).endVertex();

        builder.vertex(1F, 0F, 0F).color(r, g, b, a).endVertex();
        builder.vertex(1F, 0F, 1F).color(r, g, b, a).endVertex();
        builder.vertex(0F, 0F, 1F).color(r, g, b, a).endVertex();
        builder.vertex(0F, 0F, 0F).color(r, g, b, a).endVertex();

        return builder.end();
    }

}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\handler\FallingAnvilHandler.java

````java
package ca.teamdman.sfm.common.handler;

import ca.teamdman.sfm.SFM;
import ca.teamdman.sfm.common.item.FormItem;
import ca.teamdman.sfm.common.recipe.PrintingPressRecipe;
import ca.teamdman.sfm.common.registry.SFMItems;
import ca.teamdman.sfm.common.registry.SFMRecipeTypes;
import net.minecraft.world.entity.Entity;
import net.minecraft.world.entity.item.FallingBlockEntity;
import net.minecraft.world.entity.item.ItemEntity;
import net.minecraft.world.item.EnchantedBookItem;
import net.minecraft.world.item.ItemStack;
import net.minecraft.world.item.Items;
import net.minecraft.world.item.enchantment.Enchantment;
import net.minecraft.world.item.enchantment.EnchantmentHelper;
import net.minecraft.world.item.enchantment.EnchantmentInstance;
import net.minecraft.world.level.Level;
import net.minecraft.world.level.block.AnvilBlock;
import net.minecraft.world.level.block.Block;
import net.minecraft.world.level.block.Blocks;
import net.minecraft.world.phys.AABB;
import net.minecraftforge.event.entity.EntityLeaveLevelEvent;
import net.minecraftforge.eventbus.api.SubscribeEvent;
import net.minecraftforge.fml.common.Mod;

import java.util.List;
import java.util.Map;

@Mod.EventBusSubscriber(modid = SFM.MOD_ID, bus = Mod.EventBusSubscriber.Bus.FORGE)
public class FallingAnvilHandler {
    @SubscribeEvent
    public static void onLeave(EntityLeaveLevelEvent event) {
        if (event.getEntity() instanceof FallingBlockEntity fbe) {
            if (fbe.getBlockState().getBlock() instanceof AnvilBlock) {
                var landPosition = fbe.blockPosition();
                Level level = event.getLevel();
                Block block = level.getBlockState(landPosition.below()).getBlock();
                if (block == Blocks.IRON_BLOCK) { // create a form
                    List<PrintingPressRecipe> recipes = level
                            .getRecipeManager()
                            .getAllRecipesFor(SFMRecipeTypes.PRINTING_PRESS.get());
                    var items = level
                            .getEntitiesOfClass(ItemEntity.class, new AABB(landPosition))
                            .stream()
                            .filter(Entity::isAlive)
                            .filter(e -> !e.getItem().isEmpty())
                            .toList();
                    boolean didForm = false;

                    for (ItemEntity item : items) {
                        for (PrintingPressRecipe recipe : recipes) {
                            // check if the item can be turned into a form
                            if (recipe.FORM.test(item.getItem())) {
                                didForm = true;
                                item.setItem(FormItem.getForm(item.getItem()));
                                break;
                            }
                        }
                    }
                    if (didForm) {
                        level.setBlockAndUpdate(landPosition.below(), Blocks.AIR.defaultBlockState());
                    }
                } else if (block == Blocks.OBSIDIAN) { // crush and disenchant items
                    List<ItemEntity> items = level
                            .getEntitiesOfClass(ItemEntity.class, new AABB(landPosition))
                            .stream()
                            .filter(Entity::isAlive)
                            .filter(e -> !e.getItem().isEmpty())
                            .toList();
                    { // crush enchanted books into xp shards
                        items
                                .stream()
                                .filter(e -> e.getItem().is(Items.ENCHANTED_BOOK))
                                .forEach(e -> e.setItem(new ItemStack(
                                        SFMItems.EXPERIENCE_SHARD_ITEM.get(),
                                        e.getItem().getCount()
                                )));
                    }
                    { // remove enchantments from items
                        List<ItemEntity> bookEntities = items.stream().filter(e -> e.getItem().is(Items.BOOK)).toList();
                        int booksAvailable = bookEntities.stream().mapToInt(e -> e.getItem().getCount()).sum();
                        List<ItemEntity> enchanted = items
                                .stream()
                                .filter(e -> !e.getItem().getEnchantmentTags().isEmpty())
                                .toList();


                        for (ItemEntity enchItemEntity : enchanted) {
                            ItemStack enchStack = enchItemEntity.getItem();
                            int enchStackSize = enchStack.getCount();
                            Map<Enchantment, Integer> enchantments = EnchantmentHelper.getEnchantments(enchStack);
                            var enchIter = enchantments.entrySet().iterator();
                            while (enchIter.hasNext()) {
                                var entry = enchIter.next();
                                if (booksAvailable < enchStackSize) break;

                                // Create an enchanted book with the enchantment
                                ItemStack toSpawn = new ItemStack(Items.ENCHANTED_BOOK, enchStackSize);
                                EnchantedBookItem.addEnchantment(
                                        toSpawn,
                                        new EnchantmentInstance(entry.getKey(), entry.getValue())
                                );
                                level.addFreshEntity(new ItemEntity(
                                        level,
                                        landPosition.getX(),
                                        landPosition.getY(),
                                        landPosition.getZ(),
                                        toSpawn
                                ));

                                // Remove the enchantment from the item
                                enchIter.remove();
                                EnchantmentHelper.setEnchantments(enchantments, enchStack);
                                booksAvailable -= enchStackSize;
                                if (enchantments.isEmpty()) {
                                    break;
                                }
                            }
                        }

                        for (ItemEntity bookEntity : bookEntities) {
                            bookEntity.kill();
                        }
                        while (booksAvailable > 0) {
                            int toSpawn = Math.min(booksAvailable, 64);
                            level.addFreshEntity(new ItemEntity(
                                    level,
                                    landPosition.getX(),
                                    landPosition.getY(),
                                    landPosition.getZ(),
                                    new ItemStack(Items.BOOK, toSpawn)
                            ));
                            booksAvailable -= toSpawn;
                        }
                    }
                }
            }
        }
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfml\ast\ResourceLimits.java

````java
package ca.teamdman.sfml.ast;

import ca.teamdman.sfm.common.program.InputResourceTracker;
import ca.teamdman.sfm.common.program.OutputResourceTracker;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

public record ResourceLimits(
        List<? extends ResourceLimit<?, ?, ?>> resourceLimits,
        ResourceIdSet exclusions
) implements ASTNode {
    public List<InputResourceTracker<?, ?, ?>> createInputTrackers() {
        List<InputResourceTracker<?, ?, ?>> rtn = new ArrayList<>();
        resourceLimits.forEach(rl -> rl.gatherInputTrackers(rtn::add, exclusions));
        return rtn;
    }

    public List<OutputResourceTracker<?, ?, ?>> createOutputTrackers() {
        List<OutputResourceTracker<?, ?, ?>> rtn = new ArrayList<>();
        resourceLimits.forEach(rl -> rl.gatherOutputTrackers(rtn::add, exclusions));
        return rtn;
    }

    public ResourceLimits withDefaults(Limit limit) {
        return new ResourceLimits(resourceLimits.stream().map(il -> il.withDefaults(limit)).toList(), exclusions);
    }

    public ResourceLimits withExclusions(ResourceIdSet exclusions) {
        return new ResourceLimits(resourceLimits, exclusions);
    }

    @Override
    public String toString() {
        String rtn = this.resourceLimits.stream()
                .map(ResourceLimit::toString)
                .collect(Collectors.joining(",\n"));
        if (!exclusions.resourceIds().isEmpty()) {
            rtn += "\nEXCEPT\n" + exclusions.resourceIds().stream()
                    .map(ResourceIdentifier::toString)
                    .collect(Collectors.joining(",\n"));
        }
        return rtn;
    }

    public String toStringPretty(Limit defaults) {
        String rtn = resourceLimits.stream()
                .map(rl -> rl.toStringCondensed(defaults))
                .map(x -> resourceLimits.size() == 1 ? x : x + ",")
                .collect(Collectors.joining("\n"));
        if (!exclusions.resourceIds().isEmpty()) {
            rtn += "\nEXCEPT\n" + exclusions.resourceIds().stream()
                    .map(ResourceIdentifier::toStringCondensed)
                    .collect(Collectors.joining(",\n"));
        }
        return rtn;
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\item\DiskItem.java

````java
package ca.teamdman.sfm.common.item;

import ca.teamdman.sfm.client.ClientStuff;
import ca.teamdman.sfm.client.ProgramSyntaxHighlightingHelper;
import ca.teamdman.sfm.client.registry.SFMKeyMappings;
import ca.teamdman.sfm.common.Constants;
import ca.teamdman.sfm.common.blockentity.ManagerBlockEntity;
import ca.teamdman.sfm.common.net.ServerboundDiskItemSetProgramPacket;
import ca.teamdman.sfm.common.program.LabelPositionHolder;
import ca.teamdman.sfm.common.registry.SFMItems;
import ca.teamdman.sfm.common.registry.SFMPackets;
import ca.teamdman.sfm.common.util.SFMUtils;
import ca.teamdman.sfml.ast.Program;
import net.minecraft.ChatFormatting;
import net.minecraft.nbt.CompoundTag;
import net.minecraft.nbt.ListTag;
import net.minecraft.nbt.Tag;
import net.minecraft.network.chat.Component;
import net.minecraft.network.chat.MutableComponent;
import net.minecraft.network.chat.contents.TranslatableContents;
import net.minecraft.world.InteractionHand;
import net.minecraft.world.InteractionResultHolder;
import net.minecraft.world.entity.player.Player;
import net.minecraft.world.item.Item;
import net.minecraft.world.item.ItemStack;
import net.minecraft.world.item.TooltipFlag;
import net.minecraft.world.level.Level;
import net.minecraftforge.api.distmarker.Dist;
import net.minecraftforge.fml.DistExecutor;
import net.minecraftforge.fml.loading.FMLEnvironment;
import org.jetbrains.annotations.NotNull;

import javax.annotation.Nullable;
import java.util.Collections;
import java.util.List;
import java.util.Optional;
import java.util.concurrent.atomic.AtomicReference;
import java.util.stream.Collectors;

public class DiskItem extends Item {
    public DiskItem() {
        super(new Item.Properties().tab(SFMItems.TAB));
    }

    public static String getProgram(ItemStack stack) {
        return stack
                .getOrCreateTag()
                .getString("sfm:program");
    }

    public static Optional<Program> updateDetails(ItemStack stack, @Nullable ManagerBlockEntity manager) {
        AtomicReference<Program> rtn = new AtomicReference<>(null);
        Program.compile(
                getProgram(stack),
                (successProgram, builder) -> {
                    setProgramName(stack, successProgram.name());
                    setWarnings(stack, successProgram.gatherWarnings(stack, manager));
                    setErrors(stack, Collections.emptyList());
                    rtn.set(successProgram);
                },
                failure -> {
                    setWarnings(stack, Collections.emptyList());
                    setErrors(stack, failure);
                }
        );
        return Optional.ofNullable(rtn.get());
    }

    public static void setProgram(ItemStack stack, String program) {
        stack
                .getOrCreateTag()
                .putString("sfm:program", program.replaceAll("\r", ""));

    }

    @Override
    public @NotNull InteractionResultHolder<ItemStack> use(Level pLevel, Player pPlayer, InteractionHand pUsedHand) {
        var stack = pPlayer.getItemInHand(pUsedHand);
        if (pLevel.isClientSide) {
            ClientStuff.showProgramEditScreen(
                    stack,
                    programString -> SFMPackets.DISK_ITEM_CHANNEL.sendToServer(new ServerboundDiskItemSetProgramPacket(
                            programString,
                            pUsedHand
                    ))
            );
        }
        return InteractionResultHolder.sidedSuccess(stack, pLevel.isClientSide());
    }

    public static void setErrors(ItemStack stack, List<TranslatableContents> errors) {
        stack
                .getOrCreateTag()
                .put(
                        "sfm:errors",
                        errors
                                .stream()
                                .map(SFMUtils::serializeTranslation)
                                .collect(ListTag::new, ListTag::add, ListTag::addAll)
                );
    }


    public static void setWarnings(ItemStack stack, List<TranslatableContents> warnings) {
        stack
                .getOrCreateTag()
                .put(
                        "sfm:warnings",
                        warnings
                                .stream()
                                .map(SFMUtils::serializeTranslation)
                                .collect(ListTag::new, ListTag::add, ListTag::addAll)
                );
    }


    public static List<TranslatableContents> getErrors(ItemStack stack) {
        return stack
                .getOrCreateTag()
                .getList("sfm:errors", Tag.TAG_COMPOUND)
                .stream()
                .map(CompoundTag.class::cast)
                .map(SFMUtils::deserializeTranslation)
                .toList();
    }

    public static List<TranslatableContents> getWarnings(ItemStack stack) {
        return stack
                .getOrCreateTag()
                .getList("sfm:warnings", Tag.TAG_COMPOUND)
                .stream()
                .map(CompoundTag.class::cast)
                .map(SFMUtils::deserializeTranslation)
                .collect(
                        Collectors.toList());
    }

    public static String getProgramName(ItemStack stack) {
        return stack
                .getOrCreateTag()
                .getString("sfm:name");
    }

    public static void setProgramName(ItemStack stack, String name) {
        if (stack.getItem() instanceof DiskItem) {
            stack
                    .getOrCreateTag()
                    .putString("sfm:name", name);
        }
    }

    @Override
    public Component getName(ItemStack stack) {
        if (FMLEnvironment.dist == Dist.CLIENT) {
            if (ClientStuff.isMoreInfoKeyDown()) return super.getName(stack);
        }
        var name = getProgramName(stack);
        if (name.isEmpty()) return super.getName(stack);
        return Component.literal(name).withStyle(ChatFormatting.AQUA);
    }


    @Override
    public void appendHoverText(
            ItemStack stack, @Nullable Level level, List<Component> list, TooltipFlag detail
    ) {

        if (stack.hasTag()) {
            boolean showProgram = DistExecutor.unsafeRunForDist(
                    () -> ClientStuff::isMoreInfoKeyDown,
                    () -> () -> false
            );
            if (!showProgram) {
                list.addAll(LabelPositionHolder.from(stack).asHoverText());
                getErrors(stack)
                        .stream()
                        .map(MutableComponent::create)
                        .map(line -> line.withStyle(ChatFormatting.RED))
                        .forEach(list::add);
                getWarnings(stack)
                        .stream()
                        .map(MutableComponent::create)
                        .map(line -> line.withStyle(ChatFormatting.YELLOW))
                        .forEach(list::add);
                list.add(Constants.LocalizationKeys.GUI_ADVANCED_TOOLTIP_HINT
                                 .getComponent(SFMKeyMappings.MORE_INFO_TOOLTIP_KEY.get().getTranslatedKeyMessage())
                                 .withStyle(ChatFormatting.AQUA));
            } else {
                var program = getProgram(stack);
                if (!program.isEmpty()) {
                    var start = Component.empty();
                    ChatFormatting[] rainbowColors = new ChatFormatting[]{
                            ChatFormatting.DARK_RED,
                            ChatFormatting.RED,
                            ChatFormatting.GOLD,
                            ChatFormatting.YELLOW,
                            ChatFormatting.DARK_GREEN,
                            ChatFormatting.GREEN,
                            ChatFormatting.DARK_AQUA,
                            ChatFormatting.AQUA,
                            ChatFormatting.DARK_BLUE,
                            ChatFormatting.BLUE,
                            ChatFormatting.DARK_PURPLE,
                            ChatFormatting.LIGHT_PURPLE
                    };
                    int rainbowColorsLength = rainbowColors.length;
                    int fullCycleLength = 2 * rainbowColorsLength - 2;
                    for (int i = 0; i < getName(stack).getString().length() - 2; i++) {
                        int cyclePosition = i % fullCycleLength;
                        int adjustedIndex = cyclePosition < rainbowColorsLength
                                            ? cyclePosition
                                            : fullCycleLength - cyclePosition;
                        ChatFormatting color = rainbowColors[adjustedIndex];
                        start = start.append(Component.literal("=").withStyle(color));
                    }
                    list.add(start);
                    list.addAll(ProgramSyntaxHighlightingHelper.withSyntaxHighlighting(program, false));
                }
            }
        }
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\item\LabelGunItem.java

````java
package ca.teamdman.sfm.common.item;

import ca.teamdman.sfm.client.ClientStuff;
import ca.teamdman.sfm.common.Constants;
import ca.teamdman.sfm.common.net.ServerboundLabelGunUsePacket;
import ca.teamdman.sfm.common.program.LabelPositionHolder;
import ca.teamdman.sfm.common.registry.SFMItems;
import ca.teamdman.sfm.common.registry.SFMPackets;
import net.minecraft.ChatFormatting;
import net.minecraft.client.gui.screens.Screen;
import net.minecraft.network.chat.Component;
import net.minecraft.world.InteractionHand;
import net.minecraft.world.InteractionResult;
import net.minecraft.world.InteractionResultHolder;
import net.minecraft.world.entity.player.Player;
import net.minecraft.world.item.Item;
import net.minecraft.world.item.ItemStack;
import net.minecraft.world.item.TooltipFlag;
import net.minecraft.world.item.context.UseOnContext;
import net.minecraft.world.level.Level;

import javax.annotation.Nullable;
import java.util.Comparator;
import java.util.List;

public class LabelGunItem extends Item {
    public LabelGunItem() {
        super(new Properties().stacksTo(1).tab(SFMItems.TAB));
    }

    public static void setActiveLabel(ItemStack gun, String label) {
        if (label.isEmpty()) return;
        LabelPositionHolder.from(gun).addReferencedLabel(label).save(gun);
        gun.getOrCreateTag().putString("sfm:active_label", label);
    }

    public static String getActiveLabel(ItemStack stack) {
        //noinspection DataFlowIssue
        return !stack.hasTag() ? "" : stack.getTag().getString("sfm:active_label");
    }

    public static String getNextLabel(ItemStack gun, int change) {
        var labels = LabelPositionHolder.from(gun).get().keySet().stream().sorted(Comparator.naturalOrder()).toList();
        if (labels.isEmpty()) return "";
        var currentLabel = getActiveLabel(gun);

        int currentLabelIndex = 0;
        for (int i = 0; i < labels.size(); i++) {
            if (labels.get(i).equals(currentLabel)) {
                currentLabelIndex = i;
                break;
            }
        }

        int nextLabelIndex = currentLabelIndex + change;
        // ensure going negative wraps around
        nextLabelIndex = ((nextLabelIndex % labels.size()) + labels.size()) % labels.size();

        return labels.get(nextLabelIndex);
    }

    @Override
    public InteractionResult onItemUseFirst(
            ItemStack gun, UseOnContext ctx
    ) {
        var level = ctx.getLevel();
        if (level.isClientSide && ctx.getPlayer() != null) {
            SFMPackets.LABEL_GUN_ITEM_CHANNEL.sendToServer(new ServerboundLabelGunUsePacket(
                    ctx.getHand(),
                    ctx.getClickedPos(),
                    Screen.hasControlDown(),
                    ctx.getPlayer().isShiftKeyDown()
            ));
            return InteractionResult.SUCCESS;
        }
        return InteractionResult.CONSUME;
    }

    @Override
    public void appendHoverText(
            ItemStack stack, @Nullable Level level, List<Component> lines, TooltipFlag detail
    ) {
        lines.add(Constants.LocalizationKeys.LABEL_GUN_ITEM_TOOLTIP_1.getComponent().withStyle(ChatFormatting.GRAY));
        lines.add(Constants.LocalizationKeys.LABEL_GUN_ITEM_TOOLTIP_2.getComponent().withStyle(ChatFormatting.GRAY));
        lines.add(Constants.LocalizationKeys.LABEL_GUN_ITEM_TOOLTIP_3.getComponent().withStyle(ChatFormatting.GRAY));
        lines.addAll(LabelPositionHolder.from(stack).asHoverText());
    }

    @Override
    public InteractionResultHolder<ItemStack> use(
            Level level,
            Player player,
            InteractionHand hand
    ) {
        var stack = player.getItemInHand(hand);
        if (level.isClientSide) {
            ClientStuff.showLabelGunScreen(stack, hand);
        }
        return InteractionResultHolder.sidedSuccess(stack, level.isClientSide());
    }

    @Override
    public Component getName(ItemStack stack) {
        var name = getActiveLabel(stack);
        if (name.isEmpty()) return super.getName(stack);
        return Constants.LocalizationKeys.LABEL_GUN_ITEM_NAME_WITH_LABEL
                .getComponent(name)
                .withStyle(ChatFormatting.AQUA);
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\net\ServerboundLabelGunPrunePacket.java

````java
package ca.teamdman.sfm.common.net;

import ca.teamdman.sfm.common.item.LabelGunItem;
import ca.teamdman.sfm.common.program.LabelPositionHolder;
import net.minecraft.network.FriendlyByteBuf;
import net.minecraft.world.InteractionHand;
import net.minecraftforge.network.NetworkEvent;

import java.util.function.Supplier;

public record ServerboundLabelGunPrunePacket(
        InteractionHand hand
) {
    public static void encode(ServerboundLabelGunPrunePacket msg, FriendlyByteBuf buf) {
        buf.writeEnum(msg.hand);
    }

    public static ServerboundLabelGunPrunePacket decode(
            FriendlyByteBuf buf
    ) {
        return new ServerboundLabelGunPrunePacket(buf.readEnum(InteractionHand.class));
    }

    public static void handle(
            ServerboundLabelGunPrunePacket msg, Supplier<NetworkEvent.Context> ctx
    ) {
        ctx.get().enqueueWork(() -> {
            var sender = ctx.get().getSender();
            if (sender == null) {
                return;
            }
            var stack = sender.getItemInHand(msg.hand);
            if (stack.getItem() instanceof LabelGunItem) {
                LabelPositionHolder.from(stack).prune().save(stack);
            }
        });
        ctx.get().setPacketHandled(true);
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfml\ast\ResourceQuantity.java

````java
package ca.teamdman.sfml.ast;

public record ResourceQuantity(
        Number number,
        IdExpansionBehaviour idExpansionBehaviour
) implements ASTNode {
    @SuppressWarnings("DataFlowIssue")
    public static ResourceQuantity UNSET = new ResourceQuantity(null, IdExpansionBehaviour.NO_EXPAND);
    public static ResourceQuantity MAX_QUANTITY = new ResourceQuantity(
            new Number(Long.MAX_VALUE),
            IdExpansionBehaviour.NO_EXPAND
    );

    public ResourceQuantity add(ResourceQuantity quantity) {
        return new ResourceQuantity(
                number.add(quantity.number),
                idExpansionBehaviour
        );
    }

    public enum IdExpansionBehaviour {
        EXPAND,
        NO_EXPAND
    }

    @Override
    public String toString() {
        return number + (idExpansionBehaviour == IdExpansionBehaviour.EXPAND ? " EACH" : "");
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\command\package-info.java

````java

@ParametersAreNonnullByDefault
@MethodsReturnNonnullByDefault
@FieldsAreNonnullByDefault
package ca.teamdman.sfm.common.command;

import net.minecraft.FieldsAreNonnullByDefault;
import net.minecraft.MethodsReturnNonnullByDefault;

import javax.annotation.ParametersAreNonnullByDefault;
````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\client\gui\screen\ManagerScreen.java

````java
package ca.teamdman.sfm.client.gui.screen;

import ca.teamdman.sfm.SFM;
import ca.teamdman.sfm.client.ClientStuff;
import ca.teamdman.sfm.common.containermenu.ManagerContainerMenu;
import ca.teamdman.sfm.common.item.DiskItem;
import ca.teamdman.sfm.common.net.ServerboundManagerFixPacket;
import ca.teamdman.sfm.common.net.ServerboundManagerProgramPacket;
import ca.teamdman.sfm.common.net.ServerboundManagerResetPacket;
import ca.teamdman.sfm.common.registry.SFMPackets;
import com.mojang.blaze3d.systems.RenderSystem;
import com.mojang.blaze3d.vertex.*;
import com.mojang.math.Matrix4f;
import net.minecraft.ChatFormatting;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.components.Button;
import net.minecraft.client.gui.screens.Screen;
import net.minecraft.client.gui.screens.inventory.AbstractContainerScreen;
import net.minecraft.client.player.LocalPlayer;
import net.minecraft.client.renderer.GameRenderer;
import net.minecraft.client.resources.language.I18n;
import net.minecraft.network.chat.Component;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.world.entity.player.Inventory;
import net.minecraftforge.client.gui.widget.ExtendedButton;
import org.lwjgl.glfw.GLFW;

import java.text.DecimalFormat;
import java.text.SimpleDateFormat;
import java.util.List;

import static ca.teamdman.sfm.common.Constants.LocalizationKeys.*;

public class ManagerScreen extends AbstractContainerScreen<ManagerContainerMenu> {
    private static final ResourceLocation BACKGROUND_TEXTURE_LOCATION = new ResourceLocation(
            SFM.MOD_ID,
            "textures/gui/container/manager.png"
    );
    private final float STATUS_DURATION = 40;
    private Component status = Component.empty();
    private float statusCountdown = 0;
    @SuppressWarnings("NotNullFieldNotInitialized")
    private ExtendedButton diagButton;
    @SuppressWarnings("NotNullFieldNotInitialized")
    private ExtendedButton clipboardPasteButton;
    @SuppressWarnings("NotNullFieldNotInitialized")
    private ExtendedButton clipboardCopyButton;
    @SuppressWarnings("NotNullFieldNotInitialized")
    private ExtendedButton resetButton;
    @SuppressWarnings("NotNullFieldNotInitialized")
    private ExtendedButton editButton;
    @SuppressWarnings("NotNullFieldNotInitialized")
    private ExtendedButton examplesButton;

    public List<ExtendedButton> getButtonsForJEIExclusionZones() {
        return List.of(
                clipboardPasteButton,
                editButton,
                examplesButton,
                clipboardCopyButton
        );
    }

    public ManagerScreen(ManagerContainerMenu menu, Inventory inv, Component title) {
        super(menu, inv, title);
    }

    public boolean isReadOnly() {
        LocalPlayer player = Minecraft.getInstance().player;
        return player == null || player.isSpectator();
    }

    public void updateVisibilities() {
        boolean diskPresent = menu.getSlot(0).hasItem();
        diagButton.visible = shouldShowDiagButton();
        clipboardCopyButton.visible = diskPresent;
        clipboardPasteButton.visible = diskPresent && !isReadOnly();
        resetButton.visible = diskPresent && !isReadOnly();
        editButton.visible = diskPresent && !isReadOnly();
    }

    private Button.OnTooltip buildTooltip(LocalizationEntry entry) {
        return (btn, pose, mx, my) -> renderTooltip(
                pose,
                font.split(
                        entry.getComponent(),
                        Math.max(
                                width
                                / 2
                                - 43,
                                170
                        )
                ),
                mx,
                my
        );
    }

    @Override
    protected void init() {
        super.init();
        int buttonWidth = 120;
        clipboardPasteButton = this.addRenderableWidget(new ExtendedButtonWithTooltip(
                (this.width - this.imageWidth) / 2 - buttonWidth,
                (this.height - this.imageHeight) / 2 + 16,
                buttonWidth,
                16,
                MANAGER_GUI_PASTE_FROM_CLIPBOARD_BUTTON.getComponent(),
                button -> this.onLoadClipboard(),
                buildTooltip(MANAGER_GUI_PASTE_FROM_CLIPBOARD_BUTTON_TOOLTIP)
        ));
        editButton = this.addRenderableWidget(new ExtendedButtonWithTooltip(
                (this.width - this.imageWidth) / 2 - buttonWidth,
                (this.height - this.imageHeight) / 2 + 16 + 50,
                buttonWidth,
                16,
                MANAGER_GUI_EDIT_BUTTON.getComponent(),
                button -> onEdit(),
                buildTooltip(MANAGER_GUI_EDIT_BUTTON_TOOLTIP)
        ));
        examplesButton = this.addRenderableWidget(new ExtendedButtonWithTooltip(
                (this.width - this.imageWidth) / 2 - buttonWidth,
                (this.height - this.imageHeight) / 2 + 16 * 2 + 50,
                buttonWidth,
                16,
                MANAGER_GUI_VIEW_EXAMPLES_BUTTON.getComponent(),
                button -> onShowExamples(),
                buildTooltip(MANAGER_GUI_VIEW_EXAMPLES_BUTTON_TOOLTIP)
        ));
        clipboardCopyButton = this.addRenderableWidget(new ExtendedButton(
                (this.width - this.imageWidth) / 2 - buttonWidth,
                (this.height - this.imageHeight) / 2 + 128,
                buttonWidth,
                16,
                MANAGER_GUI_COPY_TO_CLIPBOARD_BUTTON.getComponent(),
                button -> this.onSaveClipboard()
        ));
        resetButton = this.addRenderableWidget(new ExtendedButtonWithTooltip(
                (this.width - this.imageWidth) / 2 + 120,
                (this.height - this.imageHeight) / 2 + 10,
                50,
                12,
                MANAGER_GUI_RESET_BUTTON.getComponent(),
                button -> sendReset(),
                buildTooltip(MANAGER_GUI_RESET_BUTTON_TOOLTIP)
        ));
        diagButton = this.addRenderableWidget(new ExtendedButtonWithTooltip(
                (this.width - this.imageWidth) / 2 + 35,
                (this.height - this.imageHeight) / 2 + 48,
                12,
                14,
                Component.literal("!"),
                button -> {
                    if (Screen.hasShiftDown() && !isReadOnly()) {
                        sendAttemptFix();
                    } else {
                        this.onSaveDiagClipboard();
                    }
                },
                buildTooltip(isReadOnly()
                             ? MANAGER_GUI_WARNING_BUTTON_TOOLTIP_READ_ONLY
                             : MANAGER_GUI_WARNING_BUTTON_TOOLTIP)
        ));
        updateVisibilities();
    }

    private void onEdit() {
        ClientStuff.showProgramEditScreen(menu.CONTAINER.getItem(0), this::sendProgram);
    }

    private void onShowExamples() {
        Minecraft
                .getInstance()
                .pushGuiLayer(new ProgramTemplatePickerScreen(template -> ClientStuff.showProgramEditScreen(
                        template,
                        this::sendProgram
                )));
    }

    private void sendReset() {
        SFMPackets.MANAGER_CHANNEL.sendToServer(new ServerboundManagerResetPacket(
                menu.containerId,
                menu.MANAGER_POSITION
        ));
        status = MANAGER_GUI_STATUS_RESET.getComponent();
        statusCountdown = STATUS_DURATION;
    }

    private void sendAttemptFix() {
        SFMPackets.MANAGER_CHANNEL.sendToServer(new ServerboundManagerFixPacket(
                menu.containerId,
                menu.MANAGER_POSITION
        ));
        status = MANAGER_GUI_STATUS_FIX.getComponent();
        statusCountdown = STATUS_DURATION;
    }

    private void sendProgram(String program) {
        SFMPackets.MANAGER_CHANNEL.sendToServer(new ServerboundManagerProgramPacket(
                menu.containerId,
                menu.MANAGER_POSITION,
                program
        ));
        menu.program = program;
        status = MANAGER_GUI_STATUS_LOADED_CLIPBOARD.getComponent();
        statusCountdown = STATUS_DURATION;
    }

    private void onSaveClipboard() {
        try {
            Minecraft.getInstance().keyboardHandler.setClipboard(menu.program);
            status = MANAGER_GUI_STATUS_SAVED_CLIPBOARD.getComponent();
            statusCountdown = STATUS_DURATION;
        } catch (Throwable t) {
            SFM.LOGGER.error("failed to save clipboard", t);
        }
    }

    private boolean shouldShowDiagButton() {
        var disk = menu.CONTAINER.getItem(0);
        if (!(disk.getItem() instanceof DiskItem)) return false;
        var errors = DiskItem.getErrors(disk);
        var warnings = DiskItem.getWarnings(disk);
        return !errors.isEmpty() || !warnings.isEmpty();
    }

    private void onSaveDiagClipboard() {
        try {
            var disk = menu.CONTAINER.getItem(0);
            if (!(disk.getItem() instanceof DiskItem)) return;
            StringBuilder content = new StringBuilder(menu.program);

            content
                    .append("\n\n-- Diagnostic info ")
                    .append(new SimpleDateFormat("yyyy-MM-dd HH:mm.ss").format(new java.util.Date()))
                    .append(" --");

            var errors = DiskItem.getErrors(disk);
            if (!errors.isEmpty()) {
                content.append("\n\n-- Errors\n");
                for (var error : errors) {
                    content.append("-- * ").append(I18n.get(error.getKey(), error.getArgs())).append("\n");
                }
            }

            var warnings = DiskItem.getWarnings(disk);
            if (!warnings.isEmpty()) {
                content.append("\n\n-- Warnings\n");
                for (var warning : warnings) {
                    content.append("-- * ").append(I18n.get(warning.getKey(), warning.getArgs())).append("\n");
                }
            }

            Minecraft.getInstance().keyboardHandler.setClipboard(content.toString());
            status = MANAGER_GUI_STATUS_SAVED_CLIPBOARD.getComponent();
            statusCountdown = STATUS_DURATION;
        } catch (Throwable t) {
            SFM.LOGGER.error("failed saving clipboard", t);
        }
    }

    private void onLoadClipboard() {
        try {
            String contents = Minecraft.getInstance().keyboardHandler.getClipboard();
            sendProgram(contents);
        } catch (Throwable t) {
            SFM.LOGGER.error("failed loading clipboard", t);
        }
    }

    @Override
    public boolean keyPressed(int pKeyCode, int pScanCode, int pModifiers) {
        if (Screen.isPaste(pKeyCode) && clipboardPasteButton.visible) {
            onLoadClipboard();
            return true;
        } else if (Screen.isCopy(pKeyCode) && clipboardCopyButton.visible) {
            onSaveClipboard();
            return true;
        } else if (pKeyCode == GLFW.GLFW_KEY_E
                   && Screen.hasControlDown()
                   && Screen.hasShiftDown()
                   && examplesButton.visible) {
            onShowExamples();
            return true;
        } else if (pKeyCode == GLFW.GLFW_KEY_E && Screen.hasControlDown() && editButton.visible) {
            onEdit();
            return true;
        }
        return super.keyPressed(pKeyCode, pScanCode, pModifiers);
    }

    @Override
    protected void renderLabels(PoseStack poseStack, int mx, int my) {
        // draw title
        super.renderLabels(poseStack, mx, my);

        // draw state string
        var state = menu.state;
        this.font.draw(
                poseStack,
                MANAGER_GUI_STATE.getComponent(state.LOC.getComponent().withStyle(state.COLOR)),
                titleLabelX,
                20,
                0
        );

        // draw status string
        if (statusCountdown > 0) {
            this.font.draw(
                    poseStack,
                    status,
                    inventoryLabelX + font.width(playerInventoryTitle.getString()) + 5,
                    inventoryLabelY,
                    0
            );
        }

        // Find the maximum tick time for normalization
        long peakTickTimeNanoseconds = 0;
        for (int i = 0; i < menu.tickTimeNanos.length; i++) {
            peakTickTimeNanoseconds = Long.max(peakTickTimeNanoseconds, menu.tickTimeNanos[i]);
        }
        long yMax = Long.max(peakTickTimeNanoseconds, 50000000); // Start with max at 50ms but allow it to grow

        // Constants for the plot size and position
        final int plotX = titleLabelX + 45;
        final int plotY = 40;
        final int spaceBetweenPoints = 6;
        final int plotWidth = spaceBetweenPoints * (menu.tickTimeNanos.length - 1);
        final int plotHeight = 30;


        // Set up rendering
        RenderSystem.disableTexture();
        RenderSystem.enableBlend();
        RenderSystem.defaultBlendFunc();
        RenderSystem.setShader(GameRenderer::getPositionColorShader);
        Tesselator tesselator = Tesselator.getInstance();
        Matrix4f pose = poseStack.last().pose();
        BufferBuilder bufferbuilder;

        // Draw the plot background
        bufferbuilder = tesselator.getBuilder();
        bufferbuilder.begin(VertexFormat.Mode.DEBUG_LINE_STRIP, DefaultVertexFormat.POSITION_COLOR);
        bufferbuilder.vertex(pose, plotX, plotY, 0).color(0, 0, 0, 0.5f).endVertex();
        bufferbuilder.vertex(pose, plotX + plotWidth, plotY, 0).color(0, 0, 0, 0.5f).endVertex();
        bufferbuilder.vertex(pose, plotX + plotWidth, plotY + plotHeight, 0).color(0, 0, 0, 0.5f).endVertex();
        bufferbuilder.vertex(pose, plotX, plotY + plotHeight, 0).color(0, 0, 0, 0.5f).endVertex();
        bufferbuilder.vertex(pose, plotX, plotY, 0).color(0, 0, 0, 0.5f).endVertex();
        tesselator.end();

        // Draw lines for each data point
        bufferbuilder = tesselator.getBuilder();
        bufferbuilder.begin(VertexFormat.Mode.DEBUG_LINE_STRIP, DefaultVertexFormat.POSITION_COLOR);
        int mouseTickTimeIndex = -1;
        for (int i = 0; i < menu.tickTimeNanos.length; i++) {
            long y = menu.tickTimeNanos[i];
            float normalizedTickTime = y == 0 ? 0 : (float) (Math.log10(y) / Math.log10(yMax));
            int plotPosY = plotY + plotHeight - (int) (normalizedTickTime * plotHeight);

            int plotPosX = plotX + spaceBetweenPoints * i;

            // Color the lines based on their tick times (green to red)
            var c = getMillisecondColour(y / 1_000_000f);
            //noinspection DataFlowIssue
            float red = ((c.getColor() >> 16) & 0xFF) / 255f;
            float green = ((c.getColor() >> 8) & 0xFF) / 255f;
            float blue = (c.getColor() & 0xFF) / 255f;

            bufferbuilder
                    .vertex(pose, (float) plotPosX, (float) plotPosY, (float) getBlitOffset())
                    .color(red, green, blue, 1f)
                    .endVertex();

            // Check if the mouse is hovering over this line
            if (mx - leftPos >= plotPosX - spaceBetweenPoints / 2
                && mx - leftPos <= plotPosX + spaceBetweenPoints / 2
                && my - topPos >= plotY - 2
                && my - topPos <= plotY + plotHeight + 2) {
                mouseTickTimeIndex = i;
            }
        }
        tesselator.end();

        // Draw the tick time text
        var format = new DecimalFormat("0.000");
        if (mouseTickTimeIndex != -1) { // We are hovering over the plot
            // Draw the tick time text for the hovered point instead of peak
            long hoveredTickTimeNanoseconds = menu.tickTimeNanos[mouseTickTimeIndex];
            var hoveredTickTimeMilliseconds = hoveredTickTimeNanoseconds / 1_000_000f;

            this.font.draw(
                    poseStack,
                    MANAGER_GUI_HOVERED_TICK_TIME.getComponent(Component
                                                                       .literal(format.format(
                                                                               hoveredTickTimeMilliseconds))
                                                                       .withStyle(getMillisecondColour(
                                                                               hoveredTickTimeMilliseconds))),
                    titleLabelX,
                    20f + font.lineHeight + 0.1f,
                    0
            );

            // draw a vertical line
            RenderSystem.setShader(GameRenderer::getPositionColorShader);
            tesselator = Tesselator.getInstance();
            bufferbuilder = tesselator.getBuilder();
            bufferbuilder.begin(VertexFormat.Mode.DEBUG_LINE_STRIP, DefaultVertexFormat.POSITION_COLOR);
            pose = poseStack.last().pose();

            int x = plotX + spaceBetweenPoints * mouseTickTimeIndex;
            bufferbuilder
                    .vertex(pose, (float) x, (float) plotY, (float) getBlitOffset())
                    .color(1f, 1f, 1f, 1f)
                    .endVertex();
            bufferbuilder
                    .vertex(pose, (float) x, (float) plotY + plotHeight, (float) getBlitOffset())
                    .color(1f, 1f, 1f, 1f)
                    .endVertex();
            tesselator.end();
        } else {
            // Draw the tick time text for peak value
            var peakTickTimeMilliseconds = peakTickTimeNanoseconds / 1_000_000f;
            this.font.draw(
                    poseStack,
                    MANAGER_GUI_PEAK_TICK_TIME.getComponent(Component
                                                                    .literal(format.format(peakTickTimeMilliseconds))
                                                                    .withStyle(getMillisecondColour(
                                                                            peakTickTimeMilliseconds))),
                    titleLabelX,
                    20f + font.lineHeight + 0.1f,
                    0
            );
        }

        // Restore stuff
        RenderSystem.disableBlend();
        RenderSystem.enableTexture();
    }

    public ChatFormatting getMillisecondColour(float ms) {
        if (ms <= 5) {
            return ChatFormatting.GREEN;
        } else if (ms <= 15) {
            return ChatFormatting.YELLOW;
        } else {
            return ChatFormatting.RED;
        }
    }

    @Override
    public void render(PoseStack poseStack, int mx, int my, float partialTicks) {
        this.renderBackground(poseStack);
        super.render(poseStack, mx, my, partialTicks);
        this.renderTooltip(poseStack, mx, my);

        updateVisibilities();

        // update status countdown
        statusCountdown -= partialTicks;
    }

    @Override
    protected void renderTooltip(PoseStack pose, int mx, int my) {
        super.renderTooltip(pose, mx, my);
        this.renderables
                .stream()
                .filter(ExtendedButtonWithTooltip.class::isInstance)
                .map(ExtendedButtonWithTooltip.class::cast)
                .forEach(x -> x.renderToolTip(pose, mx, my));

    }

    @Override
    protected void renderBg(PoseStack matrixStack, float partialTicks, int mx, int my) {
        //        Lighting.setupForFlatItems();
        RenderSystem.setShader(GameRenderer::getPositionTexShader);
        RenderSystem.setShaderColor(1f, 1f, 1f, 1f);
        RenderSystem.setShaderTexture(0, BACKGROUND_TEXTURE_LOCATION);
        int i = (this.width - this.imageWidth) / 2;
        int j = (this.height - this.imageHeight) / 2;
        this.blit(matrixStack, i, j, 0, 0, this.imageWidth, this.imageHeight);
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\package-info.java

````java


@ParametersAreNonnullByDefault
@MethodsReturnNonnullByDefault
@FieldsAreNonnullByDefault
package ca.teamdman.sfm.common;

import net.minecraft.FieldsAreNonnullByDefault;
import net.minecraft.MethodsReturnNonnullByDefault;

import javax.annotation.ParametersAreNonnullByDefault;
````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfml\ast\Block.java

````java
package ca.teamdman.sfml.ast;

import ca.teamdman.sfm.common.program.ProgramContext;

import java.util.List;

public record Block(List<Statement> statements) implements Statement {
    @Override
    public void tick(ProgramContext context) {
        for (Statement statement : statements) {
            statement.tick(context);
        }
    }

    @Override
    public String toString() {
        var rtn = new StringBuilder();
        for (Statement statement : statements) {
            if (statement instanceof InputStatement ins) {
                rtn.append(ins.toStringPretty().strip());
            } else if (statement instanceof OutputStatement outs) {
                rtn.append(outs.toStringPretty().strip());
            } else {
                rtn.append(statement.toString().strip());
            }
            rtn.append("\n");
        }
        return rtn.toString().strip();
    }

    @Override
    public List<Statement> getStatements() {
        return statements;
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfml\ast\RoundRobin.java

````java
package ca.teamdman.sfml.ast;

import ca.teamdman.sfm.common.program.LabelPositionHolder;
import net.minecraft.core.BlockPos;

import java.util.Collection;
import java.util.List;
import java.util.stream.Stream;

public class RoundRobin implements ASTNode {
    private final Behaviour behaviour;
    private int index = 0;

    public RoundRobin(Behaviour behaviour) {
        this.behaviour = behaviour;
    }

    public static RoundRobin disabled() {
        return new RoundRobin(Behaviour.UNMODIFIED);
    }

    public Stream<BlockPos> gather(LabelAccess labelAccess, LabelPositionHolder labelPositions) {
        return switch (behaviour) {
            case BY_LABEL -> {
                int index = this.next(labelAccess.labels().size());
                yield labelPositions.getPositions(labelAccess.labels().get(index).name()).stream();
            }
            case BY_BLOCK -> {
                List<BlockPos> positions = labelAccess.labels().stream()
                        .map(Label::name)
                        .map(labelPositions::getPositions)
                        .flatMap(Collection::stream)
                        .distinct()
                        .toList();
                if (positions.isEmpty()) {
                    yield Stream.empty();
                }
                yield Stream.of(positions.get(this.next(positions.size())));
            }
            default -> labelAccess.labels().stream()
                    .map(Label::name)
                    .map(labelPositions::getPositions)
                    .flatMap(Collection::stream);
        };
    }

    public int next(int max) {
        return index++ % max;
    }

    @Override
    public String toString() {
        return switch (behaviour) {
            case UNMODIFIED -> "NOT ROUND ROBIN";
            case BY_BLOCK -> "ROUND ROBIN BY BLOCK";
            case BY_LABEL -> "ROUND ROBIN BY LABEL";
        };
    }

    public boolean isEnabled() {
        return behaviour != Behaviour.UNMODIFIED;
    }

    public enum Behaviour {
        UNMODIFIED,
        BY_BLOCK,
        BY_LABEL
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfml\ast\IfStatement.java

````java
package ca.teamdman.sfml.ast;

import ca.teamdman.sfm.common.program.ProgramContext;

import java.util.List;
import java.util.function.Predicate;

public record IfStatement(
        BoolExpr condition,
        Block trueBlock,
        Block falseBlock
) implements ASTNode, Statement {
    @Override
    public void tick(ProgramContext context) {
        Predicate<ProgramContext> condition = this.condition;
        if (context.getExecutionPolicy() == ProgramContext.ExecutionPolicy.EXPLORE_BRANCHES) {
            condition = ctx -> {
                int conditionIndex = ctx.getProgram().getConditionIndex(this);
                return (ctx.getExplorationBranchIndex() & (1 << conditionIndex)) != 0;
            };
        }

        if (condition.test(context)) {
            context.pushPath(new ProgramContext.Branch(this, true));
            trueBlock.tick(context);
        } else {
            context.pushPath(new ProgramContext.Branch(this, false));
            falseBlock.tick(context);
        }

    }

    @Override
    public String toString() {
        var rtn = "IF " + condition + " THEN\n" + trueBlock.toString().strip().indent(1).stripTrailing();
        if (!falseBlock.getStatements().isEmpty()) {
            rtn += "\nELSE\n" + falseBlock.toString().strip().indent(1);
        }
        rtn += "\nEND";
//        var rtn = new StringBuilder();
//        rtn.append("IF ").append(condition).append(" THEN\n").append(trueBlock.toString().indent(1));
//        if (!falseBlock.getStatements().isEmpty()) {
//            rtn.append("\nELSE\n").append(falseBlock.toString().indent(1));
//        }
//        rtn.append("\nEND");
        return rtn.strip();
    }

    @Override
    public List<Statement> getStatements() {
        return List.of(trueBlock, falseBlock);
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\registry\SFMMenus.java

````java
package ca.teamdman.sfm.common.registry;


import ca.teamdman.sfm.SFM;
import ca.teamdman.sfm.client.ClientStuff;
import ca.teamdman.sfm.common.blockentity.ManagerBlockEntity;
import ca.teamdman.sfm.common.containermenu.ManagerContainerMenu;
import net.minecraft.network.FriendlyByteBuf;
import net.minecraft.world.entity.player.Inventory;
import net.minecraft.world.inventory.MenuType;
import net.minecraft.world.level.block.entity.BlockEntity;
import net.minecraftforge.common.extensions.IForgeMenuType;
import net.minecraftforge.eventbus.api.IEventBus;
import net.minecraftforge.fml.DistExecutor;
import net.minecraftforge.network.IContainerFactory;
import net.minecraftforge.registries.DeferredRegister;
import net.minecraftforge.registries.ForgeRegistries;
import net.minecraftforge.registries.RegistryObject;

public class SFMMenus {
    private static final DeferredRegister<MenuType<?>> MENU_TYPES = DeferredRegister.create(
            ForgeRegistries.MENU_TYPES,
            SFM.MOD_ID
    );

    public static void register(IEventBus bus) {
        MENU_TYPES.register(bus);
    }

    public static final RegistryObject<MenuType<ManagerContainerMenu>> MANAGER_MENU = MENU_TYPES.register(
            "manager",
            () -> IForgeMenuType.create(
                    new IContainerFactory<>() {
                        @Override
                        public ManagerContainerMenu create(
                                int windowId,
                                Inventory inv,
                                FriendlyByteBuf data
                        ) {
                            return new ManagerContainerMenu(
                                    windowId,
                                    inv,
                                    data
                            );
                        }

                        @Override
                        public ManagerContainerMenu create(
                                int windowId,
                                Inventory inv
                        ) {
                            return DistExecutor.unsafeRunForDist(
                                    () -> () -> {
                                        BlockEntity be = ClientStuff.getLookBlockEntity();
                                        if (!(be instanceof ManagerBlockEntity mbe))
                                            return IContainerFactory.super.create(windowId, inv);
                                        return new ManagerContainerMenu(windowId, inv, mbe);
                                    },
                                    () -> () -> IContainerFactory.super.create(
                                            windowId,
                                            inv
                                    )
                            );
                        }
                    })
    );


}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\command\SFMCommand.java

````java
package ca.teamdman.sfm.common.command;

import ca.teamdman.sfm.SFM;
import ca.teamdman.sfm.common.cablenetwork.CableNetworkManager;
import net.minecraft.commands.Commands;
import net.minecraft.commands.arguments.blocks.BlockInput;
import net.minecraft.commands.arguments.blocks.BlockStateArgument;
import net.minecraft.server.level.ServerLevel;
import net.minecraft.world.level.block.Block;
import net.minecraftforge.event.RegisterCommandsEvent;
import net.minecraftforge.eventbus.api.SubscribeEvent;
import net.minecraftforge.fml.common.Mod;

import static com.mojang.brigadier.Command.SINGLE_SUCCESS;

@Mod.EventBusSubscriber(bus = Mod.EventBusSubscriber.Bus.FORGE, modid = SFM.MOD_ID)
public class SFMCommand {
    @SubscribeEvent
    public static void onRegisterCommand(final RegisterCommandsEvent event) {
        var command = Commands.literal("sfm");
        command.then(Commands.literal("bust_cable_network_cache")
                             .requires(source -> source.hasPermission(2))
                             .executes(ctx -> {
                                 SFM.LOGGER.info("Busting cable networks");
                                 CableNetworkManager.clear();
                                 return SINGLE_SUCCESS;
                             }));
        command.then(Commands.literal("show_bad_cable_cache_entries")
                             .requires(source -> source.hasPermission(2))
                             .then(Commands.argument("block", BlockStateArgument.block(event.getBuildContext()))
                                           .executes(ctx -> {
                                               ServerLevel level = ctx.getSource().getLevel();
                                               CableNetworkManager.getBadCableCachePositions(level).forEach(pos -> {
                                                   BlockInput block = BlockStateArgument
                                                           .getBlock(
                                                                   ctx,
                                                                   "block"
                                                           );
                                                   block.place(
                                                           level,
                                                           pos,
                                                           Block.UPDATE_ALL
                                                   );
                                               });
                                               return SINGLE_SUCCESS;
                                           })));
        event.getDispatcher().register(command);
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\resourcetype\package-info.java

````java


@ParametersAreNonnullByDefault
@MethodsReturnNonnullByDefault
@FieldsAreNonnullByDefault
package ca.teamdman.sfm.common.resourcetype;

import net.minecraft.FieldsAreNonnullByDefault;
import net.minecraft.MethodsReturnNonnullByDefault;

import javax.annotation.ParametersAreNonnullByDefault;
````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\resourcetype\FluidResourceType.java

````java
package ca.teamdman.sfm.common.resourcetype;

import net.minecraft.world.level.material.Fluid;
import net.minecraftforge.common.capabilities.ForgeCapabilities;
import net.minecraftforge.fluids.FluidStack;
import net.minecraftforge.fluids.capability.IFluidHandler;
import net.minecraftforge.registries.ForgeRegistries;
import net.minecraftforge.registries.IForgeRegistry;

public class FluidResourceType extends ResourceType<FluidStack, Fluid, IFluidHandler> {
    public FluidResourceType() {
        super(ForgeCapabilities.FLUID_HANDLER);
    }

    @Override
    public IForgeRegistry<Fluid> getRegistry() {
        return ForgeRegistries.FLUIDS;
    }

    @Override
    public Fluid getItem(FluidStack fluidStack) {
        return fluidStack.getFluid();
    }

    @Override
    public FluidStack copy(FluidStack fluidStack) {
        return fluidStack.copy();
    }

    @Override
    protected FluidStack setCount(FluidStack fluidStack, long amount) {
        int finalAmount = amount > Integer.MAX_VALUE ? Integer.MAX_VALUE : (int) amount;
        fluidStack.setAmount(finalAmount);
        return fluidStack;
    }

    @Override
    public long getAmount(FluidStack stack) {
        return stack.getAmount();
    }

    @Override
    public FluidStack getStackInSlot(IFluidHandler cap, int slot) {
        return cap.getFluidInTank(slot);
    }

    @Override
    public FluidStack extract(IFluidHandler handler, int slot, long amount, boolean simulate) {
        var in          = getStackInSlot(handler, slot);
        int finalAmount = amount > Integer.MAX_VALUE ? Integer.MAX_VALUE : (int) amount;
        var toExtract   = new FluidStack(in.getFluid(), Math.min(in.getAmount(), finalAmount));
        return handler.drain(
                toExtract,
                simulate ? IFluidHandler.FluidAction.SIMULATE : IFluidHandler.FluidAction.EXECUTE
        );
    }

    @Override
    public boolean matchesStackType(Object o) {
        return o instanceof FluidStack;
    }

    @Override
    public boolean matchesCapabilityType(Object o) {
        return o instanceof IFluidHandler;
    }

    @Override
    public int getSlots(IFluidHandler handler) {
        return handler.getTanks();
    }

    @Override
    public long getMaxStackSize(FluidStack fluidStack) {
        return Integer.MAX_VALUE;
    }

    @Override
    public long getMaxStackSize(IFluidHandler iFluidHandler, int slot) {
        return iFluidHandler.getTankCapacity(slot);
    }

    @Override
    public FluidStack insert(IFluidHandler handler, int slot, FluidStack stack, boolean simulate) {
        //todo: PR to forge to add a method that takes tank slot index
        var x = handler.fill(stack, simulate ? IFluidHandler.FluidAction.SIMULATE : IFluidHandler.FluidAction.EXECUTE);

        // convert units to find amount NOT inserted
        return new FluidStack(stack.getFluid(), stack.getAmount() - x);
    }

    @Override
    public boolean isEmpty(FluidStack stack) {
        return stack.isEmpty();
    }

    @Override
    public FluidStack getEmptyStack() {
        return FluidStack.EMPTY;
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfml\ast\Program.java

````java
package ca.teamdman.sfml.ast;

import ca.teamdman.sfm.SFM;
import ca.teamdman.sfm.common.Constants;
import ca.teamdman.sfm.common.blockentity.ManagerBlockEntity;
import ca.teamdman.sfm.common.cablenetwork.CableNetworkManager;
import ca.teamdman.sfm.common.item.DiskItem;
import ca.teamdman.sfm.common.program.LabelPositionHolder;
import ca.teamdman.sfm.common.program.ProgramContext;
import ca.teamdman.sfm.common.resourcetype.ResourceType;
import ca.teamdman.sfm.common.util.SFMUtils;
import ca.teamdman.sfml.SFMLLexer;
import ca.teamdman.sfml.SFMLParser;
import net.minecraft.ResourceLocationException;
import net.minecraft.network.chat.contents.TranslatableContents;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.world.item.ItemStack;
import net.minecraftforge.fml.loading.FMLEnvironment;
import org.antlr.v4.runtime.*;

import javax.annotation.Nullable;
import java.util.*;
import java.util.function.BiConsumer;
import java.util.function.Consumer;

public record Program(
        String name,
        List<Trigger> triggers,
        Set<String> referencedLabels,
        Set<ResourceIdentifier<?, ?, ?>> referencedResources
) implements Statement {
    public static final int MAX_PROGRAM_LENGTH = 80960;
    public static final int MAX_LABEL_LENGTH = 256;

    public static void compile(
            String programString,
            BiConsumer<Program, ASTBuilder> onSuccess,
            Consumer<List<TranslatableContents>> onFailure
    ) {
        SFMLLexer lexer = new SFMLLexer(CharStreams.fromString(programString));
        CommonTokenStream tokens = new CommonTokenStream(lexer);
        SFMLParser parser = new SFMLParser(tokens);
        ASTBuilder builder = new ASTBuilder();

        // set up error capturing
        lexer.removeErrorListeners();
        parser.removeErrorListeners();
        List<TranslatableContents> errors = new ArrayList<>();
        List<String> buildErrors = new ArrayList<>();
        ListErrorListener listener = new ListErrorListener(buildErrors);
        lexer.addErrorListener(listener);
        parser.addErrorListener(listener);

        // initial parse
        SFMLParser.ProgramContext context = parser.program();
        buildErrors.stream().map(Constants.LocalizationKeys.PROGRAM_ERROR_LITERAL::get).forEach(errors::add);

        // build AST
        Program program = null;
        try {
            program = builder.visitProgram(context);
            // make sure all referenced resources exist now during compilation instead of waiting for the program to tick

            for (ResourceIdentifier<?, ?, ?> referencedResource : program.referencedResources) {
                try {
                    ResourceType<?, ?, ?> resourceType = referencedResource.getResourceType();
                    if (resourceType == null) {
                        errors.add(Constants.LocalizationKeys.PROGRAM_WARNING_UNKNOWN_RESOURCE_TYPE.get(
                                referencedResource));
                    }
                } catch (ResourceLocationException e) {
                    errors.add(Constants.LocalizationKeys.PROGRAM_ERROR_MALFORMED_RESOURCE_TYPE.get(referencedResource));
                }
            }
        } catch (ResourceLocationException | IllegalArgumentException | AssertionError e) {
            errors.add(Constants.LocalizationKeys.PROGRAM_ERROR_LITERAL.get(e.getMessage()));
        } catch (Throwable t) {
            errors.add(Constants.LocalizationKeys.PROGRAM_ERROR_COMPILE_FAILED.get());
            SFM.LOGGER.error("Encountered unhandled error while compiling program", t);
            if (!FMLEnvironment.production) {
                var message = t.getMessage();
                if (message != null) {
                    errors.add(SFMUtils.getTranslatableContents(t.getClass().getSimpleName() + ": " + message));
                } else {
                    errors.add(SFMUtils.getTranslatableContents(t.getClass().getSimpleName()));
                }
            }
        }


        if (errors.isEmpty()) {
            onSuccess.accept(program, builder);
        } else {
            onFailure.accept(errors);
        }
    }

    public ArrayList<TranslatableContents> gatherWarnings(ItemStack disk, @Nullable ManagerBlockEntity manager) {
        var warnings = new ArrayList<TranslatableContents>();
        var labels = LabelPositionHolder.from(disk);
        // labels in code but not in world
        for (String label : referencedLabels) {
            var isUsed = !labels.getPositions(label).isEmpty();
            if (!isUsed) {
                warnings.add(Constants.LocalizationKeys.PROGRAM_WARNING_UNUSED_LABEL.get(label));
            }
        }

        // labels used in world but not defined in code
        labels.get().keySet()
                .stream()
                .filter(x -> !referencedLabels.contains(x))
                .forEach(label -> warnings.add(Constants.LocalizationKeys.PROGRAM_WARNING_UNDEFINED_LABEL.get(label)));

        if (manager != null) {
            // labels in world but not connected via cables
            CableNetworkManager
                    .getOrRegisterNetworkFromManagerPosition(manager)
                    .ifPresent(network -> labels.forEach((label, pos) -> {
                var inNetwork = network.isInNetwork(pos);
                var adjacent = network.isAdjacentToCable(pos);
                if (!inNetwork) {
                    if (adjacent) {
                        warnings.add(Constants.LocalizationKeys.PROGRAM_WARNING_ADJACENT_BUT_DISCONNECTED_LABEL.get(
                                label,
                                String.format(
                                        "[%d,%d,%d]",
                                        pos.getX(),
                                        pos.getY(),
                                        pos.getZ()
                                )
                        ));
                    } else {
                        warnings.add(Constants.LocalizationKeys.PROGRAM_WARNING_DISCONNECTED_LABEL.get(
                                label,
                                String.format(
                                        "[%d,%d,%d]",
                                        pos.getX(),
                                        pos.getY(),
                                        pos.getZ()
                                )
                        ));
                    }
                }
            }));
        }

        // try and validate that references resources exist
        for (var resource : referencedResources) {
            // skip regex resources
            Optional<ResourceLocation> loc = resource.getLocation();
            if (loc.isEmpty()) continue;

            // make sure resource type is registered
            var type = resource.getResourceType();
            if (type == null) {
                warnings.add(Constants.LocalizationKeys.PROGRAM_WARNING_UNKNOWN_RESOURCE_TYPE.get(
                        resource.resourceTypeNamespace
                        + ":"
                        + resource.resourceTypeName,
                        resource
                ));
                continue;
            }

            // make sure resource exists in the registry
            if (!type.registryKeyExists(loc.get())) {
                warnings.add(Constants.LocalizationKeys.PROGRAM_WARNING_UNKNOWN_RESOURCE_ID.get(resource));
            }
        }
        return warnings;
    }

    public void fixWarnings(ItemStack disk, ManagerBlockEntity manager) {
        var labels = LabelPositionHolder.from(disk);
        // remove labels not defined in code
        labels.removeIf(label -> !referencedLabels.contains(label));

        // remove labels not connected via cables
        CableNetworkManager
                .getOrRegisterNetworkFromManagerPosition(manager)
                .ifPresent(network -> labels.removeIf((label, pos) -> !network.isInNetwork(pos)));
        labels.save(disk);

        // update warnings
        DiskItem.setWarnings(disk, gatherWarnings(disk, manager));
    }

    public boolean tick(ManagerBlockEntity manager) {
        // update warnings on disk item every 20 seconds
        if (manager.getTick() % 20 == 0) {
            manager.getDisk().ifPresent(disk -> DiskItem.setWarnings(disk, gatherWarnings(disk, manager)));
        }

        // build the context and tick the program
        var context = new ProgramContext(this, manager, ProgramContext.ExecutionPolicy.UNRESTRICTED);
        tick(context);

        manager.clearRedstonePulseQueue();
        //noinspection UnnecessaryLocalVariable
        boolean didSomething = triggers.stream().anyMatch(t -> t.shouldTick(context));
        return didSomething;
    }

    @Override
    public List<Statement> getStatements() {
        return triggers.stream().map(x -> (Statement) x).toList();
    }

    @Override
    public void tick(ProgramContext context) {
        for (Trigger t : triggers) {
            if (t.shouldTick(context)) {
                t.tick(context.copy());
            }
        }
    }

    @Override
    public String toString() {
        var rtn = new StringBuilder();
        rtn.append("NAME \"").append(name).append("\"\n");
        for (Trigger trigger : triggers) {
            rtn.append(trigger).append("\n");
        }
        return rtn.toString();
    }

    public void replaceOutputStatement(OutputStatement oldStatement, OutputStatement newStatement) {
        Deque<Statement> toPatch = new ArrayDeque<>();
        toPatch.add(this);
        while (!toPatch.isEmpty()) {
            Statement statement = toPatch.pollFirst();
            List<Statement> children = statement.getStatements();
            for (int i = 0; i < children.size(); i++) {
                Statement child = children.get(i);
                if (child == oldStatement) {
                    children.set(i, newStatement);
                } else {
                    toPatch.add(child);
                }
            }
        }
    }

    public int getConditionIndex(IfStatement statement) {
        Deque<Statement> toVisit = new ArrayDeque<>();
        toVisit.add(this);
        int seen = 0;
        while (!toVisit.isEmpty()) {
            Statement current = toVisit.pollFirst();
            if (current instanceof IfStatement ifStatement) {
                if (ifStatement == statement) {
                    return seen;
                }
                seen++;
            }
            toVisit.addAll(current.getStatements());
        }
        return -1;
    }

    public int getConditionCount() {
        Deque<Statement> toVisit = new ArrayDeque<>();
        toVisit.add(this);
        int seen = 0;
        while (!toVisit.isEmpty()) {
            Statement current = toVisit.pollFirst();
            if (current instanceof IfStatement) {
                seen++;
            }
            toVisit.addAll(current.getStatements());
        }
        return seen;
    }

    public static class ListErrorListener extends BaseErrorListener {
        private final List<String> errors;

        public ListErrorListener(List<String> errors) {
            this.errors = errors;
        }

        @Override
        public void syntaxError(
                Recognizer<?, ?> recognizer,
                Object offendingSymbol,
                int line,
                int charPositionInLine,
                String msg,
                RecognitionException e
        ) {
            errors.add("line " + line + ":" + charPositionInLine + " " + msg);
        }
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfml\ast\ASTBuilder.java

````java
package ca.teamdman.sfml.ast;

import ca.teamdman.sfml.SFMLBaseVisitor;
import ca.teamdman.sfml.SFMLParser;
import org.antlr.v4.runtime.ParserRuleContext;
import org.antlr.v4.runtime.misc.Pair;
import org.antlr.v4.runtime.tree.ParseTree;

import javax.annotation.Nullable;
import java.util.*;
import java.util.stream.Collectors;

public class ASTBuilder extends SFMLBaseVisitor<ASTNode> {
    private final Set<Label> USED_LABELS = new HashSet<>();
    private final Set<ResourceIdentifier<?, ?, ?>> USED_RESOURCES = new HashSet<>();
    private final List<Pair<ASTNode, ParserRuleContext>> AST_NODE_CONTEXTS = new LinkedList<>();

    public List<Pair<ASTNode, ParserRuleContext>> getNodesUnderCursor(int cursorPos) {
        return AST_NODE_CONTEXTS
                .stream()
                .filter(pair -> pair.b != null)
                .filter(pair -> pair.b.start.getStartIndex() <= cursorPos && pair.b.stop.getStopIndex() >= cursorPos)
                .collect(Collectors.toList());
    }

    public Optional<ASTNode> getNodeAtIndex(int index) {
        if (index < 0 || index >= AST_NODE_CONTEXTS.size()) return Optional.empty();
        return Optional.ofNullable(AST_NODE_CONTEXTS.get(index).a);
    }

    public int getIndexForNode(ASTNode node) {
        return AST_NODE_CONTEXTS
                .stream()
                .filter(pair -> pair.a == node)
                .map(AST_NODE_CONTEXTS::indexOf)
                .findFirst()
                .orElse(-1);
    }

    @Override
    public StringHolder visitName(@Nullable SFMLParser.NameContext ctx) {
        if (ctx == null) return new StringHolder("");
        StringHolder name = visitString(ctx.string());
        AST_NODE_CONTEXTS.add(new Pair<>(name, ctx));
        return name;
    }

    @Override
    public ASTNode visitResource(SFMLParser.ResourceContext ctx) {
        var str = ctx
                .children
                .stream()
                .map(ParseTree::getText)
                .collect(Collectors.joining())
                .replaceAll("::", ":*:")
                .replaceAll(":$", ":*")
                .replaceAll("\\*", ".*");
        var rtn = ResourceIdentifier.fromString(str);
        USED_RESOURCES.add(rtn);
        rtn.assertValid();
        AST_NODE_CONTEXTS.add(new Pair<>(rtn, ctx));
        return rtn;
    }

    @Override
    public ResourceIdentifier<?, ?, ?> visitStringResource(SFMLParser.StringResourceContext ctx) {
        var rtn = ResourceIdentifier.fromString(visitString(ctx.string()).value());
        USED_RESOURCES.add(rtn);
        rtn.assertValid();
        AST_NODE_CONTEXTS.add(new Pair<>(rtn, ctx));
        return rtn;
    }

    @Override
    public StringHolder visitString(SFMLParser.StringContext ctx) {
        var content = ctx.getText();
        StringHolder str = new StringHolder(content.substring(1, content.length() - 1));
        AST_NODE_CONTEXTS.add(new Pair<>(str, ctx));
        return str;
    }

    @Override
    public Label visitRawLabel(SFMLParser.RawLabelContext ctx) {
        var label = new Label(ctx.getText());
        if (label.name().length() > Program.MAX_LABEL_LENGTH) {
            throw new IllegalArgumentException("Label name cannot be longer than "
                                               + Program.MAX_LABEL_LENGTH
                                               + " characters.");
        }
        USED_LABELS.add(label);
        AST_NODE_CONTEXTS.add(new Pair<>(label, ctx));
        return label;
    }

    @Override
    public Label visitStringLabel(SFMLParser.StringLabelContext ctx) {
        var label = new Label(visitString(ctx.string()).value());
        if (label.name().length() > Program.MAX_LABEL_LENGTH) {
            throw new IllegalArgumentException("Label name cannot be longer than "
                                               + Program.MAX_LABEL_LENGTH
                                               + " characters.");
        }
        USED_LABELS.add(label);
        AST_NODE_CONTEXTS.add(new Pair<>(label, ctx));
        return label;
    }

    @Override
    public Program visitProgram(SFMLParser.ProgramContext ctx) {
        var name = visitName(ctx.name());
        var triggers = ctx
                .trigger()
                .stream()
                .map(this::visit)
                .map(Trigger.class::cast)
                .collect(Collectors.toList());
        var labels = USED_LABELS
                .stream()
                .map(Label::name)
                .collect(Collectors.toSet());
        Program program = new Program(name.value(), triggers, labels, USED_RESOURCES);
        AST_NODE_CONTEXTS.add(new Pair<>(program, ctx));
        return program;
    }

    @Override
    public ASTNode visitTimerTrigger(SFMLParser.TimerTriggerContext ctx) {
        var time = (Interval) visit(ctx.interval());
        if (time.getSeconds() < 1) throw new IllegalArgumentException("Minimum trigger interval is 1 second.");
        var block = visitBlock(ctx.block());
        TimerTrigger timerTrigger = new TimerTrigger(time, block);
        AST_NODE_CONTEXTS.add(new Pair<>(timerTrigger, ctx));
        return timerTrigger;
    }

    @Override
    public ASTNode visitBooleanRedstone(SFMLParser.BooleanRedstoneContext ctx) {
        ComparisonOperator comp = ComparisonOperator.GREATER_OR_EQUAL;
        Number num = new Number(0);
        if (ctx.comparisonOp() != null && ctx.number() != null) {
            comp = visitComparisonOp(ctx.comparisonOp());
            num = visitNumber(ctx.number());
        }

        ComparisonOperator finalComp = comp;
        assert num.value() <= Integer.MAX_VALUE;
        int finalNum = (int) num.value();
        //noinspection DataFlowIssue // if the program is ticking, level shouldn't be null
        BoolExpr boolExpr = new BoolExpr(
                programContext -> finalComp.test(
                        (long) programContext
                                .getManager()
                                .getLevel()
                                .getBestNeighborSignal(programContext
                                                               .getManager()
                                                               .getBlockPos()),
                        (long) finalNum
                ),
                ctx.getText()
        );
        AST_NODE_CONTEXTS.add(new Pair<>(boolExpr, ctx));
        return boolExpr;
    }

    @Override
    public ASTNode visitPulseTrigger(SFMLParser.PulseTriggerContext ctx) {
        var block = visitBlock(ctx.block());
        RedstoneTrigger redstoneTrigger = new RedstoneTrigger(block);
        AST_NODE_CONTEXTS.add(new Pair<>(redstoneTrigger, ctx));
        return redstoneTrigger;
    }

    @Override
    public Number visitNumber(SFMLParser.NumberContext ctx) {
        Number number = new Number(Long.parseLong(ctx.getText()));
        AST_NODE_CONTEXTS.add(new Pair<>(number, ctx));
        return number;
    }

    @Override
    public Interval visitTicks(SFMLParser.TicksContext ctx) {
        var num = visitNumber(ctx.number());
        assert num.value() <= Integer.MAX_VALUE;
        Interval interval = Interval.fromTicks((int) num.value());
        AST_NODE_CONTEXTS.add(new Pair<>(interval, ctx));
        return interval;
    }

    @Override
    public Interval visitSeconds(SFMLParser.SecondsContext ctx) {
        var num = visitNumber(ctx.number());
        assert num.value() <= Integer.MAX_VALUE;
        Interval interval = Interval.fromSeconds((int) num.value());
        AST_NODE_CONTEXTS.add(new Pair<>(interval, ctx));
        return interval;
    }

    @Override
    public InputStatement visitInputStatementStatement(SFMLParser.InputStatementStatementContext ctx) {
        InputStatement input = (InputStatement) visit(ctx.inputstatement());
        AST_NODE_CONTEXTS.add(new Pair<>(input, ctx));
        return input;
    }

    @Override
    public OutputStatement visitOutputStatementStatement(SFMLParser.OutputStatementStatementContext ctx) {
        OutputStatement output = (OutputStatement) visit(ctx.outputstatement());
        AST_NODE_CONTEXTS.add(new Pair<>(output, ctx));
        return output;
    }

    @Override
    public InputStatement visitInputstatement(SFMLParser.InputstatementContext ctx) {
        var labelAccess = visitLabelaccess(ctx.labelaccess());
        var matchers = visitInputmatchers(ctx.inputmatchers());
        var exclusions = visitResourceexclusion(ctx.resourceexclusion());
        var each = ctx.EACH() != null;
        InputStatement inputStatement = new InputStatement(labelAccess, matchers.withExclusions(exclusions), each);
        AST_NODE_CONTEXTS.add(new Pair<>(inputStatement, ctx));
        return inputStatement;
    }

    @Override
    public OutputStatement visitOutputstatement(SFMLParser.OutputstatementContext ctx) {
        var labelAccess = visitLabelaccess(ctx.labelaccess());
        var matchers = visitOutputmatchers(ctx.outputmatchers());
        var exclusions = visitResourceexclusion(ctx.resourceexclusion());
        var each = ctx.EACH() != null;
        OutputStatement outputStatement = new OutputStatement(labelAccess, matchers.withExclusions(exclusions), each);
        AST_NODE_CONTEXTS.add(new Pair<>(outputStatement, ctx));
        return outputStatement;
    }

    @Override
    public LabelAccess visitLabelaccess(SFMLParser.LabelaccessContext ctx) {
        LabelAccess labelAccess = new LabelAccess(
                ctx.label().stream().map(this::visit).map(Label.class::cast).collect(Collectors.toList()),
                visitSidequalifier(ctx.sidequalifier()),
                visitSlotqualifier(ctx.slotqualifier()),
                visitRoundrobin(ctx.roundrobin())
        );
        AST_NODE_CONTEXTS.add(new Pair<>(labelAccess, ctx));
        return labelAccess;
    }

    @Override
    public RoundRobin visitRoundrobin(@Nullable SFMLParser.RoundrobinContext ctx) {
        if (ctx == null) return RoundRobin.disabled();
        return ctx.BLOCK() != null
               ? new RoundRobin(RoundRobin.Behaviour.BY_BLOCK)
               : new RoundRobin(RoundRobin.Behaviour.BY_LABEL);
    }

    @Override
    public IfStatement visitIfstatement(SFMLParser.IfstatementContext ctx) {
        var conditions = ctx
                .boolexpr()
                .stream()
                .map(this::visit)
                .map(BoolExpr.class::cast)
                .collect(Collectors.toCollection(ArrayDeque::new));
        var blocks = ctx.block().stream()
                .map(this::visitBlock)
                .collect(Collectors.toCollection(ArrayDeque::new));

        IfStatement nestedStatement;
        if (conditions.size() < blocks.size()) {
            Block elseBlock = blocks.removeLast();
            Block ifBlock = blocks.removeLast();
            nestedStatement = new IfStatement(
                    conditions.removeLast(),
                    ifBlock,
                    elseBlock
            );
        } else {
            nestedStatement = new IfStatement(
                    conditions.removeLast(),
                    blocks.removeLast(),
                    new Block(List.of())
            );
        }
        while (!blocks.isEmpty()) {
            nestedStatement = new IfStatement(
                    conditions.removeLast(),
                    blocks.removeLast(),
                    new Block(List.of(nestedStatement))
            );
        }
        assert conditions.isEmpty();

        AST_NODE_CONTEXTS.add(new Pair<>(nestedStatement, ctx));
        return nestedStatement;
    }

    @Override
    public IfStatement visitIfStatementStatement(SFMLParser.IfStatementStatementContext ctx) {
        IfStatement ifStatement = visitIfstatement(ctx.ifstatement());
        AST_NODE_CONTEXTS.add(new Pair<>(ifStatement, ctx));
        return ifStatement;
    }

    @Override
    public BoolExpr visitBooleanTrue(SFMLParser.BooleanTrueContext ctx) {
        BoolExpr boolExpr = new BoolExpr(__ -> true, "TRUE");
        AST_NODE_CONTEXTS.add(new Pair<>(boolExpr, ctx));
        return boolExpr;
    }

    @Override
    public BoolExpr visitBooleanHas(SFMLParser.BooleanHasContext ctx) {
        var setOp = visitSetOp(ctx.setOp());
        var labelAccess = visitLabelaccess(ctx.labelaccess());
        var comparison = visitResourcecomparison(ctx.resourcecomparison());
        BoolExpr booleanExpression = comparison.toBooleanExpression(
                setOp,
                labelAccess,
                setOp.name().toUpperCase() + " " + labelAccess + " HAS " + comparison
        );
        AST_NODE_CONTEXTS.add(new Pair<>(booleanExpression, ctx));
        return booleanExpression;
    }

    @Override
    public SetOperator visitSetOp(@Nullable SFMLParser.SetOpContext ctx) {
        if (ctx == null) return SetOperator.OVERALL;
        SetOperator from = SetOperator.from(ctx.getText());
        AST_NODE_CONTEXTS.add(new Pair<>(from, ctx));
        return from;
    }

    @Override
    public ResourceComparer<?, ?, ?> visitResourcecomparison(SFMLParser.ResourcecomparisonContext ctx) {
        ComparisonOperator op = visitComparisonOp(ctx.comparisonOp());
        Number num = visitNumber(ctx.number());
        ResourceQuantity quantity = new ResourceQuantity(num, ResourceQuantity.IdExpansionBehaviour.NO_EXPAND);
        ResourceIdentifier<?, ?, ?> item = (ResourceIdentifier<?, ?, ?>) visit(ctx.resourceid());
        ResourceComparer<?, ?, ?> resourceComparer = new ResourceComparer<>(op, quantity, item);
        AST_NODE_CONTEXTS.add(new Pair<>(resourceComparer, ctx));
        return resourceComparer;
    }

    @Override
    public ComparisonOperator visitComparisonOp(SFMLParser.ComparisonOpContext ctx) {
        ComparisonOperator from = ComparisonOperator.from(ctx.getText());
        AST_NODE_CONTEXTS.add(new Pair<>(from, ctx));
        return from;
    }

    @Override
    public BoolExpr visitBooleanConjunction(SFMLParser.BooleanConjunctionContext ctx) {
        var left = (BoolExpr) visit(ctx.boolexpr(0));
        var right = (BoolExpr) visit(ctx.boolexpr(1));
        BoolExpr boolExpr = new BoolExpr(left.and(right), left.sourceCode() + " AND " + right.sourceCode());
        AST_NODE_CONTEXTS.add(new Pair<>(boolExpr, ctx));
        return boolExpr;
    }

    @Override
    public BoolExpr visitBooleanDisjunction(SFMLParser.BooleanDisjunctionContext ctx) {
        var left = (BoolExpr) visit(ctx.boolexpr(0));
        var right = (BoolExpr) visit(ctx.boolexpr(1));
        BoolExpr boolExpr = new BoolExpr(left.or(right), left.sourceCode() + " OR " + right.sourceCode());
        AST_NODE_CONTEXTS.add(new Pair<>(boolExpr, ctx));
        return boolExpr;
    }

    @Override
    public BoolExpr visitBooleanFalse(SFMLParser.BooleanFalseContext ctx) {
        BoolExpr boolExpr = new BoolExpr(__ -> false, "FALSE");
        AST_NODE_CONTEXTS.add(new Pair<>(boolExpr, ctx));
        return boolExpr;
    }

    @Override
    public BoolExpr visitBooleanParen(SFMLParser.BooleanParenContext ctx) {
        BoolExpr expr = (BoolExpr) visit(ctx.boolexpr());
        AST_NODE_CONTEXTS.add(new Pair<>(expr, ctx));
        return expr;
    }

    @Override
    public BoolExpr visitBooleanNegation(SFMLParser.BooleanNegationContext ctx) {
        var x = (BoolExpr) visit(ctx.boolexpr());
        BoolExpr boolExpr = new BoolExpr(x.negate(), "NOT " + x.sourceCode());
        AST_NODE_CONTEXTS.add(new Pair<>(boolExpr, ctx));
        return boolExpr;
    }

    @Override
    public Limit visitQuantityRetentionLimit(SFMLParser.QuantityRetentionLimitContext ctx) {
        var quantity = visitQuantity(ctx.quantity());
        var retain = visitRetention(ctx.retention());
        Limit limit = new Limit(quantity, retain);
        AST_NODE_CONTEXTS.add(new Pair<>(limit, ctx));
        return limit;
    }

    @Override
    public ResourceIdSet visitResourceexclusion(@Nullable SFMLParser.ResourceexclusionContext ctx) {
        if (ctx == null) return ResourceIdSet.EMPTY;
        ResourceIdSet resourceIdSet = new ResourceIdSet(ctx
                                                                .resourceid()
                                                                .stream()
                                                                .map(this::visit)
                                                                .map(ResourceIdentifier.class::cast)
                                                                .collect(HashSet::new, HashSet::add, HashSet::addAll));
        AST_NODE_CONTEXTS.add(new Pair<>(resourceIdSet, ctx));
        return resourceIdSet;
    }

    @Override
    public ResourceLimits visitInputmatchers(@Nullable SFMLParser.InputmatchersContext ctx) {
        if (ctx == null) {
            return new ResourceLimits(List.of(ResourceLimit.TAKE_ALL_LEAVE_NONE), ResourceIdSet.EMPTY);
        }
        ResourceLimits resourceLimits = ((ResourceLimits) visit(ctx.movement())).withDefaults(Limit.MAX_QUANTITY_NO_RETENTION);
        AST_NODE_CONTEXTS.add(new Pair<>(resourceLimits, ctx));
        return resourceLimits;
    }


    @Override
    public ResourceLimits visitOutputmatchers(@Nullable SFMLParser.OutputmatchersContext ctx) {
        if (ctx == null) {
            return new ResourceLimits(List.of(ResourceLimit.ACCEPT_ALL_WITHOUT_RESTRAINT), ResourceIdSet.EMPTY);
        }
        ResourceLimits resourceLimits = ((ResourceLimits) visit(ctx.movement())).withDefaults(Limit.MAX_QUANTITY_MAX_RETENTION);
        AST_NODE_CONTEXTS.add(new Pair<>(resourceLimits, ctx));
        return resourceLimits;
    }

    @Override
    public ASTNode visitResourceLimitMovement(SFMLParser.ResourceLimitMovementContext ctx) {
        ResourceLimits resourceLimits = new ResourceLimits(
                ctx.resourcelimit().stream()
                        .map(this::visitResourcelimit)
                        .collect(Collectors.toList()),
                ResourceIdSet.EMPTY
        );
        AST_NODE_CONTEXTS.add(new Pair<>(resourceLimits, ctx));
        return resourceLimits;
    }

    @Override
    public ResourceLimits visitLimitMovement(SFMLParser.LimitMovementContext ctx) {
        ResourceLimits resourceLimits = new ResourceLimits(
                List.of(new ResourceLimit<>(
                        ResourceIdentifier.MATCH_ALL, (Limit) this.visit(ctx.limit())
                )),
                ResourceIdSet.EMPTY
        );
        AST_NODE_CONTEXTS.add(new Pair<>(resourceLimits, ctx));
        return resourceLimits;
    }

    @Override
    public ResourceLimit<?, ?, ?> visitResourcelimit(SFMLParser.ResourcelimitContext ctx) {

        var res = (ResourceIdentifier<?, ?, ?>) visit(ctx.resourceid());

        if (ctx.limit() == null)
            return new ResourceLimit<>(res, Limit.UNSET);

        var limit = (Limit) visit(ctx.limit());
        ResourceLimit<?, ?, ?> resourceLimit = new ResourceLimit<>(res, limit);
        AST_NODE_CONTEXTS.add(new Pair<>(resourceLimit, ctx));
        return resourceLimit;
    }

    @Override
    public NumberRangeSet visitSlotqualifier(@Nullable SFMLParser.SlotqualifierContext ctx) {
        NumberRangeSet numberRangeSet = visitRangeset(ctx == null ? null : ctx.rangeset());
        AST_NODE_CONTEXTS.add(new Pair<>(numberRangeSet, ctx));
        return numberRangeSet;
    }

    @Override
    public ASTNode visitForgetStatementStatement(SFMLParser.ForgetStatementStatementContext ctx) {
        ForgetStatement statement = (ForgetStatement) visit(ctx.forgetstatement());
        AST_NODE_CONTEXTS.add(new Pair<>(statement, ctx));
        return statement;
    }

    @Override
    public ForgetStatement visitForgetstatement(SFMLParser.ForgetstatementContext ctx) {
        List<Label> labels = ctx
                .label()
                .stream()
                .map(this::visit)
                .map(Label.class::cast)
                .collect(Collectors.toList());
        if (labels.isEmpty()) {
            labels = USED_LABELS.stream().toList();
        }
        return new ForgetStatement(labels);
    }

    @Override
    public NumberRangeSet visitRangeset(@Nullable SFMLParser.RangesetContext ctx) {
        if (ctx == null) return NumberRangeSet.MAX_RANGE;
        NumberRangeSet numberRangeSet = new NumberRangeSet(ctx
                                                                   .range()
                                                                   .stream()
                                                                   .map(this::visitRange)
                                                                   .toArray(NumberRange[]::new));
        AST_NODE_CONTEXTS.add(new Pair<>(numberRangeSet, ctx));
        return numberRangeSet;
    }

    @Override
    public NumberRange visitRange(SFMLParser.RangeContext ctx) {
        var iter = ctx.number().stream().map(this::visitNumber).mapToLong(Number::value).iterator();
        var start = iter.next();
        if (iter.hasNext()) {
            var end = iter.next();
            NumberRange numberRange = new NumberRange(start, end);
            AST_NODE_CONTEXTS.add(new Pair<>(numberRange, ctx));
            return numberRange;
        } else {
            NumberRange numberRange = new NumberRange(start, start);
            AST_NODE_CONTEXTS.add(new Pair<>(numberRange, ctx));
            return numberRange;
        }
    }


    @Override
    public Limit visitRetentionLimit(SFMLParser.RetentionLimitContext ctx) {
        var retain = visitRetention(ctx.retention());
        Limit limit = new Limit(ResourceQuantity.UNSET, retain);
        AST_NODE_CONTEXTS.add(new Pair<>(limit, ctx));
        return limit;
    }

    @Override
    public Limit visitQuantityLimit(SFMLParser.QuantityLimitContext ctx) {
        var quantity = visitQuantity(ctx.quantity());
        Limit limit = new Limit(quantity, ResourceQuantity.UNSET);
        AST_NODE_CONTEXTS.add(new Pair<>(limit, ctx));
        return limit;
    }

    @Override
    public ResourceQuantity visitRetention(@Nullable SFMLParser.RetentionContext ctx) {
        if (ctx == null)
            return ResourceQuantity.UNSET;
        ResourceQuantity quantity = new ResourceQuantity(
                visitNumber(ctx.number()),
                ctx.EACH() != null
                ? ResourceQuantity.IdExpansionBehaviour.EXPAND
                : ResourceQuantity.IdExpansionBehaviour.NO_EXPAND
        );
        AST_NODE_CONTEXTS.add(new Pair<>(quantity, ctx));
        return quantity;
    }

    @Override
    public ResourceQuantity visitQuantity(@Nullable SFMLParser.QuantityContext ctx) {
        if (ctx == null) return ResourceQuantity.MAX_QUANTITY;
        ResourceQuantity quantity = new ResourceQuantity(
                visitNumber(ctx.number()),
                ctx.EACH() != null
                ? ResourceQuantity.IdExpansionBehaviour.EXPAND
                : ResourceQuantity.IdExpansionBehaviour.NO_EXPAND
        );
        AST_NODE_CONTEXTS.add(new Pair<>(quantity, ctx));
        return quantity;
    }

    @Override
    public DirectionQualifier visitSidequalifier(@Nullable SFMLParser.SidequalifierContext ctx) {
        if (ctx == null) return DirectionQualifier.NULL_DIRECTION;
        DirectionQualifier directionQualifier = new DirectionQualifier(
                EnumSet.copyOf(ctx.side().stream()
                                       .map(this::visitSide)
                                       .map(DirectionQualifier::lookup)
                                       .toList())
        );
        AST_NODE_CONTEXTS.add(new Pair<>(directionQualifier, ctx));
        return directionQualifier;
    }

    @Override
    public Side visitSide(SFMLParser.SideContext ctx) {
        Side side = Side.valueOf(ctx.getText().toUpperCase(Locale.ROOT));
        AST_NODE_CONTEXTS.add(new Pair<>(side, ctx));
        return side;
    }

    @Override
    public Block visitBlock(@Nullable SFMLParser.BlockContext ctx) {
        if (ctx == null) return new Block(Collections.emptyList());
        var statements = ctx
                .statement()
                .stream()
                .map(this::visit)
                .map(Statement.class::cast)
                .collect(Collectors.toList());
        Block block = new Block(statements);
        AST_NODE_CONTEXTS.add(new Pair<>(block, ctx));
        return block;
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfml\ast\StringHolder.java

````java
package ca.teamdman.sfml.ast;

public record StringHolder(String value) implements ASTNode {
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfml\ast\ForgetStatement.java

````java
package ca.teamdman.sfml.ast;

import ca.teamdman.sfm.common.program.ProgramContext;

import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;

public record ForgetStatement(
        List<Label> labels
) implements Statement {
    @Override
    public void tick(ProgramContext context) {
        // map-replace existing inputs with ones that exclude the union of the label access
        var newInputs = context.getInputs()
                .stream()
                .map(input -> new InputStatement(
                        new LabelAccess(
                                input.labelAccess().labels().stream()
                                        .filter(label -> !this.labels.contains(label))
                                        .collect(Collectors.toList()),
                                input.labelAccess().directions(),
                                input.labelAccess().slots(),
                                input.labelAccess().roundRobin()
                        ),
                        input.resourceLimits(),
                        input.each()
                ))
                .filter(input -> !input.labelAccess().labels().isEmpty())
                .toList();
        context.getInputs().clear();
        context.getInputs().addAll(newInputs);
    }

    @Override
    public String toString() {
        return "FORGET " + labels.stream().map(Objects::toString).collect(Collectors.joining(", "));
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfml\ast\ResourceIdentifier.java

````java
package ca.teamdman.sfml.ast;

import ca.teamdman.sfm.SFM;
import ca.teamdman.sfm.common.program.RegexCache;
import ca.teamdman.sfm.common.registry.SFMResourceTypes;
import ca.teamdman.sfm.common.resourcetype.ResourceType;
import it.unimi.dsi.fastutil.objects.Object2ObjectOpenHashMap;
import net.minecraft.ResourceLocationException;
import net.minecraft.resources.ResourceLocation;

import javax.annotation.Nullable;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.function.Predicate;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;

// resourceTypeName resourceNamespace, resourceTypeName name, resource resourceNamespace, resource name
// sfm:item:minecraft:stone
public class ResourceIdentifier<STACK, ITEM, CAP> implements ASTNode, Predicate<Object> {

    public static final ResourceIdentifier<?, ?, ?> MATCH_ALL = new ResourceIdentifier<>(
            ".*",
            ".*"
    );

    public final String resourceTypeNamespace;
    public final String resourceTypeName;
    public final String resourceNamespace;
    public final String resourceName;
    private @Nullable ResourceType<STACK, ITEM, CAP> resourceTypeCache = null;


    private final Predicate<String> resourceNamespacePredicate;
    private final Predicate<String> resourceNamePredicate;

    public ResourceIdentifier(
            String resourceTypeNamespace,
            String resourceTypeName,
            String resourceNamespace,
            String resourceName
    ) {
        this.resourceTypeNamespace = resourceTypeNamespace;
        this.resourceTypeName = resourceTypeName;
        this.resourceNamespace = resourceNamespace;
        this.resourceName = resourceName;
        this.resourceNamespacePredicate = RegexCache.buildPredicate(resourceNamespace);
        this.resourceNamePredicate = RegexCache.buildPredicate(resourceName);
    }

    public boolean matchesStack(ResourceLocation stackId) {
        return resourceNamePredicate.test(stackId.getPath()) && resourceNamespacePredicate.test(stackId.getNamespace());
    }

    public ResourceIdentifier(String value) {
        this(SFM.MOD_ID, "item", ".*", value);
    }

    public ResourceIdentifier(String namespace, String value) {
        this(SFM.MOD_ID, "item", namespace, value);
    }

    public ResourceIdentifier(String typeName, String resourceNamespace, String resourceName) {
        this(SFM.MOD_ID, typeName, resourceNamespace, resourceName);
    }

    public static <STACK, ITEM, CAP> ResourceIdentifier<STACK, ITEM, CAP> fromString(String string) {
        var parts = string.split(":");
        if (parts.length == 1) {
            return new ResourceIdentifier<>(parts[0]);
        } else if (parts.length == 2) {
            return new ResourceIdentifier<>(parts[0], parts[1]);
        } else if (parts.length == 3) {
            return new ResourceIdentifier<>(parts[0], parts[1], parts[2]);
        } else if (parts.length == 4) {
            return new ResourceIdentifier<>(parts[0], parts[1], parts[2], parts[3]);
        } else {
            throw new IllegalArgumentException("bad resource id: " + string);
        }
    }

    public void assertValid() throws IllegalArgumentException {
        try {
            if (RegexCache.isRegexPattern(this.resourceNamespace)) {
                Pattern.compile(this.resourceNamespace);
            }
            if (RegexCache.isRegexPattern(this.resourceName)) {
                Pattern.compile(this.resourceName);
            }
        } catch (PatternSyntaxException e) {
            throw new IllegalArgumentException("Invalid resource identifier pattern \""
                                               + this
                                               + "\" - "
                                               + e.getMessage());
        }
    }

    public Optional<ResourceLocation> getLocation() {
        try {
            return Optional.of(new ResourceLocation(resourceNamespace, resourceName));
        } catch (ResourceLocationException e) {
            return Optional.empty();
        }
    }

    private static final Map<ResourceIdentifier<?, ?, ?>, List<ResourceIdentifier<?, ?, ?>>> expansionCache = new Object2ObjectOpenHashMap<>();

    public boolean test(Object other) {
        ResourceType<STACK, ITEM, CAP> resourceType = getResourceType();
        return resourceType != null && resourceType.matchesStack(this, other);
    }

    public List<ResourceIdentifier<STACK, ITEM, CAP>> expand() {
        if (this.getResourceType() == SFMResourceTypes.FORGE_ENERGY.get())
            return List.of(new ResourceIdentifier<>(
                    this.resourceTypeNamespace,
                    this.resourceTypeName,
                    "forge",
                    "energy"
            ));
        if (expansionCache.containsKey(this)) {
            //noinspection unchecked,rawtypes
            return (List<ResourceIdentifier<STACK, ITEM, CAP>>) (List) expansionCache.get(this);
        }
        ResourceType<STACK, ITEM, CAP> resourceType = getResourceType();
        //noinspection DataFlowIssue // if we get here, it should have a registry
        List<ResourceIdentifier<STACK, ITEM, CAP>> rtn = resourceType.getRegistry().getEntries().stream()
                .filter(e -> matchesStack(e.getKey().location()))
                .map(e -> new ResourceIdentifier<STACK, ITEM, CAP>(
                        resourceTypeNamespace,
                        resourceTypeName,
                        e.getKey().location().getNamespace(),
                        e.getKey().location().getPath()
                )).toList();
        //noinspection unchecked,rawtypes
        expansionCache.put(this, (List) rtn);
        return rtn;
    }

    public void setResourceTypeCache(@Nullable ResourceType<STACK, ITEM, CAP> resourceTypeCache) {
        this.resourceTypeCache = resourceTypeCache;
    }

    public @Nullable ResourceType<STACK, ITEM, CAP> getResourceType() {
        if (resourceTypeCache == null) {
            //noinspection unchecked
            setResourceTypeCache((ResourceType<STACK, ITEM, CAP>) SFMResourceTypes.fastLookup(
                    resourceTypeNamespace,
                    resourceTypeName
            ));
        }
        return resourceTypeCache;
    }

    @Override
    public String toString() {
        return resourceTypeNamespace + ":" + resourceTypeName + ":" + resourceNamespace + ":" + resourceName;
    }

    public String toStringCondensed() {
        String rtn;
        if (resourceTypeNamespace.equals(SFM.MOD_ID) && resourceTypeName.equals("item")) {
            if (resourceNamespace.equals(".*")) {
                rtn = resourceName;
            } else {
                rtn = resourceNamespace + ":" + resourceName;
            }
        } else if (
                resourceTypeNamespace.equals(SFM.MOD_ID)
                && resourceTypeName.equals("forge_energy")
                && getLocation()
                        .filter(rl -> rl.equals(new ResourceLocation("forge", "energy")))
                        .isPresent()
        ) {
            rtn = "forge_energy::";
        } else if (resourceTypeNamespace.equals(SFM.MOD_ID)) {
            rtn = resourceTypeName + ":" + resourceNamespace + ":" + resourceName;
        } else {
            rtn = resourceTypeNamespace + ":" + resourceTypeName + ":" + resourceNamespace + ":" + resourceName;
        }
        return rtn;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        ResourceIdentifier<?, ?, ?> that = (ResourceIdentifier<?, ?, ?>) o;
        return Objects.equals(resourceTypeNamespace, that.resourceTypeNamespace)
               && Objects.equals(resourceTypeName, that.resourceTypeName)
               && Objects.equals(resourceNamespace, that.resourceNamespace)
               && Objects.equals(resourceName, that.resourceName);
    }

    @Override
    public int hashCode() {
        return Objects.hash(resourceTypeNamespace, resourceTypeName, resourceNamespace, resourceName);
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\compat\SFMMekanismCompat.java

````java
package ca.teamdman.sfm.common.compat;

import ca.teamdman.sfm.SFM;
import ca.teamdman.sfm.common.Constants;
import ca.teamdman.sfm.common.registry.SFMResourceTypes;
import ca.teamdman.sfm.common.resourcetype.*;
import ca.teamdman.sfml.ast.DirectionQualifier;
import mekanism.api.RelativeSide;
import mekanism.common.lib.transmitter.TransmissionType;
import mekanism.common.tile.component.TileComponentConfig;
import mekanism.common.tile.component.config.ConfigInfo;
import mekanism.common.tile.component.config.DataType;
import mekanism.common.tile.interfaces.ISideConfiguration;
import net.minecraft.core.Direction;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.world.level.block.entity.BlockEntity;
import net.minecraftforge.registries.DeferredRegister;

import java.util.HashSet;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;

public class SFMMekanismCompat {
    @SuppressWarnings("DataFlowIssue")
    public static Optional<ResourceType<?, ?, ?>> getResourceType(TransmissionType trans) {
        return switch (trans) {
            case ITEM -> Optional.of(SFMResourceTypes.ITEM.get());
            case FLUID -> Optional.of(SFMResourceTypes.FLUID.get());
            case GAS -> Optional.of(SFMResourceTypes.DEFERRED_TYPES
                                            .get()
                                            .getValue(new ResourceLocation(SFM.MOD_ID, "gas")));
            case INFUSION -> Optional.of(SFMResourceTypes.DEFERRED_TYPES
                                                 .get()
                                                 .getValue(new ResourceLocation(SFM.MOD_ID, "infusion")));
            case PIGMENT -> Optional.of(SFMResourceTypes.DEFERRED_TYPES
                                                .get()
                                                .getValue(new ResourceLocation(SFM.MOD_ID, "pigment")));
            case SLURRY -> Optional.of(SFMResourceTypes.DEFERRED_TYPES
                                               .get()
                                               .getValue(new ResourceLocation(SFM.MOD_ID, "slurry")));
            default -> Optional.empty();
        };
    }

    public static String gatherInspectionResults(BlockEntity blockEntity) {
        if (!(blockEntity instanceof ISideConfiguration sideConfiguration)) {
            return "";
        }
        StringBuilder sb = new StringBuilder();
        sb.append("-- Mekanism stuff\n");
        TileComponentConfig config = sideConfiguration.getConfig();
        for (TransmissionType type : TransmissionType.values()) {
            getResourceType(type)
                    .flatMap(resourceType -> SFMResourceTypes.DEFERRED_TYPES.get().getResourceKey(resourceType))
                    .ifPresent(resourceTypeKey -> {
                        ConfigInfo info = config.getConfig(type);
                        if (info != null) {
                            Set<Direction> outputSides = info.getSides(DataType::canOutput);
                            if (!outputSides.isEmpty()) {
                                sb
                                        .append("-- ")
                                        .append(Constants.LocalizationKeys.CONTAINER_INSPECTOR_MEKANISM_MACHINE_OUTPUTS.getString())
                                        .append("\n");
                                sb.append("INPUT ").append(resourceTypeKey.location()).append(":: FROM target ");
                                sb.append(outputSides
                                                  .stream()
                                                  .map(DirectionQualifier::directionToString)
                                                  .collect(Collectors.joining(", ")));
                                sb.append(" SIDE\n");
                            }

                            Set<Direction> inputSides = new HashSet<>();
                            for (RelativeSide side : RelativeSide.values()) {
                                DataType dataType = info.getDataType(side);
                                if (dataType == DataType.INPUT
                                    || dataType == DataType.INPUT_1
                                    || dataType == DataType.INPUT_2
                                    || dataType == DataType.INPUT_OUTPUT) {
                                    inputSides.add(side.getDirection(sideConfiguration.getDirection()));
                                }
                            }
                            if (!inputSides.isEmpty()) {
                                sb
                                        .append("-- ")
                                        .append(Constants.LocalizationKeys.CONTAINER_INSPECTOR_MEKANISM_MACHINE_INPUTS.getString())
                                        .append("\n");
                                sb.append("OUTPUT ").append(resourceTypeKey.location()).append(":: TO target ");
                                sb.append(inputSides
                                                  .stream()
                                                  .map(DirectionQualifier::directionToString)
                                                  .collect(Collectors.joining(", ")));
                                sb.append(" SIDE\n");
                            }
                        }
                    });
        }
        return sb.toString();
    }

    public static void register(DeferredRegister<ResourceType<?, ?, ?>> types) {
        types.register(
                "gas",
                GasResourceType::new
        );
        types.register(
                "infusion",
                InfuseResourceType::new
        );

        types.register(
                "pigment",
                PigmentResourceType::new
        );
        types.register(
                "slurry",
                SlurryResourceType::new
        );
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\client\registry\SFMKeyMappings.java

````java
package ca.teamdman.sfm.client.registry;

import ca.teamdman.sfm.SFM;
import ca.teamdman.sfm.common.Constants;
import com.mojang.blaze3d.platform.InputConstants;
import net.minecraft.client.KeyMapping;
import net.minecraftforge.api.distmarker.Dist;
import net.minecraftforge.client.event.RegisterKeyMappingsEvent;
import net.minecraftforge.client.settings.KeyConflictContext;
import net.minecraftforge.client.settings.KeyModifier;
import net.minecraftforge.common.util.Lazy;
import net.minecraftforge.eventbus.api.SubscribeEvent;
import net.minecraftforge.fml.common.Mod;
import org.lwjgl.glfw.GLFW;


@Mod.EventBusSubscriber(bus = Mod.EventBusSubscriber.Bus.MOD, modid = SFM.MOD_ID, value = Dist.CLIENT)

public class SFMKeyMappings {
    public static final Lazy<KeyMapping> MORE_INFO_TOOLTIP_KEY = Lazy.of(() -> new KeyMapping(
            Constants.LocalizationKeys.MORE_HOVER_INFO_KEY.key().get(),
            KeyConflictContext.GUI,
            InputConstants.Type.KEYSYM,
            GLFW.GLFW_KEY_LEFT_SHIFT,
            Constants.LocalizationKeys.SFM_KEY_CATEGORY.key().get()
    ));

    public static final Lazy<KeyMapping> CONTAINER_INSPECTOR_KEY = Lazy.of(() -> new KeyMapping(
            Constants.LocalizationKeys.CONTAINER_INSPECTOR_TOGGLE_KEY.key().get(),
            KeyConflictContext.GUI,
            KeyModifier.CONTROL,
            InputConstants.Type.KEYSYM,
            GLFW.GLFW_KEY_I,
            Constants.LocalizationKeys.SFM_KEY_CATEGORY.key().get()
    ));

    @SubscribeEvent
    public static void registerBindings(RegisterKeyMappingsEvent event) {
        event.register(MORE_INFO_TOOLTIP_KEY.get());
        event.register(CONTAINER_INSPECTOR_KEY.get());
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\net\ServerboundLabelGunUpdatePacket.java

````java
package ca.teamdman.sfm.common.net;

import ca.teamdman.sfm.common.item.LabelGunItem;
import net.minecraft.network.FriendlyByteBuf;
import net.minecraft.world.InteractionHand;
import net.minecraftforge.network.NetworkEvent;

import java.util.function.Supplier;

public record ServerboundLabelGunUpdatePacket(
        String label,
        InteractionHand hand
) {
    public static final int MAX_LABEL_LENGTH = 80;

    public static void encode(ca.teamdman.sfm.common.net.ServerboundLabelGunUpdatePacket msg, FriendlyByteBuf buf) {
        buf.writeUtf(msg.label, MAX_LABEL_LENGTH);
        buf.writeEnum(msg.hand);
    }

    public static ca.teamdman.sfm.common.net.ServerboundLabelGunUpdatePacket decode(
            FriendlyByteBuf buf
    ) {
        return new ServerboundLabelGunUpdatePacket(buf.readUtf(MAX_LABEL_LENGTH), buf.readEnum(InteractionHand.class));
    }

    public static void handle(
            ca.teamdman.sfm.common.net.ServerboundLabelGunUpdatePacket msg, Supplier<NetworkEvent.Context> ctx
    ) {
        ctx.get().enqueueWork(() -> {
            var sender = ctx.get().getSender();
            if (sender == null) {
                return;
            }
            var stack = sender.getItemInHand(msg.hand);
            if (stack.getItem() instanceof LabelGunItem) {
                LabelGunItem.setActiveLabel(stack, msg.label);
            }
        });
        ctx.get().setPacketHandled(true);
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\client\gui\screen\ProgramTemplatePickerScreen.java

````java
package ca.teamdman.sfm.client.gui.screen;

import ca.teamdman.sfm.common.Constants;
import ca.teamdman.sfm.common.registry.SFMResourceTypes;
import ca.teamdman.sfml.ast.Program;
import com.mojang.blaze3d.vertex.PoseStack;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.components.Button;
import net.minecraft.client.gui.screens.Screen;
import net.minecraft.network.chat.Component;
import net.minecraft.network.chat.MutableComponent;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.server.packs.resources.Resource;

import java.io.BufferedReader;
import java.io.IOException;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Map;
import java.util.function.Consumer;
import java.util.stream.Collectors;

public class ProgramTemplatePickerScreen extends Screen {
    private final Consumer<String> CALLBACK;

    public ProgramTemplatePickerScreen(Consumer<String> callback) {
        super(Constants.LocalizationKeys.PROGRAM_TEMPLATE_PICKER_GUI_TITLE.getComponent());
        CALLBACK = callback;
    }

    @Override
    protected void init() {
        super.init();

        //discover template programs
        var irm = Minecraft.getInstance().getResourceManager();
        Map<ResourceLocation, Resource> found = irm.listResources(
                "template_programs",
                (path) -> path.getPath().endsWith(".sfml") || path.getPath().endsWith(".sfm")
        );
        Map<String, String> templatePrograms = new HashMap<>();
        for (var entry : found.entrySet()) {
            try (BufferedReader reader = entry.getValue().openAsReader()) {
                String program = reader.lines().collect(Collectors.joining("\n"));
                if (program.contains("$REPLACE_RESOURCE_TYPES_HERE$")) {
                    var replacement = SFMResourceTypes.DEFERRED_TYPES.get().getEntries()
                            .stream()
                            .map(e -> e.getKey().location().getPath())
                            .map(e -> "INPUT " + e + ":: FROM a")
                            .collect(Collectors.joining("\n    "));
                    program = program.replace("$REPLACE_RESOURCE_TYPES_HERE$", replacement);
                }
                String finalProgram = program;
                Program.compile(
                        program,
                        (successProgram, builder) -> templatePrograms.put(
                                successProgram.name().isBlank() ? entry.getKey().toString() : successProgram.name(),
                                finalProgram
                        ),
                        failure -> templatePrograms.put(entry.getKey().toString(), finalProgram)
                );
            } catch (IOException ignored) {
            }
        }

        // add picker buttons
        {
            int i = 0;
            int buttonWidth = templatePrograms.keySet()
                                      .stream()
                                      .mapToInt(this.font::width)
                                      .max().orElse(50) + 10;
            int buttonHeight = 20;
            int paddingX = 5;
            int paddingY = 5;
            int buttonsPerRow = this.width / (buttonWidth + paddingX);
            for (var entry : templatePrograms
                    .entrySet()
                    .stream()
                    .sorted((o1, o2) -> Comparator.<String>naturalOrder().compare(o1.getKey(), o2.getKey()))
                    .toList()) {
                int x = (this.width - (buttonWidth + paddingX) * Math.min(buttonsPerRow, templatePrograms.size())) / 2
                        + paddingX
                        + (i % buttonsPerRow) * (
                        buttonWidth
                        + paddingX
                );
                int y = 50 + (i / buttonsPerRow) * (buttonHeight + paddingY);
                this.addRenderableWidget(new Button(
                        x,
                        y,
                        buttonWidth,
                        buttonHeight,
                        Component.literal(entry.getKey()),
                        (btn) -> {
                            onClose();
                            CALLBACK.accept(entry.getValue());
                        }
                ));
                i++;
            }
        }
    }


    @Override
    public void render(PoseStack pPoseStack, int pMouseX, int pMouseY, float pPartialTick) {
        this.renderBackground(pPoseStack);
        this.renderBackground(pPoseStack);
        this.renderBackground(pPoseStack);
        super.render(pPoseStack, pMouseX, pMouseY, pPartialTick);
        MutableComponent warning1 = Constants.LocalizationKeys.PROGRAM_TEMPLATE_PICKER_GUI_WARNING_1.getComponent();
        this.font.draw(
                pPoseStack,
                warning1,
                this.width / 2f - this.font.width(warning1) / 2f,
                20,
                16777215
        );
        MutableComponent warning2 = Constants.LocalizationKeys.PROGRAM_TEMPLATE_PICKER_GUI_WARNING_2.getComponent();
        this.font.draw(
                pPoseStack,
                warning2,
                this.width / 2f - this.font.width(warning2) / 2f,
                36,
                16777215
        );
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfml\ast\ComparisonOperator.java

````java
package ca.teamdman.sfml.ast;

import java.util.Locale;
import java.util.function.BiPredicate;

public enum ComparisonOperator implements ASTNode, BiPredicate<Long, Long> {
    GREATER((a, b) -> a > b),
    LESSER((a, b) -> a < b),
    EQUALS(Long::equals),
    LESSER_OR_EQUAL((a, b) -> a <= b),
    GREATER_OR_EQUAL((a, b) -> a >= b);

    private final BiPredicate<Long, Long> PRED;

    ComparisonOperator(BiPredicate<Long, Long> pred) {
        this.PRED = pred;
    }

    public static ComparisonOperator from(String text) {
        return switch (text.toUpperCase(Locale.ROOT)) {
            case "GT", ">" -> GREATER;
            case "LT", "<" -> LESSER;
            case "EQ", "=" -> EQUALS;
            case "LE", "<=" -> LESSER_OR_EQUAL;
            case "GE", ">=" -> GREATER_OR_EQUAL;
            default -> throw new IllegalArgumentException("Invalid comparison operator: " + text);
        };
    }

    public String getSourceCode() {
        return switch (this) {
            case GREATER -> ">";
            case LESSER -> "<";
            case EQUALS -> "=";
            case LESSER_OR_EQUAL -> "<=";
            case GREATER_OR_EQUAL -> ">=";
        };
    }

    @Override
    public boolean test(Long a, Long b) {
        return PRED.test(a, b);
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\program\RegexCache.java

````java
package ca.teamdman.sfm.common.program;

import it.unimi.dsi.fastutil.objects.Object2ObjectOpenHashMap;

import java.util.Map;
import java.util.function.Predicate;
import java.util.regex.Pattern;

// Having this logic inside ResourceIdentifier.java causes classloading issues lol
public class RegexCache {
    private static final Map<String, Predicate<String>> patternCache = new Object2ObjectOpenHashMap<>();

    static {
        // we want to make common match-all patterns fast
        // resource names are lowercase alphanumeric with underscores
        String[] matchAny = new String[]{
                ".",
                "[a-z0-9/._-]",
                };
        String[] suffixes = new String[]{"+", "*"};
        for (String s : matchAny) {
            for (String suffix : suffixes) {
                patternCache.put(s + suffix, s1 -> true);
                patternCache.put("^" + s + suffix, s1 -> true);
                patternCache.put("^" + s + suffix + "$", s1 -> true);
                patternCache.put(s + suffix + "$", s1 -> true);
            }
        }
    }

    public static Predicate<String> buildPredicate(String possiblePattern) {
        return isRegexPattern(possiblePattern)
               ? patternCache.computeIfAbsent(possiblePattern, x -> Pattern.compile(x).asMatchPredicate())
               : possiblePattern::equals;
    }

    public static boolean isRegexPattern(String pattern) {
        String specialChars = ".?*+^$[](){}|\\";
        for (int i = 0; i < pattern.length(); i++) {
            if (specialChars.indexOf(pattern.charAt(i)) >= 0) {
                return true;
            }
        }
        return false;
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\program\ProgramContext.java

````java
package ca.teamdman.sfm.common.program;

import ca.teamdman.sfm.common.blockentity.ManagerBlockEntity;
import ca.teamdman.sfm.common.cablenetwork.CableNetwork;
import ca.teamdman.sfm.common.cablenetwork.CableNetworkManager;
import ca.teamdman.sfml.ast.IfStatement;
import ca.teamdman.sfml.ast.InputStatement;
import ca.teamdman.sfml.ast.Program;
import net.minecraft.world.level.Level;

import java.util.ArrayList;
import java.util.List;

public class ProgramContext {
    private final Program PROGRAM;
    private final ManagerBlockEntity MANAGER;
    private final CableNetwork NETWORK;
    private final List<InputStatement> INPUTS = new ArrayList<>();
    private final Level LEVEL;
    private final ExecutionPolicy EXECUTION_POLICY;
    private final List<Branch> PATH_TAKEN = new ArrayList<>();
    private final int EXPLORATION_BRANCH_INDEX;
    private final int REDSTONE_PULSES;

    public ProgramContext(Program program, ManagerBlockEntity manager, ExecutionPolicy executionPolicy) {
        this(program, manager, executionPolicy, 0);
    }

    public ProgramContext(
            Program program,
            ManagerBlockEntity manager,
            ExecutionPolicy executionPolicy,
            int branchIndex
    ) {
        this.PROGRAM = program;
        this.MANAGER = manager;
        //noinspection OptionalGetWithoutIsPresent // program shouldn't be ticking if the network is bad
        NETWORK = CableNetworkManager
                .getOrRegisterNetworkFromManagerPosition(MANAGER)
                .get();
        assert MANAGER.getLevel() != null;
        LEVEL = MANAGER.getLevel();
        REDSTONE_PULSES = MANAGER.getUnprocessedRedstonePulseCount();
        EXECUTION_POLICY = executionPolicy;
        EXPLORATION_BRANCH_INDEX = branchIndex;
    }

    private ProgramContext(ProgramContext other) {
        PROGRAM = other.PROGRAM;
        MANAGER = other.MANAGER;
        NETWORK = other.NETWORK;
        LEVEL = other.LEVEL;
        REDSTONE_PULSES = other.REDSTONE_PULSES;
        EXECUTION_POLICY = other.EXECUTION_POLICY;
        EXPLORATION_BRANCH_INDEX = other.EXPLORATION_BRANCH_INDEX;
        INPUTS.addAll(other.INPUTS);
    }

    public ExecutionPolicy getExecutionPolicy() {
        return EXECUTION_POLICY;
    }

    public List<Branch> getExecutionPath() {
        return PATH_TAKEN;
    }

    public int getExplorationBranchIndex() {
        return EXPLORATION_BRANCH_INDEX;
    }

    public Program getProgram() {
        return PROGRAM;
    }

    public void pushPath(Branch branch) {
        this.PATH_TAKEN.add(branch);
    }

    public ProgramContext copy() {
        return new ProgramContext(this);
    }

    public int getRedstonePulses() {
        return REDSTONE_PULSES;
    }

    public enum ExecutionPolicy {
        EXPLORE_BRANCHES,
        UNRESTRICTED
    }

    public ManagerBlockEntity getManager() {
        return MANAGER;
    }

    public void addInput(InputStatement input) {
        INPUTS.add(input);
    }

    public List<InputStatement> getInputs() {
        return INPUTS;
    }


    public CableNetwork getNetwork() {
        return NETWORK;
    }

    public record Branch(
            IfStatement ifStatement,
            boolean wasTrue
    ) {
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\client\jei\FallingAnvilRecipe.java

````java
package ca.teamdman.sfm.client.jei;

public class FallingAnvilRecipe {

}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\registry\SFMRecipeSerializers.java

````java
package ca.teamdman.sfm.common.registry;

import ca.teamdman.sfm.SFM;
import ca.teamdman.sfm.common.recipe.DiskResetRecipe;
import ca.teamdman.sfm.common.recipe.PrintingPressRecipe;
import net.minecraft.world.item.crafting.RecipeSerializer;
import net.minecraft.world.item.crafting.SimpleRecipeSerializer;
import net.minecraftforge.eventbus.api.IEventBus;
import net.minecraftforge.registries.DeferredRegister;
import net.minecraftforge.registries.ForgeRegistries;
import net.minecraftforge.registries.RegistryObject;

public class SFMRecipeSerializers {
    private static final DeferredRegister<RecipeSerializer<?>> RECIPE_SERIALIZERS = DeferredRegister.create(
            ForgeRegistries.RECIPE_SERIALIZERS,
            SFM.MOD_ID
    );

    public static final RegistryObject<RecipeSerializer<PrintingPressRecipe>> PRINTING_PRESS = RECIPE_SERIALIZERS.register(
            "printing_press",
            PrintingPressRecipe.Serializer::new
    );

    public static final RegistryObject<SimpleRecipeSerializer<DiskResetRecipe>> DISK_RESET = RECIPE_SERIALIZERS.register(
            "disk_reset",
            () -> new SimpleRecipeSerializer<>(DiskResetRecipe::new)
    );

    public static void register(IEventBus bus) {
        RECIPE_SERIALIZERS.register(bus);
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\capabilityprovidermapper\BlockEntityCapabilityProviderMapper.java

````java
package ca.teamdman.sfm.common.capabilityprovidermapper;

import net.minecraft.core.BlockPos;
import net.minecraft.world.level.LevelAccessor;
import net.minecraftforge.common.capabilities.ICapabilityProvider;

import java.util.Optional;

public class BlockEntityCapabilityProviderMapper implements CapabilityProviderMapper {
    @Override
    public Optional<ICapabilityProvider> getProviderFor(LevelAccessor level, BlockPos pos) {
        return Optional.ofNullable(level.getBlockEntity(pos));
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfml\ast\Side.java

````java
package ca.teamdman.sfml.ast;

public enum Side implements ASTNode {
    TOP,
    BOTTOM,
    NORTH,
    SOUTH,
    EAST,
    WEST
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfml\ast\Trigger.java

````java
package ca.teamdman.sfml.ast;

import ca.teamdman.sfm.common.program.ProgramContext;

import java.util.List;

public interface Trigger extends Statement {
    boolean shouldTick(ProgramContext context);

    Block getBlock();

    @Override
    default List<Statement> getStatements() {
        return List.of(getBlock());
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\block\ManagerBlock.java

````java
package ca.teamdman.sfm.common.block;

import ca.teamdman.sfm.common.blockentity.ManagerBlockEntity;
import ca.teamdman.sfm.common.cablenetwork.CableNetworkManager;
import ca.teamdman.sfm.common.cablenetwork.ICableBlock;
import ca.teamdman.sfm.common.containermenu.ManagerContainerMenu;
import ca.teamdman.sfm.common.registry.SFMBlockEntities;
import net.minecraft.core.BlockPos;
import net.minecraft.server.level.ServerLevel;
import net.minecraft.server.level.ServerPlayer;
import net.minecraft.world.Container;
import net.minecraft.world.Containers;
import net.minecraft.world.InteractionHand;
import net.minecraft.world.InteractionResult;
import net.minecraft.world.entity.player.Player;
import net.minecraft.world.level.Level;
import net.minecraft.world.level.block.*;
import net.minecraft.world.level.block.entity.BlockEntity;
import net.minecraft.world.level.block.entity.BlockEntityTicker;
import net.minecraft.world.level.block.entity.BlockEntityType;
import net.minecraft.world.level.block.state.BlockBehaviour;
import net.minecraft.world.level.block.state.BlockState;
import net.minecraft.world.level.block.state.StateDefinition;
import net.minecraft.world.level.block.state.properties.BlockStateProperties;
import net.minecraft.world.level.block.state.properties.BooleanProperty;
import net.minecraft.world.level.material.Material;
import net.minecraft.world.phys.BlockHitResult;
import net.minecraftforge.network.NetworkHooks;

import javax.annotation.Nullable;

public class ManagerBlock extends BaseEntityBlock implements EntityBlock, ICableBlock {
    public static final BooleanProperty TRIGGERED = BlockStateProperties.TRIGGERED;

    public ManagerBlock() {
        super(BlockBehaviour.Properties
                      .of(Material.PISTON)
                      .destroyTime(2)
                      .sound(SoundType.METAL));
        registerDefaultState(getStateDefinition().any().setValue(TRIGGERED, false));
    }

    @Override
    protected void createBlockStateDefinition(StateDefinition.Builder<Block, BlockState> builder) {
        builder.add(TRIGGERED);
    }

    @SuppressWarnings("deprecation")
    public RenderShape getRenderShape(BlockState state) {
        return RenderShape.MODEL;
    }


    @Override
    @SuppressWarnings("deprecation")
    public void neighborChanged(
            BlockState state,
            Level level,
            BlockPos pos,
            Block block,
            BlockPos neighbourPos,
            boolean movedByPiston
    ) {
        if (!(level.getBlockEntity(pos) instanceof ManagerBlockEntity mgr)) return;
        if (!(level instanceof ServerLevel)) return;
        { // update cable network
            // reassess neighbours of the CABLE's position
            CableNetworkManager
                    .getOrRegisterNetworkFromCablePosition(level, pos)
                    .ifPresent(network -> network.rebuildAdjacentInventories(pos));
        }
        { // check redstone for triggers
            var isPowered = level.hasNeighborSignal(pos) || level.hasNeighborSignal(pos.above());
            var debounce  = state.getValue(TRIGGERED);
            if (isPowered && !debounce) {
                mgr.trackRedstonePulseUnprocessed();
                level.setBlock(pos, state.setValue(TRIGGERED, true), 4);
            } else if (!isPowered && debounce) {
                level.setBlock(pos, state.setValue(TRIGGERED, false), 4);
            }
        }
    }

    @Override
    public BlockEntity newBlockEntity(BlockPos pos, BlockState state) {
        return SFMBlockEntities.MANAGER_BLOCK_ENTITY
                .get()
                .create(pos, state);
    }

    @Override
    @SuppressWarnings("deprecation")
    public InteractionResult use(
            BlockState state,
            Level level,
            BlockPos pos,
            Player player,
            InteractionHand hand,
            BlockHitResult hit
    ) {
        if (level.getBlockEntity(pos) instanceof ManagerBlockEntity manager && player instanceof ServerPlayer sp) {
            NetworkHooks.openScreen(sp, manager, buf -> ManagerContainerMenu.encode(manager, buf));
            return InteractionResult.CONSUME;
        }
        return InteractionResult.SUCCESS;
    }

    @Nullable
    @Override
    public <T extends BlockEntity> BlockEntityTicker<T> getTicker(
            Level level,
            BlockState state,
            BlockEntityType<T> type
    ) {
        if (level.isClientSide()) return null;
        return createTickerHelper(type, SFMBlockEntities.MANAGER_BLOCK_ENTITY.get(), ManagerBlockEntity::serverTick);
    }

    @Override
    @SuppressWarnings("deprecation")
    public void onPlace(BlockState state, Level world, BlockPos pos, BlockState oldState, boolean isMoving) {
        CableNetworkManager.getOrRegisterNetworkFromCablePosition(world, pos);
    }

    @Override
    @SuppressWarnings("deprecation")
    public void onRemove(BlockState state, Level level, BlockPos pos, BlockState newState, boolean isMoving) {
        if (!state.is(newState.getBlock())) {
            if (level.getBlockEntity(pos) instanceof Container container) {
                Containers.dropContents(level, pos, container);
                level.updateNeighbourForOutputSignal(pos, this);
            }
            CableNetworkManager.removeCable(level, pos);
            super.onRemove(state, level, pos, newState, isMoving);
        }
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\recipe\NotContainer.java

````java
package ca.teamdman.sfm.common.recipe;

import net.minecraft.world.Container;
import net.minecraft.world.entity.player.Player;
import net.minecraft.world.item.Item;
import net.minecraft.world.item.ItemStack;

import java.util.Set;
import java.util.function.Predicate;

/**
 * Recipe stuff wants your block entities to be Containers to do stuff.
 * I don't want to use a Container when the block has no GUI.
 * This is a hack to make the recipe stuff happy.
 */
@SuppressWarnings("RedundantMethodOverride")
public interface NotContainer extends Container {

    @Override
    default void clearContent() {
    }

    @Override
    default int getContainerSize() {
        return 0;
    }

    @Override
    default boolean isEmpty() {
        return true;
    }

    @Override
    default ItemStack getItem(int pSlot) {
        return ItemStack.EMPTY;
    }

    @Override
    default ItemStack removeItem(int pSlot, int pAmount) {
        return ItemStack.EMPTY;

    }

    @Override
    default ItemStack removeItemNoUpdate(int pSlot) {
        return ItemStack.EMPTY;
    }

    @Override
    default void setItem(int pSlot, ItemStack pStack) {
    }

    @Override
    default int getMaxStackSize() {
        return 0;
    }

    @Override
    default void setChanged() {
    }

    @Override
    default boolean stillValid(Player pPlayer) {
        return false;
    }

    @Override
    default void startOpen(Player pPlayer) {
    }

    @Override
    default void stopOpen(Player pPlayer) {
    }

    @Override
    default boolean canPlaceItem(int pIndex, ItemStack pStack) {
        return false;
    }

    @Override
    default int countItem(Item pItem) {
        return 0;
    }

    @Override
    default boolean hasAnyOf(Set<Item> pSet) {
        return false;
    }

    @Override
    default boolean hasAnyMatching(Predicate<ItemStack> p_216875_) {
        return false;
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\cablenetwork\CableNetworkManager.java

````java
package ca.teamdman.sfm.common.cablenetwork;

import ca.teamdman.sfm.SFM;
import ca.teamdman.sfm.common.blockentity.ManagerBlockEntity;
import net.minecraft.core.BlockPos;
import net.minecraft.world.level.Level;
import net.minecraftforge.fml.common.Mod;

import javax.annotation.Nullable;
import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * Helper class to memorize the relevant chains of inventory cables.
 * <p>
 * Rather than looking up the connected cable blocks for each manager each tick,
 * this class aims to keep track of the chains instead.
 * Adding or removing cable blocks that invoke the relevant methods for this class
 * will help build the network.
 * <p>
 * Adding cables can do one of:
 * - append to existing network
 * - cause two existing networks to join
 * - create a new network
 * <p>
 * Removing cables can:
 * - Remove it from the network
 * - Remove the network if it was the only member
 * - Cause a network to split into other networks if it was a "bridge" block
 */
@Mod.EventBusSubscriber(bus = Mod.EventBusSubscriber.Bus.FORGE, modid = SFM.MOD_ID)
public class CableNetworkManager {

    private static final Map<Level, List<CableNetwork>> NETWORKS = new WeakHashMap<>();

    /**
     * Remove a block from any networks it is in. Then, prune any empty networks.
     */
    public static void removeCable(Level level, BlockPos cablePos) {
        getNetworkFromCablePosition(level, cablePos).ifPresent(network -> {
            removeNetwork(network);
            var newNetworks = network.withoutCable(cablePos);
            newNetworks.forEach(CableNetworkManager::addNetwork);
        });
    }

    public static Optional<CableNetwork> getOrRegisterNetworkFromManagerPosition(ManagerBlockEntity tile) {
        return getOrRegisterNetworkFromCablePosition(tile.getLevel(), tile.getBlockPos());
    }

    public static Optional<CableNetwork> getNetworkFromPosition(Level level, BlockPos pos) {
        return getNetworksForLevel(level)
                .filter(net -> net.CABLE_POSITIONS.contains(pos.asLong())
                               || net.CAPABILITY_PROVIDER_BY_POSITION.containsKey(pos.asLong()))
                .findFirst();
    }

    public static Stream<CableNetwork> getNetworksForLevel(Level level) {
        return NETWORKS.getOrDefault(level, Collections.emptyList())
                .stream()
                .filter(net -> net.getLevel().isClientSide() == level.isClientSide());
    }

    private static Optional<CableNetwork> getNetworkFromCablePosition(Level level, BlockPos pos) {
        return getNetworksForLevel(level)
                .filter(net -> net.containsCablePosition(pos))
                .findFirst();
    }

    private static void removeNetwork(CableNetwork network) {
        NETWORKS.getOrDefault(network.getLevel(), Collections.emptyList()).remove(network);
    }

    private static void addNetwork(CableNetwork network) {
        NETWORKS.computeIfAbsent(network.getLevel(), k -> new ArrayList<>()).add(network);
    }

    /**
     * Finds the set of networks that contain the given position
     */
    private static Set<CableNetwork> getCandidateNetworks(Level level, BlockPos pos) {
        return getNetworksForLevel(level)
                .filter(net -> net.isAdjacentToCable(pos))
                .collect(Collectors.toSet());
    }


    private static Optional<CableNetwork> mergeNetworks(Set<CableNetwork> networks) {
        if (networks.isEmpty()) return Optional.empty();

        Iterator<CableNetwork> iterator = networks.iterator();
        CableNetwork main = iterator.next();

        // Merge the rest into the first
        iterator.forEachRemaining(other -> {
            main.mergeNetwork(other);
            removeNetwork(other);
        });

        return Optional.of(main);
    }

    public static void unregisterNetworkForTestingPurposes(CableNetwork network) {
        removeNetwork(network);
    }

    /**
     * Gets the cable network object. If none exists and one should, it will create and populate
     * one.
     * <p>
     * Networks should only exist on the server side.
     */
    public static Optional<CableNetwork> getOrRegisterNetworkFromCablePosition(@Nullable Level level, BlockPos pos) {
        if (level == null) return Optional.empty();
        if (level.isClientSide()) return Optional.empty();

        // only cables define the main spine of a network
        if (!CableNetwork.isCable(level, pos)) return Optional.empty();

        // discover existing network for this position
        Optional<CableNetwork> existing = getNetworkFromCablePosition(level, pos);
        if (existing.isPresent()) return existing;

        // find potential networks
        Set<CableNetwork> candidates = getCandidateNetworks(level, pos);

        // no candidates, create new network
        if (candidates.isEmpty()) {
            CableNetwork network = new CableNetwork(level);
            addNetwork(network);
            // rebuild network from world
            // might be first time used after loading from disk
            network.rebuildNetwork(pos);
            return Optional.of(network);
        }

        // one candidate exists, add the cable to it
        if (candidates.size() == 1) {
            // Only one network matches this cable, add cable as member
            CableNetwork network = candidates.iterator().next();
            network.addCable(pos);
            return Optional.of(network);
        }

        // more than one candidate network exists, merge them
        Optional<CableNetwork> result = mergeNetworks(candidates);
        result.ifPresent(net -> net.addCable(pos));
        return result;
    }


    public static List<BlockPos> getBadCableCachePositions(Level level) {
        return getNetworksForLevel(level)
                .flatMap(CableNetwork::getCablePositions)
                .filter(pos -> !(level.getBlockState(pos).getBlock() instanceof ICableBlock))
                .collect(Collectors.toList());
    }

    public static void clear() {
        NETWORKS.clear();
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\resourcetype\PigmentResourceType.java

````java
package ca.teamdman.sfm.common.resourcetype;

import mekanism.api.Action;
import mekanism.api.MekanismAPI;
import mekanism.api.chemical.pigment.IPigmentHandler;
import mekanism.api.chemical.pigment.Pigment;
import mekanism.api.chemical.pigment.PigmentStack;
import net.minecraftforge.common.capabilities.Capability;
import net.minecraftforge.common.capabilities.CapabilityToken;
import net.minecraftforge.registries.IForgeRegistry;

import static net.minecraftforge.common.capabilities.CapabilityManager.get;

public class PigmentResourceType extends ResourceType<PigmentStack, Pigment, IPigmentHandler> {
    public static final Capability<IPigmentHandler> CAP = get(new CapabilityToken<>() {
    });

    public PigmentResourceType() {
        super(CAP);
    }

    @Override
    public long getAmount(PigmentStack stack) {
        return stack.getAmount();
    }

    @Override
    public PigmentStack getStackInSlot(IPigmentHandler handler, int slot) {
        return handler.getChemicalInTank(slot);
    }

    @Override
    public PigmentStack extract(IPigmentHandler handler, int slot, long amount, boolean simulate) {
        return handler.extractChemical(slot, amount, simulate ? Action.SIMULATE : Action.EXECUTE);
    }

    @Override
    public int getSlots(IPigmentHandler handler) {
        return handler.getTanks();
    }

    @Override
    public long getMaxStackSize(PigmentStack stack) {
        return Long.MAX_VALUE;
    }

    @Override
    public long getMaxStackSize(IPigmentHandler handler, int slot) {
        return handler.getTankCapacity(slot);
    }

    @Override
    public PigmentStack insert(
            IPigmentHandler handler,
            int slot,
            PigmentStack stack,
            boolean simulate
    ) {
        return handler.insertChemical(slot, stack, simulate ? Action.SIMULATE : Action.EXECUTE);
    }

    @Override
    public boolean isEmpty(PigmentStack stack) {
        return stack.isEmpty();
    }

    @Override
    public PigmentStack getEmptyStack() {
        return PigmentStack.EMPTY;
    }

    @Override
    public boolean matchesStackType(Object o) {
        return o instanceof PigmentStack;
    }

    @Override
    public boolean matchesCapabilityType(Object o) {
        return o instanceof IPigmentHandler;
    }


    @Override
    public IForgeRegistry<Pigment> getRegistry() {
        return MekanismAPI.pigmentRegistry();
    }

    @Override
    public Pigment getItem(PigmentStack stack) {
        return stack.getType();
    }

    @Override
    public PigmentStack copy(PigmentStack stack) {
        return stack.copy();
    }

    @Override
    protected PigmentStack setCount(PigmentStack stack, long amount) {
        stack.setAmount(amount);
        return stack;
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\program\LimitedInputSlotObjectPool.java

````java
package ca.teamdman.sfm.common.program;

import java.util.Arrays;
import java.util.List;

/**
 * A pool of {@link LimitedInputSlot} objects to avoid the garbage collector
 * <p>
 * This assumes that the pool will be used in a single thread.
 */
public class LimitedInputSlotObjectPool {
    @SuppressWarnings("rawtypes")
    private LimitedInputSlot[] pool = new LimitedInputSlot[1];
    private int index = -1;

    /**
     * Acquire a {@link LimitedInputSlot} from the pool, or creates a new one if none available
     */
    public <STACK, ITEM, CAP> LimitedInputSlot<STACK, ITEM, CAP> acquire(
            CAP handler,
            int slot,
            InputResourceTracker<STACK, ITEM, CAP> tracker
    ) {
        if (index == -1) {
            return new LimitedInputSlot<>(handler, slot, tracker);
        } else {
            @SuppressWarnings("unchecked") LimitedInputSlot<STACK, ITEM, CAP> obj = pool[index];
            index--;
            obj.init(handler, slot, tracker);
            return obj;
        }
    }

    /**
     * Release a {@link LimitedInputSlot} back into the pool for it to be reused instead of garbage collected
     */
    public void release(LimitedInputSlot<?, ?, ?> obj) {
        if (index == pool.length - 1) {
            // we need to grow the array
            pool = Arrays.copyOf(pool, pool.length * 2);
        }
        pool[++index] = obj;
    }

    /**
     * Release a {@link LimitedInputSlot} back into the pool for it to be reused instead of garbage collected
     */
    @SuppressWarnings("rawtypes")
    public void release(List<LimitedInputSlot> slots) {
        // handle resizing
        if (index + slots.size() >= pool.length) {
            int slotsFree = pool.length - index - 1;
            int newLength = pool.length + slots.size() - slotsFree;
            pool = Arrays.copyOf(pool, newLength);
        }
        // add to pool
        for (LimitedInputSlot slot : slots) {
            index++;
            pool[index] = slot;
        }
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\net\ServerboundManagerProgramPacket.java

````java
package ca.teamdman.sfm.common.net;

import ca.teamdman.sfm.common.blockentity.ManagerBlockEntity;
import ca.teamdman.sfm.common.containermenu.ManagerContainerMenu;
import ca.teamdman.sfm.common.registry.SFMPackets;
import ca.teamdman.sfml.ast.Program;
import net.minecraft.core.BlockPos;
import net.minecraft.network.FriendlyByteBuf;
import net.minecraftforge.network.NetworkEvent;

import java.util.function.Supplier;

public record ServerboundManagerProgramPacket(
        int windowId,
        BlockPos pos,
        String program
) {

    public static void encode(ServerboundManagerProgramPacket msg, FriendlyByteBuf friendlyByteBuf) {
        friendlyByteBuf.writeVarInt(msg.windowId());
        friendlyByteBuf.writeBlockPos(msg.pos());
        friendlyByteBuf.writeUtf(msg.program(), Program.MAX_PROGRAM_LENGTH);
    }

    public static ServerboundManagerProgramPacket decode(FriendlyByteBuf friendlyByteBuf) {
        return new ServerboundManagerProgramPacket(
                friendlyByteBuf.readVarInt(),
                friendlyByteBuf.readBlockPos(),
                friendlyByteBuf.readUtf(Program.MAX_PROGRAM_LENGTH)
        );
    }

    public static void handle(ServerboundManagerProgramPacket msg, Supplier<NetworkEvent.Context> contextSupplier) {
        SFMPackets.handleServerboundContainerPacket(
                contextSupplier,
                ManagerContainerMenu.class,
                ManagerBlockEntity.class,
                msg.pos,
                msg.windowId,
                (menu, manager) -> manager.setProgram(msg.program())
        );
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\net\ServerboundDiskItemSetProgramPacket.java

````java
package ca.teamdman.sfm.common.net;

import ca.teamdman.sfm.common.item.DiskItem;
import ca.teamdman.sfml.ast.Program;
import net.minecraft.network.FriendlyByteBuf;
import net.minecraft.world.InteractionHand;
import net.minecraftforge.network.NetworkEvent;

import java.util.function.Supplier;

public record ServerboundDiskItemSetProgramPacket(
        String programString,
        InteractionHand hand
) {

    public static void encode(ServerboundDiskItemSetProgramPacket msg, FriendlyByteBuf buf) {
        buf.writeUtf(msg.programString, Program.MAX_PROGRAM_LENGTH);
        buf.writeEnum(msg.hand);
    }

    public static ServerboundDiskItemSetProgramPacket decode(
            FriendlyByteBuf buf
    ) {
        return new ServerboundDiskItemSetProgramPacket(
                buf.readUtf(Program.MAX_PROGRAM_LENGTH),
                buf.readEnum(InteractionHand.class)
        );
    }

    public static void handle(
            ServerboundDiskItemSetProgramPacket msg, Supplier<NetworkEvent.Context> ctx
    ) {
        ctx.get().enqueueWork(() -> {
            var sender = ctx.get().getSender();
            if (sender == null) {
                return;
            }
            var stack = sender.getItemInHand(msg.hand);
            if (stack.getItem() instanceof DiskItem) {
                DiskItem.setProgram(stack, msg.programString);
                DiskItem.updateDetails(stack, null);
            }

        });
        ctx.get().setPacketHandled(true);
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfml\ast\Number.java

````java
package ca.teamdman.sfml.ast;

public record Number(long value) implements ASTNode {
    @Override
    public String toString() {
        return String.valueOf(value);
    }

    public Number add(Number number) {
        return new Number(value + number.value);
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\block\package-info.java

````java

@ParametersAreNonnullByDefault
@MethodsReturnNonnullByDefault
@FieldsAreNonnullByDefault
package ca.teamdman.sfm.common.block;

import net.minecraft.FieldsAreNonnullByDefault;
import net.minecraft.MethodsReturnNonnullByDefault;

import javax.annotation.ParametersAreNonnullByDefault;
````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\net\ServerboundManagerResetPacket.java

````java
package ca.teamdman.sfm.common.net;

import ca.teamdman.sfm.common.blockentity.ManagerBlockEntity;
import ca.teamdman.sfm.common.containermenu.ManagerContainerMenu;
import ca.teamdman.sfm.common.registry.SFMPackets;
import net.minecraft.core.BlockPos;
import net.minecraft.network.FriendlyByteBuf;
import net.minecraftforge.network.NetworkEvent;

import java.util.function.Supplier;

public record ServerboundManagerResetPacket(
        int windowId,
        BlockPos pos
) {
    public static void encode(ServerboundManagerResetPacket msg, FriendlyByteBuf friendlyByteBuf) {
        friendlyByteBuf.writeVarInt(msg.windowId());
        friendlyByteBuf.writeBlockPos(msg.pos());
    }

    public static ServerboundManagerResetPacket decode(FriendlyByteBuf friendlyByteBuf) {
        return new ServerboundManagerResetPacket(
                friendlyByteBuf.readVarInt(),
                friendlyByteBuf.readBlockPos()
        );
    }

    public static void handle(ServerboundManagerResetPacket msg, Supplier<NetworkEvent.Context> contextSupplier) {
        SFMPackets.handleServerboundContainerPacket(
                contextSupplier,
                ManagerContainerMenu.class,
                ManagerBlockEntity.class,
                msg.pos,
                msg.windowId,
                (menu, manager) -> manager.reset()
        );
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\client\render\FormItemRenderer.java

````java
package ca.teamdman.sfm.client.render;

import ca.teamdman.sfm.SFM;
import ca.teamdman.sfm.client.ClientStuff;
import ca.teamdman.sfm.common.item.FormItem;
import com.mojang.blaze3d.vertex.PoseStack;
import net.minecraft.client.Minecraft;
import net.minecraft.client.renderer.BlockEntityWithoutLevelRenderer;
import net.minecraft.client.renderer.ItemBlockRenderTypes;
import net.minecraft.client.renderer.MultiBufferSource;
import net.minecraft.client.renderer.block.model.ItemTransforms;
import net.minecraft.client.renderer.entity.ItemRenderer;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.world.item.ItemStack;
import net.minecraftforge.api.distmarker.Dist;
import net.minecraftforge.client.event.ModelEvent;
import net.minecraftforge.eventbus.api.SubscribeEvent;
import net.minecraftforge.fml.common.Mod;

@Mod.EventBusSubscriber(bus = Mod.EventBusSubscriber.Bus.MOD, modid = SFM.MOD_ID, value = Dist.CLIENT)
public class FormItemRenderer extends BlockEntityWithoutLevelRenderer {

    private static final ResourceLocation BASE_MODEL = new ResourceLocation(SFM.MOD_ID, "item/form_base");

    public FormItemRenderer() {
        super(Minecraft.getInstance().getBlockEntityRenderDispatcher(), Minecraft.getInstance().getEntityModels());
    }

    @SubscribeEvent
    public static void registerModels(ModelEvent.RegisterAdditional event) {
        event.register(BASE_MODEL);
    }

    // Thanks Shadows
    // https://github.com/Shadows-of-Fire/Hostile-Neural-Networks/blob/1.18/src/main/java/shadows/hostilenetworks/client/DataModelItemStackRenderer.java#L71
    // https://discord.com/channels/313125603924639766/915304642668290119/1029330876208795758
    @Override
    public void renderByItem(
            ItemStack stack,
            ItemTransforms.TransformType transformType,
            PoseStack poseStack,
            MultiBufferSource multiBuffer,
            int packedLight,
            int packedOverlay
    ) {
        if (!(stack.getItem() instanceof FormItem)) return;
        var renderer = Minecraft.getInstance().getItemRenderer();
        var baseModel = renderer.getItemModelShaper().getModelManager().getModel(BASE_MODEL);
        @SuppressWarnings("deprecation")
        var renderType = ItemBlockRenderTypes.getRenderType(stack, true);
        var buffer = ItemRenderer.getFoilBufferDirect(multiBuffer, renderType, true, stack.hasFoil());
        poseStack.pushPose();

        if (transformType != ItemTransforms.TransformType.FIXED && transformType != ItemTransforms.TransformType.GUI) {
            poseStack.scale(0.5F, 0.5F, 1F);
            poseStack.translate(0.5, 0.5, 0);
//            poseStack.mulPose(Vector3f.YP.rotationDegrees(-65));
        }

        if (ClientStuff.isMoreInfoKeyDown()) {
            poseStack.pushPose();
            poseStack.translate(0, 0.5f, 0.3f);
            poseStack.scale(0.5f, 0.5f, 0.5f);
            renderer.renderModelLists(baseModel, stack, packedLight, packedOverlay, poseStack, buffer);
            poseStack.popPose();

            var reference = FormItem.getReference(stack);
            if (!reference.isEmpty()) {
                var model = renderer.getItemModelShaper().getItemModel(reference.getItem());
                if (model != null) {
                    renderer.renderModelLists(model, stack, packedLight, packedOverlay, poseStack, buffer);
                }
            }
        } else {
            renderer.renderModelLists(baseModel, stack, packedLight, packedOverlay, poseStack, buffer);
        }

        poseStack.popPose();
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\program\LimitedInputSlot.java

````java
package ca.teamdman.sfm.common.program;

import ca.teamdman.sfm.common.resourcetype.ResourceType;

import javax.annotation.Nullable;

public class LimitedInputSlot<STACK, ITEM, CAP> {

    @SuppressWarnings("NotNullFieldNotInitialized")
    public ResourceType<STACK, ITEM, CAP> type;
    @SuppressWarnings("NotNullFieldNotInitialized")
    public CAP handler;
    public int slot;
    @SuppressWarnings("NotNullFieldNotInitialized")
    public InputResourceTracker<STACK, ITEM, CAP> tracker;
    private boolean done = false;
    private @Nullable STACK extractSimulateCache = null;

    public LimitedInputSlot(
            CAP handler, int slot, InputResourceTracker<STACK, ITEM, CAP> tracker
    ) {
        this.init(handler, slot, tracker);
    }

    public boolean isDone() {
        if (done) return true;
        // we don't bother setting done because if this returns true it should be the last time this is called
        if (tracker.isDone()) {
            return true;
        }
        STACK stack = peekExtractPotential();
        if (type.isEmpty(stack)) {
            return true;
        }
        return !tracker.test(stack);
    }

    public void setDone() {
        this.done = true;
    }

    public STACK extract(long amount) {
        extractSimulateCache = null;
        return type.extract(handler, slot, amount, false);
    }

    /**
     * Checks how much could possibly be extracted from this slot.
     * We need to simulate since there are some types of slots we can't undo an extract from.
     * You can't put something back in the output slot of a furnace.
     * This value is cached for performance.
     */
    public STACK peekExtractPotential() {
        if (extractSimulateCache == null) {
            extractSimulateCache = type.extract(handler, slot, Long.MAX_VALUE, true);
        }
        return extractSimulateCache;
    }

    public void init(CAP handler, int slot, InputResourceTracker<STACK, ITEM, CAP> tracker) {
        this.done = false;
        this.extractSimulateCache = null;
        this.handler = handler;
        this.tracker = tracker;
        this.slot = slot;
        //noinspection DataFlowIssue
        this.type = tracker.getResourceLimit().resourceId().getResourceType();
        assert type != null;
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\resourcetype\SlurryResourceType.java

````java
package ca.teamdman.sfm.common.resourcetype;

import mekanism.api.Action;
import mekanism.api.MekanismAPI;
import mekanism.api.chemical.slurry.ISlurryHandler;
import mekanism.api.chemical.slurry.Slurry;
import mekanism.api.chemical.slurry.SlurryStack;
import net.minecraftforge.common.capabilities.Capability;
import net.minecraftforge.common.capabilities.CapabilityToken;
import net.minecraftforge.registries.IForgeRegistry;

import static net.minecraftforge.common.capabilities.CapabilityManager.get;

public class SlurryResourceType extends ResourceType<SlurryStack, Slurry, ISlurryHandler> {
    public static final Capability<ISlurryHandler> CAP = get(new CapabilityToken<>() {
    });

    public SlurryResourceType() {
        super(CAP);
    }

    @Override
    public long getAmount(SlurryStack stack) {
        return stack.getAmount();
    }

    @Override
    public SlurryStack getStackInSlot(ISlurryHandler handler, int slot) {
        return handler.getChemicalInTank(slot);
    }

    @Override
    public SlurryStack extract(ISlurryHandler handler, int slot, long amount, boolean simulate) {
        return handler.extractChemical(slot, amount, simulate ? Action.SIMULATE : Action.EXECUTE);
    }

    @Override
    public int getSlots(ISlurryHandler handler) {
        return handler.getTanks();
    }

    @Override
    public long getMaxStackSize(SlurryStack stack) {
        return Long.MAX_VALUE;
    }

    @Override
    public long getMaxStackSize(ISlurryHandler handler, int slot) {
        return handler.getTankCapacity(slot);
    }

    @Override
    public SlurryStack insert(
            ISlurryHandler handler,
            int slot,
            SlurryStack stack,
            boolean simulate
    ) {
        return handler.insertChemical(slot, stack, simulate ? Action.SIMULATE : Action.EXECUTE);
    }

    @Override
    public boolean isEmpty(SlurryStack stack) {
        return stack.isEmpty();
    }

    @Override
    public SlurryStack getEmptyStack() {
        return SlurryStack.EMPTY;
    }

    @Override
    public boolean matchesStackType(Object o) {
        return o instanceof SlurryStack;
    }

    @Override
    public boolean matchesCapabilityType(Object o) {
        return o instanceof ISlurryHandler;
    }


    @Override
    public IForgeRegistry<Slurry> getRegistry() {
        return MekanismAPI.slurryRegistry();
    }

    @Override
    public Slurry getItem(SlurryStack stack) {
        return stack.getType();
    }

    @Override
    public SlurryStack copy(SlurryStack stack) {
        return stack.copy();
    }

    @Override
    protected SlurryStack setCount(SlurryStack stack, long amount) {
        stack.setAmount(amount);
        return stack;
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\net\ServerboundNetworkToolUsePacket.java

````java
package ca.teamdman.sfm.common.net;

import ca.teamdman.sfm.common.cablenetwork.CableNetworkManager;
import ca.teamdman.sfm.common.compat.SFMCompat;
import ca.teamdman.sfm.common.registry.SFMPackets;
import ca.teamdman.sfm.common.registry.SFMResourceTypes;
import ca.teamdman.sfm.common.util.SFMUtils;
import ca.teamdman.sfml.ast.DirectionQualifier;
import net.minecraft.core.BlockPos;
import net.minecraft.core.Direction;
import net.minecraft.network.FriendlyByteBuf;
import net.minecraft.resources.ResourceKey;
import net.minecraft.server.level.ServerPlayer;
import net.minecraft.world.level.Level;
import net.minecraft.world.level.block.entity.BlockEntity;
import net.minecraft.world.level.block.state.BlockState;
import net.minecraftforge.fml.loading.FMLEnvironment;
import net.minecraftforge.network.NetworkEvent;
import net.minecraftforge.network.PacketDistributor;

import java.util.function.Supplier;
import java.util.stream.Collectors;

public record ServerboundNetworkToolUsePacket(
        BlockPos blockPosition,
        Direction blockFace
) {
    public static void encode(ServerboundNetworkToolUsePacket msg, FriendlyByteBuf friendlyByteBuf) {
        friendlyByteBuf.writeBlockPos(msg.blockPosition);
        friendlyByteBuf.writeEnum(msg.blockFace);
    }

    public static ServerboundNetworkToolUsePacket decode(FriendlyByteBuf friendlyByteBuf) {
        return new ServerboundNetworkToolUsePacket(
                friendlyByteBuf.readBlockPos(),
                friendlyByteBuf.readEnum(Direction.class)
        );
    }

    public static void handle(
            ServerboundNetworkToolUsePacket msg, Supplier<NetworkEvent.Context> contextSupplier
    ) {
        contextSupplier.get().enqueueWork(() -> {
            // we don't know if the player has the program edit screen open from a manager or a disk in hand
            ServerPlayer player = contextSupplier.get().getSender();
            if (player == null) return;
            Level level = player.getLevel();
            BlockPos pos = msg.blockPosition();
            if (!level.isLoaded(pos)) return;
            StringBuilder payload = new StringBuilder()
                    .append("---- block position ----\n")
                    .append(pos)
                    .append("\n---- block state ----\n");
            BlockState state = level.getBlockState(pos);
            payload.append(state).append("\n");

            CableNetworkManager.getNetworkFromPosition(level, pos).ifPresent(net -> {
                payload.append("---- cable network ----\n");
                payload.append(net).append("\n");
            });

            BlockEntity entity = level.getBlockEntity(pos);
            if (entity != null) {
                if (!FMLEnvironment.production) {
                    payload.append("---- (dev only) block entity ----\n");
                    payload.append(entity).append("\n");
                }
                payload.append("---- capability directions ----\n");
                for (var cap : SFMCompat.getCapabilities()) {
                    payload
                            .append(cap.getName())
                            .append(": ");
                    String directions = DirectionQualifier.EVERY_DIRECTION
                            .stream()
                            .filter(dir -> entity.getCapability(cap, dir).isPresent())
                            .map(dir -> dir == null ? "NULL DIRECTION" : DirectionQualifier.directionToString(dir))
                            .collect(Collectors.joining(", ", "[", "]"));
                    payload.append(directions).append("\n");
                }
            }


            payload.append("---- exports ----\n");
            int len = payload.length();
            //noinspection unchecked,rawtypes
            SFMResourceTypes.DEFERRED_TYPES
                    .get()
                    .getEntries()
                    .forEach(entry -> payload.append(ServerboundContainerExportsInspectionRequestPacket.buildInspectionResults(
                            (ResourceKey) entry.getKey(),
                            entry.getValue(),
                            level,
                            pos,
                            msg.blockFace
                    )));
            if (payload.length() == len) {
                payload.append("No exports found");
            }
            payload.append("\n");


            if (entity != null) {
                if (player.hasPermissions(2)) {
                    payload.append("---- (op only) nbt data ----\n");
                    payload.append(entity.serializeNBT()).append("\n");
                }
            }


            SFMPackets.INSPECTION_CHANNEL.send(
                    PacketDistributor.PLAYER.with(() -> player),
                    new ClientboundInputInspectionResultsPacket(
                            SFMUtils.truncate(
                                    payload.toString(),
                                    ClientboundInputInspectionResultsPacket.MAX_RESULTS_LENGTH
                            ))
            );
        });
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\net\ServerboundContainerExportsInspectionRequestPacket.java

````java
package ca.teamdman.sfm.common.net;

import ca.teamdman.sfm.common.Constants;
import ca.teamdman.sfm.common.compat.SFMCompat;
import ca.teamdman.sfm.common.compat.SFMMekanismCompat;
import ca.teamdman.sfm.common.registry.SFMPackets;
import ca.teamdman.sfm.common.registry.SFMResourceTypes;
import ca.teamdman.sfm.common.resourcetype.ResourceType;
import ca.teamdman.sfm.common.util.SFMUtils;
import ca.teamdman.sfml.ast.*;
import it.unimi.dsi.fastutil.ints.Int2ObjectArrayMap;
import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
import net.minecraft.core.BlockPos;
import net.minecraft.core.Direction;
import net.minecraft.network.FriendlyByteBuf;
import net.minecraft.resources.ResourceKey;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.world.inventory.AbstractContainerMenu;
import net.minecraft.world.level.LevelAccessor;
import net.minecraft.world.level.block.entity.BlockEntity;
import net.minecraftforge.network.NetworkEvent;
import net.minecraftforge.network.PacketDistributor;
import net.minecraftforge.registries.ForgeRegistries;

import javax.annotation.Nullable;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.EnumSet;
import java.util.List;
import java.util.function.Supplier;

public record ServerboundContainerExportsInspectionRequestPacket(
        int windowId,
        BlockPos pos
) {
    public static void encode(ServerboundContainerExportsInspectionRequestPacket msg, FriendlyByteBuf friendlyByteBuf) {
        friendlyByteBuf.writeVarInt(msg.windowId());
        friendlyByteBuf.writeBlockPos(msg.pos());
    }

    public static ServerboundContainerExportsInspectionRequestPacket decode(FriendlyByteBuf friendlyByteBuf) {
        return new ServerboundContainerExportsInspectionRequestPacket(
                friendlyByteBuf.readVarInt(),
                friendlyByteBuf.readBlockPos()
        );
    }

    public static void handle(
            ServerboundContainerExportsInspectionRequestPacket msg,
            Supplier<NetworkEvent.Context> contextSupplier
    ) {
        SFMPackets.handleServerboundContainerPacket(
                contextSupplier,
                AbstractContainerMenu.class,
                BlockEntity.class,
                msg.pos,
                msg.windowId,
                (menu, blockEntity) -> {
                    assert blockEntity.getLevel() != null;
                    String payload = buildInspectionResults(blockEntity.getLevel(), blockEntity.getBlockPos());
                    var player = contextSupplier.get().getSender();

                    SFMPackets.INSPECTION_CHANNEL.send(
                            PacketDistributor.PLAYER.with(() -> player),
                            new ClientboundContainerExportsInspectionResultsPacket(
                                    msg.windowId,
                                    SFMUtils.truncate(
                                            payload,
                                            ClientboundContainerExportsInspectionResultsPacket.MAX_RESULTS_LENGTH
                                    )
                            )
                    );
                }
        );
    }


    public static String buildInspectionResults(LevelAccessor level, BlockPos pos) {
        StringBuilder sb = new StringBuilder();
        Direction[] dirs = Arrays.copyOf(Direction.values(), Direction.values().length + 1);
        dirs[dirs.length - 1] = null;
        for (Direction direction : dirs) {
            sb.append("-- ").append(direction).append("\n");
            int len = sb.length();
            //noinspection unchecked,rawtypes
            SFMResourceTypes.DEFERRED_TYPES
                    .get()
                    .getEntries()
                    .forEach(entry -> sb.append(buildInspectionResults(
                            (ResourceKey) entry.getKey(),
                            entry.getValue(),
                            level,
                            pos,
                            direction
                    )));
            if (sb.length() == len) {
                sb.append("No exports found");
            }
            sb.append("\n");
        }

        if (SFMCompat.isMekanismLoaded()) {
            BlockEntity be = level.getBlockEntity(pos);
            if (be != null) {
                sb.append(SFMMekanismCompat.gatherInspectionResults(be)).append("\n");
            }
        }

        return sb.toString();
    }

    public static <STACK, ITEM, CAP> String buildInspectionResults(
            ResourceKey<ResourceType<STACK, ITEM, CAP>> resourceTypeResourceKey,
            ResourceType<STACK, ITEM, CAP> resourceType,
            LevelAccessor level,
            BlockPos pos,
            @Nullable
            Direction direction
    ) {
        StringBuilder sb = new StringBuilder();
        SFMUtils
                .discoverCapabilityProvider(level, pos)
                .ifPresent(prov -> prov.getCapability(resourceType.CAPABILITY, direction).ifPresent(cap -> {
                    int slots = resourceType.getSlots(cap);
                    Int2ObjectMap<STACK> slotContents = new Int2ObjectArrayMap<>(slots);
                    for (int slot = 0; slot < slots; slot++) {
                        STACK stack = resourceType.getStackInSlot(cap, slot);
                        if (!resourceType.isEmpty(stack)) {
                            slotContents.put(slot, stack);
                        }
                    }

                    if (!slotContents.isEmpty()) {
                        slotContents.forEach((slot, stack) -> {
                            InputStatement inputStatement = SFMUtils.getInputStatementForStack(
                                    resourceTypeResourceKey,
                                    resourceType,
                                    stack,
                                    "target",
                                    slot,
                                    false,
                                    direction
                            );
                            sb.append(inputStatement.toStringPretty()).append("\n");
                        });

                        List<ResourceLimit<STACK, ITEM, CAP>> resourceLimitList = new ArrayList<>();
                        slotContents.forEach((slot, stack) -> {
                            ResourceLocation stackId = resourceType.getRegistryKey(stack);
                            ResourceIdentifier<STACK, ITEM, CAP> resourceIdentifier = new ResourceIdentifier<>(
                                    resourceTypeResourceKey.location().getNamespace(),
                                    resourceTypeResourceKey.location().getPath(),
                                    stackId.getNamespace(),
                                    stackId.getPath()
                            );
                            ResourceLimit<STACK, ITEM, CAP> resourceLimit = new ResourceLimit<>(
                                    resourceIdentifier,
                                    Limit.MAX_QUANTITY_NO_RETENTION
                            );
                            resourceLimitList.add(resourceLimit);
                        });
                        InputStatement inputStatement = new InputStatement(
                                new LabelAccess(
                                        List.of(new Label("target")),
                                        new DirectionQualifier(direction == null
                                                               ? EnumSet.noneOf(Direction.class)
                                                               : EnumSet.of(direction)),
                                        NumberRangeSet.MAX_RANGE,
                                        RoundRobin.disabled()
                                ),
                                new ResourceLimits(
                                        resourceLimitList.stream().distinct().toList(),
                                        ResourceIdSet.EMPTY
                                ),
                                false
                        );
                        sb.append(inputStatement.toStringPretty());
                    }
                }));
        String result = sb.toString();
        if (!result.isBlank()) {
            BlockEntity be = level.getBlockEntity(pos);
            //noinspection DataFlowIssue
            if (be != null && direction == null && ForgeRegistries.BLOCK_ENTITY_TYPES
                    .getKey(be.getType())
                    .getNamespace()
                    .equals("mekanism")) {
                return "-- "
                       + Constants.LocalizationKeys.CONTAINER_INSPECTOR_MEKANISM_NULL_DIRECTION_WARNING.getString()
                       + "\n"
                       + result;
            }
        }
        return result;
    }

}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfml\ast\Statement.java

````java
package ca.teamdman.sfml.ast;

import ca.teamdman.sfm.common.program.ProgramContext;

public interface Statement extends ASTNode {
    void tick(ProgramContext context);
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\item\FormItem.java

````java
package ca.teamdman.sfm.common.item;

import ca.teamdman.sfm.client.render.FormItemExtensions;
import ca.teamdman.sfm.common.registry.SFMItems;
import net.minecraft.network.chat.Component;
import net.minecraft.world.item.Item;
import net.minecraft.world.item.ItemStack;
import net.minecraft.world.item.TooltipFlag;
import net.minecraft.world.level.Level;
import net.minecraftforge.client.extensions.common.IClientItemExtensions;
import org.jetbrains.annotations.Nullable;

import java.util.List;
import java.util.function.Consumer;

public class FormItem extends Item {
    public FormItem() {
        super(new Item.Properties().tab(SFMItems.TAB));
    }

    public static ItemStack getForm(ItemStack stack) {
        var formStack = new ItemStack(SFMItems.FORM_ITEM.get());
        formStack.getOrCreateTag().put("reference", stack.serializeNBT());
        return formStack;
    }

    public static ItemStack getReference(ItemStack stack) {
        return ItemStack.of(stack.getOrCreateTag().getCompound("reference"));
    }

    @Override
    public void initializeClient(Consumer<IClientItemExtensions> consumer) {
        consumer.accept(new FormItemExtensions());
    }

    @Override
    public void appendHoverText(
            ItemStack pStack,
            @Nullable Level pLevel,
            List<Component> pTooltipComponents,
            TooltipFlag pIsAdvanced
    ) {
        if (pStack.hasTag()) {
            var reference = getReference(pStack);
            if (!reference.isEmpty()) {
                pTooltipComponents.add(reference.getHoverName());
                reference.getItem().appendHoverText(reference, pLevel, pTooltipComponents, pIsAdvanced);
            }
        }
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\item\NetworkToolItem.java

````java
package ca.teamdman.sfm.common.item;

import ca.teamdman.sfm.client.registry.SFMKeyMappings;
import ca.teamdman.sfm.common.Constants;
import ca.teamdman.sfm.common.cablenetwork.CableNetworkManager;
import ca.teamdman.sfm.common.net.ServerboundNetworkToolUsePacket;
import ca.teamdman.sfm.common.registry.SFMItems;
import ca.teamdman.sfm.common.registry.SFMPackets;
import net.minecraft.ChatFormatting;
import net.minecraft.nbt.CompoundTag;
import net.minecraft.nbt.ListTag;
import net.minecraft.nbt.NbtUtils;
import net.minecraft.network.chat.Component;
import net.minecraft.world.InteractionResult;
import net.minecraft.world.entity.Entity;
import net.minecraft.world.item.Item;
import net.minecraft.world.item.ItemStack;
import net.minecraft.world.item.TooltipFlag;
import net.minecraft.world.item.context.UseOnContext;
import net.minecraft.world.level.Level;

import javax.annotation.Nullable;
import java.util.List;

public class NetworkToolItem extends Item {
    public NetworkToolItem() {
        super(new Item.Properties().stacksTo(1).tab(SFMItems.TAB));
    }

    @Override
    public InteractionResult onItemUseFirst(ItemStack stack, UseOnContext pContext) {
        if (pContext.getLevel().isClientSide) return InteractionResult.SUCCESS;

        SFMPackets.INSPECTION_CHANNEL.sendToServer(new ServerboundNetworkToolUsePacket(
                pContext.getClickedPos(),
                pContext.getClickedFace()
        ));
        return InteractionResult.CONSUME;
    }

    @Override
    public void appendHoverText(
            ItemStack stack, @Nullable Level level, List<Component> lines, TooltipFlag detail
    ) {
        lines.add(Constants.LocalizationKeys.NETWORK_TOOL_ITEM_TOOLTIP_1.getComponent().withStyle(ChatFormatting.GRAY));
        lines.add(Constants.LocalizationKeys.NETWORK_TOOL_ITEM_TOOLTIP_2.getComponent().withStyle(ChatFormatting.GRAY));
        lines.add(Constants.LocalizationKeys.NETWORK_TOOL_ITEM_TOOLTIP_3.getComponent(
                SFMKeyMappings.CONTAINER_INSPECTOR_KEY.get().getTranslatedKeyMessage()
        ).withStyle(ChatFormatting.AQUA));
    }

    @Override
    public void inventoryTick(ItemStack pStack, Level pLevel, Entity pEntity, int pSlotId, boolean pIsSelected) {
        if (pIsSelected && !pLevel.isClientSide && pEntity.tickCount % 20 == 0) {
            final long maxDistance = 128;
            CompoundTag tag = new CompoundTag();
            ListTag networks = new ListTag();
            CableNetworkManager
                    .getNetworksForLevel(pLevel)
                    .filter(net -> net
                            .getCablePositions()
                            .anyMatch(cablePos -> cablePos.distSqr(pEntity.blockPosition())
                                                  < maxDistance * maxDistance))
                    .forEach(net -> {
                        CompoundTag networkTag = new CompoundTag();
                        networkTag.put(
                                "cable_positions",
                                net
                                        .getCablePositions()
                                        .map(NbtUtils::writeBlockPos)
                                        .collect(ListTag::new, ListTag::add, ListTag::addAll)
                        );
                        networkTag.put(
                                "capability_provider_positions",
                                net
                                        .getCapabilityProviderPositions()
                                        .map(NbtUtils::writeBlockPos)
                                        .collect(ListTag::new, ListTag::add, ListTag::addAll)
                        );
                        networks.add(networkTag);
                    });
            tag.put("networks", networks);
            pStack.setTag(tag);
        }
    }


}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfml\ast\package-info.java

````java


@ParametersAreNonnullByDefault
@MethodsReturnNonnullByDefault
@FieldsAreNonnullByDefault
package ca.teamdman.sfml.ast;

import net.minecraft.FieldsAreNonnullByDefault;
import net.minecraft.MethodsReturnNonnullByDefault;

import javax.annotation.ParametersAreNonnullByDefault;
````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\client\registry\package-info.java

````java
@ParametersAreNonnullByDefault
@MethodsReturnNonnullByDefault
@FieldsAreNonnullByDefault
package ca.teamdman.sfm.client.registry;

import net.minecraft.FieldsAreNonnullByDefault;
import net.minecraft.MethodsReturnNonnullByDefault;

import javax.annotation.ParametersAreNonnullByDefault;
````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\recipe\package-info.java

````java


@ParametersAreNonnullByDefault
@MethodsReturnNonnullByDefault
@FieldsAreNonnullByDefault
package ca.teamdman.sfm.common.recipe;

import net.minecraft.FieldsAreNonnullByDefault;
import net.minecraft.MethodsReturnNonnullByDefault;

import javax.annotation.ParametersAreNonnullByDefault;
````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\registry\SFMPackets.java

````java
package ca.teamdman.sfm.common.registry;

import ca.teamdman.sfm.SFM;
import ca.teamdman.sfm.common.net.*;
import net.minecraft.core.BlockPos;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.world.inventory.AbstractContainerMenu;
import net.minecraft.world.level.block.entity.BlockEntity;
import net.minecraftforge.network.NetworkEvent;
import net.minecraftforge.network.NetworkRegistry;
import net.minecraftforge.network.simple.SimpleChannel;

import javax.annotation.Nullable;
import java.util.function.BiConsumer;
import java.util.function.Supplier;

public class SFMPackets {
    public static final String MANAGER_CHANNEL_VERSION = "1";
    public static final String LABEL_GUN_ITEM_CHANNEL_VERSION = "1";
    public static final String DISK_ITEM_CHANNEL_VERSION = "1";
    public static final String INSPECTION_CHANNEL_VERSION = "1";
    public static final SimpleChannel MANAGER_CHANNEL = NetworkRegistry.newSimpleChannel(
            new ResourceLocation(SFM.MOD_ID, "manager"),
            MANAGER_CHANNEL_VERSION::toString,
            MANAGER_CHANNEL_VERSION::equals,
            MANAGER_CHANNEL_VERSION::equals
    );
    public static final SimpleChannel LABEL_GUN_ITEM_CHANNEL = NetworkRegistry.newSimpleChannel(
            new ResourceLocation(SFM.MOD_ID, "labelgun"),
            LABEL_GUN_ITEM_CHANNEL_VERSION::toString,
            LABEL_GUN_ITEM_CHANNEL_VERSION::equals,
            LABEL_GUN_ITEM_CHANNEL_VERSION::equals
    );
    public static final SimpleChannel DISK_ITEM_CHANNEL = NetworkRegistry.newSimpleChannel(
            new ResourceLocation(SFM.MOD_ID, "disk"),
            DISK_ITEM_CHANNEL_VERSION::toString,
            DISK_ITEM_CHANNEL_VERSION::equals,
            DISK_ITEM_CHANNEL_VERSION::equals
    );

    public static final SimpleChannel INSPECTION_CHANNEL = NetworkRegistry.newSimpleChannel(
            new ResourceLocation(SFM.MOD_ID, "inspection"),
            INSPECTION_CHANNEL_VERSION::toString,
            INSPECTION_CHANNEL_VERSION::equals,
            INSPECTION_CHANNEL_VERSION::equals
    );

    public static void register() {
        MANAGER_CHANNEL.registerMessage(
                0,
                ServerboundManagerProgramPacket.class,
                ServerboundManagerProgramPacket::encode,
                ServerboundManagerProgramPacket::decode,
                ServerboundManagerProgramPacket::handle
        );
        MANAGER_CHANNEL.registerMessage(
                1,
                ServerboundManagerResetPacket.class,
                ServerboundManagerResetPacket::encode,
                ServerboundManagerResetPacket::decode,
                ServerboundManagerResetPacket::handle
        );
        MANAGER_CHANNEL.registerMessage(
                2,
                ServerboundManagerFixPacket.class,
                ServerboundManagerFixPacket::encode,
                ServerboundManagerFixPacket::decode,
                ServerboundManagerFixPacket::handle
        );
        MANAGER_CHANNEL.registerMessage(
                3,
                ClientboundManagerGuiPacket.class,
                ClientboundManagerGuiPacket::encode,
                ClientboundManagerGuiPacket::decode,
                ClientboundManagerGuiPacket::handle
        );


        LABEL_GUN_ITEM_CHANNEL.registerMessage(
                0,
                ServerboundLabelGunUpdatePacket.class,
                ServerboundLabelGunUpdatePacket::encode,
                ServerboundLabelGunUpdatePacket::decode,
                ServerboundLabelGunUpdatePacket::handle
        );
        LABEL_GUN_ITEM_CHANNEL.registerMessage(
                1,
                ServerboundLabelGunPrunePacket.class,
                ServerboundLabelGunPrunePacket::encode,
                ServerboundLabelGunPrunePacket::decode,
                ServerboundLabelGunPrunePacket::handle
        );
        LABEL_GUN_ITEM_CHANNEL.registerMessage(
                2,
                ServerboundLabelGunClearPacket.class,
                ServerboundLabelGunClearPacket::encode,
                ServerboundLabelGunClearPacket::decode,
                ServerboundLabelGunClearPacket::handle
        );
        LABEL_GUN_ITEM_CHANNEL.registerMessage(
                3,
                ServerboundLabelGunUsePacket.class,
                ServerboundLabelGunUsePacket::encode,
                ServerboundLabelGunUsePacket::decode,
                ServerboundLabelGunUsePacket::handle
        );

        DISK_ITEM_CHANNEL.registerMessage(
                0,
                ServerboundDiskItemSetProgramPacket.class,
                ServerboundDiskItemSetProgramPacket::encode,
                ServerboundDiskItemSetProgramPacket::decode,
                ServerboundDiskItemSetProgramPacket::handle
        );

        INSPECTION_CHANNEL.registerMessage(
                0,
                ServerboundContainerExportsInspectionRequestPacket.class,
                ServerboundContainerExportsInspectionRequestPacket::encode,
                ServerboundContainerExportsInspectionRequestPacket::decode,
                ServerboundContainerExportsInspectionRequestPacket::handle
        );
        INSPECTION_CHANNEL.registerMessage(
                1,
                ClientboundContainerExportsInspectionResultsPacket.class,
                ClientboundContainerExportsInspectionResultsPacket::encode,
                ClientboundContainerExportsInspectionResultsPacket::decode,
                ClientboundContainerExportsInspectionResultsPacket::handle
        );
        INSPECTION_CHANNEL.registerMessage(
                2,
                ServerboundLabelInspectionRequestPacket.class,
                ServerboundLabelInspectionRequestPacket::encode,
                ServerboundLabelInspectionRequestPacket::decode,
                ServerboundLabelInspectionRequestPacket::handle
        );
        INSPECTION_CHANNEL.registerMessage(
                3,
                ClientboundLabelInspectionResultsPacket.class,
                ClientboundLabelInspectionResultsPacket::encode,
                ClientboundLabelInspectionResultsPacket::decode,
                ClientboundLabelInspectionResultsPacket::handle
        );
        INSPECTION_CHANNEL.registerMessage(
                4,
                ServerboundInputInspectionRequestPacket.class,
                ServerboundInputInspectionRequestPacket::encode,
                ServerboundInputInspectionRequestPacket::decode,
                ServerboundInputInspectionRequestPacket::handle
        );
        INSPECTION_CHANNEL.registerMessage(
                5,
                ClientboundInputInspectionResultsPacket.class,
                ClientboundInputInspectionResultsPacket::encode,
                ClientboundInputInspectionResultsPacket::decode,
                ClientboundInputInspectionResultsPacket::handle
        );
        INSPECTION_CHANNEL.registerMessage(
                6,
                ServerboundOutputInspectionRequestPacket.class,
                ServerboundOutputInspectionRequestPacket::encode,
                ServerboundOutputInspectionRequestPacket::decode,
                ServerboundOutputInspectionRequestPacket::handle
        );
        INSPECTION_CHANNEL.registerMessage(
                7,
                ClientboundOutputInspectionResultsPacket.class,
                ClientboundOutputInspectionResultsPacket::encode,
                ClientboundOutputInspectionResultsPacket::decode,
                ClientboundOutputInspectionResultsPacket::handle
        );
        INSPECTION_CHANNEL.registerMessage(
                8,
                ServerboundNetworkToolUsePacket.class,
                ServerboundNetworkToolUsePacket::encode,
                ServerboundNetworkToolUsePacket::decode,
                ServerboundNetworkToolUsePacket::handle
        );
    }

    public static <MENU extends AbstractContainerMenu, BE extends BlockEntity> void handleServerboundContainerPacket(
            @Nullable Supplier<NetworkEvent.Context> ctxSupplier,
            Class<MENU> menuClass,
            Class<BE> blockEntityClass,
            BlockPos pos,
            int containerId,
            BiConsumer<MENU, BE> callback
    ) {
        if (ctxSupplier == null) return;

        var ctx = ctxSupplier.get();
        if (ctx == null) return;
        ctx.enqueueWork(() -> {
            var sender = ctx.getSender();
            if (sender == null) return;
            if (sender.isSpectator()) return; // ignore packets from spectators

            var menu = sender.containerMenu;
            if (!menuClass.isInstance(menu)) return;
            if (menu.containerId != containerId) return;

            var level = sender.getLevel();
            //noinspection ConstantValue
            if (level == null) return;
            if (!level.isLoaded(pos)) return;

            var blockEntity = level.getBlockEntity(pos);
            if (!blockEntityClass.isInstance(blockEntity)) return;
            //noinspection unchecked
            callback.accept((MENU) menu, (BE) blockEntity);
        });
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\client\jei\FallingAnvilJEICategory.java

````java
package ca.teamdman.sfm.client.jei;

import ca.teamdman.sfm.SFM;
import ca.teamdman.sfm.common.Constants;
import ca.teamdman.sfm.common.item.FormItem;
import ca.teamdman.sfm.common.registry.SFMItems;
import mezz.jei.api.gui.builder.IRecipeLayoutBuilder;
import mezz.jei.api.gui.drawable.IDrawable;
import mezz.jei.api.helpers.IJeiHelpers;
import mezz.jei.api.recipe.IFocusGroup;
import mezz.jei.api.recipe.RecipeIngredientRole;
import mezz.jei.api.recipe.RecipeType;
import mezz.jei.api.recipe.category.IRecipeCategory;
import net.minecraft.nbt.ListTag;
import net.minecraft.nbt.StringTag;
import net.minecraft.network.chat.Component;
import net.minecraft.world.item.EnchantedBookItem;
import net.minecraft.world.item.Item;
import net.minecraft.world.item.ItemStack;
import net.minecraft.world.item.Items;
import net.minecraft.world.item.crafting.Ingredient;
import net.minecraft.world.item.enchantment.Enchantment;
import net.minecraft.world.item.enchantment.EnchantmentInstance;
import net.minecraft.world.level.block.Blocks;
import net.minecraftforge.registries.ForgeRegistries;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;

public class FallingAnvilJEICategory implements IRecipeCategory<FallingAnvilRecipe> {

    public static final RecipeType<FallingAnvilRecipe> RECIPE_TYPE = RecipeType.create(
            SFM.MOD_ID,
            "falling_anvil",
            FallingAnvilRecipe.class
    );
    private final IDrawable background;
    private final IDrawable icon;

    public FallingAnvilJEICategory(IJeiHelpers jeiHelpers) {
        background = jeiHelpers.getGuiHelper().createBlankDrawable(80, 54);
        icon = jeiHelpers.getGuiHelper().createDrawableItemStack(new ItemStack(Blocks.ANVIL));
    }

    @Override
    public RecipeType<FallingAnvilRecipe> getRecipeType() {
        return RECIPE_TYPE;
    }

    @Override
    public Component getTitle() {
        return Constants.LocalizationKeys.FALLING_ANVIL_JEI_CATEGORY_TITLE.getComponent();
    }

    @Override
    public IDrawable getBackground() {
        return background;
    }

    @Override
    public IDrawable getIcon() {
        return icon;
    }

    @Override
    public void setRecipe(IRecipeLayoutBuilder builder, FallingAnvilRecipe recipe, IFocusGroup focuses) {
        var anvil = List.of(
                new ItemStack(Items.ANVIL),
                new ItemStack(Items.CHIPPED_ANVIL),
                new ItemStack(Items.DAMAGED_ANVIL)
        );
        if (recipe instanceof FallingAnvilFormRecipe formRecipe) {
            builder.addSlot(RecipeIngredientRole.CATALYST, 0, 0).addItemStacks(anvil);
            builder.addSlot(RecipeIngredientRole.INPUT, 0, 18).addIngredients(formRecipe.PARENT.FORM);
            ItemStack ironBlock = new ItemStack(Blocks.IRON_BLOCK);
            var displayTag = ironBlock.getOrCreateTag().getCompound("display");
            var lore = new ListTag();
            lore.add(StringTag.valueOf(Component.Serializer.toJson(Constants.LocalizationKeys.FALLING_ANVIL_JEI_CONSUMED.getComponent())));
            displayTag.put("Lore", lore);
            ironBlock.getOrCreateTag().put("display", displayTag);
            builder.addSlot(RecipeIngredientRole.INPUT, 0, 36).addItemStack(ironBlock);
            builder
                    .addSlot(RecipeIngredientRole.OUTPUT, 50, 18)
                    .addItemStacks(Arrays.stream(formRecipe.PARENT.FORM.getItems()).map(FormItem::getForm).toList());
        } else if (recipe instanceof FallingAnvilDisenchantRecipe) {
            Collection<Enchantment> enchants = ForgeRegistries.ENCHANTMENTS.getValues();

            var tools = List.of(
                    Items.DIAMOND_HELMET,
                    Items.DIAMOND_CHESTPLATE,
                    Items.DIAMOND_LEGGINGS,
                    Items.DIAMOND_BOOTS,
                    Items.DIAMOND_PICKAXE,
                    Items.DIAMOND_SHOVEL,
                    Items.DIAMOND_AXE,
                    Items.DIAMOND_HOE,
                    Items.DIAMOND_SWORD,
                    Items.GOLDEN_HELMET,
                    Items.GOLDEN_CHESTPLATE,
                    Items.GOLDEN_LEGGINGS,
                    Items.GOLDEN_BOOTS,
                    Items.GOLDEN_PICKAXE,
                    Items.GOLDEN_SHOVEL,
                    Items.GOLDEN_AXE,
                    Items.GOLDEN_HOE,
                    Items.GOLDEN_SWORD,
                    Items.IRON_HELMET,
                    Items.IRON_CHESTPLATE,
                    Items.IRON_LEGGINGS,
                    Items.IRON_BOOTS,
                    Items.IRON_PICKAXE,
                    Items.IRON_SHOVEL,
                    Items.IRON_AXE,
                    Items.IRON_HOE,
                    Items.IRON_SWORD,
                    Items.LEATHER_HELMET,
                    Items.LEATHER_CHESTPLATE,
                    Items.LEATHER_LEGGINGS,
                    Items.LEATHER_BOOTS,
                    Items.CHAINMAIL_HELMET,
                    Items.CHAINMAIL_CHESTPLATE,
                    Items.CHAINMAIL_LEGGINGS,
                    Items.CHAINMAIL_BOOTS,
                    Items.WOODEN_PICKAXE,
                    Items.WOODEN_SHOVEL,
                    Items.WOODEN_AXE,
                    Items.WOODEN_HOE,
                    Items.WOODEN_SWORD,
                    Items.BOW
            );
            var enchanted = new ArrayList<ItemStack>();
            var books = new ArrayList<ItemStack>();
            for (Enchantment enchant : enchants) {
                for (Item tool : tools) {
                    var stack = new ItemStack(tool);
                    if (enchant.canEnchant(stack)) {
                        stack.enchant(enchant, enchant.getMaxLevel());
                        enchanted.add(stack);
                        books.add(EnchantedBookItem.createForEnchantment(new EnchantmentInstance(
                                enchant,
                                enchant.getMaxLevel()
                        )));
                    }
                }
            }

            builder.addSlot(RecipeIngredientRole.CATALYST, 8, 0).addItemStacks(anvil);
            builder.addSlot(RecipeIngredientRole.INPUT, 0, 18).addItemStacks(enchanted);
            builder.addSlot(RecipeIngredientRole.INPUT, 18, 18).addItemStack(new ItemStack(Items.BOOK));
            ItemStack obsidian = new ItemStack(Blocks.OBSIDIAN);
            var displayTag = obsidian.getOrCreateTag().getCompound("display");
            var lore = new ListTag();
            lore.add(StringTag.valueOf(Component.Serializer.toJson(Constants.LocalizationKeys.FALLING_ANVIL_JEI_NOT_CONSUMED.getComponent())));
            displayTag.put("Lore", lore);
            obsidian.getOrCreateTag().put("display", displayTag);
            builder.addSlot(RecipeIngredientRole.INPUT, 8, 36).addItemStack(obsidian);
            builder.addSlot(RecipeIngredientRole.OUTPUT, 50, 18).addItemStacks(books);
        } else if (recipe instanceof FallingAnvilExperienceShardRecipe) {
            builder.addSlot(RecipeIngredientRole.CATALYST, 0, 0).addItemStacks(anvil);
            builder.addSlot(RecipeIngredientRole.INPUT, 0, 18).addIngredients(Ingredient.of(Items.ENCHANTED_BOOK));
            ItemStack obsidian = new ItemStack(Blocks.OBSIDIAN);
            var displayTag = obsidian.getOrCreateTag().getCompound("display");
            var lore = new ListTag();
            lore.add(StringTag.valueOf(Component.Serializer.toJson(Constants.LocalizationKeys.FALLING_ANVIL_JEI_NOT_CONSUMED.getComponent())));
            displayTag.put("Lore", lore);
            obsidian.getOrCreateTag().put("display", displayTag);
            builder.addSlot(RecipeIngredientRole.INPUT, 0, 36).addItemStack(obsidian);
            builder
                    .addSlot(RecipeIngredientRole.OUTPUT, 50, 18)
                    .addItemStack(new ItemStack(SFMItems.EXPERIENCE_SHARD_ITEM.get()));
        }
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\containermenu\ManagerContainerMenu.java

````java
package ca.teamdman.sfm.common.containermenu;

import ca.teamdman.sfm.common.blockentity.ManagerBlockEntity;
import ca.teamdman.sfm.common.item.DiskItem;
import ca.teamdman.sfm.common.registry.SFMMenus;
import ca.teamdman.sfml.ast.Program;
import net.minecraft.core.BlockPos;
import net.minecraft.network.FriendlyByteBuf;
import net.minecraft.world.Container;
import net.minecraft.world.SimpleContainer;
import net.minecraft.world.entity.player.Inventory;
import net.minecraft.world.entity.player.Player;
import net.minecraft.world.inventory.AbstractContainerMenu;
import net.minecraft.world.inventory.Slot;
import net.minecraft.world.item.ItemStack;

public class ManagerContainerMenu extends AbstractContainerMenu {
    public final Container CONTAINER;
    public final Inventory INVENTORY;
    public final BlockPos MANAGER_POSITION;
    public String program;
    public ManagerBlockEntity.State state;
    public long[] tickTimeNanos;


    public ManagerContainerMenu(
            int windowId,
            Inventory inv,
            Container container,
            BlockPos blockEntityPos,
            String program,
            ManagerBlockEntity.State state,
            long[] tickTimeNanos
    ) {
        super(SFMMenus.MANAGER_MENU.get(), windowId);
        checkContainerSize(container, 1);
        this.CONTAINER = container;
        this.INVENTORY = inv;
        this.MANAGER_POSITION = blockEntityPos;
        this.program = program;
        this.state = state;
        this.tickTimeNanos = tickTimeNanos;

        this.addSlot(new Slot(container, 0, 15, 47) {
            @Override
            public int getMaxStackSize() {
                return 1;
            }

            @Override
            public boolean mayPlace(ItemStack stack) {
                return stack.getItem() instanceof DiskItem;
            }
        });

        for (int i = 0; i < 3; ++i) {
            for (int j = 0; j < 9; ++j) {
                this.addSlot(new Slot(inv, j + i * 9 + 9, 8 + j * 18, 84 + i * 18));
            }
        }

        for (int k = 0; k < 9; ++k) {
            this.addSlot(new Slot(inv, k, 8 + k * 18, 142));
        }
    }

    public ManagerContainerMenu(int windowId, Inventory inventory, FriendlyByteBuf buf) {
        this(
                windowId,
                inventory,
                new SimpleContainer(1),
                buf.readBlockPos(),
                buf.readUtf(Program.MAX_PROGRAM_LENGTH),
                buf.readEnum(ManagerBlockEntity.State.class),
                buf.readLongArray(null, ManagerBlockEntity.TICK_TIME_HISTORY_SIZE)
        );
    }

    public ManagerContainerMenu(int windowId, Inventory inventory, ManagerBlockEntity manager) {
        this(
                windowId,
                inventory,
                manager,
                manager.getBlockPos(),
                manager.getProgramString().orElse(""),
                manager.getState(),
                manager.getTickTimeNanos()
        );
    }

    public static void encode(ManagerBlockEntity manager, FriendlyByteBuf buf) {
        buf.writeBlockPos(manager.getBlockPos());
        buf.writeUtf(manager.getProgramString().orElse(""), Program.MAX_PROGRAM_LENGTH);
        buf.writeEnum(manager.getState());
        buf.writeLongArray(manager.getTickTimeNanos());
    }


    @Override
    public boolean stillValid(Player player) {
        return CONTAINER.stillValid(player);
    }

    @Override
    public ItemStack quickMoveStack(Player player, int slotIndex) {
        var slot = this.slots.get(slotIndex);
        if (!slot.hasItem()) return ItemStack.EMPTY;

        var containerEnd = CONTAINER.getContainerSize();
        var inventoryEnd = this.slots.size();

        var contents = slot.getItem();
        var result = contents.copy();

        if (slotIndex < containerEnd) {
            // clicked slot in container
            if (!this.moveItemStackTo(contents, containerEnd, inventoryEnd, true)) return ItemStack.EMPTY;
        } else {
            // clicked slot in inventory
            if (!this.moveItemStackTo(contents, 0, containerEnd, false)) return ItemStack.EMPTY;
        }

        if (contents.isEmpty()) {
            slot.set(ItemStack.EMPTY);
        } else {
            slot.setChanged();
        }
        return result;
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\compat\SFMCompat.java

````java
package ca.teamdman.sfm.common.compat;

import ca.teamdman.sfm.common.resourcetype.GasResourceType;
import ca.teamdman.sfm.common.resourcetype.InfuseResourceType;
import ca.teamdman.sfm.common.resourcetype.PigmentResourceType;
import ca.teamdman.sfm.common.resourcetype.SlurryResourceType;
import net.minecraftforge.common.capabilities.Capability;
import net.minecraftforge.common.capabilities.ForgeCapabilities;
import net.minecraftforge.fml.ModList;

import java.util.List;

public class SFMCompat {
    public static boolean isMekanismLoaded() {
        return ModList.get().getModContainerById("mekanism").isPresent();
    }

    public static List<Capability<?>> getCapabilities() {
        if (isMekanismLoaded()) {
            return List.of(
                    ForgeCapabilities.ITEM_HANDLER,
                    ForgeCapabilities.FLUID_HANDLER,
                    ForgeCapabilities.ENERGY,
                    GasResourceType.CAP,
                    InfuseResourceType.CAP,
                    PigmentResourceType.CAP,
                    SlurryResourceType.CAP
            );
        } else {
            return List.of(
                    ForgeCapabilities.ITEM_HANDLER,
                    ForgeCapabilities.FLUID_HANDLER,
                    ForgeCapabilities.ENERGY
            );
        }
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfml\ast\DirectionQualifier.java

````java
package ca.teamdman.sfml.ast;

import net.minecraft.core.Direction;

import javax.annotation.Nullable;
import java.util.EnumSet;
import java.util.stream.Stream;

public record DirectionQualifier(EnumSet<Direction> directions) implements ASTNode {

    public static DirectionQualifier NULL_DIRECTION = new DirectionQualifier(EnumSet.noneOf(Direction.class));
    public static DirectionQualifier EVERY_DIRECTION = new DirectionQualifier(EnumSet.allOf(Direction.class));

    public static Direction lookup(Side side) {
        return switch (side) {
            case TOP -> Direction.UP;
            case BOTTOM -> Direction.DOWN;
            case NORTH -> Direction.NORTH;
            case SOUTH -> Direction.SOUTH;
            case EAST -> Direction.EAST;
            case WEST -> Direction.WEST;
        };
    }

    public static String directionToString(@Nullable Direction direction) {
        if (direction == null) return "";
        return switch (direction) {
            case UP -> "TOP";
            case DOWN -> "BOTTOM";
            case NORTH -> "NORTH";
            case SOUTH -> "SOUTH";
            case EAST -> "EAST";
            case WEST -> "WEST";
        };
    }

    public Stream<Direction> stream() {
        if (this == EVERY_DIRECTION)
            return Stream.concat(directions.stream(), Stream.<Direction>builder().add(null).build());
        if (directions.isEmpty()) return Stream.<Direction>builder().add(null).build();
        return directions.stream();
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\compat\package-info.java

````java

@ParametersAreNonnullByDefault
@MethodsReturnNonnullByDefault
@FieldsAreNonnullByDefault
package ca.teamdman.sfm.common.compat;

import net.minecraft.FieldsAreNonnullByDefault;
import net.minecraft.MethodsReturnNonnullByDefault;

import javax.annotation.ParametersAreNonnullByDefault;
````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\util\package-info.java

````java


@ParametersAreNonnullByDefault
@MethodsReturnNonnullByDefault
@FieldsAreNonnullByDefault
package ca.teamdman.sfm.common.util;

import net.minecraft.FieldsAreNonnullByDefault;
import net.minecraft.MethodsReturnNonnullByDefault;

import javax.annotation.ParametersAreNonnullByDefault;
````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\resourcetype\ResourceType.java

````java
package ca.teamdman.sfm.common.resourcetype;

import ca.teamdman.sfm.common.cablenetwork.CableNetwork;
import ca.teamdman.sfm.common.program.LabelPositionHolder;
import ca.teamdman.sfm.common.program.ProgramContext;
import ca.teamdman.sfml.ast.LabelAccess;
import ca.teamdman.sfml.ast.ResourceIdentifier;
import it.unimi.dsi.fastutil.objects.Object2ObjectOpenHashMap;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.world.item.ItemStack;
import net.minecraftforge.common.capabilities.Capability;
import net.minecraftforge.registries.IForgeRegistry;

import java.util.Map;
import java.util.Optional;
import java.util.stream.Stream;

public abstract class ResourceType<STACK, ITEM, CAP> {
    private final Map<ITEM, ResourceLocation> registryKeyCache = new Object2ObjectOpenHashMap<>();


    public final Capability<CAP> CAPABILITY;

    public ResourceType(Capability<CAP> CAPABILITY) {
        this.CAPABILITY = CAPABILITY;
    }


    public abstract long getAmount(STACK stack);

    public abstract STACK getStackInSlot(CAP cap, int slot);

    public abstract STACK extract(CAP cap, int slot, long amount, boolean simulate);

    public abstract int getSlots(CAP handler);

    public abstract long getMaxStackSize(STACK stack);

    public abstract long getMaxStackSize(CAP cap, int slot);


    public abstract STACK insert(CAP cap, int slot, STACK stack, boolean simulate);

    public abstract boolean isEmpty(STACK stack);

    @SuppressWarnings("unused")
    public abstract STACK getEmptyStack();

    public abstract boolean matchesStackType(Object o);

    public boolean matchesStack(ResourceIdentifier<STACK, ITEM, CAP> resourceId, Object stack) {
        if (!matchesStackType(stack)) return false;
        @SuppressWarnings("unchecked") STACK stack_ = (STACK) stack;
        if (isEmpty(stack_)) return false;
        var stackId = getRegistryKey(stack_);
        return resourceId.matchesStack(stackId);
    }

    public abstract boolean matchesCapabilityType(Object o);

    public Stream<CAP> getCapabilities(
            ProgramContext programContext, LabelAccess labelAccess
    ) {
        Optional<ItemStack> disk = programContext.getManager().getDisk();
        if (disk.isEmpty()) return Stream.empty();
        LabelPositionHolder labelPositions = LabelPositionHolder.from(disk.get());
        CableNetwork network = programContext.getNetwork();
        return labelAccess.roundRobin().gather(labelAccess, labelPositions)
                .map(network::getCapabilityProvider)
                .filter(Optional::isPresent)
                .map(Optional::get)
                .flatMap((
                                 prov -> labelAccess
                                         .directions()
                                         .stream()
                                         .map(direction -> prov.getCapability(CAPABILITY, direction))
                         ))
                .map(x -> {
                    //noinspection DataFlowIssue
                    return x.orElse(null);
                })
                .filter(x -> {
                    //noinspection ConstantValue,Convert2MethodRef
                    return x != null;
                });
    }

    public Stream<STACK> collect(CAP cap, LabelAccess labelAccess) {
        var rtn = Stream.<STACK>builder();
        for (int slot = 0; slot < getSlots(cap); slot++) {
            if (!labelAccess.slots().contains(slot)) continue;
            var stack = getStackInSlot(cap, slot);
            if (!isEmpty(stack)) {
                rtn.add(stack);
            }
        }
        return rtn.build();
    }

    public boolean registryKeyExists(ResourceLocation location) {
        return getRegistry().containsKey(location);
    }

    public ResourceLocation getRegistryKey(STACK stack) {
        ITEM item = getItem(stack);
        var found = registryKeyCache.get(item);
        if (found != null) return found;
        found = getRegistry().getKey(item);
        assert found != null;
        registryKeyCache.put(item, found);
        return found;
    }

    public abstract IForgeRegistry<ITEM> getRegistry();

    public abstract ITEM getItem(STACK stack);

    public abstract STACK copy(STACK stack);

    protected abstract STACK setCount(STACK stack, long amount);

    @SuppressWarnings("unused")
    public STACK withCount(STACK stack, long count) {
        return setCount(copy(stack), count);
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\client\handler\ContainerScreenInspectorHandler.java

````java
package ca.teamdman.sfm.client.handler;

import ca.teamdman.sfm.SFM;
import ca.teamdman.sfm.client.ClientStuff;
import ca.teamdman.sfm.client.registry.SFMKeyMappings;
import ca.teamdman.sfm.common.Constants;
import ca.teamdman.sfm.common.net.ServerboundContainerExportsInspectionRequestPacket;
import ca.teamdman.sfm.common.registry.SFMPackets;
import com.mojang.blaze3d.platform.InputConstants;
import com.mojang.blaze3d.vertex.PoseStack;
import net.minecraft.ChatFormatting;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.screens.inventory.AbstractContainerScreen;
import net.minecraft.network.chat.Component;
import net.minecraft.world.entity.player.Inventory;
import net.minecraft.world.inventory.AbstractContainerMenu;
import net.minecraft.world.level.block.entity.BlockEntity;
import net.minecraftforge.api.distmarker.Dist;
import net.minecraftforge.client.event.ScreenEvent;
import net.minecraftforge.client.gui.widget.ExtendedButton;
import net.minecraftforge.eventbus.api.SubscribeEvent;
import net.minecraftforge.fml.common.Mod;

import javax.annotation.Nullable;

@Mod.EventBusSubscriber(modid = SFM.MOD_ID, bus = Mod.EventBusSubscriber.Bus.FORGE, value = Dist.CLIENT)
public class ContainerScreenInspectorHandler {
    private static boolean visible = false;
    @Nullable
    private static AbstractContainerScreen<?> lastScreen = null;
    private static final ExtendedButton exportInspectorButton = new ExtendedButton(
            5,
            50,
            100,
            20,
            Constants.LocalizationKeys.CONTAINER_INSPECTOR_SHOW_EXPORTS_BUTTON.getComponent(),
            (button) -> {
                BlockEntity lookBlockEntity = ClientStuff.getLookBlockEntity();
                if (lastScreen != null && lookBlockEntity != null) {
                    SFMPackets.INSPECTION_CHANNEL.sendToServer(new ServerboundContainerExportsInspectionRequestPacket(
                            lastScreen.getMenu().containerId,
                            lookBlockEntity.getBlockPos()
                    ));
                }
            }
    );

    @SubscribeEvent
    public static void onMouseClick(ScreenEvent.KeyPressed.MouseButtonPressed.Pre event) {
        boolean shouldCapture = Minecraft.getInstance().screen instanceof AbstractContainerScreen<?>;
        if (shouldCapture && visible && exportInspectorButton.clicked(event.getMouseX(), event.getMouseY())) {
            exportInspectorButton.playDownSound(Minecraft.getInstance().getSoundManager());
            exportInspectorButton.onClick(event.getMouseX(), event.getMouseY());
            event.setCanceled(true);
        }
    }

    @SubscribeEvent
    public static void onGuiRender(ScreenEvent.Render.Post event) {
        if (!visible) return;
        if (event.getScreen() instanceof AbstractContainerScreen<?> acs) {
            lastScreen = acs;
            AbstractContainerMenu menu = acs.getMenu();
            int containerSlotCount = 0;
            int inventorySlotCount = 0;
            PoseStack poseStack = event.getPoseStack();
            poseStack.pushPose();
            poseStack.translate(0, 0, 350); // render text over the items but under the tooltips

            // draw the button
            exportInspectorButton.render(poseStack, event.getMouseX(), event.getMouseY(), event.getPartialTick());


            // draw index on each slot
            for (var slot : menu.slots) {
                int colour;
                if (slot.container instanceof Inventory) {
                    //noinspection DataFlowIssue
                    colour = ChatFormatting.YELLOW.getColor();
                    inventorySlotCount++;
                } else {
                    colour = 0xFFF;
                    containerSlotCount++;
                }
                Minecraft.getInstance().font.draw(
                        poseStack,
                        Component.literal(Integer.toString(slot.getSlotIndex())),
                        acs.getGuiLeft() + slot.x,
                        acs.getGuiTop() + slot.y,
                        colour
                );
            }

            // draw text for slot totals
            Minecraft.getInstance().font.drawShadow(
                    poseStack,
                    Constants.LocalizationKeys.CONTAINER_INSPECTOR_CONTAINER_SLOT_COUNT.getComponent(Component
                                                                                                             .literal(
                                                                                                                     String.valueOf(
                                                                                                                             containerSlotCount))
                                                                                                             .withStyle(
                                                                                                                     ChatFormatting.BLUE)),
                    5,
                    5,
                    0xFFFFFF
            );
            Minecraft.getInstance().font.drawShadow(
                    poseStack,
                    Constants.LocalizationKeys.CONTAINER_INSPECTOR_INVENTORY_SLOT_COUNT.getComponent(Component
                                                                                                             .literal(
                                                                                                                     String.valueOf(
                                                                                                                             inventorySlotCount))
                                                                                                             .withStyle(
                                                                                                                     ChatFormatting.YELLOW)),
                    5,
                    25,
                    0xFFFFFF
            );
            poseStack.popPose();
        }
    }

    @SubscribeEvent
    public static void onKeyDown(ScreenEvent.KeyPressed.Pre event) {
        var toggleKey = SFMKeyMappings.CONTAINER_INSPECTOR_KEY.get();
        var toggleKeyPressed = toggleKey.isActiveAndMatches(InputConstants.Type.KEYSYM.getOrCreate(event.getKeyCode()));
        if (toggleKeyPressed) {
            visible = !visible;
            event.setCanceled(true);
        }
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\registry\SFMResourceTypes.java

````java
package ca.teamdman.sfm.common.registry;

import ca.teamdman.sfm.SFM;
import ca.teamdman.sfm.common.compat.SFMCompat;
import ca.teamdman.sfm.common.compat.SFMMekanismCompat;
import ca.teamdman.sfm.common.resourcetype.FluidResourceType;
import ca.teamdman.sfm.common.resourcetype.ForgeEnergyResourceType;
import ca.teamdman.sfm.common.resourcetype.ItemResourceType;
import ca.teamdman.sfm.common.resourcetype.ResourceType;
import it.unimi.dsi.fastutil.ints.Int2ObjectArrayMap;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.world.item.Item;
import net.minecraft.world.item.ItemStack;
import net.minecraft.world.level.material.Fluid;
import net.minecraftforge.energy.IEnergyStorage;
import net.minecraftforge.eventbus.api.IEventBus;
import net.minecraftforge.fluids.FluidStack;
import net.minecraftforge.fluids.capability.IFluidHandler;
import net.minecraftforge.items.IItemHandler;
import net.minecraftforge.registries.DeferredRegister;
import net.minecraftforge.registries.IForgeRegistry;
import net.minecraftforge.registries.RegistryBuilder;
import net.minecraftforge.registries.RegistryObject;

import java.util.Objects;
import java.util.function.Supplier;

public class SFMResourceTypes {
    public static final ResourceLocation REGISTRY_ID = new ResourceLocation(SFM.MOD_ID, "resource_type");

    private static final DeferredRegister<ResourceType<?, ?, ?>> TYPES = DeferredRegister.create(
            REGISTRY_ID,
            SFM.MOD_ID
    );
    public static final Supplier<IForgeRegistry<ResourceType<?, ?, ?>>> DEFERRED_TYPES = TYPES.makeRegistry(
            () -> new RegistryBuilder<ResourceType<?, ?, ?>>().setName(
                    REGISTRY_ID));
    public static final RegistryObject<ResourceType<ItemStack, Item, IItemHandler>> ITEM = TYPES.register(
            "item",
            ItemResourceType::new
    );
    public static final RegistryObject<ResourceType<FluidStack, Fluid, IFluidHandler>> FLUID = TYPES.register(
            "fluid",
            FluidResourceType::new
    );
    public static final RegistryObject<ResourceType<Integer, Class<Integer>, IEnergyStorage>> FORGE_ENERGY = TYPES.register(
            "forge_energy",
            ForgeEnergyResourceType::new
    );

    private static final Int2ObjectArrayMap<ResourceType<?, ?, ?>> DEFERRED_TYPES_BY_ID = new Int2ObjectArrayMap<>();

    public static ResourceType<?, ?, ?> fastLookup(String resourceTypeNamespace, String resourceTypeName) {
//        return DEFERRED_TYPES.get().getValue(new ResourceLocation(resourceTypeNamespace, resourceTypeName));
        return Objects.requireNonNull(DEFERRED_TYPES_BY_ID.computeIfAbsent(
                resourceTypeNamespace.hashCode() ^ resourceTypeName.hashCode(),
                i -> DEFERRED_TYPES.get().getValue(new ResourceLocation(resourceTypeNamespace, resourceTypeName))
        ));
    }

    static {
        if (SFMCompat.isMekanismLoaded()) {
            SFMMekanismCompat.register(TYPES);
        }
    }

    public static void register(IEventBus bus) {
        TYPES.register(bus);
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\net\ServerboundOutputInspectionRequestPacket.java

````java
package ca.teamdman.sfm.common.net;

import ca.teamdman.sfm.common.blockentity.ManagerBlockEntity;
import ca.teamdman.sfm.common.containermenu.ManagerContainerMenu;
import ca.teamdman.sfm.common.program.LimitedInputSlot;
import ca.teamdman.sfm.common.program.ProgramContext;
import ca.teamdman.sfm.common.registry.SFMPackets;
import ca.teamdman.sfm.common.registry.SFMResourceTypes;
import ca.teamdman.sfm.common.resourcetype.ResourceType;
import ca.teamdman.sfm.common.util.SFMUtils;
import ca.teamdman.sfml.ast.Number;
import ca.teamdman.sfml.ast.*;
import net.minecraft.network.FriendlyByteBuf;
import net.minecraft.resources.ResourceKey;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.server.level.ServerPlayer;
import net.minecraftforge.network.NetworkEvent;
import net.minecraftforge.network.PacketDistributor;
import org.antlr.v4.runtime.misc.Pair;

import java.util.ArrayList;
import java.util.List;
import java.util.ListIterator;
import java.util.Optional;
import java.util.function.Supplier;

public record ServerboundOutputInspectionRequestPacket(
        String programString,
        int outputNodeIndex
) {
    public static void encode(ServerboundOutputInspectionRequestPacket msg, FriendlyByteBuf friendlyByteBuf) {
        friendlyByteBuf.writeUtf(msg.programString, Program.MAX_PROGRAM_LENGTH);
        friendlyByteBuf.writeInt(msg.outputNodeIndex());
    }

    public static ServerboundOutputInspectionRequestPacket decode(FriendlyByteBuf friendlyByteBuf) {
        return new ServerboundOutputInspectionRequestPacket(
                friendlyByteBuf.readUtf(Program.MAX_PROGRAM_LENGTH),
                friendlyByteBuf.readInt()
        );
    }

    private static <STACK, ITEM, CAP> ResourceLimit<STACK, ITEM, CAP> getSlotResource(
            LimitedInputSlot<STACK, ITEM, CAP> limitedInputSlot
    ) {
        ResourceType<STACK, ITEM, CAP> resourceType = limitedInputSlot.type;
        //noinspection OptionalGetWithoutIsPresent
        ResourceKey<ResourceType<STACK, ITEM, CAP>> resourceTypeResourceKey = SFMResourceTypes.DEFERRED_TYPES
                .get()
                .getResourceKey(limitedInputSlot.type)
                .map(x -> {
                    //noinspection unchecked,rawtypes
                    return (ResourceKey<ResourceType<STACK, ITEM, CAP>>) (ResourceKey) x;
                })
                .get();
        STACK stack = limitedInputSlot.peekExtractPotential();
        long amount = limitedInputSlot.type.getAmount(stack);
        amount = Long.min(amount, limitedInputSlot.tracker.getResourceLimit().limit().quantity().number().value());
        long remainingObligation = limitedInputSlot.tracker.getRemainingRetentionObligation();
        amount -= Long.min(amount, remainingObligation);
        Limit amountLimit = new Limit(
                new ResourceQuantity(new Number(amount), ResourceQuantity.IdExpansionBehaviour.NO_EXPAND),
                ResourceQuantity.MAX_QUANTITY
        );
        ResourceLocation stackId = resourceType.getRegistryKey(stack);
        ResourceIdentifier<STACK, ITEM, CAP> resourceIdentifier = new ResourceIdentifier<>(
                resourceTypeResourceKey.location().getNamespace(),
                resourceTypeResourceKey.location().getPath(),
                stackId.getNamespace(),
                stackId.getPath()
        );
        return new ResourceLimit<>(
                resourceIdentifier,
                amountLimit
        );
    }


    public static void handle(
            ServerboundOutputInspectionRequestPacket msg,
            Supplier<NetworkEvent.Context> contextSupplier
    ) {
        contextSupplier.get().enqueueWork(() -> {
            // we don't know if the player has the program edit screen open from a manager or a disk in hand
            ServerPlayer player = contextSupplier.get().getSender();
            if (player == null) return;
            ManagerBlockEntity manager;
            if (player.containerMenu instanceof ManagerContainerMenu mcm) {
                if (player.getLevel().getBlockEntity(mcm.MANAGER_POSITION) instanceof ManagerBlockEntity mbe) {
                    manager = mbe;
                } else {
                    return;
                }
            } else {
                //todo: localize
                SFMPackets.INSPECTION_CHANNEL.send(
                        PacketDistributor.PLAYER.with(() -> player),
                        new ClientboundInputInspectionResultsPacket(
                                "This inspection is only available when editing inside a manager.")
                );
                return;
            }
            Program.compile(
                    msg.programString,
                    (successProgram, builder) -> builder
                            .getNodeAtIndex(msg.outputNodeIndex)
                            .filter(OutputStatement.class::isInstance)
                            .map(OutputStatement.class::cast)
                            .ifPresent(outputStatement -> {
                                StringBuilder payload = new StringBuilder();
                                payload.append(outputStatement.toStringPretty()).append("\n");
                                payload.append("-- predictions may differ from actual execution results\n");

                                successProgram.replaceOutputStatement(outputStatement, new OutputStatement(
                                        outputStatement.labelAccess(),
                                        outputStatement.resourceLimits(),
                                        outputStatement.each()
                                ) {
                                    @Override
                                    public void tick(ProgramContext context) {
                                        StringBuilder branchPayload = new StringBuilder();

                                        if (!context.getExecutionPath().isEmpty()) {
                                            payload
                                                    .append("-- POSSIBILITY ")
                                                    .append(context.getExplorationBranchIndex())
                                                    .append(" --\n");
                                            context.getExecutionPath().forEach(branch -> {
                                                if (branch.wasTrue()) {
                                                    payload
                                                            .append(branch.ifStatement().condition().sourceCode())
                                                            .append(" -- true");
                                                } else {
                                                    payload.append(branch
                                                                           .ifStatement()
                                                                           .condition()
                                                                           .negate()
                                                                           .sourceCode());
                                                }
                                                payload.append("\n");
                                            });
                                            payload.append("\n");
                                        }

                                        branchPayload.append("-- predicted inputs:\n");
                                        List<Pair<LimitedInputSlot<?, ?, ?>, LabelAccess>> inputSlots = new ArrayList<>();
                                        context
                                                .getInputs()
                                                .forEach(inputStatement -> inputStatement.gatherSlots(
                                                        context,
                                                        slot -> inputSlots.add(new Pair<>(
                                                                slot,
                                                                inputStatement.labelAccess()
                                                        ))
                                                ));
                                        List<InputStatement> inputStatements = inputSlots.stream()
                                                .map(slot -> SFMUtils.getInputStatementForSlot(slot.a, slot.b))
                                                .filter(Optional::isPresent)
                                                .map(Optional::get)
                                                .toList();
                                        if (inputStatements.isEmpty()) {
                                            branchPayload.append("none\n-- predicted outputs:\nnone");
                                        } else {
                                            inputStatements.stream()
                                                    .map(InputStatement::toStringPretty)
                                                    .map(x -> x + "\n")
                                                    .forEach(branchPayload::append);

                                            branchPayload.append(
                                                    "-- predicted outputs:\n");
                                            ResourceLimits condensedResourceLimits;
                                            {
                                                ResourceLimits resourceLimits = new ResourceLimits(
                                                        inputSlots
                                                                .stream()
                                                                .map(slot -> slot.a)
                                                                .map(ServerboundOutputInspectionRequestPacket::getSlotResource)
                                                                .toList(),
                                                        ResourceIdSet.EMPTY
                                                );
                                                List<ResourceLimit<?, ?, ?>> condensedResourceLimitList = new ArrayList<>();
                                                for (ResourceLimit<?, ?, ?> resourceLimit : resourceLimits.resourceLimits()) {
                                                    // check if an existing resource limit has the same resource identifier
                                                    condensedResourceLimitList
                                                            .stream()
                                                            .filter(x -> x
                                                                    .resourceId()
                                                                    .equals(resourceLimit.resourceId()))
                                                            .findFirst()
                                                            .ifPresentOrElse(found -> {
                                                                int i = condensedResourceLimitList.indexOf(found);
                                                                ResourceLimit<?, ?, ?> newLimit = found.withLimit(new Limit(
                                                                        found
                                                                                .limit()
                                                                                .quantity()
                                                                                .add(resourceLimit.limit().quantity()),
                                                                        ResourceQuantity.MAX_QUANTITY
                                                                ));
                                                                condensedResourceLimitList.set(i, newLimit);
                                                            }, () -> condensedResourceLimitList.add(resourceLimit));
                                                }
                                                {
                                                    // prune items not covered by the output resource limits
                                                    ListIterator<ResourceLimit<?, ?, ?>> iter = condensedResourceLimitList.listIterator();
                                                    while (iter.hasNext()) {
                                                        ResourceLimit<?, ?, ?> resourceLimit = iter.next();
                                                        // because these resource limits were generated from resource stacks
                                                        // they should always be valid resource locations (not patterns)
                                                        ResourceLocation resourceLimitLocation = new ResourceLocation(
                                                                resourceLimit.resourceId().resourceNamespace,
                                                                resourceLimit.resourceId().resourceName
                                                        );
                                                        long accept = outputStatement
                                                                .resourceLimits()
                                                                .resourceLimits()
                                                                .stream()
                                                                .filter(outputResourceLimit -> outputResourceLimit
                                                                                                       .resourceId()
                                                                                                       .matchesStack(
                                                                                                               resourceLimitLocation)
                                                                                               && outputStatement
                                                                                                       .resourceLimits()
                                                                                                       .exclusions()
                                                                                                       .resourceIds()
                                                                                                       .stream()
                                                                                                       .noneMatch(
                                                                                                               exclusion -> exclusion.matchesStack(
                                                                                                                       resourceLimitLocation)))
                                                                .mapToLong(rl -> rl.limit().quantity().number().value())
                                                                .max()
                                                                .orElse(0);
                                                        if (accept == 0) {
                                                            iter.remove();
                                                        } else {
                                                            iter.set(resourceLimit.withLimit(new Limit(
                                                                    new ResourceQuantity(new Number(Long.min(
                                                                            accept,
                                                                            resourceLimit
                                                                                    .limit()
                                                                                    .quantity()
                                                                                    .number()
                                                                                    .value()
                                                                    )), resourceLimit.limit().quantity()
                                                                                                 .idExpansionBehaviour()),
                                                                    ResourceQuantity.MAX_QUANTITY
                                                            )));
                                                        }
                                                    }
                                                }
                                                condensedResourceLimits = new ResourceLimits(
                                                        condensedResourceLimitList,
                                                        ResourceIdSet.EMPTY
                                                );
                                            }
                                            if (condensedResourceLimits.resourceLimits().isEmpty()) {
                                                branchPayload.append("none\n");
                                            } else {
                                                branchPayload
                                                        .append(new OutputStatement(
                                                                outputStatement.labelAccess(),
                                                                condensedResourceLimits,
                                                                outputStatement.each()
                                                        ).toStringPretty());
                                            }

                                        }
                                        branchPayload.append("\n");
                                        if (successProgram.getConditionCount() == 0) {
                                            payload.append(branchPayload);
                                        } else {
                                            payload.append(branchPayload.toString().indent(4));
                                        }
                                    }
                                });

                                // run the program down each possible if-branch combination
                                for (
                                        int branchIndex = 0;
                                        branchIndex < Math.pow(2, successProgram.getConditionCount());
                                        branchIndex++
                                ) {
                                    successProgram.tick(new ProgramContext(
                                            successProgram,
                                            manager,
                                            ProgramContext.ExecutionPolicy.EXPLORE_BRANCHES,
                                            branchIndex
                                    ));
                                }


                                SFMPackets.INSPECTION_CHANNEL.send(
                                        PacketDistributor.PLAYER.with(() -> player),
                                        new ClientboundOutputInspectionResultsPacket(payload.toString().strip())
                                );
                            }),
                    failure -> {
                        //todo: translate
                        SFMPackets.INSPECTION_CHANNEL.send(
                                PacketDistributor.PLAYER.with(() -> player),
                                new ClientboundOutputInspectionResultsPacket("failed to compile program")
                        );
                    }
            );
        });
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfml\ast\OutputStatement.java

````java
package ca.teamdman.sfml.ast;

import ca.teamdman.sfm.SFM;
import ca.teamdman.sfm.common.program.*;
import ca.teamdman.sfm.common.resourcetype.ResourceType;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.function.Consumer;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class OutputStatement implements Statement {
    private final LabelAccess labelAccess;
    private final ResourceLimits resourceLimits;
    private final boolean each;

    private int lastInputCapacity = 32;
    private int lastOutputCapacity = 32;

    public OutputStatement(
            LabelAccess labelAccess,
            ResourceLimits resourceLimits,
            boolean each
    ) {
        this.labelAccess = labelAccess;
        this.resourceLimits = resourceLimits;
        this.each = each;
    }

    /**
     * Juicy method function here.
     * Given two slots, move as much as possible from one to the other.
     *
     * @param source      The slot to pull from
     * @param destination the slot to push to
     * @param <STACK>     the stack type
     * @param <ITEM>      the item type
     * @param <CAP>       the capability type
     */
    public static <STACK, ITEM, CAP> void moveTo(
            LimitedInputSlot<STACK, ITEM, CAP> source, LimitedOutputSlot<STACK, ITEM, CAP> destination
    ) {
        // always ensure types match
        // items and fluids are incompatible, etc
        if (!source.type.equals(destination.type)) return;

        // find out what we can pull out
        // should never be empty by the time we get here
        STACK potential = source.peekExtractPotential();
        // ensure the output slot allows this item
        if (!destination.tracker.test(potential)) return;
        // find out how much we can fit
        STACK remainder = destination.insert(potential, true);

        // how many can we move before accounting for limits
        long toMove = source.type.getAmount(potential) - source.type.getAmount(remainder);
        if (toMove == 0) return;

        // how many have we promised to RETAIN in this slot
        toMove -= source.tracker.getExistingRetentionObligation(source.slot);
        // how many more need we are obligated to leave to satisfy the remainder of the RETAIN limit
        long remainingObligation = source.tracker.getRemainingRetentionObligation();
        remainingObligation = Long.min(toMove, remainingObligation);
        toMove -= remainingObligation;

        // update the obligation tracker
        source.tracker.trackRetentionObligation(source.slot, remainingObligation);

        // if we can't move anything after our retention obligations, we're done
        if (toMove == 0) {
            source.setDone();
            return;
        }

        // apply output constraints
        toMove = Math.min(toMove, destination.tracker.getMaxTransferable());

        // apply input constraints
        toMove = Math.min(toMove, source.tracker.getMaxTransferable());

        // apply resource constraints
        toMove = Math.min(toMove, source.type.getMaxStackSize(potential));
        if (toMove <= 0) return;

        // extract item for real
        STACK extracted = source.extract(toMove);
        // insert item for real
        remainder = destination.insert(extracted, false);
        var moved = source.type.getAmount(extracted) - source.type.getAmount(remainder);
        // track transfer amounts
        source.tracker.trackTransfer(moved);
        destination.tracker.trackTransfer(moved);

        // if remainder exists, someone lied.
        // this should never happen
        // will void items if it does
        if (!destination.type.isEmpty(remainder)) {
            SFM.LOGGER.error(
                    "Failed to move all promised items, took {} but had {} left over after insertion.",
                    extracted,
                    remainder
            );
        }
    }

    @SuppressWarnings({"rawtypes", "unchecked"})
    @Override
    public void tick(ProgramContext context) {
        if (context.getExecutionPolicy() == ProgramContext.ExecutionPolicy.EXPLORE_BRANCHES) return;
        // gather the input slots from all the input statements, +27 to hopefully avoid resizing
        List<LimitedInputSlot> inputSlots = new ArrayList<>(lastInputCapacity + 27);
        for (var inputStatement : context.getInputs()) {
            inputStatement.gatherSlots(context, inputSlots::add);
        }
        if (inputSlots.isEmpty()) return; // stop if we have nothing to move
        lastInputCapacity = inputSlots.size();

        // collect the output slots, +27 to hopefully avoid resizing
        List<LimitedOutputSlot> outputSlots = new ArrayList<>(lastOutputCapacity + 27);
        gatherSlots(context, outputSlots::add);
        lastOutputCapacity = outputSlots.size();

        // try and move resources from input slots to output slots
        var inIt = inputSlots.iterator();
        while (inIt.hasNext()) {
            var in = inIt.next();
            if (in.isDone()) { // this slot is no longer useful
                inIt.remove(); // ensure we only release slots once
                InputStatement.releaseSlot(in); // release the slot to the object pool
                continue;
            }
            var outIt = outputSlots.iterator();
            while (outIt.hasNext()) {
                var out = outIt.next();
                if (out.isDone()) { // this slot is no longer useful
                    outIt.remove(); // ensure we only release slots once
                    LimitedOutputSlotObjectPool.INSTANCE.release(out); // release the slot to the object pool
                    continue;
                }
                moveTo(in, out); // move the contents from the "in" slot to the "out" slot
                if (in.isDone()) break; // stop processing output slots if we have nothing to move
            }
            if (outputSlots.isEmpty()) break; // stop processing input slots if we have no output slots
        }

        LimitedOutputSlotObjectPool.INSTANCE.release(outputSlots);
        InputStatement.releaseSlots(inputSlots);
    }

    /**
     * The output statement contains labels.
     * Each block in the world can have more than one programString.
     * Each block can have a block entity.
     * Each block entity can have 0 or more slots.
     * <p>
     * We want collect the slots from all the labelled blocks.
     */
    @SuppressWarnings({"rawtypes", "unchecked"}) // basically impossible to make this method generic safe
    public void gatherSlots(ProgramContext context, Consumer<LimitedOutputSlot<?, ?, ?>> acceptor) {
        // find all the types referenced in the output statement
        Stream<ResourceType> types = resourceLimits
                .resourceLimits()
                .stream()
                .map(ResourceLimit::resourceId)
                .map((ResourceIdentifier x) -> x.getResourceType())
                .distinct();

        if (!each) {
            // create a single matcher to be shared by all capabilities
            List<OutputResourceTracker<?, ?, ?>> outputTracker = resourceLimits.createOutputTrackers();
            for (var type : (Iterable<ResourceType>) types::iterator) {
                for (var cap : (Iterable<?>) type.getCapabilities(context, labelAccess)::iterator) {
                    gatherSlots((ResourceType<Object, Object, Object>) type, cap, outputTracker, acceptor);
                }
            }
        } else {
            for (var type : (Iterable<ResourceType>) types::iterator) {
                for (var cap : (Iterable<?>) type.getCapabilities(context, labelAccess)::iterator) {
                    List<OutputResourceTracker<?, ?, ?>> outputTracker = resourceLimits.createOutputTrackers();
                    gatherSlots((ResourceType<Object, Object, Object>) type, cap, outputTracker, acceptor);
                }
            }
        }
    }

    private <STACK, ITEM, CAP> void gatherSlots(
            ResourceType<STACK, ITEM, CAP> type,
            CAP capability,
            List<OutputResourceTracker<?, ?, ?>> trackers,
            Consumer<LimitedOutputSlot<?, ?, ?>> acceptor
    ) {
        for (int slot = 0; slot < type.getSlots(capability); slot++) {
            if (labelAccess.slots().contains(slot)) {
                for (OutputResourceTracker<?, ?, ?> tracker : trackers) {
                    if (tracker.matchesCapabilityType(capability)) {
                        //noinspection unchecked
                        acceptor.accept(LimitedOutputSlotObjectPool.INSTANCE.acquire(
                                capability,
                                slot,
                                (OutputResourceTracker<STACK, ITEM, CAP>) tracker
                        ));
                    }
                }
            }
        }
    }

    public LabelAccess labelAccess() {
        return labelAccess;
    }

    public ResourceLimits resourceLimits() {
        return resourceLimits;
    }

    public boolean each() {
        return each;
    }

    @Override
    public boolean equals(Object obj) {
        if (obj == this) return true;
        if (obj == null || obj.getClass() != this.getClass()) return false;
        var that = (OutputStatement) obj;
        return Objects.equals(this.labelAccess, that.labelAccess) &&
               Objects.equals(this.resourceLimits, that.resourceLimits) &&
               this.each == that.each;
    }

    @Override
    public int hashCode() {
        return Objects.hash(labelAccess, resourceLimits, each);
    }

    @Override
    public String toString() {
        return "OUTPUT " + resourceLimits + " TO " + (each ? "EACH " : "") + labelAccess;
    }

    public String toStringPretty() {
        StringBuilder sb = new StringBuilder();
        sb.append("OUTPUT");
        String rls = resourceLimits.toStringPretty(Limit.MAX_QUANTITY_MAX_RETENTION);
        if (rls.lines().count() > 1) {
            sb.append("\n");
            sb.append(rls.lines().map(s -> "  " + s).collect(Collectors.joining("\n")));
            sb.append("\n");
        } else {
            sb.append(" ");
            sb.append(rls);
            sb.append(" ");
        }
        sb.append("TO ");
        sb.append(each ? "EACH " : "");
        sb.append(labelAccess);
        return sb.toString();
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\registry\package-info.java

````java


@ParametersAreNonnullByDefault
@MethodsReturnNonnullByDefault
@FieldsAreNonnullByDefault
package ca.teamdman.sfm.common.registry;

import net.minecraft.FieldsAreNonnullByDefault;
import net.minecraft.MethodsReturnNonnullByDefault;

import javax.annotation.ParametersAreNonnullByDefault;
````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\cablenetwork\package-info.java

````java

@ParametersAreNonnullByDefault
@MethodsReturnNonnullByDefault
@FieldsAreNonnullByDefault
package ca.teamdman.sfm.common.cablenetwork;

import net.minecraft.FieldsAreNonnullByDefault;
import net.minecraft.MethodsReturnNonnullByDefault;

import javax.annotation.ParametersAreNonnullByDefault;
````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\client\jei\PrintingPressJEICategory.java

````java
package ca.teamdman.sfm.client.jei;

import ca.teamdman.sfm.SFM;
import ca.teamdman.sfm.common.Constants;
import ca.teamdman.sfm.common.item.FormItem;
import ca.teamdman.sfm.common.recipe.PrintingPressRecipe;
import ca.teamdman.sfm.common.registry.SFMBlocks;
import mezz.jei.api.gui.builder.IRecipeLayoutBuilder;
import mezz.jei.api.gui.drawable.IDrawable;
import mezz.jei.api.helpers.IJeiHelpers;
import mezz.jei.api.recipe.IFocusGroup;
import mezz.jei.api.recipe.RecipeIngredientRole;
import mezz.jei.api.recipe.RecipeType;
import mezz.jei.api.recipe.category.IRecipeCategory;
import net.minecraft.network.chat.Component;
import net.minecraft.world.item.ItemStack;

import java.util.Arrays;

public class PrintingPressJEICategory implements IRecipeCategory<PrintingPressRecipe> {

    public static final RecipeType<PrintingPressRecipe> RECIPE_TYPE = RecipeType.create(
            SFM.MOD_ID,
            "printing_press",
            PrintingPressRecipe.class
    );
    private final IDrawable background;
    private final IDrawable icon;
    private final IDrawable slot;

    public PrintingPressJEICategory(IJeiHelpers jeiHelpers) {
        background = jeiHelpers.getGuiHelper().createBlankDrawable(50, 54);
        icon = jeiHelpers.getGuiHelper().createDrawableItemStack(new ItemStack(SFMBlocks.PRINTING_PRESS_BLOCK.get()));
        slot = jeiHelpers.getGuiHelper().getSlotDrawable();
    }

    @Override
    public RecipeType<PrintingPressRecipe> getRecipeType() {
        return RECIPE_TYPE;
    }

    @Override
    public Component getTitle() {
        return Constants.LocalizationKeys.PRINTING_PRESS_JEI_CATEGORY_TITLE.getComponent();
    }

    @Override
    public IDrawable getBackground() {
        return background;
    }

    @Override
    public IDrawable getIcon() {
        return icon;
    }

    @Override
    public void setRecipe(IRecipeLayoutBuilder builder, PrintingPressRecipe recipe, IFocusGroup focuses) {
        builder
                .addSlot(RecipeIngredientRole.INPUT, 0, 0)
                .addItemStacks(Arrays.stream(recipe.FORM.getItems()).map(FormItem::getForm).toList())
                .setBackground(slot, -1, -1);
        builder.addSlot(RecipeIngredientRole.INPUT, 0, 18).addIngredients(recipe.INK).setBackground(slot, -1, -1);
        builder.addSlot(RecipeIngredientRole.INPUT, 0, 36).addIngredients(recipe.PAPER).setBackground(slot, -1, -1);
        builder.addSlot(RecipeIngredientRole.OUTPUT, 25, 18).addIngredients(recipe.FORM);
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\client\gui\screen\ExtendedButtonWithTooltip.java

````java
package ca.teamdman.sfm.client.gui.screen;

import com.mojang.blaze3d.vertex.PoseStack;
import net.minecraft.network.chat.Component;
import net.minecraftforge.client.gui.widget.ExtendedButton;

public class ExtendedButtonWithTooltip extends ExtendedButton {
    private final OnTooltip TOOLTIP;

    public ExtendedButtonWithTooltip(
            int xPos,
            int yPos,
            int width,
            int height,
            Component displayString,
            OnPress handler,
            OnTooltip tooltip
    ) {
        super(xPos, yPos, width, height, displayString, handler);
        TOOLTIP = tooltip;
    }

    @Override
    public void renderToolTip(PoseStack pose, int mx, int my) {
        if (isHovered && visible) {
            TOOLTIP.onTooltip(this, pose, mx, my);
        }
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\client\ClientStuff.java

````java
package ca.teamdman.sfm.client;

import ca.teamdman.sfm.SFM;
import ca.teamdman.sfm.client.gui.screen.LabelGunScreen;
import ca.teamdman.sfm.client.gui.screen.ProgramEditScreen;
import ca.teamdman.sfm.client.registry.SFMKeyMappings;
import ca.teamdman.sfm.client.render.PrintingPressBlockEntityRenderer;
import ca.teamdman.sfm.common.containermenu.ManagerContainerMenu;
import ca.teamdman.sfm.common.item.DiskItem;
import ca.teamdman.sfm.common.net.ClientboundManagerGuiPacket;
import ca.teamdman.sfm.common.registry.SFMBlockEntities;
import com.mojang.blaze3d.platform.InputConstants;
import net.minecraft.client.Minecraft;
import net.minecraft.client.multiplayer.ClientLevel;
import net.minecraft.client.player.LocalPlayer;
import net.minecraft.world.InteractionHand;
import net.minecraft.world.item.ItemStack;
import net.minecraft.world.level.block.entity.BlockEntity;
import net.minecraft.world.phys.BlockHitResult;
import net.minecraft.world.phys.HitResult;
import net.minecraftforge.api.distmarker.Dist;
import net.minecraftforge.client.event.EntityRenderersEvent;
import net.minecraftforge.eventbus.api.SubscribeEvent;
import net.minecraftforge.fml.common.Mod;
import net.minecraftforge.fml.loading.FMLEnvironment;

import javax.annotation.Nullable;
import java.util.function.Consumer;

@Mod.EventBusSubscriber(modid = SFM.MOD_ID, value = Dist.CLIENT, bus = Mod.EventBusSubscriber.Bus.MOD)
public class ClientStuff {
    public static void showLabelGunScreen(ItemStack stack, InteractionHand hand) {
        Minecraft
                .getInstance()
                .setScreen(new LabelGunScreen(stack, hand));
    }

    public static void showProgramEditScreen(String initialContent, Consumer<String> callback) {
        ProgramEditScreen screen = new ProgramEditScreen(initialContent, callback);
        if (Minecraft.getInstance().screen == null) {
            Minecraft
                    .getInstance()
                    .setScreen(screen);
        } else {
            Minecraft
                    .getInstance()
                    .pushGuiLayer(screen);
        }
        screen.scrollToTop();
    }

    public static void showProgramEditScreen(ItemStack diskItem, Consumer<String> callback) {
        showProgramEditScreen(DiskItem.getProgram(diskItem), callback);
    }

    @SubscribeEvent
    public static void onRegisterRenderers(EntityRenderersEvent.RegisterRenderers event) {
        event.registerBlockEntityRenderer(
                SFMBlockEntities.PRINTING_PRESS_BLOCK_ENTITY.get(),
                PrintingPressBlockEntityRenderer::new
        );
    }

    public static boolean isMoreInfoKeyDown() {
        // special effort is needed to ensure this works properly when the manager screen is open
        // https://github.com/mekanism/Mekanism/blob/f92b48a49e0766cd3aa78e95c9c4a47ba90402f5/src/main/java/mekanism/client/key/MekKeyHandler.java
        long handle = Minecraft.getInstance().getWindow().getWindow();
        return InputConstants.isKeyDown(
                handle,
                SFMKeyMappings.MORE_INFO_TOOLTIP_KEY
                        .get()
                        .getKey()
                        .getValue()
        );
    }

    public static void updateMenu(ClientboundManagerGuiPacket msg) {
        LocalPlayer player = Minecraft.getInstance().player;
        if (player == null) return;
        var container = player.containerMenu;
        if (container instanceof ManagerContainerMenu menu && container.containerId == msg.windowId()) {
            menu.tickTimeNanos = msg.tickTimes();
            menu.state = msg.state();
            menu.program = msg.program();
        }
    }

    public static @Nullable BlockEntity getLookBlockEntity() {
        assert FMLEnvironment.dist.isClient();
        ClientLevel level = Minecraft.getInstance().level;
        if (level == null) return null;
        HitResult hr = Minecraft.getInstance().hitResult;
        if (hr == null) return null;
        if (hr.getType() != HitResult.Type.BLOCK) return null;
        var pos = ((BlockHitResult) hr).getBlockPos();
        return level.getBlockEntity(pos);
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\item\ExperienceShard.java

````java
package ca.teamdman.sfm.common.item;

import ca.teamdman.sfm.common.registry.SFMItems;
import net.minecraft.world.item.Item;

public class ExperienceShard extends Item {
    public ExperienceShard() {
        super(new Item.Properties().tab(SFMItems.TAB));
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\item\PrintingPressBlockItem.java

````java
package ca.teamdman.sfm.common.item;

import ca.teamdman.sfm.common.Constants;
import ca.teamdman.sfm.common.registry.SFMBlocks;
import ca.teamdman.sfm.common.registry.SFMItems;
import net.minecraft.ChatFormatting;
import net.minecraft.network.chat.Component;
import net.minecraft.world.item.BlockItem;
import net.minecraft.world.item.ItemStack;
import net.minecraft.world.item.TooltipFlag;
import net.minecraft.world.level.Level;
import org.jetbrains.annotations.Nullable;

import java.util.List;

public class PrintingPressBlockItem extends BlockItem {
    public PrintingPressBlockItem() {
        super(SFMBlocks.PRINTING_PRESS_BLOCK.get(), new Properties().tab(SFMItems.TAB));
    }

    @Override
    public void appendHoverText(ItemStack pStack, @Nullable Level pLevel, List<Component> pTooltip, TooltipFlag pFlag) {
        super.appendHoverText(pStack, pLevel, pTooltip, pFlag);
        pTooltip.add(Constants.LocalizationKeys.PRINTING_PRESS_TOOLTIP.getComponent().withStyle(ChatFormatting.GRAY));
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\program\OutputResourceTracker.java

````java
package ca.teamdman.sfm.common.program;

import ca.teamdman.sfm.common.resourcetype.ResourceType;
import ca.teamdman.sfml.ast.ResourceIdSet;
import ca.teamdman.sfml.ast.ResourceLimit;

import java.util.concurrent.atomic.AtomicLong;
import java.util.function.Predicate;

public class OutputResourceTracker<STACK, ITEM, CAP> implements Predicate<Object> {
    private final ResourceLimit<STACK, ITEM, CAP> LIMIT;
    private final ResourceIdSet EXCLUSIONS;
    private final AtomicLong TRANSFERRED;
    private final AtomicLong RETENTION_OBLIGATION_PROGRESS;

    public OutputResourceTracker(
            ResourceLimit<STACK, ITEM, CAP> resourceLimit,
            ResourceIdSet exclusions,
            AtomicLong transferred,
            AtomicLong retentionObligationProgress
    ) {
        this.LIMIT = resourceLimit;
        this.EXCLUSIONS = exclusions;
        this.TRANSFERRED = transferred;
        this.RETENTION_OBLIGATION_PROGRESS = retentionObligationProgress;
    }

    /**
     * Done when we have reached the transfer limit, or when the retention is satisfied
     */
    public boolean isDone() {
        return TRANSFERRED.get() >= LIMIT.limit().quantity().number().value()
               || RETENTION_OBLIGATION_PROGRESS.get() >= LIMIT.limit().retention().number().value();
    }

    /**
     * Update obligation progress as new limited slots are prepared
     */
    public void visit(LimitedOutputSlot<STACK, ITEM, CAP> slot) {
        var stack = slot.getStackInSlot();
        if (test(stack)) {
            RETENTION_OBLIGATION_PROGRESS.accumulateAndGet(slot.type.getAmount(stack), Long::sum);
        }
    }

    public void trackTransfer(long amount) {
        TRANSFERRED.accumulateAndGet(amount, Long::sum);
        RETENTION_OBLIGATION_PROGRESS.accumulateAndGet(amount, Long::sum);
    }

    /**
     * How much more are we allowed to move
     */
    public long getMaxTransferable() {
        long remainingRetentionRoom = LIMIT.limit().retention().number().value() - RETENTION_OBLIGATION_PROGRESS.get();
        long unusedQuantity = LIMIT.limit().quantity().number().value() - TRANSFERRED.get();
        return Math.min(unusedQuantity, remainingRetentionRoom);
    }

    public boolean matchesCapabilityType(Object capability) {
        ResourceType<STACK, ITEM, CAP> resourceType = LIMIT.resourceId().getResourceType();
        return resourceType != null && resourceType.matchesCapabilityType(capability);
    }

    @Override
    public boolean test(Object stack) {
        return LIMIT.test(stack) && !EXCLUSIONS.test(stack);
    }

    public ResourceLimit<STACK, ITEM, CAP> getLimit() {
        return LIMIT;
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\net\ServerboundLabelGunUsePacket.java

````java
package ca.teamdman.sfm.common.net;

import ca.teamdman.sfm.common.Constants;
import ca.teamdman.sfm.common.blockentity.ManagerBlockEntity;
import ca.teamdman.sfm.common.cablenetwork.CableNetwork;
import ca.teamdman.sfm.common.cablenetwork.CableNetworkManager;
import ca.teamdman.sfm.common.item.LabelGunItem;
import ca.teamdman.sfm.common.program.LabelPositionHolder;
import ca.teamdman.sfm.common.util.SFMUtils;
import net.minecraft.core.BlockPos;
import net.minecraft.core.Direction;
import net.minecraft.network.FriendlyByteBuf;
import net.minecraft.world.InteractionHand;
import net.minecraft.world.level.block.Block;
import net.minecraftforge.network.NetworkEvent;

import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.function.Supplier;
import java.util.stream.Collectors;

public record ServerboundLabelGunUsePacket(
        InteractionHand hand,
        BlockPos pos,
        boolean isCtrlKeyDown,
        boolean isShiftKeyDown
) {

    public static void encode(ServerboundLabelGunUsePacket msg, FriendlyByteBuf buf) {
        buf.writeEnum(msg.hand);
        buf.writeBlockPos(msg.pos);
        buf.writeBoolean(msg.isCtrlKeyDown);
        buf.writeBoolean(msg.isShiftKeyDown);
    }

    public static ServerboundLabelGunUsePacket decode(
            FriendlyByteBuf buf
    ) {
        return new ServerboundLabelGunUsePacket(
                buf.readEnum(InteractionHand.class),
                buf.readBlockPos(),
                buf.readBoolean(),
                buf.readBoolean()
        );
    }

    public static void handle(
            ServerboundLabelGunUsePacket msg, Supplier<NetworkEvent.Context> ctx
    ) {
        ctx.get().enqueueWork(() -> {
            var sender = ctx.get().getSender();
            if (sender == null) {
                return;
            }
            var stack = sender.getItemInHand(msg.hand);
            var level = sender.getLevel();
            if (!(stack.getItem() instanceof LabelGunItem)) {
                return;
            }

            var gunLabels = LabelPositionHolder.from(stack);
            var pos = msg.pos;

            // target is a manager, perform push or pull action
            if (level.getBlockEntity(pos) instanceof ManagerBlockEntity manager) {
                manager.getDisk().ifPresent(disk -> {
                    if (msg.isShiftKeyDown) {
                        // start with labels from disk
                        var newLabels = LabelPositionHolder.from(disk);
                        // ensure script-referenced labels are included
                        manager.getReferencedLabels().forEach(newLabels::addReferencedLabel);
                        // save to gun
                        newLabels.save(stack);
                        // give feedback to player
                        sender.sendSystemMessage(Constants.LocalizationKeys.LABEL_GUN_CHAT_PULLED.getComponent());
                    } else {
                        // save gun labels to disk
                        gunLabels.save(disk);
                        // rebuild program
                        manager.rebuildProgramAndUpdateDisk();
                        // mark manager dirty
                        manager.setChanged();
                        // give feedback to player
                        sender.sendSystemMessage(Constants.LocalizationKeys.LABEL_GUN_CHAT_PUSHED.getComponent());
                    }
                });
                return;
            }

            // target is not a manager, we will perform label toggle
            var activeLabel = LabelGunItem.getActiveLabel(stack);
            if (activeLabel.isEmpty()) return;

            if (msg.isCtrlKeyDown) {
                // find all connected inventories of the same block type and toggle the label on all of them
                // if any of them don't have it, apply it, otherwise strip from all

                // find all cable positions so that we only include inventories adjacent to a cable
                Set<BlockPos> cablePositions = CableNetworkManager
                        .getNetworksForLevel(level)
                        .flatMap(CableNetwork::getCablePositions)
                        .collect(Collectors.toSet());

                // get positions of all connected blocks of the same type
                Block targetBlock = level.getBlockState(pos).getBlock();
                List<BlockPos> positions = SFMUtils.getRecursiveStream((current, nextQueue, results) -> {
                    results.accept(current);
                    for (var d : Direction.values()) {
                        var offset = current.offset(d.getNormal());
                        if (level.getBlockState(offset).getBlock() == targetBlock) {
                            // this is the block we are looking for
                            // ensure it is also adjacent to a cable
                            if (Arrays
                                    .stream(Direction.values())
                                    .anyMatch(d2 -> cablePositions.contains(offset.offset(d2.getNormal())))) {
                                nextQueue.accept(offset);
                            }
                        }
                    }
                }, pos).toList();

                // check if any of the positions are missing the label
                var existing = new HashSet<>(gunLabels.getPositions(activeLabel));
                boolean anyMissing = positions.stream().anyMatch(p -> !existing.contains(p));

                // apply or strip label from all positions
                if (anyMissing) {
                    gunLabels.addAll(activeLabel, positions);
                } else {
                    positions.forEach(p -> gunLabels.remove(activeLabel, p));
                }
            } else {
                // normal behaviour - operate on a single position
                if (msg.isShiftKeyDown) {
                    // clear all labels from this position
                    gunLabels.remove(pos);
                } else {
                    // toggle the active label for this position
                    gunLabels.toggle(activeLabel, pos);
                }
            }

            // write changes to label gun stack
            gunLabels.save(stack);
        });
        ctx.get().setPacketHandled(true);
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\registry\SFMBlocks.java

````java
package ca.teamdman.sfm.common.registry;

import ca.teamdman.sfm.SFM;
import ca.teamdman.sfm.common.block.*;
import net.minecraft.world.level.block.Block;
import net.minecraftforge.eventbus.api.IEventBus;
import net.minecraftforge.registries.DeferredRegister;
import net.minecraftforge.registries.ForgeRegistries;
import net.minecraftforge.registries.RegistryObject;


public class SFMBlocks {
    private static final DeferredRegister<Block> BLOCKS = DeferredRegister.create(ForgeRegistries.BLOCKS, SFM.MOD_ID);
    public static final RegistryObject<Block> MANAGER_BLOCK = BLOCKS.register("manager", ManagerBlock::new);
    public static final RegistryObject<Block> PRINTING_PRESS_BLOCK = BLOCKS.register(
            "printing_press",
            PrintingPressBlock::new
    );
    public static final RegistryObject<Block> WATER_TANK_BLOCK = BLOCKS.register("water_tank", WaterTankBlock::new);
    public static final RegistryObject<Block> CABLE_BLOCK = BLOCKS.register("cable", CableBlock::new);
    public static final RegistryObject<Block> BATTERY_BLOCK = BLOCKS.register("battery", BatteryBlock::new);
    public static final RegistryObject<Block> TEST_BARREL_BLOCK = BLOCKS.register("test_barrel", TestBarrelBlock::new);

    public static void register(IEventBus bus) {
        BLOCKS.register(bus);
    }

}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\util\SFMContainerUtil.java

````java
package ca.teamdman.sfm.common.util;

import net.minecraft.world.entity.player.Player;
import net.minecraft.world.level.block.entity.BlockEntity;

public class SFMContainerUtil {
    public static boolean stillValid(BlockEntity blockEntity, Player player) {
        var level = blockEntity.getLevel();
        if (level == null) return false;
        var pos   = blockEntity.getBlockPos();
        if (level.getBlockEntity(pos) != blockEntity) return false;
        double dist = player.distanceToSqr(
                (double) pos.getX() + 0.5D,
                (double) pos.getY() + 0.5D,
                (double) pos.getZ() + 0.5D
        );
        return dist <= 64.0D;
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\program\LabelPositionHolder.java

````java
package ca.teamdman.sfm.common.program;

import ca.teamdman.sfm.common.Constants;
import net.minecraft.ChatFormatting;
import net.minecraft.core.BlockPos;
import net.minecraft.nbt.*;
import net.minecraft.network.chat.Component;
import net.minecraft.world.item.ItemStack;

import java.util.*;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import java.util.function.Predicate;
import java.util.stream.Collectors;

@SuppressWarnings("UnusedReturnValue")
public class LabelPositionHolder {
    private final Map<String, Set<BlockPos>> LABELS = new HashMap<>();

    private LabelPositionHolder() {

    }

    public static LabelPositionHolder empty() {
        return new LabelPositionHolder();
    }

    public static LabelPositionHolder from(ItemStack stack) {
        var labels = LabelPositionHolder.empty();
        var tag = stack.getOrCreateTag().getCompound("sfm:labels");
        for (var label : tag.getAllKeys()) {
            // old: storing BlockPos as long
            labels.addAll(label, tag.getList(label, Tag.TAG_LONG).stream()
                    .map(LongTag.class::cast)
                    .mapToLong(LongTag::getAsLong)
                    .mapToObj(BlockPos::of).collect(Collectors.toList()));

            // new: storing BlockPos as compound
            labels.addAll(label, tag.getList(label, Tag.TAG_COMPOUND).stream()
                    .map(CompoundTag.class::cast)
                    .map(NbtUtils::readBlockPos)
                    .collect(Collectors.toList()));
        }
        return labels;
    }

    public CompoundTag serialize() {
        var tag = new CompoundTag();
        for (var label : get().keySet()) {
            var list = new ListTag();
            list.addAll(LABELS.get(label)
                                .stream()
                                .map(NbtUtils::writeBlockPos)
                                .toList());
            tag.put(label, list);
        }
        return tag;
    }

    public boolean contains(String label, BlockPos pos) {
        return LABELS.getOrDefault(label, Collections.emptySet()).contains(pos);
    }

    public LabelPositionHolder toggle(String label, BlockPos pos) {
        if (contains(label, pos)) {
            remove(label, pos);
        } else {
            add(label, pos);
        }
        return this;
    }

    public Map<String, Set<BlockPos>> get() {
        return LABELS;
    }

    public Set<BlockPos> getPositions(String label) {
        return LABELS.computeIfAbsent(label, s -> new HashSet<>());
    }

    public LabelPositionHolder addAll(String label, Collection<BlockPos> positions) {
        getPositions(label).addAll(positions);
        return this;
    }

    public LabelPositionHolder addReferencedLabel(String label) {
        getPositions(label);
        return this;
    }

    public List<Component> asHoverText() {
        var rtn = new ArrayList<Component>();
        if (LABELS.isEmpty()) return rtn;
        rtn.add(Constants.LocalizationKeys.DISK_ITEM_TOOLTIP_LABEL_HEADER
                        .getComponent()
                        .withStyle(ChatFormatting.UNDERLINE));
        for (var entry : LABELS.entrySet()) {
            rtn.add(Constants.LocalizationKeys.DISK_ITEM_TOOLTIP_LABEL.getComponent(
                    entry.getKey(),
                    entry.getValue().size()
            ).withStyle(ChatFormatting.GRAY));
        }
        return rtn;
    }

    public LabelPositionHolder remove(BlockPos value) {
        LABELS.values().forEach(list -> list.remove(value));
        return this;
    }

    public LabelPositionHolder prune() {
        LABELS.entrySet().removeIf(entry -> entry.getValue().isEmpty());
        return this;
    }

    public LabelPositionHolder clear() {
        LABELS.clear();
        return this;
    }

    public LabelPositionHolder add(String label, BlockPos position) {
        getPositions(label).add(position);
        return this;
    }

    public LabelPositionHolder remove(String label, BlockPos pos) {
        getPositions(label).remove(pos);
        return this;
    }

    public LabelPositionHolder save(ItemStack stack) {
        stack.getOrCreateTag().put("sfm:labels", serialize());
        return this;
    }

    public LabelPositionHolder removeIf(BiPredicate<String, BlockPos> predicate) {
        LABELS.forEach((key, value) -> value.removeIf(pos -> predicate.test(key, pos)));
        return this;
    }

    public LabelPositionHolder removeIf(Predicate<String> predicate) {
        LABELS.keySet().removeIf(predicate);
        return this;
    }

    public LabelPositionHolder forEach(BiConsumer<String, BlockPos> consumer) {
        LABELS.forEach((key, value) -> value.forEach(pos -> consumer.accept(key, pos)));
        return this;
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\resourcetype\GasResourceType.java

````java
package ca.teamdman.sfm.common.resourcetype;

import mekanism.api.Action;
import mekanism.api.MekanismAPI;
import mekanism.api.chemical.gas.Gas;
import mekanism.api.chemical.gas.GasStack;
import mekanism.api.chemical.gas.IGasHandler;
import net.minecraftforge.common.capabilities.Capability;
import net.minecraftforge.common.capabilities.CapabilityToken;
import net.minecraftforge.registries.IForgeRegistry;

import static net.minecraftforge.common.capabilities.CapabilityManager.get;

public class GasResourceType extends ResourceType<GasStack, Gas, IGasHandler> {
    public static final Capability<IGasHandler> CAP = get(new CapabilityToken<>() {
    });

    public GasResourceType() {
        super(CAP);
    }

    @Override
    public long getAmount(GasStack gasStack) {
        return gasStack.getAmount();
    }

    @Override
    public GasStack getStackInSlot(IGasHandler iGasHandler, int slot) {
        return iGasHandler.getChemicalInTank(slot);
    }

    @Override
    public GasStack extract(IGasHandler handler, int slot, long amount, boolean simulate) {
        return handler.extractChemical(slot, amount, simulate ? Action.SIMULATE : Action.EXECUTE);
    }

    @Override
    public int getSlots(IGasHandler handler) {
        return handler.getTanks();
    }

    @Override
    public long getMaxStackSize(GasStack gasStack) {
        return Long.MAX_VALUE;
    }

    @Override
    public long getMaxStackSize(IGasHandler handler, int slot) {
        return handler.getTankCapacity(slot);
    }

    @Override
    public GasStack insert(IGasHandler handler, int slot, GasStack gasStack, boolean simulate) {
        return handler.insertChemical(slot, gasStack, simulate ? Action.SIMULATE : Action.EXECUTE);
    }

    @Override
    public boolean isEmpty(GasStack gasStack) {
        return gasStack.isEmpty();
    }

    @Override
    public GasStack getEmptyStack() {
        return GasStack.EMPTY;
    }

    @Override
    public boolean matchesStackType(Object o) {
        return o instanceof GasStack;
    }

    @Override
    public boolean matchesCapabilityType(Object o) {
        return o instanceof IGasHandler;
    }


    @Override
    public IForgeRegistry<Gas> getRegistry() {
        return MekanismAPI.gasRegistry();
    }

    @Override
    public Gas getItem(GasStack gasStack) {
        return gasStack.getType();
    }

    @Override
    public GasStack copy(GasStack gasStack) {
        return gasStack.copy();
    }

    @Override
    protected GasStack setCount(GasStack gasStack, long amount) {
        gasStack.setAmount(amount);
        return gasStack;
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\blockentity\PrintingPressBlockEntity.java

````java
package ca.teamdman.sfm.common.blockentity;

import ca.teamdman.sfm.common.recipe.NotContainer;
import ca.teamdman.sfm.common.registry.SFMBlockEntities;
import ca.teamdman.sfm.common.registry.SFMItems;
import ca.teamdman.sfm.common.registry.SFMRecipeTypes;
import net.minecraft.core.BlockPos;
import net.minecraft.core.Direction;
import net.minecraft.nbt.CompoundTag;
import net.minecraft.network.Connection;
import net.minecraft.network.protocol.Packet;
import net.minecraft.network.protocol.game.ClientGamePacketListener;
import net.minecraft.network.protocol.game.ClientboundBlockEntityDataPacket;
import net.minecraft.world.item.ItemStack;
import net.minecraft.world.item.crafting.RecipeManager;
import net.minecraft.world.level.block.Block;
import net.minecraft.world.level.block.entity.BlockEntity;
import net.minecraft.world.level.block.state.BlockState;
import net.minecraftforge.common.capabilities.Capability;
import net.minecraftforge.common.capabilities.ForgeCapabilities;
import net.minecraftforge.common.util.LazyOptional;
import net.minecraftforge.items.IItemHandler;
import net.minecraftforge.items.ItemStackHandler;
import net.minecraftforge.items.wrapper.CombinedInvWrapper;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

/**
 * Accepts a paper item and a form item.
 * When a piston is pressed on top of this block, it will print the form onto the paper.
 */
public class PrintingPressBlockEntity extends BlockEntity implements NotContainer {

    private final ItemStackHandler FORM = new ItemStackHandler(1) {
        @Override
        protected void onContentsChanged(int slot) {
            setChanged();
            if (level != null)
                level.sendBlockUpdated(worldPosition, getBlockState(), getBlockState(), Block.UPDATE_ALL);
        }

        @Override
        public int getSlotLimit(int slot) {
            return 1;
        }

        @Override
        public boolean isItemValid(int slot, ItemStack stack) {
            return stack.getItem() == SFMItems.FORM_ITEM.get();
        }
    };

    private final ItemStackHandler INK = new ItemStackHandler(1) {
        @Override
        protected void onContentsChanged(int slot) {
            setChanged();
            if (level != null)
                level.sendBlockUpdated(worldPosition, getBlockState(), getBlockState(), Block.UPDATE_ALL);
        }

        @Override
        public boolean isItemValid(int slot, ItemStack stack) {
            if (getLevel() == null) return false;
            return getLevel().getRecipeManager()
                    .getAllRecipesFor(SFMRecipeTypes.PRINTING_PRESS.get()).stream().anyMatch(r -> r.INK.test(stack));
        }
    };

    private final ItemStackHandler PAPER = new ItemStackHandler(1) {
        @Override
        protected void onContentsChanged(int slot) {
            setChanged();
            if (level != null)
                level.sendBlockUpdated(worldPosition, getBlockState(), getBlockState(), Block.UPDATE_ALL);
        }

        @Override
        public int getSlotLimit(int slot) {
            return 1;
        }

        @Override
        public boolean isItemValid(int slot, ItemStack stack) {
            if (getLevel() == null) return false;
            return getLevel().getRecipeManager()
                    .getAllRecipesFor(SFMRecipeTypes.PRINTING_PRESS.get()).stream().anyMatch(r -> r.PAPER.test(stack));
        }
    };
    private final LazyOptional<IItemHandler> ITEMS_CAPABILITY = LazyOptional.of(() -> new CombinedInvWrapper(
            FORM,
            INK,
            PAPER
    ));

    public PrintingPressBlockEntity(
            BlockPos pPos, BlockState pBlockState
    ) {
        super(SFMBlockEntities.PRINTING_PRESS_BLOCK_ENTITY.get(), pPos, pBlockState);
    }

    @Override
    public void load(CompoundTag tag) {
        super.load(tag);
        readItems(tag);
    }


    @Override
    protected void saveAdditional(CompoundTag tag) {
        super.saveAdditional(tag);
        writeItems(tag);
    }

    private void writeItems(CompoundTag tag) {
        tag.put("form", FORM.serializeNBT());
        tag.put("paper", PAPER.serializeNBT());
        tag.put("ink", INK.serializeNBT());
    }

    private void readItems(CompoundTag tag) {
        INK.deserializeNBT(tag.getCompound("ink"));
        PAPER.deserializeNBT(tag.getCompound("paper"));
        FORM.deserializeNBT(tag.getCompound("form"));
    }

    @Override
    public @NotNull <T> LazyOptional<T> getCapability(@NotNull Capability<T> cap, @Nullable Direction side) {
        if (cap == ForgeCapabilities.ITEM_HANDLER) {
            return ITEMS_CAPABILITY.cast();
        }
        return super.getCapability(cap, side);
    }

    public ItemStack acceptStack(ItemStack stack) {
        ItemStack remainder;
        if (!stack.isEmpty()) {
            remainder = FORM.insertItem(0, stack.copy(), false);
            if (remainder.getCount() < stack.getCount()) {
                stack.shrink(stack.getCount() - remainder.getCount());
                return stack;
            }
            remainder = INK.insertItem(0, stack.copy(), false);
            if (remainder.getCount() < stack.getCount()) {
                stack.shrink(stack.getCount() - remainder.getCount());
                return stack;
            }
            remainder = PAPER.insertItem(0, stack.copy(), false);
            if (remainder.getCount() < stack.getCount()) {
                stack.shrink(stack.getCount() - remainder.getCount());
                return stack;
            }
        } else {
            ItemStack found;
            found = PAPER.extractItem(0, 64, false);
            if (!found.isEmpty()) {
                return found;
            }
            found = FORM.extractItem(0, 64, false);
            if (!found.isEmpty()) {
                return found;
            }
            found = INK.extractItem(0, 64, false);
            if (!found.isEmpty()) {
                return found;
            }
        }
        return stack;
    }

    @Override
    public CompoundTag getUpdateTag() {
        var tag = super.getUpdateTag();
        writeItems(tag);
        return tag;
    }

    @Nullable
    @Override
    public Packet<ClientGamePacketListener> getUpdatePacket() {
        return ClientboundBlockEntityDataPacket.create(this);
    }

    @Override
    public void onDataPacket(Connection net, ClientboundBlockEntityDataPacket pkt) {
        super.onDataPacket(net, pkt);
        CompoundTag tag = pkt.getTag();
        if (tag != null)
            readItems(tag);
    }

    public ItemStack getPaper() {
        return PAPER.getStackInSlot(0);
    }

    public ItemStack getInk() {
        return INK.getStackInSlot(0);
    }

    public ItemStack getForm() {
        return FORM.getStackInSlot(0);
    }

    public void performPrint() {
        if (getLevel() == null) return;
        RecipeManager recipeManager = getLevel().getRecipeManager();
        recipeManager.getRecipeFor(SFMRecipeTypes.PRINTING_PRESS.get(), this, getLevel()).ifPresent(recipe -> {
            ItemStack paper = getPaper();
            ItemStack ink = getInk();
            ItemStack form = getForm();
            if (paper.isEmpty() || ink.isEmpty() || form.isEmpty()) {
                return;
            }
            paper = recipe.assemble(this);
            PAPER.setStackInSlot(0, paper);
            ink.shrink(1);
            INK.setStackInSlot(0, ink);
        });
    }

    public ItemStack[] getStacksToDrop() {
        return new ItemStack[]{getPaper(), getInk(), getForm()};
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\capabilityprovidermapper\CauldronCapabilityProviderMapper.java

````java
package ca.teamdman.sfm.common.capabilityprovidermapper;

import net.minecraft.core.BlockPos;
import net.minecraft.core.Direction;
import net.minecraft.world.level.LevelAccessor;
import net.minecraft.world.level.block.Block;
import net.minecraft.world.level.block.Blocks;
import net.minecraft.world.level.block.LayeredCauldronBlock;
import net.minecraft.world.level.material.Fluids;
import net.minecraftforge.common.capabilities.Capability;
import net.minecraftforge.common.capabilities.ForgeCapabilities;
import net.minecraftforge.common.capabilities.ICapabilityProvider;
import net.minecraftforge.common.util.LazyOptional;
import net.minecraftforge.fluids.FluidStack;
import net.minecraftforge.fluids.capability.IFluidHandler;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import javax.annotation.Nonnull;
import java.util.Optional;

public class CauldronCapabilityProviderMapper implements CapabilityProviderMapper {
    @Override
    public Optional<ICapabilityProvider> getProviderFor(LevelAccessor level, BlockPos pos) {
        var state = level.getBlockState(pos);
        if (state.getBlock() == Blocks.CAULDRON
            || state.getBlock() == Blocks.WATER_CAULDRON
            || state.getBlock() == Blocks.LAVA_CAULDRON) {
            return Optional.of(new CauldronCapabilityProvider(level, pos));
        }
        return Optional.empty();
    }

    private static class CauldronCapabilityProvider implements ICapabilityProvider {
        private final LazyOptional<IFluidHandler> fluidHandlerLazyOptional;


        public CauldronCapabilityProvider(LevelAccessor level, BlockPos pos) {
            this.fluidHandlerLazyOptional = LazyOptional.of(() -> new CauldronFluidHandler(level, pos));
        }

        @Nonnull
        @Override
        public @NotNull <T> LazyOptional<T> getCapability(@Nonnull Capability<T> cap, @Nullable Direction side) {
            if (cap == ForgeCapabilities.FLUID_HANDLER) {
                return fluidHandlerLazyOptional.cast();
            }
            return LazyOptional.empty();
        }
    }

    private record CauldronFluidHandler(
            LevelAccessor level,
            BlockPos pos
    ) implements IFluidHandler {

        @Override
        public int getTanks() {
            return 1;
        }

        @Override
        public @NotNull FluidStack getFluidInTank(int tank) {
            var state = level.getBlockState(pos);
            if (state.getBlock() == Blocks.WATER_CAULDRON) {
                int level = state.getValue(LayeredCauldronBlock.LEVEL);
                if (level == 0) {
                    return FluidStack.EMPTY;
                }
                return new FluidStack(Fluids.WATER, level * 250);
            } else if (state.getBlock() == Blocks.LAVA_CAULDRON) {
                return new FluidStack(Fluids.LAVA, 1000);
            }
            return FluidStack.EMPTY;
        }

        @Override
        public int getTankCapacity(int tank) {
            return 1000;
        }

        @Override
        public boolean isFluidValid(int tank, @NotNull FluidStack stack) {
            return stack.getFluid() == Fluids.WATER || stack.getFluid() == Fluids.LAVA;
        }

        @Override
        public int fill(FluidStack resource, FluidAction action) {
            var state = level.getBlockState(pos);
            if (state.getBlock() == Blocks.CAULDRON) { // if empty
                if (resource.getFluid() == Fluids.WATER) {
                    int layers = Math.min(3, resource.getAmount() / 250);
                    if (action.execute()) {
                        level.setBlock(
                                pos,
                                Blocks.WATER_CAULDRON.defaultBlockState().setValue(
                                        LayeredCauldronBlock.LEVEL,
                                        layers
                                ),
                                Block.UPDATE_ALL
                        );
                    }
                    return layers * 250;
                } else if (resource.getFluid() == Fluids.LAVA && resource.getAmount() >= 1000) {
                    if (action.execute()) {
                        level.setBlock(
                                pos,
                                Blocks.LAVA_CAULDRON.defaultBlockState(),
                                Block.UPDATE_ALL
                        );
                    }
                    return 1000;
                }
            } else if (state.getBlock() instanceof LayeredCauldronBlock) {
                int waterLevel = state.getValue(LayeredCauldronBlock.LEVEL);
                if (waterLevel >= 3) {
                    return 0;
                }
                int waterLevelIncrease = Math.min(3 - waterLevel, Math.min(3, resource.getAmount() / 250));
                if (action.execute()) {
                    level.setBlock(
                            pos,
                            state.setValue(LayeredCauldronBlock.LEVEL, waterLevel + waterLevelIncrease),
                            Block.UPDATE_ALL
                    );
                }
                return waterLevelIncrease * 250;
            }
            return 0;
        }

        @Override
        public @NotNull FluidStack drain(FluidStack resource, FluidAction action) {
            var state = level.getBlockState(pos);
            if (state.getBlock() instanceof LayeredCauldronBlock) {
                int waterLevel = state.getValue(LayeredCauldronBlock.LEVEL);
                if (waterLevel == 0) {
                    return FluidStack.EMPTY;
                }
                int waterLevelDrain = Math.min(waterLevel, resource.getAmount() / 250);
                if (action.execute()) {
                    int resultLevel = waterLevel - waterLevelDrain;
                    if (resultLevel == 0) {
                        level.setBlock(
                                pos,
                                Blocks.CAULDRON.defaultBlockState(),
                                Block.UPDATE_ALL
                        );
                    } else {
                        level.setBlock(
                                pos,
                                state.setValue(LayeredCauldronBlock.LEVEL, resultLevel),
                                Block.UPDATE_ALL
                        );
                    }
                }
                return new FluidStack(Fluids.WATER, waterLevelDrain * 250);
            } else if (state.getBlock() == Blocks.LAVA_CAULDRON && resource.getAmount() >= 1000) {
                if (action.execute()) {
                    level.setBlock(
                            pos,
                            Blocks.CAULDRON.defaultBlockState(),
                            Block.UPDATE_ALL
                    );
                }
                return new FluidStack(Fluids.LAVA, 1000);
            }
            return FluidStack.EMPTY;
        }

        @Override
        public @NotNull FluidStack drain(int maxDrain, FluidAction action) {
            var state = level.getBlockState(pos);
            if (state.getBlock() instanceof LayeredCauldronBlock) {
                int waterLevel = state.getValue(LayeredCauldronBlock.LEVEL);
                if (waterLevel == 0) {
                    return FluidStack.EMPTY;
                }
                int waterLevelDrain = Math.min(waterLevel, maxDrain / 250);
                if (action.execute()) {
                    level.setBlock(
                            pos,
                            state.setValue(LayeredCauldronBlock.LEVEL, waterLevel - waterLevelDrain),
                            Block.UPDATE_ALL
                    );
                }
                return new FluidStack(Fluids.WATER, waterLevelDrain * 250);
            } else if (state.getBlock() == Blocks.LAVA_CAULDRON && maxDrain >= 1000) {
                if (action.execute()) {
                    level.setBlock(
                            pos,
                            Blocks.CAULDRON.defaultBlockState(),
                            Block.UPDATE_ALL
                    );
                }
                return new FluidStack(Fluids.LAVA, 1000);
            }
            return FluidStack.EMPTY;
        }
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfml\ast\InputStatement.java

````java
package ca.teamdman.sfml.ast;

import ca.teamdman.sfm.common.program.InputResourceTracker;
import ca.teamdman.sfm.common.program.LimitedInputSlot;
import ca.teamdman.sfm.common.program.LimitedInputSlotObjectPool;
import ca.teamdman.sfm.common.program.ProgramContext;
import ca.teamdman.sfm.common.resourcetype.ResourceType;

import java.util.List;
import java.util.function.Consumer;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public record InputStatement(
        LabelAccess labelAccess,
        ResourceLimits resourceLimits,
        boolean each
) implements Statement {

    @Override
    public void tick(ProgramContext context) {
        context.addInput(this);
    }

    private static final LimitedInputSlotObjectPool SLOT_POOL = new LimitedInputSlotObjectPool();

    @SuppressWarnings("rawtypes")
    public static void releaseSlots(List<LimitedInputSlot> slots) {
        SLOT_POOL.release(slots);
    }

    public static void releaseSlot(LimitedInputSlot<?, ?, ?> slot) {
        SLOT_POOL.release(slot);
    }

    @SuppressWarnings({"rawtypes", "unchecked"}) // basically impossible to make this method generic safe
    public void gatherSlots(ProgramContext context, Consumer<LimitedInputSlot<?, ?, ?>> acceptor) {
        Stream<ResourceType> types = resourceLimits
                .resourceLimits()
                .stream()
                .map(ResourceLimit::resourceId)
                .map((ResourceIdentifier x) -> x.getResourceType())
                .distinct();

        if (!each) {
            // create a single matcher to be shared by all capabilities
            List<InputResourceTracker<?, ?, ?>> inputMatchers = resourceLimits.createInputTrackers();
            for (var type : (Iterable<ResourceType>) types::iterator) {
                for (var capability : (Iterable) type.getCapabilities(context, labelAccess)::iterator) {
                    gatherSlots((ResourceType<Object, Object, Object>) type, capability, inputMatchers, acceptor);
                }
            }
        } else {
            for (ResourceType type : (Iterable<ResourceType>) types::iterator) {
                for (var cap : (Iterable<?>) type.getCapabilities(context, labelAccess)::iterator) {
                    List<InputResourceTracker<?, ?, ?>> inputTrackers = resourceLimits.createInputTrackers();
                    gatherSlots((ResourceType<Object, Object, Object>) type, cap, inputTrackers, acceptor);
                }
            }
        }
    }

    private <STACK, ITEM, CAP> void gatherSlots(
            ResourceType<STACK, ITEM, CAP> type,
            CAP capability,
            List<InputResourceTracker<?, ?, ?>> trackers,
            Consumer<LimitedInputSlot<?, ?, ?>> acceptor
    ) {
        for (int slot = 0; slot < type.getSlots(capability); slot++) {
            if (labelAccess.slots().contains(slot)) {
                STACK stack = type.getStackInSlot(capability, slot);
                if (!type.isEmpty(stack)) {
                    for (InputResourceTracker<?, ?, ?> tracker : trackers) {
                        if (tracker.matchesCapabilityType(capability) && tracker.test(stack)) {
                            //noinspection unchecked
                            acceptor.accept(SLOT_POOL.acquire(
                                    capability,
                                    slot,
                                    (InputResourceTracker<STACK, ITEM, CAP>) tracker
                            ));
                        }
                    }
                }
            }
        }
    }

    @Override
    public String toString() {
        return "INPUT " + resourceLimits + " FROM " + (each ? "EACH " : "") + labelAccess;
    }

    public String toStringPretty() {
        StringBuilder sb = new StringBuilder();
        sb.append("INPUT");
        String rls = resourceLimits.toStringPretty(Limit.MAX_QUANTITY_NO_RETENTION);
        if (rls.lines().count() > 1) {
            sb.append("\n");
            sb.append(rls.lines().map(s -> "  " + s).collect(Collectors.joining("\n")));
            sb.append("\n");
        } else {
            sb.append(" ");
            sb.append(rls);
            sb.append(" ");
        }
        sb.append("FROM ");
        sb.append(each ? "EACH " : "");
        sb.append(labelAccess);
        return sb.toString();
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\client\jei\FallingAnvilFormRecipe.java

````java
package ca.teamdman.sfm.client.jei;

import ca.teamdman.sfm.common.recipe.PrintingPressRecipe;

public class FallingAnvilFormRecipe extends FallingAnvilRecipe {
    public final PrintingPressRecipe PARENT;

    public FallingAnvilFormRecipe(PrintingPressRecipe parent) {
        this.PARENT = parent;
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\client\ProgramTokenContextActions.java

````java
package ca.teamdman.sfm.client;

import ca.teamdman.sfm.SFM;
import ca.teamdman.sfm.common.net.ServerboundInputInspectionRequestPacket;
import ca.teamdman.sfm.common.net.ServerboundLabelInspectionRequestPacket;
import ca.teamdman.sfm.common.net.ServerboundOutputInspectionRequestPacket;
import ca.teamdman.sfm.common.registry.SFMPackets;
import ca.teamdman.sfml.SFMLLexer;
import ca.teamdman.sfml.SFMLParser;
import ca.teamdman.sfml.ast.*;
import org.antlr.v4.runtime.CharStreams;
import org.antlr.v4.runtime.CommonTokenStream;
import org.antlr.v4.runtime.ParserRuleContext;
import org.antlr.v4.runtime.Token;

import java.util.Optional;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class ProgramTokenContextActions {

    public static Optional<Runnable> getContextAction(String programString, int cursorPosition) {
        var lexer = new SFMLLexer(CharStreams.fromString(programString));
        var tokens = new CommonTokenStream(lexer);
        var parser = new SFMLParser(tokens);
        var builder = new ASTBuilder();
        try {
            builder.visitProgram(parser.program());
            SFM.LOGGER.info("Gathering context actions for cursor position " + cursorPosition);
            return Stream.concat(
                            builder
                                    .getNodesUnderCursor(cursorPosition)
                                    .stream(),
                            builder
                                    .getNodesUnderCursor(cursorPosition - 1)
                                    .stream()
                    )
                    .map(pair -> getContextAction(programString, builder, pair.a, pair.b, cursorPosition))
                    .filter(Optional::isPresent)
                    .map(Optional::get)
                    .findFirst();
        } catch (Throwable t) {
            return Optional.of(() -> ClientStuff.showProgramEditScreen("-- Encountered error, program parse failed:\n--"
                                                                       + t.getMessage(), next -> {
            }));
        }
    }

    public static Optional<Runnable> getContextAction(
            String programString,
            ASTBuilder builder,
            ASTNode node,
            ParserRuleContext parserRuleContext,
            int cursorPosition
    ) {
        SFM.LOGGER.info("Checking if context action exists for node {} {}", node.getClass(), node);
        if (node instanceof ResourceIdentifier<?, ?, ?> rid) {
            SFM.LOGGER.info("Found context action for resource identifier node");
            return Optional.of(() -> {
                String expansion = rid
                        .expand()
                        .stream()
                        .map(ResourceIdentifier::toStringCondensed)
                        .collect(Collectors.joining(",\n"));
                ClientStuff.showProgramEditScreen(expansion, next -> {
                });
            });
        } else if (node instanceof Label label) {
            SFM.LOGGER.info("Found context action for label node");
            return Optional.of(() -> SFMPackets.INSPECTION_CHANNEL.sendToServer(new ServerboundLabelInspectionRequestPacket(
                    label.name()
            )));
        } else if (node instanceof InputStatement) {
            if (cursorPosition > parserRuleContext.getStart().getStartIndex() + "INPUT".length()) {
                SFM.LOGGER.info("Found context action for input node, but the cursor isn't at the start of the node");
                return Optional.empty();
            }
            SFM.LOGGER.info("Found context action for input node");
            int nodeIndex = builder.getIndexForNode(node);
            return Optional.of(() -> SFMPackets.INSPECTION_CHANNEL.sendToServer(new ServerboundInputInspectionRequestPacket(
                    programString,
                    nodeIndex
            )));
        } else if (node instanceof OutputStatement) {
            if (cursorPosition > parserRuleContext.getStart().getStartIndex() + "OUTPUT".length()) {
                SFM.LOGGER.info("Found context action for output node, but the cursor isn't at the start of the node");
                return Optional.empty();
            }
            SFM.LOGGER.info("Found context action for output node");
            int nodeIndex = builder.getIndexForNode(node);
            return Optional.of(() -> SFMPackets.INSPECTION_CHANNEL.sendToServer(new ServerboundOutputInspectionRequestPacket(
                    programString,
                    nodeIndex
            )));
        }
        return Optional.empty();
    }

    public static boolean hasContextAction(Token token) {
        return switch (token.getType()) {
            case SFMLLexer.INPUT, SFMLLexer.OUTPUT, SFMLLexer.IDENTIFIER -> true;
            default -> false;
        };
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\registry\SFMBlockEntities.java

````java
package ca.teamdman.sfm.common.registry;


import ca.teamdman.sfm.SFM;
import ca.teamdman.sfm.common.blockentity.BatteryBlockEntity;
import ca.teamdman.sfm.common.blockentity.ManagerBlockEntity;
import ca.teamdman.sfm.common.blockentity.PrintingPressBlockEntity;
import ca.teamdman.sfm.common.blockentity.WaterTankBlockEntity;
import net.minecraft.world.level.block.entity.BlockEntityType;
import net.minecraftforge.eventbus.api.IEventBus;
import net.minecraftforge.registries.DeferredRegister;
import net.minecraftforge.registries.ForgeRegistries;
import net.minecraftforge.registries.RegistryObject;

@SuppressWarnings("DataFlowIssue")
public final class SFMBlockEntities {

    private static final DeferredRegister<BlockEntityType<?>> BLOCK_ENTITY_TYPES = DeferredRegister.create(
            ForgeRegistries.BLOCK_ENTITY_TYPES,
            SFM.MOD_ID
    );

    public static void register(IEventBus bus) {
        BLOCK_ENTITY_TYPES.register(bus);
    }

    public static final RegistryObject<BlockEntityType<ManagerBlockEntity>> MANAGER_BLOCK_ENTITY = BLOCK_ENTITY_TYPES.register(
            "manager",
            () -> BlockEntityType.Builder
                    .of(ManagerBlockEntity::new, SFMBlocks.MANAGER_BLOCK.get())
                    .build(null)
    );
    public static final RegistryObject<BlockEntityType<PrintingPressBlockEntity>> PRINTING_PRESS_BLOCK_ENTITY = BLOCK_ENTITY_TYPES.register(
            "printing_press",
            () -> BlockEntityType.Builder
                    .of(PrintingPressBlockEntity::new, SFMBlocks.PRINTING_PRESS_BLOCK.get())
                    .build(null)
    );

    public static final RegistryObject<BlockEntityType<WaterTankBlockEntity>> WATER_TANK_BLOCK_ENTITY = BLOCK_ENTITY_TYPES.register(
            "water_tank",
            () -> BlockEntityType.Builder
                    .of(WaterTankBlockEntity::new, SFMBlocks.WATER_TANK_BLOCK.get())
                    .build(null)
    );

    public static final RegistryObject<BlockEntityType<BatteryBlockEntity>> BATTERY_BLOCK_ENTITY = BLOCK_ENTITY_TYPES.register(
            "battery",
            () -> BlockEntityType.Builder
                    .of(BatteryBlockEntity::new, SFMBlocks.BATTERY_BLOCK.get())
                    .build(null)
    );


}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\blockentity\BatteryBlockEntity.java

````java
package ca.teamdman.sfm.common.blockentity;

import ca.teamdman.sfm.common.registry.SFMBlockEntities;
import net.minecraft.core.BlockPos;
import net.minecraft.core.Direction;
import net.minecraft.world.level.block.entity.BlockEntity;
import net.minecraft.world.level.block.state.BlockState;
import net.minecraftforge.common.capabilities.Capability;
import net.minecraftforge.common.capabilities.ForgeCapabilities;
import net.minecraftforge.common.util.LazyOptional;
import net.minecraftforge.energy.EnergyStorage;
import net.minecraftforge.energy.IEnergyStorage;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

public class BatteryBlockEntity extends BlockEntity {

    public final IEnergyStorage               CONTAINER  = new EnergyStorage(
            Integer.MAX_VALUE,
            Integer.MAX_VALUE,
            Integer.MAX_VALUE
    );
    public final LazyOptional<IEnergyStorage> CAPABILITY = LazyOptional.of(() -> CONTAINER);

    public BatteryBlockEntity(
            BlockPos pPos,
            BlockState pBlockState
    ) {
        super(SFMBlockEntities.BATTERY_BLOCK_ENTITY.get(), pPos, pBlockState);
    }


    @Override
    public @NotNull <T> LazyOptional<T> getCapability(@NotNull Capability<T> cap, @Nullable Direction side) {
        if (cap == ForgeCapabilities.ENERGY) {
            return CAPABILITY.cast();
        } else {
            return super.getCapability(cap, side);
        }
    }

    @Override
    public void invalidateCaps() {
        CAPABILITY.invalidate();
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\resourcetype\InfuseResourceType.java

````java
package ca.teamdman.sfm.common.resourcetype;

import mekanism.api.Action;
import mekanism.api.MekanismAPI;
import mekanism.api.chemical.infuse.IInfusionHandler;
import mekanism.api.chemical.infuse.InfuseType;
import mekanism.api.chemical.infuse.InfusionStack;
import net.minecraftforge.common.capabilities.Capability;
import net.minecraftforge.common.capabilities.CapabilityToken;
import net.minecraftforge.registries.IForgeRegistry;

import static net.minecraftforge.common.capabilities.CapabilityManager.get;

public class InfuseResourceType extends ResourceType<InfusionStack, InfuseType, IInfusionHandler> {
    public static final Capability<IInfusionHandler> CAP = get(new CapabilityToken<>() {
    });

    public InfuseResourceType() {
        super(CAP);
    }

    @Override
    public long getAmount(InfusionStack stack) {
        return stack.getAmount();
    }

    @Override
    public InfusionStack getStackInSlot(IInfusionHandler handler, int slot) {
        return handler.getChemicalInTank(slot);
    }

    @Override
    public InfusionStack extract(IInfusionHandler handler, int slot, long amount, boolean simulate) {
        return handler.extractChemical(slot, amount, simulate ? Action.SIMULATE : Action.EXECUTE);
    }

    @Override
    public int getSlots(IInfusionHandler handler) {
        return handler.getTanks();
    }

    @Override
    public long getMaxStackSize(InfusionStack stack) {
        return Long.MAX_VALUE;
    }

    @Override
    public long getMaxStackSize(IInfusionHandler handler, int slot) {
        return handler.getTankCapacity(slot);
    }

    @Override
    public InfusionStack insert(
            IInfusionHandler handler,
            int slot,
            InfusionStack stack,
            boolean simulate
    ) {
        return handler.insertChemical(slot, stack, simulate ? Action.SIMULATE : Action.EXECUTE);
    }

    @Override
    public boolean isEmpty(InfusionStack stack) {
        return stack.isEmpty();
    }

    @Override
    public InfusionStack getEmptyStack() {
        return InfusionStack.EMPTY;
    }

    @Override
    public boolean matchesStackType(Object o) {
        return o instanceof InfusionStack;
    }

    @Override
    public boolean matchesCapabilityType(Object o) {
        return o instanceof IInfusionHandler;
    }


    @Override
    public IForgeRegistry<InfuseType> getRegistry() {
        return MekanismAPI.infuseTypeRegistry();
    }

    @Override
    public InfuseType getItem(InfusionStack stack) {
        return stack.getType();
    }

    @Override
    public InfusionStack copy(InfusionStack stack) {
        return stack.copy();
    }

    @Override
    protected InfusionStack setCount(InfusionStack stack, long amount) {
        stack.setAmount(amount);
        return stack;
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\client\gui\EditorUtils.java

````java
package ca.teamdman.sfm.client.gui;

public class EditorUtils {
    private static int findLineStart(String content, int cursorPos) {
        while (cursorPos > 0 && content.charAt(cursorPos - 1) != '\n') {
            cursorPos--;
        }
        return cursorPos;
    }

    private static int findLineEnd(String content, int cursorPos) {
        while (cursorPos < content.length() && content.charAt(cursorPos) != '\n') {
            cursorPos++;
        }
        return cursorPos;
    }

    /**
     * Indents the given content, and updates the cursor and selection.
     *
     * @param content            The content to indent
     * @param cursorPos          The index within the string of the cursor
     * @param selectionCursorPos The index within the string of the selection cursor. If equal to cursorPosition, no selection is present.
     * @return The indented content, and the new cursor and selection cursor positions
     */
    public static ManipulationResult indent(String content, int cursorPos, int selectionCursorPos) {
        StringBuilder sb = new StringBuilder(content);
        int lineStart = findLineStart(content, Math.min(cursorPos, selectionCursorPos));
        int lineEnd = findLineEnd(content, Math.max(cursorPos, selectionCursorPos));
        if (lineStart == lineEnd) {
            sb.insert(lineStart, "    ");
            if (lineStart <= cursorPos) {
                cursorPos += 4;
            }
            if (lineStart <= selectionCursorPos) {
                selectionCursorPos += 4;
            }
        } else {
            while (lineStart < lineEnd) {
                sb.insert(lineStart, "    ");
                lineEnd += 4;
                if (lineStart < cursorPos) {
                    cursorPos += 4;
                }
                if (lineStart < selectionCursorPos) {
                    selectionCursorPos += 4;
                }
                lineStart = findLineEnd(sb.toString(), lineStart) + 1;
            }
        }
        return new ManipulationResult(sb.toString(), cursorPos, selectionCursorPos);
    }

    /**
     * Deindents the given content, and updates the cursor and selection.
     *
     * @param content            The content to deindent
     * @param cursorPos          The index within the string of the cursor
     * @param selectionCursorPos The index within the string of the selection cursor. If equal to cursorPosition, no selection is present.
     * @return The deindented content, and the new cursor and selection cursor positions
     */
    public static ManipulationResult deindent(String content, int cursorPos, int selectionCursorPos) {
        StringBuilder sb = new StringBuilder(content);
        int lineStart = findLineStart(content, Math.min(cursorPos, selectionCursorPos));
        int lineEnd = findLineEnd(content, Math.max(cursorPos, selectionCursorPos));

        while (lineStart < lineEnd) {
            for (int i = 0; i < 4 && lineStart < sb.length() && sb.charAt(lineStart) == ' '; i++) {
                sb.deleteCharAt(lineStart);
                lineEnd--;
                if (lineStart < cursorPos) {
                    cursorPos--;
                }
                if (lineStart < selectionCursorPos) {
                    selectionCursorPos--;
                }
            }
            lineStart = findLineEnd(sb.toString(), lineStart) + 1;
        }
        return new ManipulationResult(sb.toString(), cursorPos, selectionCursorPos);
    }

    /**
     * Perform the operation for hitting Ctrl+/
     * If the selection contains a line not starting with "--", prepend each line with "--"
     * If all lines in the selection start with "--", trim "--" from the start of each line
     *
     * @param content The content in the buffer
     * @param cursorPos The index within the content for the cursor position
     * @param selectionCursorPos The index within the content for the selection cursor. If equal to cursorPosition, no selection is present.
     * @return The modified content, and the new cursor positions accommodating the shifting of said content
     */
    public static ManipulationResult toggleComments(String content, int cursorPos, int selectionCursorPos) {
        StringBuilder sb = new StringBuilder(content);
        int lineStart = findLineStart(content, Math.min(cursorPos, selectionCursorPos));
        int lineEnd = findLineEnd(content, Math.max(cursorPos, selectionCursorPos));

        boolean allLinesCommented = true;
        while (lineStart < lineEnd) {
            if (lineStart + 2 >= sb.length() || sb.charAt(lineStart) != '-' || sb.charAt(lineStart + 1) != '-') {
                allLinesCommented = false;
                break;
            }
            lineStart = findLineEnd(sb.toString(), lineStart) + 1;
        }

        lineStart = findLineStart(content, Math.min(cursorPos, selectionCursorPos));
        lineEnd = findLineEnd(content, Math.max(cursorPos, selectionCursorPos));

        if (allLinesCommented) {
            while (lineStart < lineEnd) {
                sb.delete(lineStart, lineStart + 2);
                lineEnd -= 2;
                if (lineStart < cursorPos) {
                    cursorPos -= 2;
                }
                if (lineStart < selectionCursorPos) {
                    selectionCursorPos -= 2;
                }
                lineStart = findLineEnd(sb.toString(), lineStart) + 1;
            }
        } else {
            while (lineStart < lineEnd) {
                sb.insert(lineStart, "--");
                lineEnd += 2;
                if (lineStart <= cursorPos) {
                    cursorPos += 2;
                }
                if (lineStart <= selectionCursorPos) {
                    selectionCursorPos += 2;
                }
                lineStart = findLineEnd(sb.toString(), lineStart) + 1;
            }
        }
        return new ManipulationResult(sb.toString(), cursorPos, selectionCursorPos);
    }

    public record ManipulationResult(
            String content,
            int cursorPosition,
            int selectionCursorPosition
    ) {
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\client\jei\SFMJEIPlugin.java

````java
package ca.teamdman.sfm.client.jei;

import ca.teamdman.sfm.SFM;
import ca.teamdman.sfm.client.gui.screen.ManagerScreen;
import ca.teamdman.sfm.common.recipe.PrintingPressRecipe;
import ca.teamdman.sfm.common.registry.SFMBlocks;
import ca.teamdman.sfm.common.registry.SFMRecipeTypes;
import mezz.jei.api.IModPlugin;
import mezz.jei.api.JeiPlugin;
import mezz.jei.api.gui.handlers.IGuiContainerHandler;
import mezz.jei.api.registration.IGuiHandlerRegistration;
import mezz.jei.api.registration.IRecipeCatalystRegistration;
import mezz.jei.api.registration.IRecipeCategoryRegistration;
import mezz.jei.api.registration.IRecipeRegistration;
import net.minecraft.client.Minecraft;
import net.minecraft.client.renderer.Rect2i;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.world.item.ItemStack;
import net.minecraft.world.item.crafting.RecipeManager;
import net.minecraft.world.level.block.Blocks;

import java.util.ArrayList;
import java.util.List;

@JeiPlugin
public class SFMJEIPlugin implements IModPlugin {
    @Override
    public ResourceLocation getPluginUid() {
        return new ResourceLocation(SFM.MOD_ID, "sfm");
    }

    @Override
    public void registerCategories(IRecipeCategoryRegistration registration) {
        registration.addRecipeCategories(
                new PrintingPressJEICategory(registration.getJeiHelpers()),
                new FallingAnvilJEICategory(registration.getJeiHelpers())
        );
    }

    @Override
    public void registerRecipeCatalysts(IRecipeCatalystRegistration registration) {
        registration.addRecipeCatalyst(
                new ItemStack(SFMBlocks.PRINTING_PRESS_BLOCK.get()),
                PrintingPressJEICategory.RECIPE_TYPE
        );
        registration.addRecipeCatalyst(
                new ItemStack(Blocks.ANVIL),
                FallingAnvilJEICategory.RECIPE_TYPE
        );
    }

    @Override
    public void registerRecipes(IRecipeRegistration registration) {
        List<PrintingPressRecipe> printingPressRecipes = new ArrayList<>();
        List<FallingAnvilRecipe> fallingAnvilRecipes = new ArrayList<>();
        var level = Minecraft.getInstance().level;
        assert level != null;
        RecipeManager recipeManager = level.getRecipeManager();
        recipeManager.getAllRecipesFor(SFMRecipeTypes.PRINTING_PRESS.get()).forEach(r -> {
            printingPressRecipes.add(r);
            fallingAnvilRecipes.add(new FallingAnvilFormRecipe(r));
        });
        fallingAnvilRecipes.add(new FallingAnvilDisenchantRecipe());
        fallingAnvilRecipes.add(new FallingAnvilExperienceShardRecipe());
        registration.addRecipes(PrintingPressJEICategory.RECIPE_TYPE, printingPressRecipes);
        registration.addRecipes(FallingAnvilJEICategory.RECIPE_TYPE, fallingAnvilRecipes);
    }

    @Override
    public void registerGuiHandlers(IGuiHandlerRegistration registration) {
        registration.addGuiContainerHandler(ManagerScreen.class, new IGuiContainerHandler<>() {
            @Override
            public List<Rect2i> getGuiExtraAreas(ManagerScreen screen) {
                var buttons = screen.getButtonsForJEIExclusionZones();
                return buttons
                        .stream()
                        .filter(b -> b.visible)
                        .map(b -> new Rect2i(b.x, b.y, b.getWidth(), b.getHeight()))
                        .toList();
            }
        });
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\blockentity\package-info.java

````java

@ParametersAreNonnullByDefault
@MethodsReturnNonnullByDefault
@FieldsAreNonnullByDefault
package ca.teamdman.sfm.common.blockentity;

import net.minecraft.FieldsAreNonnullByDefault;
import net.minecraft.MethodsReturnNonnullByDefault;

import javax.annotation.ParametersAreNonnullByDefault;
````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\client\render\PrintingPressBlockEntityRenderer.java

````java
package ca.teamdman.sfm.client.render;

import ca.teamdman.sfm.common.blockentity.PrintingPressBlockEntity;
import com.mojang.blaze3d.vertex.PoseStack;
import com.mojang.math.Vector3f;
import net.minecraft.client.Minecraft;
import net.minecraft.client.renderer.MultiBufferSource;
import net.minecraft.client.renderer.block.model.ItemTransforms;
import net.minecraft.client.renderer.blockentity.BlockEntityRenderer;
import net.minecraft.client.renderer.blockentity.BlockEntityRendererProvider;
import net.minecraft.world.item.ItemStack;

public class PrintingPressBlockEntityRenderer implements BlockEntityRenderer<PrintingPressBlockEntity> {
    public PrintingPressBlockEntityRenderer(BlockEntityRendererProvider.Context pContext) {

    }

    @Override
    public void render(
            PrintingPressBlockEntity blockEntity,
            float partialTick,
            PoseStack poseStack,
            MultiBufferSource buf,
            int packedLight,
            int packedOverlay
    ) {
        var paper = blockEntity.getPaper();
        var dye = blockEntity.getInk();
        var form = blockEntity.getForm();
        var depthAxis = new Vector3f(1, 0, 0);
        poseStack.pushPose();
        poseStack.translate(0.5, 1, 0.6);
        poseStack.mulPose(depthAxis.rotationDegrees(-90));

        for (var stack : new ItemStack[]{form, paper, dye}) {
            if (!stack.isEmpty()) {
                Minecraft
                        .getInstance()
                        .getItemRenderer()
                        .renderStatic(
                                stack,
                                ItemTransforms.TransformType.GROUND,
                                packedLight,
                                packedOverlay,
                                poseStack,
                                buf,
                                (int) blockEntity.getBlockPos().asLong()
                        );
                poseStack.translate(0.01, 0.01, 0.03);
            }
        }
        poseStack.popPose();

    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\net\package-info.java

````java


@ParametersAreNonnullByDefault
@MethodsReturnNonnullByDefault
@FieldsAreNonnullByDefault
package ca.teamdman.sfm.common.net;

import net.minecraft.FieldsAreNonnullByDefault;
import net.minecraft.MethodsReturnNonnullByDefault;

import javax.annotation.ParametersAreNonnullByDefault;
````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\block\PrintingPressBlock.java

````java
package ca.teamdman.sfm.common.block;

import ca.teamdman.sfm.common.blockentity.PrintingPressBlockEntity;
import ca.teamdman.sfm.common.registry.SFMBlockEntities;
import net.minecraft.core.BlockPos;
import net.minecraft.world.Containers;
import net.minecraft.world.InteractionHand;
import net.minecraft.world.InteractionResult;
import net.minecraft.world.entity.player.Player;
import net.minecraft.world.item.ItemStack;
import net.minecraft.world.level.Level;
import net.minecraft.world.level.block.*;
import net.minecraft.world.level.block.entity.BlockEntity;
import net.minecraft.world.level.block.state.BlockBehaviour;
import net.minecraft.world.level.block.state.BlockState;
import net.minecraft.world.level.material.Material;
import net.minecraft.world.phys.BlockHitResult;

public class PrintingPressBlock extends BaseEntityBlock implements EntityBlock {

    public PrintingPressBlock() {
        super(BlockBehaviour.Properties.of(Material.METAL).strength(5.0F, 6.0F).noOcclusion());
        this.registerDefaultState(this.defaultBlockState());
    }

    @Override
    public BlockEntity newBlockEntity(BlockPos pos, BlockState state) {
        return SFMBlockEntities.PRINTING_PRESS_BLOCK_ENTITY
                .get()
                .create(pos, state);
    }

    @SuppressWarnings("deprecation")
    public RenderShape getRenderShape(BlockState state) {
        return RenderShape.MODEL;
    }

    @Override
    @SuppressWarnings("deprecation")
    public void neighborChanged(
            BlockState pState,
            Level pLevel,
            BlockPos pPos,
            Block pBlock,
            BlockPos pFromPos,
            boolean pIsMoving
    ) {
        super.neighborChanged(pState, pLevel, pPos, pBlock, pFromPos, pIsMoving);
        if (!pLevel.isClientSide
            && pFromPos.getY() == pPos.getY() + 1
            && pLevel.getBlockState(pFromPos).getBlock() == Blocks.PISTON_HEAD
            && pLevel.getBlockEntity(pPos) instanceof PrintingPressBlockEntity blockEntity) {
            blockEntity.performPrint();
        }
    }

    @Override
    @SuppressWarnings("deprecation")
    public InteractionResult use(
            BlockState state,
            Level level,
            BlockPos pos,
            Player player,
            InteractionHand hand,
            BlockHitResult hit
    ) {
        if (!level.isClientSide() && level.getBlockEntity(pos) instanceof PrintingPressBlockEntity blockEntity) {
            var stack = player.getItemInHand(hand);
            player.setItemInHand(hand, blockEntity.acceptStack(stack));
        }
        return InteractionResult.SUCCESS;
    }

    @SuppressWarnings("deprecation")
    public void onRemove(BlockState pState, Level pLevel, BlockPos pPos, BlockState pNewState, boolean pIsMoving) {
        if (!pState.is(pNewState.getBlock())) {
            BlockEntity blockentity = pLevel.getBlockEntity(pPos);
            if (blockentity instanceof PrintingPressBlockEntity blockEntity) {
                for (ItemStack itemStack : blockEntity.getStacksToDrop()) {
                    Containers.dropItemStack(pLevel, pPos.getX(), pPos.getY(), pPos.getZ(), itemStack);
                }
                pLevel.updateNeighbourForOutputSignal(pPos, this);
            }

            super.onRemove(pState, pLevel, pPos, pNewState, pIsMoving);
        }
    }


}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\client\jei\FallingAnvilExperienceShardRecipe.java

````java
package ca.teamdman.sfm.client.jei;

public class FallingAnvilExperienceShardRecipe extends FallingAnvilRecipe {

}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\net\ClientboundContainerExportsInspectionResultsPacket.java

````java
package ca.teamdman.sfm.common.net;

import ca.teamdman.sfm.client.ClientStuff;
import net.minecraft.client.Minecraft;
import net.minecraft.client.player.LocalPlayer;
import net.minecraft.network.FriendlyByteBuf;
import net.minecraftforge.network.NetworkEvent;

import java.util.function.Supplier;

public record ClientboundContainerExportsInspectionResultsPacket(
        int windowId,
        String results
) {
    public static final int MAX_RESULTS_LENGTH = 20480;

    public static void encode(
            ClientboundContainerExportsInspectionResultsPacket msg, FriendlyByteBuf friendlyByteBuf
    ) {
        friendlyByteBuf.writeVarInt(msg.windowId());
        friendlyByteBuf.writeUtf(msg.results(), MAX_RESULTS_LENGTH);
    }

    public static ClientboundContainerExportsInspectionResultsPacket decode(FriendlyByteBuf friendlyByteBuf) {
        return new ClientboundContainerExportsInspectionResultsPacket(
                friendlyByteBuf.readVarInt(),
                friendlyByteBuf.readUtf(MAX_RESULTS_LENGTH)
        );
    }

    public static void handle(
            ClientboundContainerExportsInspectionResultsPacket msg, Supplier<NetworkEvent.Context> contextSupplier
    ) {
        contextSupplier.get().enqueueWork(() -> {
            LocalPlayer player = Minecraft.getInstance().player;
            if (player == null) return;
            var container = player.containerMenu;
            if (container.containerId != msg.windowId) return;
            ClientStuff.showProgramEditScreen(msg.results, next -> {
            });
        });
        contextSupplier.get().setPacketHandled(true);
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfml\ast\NumberRange.java

````java
package ca.teamdman.sfml.ast;

public record NumberRange(
        long start,
        long end
) implements ASTNode {
    public static final NumberRange MAX_RANGE = new NumberRange(Long.MIN_VALUE, Long.MAX_VALUE);

    /**
     * Inclusive
     */
    public boolean contains(int value) {
        return value >= start && value <= end;
    }

    @Override
    public String toString() {
        if (start == end) return String.valueOf(start);
        return start + "-" + end;
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfml\ast\SetOperator.java

````java
package ca.teamdman.sfml.ast;

import java.util.List;
import java.util.Locale;
import java.util.function.BiPredicate;

public enum SetOperator implements ASTNode, BiPredicate<Boolean, List<Boolean>> {
    OVERALL((overall, __) -> overall),
    SOME((__, set) -> set.stream().anyMatch(Boolean::booleanValue)),
    EVERY((__, set) -> set.stream().allMatch(Boolean::booleanValue)),
    ONE((__, set) -> set.stream().filter(Boolean::booleanValue).count() == 1),
    LONE((__, set) -> set.stream().filter(Boolean::booleanValue).count() <= 1);

    private final BiPredicate<Boolean, List<Boolean>> PRED;

    SetOperator(BiPredicate<Boolean, List<Boolean>> pred) {
        this.PRED = pred;
    }

    public static SetOperator from(String text) {
        text = text.toUpperCase(Locale.ROOT);
        if (text.equals("EACH")) {
            text = "EVERY";
        }
        return SetOperator.valueOf(text);
    }

    @Override
    public boolean test(Boolean overall, List<Boolean> counts) {
        return PRED.test(overall, counts);
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\program\LimitedOutputSlot.java

````java
package ca.teamdman.sfm.common.program;

import ca.teamdman.sfm.common.resourcetype.ResourceType;

import javax.annotation.Nullable;

public class LimitedOutputSlot<STACK, ITEM, CAP> {
    @SuppressWarnings("NotNullFieldNotInitialized") // done in init method in constructor
    public ResourceType<STACK, ITEM, CAP> type;
    @SuppressWarnings("NotNullFieldNotInitialized") // done in init method in constructor
    public CAP capability;
    public int slot;
    @SuppressWarnings("NotNullFieldNotInitialized") // done in init method in constructor
    public OutputResourceTracker<STACK, ITEM, CAP> tracker;
    private @Nullable STACK stackInSlotCache = null;

    public LimitedOutputSlot(
            CAP capability, int slot, OutputResourceTracker<STACK, ITEM, CAP> tracker
    ) {
        this.init(capability, slot, tracker);
    }

    public boolean isDone() {
        if (tracker.isDone()) {
            return true;
        }
        STACK stack = getStackInSlot();
        long count = type.getAmount(stack);
        if (count >= type.getMaxStackSize(capability, slot)) {
            // if the maxStackSize is different, that will be handled by moveTo
            // for the general case, it will be faster to just assume 64 is the max stack size
            return true;
        }
        return count != 0 && !tracker.test(stack);
    }

    public STACK getStackInSlot() {
        if (stackInSlotCache == null) {
            stackInSlotCache = type.getStackInSlot(capability, slot);
        }
        return stackInSlotCache;
    }

    public STACK insert(STACK stack, boolean simulate) {
        if (!simulate) stackInSlotCache = null;
        return type.insert(capability, slot, stack, simulate);
    }

    public void init(CAP handler, int slot, OutputResourceTracker<STACK, ITEM, CAP> tracker) {
        this.stackInSlotCache = null;
        this.capability = handler;
        this.tracker = tracker;
        this.slot = slot;
        //noinspection DataFlowIssue
        this.type = tracker.getLimit().resourceId().getResourceType();
        assert type != null;
        this.tracker.visit(this);
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\recipe\DiskResetRecipe.java

````java
package ca.teamdman.sfm.common.recipe;

import ca.teamdman.sfm.common.item.DiskItem;
import ca.teamdman.sfm.common.registry.SFMItems;
import ca.teamdman.sfm.common.registry.SFMRecipeSerializers;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.world.inventory.CraftingContainer;
import net.minecraft.world.item.ItemStack;
import net.minecraft.world.item.crafting.CustomRecipe;
import net.minecraft.world.item.crafting.RecipeSerializer;
import net.minecraft.world.level.Level;

/**
 * Printing press copies a form using ink and paper.
 */
public class DiskResetRecipe extends CustomRecipe {
    public DiskResetRecipe(ResourceLocation pId) {
        super(pId);
    }

    @Override
    public boolean matches(CraftingContainer pContainer, Level pLevel) {
        int foundDisks = 0;
        for (int i = 0; i < pContainer.getContainerSize(); i++) {
            ItemStack stack = pContainer.getItem(i);
            if (stack.getItem() instanceof DiskItem) {
                foundDisks++;
            } else if (!stack.isEmpty()) {
                return false;
            }
        }
        return foundDisks > 0;
    }

    @Override
    public ItemStack assemble(CraftingContainer pContainer) {
        int foundDisks = 0;
        for (int i = 0; i < pContainer.getContainerSize(); i++) {
            ItemStack stack = pContainer.getItem(i);
            if (stack.getItem() instanceof DiskItem) {
                foundDisks++;
            } else if (!stack.isEmpty()) {
                return ItemStack.EMPTY;
            }
        }
        return foundDisks > 0 ? new ItemStack(SFMItems.DISK_ITEM.get(), foundDisks) : ItemStack.EMPTY;
    }

    @Override
    public boolean canCraftInDimensions(int pWidth, int pHeight) {
        return true;
    }

    @Override
    public RecipeSerializer<?> getSerializer() {
        return SFMRecipeSerializers.DISK_RESET.get();
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\client\jei\FallingAnvilDisenchantRecipe.java

````java
package ca.teamdman.sfm.client.jei;

public class FallingAnvilDisenchantRecipe extends FallingAnvilRecipe {

}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\net\ClientboundOutputInspectionResultsPacket.java

````java
package ca.teamdman.sfm.common.net;

import ca.teamdman.sfm.client.ClientStuff;
import net.minecraft.network.FriendlyByteBuf;
import net.minecraftforge.network.NetworkEvent;

import java.util.function.Supplier;

public record ClientboundOutputInspectionResultsPacket(
        String results
) {
    public static final int MAX_RESULTS_LENGTH = 10240;

    public static void encode(
            ClientboundOutputInspectionResultsPacket msg, FriendlyByteBuf friendlyByteBuf
    ) {
        friendlyByteBuf.writeUtf(msg.results(), MAX_RESULTS_LENGTH);
    }

    public static ClientboundOutputInspectionResultsPacket decode(FriendlyByteBuf friendlyByteBuf) {
        return new ClientboundOutputInspectionResultsPacket(
                friendlyByteBuf.readUtf(MAX_RESULTS_LENGTH)
        );
    }

    public static void handle(
            ClientboundOutputInspectionResultsPacket msg, Supplier<NetworkEvent.Context> contextSupplier
    ) {
        contextSupplier.get().enqueueWork(() -> ClientStuff.showProgramEditScreen(msg.results, next -> {
        }));
        contextSupplier.get().setPacketHandled(true);
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\client\handler\LabelGunScrollSwitcher.java

````java
package ca.teamdman.sfm.client.handler;

import ca.teamdman.sfm.SFM;
import ca.teamdman.sfm.common.item.LabelGunItem;
import ca.teamdman.sfm.common.net.ServerboundLabelGunUpdatePacket;
import ca.teamdman.sfm.common.registry.SFMPackets;
import net.minecraft.client.Minecraft;
import net.minecraft.world.InteractionHand;
import net.minecraftforge.api.distmarker.Dist;
import net.minecraftforge.client.event.InputEvent;
import net.minecraftforge.eventbus.api.SubscribeEvent;
import net.minecraftforge.fml.common.Mod;

@Mod.EventBusSubscriber(modid = SFM.MOD_ID, bus = Mod.EventBusSubscriber.Bus.FORGE, value = Dist.CLIENT)
public class LabelGunScrollSwitcher {
    @SubscribeEvent
    public static void onScroll(InputEvent.MouseScrollingEvent event) {
        var player = Minecraft.getInstance().player;
        if (player == null) return;
        if (!player.isShiftKeyDown()) return;
        var gun  = player.getMainHandItem();
        var hand = InteractionHand.MAIN_HAND;
        if (!(gun.getItem() instanceof LabelGunItem)) {
            gun  = player.getOffhandItem();
            hand = InteractionHand.OFF_HAND;
        }
        if (!(gun.getItem() instanceof LabelGunItem)) return;

        var next = LabelGunItem.getNextLabel(gun, event.getScrollDelta() < 0 ? -1 : 1);
        SFMPackets.LABEL_GUN_ITEM_CHANNEL.sendToServer(new ServerboundLabelGunUpdatePacket(
                next,
                hand
        ));

        event.setCanceled(true);
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\recipe\PrintingPressFinishedRecipe.java

````java
package ca.teamdman.sfm.common.recipe;

import ca.teamdman.sfm.common.registry.SFMRecipeSerializers;
import com.google.gson.JsonObject;
import net.minecraft.data.recipes.FinishedRecipe;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.world.item.crafting.Ingredient;
import net.minecraft.world.item.crafting.RecipeSerializer;

public class PrintingPressFinishedRecipe implements FinishedRecipe {
    private final ResourceLocation id;
    private final Ingredient form;
    private final Ingredient ink;
    private final Ingredient paper;

    public PrintingPressFinishedRecipe(
            ResourceLocation id,
            Ingredient form,
            Ingredient ink,
            Ingredient paper
    ) {
        this.id = id;
        this.form = form;
        this.ink = ink;
        this.paper = paper;
    }

    @Override
    public void serializeRecipeData(JsonObject json) {
        json.add("form", form.toJson());
        json.add("ink", ink.toJson());
        json.add("paper", paper.toJson());
    }

    @Override
    public ResourceLocation getId() {
        return id;
    }

    @Override
    public RecipeSerializer<?> getType() {
        return SFMRecipeSerializers.PRINTING_PRESS.get();
    }

    @Override
    public JsonObject serializeAdvancement() {
        return null; // No advancements needed for this recipe
    }

    @Override
    public ResourceLocation getAdvancementId() {
        return new ResourceLocation("");
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\net\ServerboundInputInspectionRequestPacket.java

````java
package ca.teamdman.sfm.common.net;

import ca.teamdman.sfm.common.blockentity.ManagerBlockEntity;
import ca.teamdman.sfm.common.containermenu.ManagerContainerMenu;
import ca.teamdman.sfm.common.program.ProgramContext;
import ca.teamdman.sfm.common.registry.SFMPackets;
import ca.teamdman.sfm.common.util.SFMUtils;
import ca.teamdman.sfml.ast.InputStatement;
import ca.teamdman.sfml.ast.Program;
import net.minecraft.network.FriendlyByteBuf;
import net.minecraft.server.level.ServerPlayer;
import net.minecraftforge.network.NetworkEvent;
import net.minecraftforge.network.PacketDistributor;

import java.util.function.Supplier;

public record ServerboundInputInspectionRequestPacket(
        String programString,
        int inputNodeIndex
) {
    public static void encode(ServerboundInputInspectionRequestPacket msg, FriendlyByteBuf friendlyByteBuf) {
        friendlyByteBuf.writeUtf(msg.programString, Program.MAX_PROGRAM_LENGTH);
        friendlyByteBuf.writeInt(msg.inputNodeIndex());
    }

    public static ServerboundInputInspectionRequestPacket decode(FriendlyByteBuf friendlyByteBuf) {
        return new ServerboundInputInspectionRequestPacket(
                friendlyByteBuf.readUtf(Program.MAX_PROGRAM_LENGTH),
                friendlyByteBuf.readInt()
        );
    }

    public static void handle(
            ServerboundInputInspectionRequestPacket msg, Supplier<NetworkEvent.Context> contextSupplier
    ) {
        contextSupplier.get().enqueueWork(() -> {
            // we don't know if the player has the program edit screen open from a manager or a disk in hand
            ServerPlayer player = contextSupplier.get().getSender();
            if (player == null) return;
            ManagerBlockEntity manager;
            if (player.containerMenu instanceof ManagerContainerMenu mcm) {
                if (player.getLevel().getBlockEntity(mcm.MANAGER_POSITION) instanceof ManagerBlockEntity mbe) {
                    manager = mbe;
                } else {
                    return;
                }
            } else {
                //todo: localize
                SFMPackets.INSPECTION_CHANNEL.send(
                        PacketDistributor.PLAYER.with(() -> player),
                        new ClientboundInputInspectionResultsPacket(
                                "This inspection is only available when editing inside a manager.")
                );
                return;
            }
            Program.compile(
                    msg.programString,
                    (successProgram, builder) -> builder
                            .getNodeAtIndex(msg.inputNodeIndex)
                            .filter(InputStatement.class::isInstance)
                            .map(InputStatement.class::cast)
                            .ifPresent(inputStatement -> {
                                StringBuilder payload = new StringBuilder();
                                payload
                                        .append(inputStatement.toStringPretty())
                                        .append("\n-- peek results --\n");

                                ProgramContext context = new ProgramContext(
                                        successProgram,
                                        manager,
                                        ProgramContext.ExecutionPolicy.EXPLORE_BRANCHES
                                );
                                int preLen = payload.length();
                                inputStatement.gatherSlots(
                                        context,
                                        slot -> SFMUtils
                                                .getInputStatementForSlot(
                                                        slot,
                                                        inputStatement.labelAccess()
                                                )
                                                .ifPresent(is -> payload
                                                        .append(is.toStringPretty())
                                                        .append("\n"))
                                );
                                if (payload.length() == preLen) {
                                    payload.append("none");
                                }

                                SFMPackets.INSPECTION_CHANNEL.send(
                                        PacketDistributor.PLAYER.with(() -> player),
                                        new ClientboundInputInspectionResultsPacket(
                                                SFMUtils.truncate(
                                                        payload.toString(),
                                                        ClientboundInputInspectionResultsPacket.MAX_RESULTS_LENGTH
                                                ))
                                );
                            }),
                    failure -> {
                    }
            );
        });
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfml\ast\LabelAccess.java

````java
package ca.teamdman.sfml.ast;

import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;

public record LabelAccess(
        List<Label> labels,
        DirectionQualifier directions,
        NumberRangeSet slots,
        RoundRobin roundRobin
) implements ASTNode {
    @Override
    public String toString() {
        StringBuilder builder = new StringBuilder();
        builder.append(labels.stream().map(Objects::toString).collect(Collectors.joining(", ")));
        if (roundRobin.isEnabled()) {
            builder.append(" ").append(roundRobin);
        }
        if (!directions.directions().isEmpty()) {
            builder.append(" ");
            builder
                    .append(directions
                                    .stream()
                                    .map(DirectionQualifier::directionToString)
                                    .collect(Collectors.joining(", ")))
                    .append(" SIDE");
        }
        if (slots.ranges().length > 0) {
            if (slots.ranges().length != 1 || !slots.ranges()[0].equals(NumberRange.MAX_RANGE)) {
                builder.append(" SLOTS");
                for (NumberRange range : slots.ranges()) {
                    builder.append(" ").append(range);
                }
            }
        }
        return builder.toString();
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\program\package-info.java

````java


@ParametersAreNonnullByDefault
@MethodsReturnNonnullByDefault
@FieldsAreNonnullByDefault
package ca.teamdman.sfm.common.program;

import net.minecraft.FieldsAreNonnullByDefault;
import net.minecraft.MethodsReturnNonnullByDefault;

import javax.annotation.ParametersAreNonnullByDefault;
````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\registry\SFMRecipeTypes.java

````java
package ca.teamdman.sfm.common.registry;

import ca.teamdman.sfm.SFM;
import ca.teamdman.sfm.common.recipe.PrintingPressRecipe;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.world.item.crafting.RecipeType;
import net.minecraftforge.eventbus.api.IEventBus;
import net.minecraftforge.registries.DeferredRegister;
import net.minecraftforge.registries.ForgeRegistries;
import net.minecraftforge.registries.RegistryObject;

public class SFMRecipeTypes {
    private static final DeferredRegister<RecipeType<?>> RECIPE_TYPES = DeferredRegister.create(
            ForgeRegistries.RECIPE_TYPES,
            SFM.MOD_ID
    );

    public static final RegistryObject<RecipeType<PrintingPressRecipe>> PRINTING_PRESS = RECIPE_TYPES.register(
            "printing_press",
            () -> RecipeType.simple(new ResourceLocation(SFM.MOD_ID, "printing_press"))
    );

    public static void register(IEventBus bus) {
        RECIPE_TYPES.register(bus);
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\item\ExperienceGoop.java

````java
package ca.teamdman.sfm.common.item;

import ca.teamdman.sfm.common.registry.SFMItems;
import net.minecraft.world.item.Item;

public class ExperienceGoop extends Item {
    public ExperienceGoop() {
        super(new Properties().tab(SFMItems.TAB));
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\client\gui\screen\LabelGunScreen.java

````java
package ca.teamdman.sfm.client.gui.screen;

import ca.teamdman.sfm.common.Constants;
import ca.teamdman.sfm.common.net.ServerboundLabelGunClearPacket;
import ca.teamdman.sfm.common.net.ServerboundLabelGunPrunePacket;
import ca.teamdman.sfm.common.net.ServerboundLabelGunUpdatePacket;
import ca.teamdman.sfm.common.program.LabelPositionHolder;
import ca.teamdman.sfm.common.registry.SFMPackets;
import com.mojang.blaze3d.vertex.PoseStack;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.components.Button;
import net.minecraft.client.gui.components.EditBox;
import net.minecraft.client.gui.screens.Screen;
import net.minecraft.network.chat.CommonComponents;
import net.minecraft.world.InteractionHand;
import net.minecraft.world.item.ItemStack;
import org.lwjgl.glfw.GLFW;

import java.util.Comparator;

public class LabelGunScreen extends Screen {
    private final InteractionHand HAND;
    private final LabelPositionHolder LABEL_HOLDER;
    @SuppressWarnings("NotNullFieldNotInitialized")
    private EditBox labelField;
    private boolean shouldRebuildWidgets = false;

    public LabelGunScreen(ItemStack labelGunStack, InteractionHand hand) {
        super(Constants.LocalizationKeys.LABEL_GUN_GUI_TITLE.getComponent());
        LABEL_HOLDER = LabelPositionHolder.from(labelGunStack);
        HAND = hand;
    }

    @Override
    protected void init() {
        super.init();
        assert this.minecraft != null;
        this.minecraft.keyboardHandler.setSendRepeatsToGui(true);
        this.labelField = addRenderableWidget(new EditBox(
                this.font,
                this.width / 2 - 150,
                50,
                300,
                20,
                Constants.LocalizationKeys.LABEL_GUN_GUI_LABEL_PLACEHOLDER.getComponent()
        ));
        this.setInitialFocus(labelField);
        this.setFocused(labelField);
        this.labelField.setFocus(true);

        this.addRenderableWidget(new Button(
                this.width / 2 - 210,
                50,
                50,
                20,
                Constants.LocalizationKeys.LABEL_GUN_GUI_CLEAR_BUTTON.getComponent(),
                (btn) -> {
                    SFMPackets.LABEL_GUN_ITEM_CHANNEL.sendToServer(new ServerboundLabelGunClearPacket(HAND));
                    LABEL_HOLDER.clear();
                    shouldRebuildWidgets = true;
                }
        ));
        this.addRenderableWidget(new Button(
                this.width / 2 + 160,
                50,
                50,
                20,
                Constants.LocalizationKeys.LABEL_GUN_GUI_PRUNE_BUTTON.getComponent(),
                (btn) -> {
                    SFMPackets.LABEL_GUN_ITEM_CHANNEL.sendToServer(new ServerboundLabelGunPrunePacket(HAND));
                    LABEL_HOLDER.prune();
                    shouldRebuildWidgets = true;
                }
        ));
        this.addRenderableWidget(new Button(
                this.width / 2 - 2 - 150,
                this.height - 50,
                300,
                20,
                CommonComponents.GUI_DONE,
                (p_97691_) -> this.onDone()
        ));
        {
            var labels = LABEL_HOLDER.get().keySet().stream().sorted(Comparator.naturalOrder()).toList();
            int i = 0;
            int buttonWidth = LABEL_HOLDER.get()
                                      .entrySet()
                                      .stream()
                                      .map(entry -> Constants.LocalizationKeys.LABEL_GUN_GUI_LABEL_BUTTON.getComponent(
                                              entry.getKey(),
                                              entry.getValue().size()
                                      ).getString())
                                      .mapToInt(this.font::width)
                                      .max().orElse(50) + 10;
            int buttonHeight = 20;
            int paddingX = 5;
            int paddingY = 5;
            int buttonsPerRow = this.width / (buttonWidth + paddingX);
            for (var label : labels) {
                int x = (this.width - (buttonWidth + paddingX) * Math.min(buttonsPerRow, labels.size())) / 2
                        + paddingX
                        + (i % buttonsPerRow) * (
                        buttonWidth
                        + paddingX
                );
                int y = 80 + (i / buttonsPerRow) * (buttonHeight + paddingY);
                int count = LABEL_HOLDER.getPositions(label).size();
                this.addRenderableWidget(new Button(
                        x,
                        y,
                        buttonWidth,
                        buttonHeight,
                        Constants.LocalizationKeys.LABEL_GUN_GUI_LABEL_BUTTON.getComponent(label, count),
                        (btn) -> {
                            this.labelField.setValue(label);
                            this.onDone();
                        }
                ));
                i++;
            }
        }
    }

    @Override
    public boolean keyPressed(int key, int mod1, int mod2) {
        if (super.keyPressed(key, mod1, mod2)) return true;
        if (key != GLFW.GLFW_KEY_ENTER && key != GLFW.GLFW_KEY_KP_ENTER) return false;
        onDone();
        return true;
    }

    public void onDone() {
        SFMPackets.LABEL_GUN_ITEM_CHANNEL.sendToServer(new ServerboundLabelGunUpdatePacket(
                labelField.getValue(),
                HAND
        ));
        onClose();
    }

    @Override
    public void resize(Minecraft mc, int x, int y) {
        var prev = this.labelField.getValue();
        init(mc, x, y);
        super.resize(mc, x, y);
        this.labelField.setValue(prev);
    }

    @Override
    public void render(PoseStack poseStack, int mx, int my, float partialTicks) {
        if (shouldRebuildWidgets) {
            // we delay this because focus gets reset _after_ the button event handler
            // we want to end with the label input field focused
            shouldRebuildWidgets = false;
            rebuildWidgets();
        }
        this.renderBackground(poseStack);
        super.render(poseStack, mx, my, partialTicks);
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\containermenu\package-info.java

````java


@ParametersAreNonnullByDefault
@MethodsReturnNonnullByDefault
@FieldsAreNonnullByDefault
package ca.teamdman.sfm.common.containermenu;

import net.minecraft.FieldsAreNonnullByDefault;
import net.minecraft.MethodsReturnNonnullByDefault;

import javax.annotation.ParametersAreNonnullByDefault;
````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\blockentity\WaterTankBlockEntity.java

````java
package ca.teamdman.sfm.common.blockentity;

import ca.teamdman.sfm.common.block.WaterTankBlock;
import ca.teamdman.sfm.common.registry.SFMBlockEntities;
import net.minecraft.core.BlockPos;
import net.minecraft.core.Direction;
import net.minecraft.world.level.block.entity.BlockEntity;
import net.minecraft.world.level.block.state.BlockState;
import net.minecraft.world.level.material.Fluids;
import net.minecraftforge.common.capabilities.Capability;
import net.minecraftforge.common.capabilities.ForgeCapabilities;
import net.minecraftforge.common.util.LazyOptional;
import net.minecraftforge.fluids.FluidStack;
import net.minecraftforge.fluids.capability.IFluidHandler;
import net.minecraftforge.fluids.capability.templates.FluidTank;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

public class WaterTankBlockEntity extends BlockEntity {
    public void setConnectedCount(int connectedCount) {
        TANK.setCapacity(connectedCount * 1000);
        TANK.getFluid().setAmount(TANK.getCapacity());
    }

    @Override
    public void onLoad() {
        super.onLoad();
        ((WaterTankBlock) getBlockState().getBlock()).recount(getLevel(), getBlockPos());
    }

    // can't fill, only extract
    public final FluidTank TANK = new FluidTank(1000, fluidStack -> false) {
        {
            setFluid(new FluidStack(Fluids.WATER, 1000));
        }

        @Override
        public @NotNull FluidStack drain(int maxDrain, FluidAction action) {
            if (!getLevel().getBlockState(getBlockPos()).getValue(WaterTankBlock.IN_WATER)) return FluidStack.EMPTY;
            int        drained = Math.min(maxDrain, TANK.getCapacity());
            FluidStack copy    = fluid.copy();
            copy.setAmount(drained);
            return copy;
        }
    };

    public final LazyOptional<IFluidHandler> TANK_CAPABILITY = LazyOptional.of(() -> TANK);

    public WaterTankBlockEntity(
            BlockPos pos,
            BlockState state
    ) {
        super(SFMBlockEntities.WATER_TANK_BLOCK_ENTITY.get(), pos, state);
    }

    @Override
    public @NotNull <T> LazyOptional<T> getCapability(@NotNull Capability<T> cap, @Nullable Direction side) {
        if (cap == ForgeCapabilities.FLUID_HANDLER) {
            return TANK_CAPABILITY.cast();
        } else {
            return super.getCapability(cap, side);
        }
    }

    @Override
    public void invalidateCaps() {
        TANK_CAPABILITY.invalidate();
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfml\ast\Interval.java

````java
package ca.teamdman.sfml.ast;

public record Interval(int ticks) implements ASTNode {
    public static Interval fromTicks(int ticks) {
        return new Interval(ticks);
    }

    public static Interval fromSeconds(int seconds) {
        return new Interval(seconds * 20);
    }

    @Override
    public String toString() {
        return ticks + " TICKS";
    }

    public int getTicks() {
        return ticks;
    }

    public int getSeconds() {
        return ticks / 20;
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfml\ast\RedstoneTrigger.java

````java
package ca.teamdman.sfml.ast;

import ca.teamdman.sfm.common.program.ProgramContext;

public record RedstoneTrigger(
        Block block
) implements Trigger {
    @Override
    public Block getBlock() {
        return block;
    }

    @Override
    public void tick(ProgramContext context) {
        for (int i = 0; i < context.getRedstonePulses(); i++) {
            block.tick(context);
        }
    }

    @Override
    public boolean shouldTick(ProgramContext context) {
        if (context.getExecutionPolicy() == ProgramContext.ExecutionPolicy.EXPLORE_BRANCHES) return true;
        return context.getManager().getUnprocessedRedstonePulseCount() > 0;
    }
}

````



## D:\repos\Minecraft\Forge\SuperFactoryManager\src\main\java\ca\teamdman\sfm\common\item\package-info.java

````java


@ParametersAreNonnullByDefault
@MethodsReturnNonnullByDefault
@FieldsAreNonnullByDefault
package ca.teamdman.sfm.common.item;

import net.minecraft.FieldsAreNonnullByDefault;
import net.minecraft.MethodsReturnNonnullByDefault;

import javax.annotation.ParametersAreNonnullByDefault;
````



That is part of the source code for SuperFactoryManager.

The mod has been experiencing a problem related to the manager no longer moving items, triggered by chunk loading.

A reproduction of the problem is accomplished by setting up a manager with a program at 10000,4,10000
in a superflat world, teleporting away, and coming back.

I have isolated the problem to ResourceType.java


    public Stream<CAP> getCapabilities(
            ProgramContext programContext, LabelAccess labelAccess
    ) {
        Optional<ItemStack> disk = programContext.getManager().getDisk();
        if (disk.isEmpty()) return Stream.empty();
        LabelPositionHolder labelPositions = LabelPositionHolder.from(disk.get());
        CableNetwork network = programContext.getNetwork();
        return labelAccess.roundRobin().gather(labelAccess, labelPositions)
                .map(network::getCapabilityProvider)
                .filter(Optional::isPresent)
                .map(Optional::get)
                .flatMap((
                                 prov -> labelAccess
                                         .directions()
                                         .stream()
                                         .map(direction -> prov.getCapability(CAPABILITY, direction))
                         ))
                .map(x -> {
                    //noinspection DataFlowIssue
                    return x.orElse(null);
                })
                .filter(x -> {
                    //noinspection ConstantValue,Convert2MethodRef
                    return x != null;
                });
    }

This uses the network::getCapabilityProvider method, which has cached the capability provider.

Here is the code for CapabilityProvider.class

//
// Source code recreated from a .class file by IntelliJ IDEA
// (powered by FernFlower decompiler)
//

package net.minecraftforge.common.capabilities;

import com.google.common.annotations.VisibleForTesting;
import java.util.function.Supplier;
import javax.annotation.ParametersAreNonnullByDefault;
import net.minecraft.MethodsReturnNonnullByDefault;
import net.minecraft.core.Direction;
import net.minecraft.nbt.CompoundTag;
import net.minecraftforge.common.util.LazyOptional;
import net.minecraftforge.event.ForgeEventFactory;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

@MethodsReturnNonnullByDefault
@ParametersAreNonnullByDefault
public abstract class CapabilityProvider<B extends ICapabilityProviderImpl<B>> implements ICapabilityProviderImpl<B> {
    @VisibleForTesting
    static boolean SUPPORTS_LAZY_CAPABILITIES = true;
    private final @NotNull Class<B> baseClass;
    private @Nullable CapabilityDispatcher capabilities;
    private boolean valid;
    private boolean isLazy;
    private Supplier<ICapabilityProvider> lazyParentSupplier;
    private CompoundTag lazyData;
    private boolean initialized;

    protected CapabilityProvider(Class<B> baseClass) {
        this(baseClass, false);
    }

    protected CapabilityProvider(Class<B> baseClass, boolean isLazy) {
        this.valid = true;
        this.isLazy = false;
        this.lazyParentSupplier = null;
        this.lazyData = null;
        this.initialized = false;
        this.baseClass = baseClass;
        this.isLazy = SUPPORTS_LAZY_CAPABILITIES && isLazy;
    }

    protected final void gatherCapabilities() {
        this.gatherCapabilities(() -> {
            return null;
        });
    }

    protected final void gatherCapabilities(@Nullable ICapabilityProvider parent) {
        this.gatherCapabilities(() -> {
            return parent;
        });
    }

    protected final void gatherCapabilities(@Nullable Supplier<ICapabilityProvider> parent) {
        if (this.isLazy && !this.initialized) {
            this.lazyParentSupplier = parent == null ? () -> {
                return null;
            } : parent;
        } else {
            this.doGatherCapabilities(parent == null ? null : (ICapabilityProvider)parent.get());
        }
    }

    private void doGatherCapabilities(@Nullable ICapabilityProvider parent) {
        this.capabilities = ForgeEventFactory.gatherCapabilities(this.baseClass, this.getProvider(), parent);
        this.initialized = true;
    }

    @NotNull B getProvider() {
        return this;
    }

    protected final @Nullable CapabilityDispatcher getCapabilities() {
        if (this.isLazy && !this.initialized) {
            this.doGatherCapabilities(this.lazyParentSupplier == null ? null : (ICapabilityProvider)this.lazyParentSupplier.get());
            if (this.lazyData != null) {
                this.deserializeCaps(this.lazyData);
            }
        }

        return this.capabilities;
    }

    public final boolean areCapsCompatible(CapabilityProvider<B> other) {
        return this.areCapsCompatible(other.getCapabilities());
    }

    public final boolean areCapsCompatible(@Nullable CapabilityDispatcher other) {
        CapabilityDispatcher disp = this.getCapabilities();
        if (disp == null) {
            return other == null ? true : other.areCompatible((CapabilityDispatcher)null);
        } else {
            return disp.areCompatible(other);
        }
    }

    protected final @Nullable CompoundTag serializeCaps() {
        if (this.isLazy && !this.initialized) {
            return this.lazyData;
        } else {
            CapabilityDispatcher disp = this.getCapabilities();
            return disp != null ? disp.serializeNBT() : null;
        }
    }

    protected final void deserializeCaps(CompoundTag tag) {
        if (this.isLazy && !this.initialized) {
            this.lazyData = tag;
        } else {
            CapabilityDispatcher disp = this.getCapabilities();
            if (disp != null) {
                disp.deserializeNBT(tag);
            }

        }
    }

    public void invalidateCaps() {
        this.valid = false;
        CapabilityDispatcher disp = this.getCapabilities();
        if (disp != null) {
            disp.invalidate();
        }

    }

    public void reviveCaps() {
        this.valid = true;
    }

    public <T> @NotNull LazyOptional<T> getCapability(@NotNull Capability<T> cap, @Nullable Direction side) {
        CapabilityDispatcher disp = this.getCapabilities();
        return this.valid && disp != null ? disp.getCapability(cap, side) : LazyOptional.empty();
    }

    public static class AsField<B extends ICapabilityProviderImpl<B>> extends CapabilityProvider<B> {
        private final B owner;

        public AsField(Class<B> baseClass, B owner) {
            super(baseClass);
            this.owner = owner;
        }

        public AsField(Class<B> baseClass, B owner, boolean isLazy) {
            super(baseClass, isLazy);
            this.owner = owner;
        }

        public void initInternal() {
            this.gatherCapabilities();
        }

        public @Nullable CompoundTag serializeInternal() {
            return this.serializeCaps();
        }

        public void deserializeInternal(CompoundTag tag) {
            this.deserializeCaps(tag);
        }

        @NotNull B getProvider() {
            return this.owner;
        }
    }
}



and here is LazyOptional.class

//
// Source code recreated from a .class file by IntelliJ IDEA
// (powered by FernFlower decompiler)
//

package net.minecraftforge.common.util;

import java.util.HashSet;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import javax.annotation.ParametersAreNonnullByDefault;
import net.minecraft.MethodsReturnNonnullByDefault;
import org.apache.commons.lang3.mutable.Mutable;
import org.apache.commons.lang3.mutable.MutableObject;
import org.apache.logging.log4j.Level;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

@ParametersAreNonnullByDefault
@MethodsReturnNonnullByDefault
public class LazyOptional<T> {
    private final NonNullSupplier<T> supplier;
    private final Object lock = new Object();
    private Mutable<T> resolved;
    private Set<NonNullConsumer<LazyOptional<T>>> listeners = new HashSet();
    private boolean isValid = true;
    private static final @NotNull LazyOptional<Void> EMPTY = new LazyOptional((NonNullSupplier)null);
    private static final Logger LOGGER = LogManager.getLogger();

    public static <T> LazyOptional<T> of(@Nullable NonNullSupplier<T> instanceSupplier) {
        return instanceSupplier == null ? empty() : new LazyOptional(instanceSupplier);
    }

    public static <T> LazyOptional<T> empty() {
        return EMPTY.cast();
    }

    public <X> LazyOptional<X> cast() {
        return this;
    }

    private LazyOptional(@Nullable NonNullSupplier<T> instanceSupplier) {
        this.supplier = instanceSupplier;
    }

    private @Nullable T getValue() {
        if (this.isValid && this.supplier != null) {
            if (this.resolved == null) {
                synchronized(this.lock) {
                    if (this.resolved == null) {
                        T temp = this.supplier.get();
                        if (temp == null) {
                            LOGGER.catching(Level.WARN, new NullPointerException("Supplier should not return null value"));
                        }

                        this.resolved = new MutableObject(temp);
                    }
                }
            }

            return this.resolved.getValue();
        } else {
            return null;
        }
    }

    private T getValueUnsafe() {
        T ret = this.getValue();
        if (ret == null) {
            throw new IllegalStateException("LazyOptional is empty or otherwise returned null from getValue() unexpectedly");
        } else {
            return ret;
        }
    }

    public boolean isPresent() {
        return this.supplier != null && this.isValid;
    }

    public void ifPresent(NonNullConsumer<? super T> consumer) {
        Objects.requireNonNull(consumer);
        T val = this.getValue();
        if (this.isValid && val != null) {
            consumer.accept(val);
        }

    }

    public <U> LazyOptional<U> lazyMap(NonNullFunction<? super T, ? extends U> mapper) {
        Objects.requireNonNull(mapper);
        return this.isPresent() ? of(() -> {
            return mapper.apply(this.getValueUnsafe());
        }) : empty();
    }

    public <U> Optional<U> map(NonNullFunction<? super T, ? extends U> mapper) {
        Objects.requireNonNull(mapper);
        return this.isPresent() ? Optional.of(mapper.apply(this.getValueUnsafe())) : Optional.empty();
    }

    public Optional<T> filter(NonNullPredicate<? super T> predicate) {
        Objects.requireNonNull(predicate);
        T value = this.getValue();
        return value != null && predicate.test(value) ? Optional.of(value) : Optional.empty();
    }

    public Optional<T> resolve() {
        return this.isPresent() ? Optional.of(this.getValueUnsafe()) : Optional.empty();
    }

    public T orElse(T other) {
        T val = this.getValue();
        return val != null ? val : other;
    }

    public T orElseGet(NonNullSupplier<? extends T> other) {
        T val = this.getValue();
        return val != null ? val : other.get();
    }

    public <X extends Throwable> T orElseThrow(NonNullSupplier<? extends X> exceptionSupplier) throws X {
        T val = this.getValue();
        if (val != null) {
            return val;
        } else {
            throw (Throwable)exceptionSupplier.get();
        }
    }

    public void addListener(NonNullConsumer<LazyOptional<T>> listener) {
        if (this.isPresent()) {
            this.listeners.add(listener);
        } else {
            listener.accept(this);
        }

    }

    public void invalidate() {
        if (this.isValid) {
            this.isValid = false;
            this.listeners.forEach((e) -> {
                e.accept(this);
            });
        }

    }
}


My understanding is that CAPABILITY_PROVIDER_BY_POSITION is caching the ICapabilityProvider, which is worse than caching the LazyOptional for the capability since we can attach a listener to the lazyoptional to remove the cache entry.
Please suggest the adjustments necessary to cache things properly in my mod so that we don't retain invalid entries.

For more context, here is ChestBlockEntity.class

//
// Source code recreated from a .class file by IntelliJ IDEA
// (powered by FernFlower decompiler)
//

package net.minecraft.world.level.block.entity;

import net.minecraft.core.BlockPos;
import net.minecraft.core.Direction;
import net.minecraft.core.NonNullList;
import net.minecraft.nbt.CompoundTag;
import net.minecraft.network.chat.Component;
import net.minecraft.sounds.SoundEvent;
import net.minecraft.sounds.SoundEvents;
import net.minecraft.sounds.SoundSource;
import net.minecraft.world.CompoundContainer;
import net.minecraft.world.Container;
import net.minecraft.world.ContainerHelper;
import net.minecraft.world.entity.player.Inventory;
import net.minecraft.world.entity.player.Player;
import net.minecraft.world.inventory.AbstractContainerMenu;
import net.minecraft.world.inventory.ChestMenu;
import net.minecraft.world.item.ItemStack;
import net.minecraft.world.level.BlockGetter;
import net.minecraft.world.level.Level;
import net.minecraft.world.level.block.Block;
import net.minecraft.world.level.block.ChestBlock;
import net.minecraft.world.level.block.state.BlockState;
import net.minecraft.world.level.block.state.properties.ChestType;
import net.minecraftforge.common.capabilities.Capability;
import net.minecraftforge.common.capabilities.ForgeCapabilities;
import net.minecraftforge.common.util.LazyOptional;
import net.minecraftforge.items.IItemHandlerModifiable;
import net.minecraftforge.items.wrapper.InvWrapper;

public class ChestBlockEntity extends RandomizableContainerBlockEntity implements LidBlockEntity {
    private static final int EVENT_SET_OPEN_COUNT = 1;
    private NonNullList<ItemStack> items;
    private final ContainerOpenersCounter openersCounter;
    private final ChestLidController chestLidController;
    private LazyOptional<IItemHandlerModifiable> chestHandler;

    protected ChestBlockEntity(BlockEntityType<?> pType, BlockPos pPos, BlockState pBlockState) {
        super(pType, pPos, pBlockState);
        this.items = NonNullList.withSize(27, ItemStack.EMPTY);
        this.openersCounter = new ContainerOpenersCounter() {
            protected void onOpen(Level p_155357_, BlockPos p_155358_, BlockState p_155359_) {
                ChestBlockEntity.playSound(p_155357_, p_155358_, p_155359_, SoundEvents.CHEST_OPEN);
            }

            protected void onClose(Level p_155367_, BlockPos p_155368_, BlockState p_155369_) {
                ChestBlockEntity.playSound(p_155367_, p_155368_, p_155369_, SoundEvents.CHEST_CLOSE);
            }

            protected void openerCountChanged(Level p_155361_, BlockPos p_155362_, BlockState p_155363_, int p_155364_, int p_155365_) {
                ChestBlockEntity.this.signalOpenCount(p_155361_, p_155362_, p_155363_, p_155364_, p_155365_);
            }

            protected boolean isOwnContainer(Player p_155355_) {
                if (!(p_155355_.containerMenu instanceof ChestMenu)) {
                    return false;
                } else {
                    Container container = ((ChestMenu)p_155355_.containerMenu).getContainer();
                    return container == ChestBlockEntity.this || container instanceof CompoundContainer && ((CompoundContainer)container).contains(ChestBlockEntity.this);
                }
            }
        };
        this.chestLidController = new ChestLidController();
    }

    public ChestBlockEntity(BlockPos pPos, BlockState pBlockState) {
        this(BlockEntityType.CHEST, pPos, pBlockState);
    }

    public int getContainerSize() {
        return 27;
    }

    protected Component getDefaultName() {
        return Component.translatable("container.chest");
    }

    public void load(CompoundTag pTag) {
        super.load(pTag);
        this.items = NonNullList.withSize(this.getContainerSize(), ItemStack.EMPTY);
        if (!this.tryLoadLootTable(pTag)) {
            ContainerHelper.loadAllItems(pTag, this.items);
        }

    }

    protected void saveAdditional(CompoundTag pTag) {
        super.saveAdditional(pTag);
        if (!this.trySaveLootTable(pTag)) {
            ContainerHelper.saveAllItems(pTag, this.items);
        }

    }

    public static void lidAnimateTick(Level pLevel, BlockPos pPos, BlockState pState, ChestBlockEntity pBlockEntity) {
        pBlockEntity.chestLidController.tickLid();
    }

    static void playSound(Level pLevel, BlockPos pPos, BlockState pState, SoundEvent pSound) {
        ChestType chesttype = (ChestType)pState.getValue(ChestBlock.TYPE);
        if (chesttype != ChestType.LEFT) {
            double d0 = (double)pPos.getX() + 0.5;
            double d1 = (double)pPos.getY() + 0.5;
            double d2 = (double)pPos.getZ() + 0.5;
            if (chesttype == ChestType.RIGHT) {
                Direction direction = ChestBlock.getConnectedDirection(pState);
                d0 += (double)direction.getStepX() * 0.5;
                d2 += (double)direction.getStepZ() * 0.5;
            }

            pLevel.playSound((Player)null, d0, d1, d2, pSound, SoundSource.BLOCKS, 0.5F, pLevel.random.nextFloat() * 0.1F + 0.9F);
        }

    }

    public boolean triggerEvent(int pId, int pType) {
        if (pId == 1) {
            this.chestLidController.shouldBeOpen(pType > 0);
            return true;
        } else {
            return super.triggerEvent(pId, pType);
        }
    }

    public void startOpen(Player pPlayer) {
        if (!this.remove && !pPlayer.isSpectator()) {
            this.openersCounter.incrementOpeners(pPlayer, this.getLevel(), this.getBlockPos(), this.getBlockState());
        }

    }

    public void stopOpen(Player pPlayer) {
        if (!this.remove && !pPlayer.isSpectator()) {
            this.openersCounter.decrementOpeners(pPlayer, this.getLevel(), this.getBlockPos(), this.getBlockState());
        }

    }

    protected NonNullList<ItemStack> getItems() {
        return this.items;
    }

    protected void setItems(NonNullList<ItemStack> pItems) {
        this.items = pItems;
    }

    public float getOpenNess(float pPartialTicks) {
        return this.chestLidController.getOpenness(pPartialTicks);
    }

    public static int getOpenCount(BlockGetter pLevel, BlockPos pPos) {
        BlockState blockstate = pLevel.getBlockState(pPos);
        if (blockstate.hasBlockEntity()) {
            BlockEntity blockentity = pLevel.getBlockEntity(pPos);
            if (blockentity instanceof ChestBlockEntity) {
                return ((ChestBlockEntity)blockentity).openersCounter.getOpenerCount();
            }
        }

        return 0;
    }

    public static void swapContents(ChestBlockEntity pChest, ChestBlockEntity pOtherChest) {
        NonNullList<ItemStack> nonnulllist = pChest.getItems();
        pChest.setItems(pOtherChest.getItems());
        pOtherChest.setItems(nonnulllist);
    }

    protected AbstractContainerMenu createMenu(int pId, Inventory pPlayer) {
        return ChestMenu.threeRows(pId, pPlayer, this);
    }

    public void setBlockState(BlockState p_155251_) {
        super.setBlockState(p_155251_);
        if (this.chestHandler != null) {
            LazyOptional<?> oldHandler = this.chestHandler;
            this.chestHandler = null;
            oldHandler.invalidate();
        }

    }

    public <T> LazyOptional<T> getCapability(Capability<T> cap, Direction side) {
        if (!this.remove && cap == ForgeCapabilities.ITEM_HANDLER) {
            if (this.chestHandler == null) {
                this.chestHandler = LazyOptional.of(this::createHandler);
            }

            return this.chestHandler.cast();
        } else {
            return super.getCapability(cap, side);
        }
    }

    private IItemHandlerModifiable createHandler() {
        BlockState state = this.getBlockState();
        if (!(state.getBlock() instanceof ChestBlock)) {
            return new InvWrapper(this);
        } else {
            Container inv = ChestBlock.getContainer((ChestBlock)state.getBlock(), state, this.getLevel(), this.getBlockPos(), true);
            return new InvWrapper((Container)(inv == null ? this : inv));
        }
    }

    public void invalidateCaps() {
        super.invalidateCaps();
        if (this.chestHandler != null) {
            this.chestHandler.invalidate();
            this.chestHandler = null;
        }

    }

    public void recheckOpen() {
        if (!this.remove) {
            this.openersCounter.recheckOpeners(this.getLevel(), this.getBlockPos(), this.getBlockState());
        }

    }

    protected void signalOpenCount(Level pLevel, BlockPos pPos, BlockState pState, int pEventId, int pEventParam) {
        Block block = pState.getBlock();
        pLevel.blockEvent(pPos, block, 1, pEventParam);
    }
}


and BaseContainerBlockEntity.class

//
// Source code recreated from a .class file by IntelliJ IDEA
// (powered by FernFlower decompiler)
//

package net.minecraft.world.level.block.entity;

import javax.annotation.Nullable;
import net.minecraft.core.BlockPos;
import net.minecraft.core.Direction;
import net.minecraft.nbt.CompoundTag;
import net.minecraft.network.chat.Component;
import net.minecraft.network.chat.Component.Serializer;
import net.minecraft.sounds.SoundEvents;
import net.minecraft.sounds.SoundSource;
import net.minecraft.world.Container;
import net.minecraft.world.LockCode;
import net.minecraft.world.MenuProvider;
import net.minecraft.world.Nameable;
import net.minecraft.world.entity.player.Inventory;
import net.minecraft.world.entity.player.Player;
import net.minecraft.world.inventory.AbstractContainerMenu;
import net.minecraft.world.level.block.state.BlockState;
import net.minecraftforge.common.capabilities.Capability;
import net.minecraftforge.common.capabilities.ForgeCapabilities;
import net.minecraftforge.common.util.LazyOptional;
import net.minecraftforge.items.IItemHandler;
import net.minecraftforge.items.wrapper.InvWrapper;

public abstract class BaseContainerBlockEntity extends BlockEntity implements Container, MenuProvider, Nameable {
    private LockCode lockKey;
    private Component name;
    private LazyOptional<?> itemHandler;

    protected BaseContainerBlockEntity(BlockEntityType<?> pType, BlockPos pPos, BlockState pBlockState) {
        super(pType, pPos, pBlockState);
        this.lockKey = LockCode.NO_LOCK;
        this.itemHandler = LazyOptional.of(() -> {
            return this.createUnSidedHandler();
        });
    }

    public void load(CompoundTag pTag) {
        super.load(pTag);
        this.lockKey = LockCode.fromTag(pTag);
        if (pTag.contains("CustomName", 8)) {
            this.name = Serializer.fromJson(pTag.getString("CustomName"));
        }

    }

    protected void saveAdditional(CompoundTag pTag) {
        super.saveAdditional(pTag);
        this.lockKey.addToTag(pTag);
        if (this.name != null) {
            pTag.putString("CustomName", Serializer.toJson(this.name));
        }

    }

    public void setCustomName(Component pName) {
        this.name = pName;
    }

    public Component getName() {
        return this.name != null ? this.name : this.getDefaultName();
    }

    public Component getDisplayName() {
        return this.getName();
    }

    @Nullable
    public Component getCustomName() {
        return this.name;
    }

    protected abstract Component getDefaultName();

    public boolean canOpen(Player pPlayer) {
        return canUnlock(pPlayer, this.lockKey, this.getDisplayName());
    }

    public static boolean canUnlock(Player pPlayer, LockCode pCode, Component pDisplayName) {
        if (!pPlayer.isSpectator() && !pCode.unlocksWith(pPlayer.getMainHandItem())) {
            pPlayer.displayClientMessage(Component.translatable("container.isLocked", new Object[]{pDisplayName}), true);
            pPlayer.playNotifySound(SoundEvents.CHEST_LOCKED, SoundSource.BLOCKS, 1.0F, 1.0F);
            return false;
        } else {
            return true;
        }
    }

    @Nullable
    public AbstractContainerMenu createMenu(int pContainerId, Inventory pPlayerInventory, Player pPlayer) {
        return this.canOpen(pPlayer) ? this.createMenu(pContainerId, pPlayerInventory) : null;
    }

    protected abstract AbstractContainerMenu createMenu(int var1, Inventory var2);

    protected IItemHandler createUnSidedHandler() {
        return new InvWrapper(this);
    }

    public <T> LazyOptional<T> getCapability(Capability<T> cap, @org.jetbrains.annotations.Nullable Direction side) {
        return !this.remove && cap == ForgeCapabilities.ITEM_HANDLER ? this.itemHandler.cast() : super.getCapability(cap, side);
    }

    public void invalidateCaps() {
        super.invalidateCaps();
        this.itemHandler.invalidate();
    }

    public void reviveCaps() {
        super.reviveCaps();
        this.itemHandler = LazyOptional.of(() -> {
            return this.createUnSidedHandler();
        });
    }
}

